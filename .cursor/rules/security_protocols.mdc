---
description: 
globs: 
alwaysApply: true
---
# Security Protocols - podAI Core

podAI Protocol implements defense-in-depth security with multiple layers of protection including blockchain-native security, input validation, rate limiting, secure key management, and comprehensive audit logging.

## Authentication & Authorization

### 1. Blockchain Authentication

All transactions require valid cryptographic signatures:

```typescript
// Signature verification pattern
export async function verifySignature(
  message: Uint8Array,
  signature: Uint8Array,
  publicKey: PublicKey
): Promise<boolean> {
  try {
    return nacl.sign.detached.verify(message, signature, publicKey.toBytes());
  } catch (error) {
    console.error('Signature verification failed:', error);
    return false;
  }
}
```

### 2. Capability-Based Access Control

```rust
// Agent capabilities bitmask
pub const AGENT_CAPABILITIES: u64 = {
    pub const NONE: u64 = 0;
    pub const COMMUNICATION: u64 = 1 << 0;
    pub const TRADING: u64 = 1 << 1;
    pub const ANALYSIS: u64 = 1 << 2;
    pub const MODERATION: u64 = 1 << 3;
    pub const ADMIN: u64 = 1 << 4;
};

// Permission validation
pub fn has_capability(agent: &AgentAccount, required: u64) -> bool {
    (agent.capabilities & required) == required
}
```

### 3. Session Management

```typescript
export class SessionManager {
  private sessions = new Map<string, SessionData>();
  private sessionTimeout = 24 * 60 * 60 * 1000; // 24 hours
  
  createSession(agentId: string): string {
    const sessionId = crypto.randomUUID();
    const session = {
      agentId,
      createdAt: Date.now(),
      lastActivity: Date.now(),
      isActive: true
    };
    
    this.sessions.set(sessionId, session);
    return sessionId;
  }
  
  validateSession(sessionId: string): boolean {
    const session = this.sessions.get(sessionId);
    if (!session || !session.isActive) return false;
    
    const isExpired = Date.now() - session.lastActivity > this.sessionTimeout;
    if (isExpired) {
      this.sessions.delete(sessionId);
      return false;
    }
    
    session.lastActivity = Date.now();
    return true;
  }
}
```

## Input Validation & Sanitization

### 1. Comprehensive Input Validation

```typescript
// Input validation schema
export const AgentRegistrationSchema = z.object({
  capabilities: z.number().min(0).max(2**32 - 1),
  metadataUri: z.string().url().max(200),
  description: z.string().max(500).optional()
});

// Validation function
export function validateAgentRegistration(input: any): AgentRegistrationOptions {
  const result = AgentRegistrationSchema.safeParse(input);
  if (!result.success) {
    throw new ValidationError(`Invalid input: ${result.error.message}`);
  }
  return result.data;
}
```

### 2. Content Sanitization

```typescript
export function sanitizeContent(content: string): string {
  // Remove potentially dangerous characters
  const sanitized = content
    .replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '')
    .replace(/javascript:/gi, '')
    .replace(/data:/gi, '')
    .replace(/vbscript:/gi, '')
    .trim();
  
  // Validate length
  if (sanitized.length > MAX_CONTENT_LENGTH) {
    throw new ValidationError('Content too long');
  }
  
  return sanitized;
}
```

### 3. SQL Injection Prevention

```typescript
// Always use parameterized queries
export async function getAgentByAddress(address: string): Promise<Agent | null> {
  const query = `
    SELECT * FROM agents 
    WHERE address = $1 AND is_active = true
  `;
  
  const result = await db.query(query, [address]);
  return result.rows[0] || null;
}
```

## Rate Limiting & DoS Protection

### 1. Multi-Level Rate Limiting

```typescript
export class RateLimiter {
  private requests = new Map<string, RequestWindow>();
  
  // Per-user rate limiting
  async checkUserRateLimit(userId: string): Promise<boolean> {
    const window = this.getOrCreateWindow(userId);
    const now = Date.now();
    
    // Clean old requests
    window.requests = window.requests.filter(
      time => now - time < window.windowMs
    );
    
    if (window.requests.length >= window.maxRequests) {
      return false;
    }
    
    window.requests.push(now);
    return true;
  }
  
  // Global rate limiting
  async checkGlobalRateLimit(): Promise<boolean> {
    const globalWindow = this.getOrCreateWindow('global');
    // Similar implementation with higher limits
  }
}
```

### 2. Blockchain-Level Rate Limiting

```rust
// Program-level rate limiting
pub fn validate_rate_limit(
    agent: &AgentAccount,
    current_time: i64
) -> Result<()> {
    const TIME_WINDOW: i64 = 60; // 1 minute
    const MAX_MESSAGES: u16 = 60;
    
    let messages_in_window = 0;
    
    // Check recent message count
    if current_time - agent.last_message_time < TIME_WINDOW {
        messages_in_window = agent.messages_in_window;
    }
    
    require!(
        messages_in_window < MAX_MESSAGES,
        ErrorCode::RateLimitExceeded
    );
    
    Ok(())
}
```

### 3. DDoS Protection

```typescript
export class DDoSProtection {
  private suspiciousIPs = new Set<string>();
  private requestCounts = new Map<string, number>();
  
  async checkRequest(ip: string, path: string): Promise<boolean> {
    // Block known malicious IPs
    if (this.suspiciousIPs.has(ip)) {
      return false;
    }
    
    // Track request patterns
    const key = `${ip}:${path}`;
    const count = this.requestCounts.get(key) || 0;
    
    if (count > 100) { // 100 requests per minute per IP/path
      this.suspiciousIPs.add(ip);
      return false;
    }
    
    this.requestCounts.set(key, count + 1);
    return true;
  }
}
```

## Cryptographic Security

### 1. Secure Key Management

```typescript
export class SecureKeyManager {
  private keys = new Map<string, CryptoKey>();
  
  async generateKey(): Promise<CryptoKey> {
    const key = await crypto.subtle.generateKey(
      {
        name: 'AES-GCM',
        length: 256
      },
      false, // Not extractable
      ['encrypt', 'decrypt']
    );
    
    return key;
  }
  
  async encryptData(data: Uint8Array, key: CryptoKey): Promise<EncryptedData> {
    const iv = crypto.getRandomValues(new Uint8Array(12));
    
    const encrypted = await crypto.subtle.encrypt(
      {
        name: 'AES-GCM',
        iv: iv
      },
      key,
      data
    );
    
    return {
      ciphertext: new Uint8Array(encrypted),
      iv: iv,
      tag: new Uint8Array(encrypted.slice(-16))
    };
  }
}
```

### 2. Message Integrity

```rust
// Secure hash computation
pub fn compute_message_hash(content: &[u8]) -> Result<[u8; 32]> {
    use sha2::{Sha256, Digest};
    
    let mut hasher = Sha256::new();
    hasher.update(content);
    let result = hasher.finalize();
    
    let mut hash = [0u8; 32];
    hash.copy_from_slice(&result);
    Ok(hash)
}

// Verify message integrity
pub fn verify_message_integrity(
    content: &[u8],
    expected_hash: &[u8; 32]
) -> Result<()> {
    let computed_hash = compute_message_hash(content)?;
    
    require!(
        computed_hash == *expected_hash,
        ErrorCode::InvalidMessageHash
    );
    
    Ok(())
}
```

### 3. Secure Random Generation

```typescript
export class SecureRandom {
  static generateNonce(): Uint8Array {
    return crypto.getRandomValues(new Uint8Array(32));
  }
  
  static generateSessionId(): string {
    const array = crypto.getRandomValues(new Uint8Array(32));
    return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
  }
  
  static generateSalt(): Uint8Array {
    return crypto.getRandomValues(new Uint8Array(16));
  }
}
```

### Cryptographic Security

- **Hashing**: Use Blake3 for all hash operations
- **Secure Memory**: Use SecureBuffer for sensitive operations
- **Constant Time**: Implement constant-time comparison functions
- **Randomness**: Use secure randomness sources for nonces and challenges
- **Key Management**: Proper handling of cryptographic keys and secrets

### State Protection

- **Account Rent**: Ensure all accounts are rent-exempt
- **State Validation**: Validate account state transitions
- **Atomic Operations**: Use atomic state changes to prevent inconsistency
- **Rollback Safety**: Ensure failed operations don't corrupt state
- **Concurrent Access**: Handle concurrent access safely

## SDK Security

### Client-Side Validation

- **Input Sanitization**: Sanitize all user inputs before sending to program
- **Transaction Validation**: Validate transaction structure before signing
- **Account Verification**: Verify account addresses and ownership
- **Amount Validation**: Check amounts and balances before operations
- **Permission Checks**: Verify user permissions locally when possible

### Network Security

- **RPC Security**: Use secure RPC endpoints with TLS
- **Connection Validation**: Verify RPC endpoint authenticity
- **Request Signing**: Sign all requests with appropriate keys
- **Replay Protection**: Use nonces to prevent replay attacks
- **Error Handling**: Secure error handling without information leakage

### Key Management

- **Private Key Security**: Never log or expose private keys
- **Secure Storage**: Use secure storage for sensitive data
- **Key Rotation**: Support key rotation and recovery mechanisms
- **Multi-Signature**: Support multi-signature transactions where appropriate
- **Hardware Wallets**: Integration with hardware wallet security

## Operational Security

### Development Security

- **Dependency Scanning**: Regular security audits of dependencies
- **Code Review**: Mandatory security-focused code reviews
- **Static Analysis**: Use static analysis tools for vulnerability detection
- **Penetration Testing**: Regular security testing by external auditors
- **Vulnerability Management**: Process for reporting and fixing vulnerabilities

### Deployment Security

- **Secure Build**: Reproducible builds with verified dependencies
- **Environment Isolation**: Separate development, testing, and production
- **Access Control**: Limit access to deployment infrastructure
- **Monitoring**: Comprehensive security monitoring and alerting
- **Incident Response**: Clear incident response procedures

### Audit Requirements

- **Code Audits**: External security audits before major releases
- **Documentation**: Comprehensive security documentation
- **Test Coverage**: Security-focused test coverage requirements
- **Compliance**: Regular compliance checks and certifications
- **Reporting**: Regular security status reporting

## Threat Model

### On-Chain Threats

- **Reentrancy**: Protection against reentrancy attacks
- **Integer Overflow**: Prevention of arithmetic overflow/underflow
- **Denial of Service**: Protection against resource exhaustion
- **Front-Running**: Mitigation of MEV and front-running attacks
- **Governance Attacks**: Protection against governance manipulation

### Off-Chain Threats

- **Client Vulnerabilities**: Protection against client-side attacks
- **Network Attacks**: Protection against network-level attacks
- **Supply Chain**: Protection against supply chain attacks
- **Social Engineering**: User education and protection measures
- **Key Compromise**: Recovery mechanisms for compromised keys

## Incident Response

### Detection

- **Monitoring**: Comprehensive security monitoring
- **Alerting**: Real-time security alerts and notifications
- **Logging**: Detailed security logging for forensic analysis
- **Automated Detection**: Automated threat detection systems
- **Community Reporting**: Bug bounty and community reporting programs

### Response

- **Incident Team**: Dedicated security incident response team
- **Communication Plan**: Clear communication during security incidents
- **Containment**: Procedures for containing security breaches
- **Recovery**: Recovery procedures and business continuity
- **Post-Incident**: Post-incident analysis and improvement processes

## Compliance

### Regulatory Compliance

- **Data Protection**: Compliance with data protection regulations
- **Financial Regulations**: Compliance with applicable financial regulations
- **Reporting Requirements**: Meet regulatory reporting requirements
- **Audit Trails**: Maintain comprehensive audit trails
- **Documentation**: Maintain compliance documentation

### Industry Standards

- **Security Frameworks**: Align with industry security frameworks
- **Best Practices**: Follow industry security best practices
- **Certifications**: Maintain relevant security certifications
- **Peer Review**: Regular peer review and benchmarking
- **Continuous Improvement**: Continuous security improvement processes.
