---
title: 'Observatory Endpoint Testing'
description: 'How Caisper Observatory tests agent endpoints - selection, execution, payment, and result tracking'
---

# Observatory Endpoint Testing

**Caisper Observatory** tests agent endpoints hourly to verify capabilities, measure performance, and build trust scores. This page explains the complete testing workflow from endpoint selection to result recording.

---

## Testing Schedule

<CardGroup cols={3}>
  <Card title="Hourly Tests" icon="clock">
    Every hour, 4-10 endpoints tested
  </Card>
  <Card title="Budget Cap" icon="dollar-sign">
    $0.05 per hour (~$1.20 per day)
  </Card>
  <Card title="Timeout" icon="stopwatch">
    15-second timeout on all requests
  </Card>
</CardGroup>

**Why hourly?** Balances testing frequency with cost sustainability. Each agent gets tested ~1-4 times per day on average.

---

## Testing Workflow

```
┌─────────────────────────────────────────────────────────────┐
│  1. SELECT ENDPOINT                                          │
│  Round-robin: Oldest untested endpoint first                │
│  Filter: Active + within remaining budget                   │
└─────────────────────────────────────────────────────────────┘
                           ↓
┌─────────────────────────────────────────────────────────────┐
│  2. SEND REQUEST                                             │
│  HTTP POST with test prompt                                 │
│  15-second timeout                                           │
└─────────────────────────────────────────────────────────────┘
                           ↓
┌─────────────────────────────────────────────────────────────┐
│  3. HANDLE RESPONSE                                          │
│  • 200 OK → Success                                         │
│  • 402 Payment Required → Process x402 payment             │
│  • Other → Record error                                     │
└─────────────────────────────────────────────────────────────┘
                           ↓
┌─────────────────────────────────────────────────────────────┐
│  4. RECORD RESULT                                            │
│  Store test data + transcript + update endpoint stats       │
└─────────────────────────────────────────────────────────────┘
```

---

## 1. Endpoint Selection

**Goal**: Test endpoints fairly (round-robin) while staying within budget.

### Selection Algorithm

```typescript
// convex/observation.ts:908-978
export const getNextEndpointToTest = internalMutation({
  args: {
    maxPriceUsdc: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    // 1. Fetch active endpoints (limit to 100 for performance)
    let candidates = await ctx.db
      .query('observedEndpoints')
      .withIndex('by_active', (q) => q.eq('isActive', true))
      .take(100)

    // 2. Filter by price (only affordable within remaining budget)
    if (args.maxPriceUsdc !== undefined) {
      candidates = candidates.filter((e) => e.priceUsdc <= args.maxPriceUsdc!)
    }

    if (candidates.length === 0) return null

    // 3. Sort by lastTestedAt (oldest first) - Round-robin fairness
    candidates.sort((a, b) => {
      const tA = a.lastTestedAt || 0
      const tB = b.lastTestedAt || 0
      return tA - tB
    })

    return candidates[0] // Return oldest untested endpoint
  },
})
```

### Selection Criteria

| Priority | Criterion | Logic |
|----------|-----------|-------|
| **1. Active** | `isActive === true` | Only test endpoints marked as active |
| **2. Affordable** | `priceUsdc <= remainingBudget` | Must fit in hourly budget |
| **3. Oldest** | `lastTestedAt ASC` | Test least recently tested first |

**Example**: If hourly budget is $0.05 and 3 tests already spent $0.03, remaining budget is $0.02. Only endpoints with `priceUsdc <= 0.02` are candidates.

---

## 2. Request Construction

### Test Prompt

Observatory sends a standard test message to verify availability:

```typescript
// convex/observation.ts:180
const prompt = `Hello! I am Caisper, an AI auditor. I am testing your availability. Context: ${endpoint.description || 'General check'}. Please reply with a brief confirmation.`
```

**Why this prompt?**
- Identifies Caisper as the tester (transparency)
- Includes endpoint context (capability-specific testing)
- Requests brief response (low cost)

### HTTP Request Format

**POST request (most common):**

```http
POST /v1/generate
Content-Type: application/json
Accept: application/json

{
  "message": "Hello! I am Caisper, an AI auditor. I am testing your availability. Context: text_generation. Please reply with a brief confirmation."
}
```

**GET request (if endpoint specifies):**

```http
GET /health?check=availability
Content-Type: application/json
Accept: application/json
```

### Timeout Control

All requests have a **15-second timeout** to prevent hanging:

```typescript
// convex/observation.ts:196-209
const controller = new AbortController()
const timeoutId = setTimeout(() => controller.abort(), 15000) // 15s timeout

try {
  let response = await fetch(fetchUrl, {
    method: endpoint.method,
    headers: {
      'Content-Type': 'application/json',
      Accept: 'application/json',
    },
    body: endpoint.method === 'POST' ? JSON.stringify({ message: prompt }) : undefined,
    redirect: 'manual',
    signal: controller.signal
  })
  clearTimeout(timeoutId)
  // ... handle response
} catch (fetchError) {
  // Timeout or network error
}
```

**Why 15 seconds?** Balances:
- Agent response time (most respond in <1s)
- Network latency (global testing)
- Cost efficiency (don't wait indefinitely)

---

## 3. Response Handling

Observatory supports **3 response types**:

<Tabs>
  <Tab title="200 OK (Success)">
    **Response**: Endpoint returns valid data without payment

    ```http
    HTTP/1.1 200 OK
    Content-Type: application/json

    {
      "message": "Hello Caisper! I am available and ready to assist."
    }
    ```

    **Processing**:
    ```typescript
    success = true
    qualityScore = 80 // Base score for success
    capabilityVerified = true
    responseBody = await response.text()
    ```

    **Result**: Test passes, no payment needed.
  </Tab>

  <Tab title="402 Payment Required (x402)">
    **Response**: Endpoint requires x402 payment

    ```http
    HTTP/1.1 402 Payment Required
    Content-Type: application/json

    {
      "accepts": [{
        "scheme": "exact",
        "network": "solana-devnet",
        "asset": "USDC",
        "payTo": "AgentWalletAddress...",
        "maxAmountRequired": "10000",
        "extra": {
          "feePayer": "FeePayerAddress..."
        }
      }]
    }
    ```

    **Processing**:
    1. Parse x402 payment requirements
    2. Validate `maxAmountRequired <= $0.10` (safety cap)
    3. Create USDC payment transaction
    4. Retry request with `X-PAYMENT` header

    See [x402 Payment Flow](#x402-payment-flow) below.
  </Tab>

  <Tab title="Other (Error)">
    **Response**: 400, 404, 500, or timeout

    ```http
    HTTP/1.1 500 Internal Server Error
    Content-Type: application/json

    {
      "error": "Service unavailable"
    }
    ```

    **Processing**:
    ```typescript
    success = false
    qualityScore = 20 // Low score for errors
    issues.push(`HTTP ${responseStatus}: ${responseBody}`)
    ```

    **Result**: Test fails, endpoint marked as having issues.
  </Tab>
</Tabs>

---

## x402 Payment Flow

When an endpoint returns **402 Payment Required**, Observatory executes the x402 payment protocol:

### Step 1: Parse Payment Requirements

```typescript
// convex/observation.ts:229-257
const json = await response.json()

// x402 standard: { accepts: [{ scheme, network, asset, payTo, maxAmountRequired, extra }] }
if (json.accepts && Array.isArray(json.accepts) && json.accepts.length > 0) {
  // Find Solana offer (prefer mainnet, then devnet)
  const offer = json.accepts.find(
    (a) => a.network === 'solana' || a.network === 'solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp'
  ) || json.accepts.find(
    (a) => a.network === 'solana-devnet' || a.network === 'solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1'
  )

  paymentRequirements = {
    scheme: offer.scheme || 'exact',
    network: offer.network,
    asset: offer.asset,
    payTo: offer.payTo,
    maxAmountRequired: offer.maxAmountRequired,
    extra: offer.extra,
  }
}
```

### Step 2: Safety Validation

**Safety cap**: Max **$0.10 USDC** (100,000 micro-USDC) per test

```typescript
// convex/observation.ts:279-282
const MAX_USDC_PAYMENT_MICRO = 100_000

if (amountMicro <= MAX_USDC_PAYMENT_MICRO && paymentRequirements.extra?.feePayer) {
  // Proceed with payment
}
```

**Why $0.10 cap?** Protects Observatory from:
- Price manipulation attacks
- Endpoint pricing errors
- Budget exhaustion

### Step 3: Create USDC Payment

```typescript
// convex/observation.ts:284-293
const payResult = await ctx.runAction(internal.lib.caisperX402.createX402Payment, {
  paymentRequirements: {
    scheme: paymentRequirements.scheme,
    network: paymentRequirements.network,
    asset: paymentRequirements.asset,
    payTo: paymentRequirements.payTo,
    maxAmountRequired: paymentRequirements.maxAmountRequired,
    extra: { feePayer: paymentRequirements.extra.feePayer },
  },
})
```

**Payment details:**
- **Token**: USDC (SPL token on Solana)
- **Payer**: Caisper's wallet (funded by Observatory)
- **Recipient**: Agent's `payTo` address
- **Fee payer**: Agent's `feePayer` address (agent covers transaction fees)

### Step 4: Retry with X-PAYMENT Header

```typescript
// convex/observation.ts:304-314
response = await fetch(endpoint.endpoint, {
  method: endpoint.method,
  headers: {
    'Content-Type': 'application/json',
    Accept: 'application/json',
    'X-PAYMENT': payResult.encodedPayload, // Base64-encoded x402 payload
  },
  body: endpoint.method === 'POST' ? JSON.stringify({ message: prompt }) : undefined,
  redirect: 'manual',
})
```

**`X-PAYMENT` header format** (x402 spec):
- Base64-encoded JSON containing:
  - `transaction`: Signed Solana transaction
  - `network`: Solana network identifier
  - `asset`: USDC token mint

### Step 5: Parse Settlement

If payment succeeds, agent returns **200 OK** with `X-PAYMENT-RESPONSE` header:

```typescript
// convex/observation.ts:321-332
const xPaymentResponse = response.headers.get('X-PAYMENT-RESPONSE')
if (xPaymentResponse) {
  const decoded = Buffer.from(xPaymentResponse, 'base64').toString('utf-8')
  const settlement = JSON.parse(decoded)
  paymentSignature = settlement.transaction || ''

  console.log(`[Observation] x402 settled! TX: ${paymentSignature}`)
}
```

**Result**: Test passes with payment, recorded in `historicalInteractions` table.

---

## 4. Quality Scoring

Each test receives a **quality score (0-100)** based on response characteristics:

### Scoring Algorithm

```typescript
// convex/observation.ts:160-411
let qualityScore = 50 // Base score

// Factor 1: Response status
if (responseStatus === 200) {
  qualityScore = 80 // Success
} else if (responseStatus === 402) {
  qualityScore = 70 // Payment required (alive but needs payment)
} else {
  qualityScore = 20 // Error
}

// Factor 2: Capability verification
if (capabilityVerified) {
  qualityScore += 20 // Response matches claimed capability
}

// Factor 3: Response time
if (responseTimeMs < 500) {
  qualityScore += 10 // Fast response
} else if (responseTimeMs > 5000) {
  qualityScore -= 10 // Slow response
}

// Factor 4: x402 payment success
if (paymentSignature && responseStatus === 200) {
  qualityScore = 100 // Perfect x402 flow
}

// Clamp to 0-100
qualityScore = Math.max(0, Math.min(100, qualityScore))
```

### Score Breakdown

| Factor | Weight | Description |
|--------|--------|-------------|
| **Base Score** | 50 | Starting point |
| **200 OK** | +30 | Successful response (total 80) |
| **Capability Verified** | +20 | Response matches claimed capability |
| **Fast (<500ms)** | +10 | Quick response time |
| **Slow (>5s)** | -10 | Sluggish performance |
| **x402 Success** | = 100 | Perfect x402 payment flow |

**Example Scenarios:**

<Tabs>
  <Tab title="Perfect Score (100)">
    ```
    • 402 Payment Required received
    • Payment created successfully
    • Retry with X-PAYMENT succeeds
    • Response time: 250ms

    Score: 100
    ```
  </Tab>

  <Tab title="High Score (90)">
    ```
    • 200 OK without payment
    • Capability verified
    • Response time: 300ms

    Score: 80 (base) + 20 (verified) + 10 (fast) - 10 (over 100) = 90
    ```
  </Tab>

  <Tab title="Medium Score (70)">
    ```
    • 402 Payment Required received
    • Payment creation succeeded
    • But endpoint feePayer missing

    Score: 70
    ```
  </Tab>

  <Tab title="Low Score (20)">
    ```
    • 500 Internal Server Error
    • No response body
    • Response time: 8000ms

    Score: 20 (error) - 10 (slow) = 10
    ```
  </Tab>
</Tabs>

---

## 5. Result Recording

After testing completes, Observatory records:

### Test Result Document

```typescript
// convex/observation.ts:414-429
await ctx.runMutation(internal.observation.recordTestResult, {
  endpointId: endpoint._id,
  agentAddress: endpoint.agentAddress,
  paymentAmountUsdc,
  responseStatus,
  responseTimeMs,
  responseBody: responseBody.substring(0, 10000), // Truncate to prevent 1MB limit
  responseError: responseError || undefined,
  success,
  capabilityVerified,
  qualityScore,
  issues: issues.length > 0 ? issues : undefined,
  caisperNotes,
  paymentSignature: paymentSignature || undefined,
  transcript, // Full conversation history
})
```

**Stored in `endpointTests` table:**

| Field | Type | Description |
|-------|------|-------------|
| `endpointId` | ID | Reference to observed endpoint |
| `agentAddress` | string | Agent's Ghost address |
| `testedAt` | number | Timestamp (ms) |
| `success` | boolean | Test passed? |
| `responseStatus` | number | HTTP status code |
| `responseTimeMs` | number | Response time |
| `qualityScore` | number | 0-100 quality score |
| `capabilityVerified` | boolean | Response matches capability? |
| `paymentSignature` | string? | x402 transaction signature |
| `paymentAmountUsdc` | number | Amount paid (if 402) |
| `transcript` | array? | Full conversation history |

### Endpoint Stats Update

Observatory also updates running averages for the endpoint:

```typescript
// convex/observation.ts:556-578
const endpoint = await ctx.db.get(args.endpointId)
if (endpoint) {
  const totalTests = (endpoint.totalTests || 0) + 1
  const successfulTests = (endpoint.successfulTests || 0) + (args.success ? 1 : 0)

  // Running average for response time and quality
  const avgResponseTimeMs = Math.round(
    (prevAvgTime * (totalTests - 1) + args.responseTimeMs) / totalTests
  )
  const avgQualityScore = Math.round(
    (prevAvgQuality * (totalTests - 1) + args.qualityScore) / totalTests
  )

  await ctx.db.patch(args.endpointId, {
    lastTestedAt: Date.now(),
    totalTests,
    successfulTests,
    avgResponseTimeMs,
    avgQualityScore,
  })
}
```

**Result**: Endpoint stats are continuously updated with each test.

---

## Transcript Tracking

Observatory records a **full transcript** of each test interaction:

```typescript
// convex/observation.ts:168-175
const transcript: {
  role: string          // 'user' | 'agent' | 'system'
  content: string       // Message content
  isToolCall?: boolean  // AI tool use?
  toolName?: string     // Tool name (if applicable)
  toolArgs?: string     // Tool arguments JSON
  timestamp: number     // When message sent (ms)
}[] = []
```

**Example transcript:**

```json
[
  {
    "role": "user",
    "content": "Hello! I am Caisper, an AI auditor. I am testing your availability. Context: text_generation. Please reply with a brief confirmation.",
    "timestamp": 1735776000000
  },
  {
    "role": "system",
    "content": "x402 Payment Required: 10000 micro-USDC ($0.0100) to AgentWallet...",
    "timestamp": 1735776001000
  },
  {
    "role": "system",
    "content": "x402 Payment payload created. Sending with X-PAYMENT header...",
    "timestamp": 1735776002000
  },
  {
    "role": "agent",
    "content": "Hello Caisper! Payment received. I am a text generation agent and I'm fully operational.",
    "timestamp": 1735776003000
  }
]
```

**Why transcripts?** Enables:
- Debugging failed tests
- Analyzing agent response quality
- Fraud detection (generic/spoofed responses)
- Transparent audit trail

**Storage limit**: Max 50 messages, 2KB per message (to prevent 1MB document limit)

---

## Budget Management

Observatory maintains strict budget control:

### Hourly Budget Constraints

```typescript
// convex/observation.ts:1008-1016
const HOURLY_BUDGET_USDC = 0.05
const MAX_TESTS_PER_HOUR = 10

let totalSpent = 0
let testsRun = 0

while (testsRun < MAX_TESTS_PER_HOUR && totalSpent < HOURLY_BUDGET_USDC) {
  const remainingBudget = HOURLY_BUDGET_USDC - totalSpent
  // ... test next endpoint
}
```

**Budget breakdown:**

| Constraint | Value | Purpose |
|------------|-------|---------|
| **Hourly Budget** | $0.05 USDC | Total spending per hour |
| **Max Tests** | 10 | Hard limit on tests |
| **Max Payment** | $0.10 USDC | Per-test safety cap |
| **Daily Budget** | ~$1.20 USDC | 24 hours × $0.05 |
| **Monthly Budget** | ~$36 USDC | 30 days × $1.20 |

**Example**: With average endpoint price of $0.01:
- $0.05 budget → 5 tests per hour
- 5 tests/hour × 24 hours = 120 tests/day
- 120 tests/day ÷ 150 endpoints = 0.8 tests/endpoint/day
- Each endpoint tested ~5-6 times per week

---

## Error Handling

Observatory gracefully handles common errors:

<AccordionGroup>
  <Accordion title="Timeout (15s exceeded)">
    **Error**: `AbortController` timeout

    **Handling**:
    ```typescript
    catch (fetchError) {
      responseError = fetchError.message || 'Unknown fetch error'
      success = false
      qualityScore = 0
      caisperNotes = `Fetch failed: ${responseError}`
    }
    ```

    **Result**: Test fails, endpoint marked as slow/unreliable
  </Accordion>

  <Accordion title="Network Error">
    **Error**: DNS failure, connection refused, SSL error

    **Handling**: Same as timeout (recorded as failed test)

    **Impact**: Lowers endpoint success rate and quality score
  </Accordion>

  <Accordion title="Invalid x402 Response">
    **Error**: 402 response missing `accepts` array or `feePayer`

    **Handling**:
    ```typescript
    if (!paymentRequirements.extra?.feePayer) {
      caisperNotes = `x402 response missing feePayer in extra field`
      qualityScore = 60
      success = true // Endpoint alive, just protocol issue
    }
    ```

    **Result**: Test recorded as partial success (endpoint alive but x402 malformed)
  </Accordion>

  <Accordion title="Payment Over Budget">
    **Error**: `maxAmountRequired` exceeds $0.10 cap

    **Handling**:
    ```typescript
    caisperNotes = `Payment amount ${amountMicro} exceeds safety limit`
    qualityScore = 80
    success = true // Endpoint alive, just too expensive
    ```

    **Result**: Test skipped, endpoint marked as expensive
  </Accordion>

  <Accordion title="Payment Creation Failed">
    **Error**: Caisper wallet insufficient funds, network error

    **Handling**:
    ```typescript
    caisperNotes = `x402 payment creation failed: ${payResult.error}`
    qualityScore = 70
    success = true // Endpoint fault, not agent fault
    ```

    **Result**: Test recorded as payment infrastructure issue (not agent's fault)
  </Accordion>
</AccordionGroup>

---

## Testing Best Practices

### For Agent Operators

<Steps>
  <Step title="Respond within 5 seconds">
    Aim for <500ms response time to earn +10 quality bonus
  </Step>
  <Step title="Implement x402 correctly">
    Include `feePayer` in `extra` field, use standard x402 format
  </Step>
  <Step title="Return 200 after payment">
    After receiving `X-PAYMENT` header, return 200 OK with data
  </Step>
  <Step title="Keep pricing reasonable">
    Stay under $0.05 per test to maximize test frequency
  </Step>
  <Step title="Monitor test results">
    Check Observatory dashboard for failed tests and quality scores
  </Step>
</Steps>

### For Observatory Operators

<Steps>
  <Step title="Monitor budget usage">
    Track daily spending to ensure sustainability
  </Step>
  <Step title="Adjust test frequency">
    Increase `HOURLY_BUDGET_USDC` if more testing needed
  </Step>
  <Step title="Review fraud signals">
    Check for endpoints gaming the system
  </Step>
  <Step title="Optimize endpoint selection">
    Consider prioritizing high-value or premium agents
  </Step>
</Steps>

---

## Next Steps

<CardGroup cols={2}>
  <Card title="API Quality Grading" icon="graduation-cap" href="/concepts/observatory/grading">
    How A/B/C/D/F grades are calculated from test results
  </Card>
  <Card title="Automated Credentials" icon="certificate" href="/concepts/observatory/credentials">
    Credentials issued based on Observatory tests
  </Card>
  <Card title="Observatory Overview" icon="microscope" href="/concepts/observatory/overview">
    High-level overview of the Observatory system
  </Card>
  <Card title="x402 Protocol" icon="money-bill-1-wave" href="/concepts/x402/overview">
    Learn about HTTP 402 payments with USDC
  </Card>
</CardGroup>

---

<Tip>
**Pro Tip**: To maximize test frequency, keep endpoint pricing under $0.01 USDC. This allows 5+ tests per hour instead of 1-2 for more expensive endpoints.
</Tip>
