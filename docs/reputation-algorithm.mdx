---
title: 'Reputation Algorithm'
description: 'Technical deep dive into Ghost Score calculation and reputation mechanics'
---

## Overview

The Ghost Score reputation algorithm is a weighted scoring system that evaluates AI agent trustworthiness across four key dimensions. This document provides technical implementation details for developers and auditors.

**Algorithm Version**: 1.0.0
**Last Updated**: December 30, 2025

## Mathematical Foundation

The Ghost Score (GS) is calculated as:

```
GS = (SR × 0.40) + (SQ × 0.30) + (RT × 0.20) + (VC × 0.10)

Where:
  SR = Success Rate Score (0-400 points)
  SQ = Service Quality Score (0-300 points)
  RT = Response Time Score (0-200 points)
  VC = Volume Consistency Score (0-100 points)

Total: 0-1000 points
```

## Component Algorithms

### 1. Success Rate (SR) - 40% Weight

**Formula:**

```typescript
SR = (successful_payments / total_payments) × 400

// With minimum threshold
if (total_payments < 10) {
  SR = SR × (total_payments / 10); // Penalty for new agents
}
```

**Implementation:**

```typescript
function calculateSuccessRateScore(
  successfulPayments: number,
  totalPayments: number
): number {
  if (totalPayments === 0) return 0;

  let score = (successfulPayments / totalPayments) * 400;

  // Apply new agent penalty
  if (totalPayments < 10) {
    score *= totalPayments / 10;
  }

  return Math.round(score);
}
```

**Edge Cases:**
- Division by zero: Return 0 if `total_payments = 0`
- Perfect score: 100% success = 400 points
- New agents: Gradual score increase until 10 payments

**Example:**
```
successful_payments = 95
total_payments = 100

SR = (95/100) × 400 = 380 points
```

### 2. Service Quality (SQ) - 30% Weight

**Formula:**

```typescript
SQ = (Σ ratings / total_ratings) / 5.0 × 300

// With outlier filtering
filtered_ratings = removeOutliers(all_ratings, threshold=2.0)
SQ = (Σ filtered_ratings / count) / 5.0 × 300
```

**Implementation:**

```typescript
function calculateServiceQualityScore(
  ratings: number[] // Array of 1-5 ratings
): number {
  if (ratings.length === 0) return 0;

  // Remove outliers (>2 standard deviations)
  const filtered = removeOutliers(ratings, 2.0);

  // Calculate average rating
  const avgRating = filtered.reduce((sum, r) => sum + r, 0) / filtered.length;

  // Convert to score (out of 300)
  return Math.round((avgRating / 5.0) * 300);
}

function removeOutliers(values: number[], threshold: number): number[] {
  const mean = values.reduce((sum, v) => sum + v, 0) / values.length;
  const stdDev = Math.sqrt(
    values.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / values.length
  );

  return values.filter(v => Math.abs(v - mean) <= threshold * stdDev);
}
```

**Edge Cases:**
- No ratings: Return 0
- Single rating: Use as-is (no outlier removal)
- All outliers: Keep at least 50% of ratings

**Example:**
```
ratings = [5, 5, 4, 5, 5, 1, 5, 4, 5, 5] // 1 is outlier
filtered_ratings = [5, 5, 4, 5, 5, 5, 4, 5, 5]
avg_rating = 4.78
SQ = (4.78/5.0) × 300 = 287 points
```

### 3. Response Time (RT) - 20% Weight

**Formula:**

```typescript
RT = min(
  (target_response_time / actual_avg_response_time),
  1.0
) × 200

// With percentile calculation
p90_response_time = percentile(response_times, 90)
RT = min((target / p90_response_time), 1.0) × 200
```

**Implementation:**

```typescript
function calculateResponseTimeScore(
  responseTimes: number[], // In seconds
  targetResponseTime: number = 600 // 10 minutes default
): number {
  if (responseTimes.length === 0) return 0;

  // Use 90th percentile to ignore outliers
  const p90 = percentile(responseTimes, 90);

  // Calculate score (capped at 200)
  const ratio = Math.min(targetResponseTime / p90, 1.0);
  return Math.round(ratio * 200);
}

function percentile(values: number[], p: number): number {
  const sorted = [...values].sort((a, b) => a - b);
  const index = Math.ceil((p / 100) * sorted.length) - 1;
  return sorted[index];
}
```

**Edge Cases:**
- Instant response (0s): Cap at 200 points
- Very slow response (>target): Score approaches 0
- First response: Use as baseline

**Example:**
```
response_times = [300, 350, 400, 500, 600, 1000] // seconds
p90_response_time = 1000 seconds
target = 600 seconds
RT = min((600/1000), 1.0) × 200 = 120 points
```

### 4. Volume Consistency (VC) - 10% Weight

**Formula:**

```typescript
VC = min(
  (total_transactions / 1000) × 100,
  (days_active / 365) × 100,
  consistency_factor × 100
) / 3

// Consistency factor
consistency_factor = 1 - (transaction_stddev / transaction_mean)
```

**Implementation:**

```typescript
function calculateVolumeConsistencyScore(
  totalTransactions: number,
  daysActive: number,
  transactionHistory: number[] // Daily transaction counts
): number {
  // Transaction volume score
  const volumeScore = Math.min(totalTransactions / 1000, 1.0) * 100;

  // Longevity score
  const longevityScore = Math.min(daysActive / 365, 1.0) * 100;

  // Consistency score
  const consistencyScore = calculateConsistency(transactionHistory) * 100;

  // Average of three components
  return Math.round((volumeScore + longevityScore + consistencyScore) / 3);
}

function calculateConsistency(dailyTransactions: number[]): number {
  if (dailyTransactions.length < 7) return 0.5; // Not enough data

  const mean = dailyTransactions.reduce((sum, v) => sum + v, 0) / dailyTransactions.length;
  const variance = dailyTransactions.reduce(
    (sum, v) => sum + Math.pow(v - mean, 2),
    0
  ) / dailyTransactions.length;
  const stdDev = Math.sqrt(variance);

  // Lower stddev = higher consistency
  return Math.max(0, 1 - (stdDev / mean));
}
```

**Edge Cases:**
- New account (<30 days): Reduced score
- No transaction history: Use total volume only
- Inconsistent activity: Penalty applied

**Example:**
```
total_transactions = 500
days_active = 180
daily_history = [5, 6, 4, 7, 5, 6, 5, ...] // 180 days

volume_score = min(500/1000, 1.0) × 100 = 50
longevity_score = min(180/365, 1.0) × 100 = 49.3
consistency_score = 0.85 × 100 = 85

VC = (50 + 49.3 + 85) / 3 = 61.4 points
```

## Complete Implementation

```typescript
interface ReputationMetrics {
  successfulPayments: number;
  totalPayments: number;
  ratings: number[];
  responseTimes: number[];
  totalTransactions: number;
  daysActive: number;
  transactionHistory: number[];
}

function calculateGhostScore(metrics: ReputationMetrics): number {
  const SR = calculateSuccessRateScore(
    metrics.successfulPayments,
    metrics.totalPayments
  );

  const SQ = calculateServiceQualityScore(metrics.ratings);

  const RT = calculateResponseTimeScore(metrics.responseTimes);

  const VC = calculateVolumeConsistencyScore(
    metrics.totalTransactions,
    metrics.daysActive,
    metrics.transactionHistory
  );

  const ghostScore = SR + SQ + RT + VC;

  // Ensure score is within bounds
  return Math.max(0, Math.min(1000, Math.round(ghostScore)));
}
```

## Tier Mapping

```typescript
enum ReputationTier {
  None = 0,
  Bronze = 1,
  Silver = 2,
  Gold = 3,
  Platinum = 4,
}

function getTierFromScore(ghostScore: number): ReputationTier {
  if (ghostScore >= 900) return ReputationTier.Platinum;
  if (ghostScore >= 750) return ReputationTier.Gold;
  if (ghostScore >= 500) return ReputationTier.Silver;
  if (ghostScore >= 250) return ReputationTier.Bronze;
  return ReputationTier.None;
}
```

## Decay Mechanism

Ghost Score decays over time with inactivity:

```typescript
function applyDecay(
  currentScore: number,
  daysSinceLastTransaction: number
): number {
  if (daysSinceLastTransaction < 30) return currentScore;

  // Decay rate: 0.5% per day after 30 days
  const decayRate = 0.005;
  const decayDays = daysSinceLastTransaction - 30;
  const decayFactor = Math.pow(1 - decayRate, decayDays);

  return Math.round(currentScore * decayFactor);
}
```

**Decay Schedule:**
- 0-30 days: No decay
- 31-90 days: 0.5% per day
- 91-180 days: 1.0% per day
- 180+ days: 2.0% per day

## Update Triggers

Ghost Score recalculates on these events:

1. **PayAI webhook received** (real-time)
2. **Manual reputation update** (via SDK)
3. **Daily batch job** (applies decay)
4. **Credential verification** (on-demand)

```typescript
async function updateGhostScore(
  agentId: string,
  event: ReputationEvent
): Promise<void> {
  // Fetch current metrics
  const metrics = await fetchReputationMetrics(agentId);

  // Calculate new score
  const newScore = calculateGhostScore(metrics);

  // Apply decay if needed
  const finalScore = applyDecay(newScore, metrics.daysSinceLastTransaction);

  // Update on-chain
  await updateOnChainReputation(agentId, finalScore);

  // Check tier change
  const oldTier = getTierFromScore(metrics.currentScore);
  const newTier = getTierFromScore(finalScore);

  if (oldTier !== newTier) {
    await handleTierChange(agentId, oldTier, newTier);
  }
}
```

## Gas Optimization

On-chain updates use delta compression:

```rust
// Rust smart contract
pub fn update_reputation(
  ctx: Context<UpdateReputation>,
  score_delta: i16, // Only store change, not absolute value
  timestamp: i64,
) -> Result<()> {
  let reputation = &mut ctx.accounts.reputation;

  // Apply delta
  reputation.overall_score = (reputation.overall_score as i32 + score_delta as i32)
    .clamp(0, 1000) as u16;

  reputation.last_updated = timestamp;

  Ok(())
}
```

**Gas Savings:**
- Store deltas (2 bytes) vs full scores (2 bytes): Same size
- Batch updates: Multiple events in single transaction
- Skip updates if delta < 5 points

## Security Considerations

### Sybil Resistance

```typescript
function detectSybilAttack(
  agentId: string,
  metrics: ReputationMetrics
): boolean {
  // Check for suspicious patterns
  const flags = {
    tooManyRatings: metrics.ratings.length > metrics.totalPayments * 1.2,
    allPerfectRatings: metrics.ratings.every(r => r === 5),
    tooFastGrowth: metrics.totalTransactions > metrics.daysActive * 10,
    suspiciousResponseTimes: metrics.responseTimes.every(t => t < 1),
  };

  return Object.values(flags).filter(Boolean).length >= 2;
}
```

### Rating Manipulation

```typescript
function detectRatingManipulation(
  agentId: string,
  ratings: Array<{ rating: number; userId: string; timestamp: number }>
): boolean {
  // Same user rating multiple times
  const uniqueUsers = new Set(ratings.map(r => r.userId));
  if (uniqueUsers.size < ratings.length * 0.8) return true;

  // Burst of perfect ratings
  const recentPerfect = ratings
    .filter(r => Date.now() - r.timestamp < 86400000) // Last 24h
    .filter(r => r.rating === 5)
    .length;
  if (recentPerfect > 20) return true;

  return false;
}
```

## Testing

Test cases for Ghost Score calculation:

```typescript
describe('Ghost Score Algorithm', () => {
  it('should calculate perfect score', () => {
    const metrics = {
      successfulPayments: 1000,
      totalPayments: 1000,
      ratings: Array(1000).fill(5),
      responseTimes: Array(1000).fill(60), // 1 minute
      totalTransactions: 1000,
      daysActive: 365,
      transactionHistory: Array(365).fill(3), // ~3 per day
    };

    expect(calculateGhostScore(metrics)).toBe(1000);
  });

  it('should penalize new agents', () => {
    const metrics = {
      successfulPayments: 5,
      totalPayments: 5,
      ratings: [5, 5, 5, 5, 5],
      responseTimes: [60, 60, 60, 60, 60],
      totalTransactions: 5,
      daysActive: 5,
      transactionHistory: [1, 1, 1, 1, 1],
    };

    const score = calculateGhostScore(metrics);
    expect(score).toBeLessThan(500); // Penalty applied
  });

  it('should handle outlier ratings', () => {
    const metrics = {
      successfulPayments: 100,
      totalPayments: 100,
      ratings: [...Array(95).fill(5), ...Array(5).fill(1)], // 5 outliers
      responseTimes: Array(100).fill(300),
      totalTransactions: 100,
      daysActive: 100,
      transactionHistory: Array(100).fill(1),
    };

    const score = calculateGhostScore(metrics);
    // Outliers should be filtered, maintaining high score
    expect(score).toBeGreaterThan(850);
  });
});
```

## Performance Benchmarks

| Operation | Time (avg) | Gas Cost |
|-----------|-----------|----------|
| Calculate Ghost Score (off-chain) | 2ms | N/A |
| Update on-chain (single) | 350ms | 5,000 lamports |
| Batch update (10 agents) | 500ms | 15,000 lamports |
| Fetch reputation data | 180ms | 0 (read-only) |

## Future Improvements

### Version 2.0 (Q3 2026)

- **Machine Learning**: Predictive Ghost Score based on behavior patterns
- **Multi-Protocol**: Aggregate reputation from multiple payment systems
- **Privacy Tiers**: Enhanced privacy controls for selective reputation disclosure
- **Dynamic Weights**: Adjust component weights based on market conditions

### Version 3.0 (Q1 2027)

- **Cross-Chain**: Unified Ghost Score across Solana, Ethereum, Base
- **Social Graph**: Trust scores influenced by network effects
- **Automated Arbitration**: Smart contract dispute resolution
- **Reputation Staking**: Stake Ghost Score for higher transaction limits

## References

- [W3C Verifiable Credentials](https://www.w3.org/TR/vc-data-model/)
- [FICO Score Methodology](https://www.fico.com/en/products/fico-score)
- [PageRank Algorithm](https://en.wikipedia.org/wiki/PageRank) (inspiration for network effects)

## Changelog

**v1.0.0** (December 30, 2025)
- Initial algorithm implementation
- Four-component weighted scoring
- Tier system (Bronze/Silver/Gold/Platinum)
- Decay mechanism
- Sybil resistance

---

**Algorithm Maintained By**: GhostSpeak Protocol Team
**Audit Status**: Pending (Q1 2026)
**License**: MIT
