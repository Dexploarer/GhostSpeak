import { createRequire } from "node:module";
var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __esm = (fn, res) => () => (fn && (res = fn(fn = 0)), res);
var __require = /* @__PURE__ */ createRequire(import.meta.url);

// ../sdk-typescript/dist/chunk-SKMJJ3Q6.js
function chunkArray(array, size) {
  const chunks = [];
  for (let i = 0;i < array.length; i += size) {
    chunks.push(array.slice(i, i + size));
  }
  return chunks;
}
async function batchGetAccounts(rpc, addresses, config = {}) {
  const batchSize = Math.min(config.batchSize ?? MAX_ACCOUNTS_PER_BATCH, MAX_ACCOUNTS_PER_BATCH);
  if (addresses.length === 0)
    return [];
  if (addresses.length <= batchSize) {
    const result = await rpc.getMultipleAccounts(addresses).send();
    return result.value;
  }
  const batches = chunkArray(addresses, batchSize);
  const results = [];
  let completed = 0;
  const batchPromises = batches.map(async (batch) => {
    const result = await rpc.getMultipleAccounts(batch).send();
    completed += batch.length;
    config.onProgress?.(completed, addresses.length);
    return result.value;
  });
  results.push(...await Promise.all(batchPromises));
  return results.flat();
}
async function batchGetExistingAccounts(rpc, addresses, config = {}) {
  const accounts = await batchGetAccounts(rpc, addresses, config);
  const existing = [];
  for (let i = 0;i < accounts.length; i++) {
    const account = accounts[i];
    if (account !== null) {
      existing.push({
        address: addresses[i],
        account
      });
    }
  }
  return existing;
}
async function batchGetAndMap(rpc, addresses, mapper, config = {}) {
  const accounts = await batchGetAccounts(rpc, addresses, config);
  return accounts.map((account, index) => mapper(account, addresses[index], index));
}
async function batchGetAccountsWithRetry(rpc, addresses, config = {}, maxRetries = 3) {
  const batchSize = Math.min(config.batchSize ?? MAX_ACCOUNTS_PER_BATCH, MAX_ACCOUNTS_PER_BATCH);
  if (addresses.length === 0)
    return [];
  const batches = chunkArray(addresses, batchSize);
  const results = new Array(addresses.length);
  let completed = 0;
  await Promise.all(batches.map(async (batch, batchIndex) => {
    let retries = 0;
    let success = false;
    while (!success && retries <= maxRetries) {
      try {
        const result = await rpc.getMultipleAccounts(batch).send();
        const batchResults = result.value;
        batchResults.forEach((account, i) => {
          results[batchIndex * batchSize + i] = account;
        });
        completed += batch.length;
        config.onProgress?.(completed, addresses.length);
        success = true;
      } catch (error) {
        retries++;
        if (retries > maxRetries) {
          throw new Error(`Batch ${batchIndex} failed after ${maxRetries} retries: ${error}`);
        }
        await new Promise((resolve) => setTimeout(resolve, 100 * Math.pow(2, retries - 1)));
      }
    }
  }));
  return results;
}
function createBatchFetcher(rpc, defaultConfig = {}) {
  return {
    getAccounts: (addresses, config) => batchGetAccounts(rpc, addresses, { ...defaultConfig, ...config }),
    getExisting: (addresses, config) => batchGetExistingAccounts(rpc, addresses, {
      ...defaultConfig,
      ...config
    }),
    getAndMap: (addresses, mapper, config) => batchGetAndMap(rpc, addresses, mapper, {
      ...defaultConfig,
      ...config
    }),
    getWithRetry: (addresses, config, maxRetries) => batchGetAccountsWithRetry(rpc, addresses, { ...defaultConfig, ...config }, maxRetries)
  };
}
var MAX_ACCOUNTS_PER_BATCH = 100;
var init_chunk_SKMJJ3Q6 = () => {};

// ../../node_modules/.bun/@solana+errors@5.3.0+1fb4c65d43e298b9/node_modules/@solana/errors/dist/index.node.mjs
function getHumanReadableErrorMessage(code, context = {}) {
  const messageFormatString = SolanaErrorMessages[code];
  if (messageFormatString.length === 0) {
    return "";
  }
  let state;
  function commitStateUpTo(endIndex) {
    if (state[TYPE] === 2) {
      const variableName = messageFormatString.slice(state[START_INDEX] + 1, endIndex);
      fragments.push(variableName in context ? `${context[variableName]}` : `$${variableName}`);
    } else if (state[TYPE] === 1) {
      fragments.push(messageFormatString.slice(state[START_INDEX], endIndex));
    }
  }
  const fragments = [];
  messageFormatString.split("").forEach((char, ii) => {
    if (ii === 0) {
      state = {
        [START_INDEX]: 0,
        [TYPE]: messageFormatString[0] === "\\" ? 0 : messageFormatString[0] === "$" ? 2 : 1
      };
      return;
    }
    let nextState;
    switch (state[TYPE]) {
      case 0:
        nextState = { [START_INDEX]: ii, [TYPE]: 1 };
        break;
      case 1:
        if (char === "\\") {
          nextState = { [START_INDEX]: ii, [TYPE]: 0 };
        } else if (char === "$") {
          nextState = { [START_INDEX]: ii, [TYPE]: 2 };
        }
        break;
      case 2:
        if (char === "\\") {
          nextState = { [START_INDEX]: ii, [TYPE]: 0 };
        } else if (char === "$") {
          nextState = { [START_INDEX]: ii, [TYPE]: 2 };
        } else if (!char.match(/\w/)) {
          nextState = { [START_INDEX]: ii, [TYPE]: 1 };
        }
        break;
    }
    if (nextState) {
      if (state !== nextState) {
        commitStateUpTo(ii);
      }
      state = nextState;
    }
  });
  commitStateUpTo();
  return fragments.join("");
}
function getErrorMessage(code, context = {}) {
  if (true) {
    return getHumanReadableErrorMessage(code, context);
  } else {}
}
function isSolanaError(e, code) {
  const isSolanaError2 = e instanceof Error && e.name === "SolanaError";
  if (isSolanaError2) {
    if (code !== undefined) {
      return e.context.__code === code;
    }
    return true;
  }
  return false;
}
var SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED = 1, SOLANA_ERROR__INVALID_NONCE = 2, SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND = 3, SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE = 4, SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH = 5, SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE = 6, SOLANA_ERROR__MALFORMED_BIGINT_STRING = 7, SOLANA_ERROR__MALFORMED_NUMBER_STRING = 8, SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE = 9, SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR = 10, SOLANA_ERROR__JSON_RPC__PARSE_ERROR = -32700, SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR = -32603, SOLANA_ERROR__JSON_RPC__INVALID_PARAMS = -32602, SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND = -32601, SOLANA_ERROR__JSON_RPC__INVALID_REQUEST = -32600, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_UNREACHABLE = -32019, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_NOT_EPOCH_BOUNDARY = -32018, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_EPOCH_REWARDS_PERIOD_ACTIVE = -32017, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED = -32016, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION = -32015, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET = -32014, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH = -32013, SOLANA_ERROR__JSON_RPC__SCAN_ERROR = -32012, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE = -32011, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX = -32010, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED = -32009, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT = -32008, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED = -32007, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE = -32006, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY = -32005, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE = -32004, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE = -32003, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE = -32002, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP = -32001, SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH = 2800000, SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE = 2800001, SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS = 2800002, SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY = 2800003, SOLANA_ERROR__ADDRESSES__MALFORMED_PDA = 2800004, SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE = 2800005, SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED = 2800006, SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED = 2800007, SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE = 2800008, SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED = 2800009, SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER = 2800010, SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS = 2800011, SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND = 3230000, SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND = 32300001, SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT = 3230002, SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT = 3230003, SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED = 3230004, SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT = 3610000, SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED = 3610001, SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED = 3610002, SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED = 3610003, SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED = 3610004, SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED = 3610005, SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED = 3610006, SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY = 3610007, SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED = 3611000, SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH = 3704000, SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH = 3704001, SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH = 3704002, SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE = 3704003, SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY = 3704004, SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS = 4128000, SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA = 4128001, SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH = 4128002, SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN = 4615000, SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR = 4615001, SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT = 4615002, SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA = 4615003, SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA = 4615004, SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL = 4615005, SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS = 4615006, SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID = 4615007, SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE = 4615008, SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED = 4615009, SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT = 4615010, SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION = 4615011, SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID = 4615012, SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND = 4615013, SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED = 4615014, SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE = 4615015, SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED = 4615016, SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX = 4615017, SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED = 4615018, SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED = 4615019, SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS = 4615020, SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED = 4615021, SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE = 4615022, SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED = 4615023, SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING = 4615024, SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC = 4615025, SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM = 4615026, SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR = 4615027, SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED = 4615028, SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE = 4615029, SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT = 4615030, SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID = 4615031, SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH = 4615032, SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT = 4615033, SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED = 4615034, SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED = 4615035, SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS = 4615036, SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC = 4615037, SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED = 4615038, SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION = 4615039, SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE = 4615040, SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE = 4615041, SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE = 4615042, SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE = 4615043, SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY = 4615044, SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR = 4615045, SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT = 4615046, SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER = 4615047, SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW = 4615048, SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR = 4615049, SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER = 4615050, SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED = 4615051, SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED = 4615052, SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED = 4615053, SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS = 4615054, SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS = 5508000, SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER = 5508001, SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER = 5508002, SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER = 5508003, SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER = 5508004, SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER = 5508005, SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER = 5508006, SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER = 5508007, SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER = 5508008, SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS = 5508009, SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING = 5508010, SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED = 5508011, SOLANA_ERROR__OFFCHAIN_MESSAGE__MAXIMUM_LENGTH_EXCEEDED = 5607000, SOLANA_ERROR__OFFCHAIN_MESSAGE__RESTRICTED_ASCII_BODY_CHARACTER_OUT_OF_RANGE = 5607001, SOLANA_ERROR__OFFCHAIN_MESSAGE__APPLICATION_DOMAIN_STRING_LENGTH_OUT_OF_RANGE = 5607002, SOLANA_ERROR__OFFCHAIN_MESSAGE__INVALID_APPLICATION_DOMAIN_BYTE_LENGTH = 5607003, SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_SIGNATURES_MISMATCH = 5607004, SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO = 5607005, SOLANA_ERROR__OFFCHAIN_MESSAGE__VERSION_NUMBER_NOT_SUPPORTED = 5607006, SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_FORMAT_MISMATCH = 5607007, SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_LENGTH_MISMATCH = 5607008, SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_MUST_BE_NON_EMPTY = 5607009, SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_ENVELOPE_SIGNATURES_CANNOT_BE_ZERO = 5607010, SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURES_MISSING = 5607011, SOLANA_ERROR__OFFCHAIN_MESSAGE__ENVELOPE_SIGNERS_MISMATCH = 5607012, SOLANA_ERROR__OFFCHAIN_MESSAGE__ADDRESSES_CANNOT_SIGN_OFFCHAIN_MESSAGE = 5607013, SOLANA_ERROR__OFFCHAIN_MESSAGE__UNEXPECTED_VERSION = 5607014, SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATORIES_MUST_BE_SORTED = 5607015, SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATORIES_MUST_BE_UNIQUE = 5607016, SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURE_VERIFICATION_FAILURE = 5607017, SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES = 5663000, SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE = 5663001, SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME = 5663002, SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME = 5663003, SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE = 5663004, SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING = 5663005, SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE = 5663006, SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND = 5663007, SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING = 5663008, SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING = 5663009, SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING = 5663010, SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING = 5663011, SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING = 5663012, SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING = 5663013, SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE = 5663014, SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION = 5663015, SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES = 5663016, SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH = 5663017, SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT = 5663018, SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT = 5663019, SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT = 5663020, SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_NOT_SUPPORTED = 5663021, SOLANA_ERROR__TRANSACTION__NONCE_ACCOUNT_CANNOT_BE_IN_LOOKUP_TABLE = 5663022, SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN = 7050000, SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE = 7050001, SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE = 7050002, SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND = 7050003, SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND = 7050004, SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE = 7050005, SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE = 7050006, SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED = 7050007, SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND = 7050008, SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP = 7050009, SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE = 7050010, SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX = 7050011, SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE = 7050012, SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION = 7050013, SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE = 7050014, SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE = 7050015, SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING = 7050016, SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT = 7050017, SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION = 7050018, SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT = 7050019, SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT = 7050020, SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT = 7050021, SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS = 7050022, SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND = 7050023, SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER = 7050024, SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA = 7050025, SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX = 7050026, SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT = 7050027, SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT = 7050028, SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT = 7050029, SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION = 7050030, SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT = 7050031, SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED = 7050032, SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT = 7050033, SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED = 7050034, SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED = 7050035, SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION = 7050036, SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN = 7618000, SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_PACKER_ALREADY_COMPLETE = 7618001, SOLANA_ERROR__INSTRUCTION_PLANS__EMPTY_INSTRUCTION_PLAN = 7618002, SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_TO_EXECUTE_TRANSACTION_PLAN = 7618003, SOLANA_ERROR__INSTRUCTION_PLANS__NON_DIVISIBLE_TRANSACTION_PLANS_NOT_SUPPORTED = 7618004, SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY = 8078000, SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH = 8078001, SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH = 8078002, SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH = 8078003, SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH = 8078004, SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH = 8078005, SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH = 8078006, SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS = 8078007, SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE = 8078008, SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT = 8078009, SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT = 8078010, SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE = 8078011, SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE = 8078012, SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH = 8078013, SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE = 8078014, SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT = 8078015, SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE = 8078016, SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE = 8078017, SOLANA_ERROR__CODECS__INVALID_CONSTANT = 8078018, SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE = 8078019, SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL = 8078020, SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES = 8078021, SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS = 8078022, SOLANA_ERROR__CODECS__EXPECTED_DECODER_TO_CONSUME_ENTIRE_BYTE_ARRAY = 8078023, SOLANA_ERROR__RPC__INTEGER_OVERFLOW = 8100000, SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN = 8100001, SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR = 8100002, SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD = 8100003, SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN = 8190000, SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID = 8190001, SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED = 8190002, SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED = 8190003, SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT = 8190004, SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING = 9900000, SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE = 9900001, SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING = 9900002, SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE = 9900003, SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED = 9900004, SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_INSTRUCTION_PLAN_KIND = 9900005, SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_TRANSACTION_PLAN_KIND = 9900006, SolanaErrorMessages, START_INDEX = "i", TYPE = "t", SolanaError;
var init_index_node = __esm(() => {
  SolanaErrorMessages = {
    [SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND]: "Account not found at address: $address",
    [SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED]: "Not all accounts were decoded. Encoded accounts found at addresses: $addresses.",
    [SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT]: "Expected decoded account at address: $address",
    [SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT]: "Failed to decode account data at address: $address",
    [SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND]: "Accounts not found at addresses: $addresses",
    [SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED]: "Unable to find a viable program address bump seed.",
    [SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS]: "$putativeAddress is not a base58-encoded address.",
    [SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH]: "Expected base58 encoded address to decode to a byte array of length 32. Actual length: $actualLength.",
    [SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY]: "The `CryptoKey` must be an `Ed25519` public key.",
    [SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS]: "$putativeOffCurveAddress is not a base58-encoded off-curve address.",
    [SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE]: "Invalid seeds; point must fall off the Ed25519 curve.",
    [SOLANA_ERROR__ADDRESSES__MALFORMED_PDA]: "Expected given program derived address to have the following format: [Address, ProgramDerivedAddressBump].",
    [SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED]: "A maximum of $maxSeeds seeds, including the bump seed, may be supplied when creating an address. Received: $actual.",
    [SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED]: "The seed at index $index with length $actual exceeds the maximum length of $maxSeedLength bytes.",
    [SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE]: "Expected program derived address bump to be in the range [0, 255], got: $bump.",
    [SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER]: "Program address cannot end with PDA marker.",
    [SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE]: "Expected base58-encoded address string of length in the range [32, 44]. Actual length: $actualLength.",
    [SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE]: "Expected base58-encoded blockash string of length in the range [32, 44]. Actual length: $actualLength.",
    [SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED]: "The network has progressed past the last block for which this transaction could have been committed.",
    [SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY]: "Codec [$codecDescription] cannot decode empty byte arrays.",
    [SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS]: "Enum codec cannot use lexical values [$stringValues] as discriminators. Either remove all lexical values or set `useValuesAsDiscriminators` to `false`.",
    [SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL]: "Sentinel [$hexSentinel] must not be present in encoded bytes [$hexEncodedBytes].",
    [SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH]: "Encoder and decoder must have the same fixed size, got [$encoderFixedSize] and [$decoderFixedSize].",
    [SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH]: "Encoder and decoder must have the same max size, got [$encoderMaxSize] and [$decoderMaxSize].",
    [SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH]: "Encoder and decoder must either both be fixed-size or variable-size.",
    [SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE]: "Enum discriminator out of range. Expected a number in [$formattedValidDiscriminators], got $discriminator.",
    [SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH]: "Expected a fixed-size codec, got a variable-size one.",
    [SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH]: "Codec [$codecDescription] expected a positive byte length, got $bytesLength.",
    [SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH]: "Expected a variable-size codec, got a fixed-size one.",
    [SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE]: "Codec [$codecDescription] expected zero-value [$hexZeroValue] to have the same size as the provided fixed-size item [$expectedSize bytes].",
    [SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH]: "Codec [$codecDescription] expected $expected bytes, got $bytesLength.",
    [SOLANA_ERROR__CODECS__INVALID_CONSTANT]: "Expected byte array constant [$hexConstant] to be present in data [$hexData] at offset [$offset].",
    [SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT]: "Invalid discriminated union variant. Expected one of [$variants], got $value.",
    [SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT]: "Invalid enum variant. Expected one of [$stringValues] or a number in [$formattedNumericalValues], got $variant.",
    [SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT]: "Invalid literal union variant. Expected one of [$variants], got $value.",
    [SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS]: "Expected [$codecDescription] to have $expected items, got $actual.",
    [SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE]: "Invalid value $value for base $base with alphabet $alphabet.",
    [SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE]: "Literal union discriminator out of range. Expected a number between $minRange and $maxRange, got $discriminator.",
    [SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE]: "Codec [$codecDescription] expected number to be in the range [$min, $max], got $value.",
    [SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE]: "Codec [$codecDescription] expected offset to be in the range [0, $bytesLength], got $offset.",
    [SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES]: "Expected sentinel [$hexSentinel] to be present in decoded bytes [$hexDecodedBytes].",
    [SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE]: "Union variant out of range. Expected an index between $minRange and $maxRange, got $variant.",
    [SOLANA_ERROR__CODECS__EXPECTED_DECODER_TO_CONSUME_ENTIRE_BYTE_ARRAY]: "This decoder expected a byte array of exactly $expectedLength bytes, but $numExcessBytes unexpected excess bytes remained after decoding. Are you sure that you have chosen the correct decoder for this data?",
    [SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED]: "No random values implementation could be found.",
    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED]: "instruction requires an uninitialized account",
    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED]: "instruction tries to borrow reference for an account which is already borrowed",
    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING]: "instruction left account with an outstanding borrowed reference",
    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED]: "program other than the account's owner changed the size of the account data",
    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL]: "account data too small for instruction",
    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE]: "instruction expected an executable account",
    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT]: "An account does not have enough lamports to be rent-exempt",
    [SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW]: "Program arithmetic overflowed",
    [SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR]: "Failed to serialize or deserialize account data: $encodedData",
    [SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS]: "Builtin programs must consume compute units",
    [SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH]: "Cross-program invocation call depth too deep",
    [SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED]: "Computational budget exceeded",
    [SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM]: "custom program error: #$code",
    [SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX]: "instruction contains duplicate accounts",
    [SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC]: "instruction modifications of multiply-passed account differ",
    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT]: "executable accounts must be rent exempt",
    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED]: "instruction changed executable accounts data",
    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE]: "instruction changed the balance of an executable account",
    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED]: "instruction changed executable bit of an account",
    [SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED]: "instruction modified data of an account it does not own",
    [SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND]: "instruction spent from the balance of an account it does not own",
    [SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR]: "generic instruction error",
    [SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER]: "Provided owner is not allowed",
    [SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE]: "Account is immutable",
    [SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY]: "Incorrect authority provided",
    [SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID]: "incorrect program id for instruction",
    [SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS]: "insufficient funds for instruction",
    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA]: "invalid account data for instruction",
    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER]: "Invalid account owner",
    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT]: "invalid program argument",
    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR]: "program returned invalid error code",
    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA]: "invalid instruction data",
    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC]: "Failed to reallocate account data",
    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS]: "Provided seeds do not result in a valid address",
    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED]: "Accounts data allocations exceeded the maximum allowed per transaction",
    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED]: "Max accounts exceeded",
    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED]: "Max instruction trace length exceeded",
    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED]: "Length of the seed is too long for address generation",
    [SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT]: "An account required by the instruction is missing",
    [SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE]: "missing required signature for instruction",
    [SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID]: "instruction illegally modified the program id of an account",
    [SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS]: "insufficient account keys for instruction",
    [SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION]: "Cross-program invocation with unauthorized signer or writable account",
    [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE]: "Failed to create program execution environment",
    [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE]: "Program failed to compile",
    [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE]: "Program failed to complete",
    [SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED]: "instruction modified data of a read-only account",
    [SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE]: "instruction changed the balance of a read-only account",
    [SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED]: "Cross-program invocation reentrancy not allowed for this instruction",
    [SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED]: "instruction modified rent epoch of an account",
    [SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION]: "sum of account balances before and after instruction do not match",
    [SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT]: "instruction requires an initialized account",
    [SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN]: "",
    [SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID]: "Unsupported program id",
    [SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR]: "Unsupported sysvar",
    [SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_INSTRUCTION_PLAN_KIND]: "Invalid instruction plan kind: $kind.",
    [SOLANA_ERROR__INSTRUCTION_PLANS__EMPTY_INSTRUCTION_PLAN]: "The provided instruction plan is empty.",
    [SOLANA_ERROR__INSTRUCTION_PLANS__NON_DIVISIBLE_TRANSACTION_PLANS_NOT_SUPPORTED]: "This transaction plan executor does not support non-divisible sequential plans. To support them, you may create your own executor such that multi-transaction atomicity is preserved â€” e.g. by targetting RPCs that support transaction bundles.",
    [SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_TO_EXECUTE_TRANSACTION_PLAN]: "The provided transaction plan failed to execute. See the `transactionPlanResult` attribute and the `cause` error for more details.",
    [SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN]: "The provided message has insufficient capacity to accommodate the next instruction(s) in this plan. Expected at least $numBytesRequired free byte(s), got $numFreeBytes byte(s).",
    [SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_TRANSACTION_PLAN_KIND]: "Invalid transaction plan kind: $kind.",
    [SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_PACKER_ALREADY_COMPLETE]: "No more instructions to pack; the message packer has completed the instruction plan.",
    [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS]: "The instruction does not have any accounts.",
    [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA]: "The instruction does not have any data.",
    [SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH]: "Expected instruction to have progress address $expectedProgramAddress, got $actualProgramAddress.",
    [SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH]: "Expected base58 encoded blockhash to decode to a byte array of length 32. Actual length: $actualLength.",
    [SOLANA_ERROR__INVALID_NONCE]: "The nonce `$expectedNonceValue` is no longer valid. It has advanced to `$actualNonceValue`",
    [SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING]: "Invariant violation: Found no abortable iterable cache entry for key `$cacheKey`. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
    [SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED]: "Invariant violation: This data publisher does not publish to the channel named `$channelName`. Supported channels include $supportedChannelNames.",
    [SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE]: "Invariant violation: WebSocket message iterator state is corrupt; iterated without first resolving existing message promise. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
    [SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING]: "Invariant violation: WebSocket message iterator is missing state storage. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
    [SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE]: "Invariant violation: Switch statement non-exhaustive. Received unexpected value `$unexpectedValue`. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
    [SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR]: "JSON-RPC error: Internal JSON-RPC error ($__serverMessage)",
    [SOLANA_ERROR__JSON_RPC__INVALID_PARAMS]: "JSON-RPC error: Invalid method parameter(s) ($__serverMessage)",
    [SOLANA_ERROR__JSON_RPC__INVALID_REQUEST]: "JSON-RPC error: The JSON sent is not a valid `Request` object ($__serverMessage)",
    [SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND]: "JSON-RPC error: The method does not exist / is not available ($__serverMessage)",
    [SOLANA_ERROR__JSON_RPC__PARSE_ERROR]: "JSON-RPC error: An error occurred on the server while parsing the JSON text ($__serverMessage)",
    [SOLANA_ERROR__JSON_RPC__SCAN_ERROR]: "$__serverMessage",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP]: "$__serverMessage",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE]: "$__serverMessage",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET]: "$__serverMessage",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_EPOCH_REWARDS_PERIOD_ACTIVE]: "Epoch rewards period still active at slot $slot",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX]: "$__serverMessage",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED]: "$__serverMessage",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_UNREACHABLE]: "Failed to query long-term storage; please try again",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED]: "Minimum context slot has not been reached",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY]: "Node is unhealthy; behind by $numSlotsBehind slots",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT]: "No snapshot",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE]: "Transaction simulation failed",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_NOT_EPOCH_BOUNDARY]: "Rewards cannot be found because slot $slot is not the epoch boundary. This may be due to gap in the queried node's local ledger or long-term storage",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED]: "$__serverMessage",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE]: "Transaction history is not available from this node",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE]: "$__serverMessage",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH]: "Transaction signature length mismatch",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE]: "Transaction signature verification failure",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION]: "$__serverMessage",
    [SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH]: "Key pair bytes must be of length 64, got $byteLength.",
    [SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH]: "Expected private key bytes with length 32. Actual length: $actualLength.",
    [SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH]: "Expected base58-encoded signature to decode to a byte array of length 64. Actual length: $actualLength.",
    [SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY]: "The provided private key does not match the provided public key.",
    [SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE]: "Expected base58-encoded signature string of length in the range [64, 88]. Actual length: $actualLength.",
    [SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE]: "Lamports value must be in the range [0, 2e64-1]",
    [SOLANA_ERROR__MALFORMED_BIGINT_STRING]: "`$value` cannot be parsed as a `BigInt`",
    [SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR]: "$message",
    [SOLANA_ERROR__MALFORMED_NUMBER_STRING]: "`$value` cannot be parsed as a `Number`",
    [SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND]: "No nonce account could be found at address `$nonceAccountAddress`",
    [SOLANA_ERROR__OFFCHAIN_MESSAGE__INVALID_APPLICATION_DOMAIN_BYTE_LENGTH]: "Expected base58 encoded application domain to decode to a byte array of length 32. Actual length: $actualLength.",
    [SOLANA_ERROR__OFFCHAIN_MESSAGE__ADDRESSES_CANNOT_SIGN_OFFCHAIN_MESSAGE]: "Attempted to sign an offchain message with an address that is not a signer for it",
    [SOLANA_ERROR__OFFCHAIN_MESSAGE__APPLICATION_DOMAIN_STRING_LENGTH_OUT_OF_RANGE]: "Expected base58-encoded application domain string of length in the range [32, 44]. Actual length: $actualLength.",
    [SOLANA_ERROR__OFFCHAIN_MESSAGE__ENVELOPE_SIGNERS_MISMATCH]: "The signer addresses in this offchain message envelope do not match the list of required signers in the message preamble. These unexpected signers were present in the envelope: `[$unexpectedSigners]`. These required signers were missing from the envelope `[$missingSigners]`.",
    [SOLANA_ERROR__OFFCHAIN_MESSAGE__MAXIMUM_LENGTH_EXCEEDED]: "The message body provided has a byte-length of $actualBytes. The maximum allowable byte-length is $maxBytes",
    [SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_FORMAT_MISMATCH]: "Expected message format $expectedMessageFormat, got $actualMessageFormat",
    [SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_LENGTH_MISMATCH]: "The message length specified in the message preamble is $specifiedLength bytes. The actual length of the message is $actualLength bytes.",
    [SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_MUST_BE_NON_EMPTY]: "Offchain message content must be non-empty",
    [SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO]: "Offchain message must specify the address of at least one required signer",
    [SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_ENVELOPE_SIGNATURES_CANNOT_BE_ZERO]: "Offchain message envelope must reserve space for at least one signature",
    [SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_SIGNATURES_MISMATCH]: "The offchain message preamble specifies $numRequiredSignatures required signature(s), got $signaturesLength.",
    [SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATORIES_MUST_BE_SORTED]: "The signatories of this offchain message must be listed in lexicographical order",
    [SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATORIES_MUST_BE_UNIQUE]: "An address must be listed no more than once among the signatories of an offchain message",
    [SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURES_MISSING]: "Offchain message is missing signatures for addresses: $addresses.",
    [SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURE_VERIFICATION_FAILURE]: "Offchain message signature verification failed. Signature mismatch for required signatories [$signatoriesWithInvalidSignatures]. Missing signatures for signatories [$signatoriesWithMissingSignatures]",
    [SOLANA_ERROR__OFFCHAIN_MESSAGE__RESTRICTED_ASCII_BODY_CHARACTER_OUT_OF_RANGE]: "The message body provided contains characters whose codes fall outside the allowed range. In order to ensure clear-signing compatiblity with hardware wallets, the message may only contain line feeds and characters in the range [\\x20-\\x7e].",
    [SOLANA_ERROR__OFFCHAIN_MESSAGE__UNEXPECTED_VERSION]: "Expected offchain message version $expectedVersion. Got $actualVersion.",
    [SOLANA_ERROR__OFFCHAIN_MESSAGE__VERSION_NUMBER_NOT_SUPPORTED]: "This version of Kit does not support decoding offchain messages with version $unsupportedVersion. The current max supported version is 0.",
    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN]: "The notification name must end in 'Notifications' and the API must supply a subscription plan creator function for the notification '$notificationName'.",
    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED]: "WebSocket was closed before payload could be added to the send buffer",
    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED]: "WebSocket connection closed",
    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT]: "WebSocket failed to connect",
    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID]: "Failed to obtain a subscription id from the server",
    [SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD]: "Could not find an API plan for RPC method: `$method`",
    [SOLANA_ERROR__RPC__INTEGER_OVERFLOW]: "The $argumentLabel argument to the `$methodName` RPC method$optionalPathLabel was `$value`. This number is unsafe for use with the Solana JSON-RPC because it exceeds `Number.MAX_SAFE_INTEGER`.",
    [SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR]: "HTTP error ($statusCode): $message",
    [SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN]: "HTTP header(s) forbidden: $headers. Learn more at https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name.",
    [SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS]: "Multiple distinct signers were identified for address `$address`. Please ensure that you are using the same signer instance for each address.",
    [SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER]: "The provided value does not implement the `KeyPairSigner` interface",
    [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER]: "The provided value does not implement the `MessageModifyingSigner` interface",
    [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER]: "The provided value does not implement the `MessagePartialSigner` interface",
    [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER]: "The provided value does not implement any of the `MessageSigner` interfaces",
    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER]: "The provided value does not implement the `TransactionModifyingSigner` interface",
    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER]: "The provided value does not implement the `TransactionPartialSigner` interface",
    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER]: "The provided value does not implement the `TransactionSendingSigner` interface",
    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER]: "The provided value does not implement any of the `TransactionSigner` interfaces",
    [SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS]: "More than one `TransactionSendingSigner` was identified.",
    [SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING]: "No `TransactionSendingSigner` was identified. Please provide a valid `TransactionWithSingleSendingSigner` transaction.",
    [SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED]: "Wallet account signers do not support signing multiple messages/transactions in a single operation",
    [SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY]: "Cannot export a non-extractable key.",
    [SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED]: "No digest implementation could be found.",
    [SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT]: "Cryptographic operations are only allowed in secure browser contexts. Read more here: https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts.",
    [SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED]: `This runtime does not support the generation of Ed25519 key pairs.

Install @solana/webcrypto-ed25519-polyfill and call its \`install\` function before generating keys in environments that do not support Ed25519.

For a list of runtimes that currently support Ed25519 operations, visit https://github.com/WICG/webcrypto-secure-curves/issues/20.`,
    [SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED]: "No signature verification implementation could be found.",
    [SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED]: "No key generation implementation could be found.",
    [SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED]: "No signing implementation could be found.",
    [SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED]: "No key export implementation could be found.",
    [SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE]: "Timestamp value must be in the range [-(2n ** 63n), (2n ** 63n) - 1]. `$value` given",
    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING]: "Transaction processing left an account with an outstanding borrowed reference",
    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE]: "Account in use",
    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE]: "Account loaded twice",
    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND]: "Attempt to debit an account but found no record of a prior credit.",
    [SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND]: "Transaction loads an address table account that doesn't exist",
    [SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED]: "This transaction has already been processed",
    [SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND]: "Blockhash not found",
    [SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP]: "Loader call chain is too deep",
    [SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE]: "Transactions are currently disabled due to cluster maintenance",
    [SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION]: "Transaction contains a duplicate instruction ($index) that is not allowed",
    [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE]: "Insufficient funds for fee",
    [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT]: "Transaction results in an account ($accountIndex) with insufficient funds for rent",
    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE]: "This account may not be used to pay transaction fees",
    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX]: "Transaction contains an invalid account reference",
    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA]: "Transaction loads an address table account with invalid data",
    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX]: "Transaction address table lookup uses an invalid index",
    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER]: "Transaction loads an address table account with an invalid owner",
    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT]: "LoadedAccountsDataSizeLimit set for transaction must be greater than 0.",
    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION]: "This program may not be used for executing instructions",
    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT]: "Transaction leaves an account with a lower balance than rent-exempt minimum",
    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT]: "Transaction loads a writable account that cannot be written",
    [SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED]: "Transaction exceeded max loaded accounts data size cap",
    [SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE]: "Transaction requires a fee but has no signature present",
    [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND]: "Attempt to load a program that does not exist",
    [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED]: "Execution of the program referenced by account at index $accountIndex is temporarily restricted.",
    [SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED]: "ResanitizationNeeded",
    [SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE]: "Transaction failed to sanitize accounts offsets correctly",
    [SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE]: "Transaction did not pass signature verification",
    [SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS]: "Transaction locked too many accounts",
    [SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION]: "Sum of account balances before and after transaction do not match",
    [SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN]: "The transaction failed with the error `$errorName`",
    [SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION]: "Transaction version is unsupported",
    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT]: "Transaction would exceed account data limit within the block",
    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT]: "Transaction would exceed total account data limit",
    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT]: "Transaction would exceed max account limit within the block",
    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT]: "Transaction would exceed max Block Cost Limit",
    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT]: "Transaction would exceed max Vote Cost Limit",
    [SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION]: "Attempted to sign a transaction with an address that is not a signer for it",
    [SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING]: "Transaction is missing an address at index: $index.",
    [SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES]: "Transaction has no expected signers therefore it cannot be encoded",
    [SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT]: "Transaction size $transactionSize exceeds limit of $transactionSizeLimit bytes",
    [SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME]: "Transaction does not have a blockhash lifetime",
    [SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME]: "Transaction is not a durable nonce transaction",
    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING]: "Contents of these address lookup tables unknown: $lookupTableAddresses",
    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE]: "Lookup of address at index $highestRequestedIndex failed for lookup table `$lookupTableAddress`. Highest known index is $highestKnownIndex. The lookup table may have been extended since its contents were retrieved",
    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING]: "No fee payer set in CompiledTransaction",
    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND]: "Could not find program address at index $index",
    [SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT]: "Failed to estimate the compute unit consumption for this transaction message. This is likely because simulating the transaction failed. Inspect the `cause` property of this error to learn more",
    [SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT]: "Transaction failed when it was simulated in order to estimate the compute unit consumption. The compute unit estimate provided is for a transaction that failed when simulated and may not be representative of the compute units this transaction would consume if successful. Inspect the `cause` property of this error to learn more",
    [SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING]: "Transaction is missing a fee payer.",
    [SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING]: "Could not determine this transaction's signature. Make sure that the transaction has been signed by its fee payer.",
    [SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE]: "Transaction first instruction is not advance nonce account instruction.",
    [SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING]: "Transaction with no instructions cannot be durable nonce transaction.",
    [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES]: "This transaction includes an address (`$programAddress`) which is both invoked and set as the fee payer. Program addresses may not pay fees",
    [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE]: "This transaction includes an address (`$programAddress`) which is both invoked and marked writable. Program addresses may not be writable",
    [SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH]: "The transaction message expected the transaction to have $numRequiredSignatures signatures, got $signaturesLength.",
    [SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING]: "Transaction is missing signatures for addresses: $addresses.",
    [SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE]: "Transaction version must be in the range [0, 127]. `$actualVersion` given",
    [SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_NOT_SUPPORTED]: "This version of Kit does not support decoding transactions with version $unsupportedVersion. The current max supported version is 0.",
    [SOLANA_ERROR__TRANSACTION__NONCE_ACCOUNT_CANNOT_BE_IN_LOOKUP_TABLE]: "The transaction has a durable nonce lifetime (with nonce `$nonce`), but the nonce account address is in a lookup table. The lifetime constraint cannot be constructed without fetching the lookup tables for the transaction."
  };
  SolanaError = class extends Error {
    cause = this.cause;
    context;
    constructor(...[code, contextAndErrorOptions]) {
      let context;
      let errorOptions;
      if (contextAndErrorOptions) {
        Object.entries(Object.getOwnPropertyDescriptors(contextAndErrorOptions)).forEach(([name, descriptor]) => {
          if (name === "cause") {
            errorOptions = { cause: descriptor.value };
          } else {
            if (context === undefined) {
              context = {
                __code: code
              };
            }
            Object.defineProperty(context, name, descriptor);
          }
        });
      }
      const message = getErrorMessage(code, context);
      super(message, errorOptions);
      this.context = Object.freeze(context === undefined ? {
        __code: code
      } : context);
      this.name = "SolanaError";
    }
  };
});

// ../../node_modules/.bun/@solana+codecs-core@5.3.0+1fb4c65d43e298b9/node_modules/@solana/codecs-core/dist/index.node.mjs
function padBytes(bytes, length) {
  if (bytes.length >= length)
    return bytes;
  const paddedBytes = new Uint8Array(length).fill(0);
  paddedBytes.set(bytes);
  return paddedBytes;
}
function bytesEqual(bytes1, bytes2) {
  return bytes1.length === bytes2.length && bytes1.every((value, index) => value === bytes2[index]);
}
function getEncodedSize(value, encoder) {
  return "fixedSize" in encoder ? encoder.fixedSize : encoder.getSizeFromValue(value);
}
function createEncoder(encoder) {
  return Object.freeze({
    ...encoder,
    encode: (value) => {
      const bytes = new Uint8Array(getEncodedSize(value, encoder));
      encoder.write(value, bytes, 0);
      return bytes;
    }
  });
}
function createDecoder(decoder) {
  return Object.freeze({
    ...decoder,
    decode: (bytes, offset = 0) => decoder.read(bytes, offset)[0]
  });
}
function isFixedSize(codec) {
  return "fixedSize" in codec && typeof codec.fixedSize === "number";
}
function isVariableSize(codec) {
  return !isFixedSize(codec);
}
function combineCodec(encoder, decoder) {
  if (isFixedSize(encoder) !== isFixedSize(decoder)) {
    throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH);
  }
  if (isFixedSize(encoder) && isFixedSize(decoder) && encoder.fixedSize !== decoder.fixedSize) {
    throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH, {
      decoderFixedSize: decoder.fixedSize,
      encoderFixedSize: encoder.fixedSize
    });
  }
  if (!isFixedSize(encoder) && !isFixedSize(decoder) && encoder.maxSize !== decoder.maxSize) {
    throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH, {
      decoderMaxSize: decoder.maxSize,
      encoderMaxSize: encoder.maxSize
    });
  }
  return {
    ...decoder,
    ...encoder,
    decode: decoder.decode,
    encode: encoder.encode,
    read: decoder.read,
    write: encoder.write
  };
}
function assertByteArrayHasEnoughBytesForCodec(codecDescription, expected, bytes, offset = 0) {
  const bytesLength = bytes.length - offset;
  if (bytesLength < expected) {
    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH, {
      bytesLength,
      codecDescription,
      expected
    });
  }
}
function fixEncoderSize(encoder, fixedBytes) {
  return createEncoder({
    fixedSize: fixedBytes,
    write: (value, bytes, offset) => {
      const variableByteArray = encoder.encode(value);
      const fixedByteArray = variableByteArray.length > fixedBytes ? variableByteArray.slice(0, fixedBytes) : variableByteArray;
      bytes.set(fixedByteArray, offset);
      return offset + fixedBytes;
    }
  });
}
function fixDecoderSize(decoder, fixedBytes) {
  return createDecoder({
    fixedSize: fixedBytes,
    read: (bytes, offset) => {
      assertByteArrayHasEnoughBytesForCodec("fixCodecSize", fixedBytes, bytes, offset);
      if (offset > 0 || bytes.length > fixedBytes) {
        bytes = bytes.slice(offset, offset + fixedBytes);
      }
      if (isFixedSize(decoder)) {
        bytes = fixBytes(bytes, decoder.fixedSize);
      }
      const [value] = decoder.read(bytes, 0);
      return [value, offset + fixedBytes];
    }
  });
}
function transformEncoder(encoder, unmap) {
  return createEncoder({
    ...isVariableSize(encoder) ? { ...encoder, getSizeFromValue: (value) => encoder.getSizeFromValue(unmap(value)) } : encoder,
    write: (value, bytes, offset) => encoder.write(unmap(value), bytes, offset)
  });
}
var fixBytes = (bytes, length) => padBytes(bytes.length <= length ? bytes : bytes.slice(0, length), length);
var init_index_node2 = __esm(() => {
  init_index_node();
});

// ../../node_modules/.bun/@solana+codecs-strings@5.3.0+7f9e3d21594a24ff/node_modules/@solana/codecs-strings/dist/index.node.mjs
function assertValidBaseString(alphabet4, testValue, givenValue = testValue) {
  if (!testValue.match(new RegExp(`^[${alphabet4}]*$`))) {
    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {
      alphabet: alphabet4,
      base: alphabet4.length,
      value: givenValue
    });
  }
}
function partitionLeadingZeroes(value, zeroCharacter) {
  const [leadingZeros, tailChars] = value.split(new RegExp(`((?!${zeroCharacter}).*)`));
  return [leadingZeros, tailChars];
}
function getBigIntFromBaseX(value, alphabet4) {
  const base = BigInt(alphabet4.length);
  let sum = 0n;
  for (const char of value) {
    sum *= base;
    sum += BigInt(alphabet4.indexOf(char));
  }
  return sum;
}
function getBaseXFromBigInt(value, alphabet4) {
  const base = BigInt(alphabet4.length);
  const tailChars = [];
  while (value > 0n) {
    tailChars.unshift(alphabet4[Number(value % base)]);
    value /= base;
  }
  return tailChars.join("");
}
var getBaseXEncoder = (alphabet4) => {
  return createEncoder({
    getSizeFromValue: (value) => {
      const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet4[0]);
      if (!tailChars)
        return value.length;
      const base10Number = getBigIntFromBaseX(tailChars, alphabet4);
      return leadingZeroes.length + Math.ceil(base10Number.toString(16).length / 2);
    },
    write(value, bytes, offset) {
      assertValidBaseString(alphabet4, value);
      if (value === "")
        return offset;
      const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet4[0]);
      if (!tailChars) {
        bytes.set(new Uint8Array(leadingZeroes.length).fill(0), offset);
        return offset + leadingZeroes.length;
      }
      let base10Number = getBigIntFromBaseX(tailChars, alphabet4);
      const tailBytes = [];
      while (base10Number > 0n) {
        tailBytes.unshift(Number(base10Number % 256n));
        base10Number /= 256n;
      }
      const bytesToAdd = [...Array(leadingZeroes.length).fill(0), ...tailBytes];
      bytes.set(bytesToAdd, offset);
      return offset + bytesToAdd.length;
    }
  });
}, getBaseXDecoder = (alphabet4) => {
  return createDecoder({
    read(rawBytes, offset) {
      const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);
      if (bytes.length === 0)
        return ["", 0];
      let trailIndex = bytes.findIndex((n) => n !== 0);
      trailIndex = trailIndex === -1 ? bytes.length : trailIndex;
      const leadingZeroes = alphabet4[0].repeat(trailIndex);
      if (trailIndex === bytes.length)
        return [leadingZeroes, rawBytes.length];
      const base10Number = bytes.slice(trailIndex).reduce((sum, byte) => sum * 256n + BigInt(byte), 0n);
      const tailChars = getBaseXFromBigInt(base10Number, alphabet4);
      return [leadingZeroes + tailChars, rawBytes.length];
    }
  });
}, alphabet2 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz", getBase58Encoder = () => getBaseXEncoder(alphabet2), getBase58Decoder = () => getBaseXDecoder(alphabet2), e, o;
var init_index_node3 = __esm(() => {
  init_index_node();
  init_index_node2();
  e = globalThis.TextDecoder;
  o = globalThis.TextEncoder;
});

// ../../node_modules/.bun/@solana+assertions@5.3.0+1fb4c65d43e298b9/node_modules/@solana/assertions/dist/index.node.mjs
function assertDigestCapabilityIsAvailable() {
  if (typeof globalThis.crypto === "undefined" || typeof globalThis.crypto.subtle?.digest !== "function") {
    throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED);
  }
}
function assertKeyExporterIsAvailable() {
  if (typeof globalThis.crypto === "undefined" || typeof globalThis.crypto.subtle?.exportKey !== "function") {
    throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED);
  }
}
var init_index_node4 = __esm(() => {
  init_index_node();
});

// ../../node_modules/.bun/@solana+addresses@5.3.0+7f9e3d21594a24ff/node_modules/@solana/addresses/dist/index.node.mjs
var exports_index_node = {};
__export(exports_index_node, {
  offCurveAddress: () => offCurveAddress,
  isProgramDerivedAddress: () => isProgramDerivedAddress,
  isOffCurveAddress: () => isOffCurveAddress,
  isAddress: () => isAddress,
  getPublicKeyFromAddress: () => getPublicKeyFromAddress,
  getProgramDerivedAddress: () => getProgramDerivedAddress,
  getAddressFromPublicKey: () => getAddressFromPublicKey,
  getAddressEncoder: () => getAddressEncoder,
  getAddressDecoder: () => getAddressDecoder,
  getAddressComparator: () => getAddressComparator,
  getAddressCodec: () => getAddressCodec,
  createAddressWithSeed: () => createAddressWithSeed,
  assertIsProgramDerivedAddress: () => assertIsProgramDerivedAddress,
  assertIsOffCurveAddress: () => assertIsOffCurveAddress,
  assertIsAddress: () => assertIsAddress,
  address: () => address
});
function getMemoizedBase58Encoder() {
  if (!memoizedBase58Encoder)
    memoizedBase58Encoder = getBase58Encoder();
  return memoizedBase58Encoder;
}
function getMemoizedBase58Decoder() {
  if (!memoizedBase58Decoder)
    memoizedBase58Decoder = getBase58Decoder();
  return memoizedBase58Decoder;
}
function isAddress(putativeAddress) {
  if (putativeAddress.length < 32 || putativeAddress.length > 44) {
    return false;
  }
  const base58Encoder = getMemoizedBase58Encoder();
  try {
    return base58Encoder.encode(putativeAddress).byteLength === 32;
  } catch {
    return false;
  }
}
function assertIsAddress(putativeAddress) {
  if (putativeAddress.length < 32 || putativeAddress.length > 44) {
    throw new SolanaError(SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE, {
      actualLength: putativeAddress.length
    });
  }
  const base58Encoder = getMemoizedBase58Encoder();
  const bytes = base58Encoder.encode(putativeAddress);
  const numBytes = bytes.byteLength;
  if (numBytes !== 32) {
    throw new SolanaError(SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH, {
      actualLength: numBytes
    });
  }
}
function address(putativeAddress) {
  assertIsAddress(putativeAddress);
  return putativeAddress;
}
function getAddressEncoder() {
  return transformEncoder(fixEncoderSize(getMemoizedBase58Encoder(), 32), (putativeAddress) => address(putativeAddress));
}
function getAddressDecoder() {
  return fixDecoderSize(getMemoizedBase58Decoder(), 32);
}
function getAddressCodec() {
  return combineCodec(getAddressEncoder(), getAddressDecoder());
}
function getAddressComparator() {
  return new Intl.Collator("en", {
    caseFirst: "lower",
    ignorePunctuation: false,
    localeMatcher: "best fit",
    numeric: false,
    sensitivity: "variant",
    usage: "sort"
  }).compare;
}
function mod(a) {
  const r = a % P;
  return r >= 0n ? r : P + r;
}
function pow2(x, power) {
  let r = x;
  while (power-- > 0n) {
    r *= r;
    r %= P;
  }
  return r;
}
function pow_2_252_3(x) {
  const x2 = x * x % P;
  const b2 = x2 * x % P;
  const b4 = pow2(b2, 2n) * b2 % P;
  const b5 = pow2(b4, 1n) * x % P;
  const b10 = pow2(b5, 5n) * b5 % P;
  const b20 = pow2(b10, 10n) * b10 % P;
  const b40 = pow2(b20, 20n) * b20 % P;
  const b80 = pow2(b40, 40n) * b40 % P;
  const b160 = pow2(b80, 80n) * b80 % P;
  const b240 = pow2(b160, 80n) * b80 % P;
  const b250 = pow2(b240, 10n) * b10 % P;
  const pow_p_5_8 = pow2(b250, 2n) * x % P;
  return pow_p_5_8;
}
function uvRatio(u, v) {
  const v3 = mod(v * v * v);
  const v7 = mod(v3 * v3 * v);
  const pow = pow_2_252_3(u * v7);
  let x = mod(u * v3 * pow);
  const vx2 = mod(v * x * x);
  const root1 = x;
  const root2 = mod(x * RM1);
  const useRoot1 = vx2 === u;
  const useRoot2 = vx2 === mod(-u);
  const noRoot = vx2 === mod(-u * RM1);
  if (useRoot1)
    x = root1;
  if (useRoot2 || noRoot)
    x = root2;
  if ((mod(x) & 1n) === 1n)
    x = mod(-x);
  if (!useRoot1 && !useRoot2) {
    return null;
  }
  return x;
}
function pointIsOnCurve(y, lastByte) {
  const y2 = mod(y * y);
  const u = mod(y2 - 1n);
  const v = mod(D * y2 + 1n);
  const x = uvRatio(u, v);
  if (x === null) {
    return false;
  }
  const isLastByteOdd = (lastByte & 128) !== 0;
  if (x === 0n && isLastByteOdd) {
    return false;
  }
  return true;
}
function byteToHex(byte) {
  const hexString = byte.toString(16);
  if (hexString.length === 1) {
    return `0${hexString}`;
  } else {
    return hexString;
  }
}
function decompressPointBytes(bytes) {
  const hexString = bytes.reduce((acc, byte, ii) => `${byteToHex(ii === 31 ? byte & -129 : byte)}${acc}`, "");
  const integerLiteralString = `0x${hexString}`;
  return BigInt(integerLiteralString);
}
function compressedPointBytesAreOnCurve(bytes) {
  if (bytes.byteLength !== 32) {
    return false;
  }
  const y = decompressPointBytes(bytes);
  return pointIsOnCurve(y, bytes[31]);
}
function isOffCurveAddress(putativeOffCurveAddress) {
  const addressBytes = getAddressCodec().encode(putativeOffCurveAddress);
  return compressedPointBytesAreOnCurve(addressBytes) === false;
}
function assertIsOffCurveAddress(putativeOffCurveAddress) {
  if (!isOffCurveAddress(putativeOffCurveAddress)) {
    throw new SolanaError(SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS);
  }
}
function offCurveAddress(putativeOffCurveAddress) {
  assertIsOffCurveAddress(putativeOffCurveAddress);
  return putativeOffCurveAddress;
}
function isProgramDerivedAddress(value) {
  return Array.isArray(value) && value.length === 2 && typeof value[0] === "string" && typeof value[1] === "number" && value[1] >= 0 && value[1] <= 255 && isAddress(value[0]);
}
function assertIsProgramDerivedAddress(value) {
  const validFormat = Array.isArray(value) && value.length === 2 && typeof value[0] === "string" && typeof value[1] === "number";
  if (!validFormat) {
    throw new SolanaError(SOLANA_ERROR__ADDRESSES__MALFORMED_PDA);
  }
  if (value[1] < 0 || value[1] > 255) {
    throw new SolanaError(SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE, {
      bump: value[1]
    });
  }
  assertIsAddress(value[0]);
}
async function createProgramDerivedAddress({ programAddress, seeds }) {
  assertDigestCapabilityIsAvailable();
  if (seeds.length > MAX_SEEDS) {
    throw new SolanaError(SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED, {
      actual: seeds.length,
      maxSeeds: MAX_SEEDS
    });
  }
  let textEncoder;
  const seedBytes = seeds.reduce((acc, seed, ii) => {
    const bytes = typeof seed === "string" ? (textEncoder ||= new TextEncoder).encode(seed) : seed;
    if (bytes.byteLength > MAX_SEED_LENGTH) {
      throw new SolanaError(SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED, {
        actual: bytes.byteLength,
        index: ii,
        maxSeedLength: MAX_SEED_LENGTH
      });
    }
    acc.push(...bytes);
    return acc;
  }, []);
  const base58EncodedAddressCodec = getAddressCodec();
  const programAddressBytes = base58EncodedAddressCodec.encode(programAddress);
  const addressBytesBuffer = await crypto.subtle.digest("SHA-256", new Uint8Array([...seedBytes, ...programAddressBytes, ...PDA_MARKER_BYTES]));
  const addressBytes = new Uint8Array(addressBytesBuffer);
  if (compressedPointBytesAreOnCurve(addressBytes)) {
    throw new SolanaError(SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE);
  }
  return base58EncodedAddressCodec.decode(addressBytes);
}
async function getProgramDerivedAddress({
  programAddress,
  seeds
}) {
  let bumpSeed = 255;
  while (bumpSeed > 0) {
    try {
      const address2 = await createProgramDerivedAddress({
        programAddress,
        seeds: [...seeds, new Uint8Array([bumpSeed])]
      });
      return [address2, bumpSeed];
    } catch (e2) {
      if (isSolanaError(e2, SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE)) {
        bumpSeed--;
      } else {
        throw e2;
      }
    }
  }
  throw new SolanaError(SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED);
}
async function createAddressWithSeed({ baseAddress, programAddress, seed }) {
  const { encode, decode } = getAddressCodec();
  const seedBytes = typeof seed === "string" ? new TextEncoder().encode(seed) : seed;
  if (seedBytes.byteLength > MAX_SEED_LENGTH) {
    throw new SolanaError(SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED, {
      actual: seedBytes.byteLength,
      index: 0,
      maxSeedLength: MAX_SEED_LENGTH
    });
  }
  const programAddressBytes = encode(programAddress);
  if (programAddressBytes.length >= PDA_MARKER_BYTES.length && bytesEqual(programAddressBytes.slice(-PDA_MARKER_BYTES.length), new Uint8Array(PDA_MARKER_BYTES))) {
    throw new SolanaError(SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER);
  }
  const addressBytesBuffer = await crypto.subtle.digest("SHA-256", new Uint8Array([...encode(baseAddress), ...seedBytes, ...programAddressBytes]));
  const addressBytes = new Uint8Array(addressBytesBuffer);
  return decode(addressBytes);
}
async function getAddressFromPublicKey(publicKey) {
  assertKeyExporterIsAvailable();
  if (publicKey.type !== "public" || publicKey.algorithm.name !== "Ed25519") {
    throw new SolanaError(SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY);
  }
  const publicKeyBytes = await crypto.subtle.exportKey("raw", publicKey);
  return getAddressDecoder().decode(new Uint8Array(publicKeyBytes));
}
async function getPublicKeyFromAddress(address2) {
  const addressBytes = getAddressEncoder().encode(address2);
  return await crypto.subtle.importKey("raw", addressBytes, { name: "Ed25519" }, true, ["verify"]);
}
var memoizedBase58Encoder, memoizedBase58Decoder, D = 37095705934669439343138083508754565189542113879843219016388785533085940283555n, P = 57896044618658097711785492504343953926634992332820282019728792003956564819949n, RM1 = 19681161376707505956807079304988542015446066515923890162744021073123829784752n, MAX_SEED_LENGTH = 32, MAX_SEEDS = 16, PDA_MARKER_BYTES;
var init_index_node5 = __esm(() => {
  init_index_node2();
  init_index_node3();
  init_index_node();
  init_index_node4();
  PDA_MARKER_BYTES = [
    80,
    114,
    111,
    103,
    114,
    97,
    109,
    68,
    101,
    114,
    105,
    118,
    101,
    100,
    65,
    100,
    100,
    114,
    101,
    115,
    115
  ];
});

// ../sdk-typescript/dist/chunk-TTB4OS2D.js
var ReputationSource, BaseReputationAdapter = class {
  config;
  constructor(config) {
    this.config = config;
  }
  calculateReliability(_data) {
    return this.config.reliability / 1e4;
  }
  isEnabled() {
    return this.config.enabled;
  }
  getWeight() {
    return this.config.weight;
  }
  validateScoreRange(score) {
    return score >= 0 && score <= 1000;
  }
  clampScore(score) {
    return Math.max(0, Math.min(1000, score));
  }
}, GHOSTSPEAK_PROGRAM_ID;
var init_chunk_TTB4OS2D = __esm(() => {
  init_index_node5();
  ReputationSource = /* @__PURE__ */ ((ReputationSource2) => {
    ReputationSource2["PayAI"] = "payai";
    ReputationSource2["DirectSolana"] = "direct-solana";
    ReputationSource2["GitHub"] = "github";
    ReputationSource2["Twitter"] = "twitter";
    ReputationSource2["CustomWebhook"] = "custom-webhook";
    ReputationSource2["OnChainHistory"] = "onchain-history";
    return ReputationSource2;
  })(ReputationSource || {});
  GHOSTSPEAK_PROGRAM_ID = address("4wHjA2a5YC4twZb4NQpwZpixo5FgxxzuJUrCG7UnF9pB");
  address("DFQ9ejBt1T192Xnru1J21bFq9FSU7gjRRRYJkehvpump");
});

// ../sdk-typescript/dist/chunk-Z6ZWNWWR.js
var __defProp2, __getOwnPropDesc, __getOwnPropNames2, __hasOwnProp2, __require2, __esm2 = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames2(fn)[0]])(fn = 0)), res;
}, __export2 = (target, all) => {
  for (var name in all)
    __defProp2(target, name, { get: all[name], enumerable: true });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames2(from))
      if (!__hasOwnProp2.call(to, key) && key !== except)
        __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
}, __toCommonJS = (mod2) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod2);
var init_chunk_Z6ZWNWWR = __esm(() => {
  __defProp2 = Object.defineProperty;
  __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  __getOwnPropNames2 = Object.getOwnPropertyNames;
  __hasOwnProp2 = Object.prototype.hasOwnProperty;
  __require2 = /* @__PURE__ */ ((x) => __require)(function(x) {
    if (true)
      return __require.apply(this, arguments);
    throw Error('Dynamic require of "' + x + '" is not supported');
  });
});

// ../../node_modules/.bun/@solana+errors@5.1.0+1fb4c65d43e298b9/node_modules/@solana/errors/dist/index.node.mjs
function getHumanReadableErrorMessage2(code, context = {}) {
  const messageFormatString = SolanaErrorMessages2[code];
  if (messageFormatString.length === 0) {
    return "";
  }
  let state;
  function commitStateUpTo(endIndex) {
    if (state[TYPE2] === 2) {
      const variableName = messageFormatString.slice(state[START_INDEX2] + 1, endIndex);
      fragments.push(variableName in context ? `${context[variableName]}` : `$${variableName}`);
    } else if (state[TYPE2] === 1) {
      fragments.push(messageFormatString.slice(state[START_INDEX2], endIndex));
    }
  }
  const fragments = [];
  messageFormatString.split("").forEach((char, ii) => {
    if (ii === 0) {
      state = {
        [START_INDEX2]: 0,
        [TYPE2]: messageFormatString[0] === "\\" ? 0 : messageFormatString[0] === "$" ? 2 : 1
      };
      return;
    }
    let nextState;
    switch (state[TYPE2]) {
      case 0:
        nextState = { [START_INDEX2]: ii, [TYPE2]: 1 };
        break;
      case 1:
        if (char === "\\") {
          nextState = { [START_INDEX2]: ii, [TYPE2]: 0 };
        } else if (char === "$") {
          nextState = { [START_INDEX2]: ii, [TYPE2]: 2 };
        }
        break;
      case 2:
        if (char === "\\") {
          nextState = { [START_INDEX2]: ii, [TYPE2]: 0 };
        } else if (char === "$") {
          nextState = { [START_INDEX2]: ii, [TYPE2]: 2 };
        } else if (!char.match(/\w/)) {
          nextState = { [START_INDEX2]: ii, [TYPE2]: 1 };
        }
        break;
    }
    if (nextState) {
      if (state !== nextState) {
        commitStateUpTo(ii);
      }
      state = nextState;
    }
  });
  commitStateUpTo();
  return fragments.join("");
}
function getErrorMessage2(code, context = {}) {
  if (true) {
    return getHumanReadableErrorMessage2(code, context);
  } else {}
}
function isSolanaError2(e2, code) {
  const isSolanaError22 = e2 instanceof Error && e2.name === "SolanaError";
  if (isSolanaError22) {
    if (code !== undefined) {
      return e2.context.__code === code;
    }
    return true;
  }
  return false;
}
function safeCaptureStackTrace(...args) {
  if ("captureStackTrace" in Error && typeof Error.captureStackTrace === "function") {
    Error.captureStackTrace(...args);
  }
}
function getSolanaErrorFromRpcError({ errorCodeBaseOffset, getErrorContext, orderedErrorNames, rpcEnumError }, constructorOpt) {
  let rpcErrorName;
  let rpcErrorContext;
  if (typeof rpcEnumError === "string") {
    rpcErrorName = rpcEnumError;
  } else {
    rpcErrorName = Object.keys(rpcEnumError)[0];
    rpcErrorContext = rpcEnumError[rpcErrorName];
  }
  const codeOffset = orderedErrorNames.indexOf(rpcErrorName);
  const errorCode = errorCodeBaseOffset + codeOffset;
  const errorContext = getErrorContext(errorCode, rpcErrorName, rpcErrorContext);
  const err = new SolanaError2(errorCode, errorContext);
  safeCaptureStackTrace(err, constructorOpt);
  return err;
}
function getSolanaErrorFromInstructionError(index, instructionError) {
  const numberIndex = Number(index);
  return getSolanaErrorFromRpcError({
    errorCodeBaseOffset: 4615001,
    getErrorContext(errorCode, rpcErrorName, rpcErrorContext) {
      if (errorCode === SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN2) {
        return {
          errorName: rpcErrorName,
          index: numberIndex,
          ...rpcErrorContext !== undefined ? { instructionErrorContext: rpcErrorContext } : null
        };
      } else if (errorCode === SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM2) {
        return {
          code: Number(rpcErrorContext),
          index: numberIndex
        };
      }
      return { index: numberIndex };
    },
    orderedErrorNames: ORDERED_ERROR_NAMES,
    rpcEnumError: instructionError
  }, getSolanaErrorFromInstructionError);
}
function getSolanaErrorFromTransactionError(transactionError) {
  if (typeof transactionError === "object" && "InstructionError" in transactionError) {
    return getSolanaErrorFromInstructionError(...transactionError.InstructionError);
  }
  return getSolanaErrorFromRpcError({
    errorCodeBaseOffset: 7050001,
    getErrorContext(errorCode, rpcErrorName, rpcErrorContext) {
      if (errorCode === SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN2) {
        return {
          errorName: rpcErrorName,
          ...rpcErrorContext !== undefined ? { transactionErrorContext: rpcErrorContext } : null
        };
      } else if (errorCode === SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION2) {
        return {
          index: Number(rpcErrorContext)
        };
      } else if (errorCode === SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT2 || errorCode === SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED2) {
        return {
          accountIndex: Number(rpcErrorContext.account_index)
        };
      }
    },
    orderedErrorNames: ORDERED_ERROR_NAMES2,
    rpcEnumError: transactionError
  }, getSolanaErrorFromTransactionError);
}
function getSolanaErrorFromJsonRpcError(putativeErrorResponse) {
  let out;
  if (isRpcErrorResponse(putativeErrorResponse)) {
    const { code: rawCode, data, message } = putativeErrorResponse;
    const code = Number(rawCode);
    if (code === SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE2) {
      const { err, ...preflightErrorContext } = data;
      const causeObject = err ? { cause: getSolanaErrorFromTransactionError(err) } : null;
      out = new SolanaError2(SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE2, {
        ...preflightErrorContext,
        ...causeObject
      });
    } else {
      let errorContext;
      switch (code) {
        case SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR2:
        case SOLANA_ERROR__JSON_RPC__INVALID_PARAMS2:
        case SOLANA_ERROR__JSON_RPC__INVALID_REQUEST2:
        case SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND2:
        case SOLANA_ERROR__JSON_RPC__PARSE_ERROR2:
        case SOLANA_ERROR__JSON_RPC__SCAN_ERROR2:
        case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP2:
        case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE2:
        case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET2:
        case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX2:
        case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED2:
        case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED2:
        case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE2:
        case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION2:
          errorContext = { __serverMessage: message };
          break;
        default:
          if (typeof data === "object" && !Array.isArray(data)) {
            errorContext = data;
          }
      }
      out = new SolanaError2(code, errorContext);
    }
  } else {
    const message = typeof putativeErrorResponse === "object" && putativeErrorResponse !== null && "message" in putativeErrorResponse && typeof putativeErrorResponse.message === "string" ? putativeErrorResponse.message : "Malformed JSON-RPC error with no message attribute";
    out = new SolanaError2(SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR2, { error: putativeErrorResponse, message });
  }
  safeCaptureStackTrace(out, getSolanaErrorFromJsonRpcError);
  return out;
}
function isRpcErrorResponse(value) {
  return typeof value === "object" && value !== null && "code" in value && "message" in value && (typeof value.code === "number" || typeof value.code === "bigint") && typeof value.message === "string";
}
var SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED2 = 1, SOLANA_ERROR__INVALID_NONCE2 = 2, SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND2 = 3, SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE2 = 4, SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH2 = 5, SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE2 = 6, SOLANA_ERROR__MALFORMED_BIGINT_STRING2 = 7, SOLANA_ERROR__MALFORMED_NUMBER_STRING2 = 8, SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE2 = 9, SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR2 = 10, SOLANA_ERROR__JSON_RPC__PARSE_ERROR2 = -32700, SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR2 = -32603, SOLANA_ERROR__JSON_RPC__INVALID_PARAMS2 = -32602, SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND2 = -32601, SOLANA_ERROR__JSON_RPC__INVALID_REQUEST2 = -32600, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_UNREACHABLE2 = -32019, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_NOT_EPOCH_BOUNDARY2 = -32018, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_EPOCH_REWARDS_PERIOD_ACTIVE2 = -32017, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED2 = -32016, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION2 = -32015, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET2 = -32014, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH2 = -32013, SOLANA_ERROR__JSON_RPC__SCAN_ERROR2 = -32012, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE2 = -32011, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX2 = -32010, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED2 = -32009, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT2 = -32008, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED2 = -32007, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE2 = -32006, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY2 = -32005, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE2 = -32004, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE2 = -32003, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE2 = -32002, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP2 = -32001, SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH2 = 2800000, SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE2 = 2800001, SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS2 = 2800002, SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY2 = 2800003, SOLANA_ERROR__ADDRESSES__MALFORMED_PDA2 = 2800004, SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE2 = 2800005, SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED2 = 2800006, SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED2 = 2800007, SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE2 = 2800008, SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED2 = 2800009, SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER2 = 2800010, SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS2 = 2800011, SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND2 = 3230000, SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND2 = 32300001, SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT2 = 3230002, SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT2 = 3230003, SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED2 = 3230004, SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT2 = 3610000, SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED2 = 3610001, SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED2 = 3610002, SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED2 = 3610003, SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED2 = 3610004, SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED2 = 3610005, SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED2 = 3610006, SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY2 = 3610007, SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED2 = 3611000, SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH2 = 3704000, SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH2 = 3704001, SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH2 = 3704002, SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE2 = 3704003, SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY2 = 3704004, SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS2 = 4128000, SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA2 = 4128001, SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH2 = 4128002, SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN2 = 4615000, SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR2 = 4615001, SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT2 = 4615002, SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA2 = 4615003, SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA2 = 4615004, SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL2 = 4615005, SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS2 = 4615006, SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID2 = 4615007, SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE2 = 4615008, SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED2 = 4615009, SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT2 = 4615010, SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION2 = 4615011, SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID2 = 4615012, SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND2 = 4615013, SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED2 = 4615014, SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE2 = 4615015, SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED2 = 4615016, SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX2 = 4615017, SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED2 = 4615018, SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED2 = 4615019, SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS2 = 4615020, SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED2 = 4615021, SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE2 = 4615022, SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED2 = 4615023, SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING2 = 4615024, SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC2 = 4615025, SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM2 = 4615026, SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR2 = 4615027, SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED2 = 4615028, SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE2 = 4615029, SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT2 = 4615030, SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID2 = 4615031, SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH2 = 4615032, SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT2 = 4615033, SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED2 = 4615034, SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED2 = 4615035, SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS2 = 4615036, SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC2 = 4615037, SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED2 = 4615038, SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION2 = 4615039, SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE2 = 4615040, SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE2 = 4615041, SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE2 = 4615042, SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE2 = 4615043, SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY2 = 4615044, SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR2 = 4615045, SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT2 = 4615046, SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER2 = 4615047, SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW2 = 4615048, SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR2 = 4615049, SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER2 = 4615050, SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED2 = 4615051, SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED2 = 4615052, SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED2 = 4615053, SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS2 = 4615054, SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS2 = 5508000, SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER2 = 5508001, SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER2 = 5508002, SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER2 = 5508003, SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER2 = 5508004, SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER2 = 5508005, SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER2 = 5508006, SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER2 = 5508007, SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER2 = 5508008, SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS2 = 5508009, SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING2 = 5508010, SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED2 = 5508011, SOLANA_ERROR__OFFCHAIN_MESSAGE__MAXIMUM_LENGTH_EXCEEDED2 = 5607000, SOLANA_ERROR__OFFCHAIN_MESSAGE__RESTRICTED_ASCII_BODY_CHARACTER_OUT_OF_RANGE2 = 5607001, SOLANA_ERROR__OFFCHAIN_MESSAGE__APPLICATION_DOMAIN_STRING_LENGTH_OUT_OF_RANGE2 = 5607002, SOLANA_ERROR__OFFCHAIN_MESSAGE__INVALID_APPLICATION_DOMAIN_BYTE_LENGTH2 = 5607003, SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_SIGNATURES_MISMATCH2 = 5607004, SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO2 = 5607005, SOLANA_ERROR__OFFCHAIN_MESSAGE__VERSION_NUMBER_NOT_SUPPORTED2 = 5607006, SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_FORMAT_MISMATCH2 = 5607007, SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_LENGTH_MISMATCH2 = 5607008, SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_MUST_BE_NON_EMPTY2 = 5607009, SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_ENVELOPE_SIGNATURES_CANNOT_BE_ZERO2 = 5607010, SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURES_MISSING2 = 5607011, SOLANA_ERROR__OFFCHAIN_MESSAGE__ENVELOPE_SIGNERS_MISMATCH2 = 5607012, SOLANA_ERROR__OFFCHAIN_MESSAGE__ADDRESSES_CANNOT_SIGN_OFFCHAIN_MESSAGE2 = 5607013, SOLANA_ERROR__OFFCHAIN_MESSAGE__UNEXPECTED_VERSION2 = 5607014, SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATORIES_MUST_BE_SORTED2 = 5607015, SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATORIES_MUST_BE_UNIQUE2 = 5607016, SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURE_VERIFICATION_FAILURE2 = 5607017, SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES2 = 5663000, SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE2 = 5663001, SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME2 = 5663002, SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME2 = 5663003, SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE2 = 5663004, SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING2 = 5663005, SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE2 = 5663006, SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND2 = 5663007, SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING2 = 5663008, SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING2 = 5663009, SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING2 = 5663010, SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING2 = 5663011, SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING2 = 5663012, SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING2 = 5663013, SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE2 = 5663014, SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION2 = 5663015, SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES2 = 5663016, SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH2 = 5663017, SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT2 = 5663018, SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT2 = 5663019, SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT2 = 5663020, SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_NOT_SUPPORTED2 = 5663021, SOLANA_ERROR__TRANSACTION__NONCE_ACCOUNT_CANNOT_BE_IN_LOOKUP_TABLE2 = 5663022, SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN2 = 7050000, SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE2 = 7050001, SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE2 = 7050002, SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND2 = 7050003, SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND2 = 7050004, SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE2 = 7050005, SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE2 = 7050006, SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED2 = 7050007, SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND2 = 7050008, SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP2 = 7050009, SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE2 = 7050010, SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX2 = 7050011, SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE2 = 7050012, SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION2 = 7050013, SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE2 = 7050014, SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE2 = 7050015, SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING2 = 7050016, SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT2 = 7050017, SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION2 = 7050018, SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT2 = 7050019, SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT2 = 7050020, SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT2 = 7050021, SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS2 = 7050022, SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND2 = 7050023, SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER2 = 7050024, SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA2 = 7050025, SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX2 = 7050026, SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT2 = 7050027, SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT2 = 7050028, SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT2 = 7050029, SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION2 = 7050030, SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT2 = 7050031, SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED2 = 7050032, SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT2 = 7050033, SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED2 = 7050034, SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED2 = 7050035, SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION2 = 7050036, SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN2 = 7618000, SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_PACKER_ALREADY_COMPLETE2 = 7618001, SOLANA_ERROR__INSTRUCTION_PLANS__EMPTY_INSTRUCTION_PLAN2 = 7618002, SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_TO_EXECUTE_TRANSACTION_PLAN2 = 7618003, SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY2 = 8078000, SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH2 = 8078001, SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH2 = 8078002, SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH2 = 8078003, SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH2 = 8078004, SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH2 = 8078005, SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH2 = 8078006, SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS2 = 8078007, SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE2 = 8078008, SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT2 = 8078009, SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT2 = 8078010, SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE2 = 8078011, SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE2 = 8078012, SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH2 = 8078013, SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE2 = 8078014, SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT2 = 8078015, SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE2 = 8078016, SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE2 = 8078017, SOLANA_ERROR__CODECS__INVALID_CONSTANT2 = 8078018, SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE2 = 8078019, SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL2 = 8078020, SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES2 = 8078021, SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS2 = 8078022, SOLANA_ERROR__CODECS__EXPECTED_DECODER_TO_CONSUME_ENTIRE_BYTE_ARRAY2 = 8078023, SOLANA_ERROR__RPC__INTEGER_OVERFLOW2 = 8100000, SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN2 = 8100001, SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR2 = 8100002, SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD2 = 8100003, SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN2 = 8190000, SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID2 = 8190001, SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED2 = 8190002, SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED2 = 8190003, SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT2 = 8190004, SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING2 = 9900000, SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE2 = 9900001, SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING2 = 9900002, SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE2 = 9900003, SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED2 = 9900004, SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_INSTRUCTION_PLAN_KIND2 = 9900005, SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_TRANSACTION_PLAN_KIND2 = 9900006, SolanaErrorMessages2, START_INDEX2 = "i", TYPE2 = "t", SolanaError2, ORDERED_ERROR_NAMES, ORDERED_ERROR_NAMES2;
var init_index_node6 = __esm(() => {
  SolanaErrorMessages2 = {
    [SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND2]: "Account not found at address: $address",
    [SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED2]: "Not all accounts were decoded. Encoded accounts found at addresses: $addresses.",
    [SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT2]: "Expected decoded account at address: $address",
    [SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT2]: "Failed to decode account data at address: $address",
    [SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND2]: "Accounts not found at addresses: $addresses",
    [SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED2]: "Unable to find a viable program address bump seed.",
    [SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS2]: "$putativeAddress is not a base58-encoded address.",
    [SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH2]: "Expected base58 encoded address to decode to a byte array of length 32. Actual length: $actualLength.",
    [SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY2]: "The `CryptoKey` must be an `Ed25519` public key.",
    [SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS2]: "$putativeOffCurveAddress is not a base58-encoded off-curve address.",
    [SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE2]: "Invalid seeds; point must fall off the Ed25519 curve.",
    [SOLANA_ERROR__ADDRESSES__MALFORMED_PDA2]: "Expected given program derived address to have the following format: [Address, ProgramDerivedAddressBump].",
    [SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED2]: "A maximum of $maxSeeds seeds, including the bump seed, may be supplied when creating an address. Received: $actual.",
    [SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED2]: "The seed at index $index with length $actual exceeds the maximum length of $maxSeedLength bytes.",
    [SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE2]: "Expected program derived address bump to be in the range [0, 255], got: $bump.",
    [SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER2]: "Program address cannot end with PDA marker.",
    [SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE2]: "Expected base58-encoded address string of length in the range [32, 44]. Actual length: $actualLength.",
    [SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE2]: "Expected base58-encoded blockash string of length in the range [32, 44]. Actual length: $actualLength.",
    [SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED2]: "The network has progressed past the last block for which this transaction could have been committed.",
    [SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY2]: "Codec [$codecDescription] cannot decode empty byte arrays.",
    [SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS2]: "Enum codec cannot use lexical values [$stringValues] as discriminators. Either remove all lexical values or set `useValuesAsDiscriminators` to `false`.",
    [SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL2]: "Sentinel [$hexSentinel] must not be present in encoded bytes [$hexEncodedBytes].",
    [SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH2]: "Encoder and decoder must have the same fixed size, got [$encoderFixedSize] and [$decoderFixedSize].",
    [SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH2]: "Encoder and decoder must have the same max size, got [$encoderMaxSize] and [$decoderMaxSize].",
    [SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH2]: "Encoder and decoder must either both be fixed-size or variable-size.",
    [SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE2]: "Enum discriminator out of range. Expected a number in [$formattedValidDiscriminators], got $discriminator.",
    [SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH2]: "Expected a fixed-size codec, got a variable-size one.",
    [SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH2]: "Codec [$codecDescription] expected a positive byte length, got $bytesLength.",
    [SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH2]: "Expected a variable-size codec, got a fixed-size one.",
    [SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE2]: "Codec [$codecDescription] expected zero-value [$hexZeroValue] to have the same size as the provided fixed-size item [$expectedSize bytes].",
    [SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH2]: "Codec [$codecDescription] expected $expected bytes, got $bytesLength.",
    [SOLANA_ERROR__CODECS__INVALID_CONSTANT2]: "Expected byte array constant [$hexConstant] to be present in data [$hexData] at offset [$offset].",
    [SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT2]: "Invalid discriminated union variant. Expected one of [$variants], got $value.",
    [SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT2]: "Invalid enum variant. Expected one of [$stringValues] or a number in [$formattedNumericalValues], got $variant.",
    [SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT2]: "Invalid literal union variant. Expected one of [$variants], got $value.",
    [SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS2]: "Expected [$codecDescription] to have $expected items, got $actual.",
    [SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE2]: "Invalid value $value for base $base with alphabet $alphabet.",
    [SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE2]: "Literal union discriminator out of range. Expected a number between $minRange and $maxRange, got $discriminator.",
    [SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE2]: "Codec [$codecDescription] expected number to be in the range [$min, $max], got $value.",
    [SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE2]: "Codec [$codecDescription] expected offset to be in the range [0, $bytesLength], got $offset.",
    [SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES2]: "Expected sentinel [$hexSentinel] to be present in decoded bytes [$hexDecodedBytes].",
    [SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE2]: "Union variant out of range. Expected an index between $minRange and $maxRange, got $variant.",
    [SOLANA_ERROR__CODECS__EXPECTED_DECODER_TO_CONSUME_ENTIRE_BYTE_ARRAY2]: "This decoder expected a byte array of exactly $expectedLength bytes, but $numExcessBytes unexpected excess bytes remained after decoding. Are you sure that you have chosen the correct decoder for this data?",
    [SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED2]: "No random values implementation could be found.",
    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED2]: "instruction requires an uninitialized account",
    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED2]: "instruction tries to borrow reference for an account which is already borrowed",
    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING2]: "instruction left account with an outstanding borrowed reference",
    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED2]: "program other than the account's owner changed the size of the account data",
    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL2]: "account data too small for instruction",
    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE2]: "instruction expected an executable account",
    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT2]: "An account does not have enough lamports to be rent-exempt",
    [SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW2]: "Program arithmetic overflowed",
    [SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR2]: "Failed to serialize or deserialize account data: $encodedData",
    [SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS2]: "Builtin programs must consume compute units",
    [SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH2]: "Cross-program invocation call depth too deep",
    [SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED2]: "Computational budget exceeded",
    [SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM2]: "custom program error: #$code",
    [SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX2]: "instruction contains duplicate accounts",
    [SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC2]: "instruction modifications of multiply-passed account differ",
    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT2]: "executable accounts must be rent exempt",
    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED2]: "instruction changed executable accounts data",
    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE2]: "instruction changed the balance of an executable account",
    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED2]: "instruction changed executable bit of an account",
    [SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED2]: "instruction modified data of an account it does not own",
    [SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND2]: "instruction spent from the balance of an account it does not own",
    [SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR2]: "generic instruction error",
    [SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER2]: "Provided owner is not allowed",
    [SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE2]: "Account is immutable",
    [SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY2]: "Incorrect authority provided",
    [SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID2]: "incorrect program id for instruction",
    [SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS2]: "insufficient funds for instruction",
    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA2]: "invalid account data for instruction",
    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER2]: "Invalid account owner",
    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT2]: "invalid program argument",
    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR2]: "program returned invalid error code",
    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA2]: "invalid instruction data",
    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC2]: "Failed to reallocate account data",
    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS2]: "Provided seeds do not result in a valid address",
    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED2]: "Accounts data allocations exceeded the maximum allowed per transaction",
    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED2]: "Max accounts exceeded",
    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED2]: "Max instruction trace length exceeded",
    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED2]: "Length of the seed is too long for address generation",
    [SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT2]: "An account required by the instruction is missing",
    [SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE2]: "missing required signature for instruction",
    [SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID2]: "instruction illegally modified the program id of an account",
    [SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS2]: "insufficient account keys for instruction",
    [SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION2]: "Cross-program invocation with unauthorized signer or writable account",
    [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE2]: "Failed to create program execution environment",
    [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE2]: "Program failed to compile",
    [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE2]: "Program failed to complete",
    [SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED2]: "instruction modified data of a read-only account",
    [SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE2]: "instruction changed the balance of a read-only account",
    [SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED2]: "Cross-program invocation reentrancy not allowed for this instruction",
    [SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED2]: "instruction modified rent epoch of an account",
    [SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION2]: "sum of account balances before and after instruction do not match",
    [SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT2]: "instruction requires an initialized account",
    [SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN2]: "",
    [SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID2]: "Unsupported program id",
    [SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR2]: "Unsupported sysvar",
    [SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_INSTRUCTION_PLAN_KIND2]: "Invalid instruction plan kind: $kind.",
    [SOLANA_ERROR__INSTRUCTION_PLANS__EMPTY_INSTRUCTION_PLAN2]: "The provided instruction plan is empty.",
    [SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_TO_EXECUTE_TRANSACTION_PLAN2]: "The provided transaction plan failed to execute. See the `transactionPlanResult` attribute and the `cause` error for more details.",
    [SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN2]: "The provided message has insufficient capacity to accommodate the next instruction(s) in this plan. Expected at least $numBytesRequired free byte(s), got $numFreeBytes byte(s).",
    [SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_TRANSACTION_PLAN_KIND2]: "Invalid transaction plan kind: $kind.",
    [SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_PACKER_ALREADY_COMPLETE2]: "No more instructions to pack; the message packer has completed the instruction plan.",
    [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS2]: "The instruction does not have any accounts.",
    [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA2]: "The instruction does not have any data.",
    [SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH2]: "Expected instruction to have progress address $expectedProgramAddress, got $actualProgramAddress.",
    [SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH2]: "Expected base58 encoded blockhash to decode to a byte array of length 32. Actual length: $actualLength.",
    [SOLANA_ERROR__INVALID_NONCE2]: "The nonce `$expectedNonceValue` is no longer valid. It has advanced to `$actualNonceValue`",
    [SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING2]: "Invariant violation: Found no abortable iterable cache entry for key `$cacheKey`. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
    [SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED2]: "Invariant violation: This data publisher does not publish to the channel named `$channelName`. Supported channels include $supportedChannelNames.",
    [SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE2]: "Invariant violation: WebSocket message iterator state is corrupt; iterated without first resolving existing message promise. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
    [SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING2]: "Invariant violation: WebSocket message iterator is missing state storage. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
    [SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE2]: "Invariant violation: Switch statement non-exhaustive. Received unexpected value `$unexpectedValue`. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
    [SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR2]: "JSON-RPC error: Internal JSON-RPC error ($__serverMessage)",
    [SOLANA_ERROR__JSON_RPC__INVALID_PARAMS2]: "JSON-RPC error: Invalid method parameter(s) ($__serverMessage)",
    [SOLANA_ERROR__JSON_RPC__INVALID_REQUEST2]: "JSON-RPC error: The JSON sent is not a valid `Request` object ($__serverMessage)",
    [SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND2]: "JSON-RPC error: The method does not exist / is not available ($__serverMessage)",
    [SOLANA_ERROR__JSON_RPC__PARSE_ERROR2]: "JSON-RPC error: An error occurred on the server while parsing the JSON text ($__serverMessage)",
    [SOLANA_ERROR__JSON_RPC__SCAN_ERROR2]: "$__serverMessage",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP2]: "$__serverMessage",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE2]: "$__serverMessage",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET2]: "$__serverMessage",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_EPOCH_REWARDS_PERIOD_ACTIVE2]: "Epoch rewards period still active at slot $slot",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX2]: "$__serverMessage",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED2]: "$__serverMessage",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_UNREACHABLE2]: "Failed to query long-term storage; please try again",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED2]: "Minimum context slot has not been reached",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY2]: "Node is unhealthy; behind by $numSlotsBehind slots",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT2]: "No snapshot",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE2]: "Transaction simulation failed",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_NOT_EPOCH_BOUNDARY2]: "Rewards cannot be found because slot $slot is not the epoch boundary. This may be due to gap in the queried node's local ledger or long-term storage",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED2]: "$__serverMessage",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE2]: "Transaction history is not available from this node",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE2]: "$__serverMessage",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH2]: "Transaction signature length mismatch",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE2]: "Transaction signature verification failure",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION2]: "$__serverMessage",
    [SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH2]: "Key pair bytes must be of length 64, got $byteLength.",
    [SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH2]: "Expected private key bytes with length 32. Actual length: $actualLength.",
    [SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH2]: "Expected base58-encoded signature to decode to a byte array of length 64. Actual length: $actualLength.",
    [SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY2]: "The provided private key does not match the provided public key.",
    [SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE2]: "Expected base58-encoded signature string of length in the range [64, 88]. Actual length: $actualLength.",
    [SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE2]: "Lamports value must be in the range [0, 2e64-1]",
    [SOLANA_ERROR__MALFORMED_BIGINT_STRING2]: "`$value` cannot be parsed as a `BigInt`",
    [SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR2]: "$message",
    [SOLANA_ERROR__MALFORMED_NUMBER_STRING2]: "`$value` cannot be parsed as a `Number`",
    [SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND2]: "No nonce account could be found at address `$nonceAccountAddress`",
    [SOLANA_ERROR__OFFCHAIN_MESSAGE__INVALID_APPLICATION_DOMAIN_BYTE_LENGTH2]: "Expected base58 encoded application domain to decode to a byte array of length 32. Actual length: $actualLength.",
    [SOLANA_ERROR__OFFCHAIN_MESSAGE__ADDRESSES_CANNOT_SIGN_OFFCHAIN_MESSAGE2]: "Attempted to sign an offchain message with an address that is not a signer for it",
    [SOLANA_ERROR__OFFCHAIN_MESSAGE__APPLICATION_DOMAIN_STRING_LENGTH_OUT_OF_RANGE2]: "Expected base58-encoded application domain string of length in the range [32, 44]. Actual length: $actualLength.",
    [SOLANA_ERROR__OFFCHAIN_MESSAGE__ENVELOPE_SIGNERS_MISMATCH2]: "The signer addresses in this offchain message envelope do not match the list of required signers in the message preamble. These unexpected signers were present in the envelope: `[$unexpectedSigners]`. These required signers were missing from the envelope `[$missingSigners]`.",
    [SOLANA_ERROR__OFFCHAIN_MESSAGE__MAXIMUM_LENGTH_EXCEEDED2]: "The message body provided has a byte-length of $actualBytes. The maximum allowable byte-length is $maxBytes",
    [SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_FORMAT_MISMATCH2]: "Expected message format $expectedMessageFormat, got $actualMessageFormat",
    [SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_LENGTH_MISMATCH2]: "The message length specified in the message preamble is $specifiedLength bytes. The actual length of the message is $actualLength bytes.",
    [SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_MUST_BE_NON_EMPTY2]: "Offchain message content must be non-empty",
    [SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO2]: "Offchain message must specify the address of at least one required signer",
    [SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_ENVELOPE_SIGNATURES_CANNOT_BE_ZERO2]: "Offchain message envelope must reserve space for at least one signature",
    [SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_SIGNATURES_MISMATCH2]: "The offchain message preamble specifies $numRequiredSignatures required signature(s), got $signaturesLength.",
    [SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATORIES_MUST_BE_SORTED2]: "The signatories of this offchain message must be listed in lexicographical order",
    [SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATORIES_MUST_BE_UNIQUE2]: "An address must be listed no more than once among the signatories of an offchain message",
    [SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURES_MISSING2]: "Offchain message is missing signatures for addresses: $addresses.",
    [SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURE_VERIFICATION_FAILURE2]: "Offchain message signature verification failed. Signature mismatch for required signatories [$signatoriesWithInvalidSignatures]. Missing signatures for signatories [$signatoriesWithMissingSignatures]",
    [SOLANA_ERROR__OFFCHAIN_MESSAGE__RESTRICTED_ASCII_BODY_CHARACTER_OUT_OF_RANGE2]: "The message body provided contains characters whose codes fall outside the allowed range. In order to ensure clear-signing compatiblity with hardware wallets, the message may only contain line feeds and characters in the range [\\x20-\\x7e].",
    [SOLANA_ERROR__OFFCHAIN_MESSAGE__UNEXPECTED_VERSION2]: "Expected offchain message version $expectedVersion. Got $actualVersion.",
    [SOLANA_ERROR__OFFCHAIN_MESSAGE__VERSION_NUMBER_NOT_SUPPORTED2]: "This version of Kit does not support decoding offchain messages with version $unsupportedVersion. The current max supported version is 0.",
    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN2]: "The notification name must end in 'Notifications' and the API must supply a subscription plan creator function for the notification '$notificationName'.",
    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED2]: "WebSocket was closed before payload could be added to the send buffer",
    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED2]: "WebSocket connection closed",
    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT2]: "WebSocket failed to connect",
    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID2]: "Failed to obtain a subscription id from the server",
    [SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD2]: "Could not find an API plan for RPC method: `$method`",
    [SOLANA_ERROR__RPC__INTEGER_OVERFLOW2]: "The $argumentLabel argument to the `$methodName` RPC method$optionalPathLabel was `$value`. This number is unsafe for use with the Solana JSON-RPC because it exceeds `Number.MAX_SAFE_INTEGER`.",
    [SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR2]: "HTTP error ($statusCode): $message",
    [SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN2]: "HTTP header(s) forbidden: $headers. Learn more at https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name.",
    [SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS2]: "Multiple distinct signers were identified for address `$address`. Please ensure that you are using the same signer instance for each address.",
    [SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER2]: "The provided value does not implement the `KeyPairSigner` interface",
    [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER2]: "The provided value does not implement the `MessageModifyingSigner` interface",
    [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER2]: "The provided value does not implement the `MessagePartialSigner` interface",
    [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER2]: "The provided value does not implement any of the `MessageSigner` interfaces",
    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER2]: "The provided value does not implement the `TransactionModifyingSigner` interface",
    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER2]: "The provided value does not implement the `TransactionPartialSigner` interface",
    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER2]: "The provided value does not implement the `TransactionSendingSigner` interface",
    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER2]: "The provided value does not implement any of the `TransactionSigner` interfaces",
    [SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS2]: "More than one `TransactionSendingSigner` was identified.",
    [SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING2]: "No `TransactionSendingSigner` was identified. Please provide a valid `TransactionWithSingleSendingSigner` transaction.",
    [SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED2]: "Wallet account signers do not support signing multiple messages/transactions in a single operation",
    [SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY2]: "Cannot export a non-extractable key.",
    [SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED2]: "No digest implementation could be found.",
    [SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT2]: "Cryptographic operations are only allowed in secure browser contexts. Read more here: https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts.",
    [SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED2]: `This runtime does not support the generation of Ed25519 key pairs.

Install @solana/webcrypto-ed25519-polyfill and call its \`install\` function before generating keys in environments that do not support Ed25519.

For a list of runtimes that currently support Ed25519 operations, visit https://github.com/WICG/webcrypto-secure-curves/issues/20.`,
    [SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED2]: "No signature verification implementation could be found.",
    [SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED2]: "No key generation implementation could be found.",
    [SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED2]: "No signing implementation could be found.",
    [SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED2]: "No key export implementation could be found.",
    [SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE2]: "Timestamp value must be in the range [-(2n ** 63n), (2n ** 63n) - 1]. `$value` given",
    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING2]: "Transaction processing left an account with an outstanding borrowed reference",
    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE2]: "Account in use",
    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE2]: "Account loaded twice",
    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND2]: "Attempt to debit an account but found no record of a prior credit.",
    [SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND2]: "Transaction loads an address table account that doesn't exist",
    [SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED2]: "This transaction has already been processed",
    [SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND2]: "Blockhash not found",
    [SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP2]: "Loader call chain is too deep",
    [SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE2]: "Transactions are currently disabled due to cluster maintenance",
    [SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION2]: "Transaction contains a duplicate instruction ($index) that is not allowed",
    [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE2]: "Insufficient funds for fee",
    [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT2]: "Transaction results in an account ($accountIndex) with insufficient funds for rent",
    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE2]: "This account may not be used to pay transaction fees",
    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX2]: "Transaction contains an invalid account reference",
    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA2]: "Transaction loads an address table account with invalid data",
    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX2]: "Transaction address table lookup uses an invalid index",
    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER2]: "Transaction loads an address table account with an invalid owner",
    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT2]: "LoadedAccountsDataSizeLimit set for transaction must be greater than 0.",
    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION2]: "This program may not be used for executing instructions",
    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT2]: "Transaction leaves an account with a lower balance than rent-exempt minimum",
    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT2]: "Transaction loads a writable account that cannot be written",
    [SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED2]: "Transaction exceeded max loaded accounts data size cap",
    [SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE2]: "Transaction requires a fee but has no signature present",
    [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND2]: "Attempt to load a program that does not exist",
    [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED2]: "Execution of the program referenced by account at index $accountIndex is temporarily restricted.",
    [SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED2]: "ResanitizationNeeded",
    [SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE2]: "Transaction failed to sanitize accounts offsets correctly",
    [SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE2]: "Transaction did not pass signature verification",
    [SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS2]: "Transaction locked too many accounts",
    [SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION2]: "Sum of account balances before and after transaction do not match",
    [SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN2]: "The transaction failed with the error `$errorName`",
    [SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION2]: "Transaction version is unsupported",
    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT2]: "Transaction would exceed account data limit within the block",
    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT2]: "Transaction would exceed total account data limit",
    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT2]: "Transaction would exceed max account limit within the block",
    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT2]: "Transaction would exceed max Block Cost Limit",
    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT2]: "Transaction would exceed max Vote Cost Limit",
    [SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION2]: "Attempted to sign a transaction with an address that is not a signer for it",
    [SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING2]: "Transaction is missing an address at index: $index.",
    [SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES2]: "Transaction has no expected signers therefore it cannot be encoded",
    [SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT2]: "Transaction size $transactionSize exceeds limit of $transactionSizeLimit bytes",
    [SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME2]: "Transaction does not have a blockhash lifetime",
    [SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME2]: "Transaction is not a durable nonce transaction",
    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING2]: "Contents of these address lookup tables unknown: $lookupTableAddresses",
    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE2]: "Lookup of address at index $highestRequestedIndex failed for lookup table `$lookupTableAddress`. Highest known index is $highestKnownIndex. The lookup table may have been extended since its contents were retrieved",
    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING2]: "No fee payer set in CompiledTransaction",
    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND2]: "Could not find program address at index $index",
    [SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT2]: "Failed to estimate the compute unit consumption for this transaction message. This is likely because simulating the transaction failed. Inspect the `cause` property of this error to learn more",
    [SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT2]: "Transaction failed when it was simulated in order to estimate the compute unit consumption. The compute unit estimate provided is for a transaction that failed when simulated and may not be representative of the compute units this transaction would consume if successful. Inspect the `cause` property of this error to learn more",
    [SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING2]: "Transaction is missing a fee payer.",
    [SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING2]: "Could not determine this transaction's signature. Make sure that the transaction has been signed by its fee payer.",
    [SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE2]: "Transaction first instruction is not advance nonce account instruction.",
    [SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING2]: "Transaction with no instructions cannot be durable nonce transaction.",
    [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES2]: "This transaction includes an address (`$programAddress`) which is both invoked and set as the fee payer. Program addresses may not pay fees",
    [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE2]: "This transaction includes an address (`$programAddress`) which is both invoked and marked writable. Program addresses may not be writable",
    [SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH2]: "The transaction message expected the transaction to have $numRequiredSignatures signatures, got $signaturesLength.",
    [SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING2]: "Transaction is missing signatures for addresses: $addresses.",
    [SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE2]: "Transaction version must be in the range [0, 127]. `$actualVersion` given",
    [SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_NOT_SUPPORTED2]: "This version of Kit does not support decoding transactions with version $unsupportedVersion. The current max supported version is 0.",
    [SOLANA_ERROR__TRANSACTION__NONCE_ACCOUNT_CANNOT_BE_IN_LOOKUP_TABLE2]: "The transaction has a durable nonce lifetime (with nonce `$nonce`), but the nonce account address is in a lookup table. The lifetime constraint cannot be constructed without fetching the lookup tables for the transaction."
  };
  SolanaError2 = class extends Error {
    cause = this.cause;
    context;
    constructor(...[code, contextAndErrorOptions]) {
      let context;
      let errorOptions;
      if (contextAndErrorOptions) {
        Object.entries(Object.getOwnPropertyDescriptors(contextAndErrorOptions)).forEach(([name, descriptor]) => {
          if (name === "cause") {
            errorOptions = { cause: descriptor.value };
          } else {
            if (context === undefined) {
              context = {
                __code: code
              };
            }
            Object.defineProperty(context, name, descriptor);
          }
        });
      }
      const message = getErrorMessage2(code, context);
      super(message, errorOptions);
      this.context = Object.freeze(context === undefined ? {
        __code: code
      } : context);
      this.name = "SolanaError";
    }
  };
  ORDERED_ERROR_NAMES = [
    "GenericError",
    "InvalidArgument",
    "InvalidInstructionData",
    "InvalidAccountData",
    "AccountDataTooSmall",
    "InsufficientFunds",
    "IncorrectProgramId",
    "MissingRequiredSignature",
    "AccountAlreadyInitialized",
    "UninitializedAccount",
    "UnbalancedInstruction",
    "ModifiedProgramId",
    "ExternalAccountLamportSpend",
    "ExternalAccountDataModified",
    "ReadonlyLamportChange",
    "ReadonlyDataModified",
    "DuplicateAccountIndex",
    "ExecutableModified",
    "RentEpochModified",
    "NotEnoughAccountKeys",
    "AccountDataSizeChanged",
    "AccountNotExecutable",
    "AccountBorrowFailed",
    "AccountBorrowOutstanding",
    "DuplicateAccountOutOfSync",
    "Custom",
    "InvalidError",
    "ExecutableDataModified",
    "ExecutableLamportChange",
    "ExecutableAccountNotRentExempt",
    "UnsupportedProgramId",
    "CallDepth",
    "MissingAccount",
    "ReentrancyNotAllowed",
    "MaxSeedLengthExceeded",
    "InvalidSeeds",
    "InvalidRealloc",
    "ComputationalBudgetExceeded",
    "PrivilegeEscalation",
    "ProgramEnvironmentSetupFailure",
    "ProgramFailedToComplete",
    "ProgramFailedToCompile",
    "Immutable",
    "IncorrectAuthority",
    "BorshIoError",
    "AccountNotRentExempt",
    "InvalidAccountOwner",
    "ArithmeticOverflow",
    "UnsupportedSysvar",
    "IllegalOwner",
    "MaxAccountsDataAllocationsExceeded",
    "MaxAccountsExceeded",
    "MaxInstructionTraceLengthExceeded",
    "BuiltinProgramsMustConsumeComputeUnits"
  ];
  ORDERED_ERROR_NAMES2 = [
    "AccountInUse",
    "AccountLoadedTwice",
    "AccountNotFound",
    "ProgramAccountNotFound",
    "InsufficientFundsForFee",
    "InvalidAccountForFee",
    "AlreadyProcessed",
    "BlockhashNotFound",
    "CallChainTooDeep",
    "MissingSignatureForFee",
    "InvalidAccountIndex",
    "SignatureFailure",
    "InvalidProgramForExecution",
    "SanitizeFailure",
    "ClusterMaintenance",
    "AccountBorrowOutstanding",
    "WouldExceedMaxBlockCostLimit",
    "UnsupportedVersion",
    "InvalidWritableAccount",
    "WouldExceedMaxAccountCostLimit",
    "WouldExceedAccountDataBlockLimit",
    "TooManyAccountLocks",
    "AddressLookupTableNotFound",
    "InvalidAddressLookupTableOwner",
    "InvalidAddressLookupTableData",
    "InvalidAddressLookupTableIndex",
    "InvalidRentPayingAccount",
    "WouldExceedMaxVoteCostLimit",
    "WouldExceedAccountDataTotalLimit",
    "DuplicateInstruction",
    "InsufficientFundsForRent",
    "MaxLoadedAccountsDataSizeExceeded",
    "InvalidLoadedAccountsDataSizeLimit",
    "ResanitizationNeeded",
    "ProgramExecutionTemporarilyRestricted",
    "UnbalancedTransaction"
  ];
});

// ../../node_modules/.bun/@solana+codecs-core@5.1.0+1fb4c65d43e298b9/node_modules/@solana/codecs-core/dist/index.node.mjs
function padBytes2(bytes, length) {
  if (bytes.length >= length)
    return bytes;
  const paddedBytes = new Uint8Array(length).fill(0);
  paddedBytes.set(bytes);
  return paddedBytes;
}
function containsBytes(data, bytes, offset) {
  const slice = offset === 0 && data.length === bytes.length ? data : data.slice(offset, offset + bytes.length);
  return bytesEqual2(slice, bytes);
}
function bytesEqual2(bytes1, bytes2) {
  return bytes1.length === bytes2.length && bytes1.every((value, index) => value === bytes2[index]);
}
function getEncodedSize2(value, encoder) {
  return "fixedSize" in encoder ? encoder.fixedSize : encoder.getSizeFromValue(value);
}
function createEncoder2(encoder) {
  return Object.freeze({
    ...encoder,
    encode: (value) => {
      const bytes = new Uint8Array(getEncodedSize2(value, encoder));
      encoder.write(value, bytes, 0);
      return bytes;
    }
  });
}
function createDecoder2(decoder) {
  return Object.freeze({
    ...decoder,
    decode: (bytes, offset = 0) => decoder.read(bytes, offset)[0]
  });
}
function createCodec(codec) {
  return Object.freeze({
    ...codec,
    decode: (bytes, offset = 0) => codec.read(bytes, offset)[0],
    encode: (value) => {
      const bytes = new Uint8Array(getEncodedSize2(value, codec));
      codec.write(value, bytes, 0);
      return bytes;
    }
  });
}
function isFixedSize2(codec) {
  return "fixedSize" in codec && typeof codec.fixedSize === "number";
}
function assertIsFixedSize(codec) {
  if (!isFixedSize2(codec)) {
    throw new SolanaError2(SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH2);
  }
}
function isVariableSize2(codec) {
  return !isFixedSize2(codec);
}
function assertIsVariableSize(codec) {
  if (!isVariableSize2(codec)) {
    throw new SolanaError2(SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH2);
  }
}
function combineCodec2(encoder, decoder) {
  if (isFixedSize2(encoder) !== isFixedSize2(decoder)) {
    throw new SolanaError2(SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH2);
  }
  if (isFixedSize2(encoder) && isFixedSize2(decoder) && encoder.fixedSize !== decoder.fixedSize) {
    throw new SolanaError2(SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH2, {
      decoderFixedSize: decoder.fixedSize,
      encoderFixedSize: encoder.fixedSize
    });
  }
  if (!isFixedSize2(encoder) && !isFixedSize2(decoder) && encoder.maxSize !== decoder.maxSize) {
    throw new SolanaError2(SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH2, {
      decoderMaxSize: decoder.maxSize,
      encoderMaxSize: encoder.maxSize
    });
  }
  return {
    ...decoder,
    ...encoder,
    decode: decoder.decode,
    encode: encoder.encode,
    read: decoder.read,
    write: encoder.write
  };
}
function addEncoderSentinel(encoder, sentinel) {
  const write = (value, bytes, offset) => {
    const encoderBytes = encoder.encode(value);
    if (findSentinelIndex(encoderBytes, sentinel) >= 0) {
      throw new SolanaError2(SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL2, {
        encodedBytes: encoderBytes,
        hexEncodedBytes: hexBytes(encoderBytes),
        hexSentinel: hexBytes(sentinel),
        sentinel
      });
    }
    bytes.set(encoderBytes, offset);
    offset += encoderBytes.length;
    bytes.set(sentinel, offset);
    offset += sentinel.length;
    return offset;
  };
  if (isFixedSize2(encoder)) {
    return createEncoder2({ ...encoder, fixedSize: encoder.fixedSize + sentinel.length, write });
  }
  return createEncoder2({
    ...encoder,
    ...encoder.maxSize != null ? { maxSize: encoder.maxSize + sentinel.length } : {},
    getSizeFromValue: (value) => encoder.getSizeFromValue(value) + sentinel.length,
    write
  });
}
function addDecoderSentinel(decoder, sentinel) {
  const read = (bytes, offset) => {
    const candidateBytes = offset === 0 ? bytes : bytes.slice(offset);
    const sentinelIndex = findSentinelIndex(candidateBytes, sentinel);
    if (sentinelIndex === -1) {
      throw new SolanaError2(SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES2, {
        decodedBytes: candidateBytes,
        hexDecodedBytes: hexBytes(candidateBytes),
        hexSentinel: hexBytes(sentinel),
        sentinel
      });
    }
    const preSentinelBytes = candidateBytes.slice(0, sentinelIndex);
    return [decoder.decode(preSentinelBytes), offset + preSentinelBytes.length + sentinel.length];
  };
  if (isFixedSize2(decoder)) {
    return createDecoder2({ ...decoder, fixedSize: decoder.fixedSize + sentinel.length, read });
  }
  return createDecoder2({
    ...decoder,
    ...decoder.maxSize != null ? { maxSize: decoder.maxSize + sentinel.length } : {},
    read
  });
}
function addCodecSentinel(codec, sentinel) {
  return combineCodec2(addEncoderSentinel(codec, sentinel), addDecoderSentinel(codec, sentinel));
}
function findSentinelIndex(bytes, sentinel) {
  return bytes.findIndex((byte, index, arr) => {
    if (sentinel.length === 1)
      return byte === sentinel[0];
    return containsBytes(arr, sentinel, index);
  });
}
function hexBytes(bytes) {
  return bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, "0"), "");
}
function assertByteArrayIsNotEmptyForCodec(codecDescription, bytes, offset = 0) {
  if (bytes.length - offset <= 0) {
    throw new SolanaError2(SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY2, {
      codecDescription
    });
  }
}
function assertByteArrayHasEnoughBytesForCodec2(codecDescription, expected, bytes, offset = 0) {
  const bytesLength = bytes.length - offset;
  if (bytesLength < expected) {
    throw new SolanaError2(SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH2, {
      bytesLength,
      codecDescription,
      expected
    });
  }
}
function assertByteArrayOffsetIsNotOutOfRange(codecDescription, offset, bytesLength) {
  if (offset < 0 || offset > bytesLength) {
    throw new SolanaError2(SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE2, {
      bytesLength,
      codecDescription,
      offset
    });
  }
}
function addEncoderSizePrefix(encoder, prefix) {
  const write = (value, bytes, offset) => {
    const encoderBytes = encoder.encode(value);
    offset = prefix.write(encoderBytes.length, bytes, offset);
    bytes.set(encoderBytes, offset);
    return offset + encoderBytes.length;
  };
  if (isFixedSize2(prefix) && isFixedSize2(encoder)) {
    return createEncoder2({ ...encoder, fixedSize: prefix.fixedSize + encoder.fixedSize, write });
  }
  const prefixMaxSize = isFixedSize2(prefix) ? prefix.fixedSize : prefix.maxSize ?? null;
  const encoderMaxSize = isFixedSize2(encoder) ? encoder.fixedSize : encoder.maxSize ?? null;
  const maxSize = prefixMaxSize !== null && encoderMaxSize !== null ? prefixMaxSize + encoderMaxSize : null;
  return createEncoder2({
    ...encoder,
    ...maxSize !== null ? { maxSize } : {},
    getSizeFromValue: (value) => {
      const encoderSize = getEncodedSize2(value, encoder);
      return getEncodedSize2(encoderSize, prefix) + encoderSize;
    },
    write
  });
}
function addDecoderSizePrefix(decoder, prefix) {
  const read = (bytes, offset) => {
    const [bigintSize, decoderOffset] = prefix.read(bytes, offset);
    const size = Number(bigintSize);
    offset = decoderOffset;
    if (offset > 0 || bytes.length > size) {
      bytes = bytes.slice(offset, offset + size);
    }
    assertByteArrayHasEnoughBytesForCodec2("addDecoderSizePrefix", size, bytes);
    return [decoder.decode(bytes), offset + size];
  };
  if (isFixedSize2(prefix) && isFixedSize2(decoder)) {
    return createDecoder2({ ...decoder, fixedSize: prefix.fixedSize + decoder.fixedSize, read });
  }
  const prefixMaxSize = isFixedSize2(prefix) ? prefix.fixedSize : prefix.maxSize ?? null;
  const decoderMaxSize = isFixedSize2(decoder) ? decoder.fixedSize : decoder.maxSize ?? null;
  const maxSize = prefixMaxSize !== null && decoderMaxSize !== null ? prefixMaxSize + decoderMaxSize : null;
  return createDecoder2({ ...decoder, ...maxSize !== null ? { maxSize } : {}, read });
}
function addCodecSizePrefix(codec, prefix) {
  return combineCodec2(addEncoderSizePrefix(codec, prefix), addDecoderSizePrefix(codec, prefix));
}
function createDecoderThatConsumesEntireByteArray(decoder) {
  return createDecoder2({
    ...decoder,
    read(bytes, offset) {
      const [value, newOffset] = decoder.read(bytes, offset);
      if (bytes.length > newOffset) {
        throw new SolanaError2(SOLANA_ERROR__CODECS__EXPECTED_DECODER_TO_CONSUME_ENTIRE_BYTE_ARRAY2, {
          expectedLength: newOffset,
          numExcessBytes: bytes.length - newOffset
        });
      }
      return [value, newOffset];
    }
  });
}
function fixEncoderSize2(encoder, fixedBytes) {
  return createEncoder2({
    fixedSize: fixedBytes,
    write: (value, bytes, offset) => {
      const variableByteArray = encoder.encode(value);
      const fixedByteArray = variableByteArray.length > fixedBytes ? variableByteArray.slice(0, fixedBytes) : variableByteArray;
      bytes.set(fixedByteArray, offset);
      return offset + fixedBytes;
    }
  });
}
function fixDecoderSize2(decoder, fixedBytes) {
  return createDecoder2({
    fixedSize: fixedBytes,
    read: (bytes, offset) => {
      assertByteArrayHasEnoughBytesForCodec2("fixCodecSize", fixedBytes, bytes, offset);
      if (offset > 0 || bytes.length > fixedBytes) {
        bytes = bytes.slice(offset, offset + fixedBytes);
      }
      if (isFixedSize2(decoder)) {
        bytes = fixBytes2(bytes, decoder.fixedSize);
      }
      const [value] = decoder.read(bytes, 0);
      return [value, offset + fixedBytes];
    }
  });
}
function fixCodecSize(codec, fixedBytes) {
  return combineCodec2(fixEncoderSize2(codec, fixedBytes), fixDecoderSize2(codec, fixedBytes));
}
function offsetEncoder(encoder, config) {
  return createEncoder2({
    ...encoder,
    write: (value, bytes, preOffset) => {
      const wrapBytes = (offset) => modulo(offset, bytes.length);
      const newPreOffset = config.preOffset ? config.preOffset({ bytes, preOffset, wrapBytes }) : preOffset;
      assertByteArrayOffsetIsNotOutOfRange("offsetEncoder", newPreOffset, bytes.length);
      const postOffset = encoder.write(value, bytes, newPreOffset);
      const newPostOffset = config.postOffset ? config.postOffset({ bytes, newPreOffset, postOffset, preOffset, wrapBytes }) : postOffset;
      assertByteArrayOffsetIsNotOutOfRange("offsetEncoder", newPostOffset, bytes.length);
      return newPostOffset;
    }
  });
}
function offsetDecoder(decoder, config) {
  return createDecoder2({
    ...decoder,
    read: (bytes, preOffset) => {
      const wrapBytes = (offset) => modulo(offset, bytes.length);
      const newPreOffset = config.preOffset ? config.preOffset({ bytes, preOffset, wrapBytes }) : preOffset;
      assertByteArrayOffsetIsNotOutOfRange("offsetDecoder", newPreOffset, bytes.length);
      const [value, postOffset] = decoder.read(bytes, newPreOffset);
      const newPostOffset = config.postOffset ? config.postOffset({ bytes, newPreOffset, postOffset, preOffset, wrapBytes }) : postOffset;
      assertByteArrayOffsetIsNotOutOfRange("offsetDecoder", newPostOffset, bytes.length);
      return [value, newPostOffset];
    }
  });
}
function offsetCodec(codec, config) {
  return combineCodec2(offsetEncoder(codec, config), offsetDecoder(codec, config));
}
function modulo(dividend, divisor) {
  if (divisor === 0)
    return 0;
  return (dividend % divisor + divisor) % divisor;
}
function resizeEncoder(encoder, resize) {
  if (isFixedSize2(encoder)) {
    const fixedSize = resize(encoder.fixedSize);
    if (fixedSize < 0) {
      throw new SolanaError2(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH2, {
        bytesLength: fixedSize,
        codecDescription: "resizeEncoder"
      });
    }
    return createEncoder2({ ...encoder, fixedSize });
  }
  return createEncoder2({
    ...encoder,
    getSizeFromValue: (value) => {
      const newSize = resize(encoder.getSizeFromValue(value));
      if (newSize < 0) {
        throw new SolanaError2(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH2, {
          bytesLength: newSize,
          codecDescription: "resizeEncoder"
        });
      }
      return newSize;
    }
  });
}
function resizeDecoder(decoder, resize) {
  if (isFixedSize2(decoder)) {
    const fixedSize = resize(decoder.fixedSize);
    if (fixedSize < 0) {
      throw new SolanaError2(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH2, {
        bytesLength: fixedSize,
        codecDescription: "resizeDecoder"
      });
    }
    return createDecoder2({ ...decoder, fixedSize });
  }
  return decoder;
}
function resizeCodec(codec, resize) {
  return combineCodec2(resizeEncoder(codec, resize), resizeDecoder(codec, resize));
}
function padLeftEncoder(encoder, offset) {
  return offsetEncoder(resizeEncoder(encoder, (size) => size + offset), { preOffset: ({ preOffset }) => preOffset + offset });
}
function padRightEncoder(encoder, offset) {
  return offsetEncoder(resizeEncoder(encoder, (size) => size + offset), { postOffset: ({ postOffset }) => postOffset + offset });
}
function padLeftDecoder(decoder, offset) {
  return offsetDecoder(resizeDecoder(decoder, (size) => size + offset), { preOffset: ({ preOffset }) => preOffset + offset });
}
function padRightDecoder(decoder, offset) {
  return offsetDecoder(resizeDecoder(decoder, (size) => size + offset), { postOffset: ({ postOffset }) => postOffset + offset });
}
function padLeftCodec(codec, offset) {
  return combineCodec2(padLeftEncoder(codec, offset), padLeftDecoder(codec, offset));
}
function padRightCodec(codec, offset) {
  return combineCodec2(padRightEncoder(codec, offset), padRightDecoder(codec, offset));
}
function copySourceToTargetInReverse(source, target_WILL_MUTATE, sourceOffset, sourceLength, targetOffset = 0) {
  while (sourceOffset < --sourceLength) {
    const leftValue = source[sourceOffset];
    target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceLength];
    target_WILL_MUTATE[sourceLength + targetOffset] = leftValue;
    sourceOffset++;
  }
  if (sourceOffset === sourceLength) {
    target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceOffset];
  }
}
function reverseEncoder(encoder) {
  assertIsFixedSize(encoder);
  return createEncoder2({
    ...encoder,
    write: (value, bytes, offset) => {
      const newOffset = encoder.write(value, bytes, offset);
      copySourceToTargetInReverse(bytes, bytes, offset, offset + encoder.fixedSize);
      return newOffset;
    }
  });
}
function reverseDecoder(decoder) {
  assertIsFixedSize(decoder);
  return createDecoder2({
    ...decoder,
    read: (bytes, offset) => {
      const reversedBytes = bytes.slice();
      copySourceToTargetInReverse(bytes, reversedBytes, offset, offset + decoder.fixedSize);
      return decoder.read(reversedBytes, offset);
    }
  });
}
function reverseCodec(codec) {
  return combineCodec2(reverseEncoder(codec), reverseDecoder(codec));
}
function transformEncoder2(encoder, unmap) {
  return createEncoder2({
    ...isVariableSize2(encoder) ? { ...encoder, getSizeFromValue: (value) => encoder.getSizeFromValue(unmap(value)) } : encoder,
    write: (value, bytes, offset) => encoder.write(unmap(value), bytes, offset)
  });
}
function transformDecoder(decoder, map) {
  return createDecoder2({
    ...decoder,
    read: (bytes, offset) => {
      const [value, newOffset] = decoder.read(bytes, offset);
      return [map(value, bytes, offset), newOffset];
    }
  });
}
function transformCodec(codec, unmap, map) {
  return createCodec({
    ...transformEncoder2(codec, unmap),
    read: map ? transformDecoder(codec, map).read : codec.read
  });
}
var mergeBytes = (byteArrays) => {
  const nonEmptyByteArrays = byteArrays.filter((arr) => arr.length);
  if (nonEmptyByteArrays.length === 0) {
    return byteArrays.length ? byteArrays[0] : new Uint8Array;
  }
  if (nonEmptyByteArrays.length === 1) {
    return nonEmptyByteArrays[0];
  }
  const totalLength = nonEmptyByteArrays.reduce((total, arr) => total + arr.length, 0);
  const result = new Uint8Array(totalLength);
  let offset = 0;
  nonEmptyByteArrays.forEach((arr) => {
    result.set(arr, offset);
    offset += arr.length;
  });
  return result;
}, fixBytes2 = (bytes, length) => padBytes2(bytes.length <= length ? bytes : bytes.slice(0, length), length);
var init_index_node7 = __esm(() => {
  init_index_node6();
});

// ../../node_modules/.bun/@solana+codecs-strings@5.1.0+7f9e3d21594a24ff/node_modules/@solana/codecs-strings/dist/index.node.mjs
function assertValidBaseString2(alphabet4, testValue, givenValue = testValue) {
  if (!testValue.match(new RegExp(`^[${alphabet4}]*$`))) {
    throw new SolanaError2(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE2, {
      alphabet: alphabet4,
      base: alphabet4.length,
      value: givenValue
    });
  }
}
function partitionLeadingZeroes2(value, zeroCharacter) {
  const [leadingZeros, tailChars] = value.split(new RegExp(`((?!${zeroCharacter}).*)`));
  return [leadingZeros, tailChars];
}
function getBigIntFromBaseX2(value, alphabet4) {
  const base = BigInt(alphabet4.length);
  let sum = 0n;
  for (const char of value) {
    sum *= base;
    sum += BigInt(alphabet4.indexOf(char));
  }
  return sum;
}
function getBaseXFromBigInt2(value, alphabet4) {
  const base = BigInt(alphabet4.length);
  const tailChars = [];
  while (value > 0n) {
    tailChars.unshift(alphabet4[Number(value % base)]);
    value /= base;
  }
  return tailChars.join("");
}
function charCodeToBase16(char) {
  if (char >= 48 && char <= 57)
    return char - 48;
  if (char >= 65 && char <= 70)
    return char - (65 - 10);
  if (char >= 97 && char <= 102)
    return char - (97 - 10);
}
function reslice(input, inputBits, outputBits, useRemainder) {
  const output = [];
  let accumulator = 0;
  let bitsInAccumulator = 0;
  const mask = (1 << outputBits) - 1;
  for (const value of input) {
    accumulator = accumulator << inputBits | value;
    bitsInAccumulator += inputBits;
    while (bitsInAccumulator >= outputBits) {
      bitsInAccumulator -= outputBits;
      output.push(accumulator >> bitsInAccumulator & mask);
    }
  }
  if (useRemainder && bitsInAccumulator > 0) {
    output.push(accumulator << outputBits - bitsInAccumulator & mask);
  }
  return output;
}
var getBaseXEncoder2 = (alphabet4) => {
  return createEncoder2({
    getSizeFromValue: (value) => {
      const [leadingZeroes, tailChars] = partitionLeadingZeroes2(value, alphabet4[0]);
      if (!tailChars)
        return value.length;
      const base10Number = getBigIntFromBaseX2(tailChars, alphabet4);
      return leadingZeroes.length + Math.ceil(base10Number.toString(16).length / 2);
    },
    write(value, bytes, offset) {
      assertValidBaseString2(alphabet4, value);
      if (value === "")
        return offset;
      const [leadingZeroes, tailChars] = partitionLeadingZeroes2(value, alphabet4[0]);
      if (!tailChars) {
        bytes.set(new Uint8Array(leadingZeroes.length).fill(0), offset);
        return offset + leadingZeroes.length;
      }
      let base10Number = getBigIntFromBaseX2(tailChars, alphabet4);
      const tailBytes = [];
      while (base10Number > 0n) {
        tailBytes.unshift(Number(base10Number % 256n));
        base10Number /= 256n;
      }
      const bytesToAdd = [...Array(leadingZeroes.length).fill(0), ...tailBytes];
      bytes.set(bytesToAdd, offset);
      return offset + bytesToAdd.length;
    }
  });
}, getBaseXDecoder2 = (alphabet4) => {
  return createDecoder2({
    read(rawBytes, offset) {
      const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);
      if (bytes.length === 0)
        return ["", 0];
      let trailIndex = bytes.findIndex((n) => n !== 0);
      trailIndex = trailIndex === -1 ? bytes.length : trailIndex;
      const leadingZeroes = alphabet4[0].repeat(trailIndex);
      if (trailIndex === bytes.length)
        return [leadingZeroes, rawBytes.length];
      const base10Number = bytes.slice(trailIndex).reduce((sum, byte) => sum * 256n + BigInt(byte), 0n);
      const tailChars = getBaseXFromBigInt2(base10Number, alphabet4);
      return [leadingZeroes + tailChars, rawBytes.length];
    }
  });
}, getBaseXCodec = (alphabet4) => combineCodec2(getBaseXEncoder2(alphabet4), getBaseXDecoder2(alphabet4)), alphabet = "0123456789", getBase10Encoder = () => getBaseXEncoder2(alphabet), getBase10Decoder = () => getBaseXDecoder2(alphabet), getBase10Codec = () => getBaseXCodec(alphabet), INVALID_STRING_ERROR_BASE_CONFIG, getBase16Encoder = () => createEncoder2({
  getSizeFromValue: (value) => Math.ceil(value.length / 2),
  write(value, bytes, offset) {
    const len = value.length;
    const al = len / 2;
    if (len === 1) {
      const c = value.charCodeAt(0);
      const n = charCodeToBase16(c);
      if (n === undefined) {
        throw new SolanaError2(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE2, {
          ...INVALID_STRING_ERROR_BASE_CONFIG,
          value
        });
      }
      bytes.set([n], offset);
      return 1 + offset;
    }
    const hexBytes2 = new Uint8Array(al);
    for (let i = 0, j = 0;i < al; i++) {
      const c1 = value.charCodeAt(j++);
      const c2 = value.charCodeAt(j++);
      const n1 = charCodeToBase16(c1);
      const n2 = charCodeToBase16(c2);
      if (n1 === undefined || n2 === undefined && !Number.isNaN(c2)) {
        throw new SolanaError2(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE2, {
          ...INVALID_STRING_ERROR_BASE_CONFIG,
          value
        });
      }
      hexBytes2[i] = !Number.isNaN(c2) ? n1 << 4 | (n2 ?? 0) : n1;
    }
    bytes.set(hexBytes2, offset);
    return hexBytes2.length + offset;
  }
}), getBase16Decoder = () => createDecoder2({
  read(bytes, offset) {
    const value = bytes.slice(offset).reduce((str, byte) => str + byte.toString(16).padStart(2, "0"), "");
    return [value, bytes.length];
  }
}), getBase16Codec = () => combineCodec2(getBase16Encoder(), getBase16Decoder()), alphabet22 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz", getBase58Encoder2 = () => getBaseXEncoder2(alphabet22), getBase58Decoder2 = () => getBaseXDecoder2(alphabet22), getBase58Codec = () => getBaseXCodec(alphabet22), getBaseXResliceEncoder = (alphabet4, bits) => createEncoder2({
  getSizeFromValue: (value) => Math.floor(value.length * bits / 8),
  write(value, bytes, offset) {
    assertValidBaseString2(alphabet4, value);
    if (value === "")
      return offset;
    const charIndices = [...value].map((c) => alphabet4.indexOf(c));
    const reslicedBytes = reslice(charIndices, bits, 8, false);
    bytes.set(reslicedBytes, offset);
    return reslicedBytes.length + offset;
  }
}), getBaseXResliceDecoder = (alphabet4, bits) => createDecoder2({
  read(rawBytes, offset = 0) {
    const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);
    if (bytes.length === 0)
      return ["", rawBytes.length];
    const charIndices = reslice([...bytes], 8, bits, true);
    return [charIndices.map((i) => alphabet4[i]).join(""), rawBytes.length];
  }
}), getBaseXResliceCodec = (alphabet4, bits) => combineCodec2(getBaseXResliceEncoder(alphabet4, bits), getBaseXResliceDecoder(alphabet4, bits)), alphabet3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", getBase64Encoder = () => {
  {
    return createEncoder2({
      getSizeFromValue: (value) => Buffer.from(value, "base64").length,
      write(value, bytes, offset) {
        assertValidBaseString2(alphabet3, value.replace(/=/g, ""));
        const buffer = Buffer.from(value, "base64");
        bytes.set(buffer, offset);
        return buffer.length + offset;
      }
    });
  }
}, getBase64Decoder = () => {
  {
    return createDecoder2({
      read: (bytes, offset = 0) => [Buffer.from(bytes, offset).toString("base64"), bytes.length]
    });
  }
}, getBase64Codec = () => combineCodec2(getBase64Encoder(), getBase64Decoder()), removeNullCharacters = (value) => value.replace(/\u0000/g, ""), padNullCharacters = (value, chars) => value.padEnd(chars, "\x00"), e2, o2, getUtf8Encoder = () => {
  let textEncoder;
  return createEncoder2({
    getSizeFromValue: (value) => (textEncoder ||= new o2).encode(value).length,
    write: (value, bytes, offset) => {
      const bytesToAdd = (textEncoder ||= new o2).encode(value);
      bytes.set(bytesToAdd, offset);
      return offset + bytesToAdd.length;
    }
  });
}, getUtf8Decoder = () => {
  let textDecoder;
  return createDecoder2({
    read(bytes, offset) {
      const value = (textDecoder ||= new e2).decode(bytes.slice(offset));
      return [removeNullCharacters(value), bytes.length];
    }
  });
}, getUtf8Codec = () => combineCodec2(getUtf8Encoder(), getUtf8Decoder());
var init_index_node8 = __esm(() => {
  init_index_node6();
  init_index_node7();
  INVALID_STRING_ERROR_BASE_CONFIG = {
    alphabet: "0123456789abcdef",
    base: 16
  };
  e2 = globalThis.TextDecoder;
  o2 = globalThis.TextEncoder;
});

// ../../node_modules/.bun/@solana+accounts@5.1.0+7f9e3d21594a24ff/node_modules/@solana/accounts/dist/index.node.mjs
function decodeAccount(encodedAccount, decoder) {
  try {
    if ("exists" in encodedAccount && !encodedAccount.exists) {
      return encodedAccount;
    }
    return Object.freeze({ ...encodedAccount, data: decoder.decode(encodedAccount.data) });
  } catch {
    throw new SolanaError2(SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT2, {
      address: encodedAccount.address
    });
  }
}
function accountExists(account) {
  return !("exists" in account) || "exists" in account && account.exists;
}
function assertAccountDecoded(account) {
  if (accountExists(account) && account.data instanceof Uint8Array) {
    throw new SolanaError2(SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT2, {
      address: account.address
    });
  }
}
function assertAccountsDecoded(accounts) {
  const encoded = accounts.filter((a) => accountExists(a) && a.data instanceof Uint8Array);
  if (encoded.length > 0) {
    const encodedAddresses = encoded.map((a) => a.address);
    throw new SolanaError2(SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED2, {
      addresses: encodedAddresses
    });
  }
}
function parseBase64RpcAccount(address2, rpcAccount) {
  if (!rpcAccount)
    return Object.freeze({ address: address2, exists: false });
  const data = getBase64Encoder().encode(rpcAccount.data[0]);
  return Object.freeze({ ...parseBaseAccount(rpcAccount), address: address2, data, exists: true });
}
function parseBase58RpcAccount(address2, rpcAccount) {
  if (!rpcAccount)
    return Object.freeze({ address: address2, exists: false });
  const data = getBase58Encoder2().encode(typeof rpcAccount.data === "string" ? rpcAccount.data : rpcAccount.data[0]);
  return Object.freeze({ ...parseBaseAccount(rpcAccount), address: address2, data, exists: true });
}
function parseJsonRpcAccount(address2, rpcAccount) {
  if (!rpcAccount)
    return Object.freeze({ address: address2, exists: false });
  const data = rpcAccount.data.parsed.info;
  return Object.freeze({ ...parseBaseAccount(rpcAccount), address: address2, data, exists: true });
}
function parseBaseAccount(rpcAccount) {
  return Object.freeze({
    executable: rpcAccount.executable,
    lamports: rpcAccount.lamports,
    programAddress: rpcAccount.owner,
    space: rpcAccount.space
  });
}
async function fetchEncodedAccount(rpc, address2, config = {}) {
  const { abortSignal, ...rpcConfig } = config;
  const response = await rpc.getAccountInfo(address2, { ...rpcConfig, encoding: "base64" }).send({ abortSignal });
  return parseBase64RpcAccount(address2, response.value);
}
async function fetchJsonParsedAccount(rpc, address2, config = {}) {
  const { abortSignal, ...rpcConfig } = config;
  const { value: account } = await rpc.getAccountInfo(address2, { ...rpcConfig, encoding: "jsonParsed" }).send({ abortSignal });
  return !!account && typeof account === "object" && "parsed" in account.data ? parseJsonRpcAccount(address2, account) : parseBase64RpcAccount(address2, account);
}
async function fetchEncodedAccounts(rpc, addresses, config = {}) {
  const { abortSignal, ...rpcConfig } = config;
  const response = await rpc.getMultipleAccounts(addresses, { ...rpcConfig, encoding: "base64" }).send({ abortSignal });
  return response.value.map((account, index) => parseBase64RpcAccount(addresses[index], account));
}
async function fetchJsonParsedAccounts(rpc, addresses, config = {}) {
  const { abortSignal, ...rpcConfig } = config;
  const response = await rpc.getMultipleAccounts(addresses, { ...rpcConfig, encoding: "jsonParsed" }).send({ abortSignal });
  return response.value.map((account, index) => {
    return !!account && typeof account === "object" && "parsed" in account.data ? parseJsonRpcAccount(addresses[index], account) : parseBase64RpcAccount(addresses[index], account);
  });
}
function assertAccountExists(account) {
  if (!account.exists) {
    throw new SolanaError2(SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND2, { address: account.address });
  }
}
function assertAccountsExist(accounts) {
  const missingAccounts = accounts.filter((a) => !a.exists);
  if (missingAccounts.length > 0) {
    const missingAddresses = missingAccounts.map((a) => a.address);
    throw new SolanaError2(SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND2, { addresses: missingAddresses });
  }
}
var BASE_ACCOUNT_SIZE = 128;
var init_index_node9 = __esm(() => {
  init_index_node6();
  init_index_node8();
});

// ../../node_modules/.bun/@solana+assertions@5.1.0+1fb4c65d43e298b9/node_modules/@solana/assertions/dist/index.node.mjs
function assertPRNGIsAvailable() {
  if (typeof globalThis.crypto === "undefined" || typeof globalThis.crypto.getRandomValues !== "function") {
    throw new SolanaError2(SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED2);
  }
}
async function isEd25519CurveSupported(subtle) {
  if (cachedEd25519Decision === undefined) {
    cachedEd25519Decision = new Promise((resolve) => {
      subtle.generateKey("Ed25519", false, ["sign", "verify"]).then(() => {
        resolve(cachedEd25519Decision = true);
      }).catch(() => {
        resolve(cachedEd25519Decision = false);
      });
    });
  }
  if (typeof cachedEd25519Decision === "boolean") {
    return cachedEd25519Decision;
  } else {
    return await cachedEd25519Decision;
  }
}
function assertDigestCapabilityIsAvailable2() {
  if (typeof globalThis.crypto === "undefined" || typeof globalThis.crypto.subtle?.digest !== "function") {
    throw new SolanaError2(SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED2);
  }
}
async function assertKeyGenerationIsAvailable() {
  if (typeof globalThis.crypto === "undefined" || typeof globalThis.crypto.subtle?.generateKey !== "function") {
    throw new SolanaError2(SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED2);
  }
  if (!await isEd25519CurveSupported(globalThis.crypto.subtle)) {
    throw new SolanaError2(SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED2);
  }
}
function assertKeyExporterIsAvailable2() {
  if (typeof globalThis.crypto === "undefined" || typeof globalThis.crypto.subtle?.exportKey !== "function") {
    throw new SolanaError2(SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED2);
  }
}
function assertSigningCapabilityIsAvailable() {
  if (typeof globalThis.crypto === "undefined" || typeof globalThis.crypto.subtle?.sign !== "function") {
    throw new SolanaError2(SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED2);
  }
}
function assertVerificationCapabilityIsAvailable() {
  if (typeof globalThis.crypto === "undefined" || typeof globalThis.crypto.subtle?.verify !== "function") {
    throw new SolanaError2(SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED2);
  }
}
var cachedEd25519Decision;
var init_index_node10 = __esm(() => {
  init_index_node6();
});

// ../../node_modules/.bun/@solana+addresses@5.1.0+7f9e3d21594a24ff/node_modules/@solana/addresses/dist/index.node.mjs
function getMemoizedBase58Encoder2() {
  if (!memoizedBase58Encoder2)
    memoizedBase58Encoder2 = getBase58Encoder2();
  return memoizedBase58Encoder2;
}
function getMemoizedBase58Decoder2() {
  if (!memoizedBase58Decoder2)
    memoizedBase58Decoder2 = getBase58Decoder2();
  return memoizedBase58Decoder2;
}
function isAddress2(putativeAddress) {
  if (putativeAddress.length < 32 || putativeAddress.length > 44) {
    return false;
  }
  const base58Encoder = getMemoizedBase58Encoder2();
  try {
    return base58Encoder.encode(putativeAddress).byteLength === 32;
  } catch {
    return false;
  }
}
function assertIsAddress2(putativeAddress) {
  if (putativeAddress.length < 32 || putativeAddress.length > 44) {
    throw new SolanaError2(SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE2, {
      actualLength: putativeAddress.length
    });
  }
  const base58Encoder = getMemoizedBase58Encoder2();
  const bytes = base58Encoder.encode(putativeAddress);
  const numBytes = bytes.byteLength;
  if (numBytes !== 32) {
    throw new SolanaError2(SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH2, {
      actualLength: numBytes
    });
  }
}
function address2(putativeAddress) {
  assertIsAddress2(putativeAddress);
  return putativeAddress;
}
function getAddressEncoder2() {
  return transformEncoder2(fixEncoderSize2(getMemoizedBase58Encoder2(), 32), (putativeAddress) => address2(putativeAddress));
}
function getAddressDecoder2() {
  return fixDecoderSize2(getMemoizedBase58Decoder2(), 32);
}
function getAddressCodec2() {
  return combineCodec2(getAddressEncoder2(), getAddressDecoder2());
}
function getAddressComparator2() {
  return new Intl.Collator("en", {
    caseFirst: "lower",
    ignorePunctuation: false,
    localeMatcher: "best fit",
    numeric: false,
    sensitivity: "variant",
    usage: "sort"
  }).compare;
}
function mod2(a) {
  const r = a % P2;
  return r >= 0n ? r : P2 + r;
}
function pow22(x, power) {
  let r = x;
  while (power-- > 0n) {
    r *= r;
    r %= P2;
  }
  return r;
}
function pow_2_252_32(x) {
  const x2 = x * x % P2;
  const b2 = x2 * x % P2;
  const b4 = pow22(b2, 2n) * b2 % P2;
  const b5 = pow22(b4, 1n) * x % P2;
  const b10 = pow22(b5, 5n) * b5 % P2;
  const b20 = pow22(b10, 10n) * b10 % P2;
  const b40 = pow22(b20, 20n) * b20 % P2;
  const b80 = pow22(b40, 40n) * b40 % P2;
  const b160 = pow22(b80, 80n) * b80 % P2;
  const b240 = pow22(b160, 80n) * b80 % P2;
  const b250 = pow22(b240, 10n) * b10 % P2;
  const pow_p_5_8 = pow22(b250, 2n) * x % P2;
  return pow_p_5_8;
}
function uvRatio2(u, v) {
  const v3 = mod2(v * v * v);
  const v7 = mod2(v3 * v3 * v);
  const pow = pow_2_252_32(u * v7);
  let x = mod2(u * v3 * pow);
  const vx2 = mod2(v * x * x);
  const root1 = x;
  const root2 = mod2(x * RM12);
  const useRoot1 = vx2 === u;
  const useRoot2 = vx2 === mod2(-u);
  const noRoot = vx2 === mod2(-u * RM12);
  if (useRoot1)
    x = root1;
  if (useRoot2 || noRoot)
    x = root2;
  if ((mod2(x) & 1n) === 1n)
    x = mod2(-x);
  if (!useRoot1 && !useRoot2) {
    return null;
  }
  return x;
}
function pointIsOnCurve2(y, lastByte) {
  const y2 = mod2(y * y);
  const u = mod2(y2 - 1n);
  const v = mod2(D2 * y2 + 1n);
  const x = uvRatio2(u, v);
  if (x === null) {
    return false;
  }
  const isLastByteOdd = (lastByte & 128) !== 0;
  if (x === 0n && isLastByteOdd) {
    return false;
  }
  return true;
}
function byteToHex2(byte) {
  const hexString = byte.toString(16);
  if (hexString.length === 1) {
    return `0${hexString}`;
  } else {
    return hexString;
  }
}
function decompressPointBytes2(bytes) {
  const hexString = bytes.reduce((acc, byte, ii) => `${byteToHex2(ii === 31 ? byte & -129 : byte)}${acc}`, "");
  const integerLiteralString = `0x${hexString}`;
  return BigInt(integerLiteralString);
}
function compressedPointBytesAreOnCurve2(bytes) {
  if (bytes.byteLength !== 32) {
    return false;
  }
  const y = decompressPointBytes2(bytes);
  return pointIsOnCurve2(y, bytes[31]);
}
function isOffCurveAddress2(putativeOffCurveAddress) {
  const addressBytes = getAddressCodec2().encode(putativeOffCurveAddress);
  return compressedPointBytesAreOnCurve2(addressBytes) === false;
}
function assertIsOffCurveAddress2(putativeOffCurveAddress) {
  if (!isOffCurveAddress2(putativeOffCurveAddress)) {
    throw new SolanaError2(SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS2);
  }
}
function offCurveAddress2(putativeOffCurveAddress) {
  assertIsOffCurveAddress2(putativeOffCurveAddress);
  return putativeOffCurveAddress;
}
function isProgramDerivedAddress2(value) {
  return Array.isArray(value) && value.length === 2 && typeof value[0] === "string" && typeof value[1] === "number" && value[1] >= 0 && value[1] <= 255 && isAddress2(value[0]);
}
function assertIsProgramDerivedAddress2(value) {
  const validFormat = Array.isArray(value) && value.length === 2 && typeof value[0] === "string" && typeof value[1] === "number";
  if (!validFormat) {
    throw new SolanaError2(SOLANA_ERROR__ADDRESSES__MALFORMED_PDA2);
  }
  if (value[1] < 0 || value[1] > 255) {
    throw new SolanaError2(SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE2, {
      bump: value[1]
    });
  }
  assertIsAddress2(value[0]);
}
async function createProgramDerivedAddress2({ programAddress, seeds }) {
  assertDigestCapabilityIsAvailable2();
  if (seeds.length > MAX_SEEDS2) {
    throw new SolanaError2(SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED2, {
      actual: seeds.length,
      maxSeeds: MAX_SEEDS2
    });
  }
  let textEncoder;
  const seedBytes = seeds.reduce((acc, seed, ii) => {
    const bytes = typeof seed === "string" ? (textEncoder ||= new TextEncoder).encode(seed) : seed;
    if (bytes.byteLength > MAX_SEED_LENGTH2) {
      throw new SolanaError2(SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED2, {
        actual: bytes.byteLength,
        index: ii,
        maxSeedLength: MAX_SEED_LENGTH2
      });
    }
    acc.push(...bytes);
    return acc;
  }, []);
  const base58EncodedAddressCodec = getAddressCodec2();
  const programAddressBytes = base58EncodedAddressCodec.encode(programAddress);
  const addressBytesBuffer = await crypto.subtle.digest("SHA-256", new Uint8Array([...seedBytes, ...programAddressBytes, ...PDA_MARKER_BYTES2]));
  const addressBytes = new Uint8Array(addressBytesBuffer);
  if (compressedPointBytesAreOnCurve2(addressBytes)) {
    throw new SolanaError2(SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE2);
  }
  return base58EncodedAddressCodec.decode(addressBytes);
}
async function getProgramDerivedAddress2({
  programAddress,
  seeds
}) {
  let bumpSeed = 255;
  while (bumpSeed > 0) {
    try {
      const address22 = await createProgramDerivedAddress2({
        programAddress,
        seeds: [...seeds, new Uint8Array([bumpSeed])]
      });
      return [address22, bumpSeed];
    } catch (e3) {
      if (isSolanaError2(e3, SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE2)) {
        bumpSeed--;
      } else {
        throw e3;
      }
    }
  }
  throw new SolanaError2(SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED2);
}
async function createAddressWithSeed2({ baseAddress, programAddress, seed }) {
  const { encode, decode } = getAddressCodec2();
  const seedBytes = typeof seed === "string" ? new TextEncoder().encode(seed) : seed;
  if (seedBytes.byteLength > MAX_SEED_LENGTH2) {
    throw new SolanaError2(SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED2, {
      actual: seedBytes.byteLength,
      index: 0,
      maxSeedLength: MAX_SEED_LENGTH2
    });
  }
  const programAddressBytes = encode(programAddress);
  if (programAddressBytes.length >= PDA_MARKER_BYTES2.length && bytesEqual2(programAddressBytes.slice(-PDA_MARKER_BYTES2.length), new Uint8Array(PDA_MARKER_BYTES2))) {
    throw new SolanaError2(SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER2);
  }
  const addressBytesBuffer = await crypto.subtle.digest("SHA-256", new Uint8Array([...encode(baseAddress), ...seedBytes, ...programAddressBytes]));
  const addressBytes = new Uint8Array(addressBytesBuffer);
  return decode(addressBytes);
}
async function getAddressFromPublicKey2(publicKey) {
  assertKeyExporterIsAvailable2();
  if (publicKey.type !== "public" || publicKey.algorithm.name !== "Ed25519") {
    throw new SolanaError2(SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY2);
  }
  const publicKeyBytes = await crypto.subtle.exportKey("raw", publicKey);
  return getAddressDecoder2().decode(new Uint8Array(publicKeyBytes));
}
async function getPublicKeyFromAddress2(address22) {
  const addressBytes = getAddressEncoder2().encode(address22);
  return await crypto.subtle.importKey("raw", addressBytes, { name: "Ed25519" }, true, ["verify"]);
}
var memoizedBase58Encoder2, memoizedBase58Decoder2, D2 = 37095705934669439343138083508754565189542113879843219016388785533085940283555n, P2 = 57896044618658097711785492504343953926634992332820282019728792003956564819949n, RM12 = 19681161376707505956807079304988542015446066515923890162744021073123829784752n, MAX_SEED_LENGTH2 = 32, MAX_SEEDS2 = 16, PDA_MARKER_BYTES2;
var init_index_node11 = __esm(() => {
  init_index_node7();
  init_index_node8();
  init_index_node6();
  init_index_node10();
  PDA_MARKER_BYTES2 = [
    80,
    114,
    111,
    103,
    114,
    97,
    109,
    68,
    101,
    114,
    105,
    118,
    101,
    100,
    65,
    100,
    100,
    114,
    101,
    115,
    115
  ];
});

// ../../node_modules/.bun/@solana+codecs-numbers@5.1.0+1fb4c65d43e298b9/node_modules/@solana/codecs-numbers/dist/index.node.mjs
function assertNumberIsBetweenForCodec(codecDescription, min, max, value) {
  if (value < min || value > max) {
    throw new SolanaError2(SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE2, {
      codecDescription,
      max,
      min,
      value
    });
  }
}
function isLittleEndian(config) {
  return config?.endian === 1 ? false : true;
}
function numberEncoderFactory(input) {
  return createEncoder2({
    fixedSize: input.size,
    write(value, bytes, offset) {
      if (input.range) {
        assertNumberIsBetweenForCodec(input.name, input.range[0], input.range[1], value);
      }
      const arrayBuffer = new ArrayBuffer(input.size);
      input.set(new DataView(arrayBuffer), value, isLittleEndian(input.config));
      bytes.set(new Uint8Array(arrayBuffer), offset);
      return offset + input.size;
    }
  });
}
function numberDecoderFactory(input) {
  return createDecoder2({
    fixedSize: input.size,
    read(bytes, offset = 0) {
      assertByteArrayIsNotEmptyForCodec(input.name, bytes, offset);
      assertByteArrayHasEnoughBytesForCodec2(input.name, input.size, bytes, offset);
      const view = new DataView(toArrayBuffer2(bytes, offset, input.size));
      return [input.get(view, isLittleEndian(input.config)), offset + input.size];
    }
  });
}
function toArrayBuffer2(bytes, offset, length) {
  const bytesOffset = bytes.byteOffset + (offset ?? 0);
  const bytesLength = length ?? bytes.byteLength;
  return bytes.buffer.slice(bytesOffset, bytesOffset + bytesLength);
}
var Endian, getF32Encoder = (config = {}) => numberEncoderFactory({
  config,
  name: "f32",
  set: (view, value, le) => view.setFloat32(0, Number(value), le),
  size: 4
}), getF32Decoder = (config = {}) => numberDecoderFactory({
  config,
  get: (view, le) => view.getFloat32(0, le),
  name: "f32",
  size: 4
}), getF32Codec = (config = {}) => combineCodec2(getF32Encoder(config), getF32Decoder(config)), getF64Encoder = (config = {}) => numberEncoderFactory({
  config,
  name: "f64",
  set: (view, value, le) => view.setFloat64(0, Number(value), le),
  size: 8
}), getF64Decoder = (config = {}) => numberDecoderFactory({
  config,
  get: (view, le) => view.getFloat64(0, le),
  name: "f64",
  size: 8
}), getF64Codec = (config = {}) => combineCodec2(getF64Encoder(config), getF64Decoder(config)), getI128Encoder = (config = {}) => numberEncoderFactory({
  config,
  name: "i128",
  range: [-BigInt("0x7fffffffffffffffffffffffffffffff") - 1n, BigInt("0x7fffffffffffffffffffffffffffffff")],
  set: (view, value, le) => {
    const leftOffset = le ? 8 : 0;
    const rightOffset = le ? 0 : 8;
    const rightMask = 0xffffffffffffffffn;
    view.setBigInt64(leftOffset, BigInt(value) >> 64n, le);
    view.setBigUint64(rightOffset, BigInt(value) & rightMask, le);
  },
  size: 16
}), getI128Decoder = (config = {}) => numberDecoderFactory({
  config,
  get: (view, le) => {
    const leftOffset = le ? 8 : 0;
    const rightOffset = le ? 0 : 8;
    const left = view.getBigInt64(leftOffset, le);
    const right = view.getBigUint64(rightOffset, le);
    return (left << 64n) + right;
  },
  name: "i128",
  size: 16
}), getI128Codec = (config = {}) => combineCodec2(getI128Encoder(config), getI128Decoder(config)), getI16Encoder = (config = {}) => numberEncoderFactory({
  config,
  name: "i16",
  range: [-Number("0x7fff") - 1, Number("0x7fff")],
  set: (view, value, le) => view.setInt16(0, Number(value), le),
  size: 2
}), getI16Decoder = (config = {}) => numberDecoderFactory({
  config,
  get: (view, le) => view.getInt16(0, le),
  name: "i16",
  size: 2
}), getI16Codec = (config = {}) => combineCodec2(getI16Encoder(config), getI16Decoder(config)), getI32Encoder = (config = {}) => numberEncoderFactory({
  config,
  name: "i32",
  range: [-Number("0x7fffffff") - 1, Number("0x7fffffff")],
  set: (view, value, le) => view.setInt32(0, Number(value), le),
  size: 4
}), getI32Decoder = (config = {}) => numberDecoderFactory({
  config,
  get: (view, le) => view.getInt32(0, le),
  name: "i32",
  size: 4
}), getI32Codec = (config = {}) => combineCodec2(getI32Encoder(config), getI32Decoder(config)), getI64Encoder = (config = {}) => numberEncoderFactory({
  config,
  name: "i64",
  range: [-BigInt("0x7fffffffffffffff") - 1n, BigInt("0x7fffffffffffffff")],
  set: (view, value, le) => view.setBigInt64(0, BigInt(value), le),
  size: 8
}), getI64Decoder = (config = {}) => numberDecoderFactory({
  config,
  get: (view, le) => view.getBigInt64(0, le),
  name: "i64",
  size: 8
}), getI64Codec = (config = {}) => combineCodec2(getI64Encoder(config), getI64Decoder(config)), getI8Encoder = () => numberEncoderFactory({
  name: "i8",
  range: [-Number("0x7f") - 1, Number("0x7f")],
  set: (view, value) => view.setInt8(0, Number(value)),
  size: 1
}), getI8Decoder = () => numberDecoderFactory({
  get: (view) => view.getInt8(0),
  name: "i8",
  size: 1
}), getI8Codec = () => combineCodec2(getI8Encoder(), getI8Decoder()), getShortU16Encoder = () => createEncoder2({
  getSizeFromValue: (value) => {
    if (value <= 127)
      return 1;
    if (value <= 16383)
      return 2;
    return 3;
  },
  maxSize: 3,
  write: (value, bytes, offset) => {
    assertNumberIsBetweenForCodec("shortU16", 0, 65535, value);
    const shortU16Bytes = [0];
    for (let ii = 0;; ii += 1) {
      const alignedValue = Number(value) >> ii * 7;
      if (alignedValue === 0) {
        break;
      }
      const nextSevenBits = 127 & alignedValue;
      shortU16Bytes[ii] = nextSevenBits;
      if (ii > 0) {
        shortU16Bytes[ii - 1] |= 128;
      }
    }
    bytes.set(shortU16Bytes, offset);
    return offset + shortU16Bytes.length;
  }
}), getShortU16Decoder = () => createDecoder2({
  maxSize: 3,
  read: (bytes, offset) => {
    let value = 0;
    let byteCount = 0;
    while (++byteCount) {
      const byteIndex = byteCount - 1;
      const currentByte = bytes[offset + byteIndex];
      const nextSevenBits = 127 & currentByte;
      value |= nextSevenBits << byteIndex * 7;
      if ((currentByte & 128) === 0) {
        break;
      }
    }
    return [value, offset + byteCount];
  }
}), getShortU16Codec = () => combineCodec2(getShortU16Encoder(), getShortU16Decoder()), getU128Encoder = (config = {}) => numberEncoderFactory({
  config,
  name: "u128",
  range: [0n, BigInt("0xffffffffffffffffffffffffffffffff")],
  set: (view, value, le) => {
    const leftOffset = le ? 8 : 0;
    const rightOffset = le ? 0 : 8;
    const rightMask = 0xffffffffffffffffn;
    view.setBigUint64(leftOffset, BigInt(value) >> 64n, le);
    view.setBigUint64(rightOffset, BigInt(value) & rightMask, le);
  },
  size: 16
}), getU128Decoder = (config = {}) => numberDecoderFactory({
  config,
  get: (view, le) => {
    const leftOffset = le ? 8 : 0;
    const rightOffset = le ? 0 : 8;
    const left = view.getBigUint64(leftOffset, le);
    const right = view.getBigUint64(rightOffset, le);
    return (left << 64n) + right;
  },
  name: "u128",
  size: 16
}), getU128Codec = (config = {}) => combineCodec2(getU128Encoder(config), getU128Decoder(config)), getU16Encoder = (config = {}) => numberEncoderFactory({
  config,
  name: "u16",
  range: [0, Number("0xffff")],
  set: (view, value, le) => view.setUint16(0, Number(value), le),
  size: 2
}), getU16Decoder = (config = {}) => numberDecoderFactory({
  config,
  get: (view, le) => view.getUint16(0, le),
  name: "u16",
  size: 2
}), getU16Codec = (config = {}) => combineCodec2(getU16Encoder(config), getU16Decoder(config)), getU32Encoder = (config = {}) => numberEncoderFactory({
  config,
  name: "u32",
  range: [0, Number("0xffffffff")],
  set: (view, value, le) => view.setUint32(0, Number(value), le),
  size: 4
}), getU32Decoder = (config = {}) => numberDecoderFactory({
  config,
  get: (view, le) => view.getUint32(0, le),
  name: "u32",
  size: 4
}), getU32Codec = (config = {}) => combineCodec2(getU32Encoder(config), getU32Decoder(config)), getU64Encoder = (config = {}) => numberEncoderFactory({
  config,
  name: "u64",
  range: [0n, BigInt("0xffffffffffffffff")],
  set: (view, value, le) => view.setBigUint64(0, BigInt(value), le),
  size: 8
}), getU64Decoder = (config = {}) => numberDecoderFactory({
  config,
  get: (view, le) => view.getBigUint64(0, le),
  name: "u64",
  size: 8
}), getU64Codec = (config = {}) => combineCodec2(getU64Encoder(config), getU64Decoder(config)), getU8Encoder = () => numberEncoderFactory({
  name: "u8",
  range: [0, Number("0xff")],
  set: (view, value) => view.setUint8(0, Number(value)),
  size: 1
}), getU8Decoder = () => numberDecoderFactory({
  get: (view) => view.getUint8(0),
  name: "u8",
  size: 1
}), getU8Codec = () => combineCodec2(getU8Encoder(), getU8Decoder());
var init_index_node12 = __esm(() => {
  init_index_node6();
  init_index_node7();
  Endian = /* @__PURE__ */ ((Endian2) => {
    Endian2[Endian2["Little"] = 0] = "Little";
    Endian2[Endian2["Big"] = 1] = "Big";
    return Endian2;
  })(Endian || {});
});

// ../../node_modules/.bun/@solana+codecs-data-structures@5.1.0+1fb4c65d43e298b9/node_modules/@solana/codecs-data-structures/dist/index.node.mjs
function assertValidNumberOfItemsForCodec(codecDescription, expected, actual) {
  if (expected !== actual) {
    throw new SolanaError2(SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS2, {
      actual,
      codecDescription,
      expected
    });
  }
}
function maxCodecSizes(sizes) {
  return sizes.reduce((all, size) => all === null || size === null ? null : Math.max(all, size), 0);
}
function sumCodecSizes(sizes) {
  return sizes.reduce((all, size) => all === null || size === null ? null : all + size, 0);
}
function getFixedSize(codec) {
  return isFixedSize2(codec) ? codec.fixedSize : null;
}
function getMaxSize(codec) {
  return isFixedSize2(codec) ? codec.fixedSize : codec.maxSize ?? null;
}
function getArrayEncoder(item, config = {}) {
  const size = config.size ?? getU32Encoder();
  const fixedSize = computeArrayLikeCodecSize(size, getFixedSize(item));
  const maxSize = computeArrayLikeCodecSize(size, getMaxSize(item)) ?? undefined;
  return createEncoder2({
    ...fixedSize !== null ? { fixedSize } : {
      getSizeFromValue: (array) => {
        const prefixSize = typeof size === "object" ? getEncodedSize2(array.length, size) : 0;
        return prefixSize + [...array].reduce((all, value) => all + getEncodedSize2(value, item), 0);
      },
      maxSize
    },
    write: (array, bytes, offset) => {
      if (typeof size === "number") {
        assertValidNumberOfItemsForCodec("array", size, array.length);
      }
      if (typeof size === "object") {
        offset = size.write(array.length, bytes, offset);
      }
      array.forEach((value) => {
        offset = item.write(value, bytes, offset);
      });
      return offset;
    }
  });
}
function getArrayDecoder(item, config = {}) {
  const size = config.size ?? getU32Decoder();
  const itemSize = getFixedSize(item);
  const fixedSize = computeArrayLikeCodecSize(size, itemSize);
  const maxSize = computeArrayLikeCodecSize(size, getMaxSize(item)) ?? undefined;
  return createDecoder2({
    ...fixedSize !== null ? { fixedSize } : { maxSize },
    read: (bytes, offset) => {
      const array = [];
      if (typeof size === "object" && bytes.slice(offset).length === 0) {
        return [array, offset];
      }
      if (size === "remainder") {
        while (offset < bytes.length) {
          const [value, newOffset2] = item.read(bytes, offset);
          offset = newOffset2;
          array.push(value);
        }
        return [array, offset];
      }
      const [resolvedSize, newOffset] = typeof size === "number" ? [size, offset] : size.read(bytes, offset);
      offset = newOffset;
      for (let i = 0;i < resolvedSize; i += 1) {
        const [value, newOffset2] = item.read(bytes, offset);
        offset = newOffset2;
        array.push(value);
      }
      return [array, offset];
    }
  });
}
function getArrayCodec(item, config = {}) {
  return combineCodec2(getArrayEncoder(item, config), getArrayDecoder(item, config));
}
function computeArrayLikeCodecSize(size, itemSize) {
  if (typeof size !== "number")
    return null;
  if (size === 0)
    return 0;
  return itemSize === null ? null : itemSize * size;
}
function getBitArrayEncoder(size, config = {}) {
  const parsedConfig = typeof config === "boolean" ? { backward: config } : config;
  const backward = parsedConfig.backward ?? false;
  return createEncoder2({
    fixedSize: size,
    write(value, bytes, offset) {
      const bytesToAdd = [];
      for (let i = 0;i < size; i += 1) {
        let byte = 0;
        for (let j = 0;j < 8; j += 1) {
          const feature = Number(value[i * 8 + j] ?? 0);
          byte |= feature << (backward ? j : 7 - j);
        }
        if (backward) {
          bytesToAdd.unshift(byte);
        } else {
          bytesToAdd.push(byte);
        }
      }
      bytes.set(bytesToAdd, offset);
      return size;
    }
  });
}
function getBitArrayDecoder(size, config = {}) {
  const parsedConfig = typeof config === "boolean" ? { backward: config } : config;
  const backward = parsedConfig.backward ?? false;
  return createDecoder2({
    fixedSize: size,
    read(bytes, offset) {
      assertByteArrayHasEnoughBytesForCodec2("bitArray", size, bytes, offset);
      const booleans = [];
      let slice = bytes.slice(offset, offset + size);
      slice = backward ? slice.reverse() : slice;
      slice.forEach((byte) => {
        for (let i = 0;i < 8; i += 1) {
          if (backward) {
            booleans.push(Boolean(byte & 1));
            byte >>= 1;
          } else {
            booleans.push(Boolean(byte & 128));
            byte <<= 1;
          }
        }
      });
      return [booleans, offset + size];
    }
  });
}
function getBitArrayCodec(size, config = {}) {
  return combineCodec2(getBitArrayEncoder(size, config), getBitArrayDecoder(size, config));
}
function getBooleanEncoder(config = {}) {
  return transformEncoder2(config.size ?? getU8Encoder(), (value) => value ? 1 : 0);
}
function getBooleanDecoder(config = {}) {
  return transformDecoder(config.size ?? getU8Decoder(), (value) => Number(value) === 1);
}
function getBooleanCodec(config = {}) {
  return combineCodec2(getBooleanEncoder(config), getBooleanDecoder(config));
}
function getBytesEncoder() {
  return createEncoder2({
    getSizeFromValue: (value) => value.length,
    write: (value, bytes, offset) => {
      bytes.set(value, offset);
      return offset + value.length;
    }
  });
}
function getBytesDecoder() {
  return createDecoder2({
    read: (bytes, offset) => {
      const slice = bytes.slice(offset);
      return [slice, offset + slice.length];
    }
  });
}
function getBytesCodec() {
  return combineCodec2(getBytesEncoder(), getBytesDecoder());
}
function getConstantEncoder(constant) {
  return createEncoder2({
    fixedSize: constant.length,
    write: (_, bytes, offset) => {
      bytes.set(constant, offset);
      return offset + constant.length;
    }
  });
}
function getConstantDecoder(constant) {
  return createDecoder2({
    fixedSize: constant.length,
    read: (bytes, offset) => {
      const base16 = getBase16Decoder2();
      if (!containsBytes(bytes, constant, offset)) {
        throw new SolanaError2(SOLANA_ERROR__CODECS__INVALID_CONSTANT2, {
          constant,
          data: bytes,
          hexConstant: base16.decode(constant),
          hexData: base16.decode(bytes),
          offset
        });
      }
      return [undefined, offset + constant.length];
    }
  });
}
function getConstantCodec(constant) {
  return combineCodec2(getConstantEncoder(constant), getConstantDecoder(constant));
}
function getTupleEncoder(items) {
  const fixedSize = sumCodecSizes(items.map(getFixedSize));
  const maxSize = sumCodecSizes(items.map(getMaxSize)) ?? undefined;
  return createEncoder2({
    ...fixedSize === null ? {
      getSizeFromValue: (value) => items.map((item, index) => getEncodedSize2(value[index], item)).reduce((all, one) => all + one, 0),
      maxSize
    } : { fixedSize },
    write: (value, bytes, offset) => {
      assertValidNumberOfItemsForCodec("tuple", items.length, value.length);
      items.forEach((item, index) => {
        offset = item.write(value[index], bytes, offset);
      });
      return offset;
    }
  });
}
function getTupleDecoder(items) {
  const fixedSize = sumCodecSizes(items.map(getFixedSize));
  const maxSize = sumCodecSizes(items.map(getMaxSize)) ?? undefined;
  return createDecoder2({
    ...fixedSize === null ? { maxSize } : { fixedSize },
    read: (bytes, offset) => {
      const values = [];
      items.forEach((item) => {
        const [newValue, newOffset] = item.read(bytes, offset);
        values.push(newValue);
        offset = newOffset;
      });
      return [values, offset];
    }
  });
}
function getTupleCodec(items) {
  return combineCodec2(getTupleEncoder(items), getTupleDecoder(items));
}
function getUnionEncoder(variants, getIndexFromValue) {
  const fixedSize = getUnionFixedSize(variants);
  const write = (variant, bytes, offset) => {
    const index = getIndexFromValue(variant);
    assertValidVariantIndex(variants, index);
    return variants[index].write(variant, bytes, offset);
  };
  if (fixedSize !== null) {
    return createEncoder2({ fixedSize, write });
  }
  const maxSize = getUnionMaxSize(variants);
  return createEncoder2({
    ...maxSize !== null ? { maxSize } : {},
    getSizeFromValue: (variant) => {
      const index = getIndexFromValue(variant);
      assertValidVariantIndex(variants, index);
      return getEncodedSize2(variant, variants[index]);
    },
    write
  });
}
function getUnionDecoder(variants, getIndexFromBytes) {
  const fixedSize = getUnionFixedSize(variants);
  const read = (bytes, offset) => {
    const index = getIndexFromBytes(bytes, offset);
    assertValidVariantIndex(variants, index);
    return variants[index].read(bytes, offset);
  };
  if (fixedSize !== null) {
    return createDecoder2({ fixedSize, read });
  }
  const maxSize = getUnionMaxSize(variants);
  return createDecoder2({ ...maxSize !== null ? { maxSize } : {}, read });
}
function getUnionCodec(variants, getIndexFromValue, getIndexFromBytes) {
  return combineCodec2(getUnionEncoder(variants, getIndexFromValue), getUnionDecoder(variants, getIndexFromBytes));
}
function assertValidVariantIndex(variants, index) {
  if (typeof variants[index] === "undefined") {
    throw new SolanaError2(SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE2, {
      maxRange: variants.length - 1,
      minRange: 0,
      variant: index
    });
  }
}
function getUnionFixedSize(variants) {
  if (variants.length === 0)
    return 0;
  if (!isFixedSize2(variants[0]))
    return null;
  const variantSize = variants[0].fixedSize;
  const sameSizedVariants = variants.every((variant) => isFixedSize2(variant) && variant.fixedSize === variantSize);
  return sameSizedVariants ? variantSize : null;
}
function getUnionMaxSize(variants) {
  return maxCodecSizes(variants.map((variant) => getMaxSize(variant)));
}
function getDiscriminatedUnionEncoder(variants, config = {}) {
  const discriminatorProperty = config.discriminator ?? "__kind";
  const prefix = config.size ?? getU8Encoder();
  return getUnionEncoder(variants.map(([, variant], index) => transformEncoder2(getTupleEncoder([prefix, variant]), (value) => [index, value])), (value) => getVariantDiscriminator(variants, value[discriminatorProperty]));
}
function getDiscriminatedUnionDecoder(variants, config = {}) {
  const discriminatorProperty = config.discriminator ?? "__kind";
  const prefix = config.size ?? getU8Decoder();
  return getUnionDecoder(variants.map(([discriminator, variant]) => transformDecoder(getTupleDecoder([prefix, variant]), ([, value]) => ({
    [discriminatorProperty]: discriminator,
    ...value
  }))), (bytes, offset) => Number(prefix.read(bytes, offset)[0]));
}
function getDiscriminatedUnionCodec(variants, config = {}) {
  return combineCodec2(getDiscriminatedUnionEncoder(variants, config), getDiscriminatedUnionDecoder(variants, config));
}
function getVariantDiscriminator(variants, discriminatorValue) {
  const discriminator = variants.findIndex(([key]) => discriminatorValue === key);
  if (discriminator < 0) {
    throw new SolanaError2(SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT2, {
      value: discriminatorValue,
      variants: variants.map(([key]) => key)
    });
  }
  return discriminator;
}
function getEnumStats(constructor) {
  const numericalValues = [...new Set(Object.values(constructor).filter((v) => typeof v === "number"))].sort();
  const enumRecord = Object.fromEntries(Object.entries(constructor).slice(numericalValues.length));
  const enumKeys = Object.keys(enumRecord);
  const enumValues = Object.values(enumRecord);
  const stringValues = [
    .../* @__PURE__ */ new Set([...enumKeys, ...enumValues.filter((v) => typeof v === "string")])
  ];
  return { enumKeys, enumRecord, enumValues, numericalValues, stringValues };
}
function getEnumIndexFromVariant({
  enumKeys,
  enumValues,
  variant
}) {
  const valueIndex = findLastIndex(enumValues, (value) => value === variant);
  if (valueIndex >= 0)
    return valueIndex;
  return enumKeys.findIndex((key) => key === variant);
}
function getEnumIndexFromDiscriminator({
  discriminator,
  enumKeys,
  enumValues,
  useValuesAsDiscriminators
}) {
  if (!useValuesAsDiscriminators) {
    return discriminator >= 0 && discriminator < enumKeys.length ? discriminator : -1;
  }
  return findLastIndex(enumValues, (value) => value === discriminator);
}
function findLastIndex(array, predicate) {
  let l = array.length;
  while (l--) {
    if (predicate(array[l], l, array))
      return l;
  }
  return -1;
}
function formatNumericalValues(values) {
  if (values.length === 0)
    return "";
  let range = [values[0], values[0]];
  const ranges = [];
  for (let index = 1;index < values.length; index++) {
    const value = values[index];
    if (range[1] + 1 === value) {
      range[1] = value;
    } else {
      ranges.push(range[0] === range[1] ? `${range[0]}` : `${range[0]}-${range[1]}`);
      range = [value, value];
    }
  }
  ranges.push(range[0] === range[1] ? `${range[0]}` : `${range[0]}-${range[1]}`);
  return ranges.join(", ");
}
function getEnumEncoder(constructor, config = {}) {
  const prefix = config.size ?? getU8Encoder();
  const useValuesAsDiscriminators = config.useValuesAsDiscriminators ?? false;
  const { enumKeys, enumValues, numericalValues, stringValues } = getEnumStats(constructor);
  if (useValuesAsDiscriminators && enumValues.some((value) => typeof value === "string")) {
    throw new SolanaError2(SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS2, {
      stringValues: enumValues.filter((v) => typeof v === "string")
    });
  }
  return transformEncoder2(prefix, (variant) => {
    const index = getEnumIndexFromVariant({ enumKeys, enumValues, variant });
    if (index < 0) {
      throw new SolanaError2(SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT2, {
        formattedNumericalValues: formatNumericalValues(numericalValues),
        numericalValues,
        stringValues,
        variant
      });
    }
    return useValuesAsDiscriminators ? enumValues[index] : index;
  });
}
function getEnumDecoder(constructor, config = {}) {
  const prefix = config.size ?? getU8Decoder();
  const useValuesAsDiscriminators = config.useValuesAsDiscriminators ?? false;
  const { enumKeys, enumValues, numericalValues } = getEnumStats(constructor);
  if (useValuesAsDiscriminators && enumValues.some((value) => typeof value === "string")) {
    throw new SolanaError2(SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS2, {
      stringValues: enumValues.filter((v) => typeof v === "string")
    });
  }
  return transformDecoder(prefix, (value) => {
    const discriminator = Number(value);
    const index = getEnumIndexFromDiscriminator({
      discriminator,
      enumKeys,
      enumValues,
      useValuesAsDiscriminators
    });
    if (index < 0) {
      const validDiscriminators = useValuesAsDiscriminators ? numericalValues : [...Array(enumKeys.length).keys()];
      throw new SolanaError2(SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE2, {
        discriminator,
        formattedValidDiscriminators: formatNumericalValues(validDiscriminators),
        validDiscriminators
      });
    }
    return enumValues[index];
  });
}
function getEnumCodec(constructor, config = {}) {
  return combineCodec2(getEnumEncoder(constructor, config), getEnumDecoder(constructor, config));
}
function getHiddenPrefixEncoder(encoder, prefixedEncoders) {
  return transformEncoder2(getTupleEncoder([...prefixedEncoders, encoder]), (value) => [...prefixedEncoders.map(() => {
    return;
  }), value]);
}
function getHiddenPrefixDecoder(decoder, prefixedDecoders) {
  return transformDecoder(getTupleDecoder([...prefixedDecoders, decoder]), (tuple) => tuple[tuple.length - 1]);
}
function getHiddenPrefixCodec(codec, prefixedCodecs) {
  return combineCodec2(getHiddenPrefixEncoder(codec, prefixedCodecs), getHiddenPrefixDecoder(codec, prefixedCodecs));
}
function getHiddenSuffixEncoder(encoder, suffixedEncoders) {
  return transformEncoder2(getTupleEncoder([encoder, ...suffixedEncoders]), (value) => [value, ...suffixedEncoders.map(() => {
    return;
  })]);
}
function getHiddenSuffixDecoder(decoder, suffixedDecoders) {
  return transformDecoder(getTupleDecoder([decoder, ...suffixedDecoders]), (tuple) => tuple[0]);
}
function getHiddenSuffixCodec(codec, suffixedCodecs) {
  return combineCodec2(getHiddenSuffixEncoder(codec, suffixedCodecs), getHiddenSuffixDecoder(codec, suffixedCodecs));
}
function getLiteralUnionEncoder(variants, config = {}) {
  const discriminator = config.size ?? getU8Encoder();
  return transformEncoder2(discriminator, (variant) => {
    const index = variants.indexOf(variant);
    if (index < 0) {
      throw new SolanaError2(SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT2, {
        value: variant,
        variants
      });
    }
    return index;
  });
}
function getLiteralUnionDecoder(variants, config = {}) {
  const discriminator = config.size ?? getU8Decoder();
  return transformDecoder(discriminator, (index) => {
    if (index < 0 || index >= variants.length) {
      throw new SolanaError2(SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE2, {
        discriminator: index,
        maxRange: variants.length - 1,
        minRange: 0
      });
    }
    return variants[Number(index)];
  });
}
function getLiteralUnionCodec(variants, config = {}) {
  return combineCodec2(getLiteralUnionEncoder(variants, config), getLiteralUnionDecoder(variants, config));
}
function getMapEncoder(key, value, config = {}) {
  return transformEncoder2(getArrayEncoder(getTupleEncoder([key, value]), config), (map) => [...map.entries()]);
}
function getMapDecoder(key, value, config = {}) {
  return transformDecoder(getArrayDecoder(getTupleDecoder([key, value]), config), (entries) => new Map(entries));
}
function getMapCodec(key, value, config = {}) {
  return combineCodec2(getMapEncoder(key, value, config), getMapDecoder(key, value, config));
}
function getUnitEncoder() {
  return createEncoder2({
    fixedSize: 0,
    write: (_value, _bytes, offset) => offset
  });
}
function getUnitDecoder() {
  return createDecoder2({
    fixedSize: 0,
    read: (_bytes, offset) => [undefined, offset]
  });
}
function getUnitCodec() {
  return combineCodec2(getUnitEncoder(), getUnitDecoder());
}
function getNullableEncoder(item, config = {}) {
  const prefix = (() => {
    if (config.prefix === null) {
      return transformEncoder2(getUnitEncoder(), (_boolean) => {
        return;
      });
    }
    return getBooleanEncoder({ size: config.prefix ?? getU8Encoder() });
  })();
  const noneValue = (() => {
    if (config.noneValue === "zeroes") {
      assertIsFixedSize(item);
      return fixEncoderSize2(getUnitEncoder(), item.fixedSize);
    }
    if (!config.noneValue) {
      return getUnitEncoder();
    }
    return getConstantEncoder(config.noneValue);
  })();
  return getUnionEncoder([
    transformEncoder2(getTupleEncoder([prefix, noneValue]), (_value) => [
      false,
      undefined
    ]),
    transformEncoder2(getTupleEncoder([prefix, item]), (value) => [true, value])
  ], (variant) => Number(variant !== null));
}
function getNullableDecoder(item, config = {}) {
  const prefix = (() => {
    if (config.prefix === null) {
      return transformDecoder(getUnitDecoder(), () => false);
    }
    return getBooleanDecoder({ size: config.prefix ?? getU8Decoder() });
  })();
  const noneValue = (() => {
    if (config.noneValue === "zeroes") {
      assertIsFixedSize(item);
      return fixDecoderSize2(getUnitDecoder(), item.fixedSize);
    }
    if (!config.noneValue) {
      return getUnitDecoder();
    }
    return getConstantDecoder(config.noneValue);
  })();
  return getUnionDecoder([
    transformDecoder(getTupleDecoder([prefix, noneValue]), () => null),
    transformDecoder(getTupleDecoder([prefix, item]), ([, value]) => value)
  ], (bytes, offset) => {
    if (config.prefix === null && !config.noneValue) {
      return Number(offset < bytes.length);
    }
    if (config.prefix === null && config.noneValue != null) {
      const zeroValue = config.noneValue === "zeroes" ? new Uint8Array(noneValue.fixedSize).fill(0) : config.noneValue;
      return containsBytes(bytes, zeroValue, offset) ? 0 : 1;
    }
    return Number(prefix.read(bytes, offset)[0]);
  });
}
function getNullableCodec(item, config = {}) {
  return combineCodec2(getNullableEncoder(item, config), getNullableDecoder(item, config));
}
function getSetEncoder(item, config = {}) {
  return transformEncoder2(getArrayEncoder(item, config), (set) => [...set]);
}
function getSetDecoder(item, config = {}) {
  return transformDecoder(getArrayDecoder(item, config), (entries) => new Set(entries));
}
function getSetCodec(item, config = {}) {
  return combineCodec2(getSetEncoder(item, config), getSetDecoder(item, config));
}
function getStructEncoder(fields) {
  const fieldCodecs = fields.map(([, codec]) => codec);
  const fixedSize = sumCodecSizes(fieldCodecs.map(getFixedSize));
  const maxSize = sumCodecSizes(fieldCodecs.map(getMaxSize)) ?? undefined;
  return createEncoder2({
    ...fixedSize === null ? {
      getSizeFromValue: (value) => fields.map(([key, codec]) => getEncodedSize2(value[key], codec)).reduce((all, one) => all + one, 0),
      maxSize
    } : { fixedSize },
    write: (struct, bytes, offset) => {
      fields.forEach(([key, codec]) => {
        offset = codec.write(struct[key], bytes, offset);
      });
      return offset;
    }
  });
}
function getStructDecoder(fields) {
  const fieldCodecs = fields.map(([, codec]) => codec);
  const fixedSize = sumCodecSizes(fieldCodecs.map(getFixedSize));
  const maxSize = sumCodecSizes(fieldCodecs.map(getMaxSize)) ?? undefined;
  return createDecoder2({
    ...fixedSize === null ? { maxSize } : { fixedSize },
    read: (bytes, offset) => {
      const struct = {};
      fields.forEach(([key, codec]) => {
        const [value, newOffset] = codec.read(bytes, offset);
        offset = newOffset;
        struct[key] = value;
      });
      return [struct, offset];
    }
  });
}
function getStructCodec(fields) {
  return combineCodec2(getStructEncoder(fields), getStructDecoder(fields));
}
var getBase16Decoder2 = () => createDecoder2({
  read(bytes, offset) {
    const value = bytes.slice(offset).reduce((str, byte) => str + byte.toString(16).padStart(2, "0"), "");
    return [value, bytes.length];
  }
});
var init_index_node13 = __esm(() => {
  init_index_node7();
  init_index_node12();
  init_index_node6();
});

// ../../node_modules/.bun/@solana+options@5.1.0+7f9e3d21594a24ff/node_modules/@solana/options/dist/index.node.mjs
function unwrapOption(option, fallback) {
  if (isSome(option))
    return option.value;
  return fallback ? fallback() : null;
}
function getOptionEncoder(item, config = {}) {
  const prefix = (() => {
    if (config.prefix === null) {
      return transformEncoder2(getUnitEncoder(), (_boolean) => {
        return;
      });
    }
    return getBooleanEncoder({ size: config.prefix ?? getU8Encoder() });
  })();
  const noneValue = (() => {
    if (config.noneValue === "zeroes") {
      assertIsFixedSize(item);
      return fixEncoderSize2(getUnitEncoder(), item.fixedSize);
    }
    if (!config.noneValue) {
      return getUnitEncoder();
    }
    return getConstantEncoder(config.noneValue);
  })();
  return getUnionEncoder([
    transformEncoder2(getTupleEncoder([prefix, noneValue]), (_value) => [
      false,
      undefined
    ]),
    transformEncoder2(getTupleEncoder([prefix, item]), (value) => [
      true,
      isOption(value) && isSome(value) ? value.value : value
    ])
  ], (variant) => {
    const option = isOption(variant) ? variant : wrapNullable(variant);
    return Number(isSome(option));
  });
}
function getOptionDecoder(item, config = {}) {
  const prefix = (() => {
    if (config.prefix === null) {
      return transformDecoder(getUnitDecoder(), () => false);
    }
    return getBooleanDecoder({ size: config.prefix ?? getU8Decoder() });
  })();
  const noneValue = (() => {
    if (config.noneValue === "zeroes") {
      assertIsFixedSize(item);
      return fixDecoderSize2(getUnitDecoder(), item.fixedSize);
    }
    if (!config.noneValue) {
      return getUnitDecoder();
    }
    return getConstantDecoder(config.noneValue);
  })();
  return getUnionDecoder([
    transformDecoder(getTupleDecoder([prefix, noneValue]), () => none()),
    transformDecoder(getTupleDecoder([prefix, item]), ([, value]) => some(value))
  ], (bytes, offset) => {
    if (config.prefix === null && !config.noneValue) {
      return Number(offset < bytes.length);
    }
    if (config.prefix === null && config.noneValue != null) {
      const zeroValue = config.noneValue === "zeroes" ? new Uint8Array(noneValue.fixedSize).fill(0) : config.noneValue;
      return containsBytes(bytes, zeroValue, offset) ? 0 : 1;
    }
    return Number(prefix.read(bytes, offset)[0]);
  });
}
function getOptionCodec(item, config = {}) {
  return combineCodec2(getOptionEncoder(item, config), getOptionDecoder(item, config));
}
function unwrapOptionRecursively(input, fallback) {
  if (!input || ArrayBuffer.isView(input)) {
    return input;
  }
  const next = (x) => fallback ? unwrapOptionRecursively(x, fallback) : unwrapOptionRecursively(x);
  if (isOption(input)) {
    if (isSome(input))
      return next(input.value);
    return fallback ? fallback() : null;
  }
  if (Array.isArray(input)) {
    return input.map(next);
  }
  if (typeof input === "object") {
    return Object.fromEntries(Object.entries(input).map(([k, v]) => [k, next(v)]));
  }
  return input;
}
var some = (value) => ({ __option: "Some", value }), none = () => ({ __option: "None" }), isOption = (input) => !!(input && typeof input === "object" && ("__option" in input) && (input.__option === "Some" && ("value" in input) || input.__option === "None")), isSome = (option) => option.__option === "Some", isNone = (option) => option.__option === "None", wrapNullable = (nullable) => nullable !== null ? some(nullable) : none();
var init_index_node14 = __esm(() => {
  init_index_node7();
  init_index_node13();
  init_index_node12();
});

// ../../node_modules/.bun/@solana+codecs@5.1.0+7f9e3d21594a24ff/node_modules/@solana/codecs/dist/index.node.mjs
var init_index_node15 = __esm(() => {
  init_index_node7();
  init_index_node13();
  init_index_node12();
  init_index_node8();
  init_index_node14();
});

// ../../node_modules/.bun/@solana+functional@5.1.0+1fb4c65d43e298b9/node_modules/@solana/functional/dist/index.node.mjs
function pipe(init, ...fns) {
  return fns.reduce((acc, fn) => fn(acc), init);
}
var init_index_node16 = () => {};

// ../../node_modules/.bun/@solana+instructions@5.1.0+1fb4c65d43e298b9/node_modules/@solana/instructions/dist/index.node.mjs
function isInstructionForProgram(instruction, programAddress) {
  return instruction.programAddress === programAddress;
}
function assertIsInstructionForProgram(instruction, programAddress) {
  if (instruction.programAddress !== programAddress) {
    throw new SolanaError2(SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH2, {
      actualProgramAddress: instruction.programAddress,
      expectedProgramAddress: programAddress
    });
  }
}
function isInstructionWithAccounts(instruction) {
  return instruction.accounts !== undefined;
}
function assertIsInstructionWithAccounts(instruction) {
  if (instruction.accounts === undefined) {
    throw new SolanaError2(SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS2, {
      data: instruction.data,
      programAddress: instruction.programAddress
    });
  }
}
function isInstructionWithData(instruction) {
  return instruction.data !== undefined;
}
function assertIsInstructionWithData(instruction) {
  if (instruction.data === undefined) {
    throw new SolanaError2(SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA2, {
      accountAddresses: instruction.accounts?.map((a) => a.address),
      programAddress: instruction.programAddress
    });
  }
}
function downgradeRoleToNonSigner(role) {
  return role & ~IS_SIGNER_BITMASK;
}
function downgradeRoleToReadonly(role) {
  return role & ~IS_WRITABLE_BITMASK;
}
function isSignerRole(role) {
  return role >= 2;
}
function isWritableRole(role) {
  return (role & IS_WRITABLE_BITMASK) !== 0;
}
function mergeRoles(roleA, roleB) {
  return roleA | roleB;
}
function upgradeRoleToSigner(role) {
  return role | IS_SIGNER_BITMASK;
}
function upgradeRoleToWritable(role) {
  return role | IS_WRITABLE_BITMASK;
}
var AccountRole, IS_SIGNER_BITMASK = 2, IS_WRITABLE_BITMASK = 1;
var init_index_node17 = __esm(() => {
  init_index_node6();
  AccountRole = /* @__PURE__ */ ((AccountRole2) => {
    AccountRole2[AccountRole2["WRITABLE_SIGNER"] = 3] = "WRITABLE_SIGNER";
    AccountRole2[AccountRole2["READONLY_SIGNER"] = 2] = "READONLY_SIGNER";
    AccountRole2[AccountRole2["WRITABLE"] = 1] = "WRITABLE";
    AccountRole2[AccountRole2["READONLY"] = 0] = "READONLY";
    return AccountRole2;
  })(AccountRole || {});
});

// ../../node_modules/.bun/@solana+rpc-types@5.1.0+7f9e3d21594a24ff/node_modules/@solana/rpc-types/dist/index.node.mjs
function isBlockhash(putativeBlockhash) {
  return isAddress2(putativeBlockhash);
}
function assertIsBlockhash(putativeBlockhash) {
  try {
    assertIsAddress2(putativeBlockhash);
  } catch (error) {
    if (isSolanaError2(error, SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE2)) {
      throw new SolanaError2(SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE2, error.context);
    }
    if (isSolanaError2(error, SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH2)) {
      throw new SolanaError2(SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH2, error.context);
    }
    throw error;
  }
}
function blockhash(putativeBlockhash) {
  assertIsBlockhash(putativeBlockhash);
  return putativeBlockhash;
}
function getBlockhashEncoder() {
  const addressEncoder = getAddressEncoder2();
  return createEncoder2({
    fixedSize: 32,
    write: (value, bytes, offset) => {
      assertIsBlockhash(value);
      return addressEncoder.write(value, bytes, offset);
    }
  });
}
function getBlockhashDecoder() {
  return getAddressDecoder2();
}
function getBlockhashCodec() {
  return combineCodec2(getBlockhashEncoder(), getBlockhashDecoder());
}
function getBlockhashComparator() {
  return new Intl.Collator("en", {
    caseFirst: "lower",
    ignorePunctuation: false,
    localeMatcher: "best fit",
    numeric: false,
    sensitivity: "variant",
    usage: "sort"
  }).compare;
}
function mainnet(putativeString) {
  return putativeString;
}
function devnet(putativeString) {
  return putativeString;
}
function testnet(putativeString) {
  return putativeString;
}
function getCommitmentScore(commitment) {
  switch (commitment) {
    case "finalized":
      return 2;
    case "confirmed":
      return 1;
    case "processed":
      return 0;
    default:
      throw new SolanaError2(SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE2, {
        unexpectedValue: commitment
      });
  }
}
function commitmentComparator(a, b) {
  if (a === b) {
    return 0;
  }
  return getCommitmentScore(a) < getCommitmentScore(b) ? -1 : 1;
}
function getMemoizedU64Encoder() {
  if (!memoizedU64Encoder)
    memoizedU64Encoder = getU64Encoder();
  return memoizedU64Encoder;
}
function getMemoizedU64Decoder() {
  if (!memoizedU64Decoder)
    memoizedU64Decoder = getU64Decoder();
  return memoizedU64Decoder;
}
function isLamports(putativeLamports) {
  return putativeLamports >= 0 && putativeLamports <= maxU64Value;
}
function assertIsLamports(putativeLamports) {
  if (putativeLamports < 0 || putativeLamports > maxU64Value) {
    throw new SolanaError2(SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE2);
  }
}
function lamports(putativeLamports) {
  assertIsLamports(putativeLamports);
  return putativeLamports;
}
function getDefaultLamportsEncoder() {
  return getLamportsEncoder(getMemoizedU64Encoder());
}
function getLamportsEncoder(innerEncoder) {
  return innerEncoder;
}
function getDefaultLamportsDecoder() {
  return getLamportsDecoder(getMemoizedU64Decoder());
}
function getLamportsDecoder(innerDecoder) {
  return transformDecoder(innerDecoder, (value) => lamports(typeof value === "bigint" ? value : BigInt(value)));
}
function getDefaultLamportsCodec() {
  return combineCodec2(getDefaultLamportsEncoder(), getDefaultLamportsDecoder());
}
function getLamportsCodec(innerCodec) {
  return combineCodec2(getLamportsEncoder(innerCodec), getLamportsDecoder(innerCodec));
}
function isStringifiedBigInt(putativeBigInt) {
  try {
    BigInt(putativeBigInt);
    return true;
  } catch {
    return false;
  }
}
function assertIsStringifiedBigInt(putativeBigInt) {
  try {
    BigInt(putativeBigInt);
  } catch {
    throw new SolanaError2(SOLANA_ERROR__MALFORMED_BIGINT_STRING2, {
      value: putativeBigInt
    });
  }
}
function stringifiedBigInt(putativeBigInt) {
  assertIsStringifiedBigInt(putativeBigInt);
  return putativeBigInt;
}
function isStringifiedNumber(putativeNumber) {
  return !Number.isNaN(Number(putativeNumber));
}
function assertIsStringifiedNumber(putativeNumber) {
  if (Number.isNaN(Number(putativeNumber))) {
    throw new SolanaError2(SOLANA_ERROR__MALFORMED_NUMBER_STRING2, {
      value: putativeNumber
    });
  }
}
function stringifiedNumber(putativeNumber) {
  assertIsStringifiedNumber(putativeNumber);
  return putativeNumber;
}
function isUnixTimestamp(putativeTimestamp) {
  return putativeTimestamp >= minI64Value && putativeTimestamp <= maxI64Value;
}
function assertIsUnixTimestamp(putativeTimestamp) {
  if (putativeTimestamp < minI64Value || putativeTimestamp > maxI64Value) {
    throw new SolanaError2(SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE2, {
      value: putativeTimestamp
    });
  }
}
function unixTimestamp(putativeTimestamp) {
  assertIsUnixTimestamp(putativeTimestamp);
  return putativeTimestamp;
}
var maxU64Value = 18446744073709551615n, memoizedU64Encoder, memoizedU64Decoder, maxI64Value = 9223372036854775807n, minI64Value;
var init_index_node18 = __esm(() => {
  init_index_node11();
  init_index_node7();
  init_index_node6();
  init_index_node12();
  minI64Value = -9223372036854775808n;
});

// ../../node_modules/.bun/@solana+transaction-messages@5.1.0+7f9e3d21594a24ff/node_modules/@solana/transaction-messages/dist/index.node.mjs
function isTransactionMessageWithBlockhashLifetime(transactionMessage) {
  return "lifetimeConstraint" in transactionMessage && typeof transactionMessage.lifetimeConstraint.blockhash === "string" && typeof transactionMessage.lifetimeConstraint.lastValidBlockHeight === "bigint" && isBlockhash(transactionMessage.lifetimeConstraint.blockhash);
}
function assertIsTransactionMessageWithBlockhashLifetime(transactionMessage) {
  if (!isTransactionMessageWithBlockhashLifetime(transactionMessage)) {
    throw new SolanaError2(SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME2);
  }
}
function setTransactionMessageLifetimeUsingBlockhash(blockhashLifetimeConstraint, transactionMessage) {
  if ("lifetimeConstraint" in transactionMessage && transactionMessage.lifetimeConstraint && "blockhash" in transactionMessage.lifetimeConstraint && transactionMessage.lifetimeConstraint.blockhash === blockhashLifetimeConstraint.blockhash && transactionMessage.lifetimeConstraint.lastValidBlockHeight === blockhashLifetimeConstraint.lastValidBlockHeight) {
    return transactionMessage;
  }
  return Object.freeze({
    ...transactionMessage,
    lifetimeConstraint: Object.freeze(blockhashLifetimeConstraint)
  });
}
function assertValidBaseString3(alphabet4, testValue, givenValue = testValue) {
  if (!testValue.match(new RegExp(`^[${alphabet4}]*$`))) {
    throw new SolanaError2(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE2, {
      alphabet: alphabet4,
      base: alphabet4.length,
      value: givenValue
    });
  }
}
function partitionLeadingZeroes3(value, zeroCharacter) {
  const [leadingZeros, tailChars] = value.split(new RegExp(`((?!${zeroCharacter}).*)`));
  return [leadingZeros, tailChars];
}
function getBigIntFromBaseX3(value, alphabet4) {
  const base = BigInt(alphabet4.length);
  let sum = 0n;
  for (const char of value) {
    sum *= base;
    sum += BigInt(alphabet4.indexOf(char));
  }
  return sum;
}
function getBaseXFromBigInt3(value, alphabet4) {
  const base = BigInt(alphabet4.length);
  const tailChars = [];
  while (value > 0n) {
    tailChars.unshift(alphabet4[Number(value % base)]);
    value /= base;
  }
  return tailChars.join("");
}
function getAddressTableLookupEncoder() {
  if (!memoizedAddressTableLookupEncoder) {
    const indexEncoder = getArrayEncoder(getU8Encoder(), { size: getShortU16Encoder() });
    memoizedAddressTableLookupEncoder = getStructEncoder([
      ["lookupTableAddress", getAddressEncoder2()],
      ["writableIndexes", indexEncoder],
      ["readonlyIndexes", indexEncoder]
    ]);
  }
  return memoizedAddressTableLookupEncoder;
}
function getAddressTableLookupDecoder() {
  if (!memoizedAddressTableLookupDecoder) {
    const indexEncoder = getArrayDecoder(getU8Decoder(), { size: getShortU16Decoder() });
    memoizedAddressTableLookupDecoder = getStructDecoder([
      ["lookupTableAddress", getAddressDecoder2()],
      ["writableIndexes", indexEncoder],
      ["readonlyIndexes", indexEncoder]
    ]);
  }
  return memoizedAddressTableLookupDecoder;
}
function getMemoizedU8Encoder() {
  if (!memoizedU8Encoder)
    memoizedU8Encoder = getU8Encoder();
  return memoizedU8Encoder;
}
function getMemoizedU8Decoder() {
  if (!memoizedU8Decoder)
    memoizedU8Decoder = getU8Decoder();
  return memoizedU8Decoder;
}
function getMessageHeaderEncoder() {
  return getStructEncoder([
    ["numSignerAccounts", getMemoizedU8Encoder()],
    ["numReadonlySignerAccounts", getMemoizedU8Encoder()],
    ["numReadonlyNonSignerAccounts", getMemoizedU8Encoder()]
  ]);
}
function getMessageHeaderDecoder() {
  return getStructDecoder([
    ["numSignerAccounts", getMemoizedU8Decoder()],
    ["numReadonlySignerAccounts", getMemoizedU8Decoder()],
    ["numReadonlyNonSignerAccounts", getMemoizedU8Decoder()]
  ]);
}
function getInstructionEncoder() {
  if (!memoizedGetInstructionEncoder) {
    memoizedGetInstructionEncoder = transformEncoder2(getStructEncoder([
      ["programAddressIndex", getU8Encoder()],
      ["accountIndices", getArrayEncoder(getU8Encoder(), { size: getShortU16Encoder() })],
      ["data", addEncoderSizePrefix(getBytesEncoder(), getShortU16Encoder())]
    ]), (instruction) => {
      if (instruction.accountIndices !== undefined && instruction.data !== undefined) {
        return instruction;
      }
      return {
        ...instruction,
        accountIndices: instruction.accountIndices ?? [],
        data: instruction.data ?? new Uint8Array(0)
      };
    });
  }
  return memoizedGetInstructionEncoder;
}
function getInstructionDecoder() {
  if (!memoizedGetInstructionDecoder) {
    memoizedGetInstructionDecoder = transformDecoder(getStructDecoder([
      ["programAddressIndex", getU8Decoder()],
      ["accountIndices", getArrayDecoder(getU8Decoder(), { size: getShortU16Decoder() })],
      [
        "data",
        addDecoderSizePrefix(getBytesDecoder(), getShortU16Decoder())
      ]
    ]), (instruction) => {
      if (instruction.accountIndices.length && instruction.data.byteLength) {
        return instruction;
      }
      const { accountIndices, data, ...rest } = instruction;
      return {
        ...rest,
        ...accountIndices.length ? { accountIndices } : null,
        ...data.byteLength ? { data } : null
      };
    });
  }
  return memoizedGetInstructionDecoder;
}
function getTransactionVersionEncoder() {
  return createEncoder2({
    getSizeFromValue: (value) => value === "legacy" ? 0 : 1,
    maxSize: 1,
    write: (value, bytes, offset) => {
      if (value === "legacy") {
        return offset;
      }
      if (value < 0 || value > 127) {
        throw new SolanaError2(SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE2, {
          actualVersion: value
        });
      }
      if (value > MAX_SUPPORTED_TRANSACTION_VERSION) {
        throw new SolanaError2(SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_NOT_SUPPORTED2, {
          unsupportedVersion: value
        });
      }
      bytes.set([value | VERSION_FLAG_MASK], offset);
      return offset + 1;
    }
  });
}
function getTransactionVersionDecoder() {
  return createDecoder2({
    maxSize: 1,
    read: (bytes, offset) => {
      const firstByte = bytes[offset];
      if ((firstByte & VERSION_FLAG_MASK) === 0) {
        return ["legacy", offset];
      } else {
        const version = firstByte ^ VERSION_FLAG_MASK;
        if (version > MAX_SUPPORTED_TRANSACTION_VERSION) {
          throw new SolanaError2(SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_NOT_SUPPORTED2, {
            unsupportedVersion: version
          });
        }
        return [version, offset + 1];
      }
    }
  });
}
function getTransactionVersionCodec() {
  return combineCodec2(getTransactionVersionEncoder(), getTransactionVersionDecoder());
}
function getCompiledMessageLegacyEncoder() {
  return getStructEncoder(getPreludeStructEncoderTuple());
}
function getCompiledMessageVersionedEncoder() {
  return transformEncoder2(getStructEncoder([
    ...getPreludeStructEncoderTuple(),
    ["addressTableLookups", getAddressTableLookupArrayEncoder()]
  ]), (value) => {
    if (value.version === "legacy") {
      return value;
    }
    return {
      ...value,
      addressTableLookups: value.addressTableLookups ?? []
    };
  });
}
function getPreludeStructEncoderTuple() {
  const lifetimeTokenEncoder = getUnionEncoder([
    getConstantEncoder(new Uint8Array(32)),
    fixEncoderSize2(getBase58Encoder3(), 32)
  ], (value) => value === undefined ? 0 : 1);
  return [
    ["version", getTransactionVersionEncoder()],
    ["header", getMessageHeaderEncoder()],
    ["staticAccounts", getArrayEncoder(getAddressEncoder2(), { size: getShortU16Encoder() })],
    ["lifetimeToken", lifetimeTokenEncoder],
    ["instructions", getArrayEncoder(getInstructionEncoder(), { size: getShortU16Encoder() })]
  ];
}
function getPreludeStructDecoderTuple() {
  return [
    ["version", getTransactionVersionDecoder()],
    ["header", getMessageHeaderDecoder()],
    ["staticAccounts", getArrayDecoder(getAddressDecoder2(), { size: getShortU16Decoder() })],
    ["lifetimeToken", fixDecoderSize2(getBase58Decoder3(), 32)],
    ["instructions", getArrayDecoder(getInstructionDecoder(), { size: getShortU16Decoder() })],
    ["addressTableLookups", getAddressTableLookupArrayDecoder()]
  ];
}
function getAddressTableLookupArrayEncoder() {
  return getArrayEncoder(getAddressTableLookupEncoder(), { size: getShortU16Encoder() });
}
function getAddressTableLookupArrayDecoder() {
  return getArrayDecoder(getAddressTableLookupDecoder(), { size: getShortU16Decoder() });
}
function getCompiledTransactionMessageEncoder() {
  return createEncoder2({
    getSizeFromValue: (compiledMessage) => {
      if (compiledMessage.version === "legacy") {
        return getCompiledMessageLegacyEncoder().getSizeFromValue(compiledMessage);
      } else {
        return getCompiledMessageVersionedEncoder().getSizeFromValue(compiledMessage);
      }
    },
    write: (compiledMessage, bytes, offset) => {
      if (compiledMessage.version === "legacy") {
        return getCompiledMessageLegacyEncoder().write(compiledMessage, bytes, offset);
      } else {
        return getCompiledMessageVersionedEncoder().write(compiledMessage, bytes, offset);
      }
    }
  });
}
function getCompiledTransactionMessageDecoder() {
  return transformDecoder(getStructDecoder(getPreludeStructDecoderTuple()), ({ addressTableLookups, ...restOfMessage }) => {
    if (restOfMessage.version === "legacy" || !addressTableLookups?.length) {
      return restOfMessage;
    }
    return { ...restOfMessage, addressTableLookups };
  });
}
function getCompiledTransactionMessageCodec() {
  return combineCodec2(getCompiledTransactionMessageEncoder(), getCompiledTransactionMessageDecoder());
}
function upsert(addressMap, address3, update) {
  addressMap[address3] = update(addressMap[address3] ?? { role: AccountRole.READONLY });
}
function getAddressMapFromInstructions(feePayer, instructions) {
  const addressMap = {
    [feePayer]: { [TYPE3]: 0, role: AccountRole.WRITABLE_SIGNER }
  };
  const addressesOfInvokedPrograms = /* @__PURE__ */ new Set;
  for (const instruction of instructions) {
    upsert(addressMap, instruction.programAddress, (entry) => {
      addressesOfInvokedPrograms.add(instruction.programAddress);
      if (TYPE3 in entry) {
        if (isWritableRole(entry.role)) {
          switch (entry[TYPE3]) {
            case 0:
              throw new SolanaError2(SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES2, {
                programAddress: instruction.programAddress
              });
            default:
              throw new SolanaError2(SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE2, {
                programAddress: instruction.programAddress
              });
          }
        }
        if (entry[TYPE3] === 2) {
          return entry;
        }
      }
      return { [TYPE3]: 2, role: AccountRole.READONLY };
    });
    let addressComparator;
    if (!instruction.accounts) {
      continue;
    }
    for (const account of instruction.accounts) {
      upsert(addressMap, account.address, (entry) => {
        const {
          address: _,
          ...accountMeta
        } = account;
        if (TYPE3 in entry) {
          switch (entry[TYPE3]) {
            case 0:
              return entry;
            case 1: {
              const nextRole = mergeRoles(entry.role, accountMeta.role);
              if ("lookupTableAddress" in accountMeta) {
                const shouldReplaceEntry = entry.lookupTableAddress !== accountMeta.lookupTableAddress && (addressComparator ||= getAddressComparator2())(accountMeta.lookupTableAddress, entry.lookupTableAddress) < 0;
                if (shouldReplaceEntry) {
                  return {
                    [TYPE3]: 1,
                    ...accountMeta,
                    role: nextRole
                  };
                }
              } else if (isSignerRole(accountMeta.role)) {
                return {
                  [TYPE3]: 2,
                  role: nextRole
                };
              }
              if (entry.role !== nextRole) {
                return {
                  ...entry,
                  role: nextRole
                };
              } else {
                return entry;
              }
            }
            case 2: {
              const nextRole = mergeRoles(entry.role, accountMeta.role);
              if (addressesOfInvokedPrograms.has(account.address)) {
                if (isWritableRole(accountMeta.role)) {
                  throw new SolanaError2(SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE2, {
                    programAddress: account.address
                  });
                }
                if (entry.role !== nextRole) {
                  return {
                    ...entry,
                    role: nextRole
                  };
                } else {
                  return entry;
                }
              } else if ("lookupTableAddress" in accountMeta && !isSignerRole(entry.role)) {
                return {
                  ...accountMeta,
                  [TYPE3]: 1,
                  role: nextRole
                };
              } else {
                if (entry.role !== nextRole) {
                  return {
                    ...entry,
                    role: nextRole
                  };
                } else {
                  return entry;
                }
              }
            }
          }
        }
        if ("lookupTableAddress" in accountMeta) {
          return {
            ...accountMeta,
            [TYPE3]: 1
          };
        } else {
          return {
            ...accountMeta,
            [TYPE3]: 2
          };
        }
      });
    }
  }
  return addressMap;
}
function getOrderedAccountsFromAddressMap(addressMap) {
  let addressComparator;
  const orderedAccounts = Object.entries(addressMap).sort(([leftAddress, leftEntry], [rightAddress, rightEntry]) => {
    if (leftEntry[TYPE3] !== rightEntry[TYPE3]) {
      if (leftEntry[TYPE3] === 0) {
        return -1;
      } else if (rightEntry[TYPE3] === 0) {
        return 1;
      } else if (leftEntry[TYPE3] === 2) {
        return -1;
      } else if (rightEntry[TYPE3] === 2) {
        return 1;
      }
    }
    const leftIsSigner = isSignerRole(leftEntry.role);
    if (leftIsSigner !== isSignerRole(rightEntry.role)) {
      return leftIsSigner ? -1 : 1;
    }
    const leftIsWritable = isWritableRole(leftEntry.role);
    if (leftIsWritable !== isWritableRole(rightEntry.role)) {
      return leftIsWritable ? -1 : 1;
    }
    addressComparator ||= getAddressComparator2();
    if (leftEntry[TYPE3] === 1 && rightEntry[TYPE3] === 1 && leftEntry.lookupTableAddress !== rightEntry.lookupTableAddress) {
      return addressComparator(leftEntry.lookupTableAddress, rightEntry.lookupTableAddress);
    } else {
      return addressComparator(leftAddress, rightAddress);
    }
  }).map(([address3, addressMeta]) => ({
    address: address3,
    ...addressMeta
  }));
  return orderedAccounts;
}
function getCompiledAddressTableLookups(orderedAccounts) {
  const index = {};
  for (const account of orderedAccounts) {
    if (!("lookupTableAddress" in account)) {
      continue;
    }
    const entry = index[account.lookupTableAddress] ||= {
      readonlyIndexes: [],
      writableIndexes: []
    };
    if (account.role === AccountRole.WRITABLE) {
      entry.writableIndexes.push(account.addressIndex);
    } else {
      entry.readonlyIndexes.push(account.addressIndex);
    }
  }
  return Object.keys(index).sort(getAddressComparator2()).map((lookupTableAddress) => ({
    lookupTableAddress,
    ...index[lookupTableAddress]
  }));
}
function getCompiledMessageHeader(orderedAccounts) {
  let numReadonlyNonSignerAccounts = 0;
  let numReadonlySignerAccounts = 0;
  let numSignerAccounts = 0;
  for (const account of orderedAccounts) {
    if ("lookupTableAddress" in account) {
      break;
    }
    const accountIsWritable = isWritableRole(account.role);
    if (isSignerRole(account.role)) {
      numSignerAccounts++;
      if (!accountIsWritable) {
        numReadonlySignerAccounts++;
      }
    } else if (!accountIsWritable) {
      numReadonlyNonSignerAccounts++;
    }
  }
  return {
    numReadonlyNonSignerAccounts,
    numReadonlySignerAccounts,
    numSignerAccounts
  };
}
function getAccountIndex(orderedAccounts) {
  const out = {};
  for (const [index, account] of orderedAccounts.entries()) {
    out[account.address] = index;
  }
  return out;
}
function getCompiledInstructions(instructions, orderedAccounts) {
  const accountIndex = getAccountIndex(orderedAccounts);
  return instructions.map(({ accounts, data, programAddress }) => {
    return {
      programAddressIndex: accountIndex[programAddress],
      ...accounts ? { accountIndices: accounts.map(({ address: address3 }) => accountIndex[address3]) } : null,
      ...data ? { data } : null
    };
  });
}
function getCompiledLifetimeToken(lifetimeConstraint) {
  if ("nonce" in lifetimeConstraint) {
    return lifetimeConstraint.nonce;
  }
  return lifetimeConstraint.blockhash;
}
function getCompiledStaticAccounts(orderedAccounts) {
  const firstLookupTableAccountIndex = orderedAccounts.findIndex((account) => ("lookupTableAddress" in account));
  const orderedStaticAccounts = firstLookupTableAccountIndex === -1 ? orderedAccounts : orderedAccounts.slice(0, firstLookupTableAccountIndex);
  return orderedStaticAccounts.map(({ address: address3 }) => address3);
}
function compileTransactionMessage(transactionMessage) {
  const addressMap = getAddressMapFromInstructions(transactionMessage.feePayer.address, transactionMessage.instructions);
  const orderedAccounts = getOrderedAccountsFromAddressMap(addressMap);
  const lifetimeConstraint = transactionMessage.lifetimeConstraint;
  return {
    ...transactionMessage.version !== "legacy" ? { addressTableLookups: getCompiledAddressTableLookups(orderedAccounts) } : null,
    ...lifetimeConstraint ? { lifetimeToken: getCompiledLifetimeToken(lifetimeConstraint) } : null,
    header: getCompiledMessageHeader(orderedAccounts),
    instructions: getCompiledInstructions(transactionMessage.instructions, orderedAccounts),
    staticAccounts: getCompiledStaticAccounts(orderedAccounts),
    version: transactionMessage.version
  };
}
function findAddressInLookupTables(address3, role, addressesByLookupTableAddress) {
  for (const [lookupTableAddress, addresses] of Object.entries(addressesByLookupTableAddress)) {
    for (let i = 0;i < addresses.length; i++) {
      if (address3 === addresses[i]) {
        return {
          address: address3,
          addressIndex: i,
          lookupTableAddress,
          role
        };
      }
    }
  }
}
function compressTransactionMessageUsingAddressLookupTables(transactionMessage, addressesByLookupTableAddress) {
  const programAddresses = new Set(transactionMessage.instructions.map((ix) => ix.programAddress));
  const eligibleLookupAddresses = new Set(Object.values(addressesByLookupTableAddress).flatMap((a) => a).filter((address3) => !programAddresses.has(address3)));
  const newInstructions = [];
  let updatedAnyInstructions = false;
  for (const instruction of transactionMessage.instructions) {
    if (!instruction.accounts) {
      newInstructions.push(instruction);
      continue;
    }
    const newAccounts = [];
    let updatedAnyAccounts = false;
    for (const account of instruction.accounts) {
      if ("lookupTableAddress" in account || !eligibleLookupAddresses.has(account.address) || isSignerRole(account.role)) {
        newAccounts.push(account);
        continue;
      }
      const lookupMetaAccount = findAddressInLookupTables(account.address, account.role, addressesByLookupTableAddress);
      newAccounts.push(Object.freeze(lookupMetaAccount));
      updatedAnyAccounts = true;
      updatedAnyInstructions = true;
    }
    newInstructions.push(Object.freeze(updatedAnyAccounts ? { ...instruction, accounts: newAccounts } : instruction));
  }
  return Object.freeze(updatedAnyInstructions ? { ...transactionMessage, instructions: newInstructions } : transactionMessage);
}
function createTransactionMessage(config) {
  return Object.freeze({
    instructions: Object.freeze([]),
    version: config.version
  });
}
function createAdvanceNonceAccountInstruction(nonceAccountAddress, nonceAuthorityAddress) {
  return {
    accounts: [
      { address: nonceAccountAddress, role: AccountRole.WRITABLE },
      {
        address: RECENT_BLOCKHASHES_SYSVAR_ADDRESS,
        role: AccountRole.READONLY
      },
      { address: nonceAuthorityAddress, role: AccountRole.READONLY_SIGNER }
    ],
    data: new Uint8Array([4, 0, 0, 0]),
    programAddress: SYSTEM_PROGRAM_ADDRESS
  };
}
function isAdvanceNonceAccountInstruction(instruction) {
  return instruction.programAddress === SYSTEM_PROGRAM_ADDRESS && instruction.data != null && isAdvanceNonceAccountInstructionData(instruction.data) && instruction.accounts?.length === 3 && instruction.accounts[0].address != null && instruction.accounts[0].role === AccountRole.WRITABLE && instruction.accounts[1].address === RECENT_BLOCKHASHES_SYSVAR_ADDRESS && instruction.accounts[1].role === AccountRole.READONLY && instruction.accounts[2].address != null && isSignerRole(instruction.accounts[2].role);
}
function isAdvanceNonceAccountInstructionData(data) {
  return data.byteLength === 4 && data[0] === 4 && data[1] === 0 && data[2] === 0 && data[3] === 0;
}
function isTransactionMessageWithDurableNonceLifetime(transactionMessage) {
  return "lifetimeConstraint" in transactionMessage && typeof transactionMessage.lifetimeConstraint.nonce === "string" && transactionMessage.instructions[0] != null && isAdvanceNonceAccountInstruction(transactionMessage.instructions[0]);
}
function assertIsTransactionMessageWithDurableNonceLifetime(transactionMessage) {
  if (!isTransactionMessageWithDurableNonceLifetime(transactionMessage)) {
    throw new SolanaError2(SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME2);
  }
}
function isAdvanceNonceAccountInstructionForNonce(instruction, nonceAccountAddress, nonceAuthorityAddress) {
  return instruction.accounts[0].address === nonceAccountAddress && instruction.accounts[2].address === nonceAuthorityAddress;
}
function setTransactionMessageLifetimeUsingDurableNonce({
  nonce,
  nonceAccountAddress,
  nonceAuthorityAddress
}, transactionMessage) {
  let newInstructions;
  const firstInstruction = transactionMessage.instructions[0];
  if (firstInstruction && isAdvanceNonceAccountInstruction(firstInstruction)) {
    if (isAdvanceNonceAccountInstructionForNonce(firstInstruction, nonceAccountAddress, nonceAuthorityAddress)) {
      if (isTransactionMessageWithDurableNonceLifetime(transactionMessage) && transactionMessage.lifetimeConstraint.nonce === nonce) {
        return transactionMessage;
      } else {
        newInstructions = [firstInstruction, ...transactionMessage.instructions.slice(1)];
      }
    } else {
      newInstructions = [
        Object.freeze(createAdvanceNonceAccountInstruction(nonceAccountAddress, nonceAuthorityAddress)),
        ...transactionMessage.instructions.slice(1)
      ];
    }
  } else {
    newInstructions = [
      Object.freeze(createAdvanceNonceAccountInstruction(nonceAccountAddress, nonceAuthorityAddress)),
      ...transactionMessage.instructions
    ];
  }
  return Object.freeze({
    ...transactionMessage,
    instructions: Object.freeze(newInstructions),
    lifetimeConstraint: Object.freeze({ nonce })
  });
}
function setTransactionMessageFeePayer(feePayer, transactionMessage) {
  if ("feePayer" in transactionMessage && feePayer === transactionMessage.feePayer?.address && isAddressOnlyFeePayer(transactionMessage.feePayer)) {
    return transactionMessage;
  }
  const out = {
    ...transactionMessage,
    feePayer: Object.freeze({ address: feePayer })
  };
  Object.freeze(out);
  return out;
}
function isAddressOnlyFeePayer(feePayer) {
  return !!feePayer && "address" in feePayer && typeof feePayer.address === "string" && Object.keys(feePayer).length === 1;
}
function appendTransactionMessageInstruction(instruction, transactionMessage) {
  return appendTransactionMessageInstructions([instruction], transactionMessage);
}
function appendTransactionMessageInstructions(instructions, transactionMessage) {
  return Object.freeze({
    ...transactionMessage,
    instructions: Object.freeze([
      ...transactionMessage.instructions,
      ...instructions
    ])
  });
}
function prependTransactionMessageInstruction(instruction, transactionMessage) {
  return prependTransactionMessageInstructions([instruction], transactionMessage);
}
function prependTransactionMessageInstructions(instructions, transactionMessage) {
  return Object.freeze({
    ...transactionMessage,
    instructions: Object.freeze([
      ...instructions,
      ...transactionMessage.instructions
    ])
  });
}
function getAccountMetas(message) {
  const { header } = message;
  const numWritableSignerAccounts = header.numSignerAccounts - header.numReadonlySignerAccounts;
  const numWritableNonSignerAccounts = message.staticAccounts.length - header.numSignerAccounts - header.numReadonlyNonSignerAccounts;
  const accountMetas = [];
  let accountIndex = 0;
  for (let i = 0;i < numWritableSignerAccounts; i++) {
    accountMetas.push({
      address: message.staticAccounts[accountIndex],
      role: AccountRole.WRITABLE_SIGNER
    });
    accountIndex++;
  }
  for (let i = 0;i < header.numReadonlySignerAccounts; i++) {
    accountMetas.push({
      address: message.staticAccounts[accountIndex],
      role: AccountRole.READONLY_SIGNER
    });
    accountIndex++;
  }
  for (let i = 0;i < numWritableNonSignerAccounts; i++) {
    accountMetas.push({
      address: message.staticAccounts[accountIndex],
      role: AccountRole.WRITABLE
    });
    accountIndex++;
  }
  for (let i = 0;i < header.numReadonlyNonSignerAccounts; i++) {
    accountMetas.push({
      address: message.staticAccounts[accountIndex],
      role: AccountRole.READONLY
    });
    accountIndex++;
  }
  return accountMetas;
}
function getAddressLookupMetas(compiledAddressTableLookups, addressesByLookupTableAddress) {
  const compiledAddressTableLookupAddresses = compiledAddressTableLookups.map((l) => l.lookupTableAddress);
  const missing = compiledAddressTableLookupAddresses.filter((a) => addressesByLookupTableAddress[a] === undefined);
  if (missing.length > 0) {
    throw new SolanaError2(SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING2, {
      lookupTableAddresses: missing
    });
  }
  const readOnlyMetas = [];
  const writableMetas = [];
  for (const lookup of compiledAddressTableLookups) {
    const addresses = addressesByLookupTableAddress[lookup.lookupTableAddress];
    const readonlyIndexes = lookup.readonlyIndexes;
    const writableIndexes = lookup.writableIndexes;
    const highestIndex = Math.max(...readonlyIndexes, ...writableIndexes);
    if (highestIndex >= addresses.length) {
      throw new SolanaError2(SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE2, {
        highestKnownIndex: addresses.length - 1,
        highestRequestedIndex: highestIndex,
        lookupTableAddress: lookup.lookupTableAddress
      });
    }
    const readOnlyForLookup = readonlyIndexes.map((r) => ({
      address: addresses[r],
      addressIndex: r,
      lookupTableAddress: lookup.lookupTableAddress,
      role: AccountRole.READONLY
    }));
    readOnlyMetas.push(...readOnlyForLookup);
    const writableForLookup = writableIndexes.map((w) => ({
      address: addresses[w],
      addressIndex: w,
      lookupTableAddress: lookup.lookupTableAddress,
      role: AccountRole.WRITABLE
    }));
    writableMetas.push(...writableForLookup);
  }
  return [...writableMetas, ...readOnlyMetas];
}
function convertInstruction(instruction, accountMetas) {
  const programAddress = accountMetas[instruction.programAddressIndex]?.address;
  if (!programAddress) {
    throw new SolanaError2(SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND2, {
      index: instruction.programAddressIndex
    });
  }
  const accounts = instruction.accountIndices?.map((accountIndex) => accountMetas[accountIndex]);
  const { data } = instruction;
  return Object.freeze({
    programAddress,
    ...accounts && accounts.length ? { accounts: Object.freeze(accounts) } : {},
    ...data && data.length ? { data } : {}
  });
}
function getLifetimeConstraint(messageLifetimeToken, firstInstruction, lastValidBlockHeight) {
  if (!firstInstruction || !isAdvanceNonceAccountInstruction(firstInstruction)) {
    return {
      blockhash: messageLifetimeToken,
      lastValidBlockHeight: lastValidBlockHeight ?? 2n ** 64n - 1n
    };
  } else {
    const nonceAccountAddress = firstInstruction.accounts[0].address;
    assertIsAddress2(nonceAccountAddress);
    const nonceAuthorityAddress = firstInstruction.accounts[2].address;
    assertIsAddress2(nonceAuthorityAddress);
    return {
      nonce: messageLifetimeToken,
      nonceAccountAddress,
      nonceAuthorityAddress
    };
  }
}
function decompileTransactionMessage(compiledTransactionMessage, config) {
  const feePayer = compiledTransactionMessage.staticAccounts[0];
  if (!feePayer) {
    throw new SolanaError2(SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING2);
  }
  const accountMetas = getAccountMetas(compiledTransactionMessage);
  const accountLookupMetas = "addressTableLookups" in compiledTransactionMessage && compiledTransactionMessage.addressTableLookups !== undefined && compiledTransactionMessage.addressTableLookups.length > 0 ? getAddressLookupMetas(compiledTransactionMessage.addressTableLookups, config?.addressesByLookupTableAddress ?? {}) : [];
  const transactionMetas = [...accountMetas, ...accountLookupMetas];
  const instructions = compiledTransactionMessage.instructions.map((compiledInstruction) => convertInstruction(compiledInstruction, transactionMetas));
  const firstInstruction = instructions[0];
  const lifetimeConstraint = getLifetimeConstraint(compiledTransactionMessage.lifetimeToken, firstInstruction, config?.lastValidBlockHeight);
  return pipe(createTransactionMessage({ version: compiledTransactionMessage.version }), (m) => setTransactionMessageFeePayer(feePayer, m), (m) => instructions.reduce((acc, instruction) => appendTransactionMessageInstruction(instruction, acc), m), (m) => ("blockhash" in lifetimeConstraint) ? setTransactionMessageLifetimeUsingBlockhash(lifetimeConstraint, m) : setTransactionMessageLifetimeUsingDurableNonce(lifetimeConstraint, m));
}
var getBaseXEncoder3 = (alphabet4) => {
  return createEncoder2({
    getSizeFromValue: (value) => {
      const [leadingZeroes, tailChars] = partitionLeadingZeroes3(value, alphabet4[0]);
      if (!tailChars)
        return value.length;
      const base10Number = getBigIntFromBaseX3(tailChars, alphabet4);
      return leadingZeroes.length + Math.ceil(base10Number.toString(16).length / 2);
    },
    write(value, bytes, offset) {
      assertValidBaseString3(alphabet4, value);
      if (value === "")
        return offset;
      const [leadingZeroes, tailChars] = partitionLeadingZeroes3(value, alphabet4[0]);
      if (!tailChars) {
        bytes.set(new Uint8Array(leadingZeroes.length).fill(0), offset);
        return offset + leadingZeroes.length;
      }
      let base10Number = getBigIntFromBaseX3(tailChars, alphabet4);
      const tailBytes = [];
      while (base10Number > 0n) {
        tailBytes.unshift(Number(base10Number % 256n));
        base10Number /= 256n;
      }
      const bytesToAdd = [...Array(leadingZeroes.length).fill(0), ...tailBytes];
      bytes.set(bytesToAdd, offset);
      return offset + bytesToAdd.length;
    }
  });
}, getBaseXDecoder3 = (alphabet4) => {
  return createDecoder2({
    read(rawBytes, offset) {
      const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);
      if (bytes.length === 0)
        return ["", 0];
      let trailIndex = bytes.findIndex((n) => n !== 0);
      trailIndex = trailIndex === -1 ? bytes.length : trailIndex;
      const leadingZeroes = alphabet4[0].repeat(trailIndex);
      if (trailIndex === bytes.length)
        return [leadingZeroes, rawBytes.length];
      const base10Number = bytes.slice(trailIndex).reduce((sum, byte) => sum * 256n + BigInt(byte), 0n);
      const tailChars = getBaseXFromBigInt3(base10Number, alphabet4);
      return [leadingZeroes + tailChars, rawBytes.length];
    }
  });
}, alphabet23 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz", getBase58Encoder3 = () => getBaseXEncoder3(alphabet23), getBase58Decoder3 = () => getBaseXDecoder3(alphabet23), memoizedAddressTableLookupEncoder, memoizedAddressTableLookupDecoder, memoizedU8Encoder, memoizedU8Decoder, memoizedGetInstructionEncoder, memoizedGetInstructionDecoder, MAX_SUPPORTED_TRANSACTION_VERSION = 0, VERSION_FLAG_MASK = 128, TYPE3, RECENT_BLOCKHASHES_SYSVAR_ADDRESS = "SysvarRecentB1ockHashes11111111111111111111", SYSTEM_PROGRAM_ADDRESS = "11111111111111111111111111111111";
var init_index_node19 = __esm(() => {
  init_index_node6();
  init_index_node18();
  init_index_node11();
  init_index_node7();
  init_index_node13();
  init_index_node12();
  init_index_node17();
  init_index_node16();
  TYPE3 = Symbol("AddressMapTypeProperty");
});

// ../../node_modules/.bun/@solana+keys@5.1.0+7f9e3d21594a24ff/node_modules/@solana/keys/dist/index.node.mjs
function addPkcs8Header(bytes) {
  return new Uint8Array([
    48,
    46,
    2,
    1,
    0,
    48,
    5,
    6,
    3,
    43,
    101,
    112,
    4,
    34,
    4,
    32,
    ...bytes
  ]);
}
async function createPrivateKeyFromBytes(bytes, extractable = false) {
  const actualLength = bytes.byteLength;
  if (actualLength !== 32) {
    throw new SolanaError2(SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH2, {
      actualLength
    });
  }
  const privateKeyBytesPkcs8 = addPkcs8Header(bytes);
  return await crypto.subtle.importKey("pkcs8", privateKeyBytesPkcs8, ED25519_ALGORITHM_IDENTIFIER, extractable, [
    "sign"
  ]);
}
async function getPublicKeyFromPrivateKey(privateKey, extractable = false) {
  assertKeyExporterIsAvailable2();
  if (privateKey.extractable === false) {
    throw new SolanaError2(SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY2, { key: privateKey });
  }
  const jwk = await crypto.subtle.exportKey("jwk", privateKey);
  return await crypto.subtle.importKey("jwk", {
    crv: "Ed25519",
    ext: extractable,
    key_ops: ["verify"],
    kty: "OKP",
    x: jwk.x
  }, "Ed25519", extractable, ["verify"]);
}
function assertIsSignature(putativeSignature) {
  if (!base58Encoder)
    base58Encoder = getBase58Encoder2();
  if (putativeSignature.length < 64 || putativeSignature.length > 88) {
    throw new SolanaError2(SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE2, {
      actualLength: putativeSignature.length
    });
  }
  const bytes = base58Encoder.encode(putativeSignature);
  assertIsSignatureBytes(bytes);
}
function assertIsSignatureBytes(putativeSignatureBytes) {
  const numBytes = putativeSignatureBytes.byteLength;
  if (numBytes !== 64) {
    throw new SolanaError2(SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH2, {
      actualLength: numBytes
    });
  }
}
function isSignature(putativeSignature) {
  if (!base58Encoder)
    base58Encoder = getBase58Encoder2();
  if (putativeSignature.length < 64 || putativeSignature.length > 88) {
    return false;
  }
  const bytes = base58Encoder.encode(putativeSignature);
  return isSignatureBytes(bytes);
}
function isSignatureBytes(putativeSignatureBytes) {
  return putativeSignatureBytes.byteLength === 64;
}
async function signBytes(key, data) {
  assertSigningCapabilityIsAvailable();
  const signedData = await crypto.subtle.sign(ED25519_ALGORITHM_IDENTIFIER, key, data);
  return new Uint8Array(signedData);
}
function signature(putativeSignature) {
  assertIsSignature(putativeSignature);
  return putativeSignature;
}
function signatureBytes(putativeSignatureBytes) {
  assertIsSignatureBytes(putativeSignatureBytes);
  return putativeSignatureBytes;
}
async function verifySignature(key, signature2, data) {
  assertVerificationCapabilityIsAvailable();
  return await crypto.subtle.verify(ED25519_ALGORITHM_IDENTIFIER, key, signature2, data);
}
async function generateKeyPair() {
  await assertKeyGenerationIsAvailable();
  const keyPair = await crypto.subtle.generateKey(ED25519_ALGORITHM_IDENTIFIER, false, ["sign", "verify"]);
  return keyPair;
}
async function createKeyPairFromBytes(bytes, extractable = false) {
  assertPRNGIsAvailable();
  if (bytes.byteLength !== 64) {
    throw new SolanaError2(SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH2, { byteLength: bytes.byteLength });
  }
  const [publicKey, privateKey] = await Promise.all([
    crypto.subtle.importKey("raw", bytes.slice(32), ED25519_ALGORITHM_IDENTIFIER, true, [
      "verify"
    ]),
    createPrivateKeyFromBytes(bytes.slice(0, 32), extractable)
  ]);
  const randomBytes = new Uint8Array(32);
  crypto.getRandomValues(randomBytes);
  const signedData = await signBytes(privateKey, randomBytes);
  const isValid = await verifySignature(publicKey, signedData, randomBytes);
  if (!isValid) {
    throw new SolanaError2(SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY2);
  }
  return { privateKey, publicKey };
}
async function createKeyPairFromPrivateKeyBytes(bytes, extractable = false) {
  const privateKeyPromise = createPrivateKeyFromBytes(bytes, extractable);
  const [publicKey, privateKey] = await Promise.all([
    (extractable ? privateKeyPromise : createPrivateKeyFromBytes(bytes, true)).then(async (privateKey2) => await getPublicKeyFromPrivateKey(privateKey2, true)),
    privateKeyPromise
  ]);
  return { privateKey, publicKey };
}
var ED25519_ALGORITHM_IDENTIFIER, base58Encoder;
var init_index_node20 = __esm(() => {
  init_index_node10();
  init_index_node6();
  init_index_node8();
  ED25519_ALGORITHM_IDENTIFIER = Object.freeze({ name: "Ed25519" });
});

// ../../node_modules/.bun/@solana+transactions@5.1.0+7f9e3d21594a24ff/node_modules/@solana/transactions/dist/index.node.mjs
function getSignaturesToEncode(signaturesMap) {
  const signatures = Object.values(signaturesMap);
  if (signatures.length === 0) {
    throw new SolanaError2(SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES2);
  }
  return signatures.map((signature2) => {
    if (!signature2) {
      return new Uint8Array(64).fill(0);
    }
    return signature2;
  });
}
function getSignaturesEncoder() {
  return transformEncoder2(getArrayEncoder(fixEncoderSize2(getBytesEncoder(), 64), { size: getShortU16Encoder() }), getSignaturesToEncode);
}
function getTransactionEncoder() {
  return getStructEncoder([
    ["signatures", getSignaturesEncoder()],
    ["messageBytes", getBytesEncoder()]
  ]);
}
function getTransactionDecoder() {
  return transformDecoder(getStructDecoder([
    ["signatures", getArrayDecoder(fixDecoderSize2(getBytesDecoder(), 64), { size: getShortU16Decoder() })],
    ["messageBytes", getBytesDecoder()]
  ]), decodePartiallyDecodedTransaction);
}
function getTransactionCodec() {
  return combineCodec2(getTransactionEncoder(), getTransactionDecoder());
}
function decodePartiallyDecodedTransaction(transaction) {
  const { messageBytes, signatures } = transaction;
  const signerAddressesDecoder = getTupleDecoder([
    getTransactionVersionDecoder(),
    padRightDecoder(getU8Decoder(), 2),
    getArrayDecoder(getAddressDecoder2(), { size: getShortU16Decoder() })
  ]);
  const [_txVersion, numRequiredSignatures, staticAddresses] = signerAddressesDecoder.decode(messageBytes);
  const signerAddresses = staticAddresses.slice(0, numRequiredSignatures);
  if (signerAddresses.length !== signatures.length) {
    throw new SolanaError2(SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH2, {
      numRequiredSignatures,
      signaturesLength: signatures.length,
      signerAddresses
    });
  }
  const signaturesMap = {};
  signerAddresses.forEach((address3, index) => {
    const signatureForAddress = signatures[index];
    if (signatureForAddress.every((b) => b === 0)) {
      signaturesMap[address3] = null;
    } else {
      signaturesMap[address3] = signatureForAddress;
    }
  });
  return {
    messageBytes,
    signatures: Object.freeze(signaturesMap)
  };
}
function compiledInstructionIsAdvanceNonceInstruction(instruction, staticAddresses) {
  return staticAddresses[instruction.programAddressIndex] === SYSTEM_PROGRAM_ADDRESS2 && instruction.data != null && isAdvanceNonceAccountInstructionData2(instruction.data) && instruction.accountIndices?.length === 3;
}
function isAdvanceNonceAccountInstructionData2(data) {
  return data.byteLength === 4 && data[0] === 4 && data[1] === 0 && data[2] === 0 && data[3] === 0;
}
async function getTransactionLifetimeConstraintFromCompiledTransactionMessage(compiledTransactionMessage) {
  const firstInstruction = compiledTransactionMessage.instructions[0];
  const { staticAccounts } = compiledTransactionMessage;
  if (firstInstruction && compiledInstructionIsAdvanceNonceInstruction(firstInstruction, staticAccounts)) {
    const nonceAccountAddress = staticAccounts[firstInstruction.accountIndices[0]];
    if (!nonceAccountAddress) {
      throw new SolanaError2(SOLANA_ERROR__TRANSACTION__NONCE_ACCOUNT_CANNOT_BE_IN_LOOKUP_TABLE2, {
        nonce: compiledTransactionMessage.lifetimeToken
      });
    }
    return {
      nonce: compiledTransactionMessage.lifetimeToken,
      nonceAccountAddress
    };
  } else {
    return {
      blockhash: compiledTransactionMessage.lifetimeToken,
      lastValidBlockHeight: 0xffffffffffffffffn
    };
  }
}
function isTransactionWithBlockhashLifetime(transaction) {
  return "lifetimeConstraint" in transaction && "blockhash" in transaction.lifetimeConstraint && typeof transaction.lifetimeConstraint.blockhash === "string" && typeof transaction.lifetimeConstraint.lastValidBlockHeight === "bigint" && isBlockhash(transaction.lifetimeConstraint.blockhash);
}
function assertIsTransactionWithBlockhashLifetime(transaction) {
  if (!isTransactionWithBlockhashLifetime(transaction)) {
    throw new SolanaError2(SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME2);
  }
}
function isTransactionWithDurableNonceLifetime(transaction) {
  return "lifetimeConstraint" in transaction && "nonce" in transaction.lifetimeConstraint && typeof transaction.lifetimeConstraint.nonce === "string" && typeof transaction.lifetimeConstraint.nonceAccountAddress === "string" && isAddress2(transaction.lifetimeConstraint.nonceAccountAddress);
}
function assertIsTransactionWithDurableNonceLifetime(transaction) {
  if (!isTransactionWithDurableNonceLifetime(transaction)) {
    throw new SolanaError2(SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME2);
  }
}
function compileTransaction(transactionMessage) {
  const compiledMessage = compileTransactionMessage(transactionMessage);
  const messageBytes = getCompiledTransactionMessageEncoder().encode(compiledMessage);
  const transactionSigners = compiledMessage.staticAccounts.slice(0, compiledMessage.header.numSignerAccounts);
  const signatures = {};
  for (const signerAddress of transactionSigners) {
    signatures[signerAddress] = null;
  }
  let lifetimeConstraint;
  if (isTransactionMessageWithBlockhashLifetime(transactionMessage)) {
    lifetimeConstraint = {
      blockhash: transactionMessage.lifetimeConstraint.blockhash,
      lastValidBlockHeight: transactionMessage.lifetimeConstraint.lastValidBlockHeight
    };
  } else if (isTransactionMessageWithDurableNonceLifetime(transactionMessage)) {
    lifetimeConstraint = {
      nonce: transactionMessage.lifetimeConstraint.nonce,
      nonceAccountAddress: transactionMessage.instructions[0].accounts[0].address
    };
  }
  return Object.freeze({
    ...lifetimeConstraint ? { lifetimeConstraint } : undefined,
    messageBytes,
    signatures: Object.freeze(signatures)
  });
}
function getSignatureFromTransaction(transaction) {
  if (!base58Decoder)
    base58Decoder = getBase58Decoder2();
  const signatureBytes2 = Object.values(transaction.signatures)[0];
  if (!signatureBytes2) {
    throw new SolanaError2(SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING2);
  }
  const transactionSignature = base58Decoder.decode(signatureBytes2);
  return transactionSignature;
}
async function partiallySignTransaction(keyPairs, transaction) {
  let newSignatures;
  let unexpectedSigners;
  await Promise.all(keyPairs.map(async (keyPair) => {
    const address3 = await getAddressFromPublicKey2(keyPair.publicKey);
    const existingSignature = transaction.signatures[address3];
    if (existingSignature === undefined) {
      unexpectedSigners ||= /* @__PURE__ */ new Set;
      unexpectedSigners.add(address3);
      return;
    }
    if (unexpectedSigners) {
      return;
    }
    const newSignature = await signBytes(keyPair.privateKey, transaction.messageBytes);
    if (existingSignature !== null && bytesEqual2(newSignature, existingSignature)) {
      return;
    }
    newSignatures ||= {};
    newSignatures[address3] = newSignature;
  }));
  if (unexpectedSigners && unexpectedSigners.size > 0) {
    const expectedSigners = Object.keys(transaction.signatures);
    throw new SolanaError2(SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION2, {
      expectedAddresses: expectedSigners,
      unexpectedAddresses: [...unexpectedSigners]
    });
  }
  if (!newSignatures) {
    return transaction;
  }
  return Object.freeze({
    ...transaction,
    signatures: Object.freeze({
      ...transaction.signatures,
      ...newSignatures
    })
  });
}
async function signTransaction(keyPairs, transaction) {
  const out = await partiallySignTransaction(keyPairs, transaction);
  assertIsFullySignedTransaction(out);
  Object.freeze(out);
  return out;
}
function isFullySignedTransaction(transaction) {
  return Object.entries(transaction.signatures).every(([_, signatureBytes2]) => !!signatureBytes2);
}
function assertIsFullySignedTransaction(transaction) {
  const missingSigs = [];
  Object.entries(transaction.signatures).forEach(([address3, signatureBytes2]) => {
    if (!signatureBytes2) {
      missingSigs.push(address3);
    }
  });
  if (missingSigs.length > 0) {
    throw new SolanaError2(SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING2, {
      addresses: missingSigs
    });
  }
}
function getBase64EncodedWireTransaction(transaction) {
  const wireTransactionBytes = getTransactionEncoder().encode(transaction);
  return getBase64Decoder().decode(wireTransactionBytes);
}
function getTransactionSize(transaction) {
  return getTransactionEncoder().getSizeFromValue(transaction);
}
function isTransactionWithinSizeLimit(transaction) {
  return getTransactionSize(transaction) <= TRANSACTION_SIZE_LIMIT;
}
function assertIsTransactionWithinSizeLimit(transaction) {
  const transactionSize = getTransactionSize(transaction);
  if (transactionSize > TRANSACTION_SIZE_LIMIT) {
    throw new SolanaError2(SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT2, {
      transactionSize,
      transactionSizeLimit: TRANSACTION_SIZE_LIMIT
    });
  }
}
function isSendableTransaction(transaction) {
  return isFullySignedTransaction(transaction) && isTransactionWithinSizeLimit(transaction);
}
function assertIsSendableTransaction(transaction) {
  assertIsFullySignedTransaction(transaction);
  assertIsTransactionWithinSizeLimit(transaction);
}
function getTransactionMessageSize(transactionMessage) {
  return getTransactionSize(compileTransaction(transactionMessage));
}
function isTransactionMessageWithinSizeLimit(transactionMessage) {
  return getTransactionMessageSize(transactionMessage) <= TRANSACTION_SIZE_LIMIT;
}
function assertIsTransactionMessageWithinSizeLimit(transactionMessage) {
  const transactionSize = getTransactionMessageSize(transactionMessage);
  if (transactionSize > TRANSACTION_SIZE_LIMIT) {
    throw new SolanaError2(SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT2, {
      transactionSize,
      transactionSizeLimit: TRANSACTION_SIZE_LIMIT
    });
  }
}
var SYSTEM_PROGRAM_ADDRESS2 = "11111111111111111111111111111111", base58Decoder, TRANSACTION_PACKET_SIZE = 1280, TRANSACTION_PACKET_HEADER, TRANSACTION_SIZE_LIMIT;
var init_index_node21 = __esm(() => {
  init_index_node11();
  init_index_node7();
  init_index_node13();
  init_index_node12();
  init_index_node6();
  init_index_node19();
  init_index_node18();
  init_index_node8();
  init_index_node20();
  TRANSACTION_PACKET_HEADER = 40 + 8;
  TRANSACTION_SIZE_LIMIT = TRANSACTION_PACKET_SIZE - TRANSACTION_PACKET_HEADER;
});

// ../../node_modules/.bun/@solana+promises@5.1.0+1fb4c65d43e298b9/node_modules/@solana/promises/dist/index.node.mjs
function isObject(value) {
  return value !== null && (typeof value === "object" || typeof value === "function");
}
function addRaceContender(contender) {
  const deferreds = /* @__PURE__ */ new Set;
  const record = { deferreds, settled: false };
  Promise.resolve(contender).then((value) => {
    for (const { resolve } of deferreds) {
      resolve(value);
    }
    deferreds.clear();
    record.settled = true;
  }, (err) => {
    for (const { reject } of deferreds) {
      reject(err);
    }
    deferreds.clear();
    record.settled = true;
  });
  return record;
}
async function safeRace(contenders) {
  let deferred;
  const result = new Promise((resolve, reject) => {
    deferred = { reject, resolve };
    for (const contender of contenders) {
      if (!isObject(contender)) {
        Promise.resolve(contender).then(resolve, reject);
        continue;
      }
      let record = wm.get(contender);
      if (record === undefined) {
        record = addRaceContender(contender);
        record.deferreds.add(deferred);
        wm.set(contender, record);
      } else if (record.settled) {
        Promise.resolve(contender).then(resolve, reject);
      } else {
        record.deferreds.add(deferred);
      }
    }
  });
  return await result.finally(() => {
    for (const contender of contenders) {
      if (isObject(contender)) {
        const record = wm.get(contender);
        record.deferreds.delete(deferred);
      }
    }
  });
}
function getAbortablePromise(promise, abortSignal) {
  if (!abortSignal) {
    return promise;
  } else {
    return safeRace([
      new Promise((_, reject) => {
        if (abortSignal.aborted) {
          reject(abortSignal.reason);
        } else {
          abortSignal.addEventListener("abort", function() {
            reject(this.reason);
          });
        }
      }),
      promise
    ]);
  }
}
var wm;
var init_index_node22 = __esm(() => {
  wm = /* @__PURE__ */ new WeakMap;
});

// ../../node_modules/.bun/@solana+instruction-plans@5.1.0+7f9e3d21594a24ff/node_modules/@solana/instruction-plans/dist/index.node.mjs
function parallelInstructionPlan(plans) {
  return Object.freeze({
    kind: "parallel",
    plans: parseSingleInstructionPlans(plans)
  });
}
function sequentialInstructionPlan(plans) {
  return Object.freeze({
    divisible: true,
    kind: "sequential",
    plans: parseSingleInstructionPlans(plans)
  });
}
function nonDivisibleSequentialInstructionPlan(plans) {
  return Object.freeze({
    divisible: false,
    kind: "sequential",
    plans: parseSingleInstructionPlans(plans)
  });
}
function singleInstructionPlan(instruction) {
  return Object.freeze({ instruction, kind: "single" });
}
function parseSingleInstructionPlans(plans) {
  return plans.map((plan) => ("kind" in plan) ? plan : singleInstructionPlan(plan));
}
function getLinearMessagePackerInstructionPlan({
  getInstruction,
  totalLength: totalBytes
}) {
  return Object.freeze({
    getMessagePacker: () => {
      let offset = 0;
      return Object.freeze({
        done: () => offset >= totalBytes,
        packMessageToCapacity: (message) => {
          if (offset >= totalBytes) {
            throw new SolanaError2(SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_PACKER_ALREADY_COMPLETE2);
          }
          const messageSizeWithBaseInstruction = getTransactionMessageSize(appendTransactionMessageInstruction(getInstruction(offset, 0), message));
          const freeSpace = TRANSACTION_SIZE_LIMIT - messageSizeWithBaseInstruction - 1;
          if (freeSpace <= 0) {
            const messageSize = getTransactionMessageSize(message);
            throw new SolanaError2(SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN2, {
              numBytesRequired: messageSizeWithBaseInstruction - messageSize + 1,
              numFreeBytes: TRANSACTION_SIZE_LIMIT - messageSize - 1
            });
          }
          const length = Math.min(totalBytes - offset, freeSpace);
          const instruction = getInstruction(offset, length);
          offset += length;
          return appendTransactionMessageInstruction(instruction, message);
        }
      });
    },
    kind: "messagePacker"
  });
}
function getMessagePackerInstructionPlanFromInstructions(instructions) {
  return Object.freeze({
    getMessagePacker: () => {
      let instructionIndex = 0;
      return Object.freeze({
        done: () => instructionIndex >= instructions.length,
        packMessageToCapacity: (message) => {
          if (instructionIndex >= instructions.length) {
            throw new SolanaError2(SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_PACKER_ALREADY_COMPLETE2);
          }
          const originalMessageSize = getTransactionMessageSize(message);
          for (let index = instructionIndex;index < instructions.length; index++) {
            message = appendTransactionMessageInstruction(instructions[index], message);
            const messageSize = getTransactionMessageSize(message);
            if (messageSize > TRANSACTION_SIZE_LIMIT) {
              if (index === instructionIndex) {
                throw new SolanaError2(SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN2, {
                  numBytesRequired: messageSize - originalMessageSize,
                  numFreeBytes: TRANSACTION_SIZE_LIMIT - originalMessageSize
                });
              }
              instructionIndex = index;
              return message;
            }
          }
          instructionIndex = instructions.length;
          return message;
        }
      });
    },
    kind: "messagePacker"
  });
}
function getReallocMessagePackerInstructionPlan({
  getInstruction,
  totalSize
}) {
  const numberOfInstructions = Math.ceil(totalSize / REALLOC_LIMIT);
  const lastInstructionSize = totalSize % REALLOC_LIMIT;
  const instructions = new Array(numberOfInstructions).fill(0).map((_, i) => getInstruction(i === numberOfInstructions - 1 ? lastInstructionSize : REALLOC_LIMIT));
  return getMessagePackerInstructionPlanFromInstructions(instructions);
}
function sequentialTransactionPlanResult(plans) {
  return Object.freeze({ divisible: true, kind: "sequential", plans });
}
function nonDivisibleSequentialTransactionPlanResult(plans) {
  return Object.freeze({ divisible: false, kind: "sequential", plans });
}
function parallelTransactionPlanResult(plans) {
  return Object.freeze({ kind: "parallel", plans });
}
function successfulSingleTransactionPlanResult(transactionMessage, transaction, context) {
  return Object.freeze({
    kind: "single",
    message: transactionMessage,
    status: Object.freeze({
      context: context ?? {},
      kind: "successful",
      signature: getSignatureFromTransaction(transaction),
      transaction
    })
  });
}
function successfulSingleTransactionPlanResultFromSignature(transactionMessage, signature2, context) {
  return Object.freeze({
    kind: "single",
    message: transactionMessage,
    status: Object.freeze({ context: context ?? {}, kind: "successful", signature: signature2 })
  });
}
function failedSingleTransactionPlanResult(transactionMessage, error) {
  return Object.freeze({
    kind: "single",
    message: transactionMessage,
    status: Object.freeze({ error, kind: "failed" })
  });
}
function canceledSingleTransactionPlanResult(transactionMessage) {
  return Object.freeze({
    kind: "single",
    message: transactionMessage,
    status: Object.freeze({ kind: "canceled" })
  });
}
function flattenTransactionPlanResult(result) {
  const transactionPlanResults = [];
  function traverse3(result2) {
    if (result2.kind === "single") {
      transactionPlanResults.push(result2);
    } else {
      for (const subResult of result2.plans) {
        traverse3(subResult);
      }
    }
  }
  traverse3(result);
  return transactionPlanResults;
}
function summarizeTransactionPlanResult(result) {
  const successfulTransactions = [];
  const failedTransactions = [];
  const canceledTransactions = [];
  const flattenedResults = flattenTransactionPlanResult(result);
  for (const singleResult of flattenedResults) {
    switch (singleResult.status.kind) {
      case "successful": {
        successfulTransactions.push(singleResult);
        break;
      }
      case "failed": {
        failedTransactions.push(singleResult);
        break;
      }
      case "canceled": {
        canceledTransactions.push(singleResult);
        break;
      }
    }
  }
  return Object.freeze({
    canceledTransactions,
    failedTransactions,
    successful: failedTransactions.length === 0 && canceledTransactions.length === 0,
    successfulTransactions
  });
}
function createTransactionPlanExecutor(config) {
  return async (plan, { abortSignal } = {}) => {
    const context = {
      ...config,
      abortSignal,
      canceled: abortSignal?.aborted ?? false
    };
    const cancelHandler = () => {
      context.canceled = true;
    };
    abortSignal?.addEventListener("abort", cancelHandler);
    const transactionPlanResult = await traverse(plan, context);
    abortSignal?.removeEventListener("abort", cancelHandler);
    if (context.canceled) {
      const abortReason = abortSignal?.aborted ? abortSignal.reason : undefined;
      const context2 = { cause: findErrorFromTransactionPlanResult(transactionPlanResult) ?? abortReason };
      Object.defineProperty(context2, "transactionPlanResult", {
        configurable: false,
        enumerable: false,
        value: transactionPlanResult,
        writable: false
      });
      throw new SolanaError2(SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_TO_EXECUTE_TRANSACTION_PLAN2, context2);
    }
    return transactionPlanResult;
  };
}
async function traverse(transactionPlan, context) {
  const kind = transactionPlan.kind;
  switch (kind) {
    case "sequential":
      return await traverseSequential(transactionPlan, context);
    case "parallel":
      return await traverseParallel(transactionPlan, context);
    case "single":
      return await traverseSingle(transactionPlan, context);
    default:
      throw new SolanaError2(SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_TRANSACTION_PLAN_KIND2, { kind });
  }
}
async function traverseSequential(transactionPlan, context) {
  const results = [];
  for (const subPlan of transactionPlan.plans) {
    const result = await traverse(subPlan, context);
    results.push(result);
  }
  return transactionPlan.divisible ? sequentialTransactionPlanResult(results) : nonDivisibleSequentialTransactionPlanResult(results);
}
async function traverseParallel(transactionPlan, context) {
  const results = await Promise.all(transactionPlan.plans.map((plan) => traverse(plan, context)));
  return parallelTransactionPlanResult(results);
}
async function traverseSingle(transactionPlan, context) {
  if (context.canceled) {
    return canceledSingleTransactionPlanResult(transactionPlan.message);
  }
  try {
    const result = await getAbortablePromise(context.executeTransactionMessage(transactionPlan.message, { abortSignal: context.abortSignal }), context.abortSignal);
    if ("transaction" in result) {
      return successfulSingleTransactionPlanResult(transactionPlan.message, result.transaction, result.context);
    } else {
      return successfulSingleTransactionPlanResultFromSignature(transactionPlan.message, result.signature, result.context);
    }
  } catch (error) {
    context.canceled = true;
    return failedSingleTransactionPlanResult(transactionPlan.message, error);
  }
}
function findErrorFromTransactionPlanResult(result) {
  if (result.kind === "single") {
    return result.status.kind === "failed" ? result.status.error : undefined;
  }
  for (const plan of result.plans) {
    const error = findErrorFromTransactionPlanResult(plan);
    if (error) {
      return error;
    }
  }
}
function parallelTransactionPlan(plans) {
  return Object.freeze({ kind: "parallel", plans: parseSingleTransactionPlans(plans) });
}
function sequentialTransactionPlan(plans) {
  return Object.freeze({ divisible: true, kind: "sequential", plans: parseSingleTransactionPlans(plans) });
}
function nonDivisibleSequentialTransactionPlan(plans) {
  return Object.freeze({ divisible: false, kind: "sequential", plans: parseSingleTransactionPlans(plans) });
}
function singleTransactionPlan(transactionMessage) {
  return Object.freeze({ kind: "single", message: transactionMessage });
}
function parseSingleTransactionPlans(plans) {
  return plans.map((plan) => ("kind" in plan) ? plan : singleTransactionPlan(plan));
}
function getAllSingleTransactionPlans(transactionPlan) {
  if (transactionPlan.kind === "single") {
    return [transactionPlan];
  }
  return transactionPlan.plans.flatMap(getAllSingleTransactionPlans);
}
function createTransactionPlanner(config) {
  return async (instructionPlan, { abortSignal } = {}) => {
    const plan = await traverse2(instructionPlan, {
      abortSignal,
      createTransactionMessage: config.createTransactionMessage,
      onTransactionMessageUpdated: config.onTransactionMessageUpdated ?? ((msg) => msg),
      parent: null,
      parentCandidates: []
    });
    if (!plan) {
      throw new SolanaError2(SOLANA_ERROR__INSTRUCTION_PLANS__EMPTY_INSTRUCTION_PLAN2);
    }
    return freezeTransactionPlan(plan);
  };
}
async function traverse2(instructionPlan, context) {
  context.abortSignal?.throwIfAborted();
  const kind = instructionPlan.kind;
  switch (kind) {
    case "sequential":
      return await traverseSequential2(instructionPlan, context);
    case "parallel":
      return await traverseParallel2(instructionPlan, context);
    case "single":
      return await traverseSingle2(instructionPlan, context);
    case "messagePacker":
      return await traverseMessagePacker(instructionPlan, context);
    default:
      throw new SolanaError2(SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_INSTRUCTION_PLAN_KIND2, { kind });
  }
}
async function traverseSequential2(instructionPlan, context) {
  let candidate = null;
  const mustEntirelyFitInParentCandidate = context.parent && (context.parent.kind === "parallel" || !instructionPlan.divisible);
  if (mustEntirelyFitInParentCandidate) {
    const candidate2 = await selectAndMutateCandidate(context, context.parentCandidates, (message) => fitEntirePlanInsideMessage(instructionPlan, message));
    if (candidate2) {
      return null;
    }
  } else {
    candidate = context.parentCandidates.length > 0 ? context.parentCandidates[0] : null;
  }
  const transactionPlans = [];
  for (const plan of instructionPlan.plans) {
    const transactionPlan = await traverse2(plan, {
      ...context,
      parent: instructionPlan,
      parentCandidates: candidate ? [candidate] : []
    });
    if (transactionPlan) {
      candidate = getSequentialCandidate(transactionPlan);
      const newPlans = transactionPlan.kind === "sequential" && (transactionPlan.divisible || !instructionPlan.divisible) ? transactionPlan.plans : [transactionPlan];
      transactionPlans.push(...newPlans);
    }
  }
  if (transactionPlans.length === 1) {
    return transactionPlans[0];
  }
  if (transactionPlans.length === 0) {
    return null;
  }
  return {
    divisible: instructionPlan.divisible,
    kind: "sequential",
    plans: transactionPlans
  };
}
async function traverseParallel2(instructionPlan, context) {
  const candidates = [...context.parentCandidates];
  const transactionPlans = [];
  const sortedChildren = Array.from(instructionPlan.plans).sort((a, b) => Number(a.kind === "messagePacker") - Number(b.kind === "messagePacker"));
  for (const plan of sortedChildren) {
    const transactionPlan = await traverse2(plan, {
      ...context,
      parent: instructionPlan,
      parentCandidates: candidates
    });
    if (transactionPlan) {
      candidates.push(...getParallelCandidates(transactionPlan));
      const newPlans = transactionPlan.kind === "parallel" ? transactionPlan.plans : [transactionPlan];
      transactionPlans.push(...newPlans);
    }
  }
  if (transactionPlans.length === 1) {
    return transactionPlans[0];
  }
  if (transactionPlans.length === 0) {
    return null;
  }
  return { kind: "parallel", plans: transactionPlans };
}
async function traverseSingle2(instructionPlan, context) {
  const predicate = (message2) => appendTransactionMessageInstructions([instructionPlan.instruction], message2);
  const candidate = await selectAndMutateCandidate(context, context.parentCandidates, predicate);
  if (candidate) {
    return null;
  }
  const message = await createNewMessage(context, predicate);
  return { kind: "single", message };
}
async function traverseMessagePacker(instructionPlan, context) {
  const messagePacker = instructionPlan.getMessagePacker();
  const transactionPlans = [];
  const candidates = [...context.parentCandidates];
  while (!messagePacker.done()) {
    const candidate = await selectAndMutateCandidate(context, candidates, messagePacker.packMessageToCapacity);
    if (!candidate) {
      const message = await createNewMessage(context, messagePacker.packMessageToCapacity);
      const newPlan = { kind: "single", message };
      transactionPlans.push(newPlan);
    }
  }
  if (transactionPlans.length === 1) {
    return transactionPlans[0];
  }
  if (transactionPlans.length === 0) {
    return null;
  }
  if (context.parent?.kind === "parallel") {
    return { kind: "parallel", plans: transactionPlans };
  }
  return {
    divisible: context.parent?.kind === "sequential" ? context.parent.divisible : true,
    kind: "sequential",
    plans: transactionPlans
  };
}
function getSequentialCandidate(latestPlan) {
  if (latestPlan.kind === "single") {
    return latestPlan;
  }
  if (latestPlan.kind === "sequential" && latestPlan.plans.length > 0) {
    return getSequentialCandidate(latestPlan.plans[latestPlan.plans.length - 1]);
  }
  return null;
}
function getParallelCandidates(latestPlan) {
  return getAllSingleTransactionPlans(latestPlan);
}
async function selectAndMutateCandidate(context, candidates, predicate) {
  for (const candidate of candidates) {
    try {
      const message = await getAbortablePromise(Promise.resolve(context.onTransactionMessageUpdated(predicate(candidate.message), {
        abortSignal: context.abortSignal
      })), context.abortSignal);
      if (getTransactionMessageSize(message) <= TRANSACTION_SIZE_LIMIT) {
        candidate.message = message;
        return candidate;
      }
    } catch (error) {
      if (isSolanaError2(error, SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN2))
        ;
      else {
        throw error;
      }
    }
  }
  return null;
}
async function createNewMessage(context, predicate) {
  const newMessage = await getAbortablePromise(Promise.resolve(context.createTransactionMessage({ abortSignal: context.abortSignal })), context.abortSignal);
  const updatedMessage = await getAbortablePromise(Promise.resolve(context.onTransactionMessageUpdated(predicate(newMessage), { abortSignal: context.abortSignal })), context.abortSignal);
  const updatedMessageSize = getTransactionMessageSize(updatedMessage);
  if (updatedMessageSize > TRANSACTION_SIZE_LIMIT) {
    const newMessageSize = getTransactionMessageSize(newMessage);
    throw new SolanaError2(SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN2, {
      numBytesRequired: updatedMessageSize - newMessageSize,
      numFreeBytes: TRANSACTION_SIZE_LIMIT - newMessageSize
    });
  }
  return updatedMessage;
}
function freezeTransactionPlan(plan) {
  const kind = plan.kind;
  switch (kind) {
    case "single":
      return singleTransactionPlan(plan.message);
    case "sequential":
      return plan.divisible ? sequentialTransactionPlan(plan.plans.map(freezeTransactionPlan)) : nonDivisibleSequentialTransactionPlan(plan.plans.map(freezeTransactionPlan));
    case "parallel":
      return parallelTransactionPlan(plan.plans.map(freezeTransactionPlan));
    default:
      throw new SolanaError2(SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_TRANSACTION_PLAN_KIND2, { kind });
  }
}
function fitEntirePlanInsideMessage(instructionPlan, message) {
  let newMessage = message;
  const kind = instructionPlan.kind;
  switch (kind) {
    case "sequential":
    case "parallel":
      for (const plan of instructionPlan.plans) {
        newMessage = fitEntirePlanInsideMessage(plan, newMessage);
      }
      return newMessage;
    case "single":
      newMessage = appendTransactionMessageInstructions([instructionPlan.instruction], message);
      const newMessageSize = getTransactionMessageSize(newMessage);
      if (newMessageSize > TRANSACTION_SIZE_LIMIT) {
        const baseMessageSize = getTransactionMessageSize(message);
        throw new SolanaError2(SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN2, {
          numBytesRequired: newMessageSize - baseMessageSize,
          numFreeBytes: TRANSACTION_SIZE_LIMIT - baseMessageSize
        });
      }
      return newMessage;
    case "messagePacker":
      const messagePacker = instructionPlan.getMessagePacker();
      while (!messagePacker.done()) {
        newMessage = messagePacker.packMessageToCapacity(message);
      }
      return newMessage;
    default:
      throw new SolanaError2(SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_INSTRUCTION_PLAN_KIND2, { kind });
  }
}
var REALLOC_LIMIT = 10240;
var init_index_node23 = __esm(() => {
  init_index_node6();
  init_index_node19();
  init_index_node21();
  init_index_node22();
});

// ../../node_modules/.bun/@solana+offchain-messages@5.1.0+7f9e3d21594a24ff/node_modules/@solana/offchain-messages/dist/index.node.mjs
function isOffchainMessageApplicationDomain(putativeApplicationDomain) {
  return isAddress2(putativeApplicationDomain);
}
function assertIsOffchainMessageApplicationDomain(putativeApplicationDomain) {
  try {
    assertIsAddress2(putativeApplicationDomain);
  } catch (error) {
    if (isSolanaError2(error, SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE2)) {
      throw new SolanaError2(SOLANA_ERROR__OFFCHAIN_MESSAGE__APPLICATION_DOMAIN_STRING_LENGTH_OUT_OF_RANGE2, error.context);
    }
    if (isSolanaError2(error, SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH2)) {
      throw new SolanaError2(SOLANA_ERROR__OFFCHAIN_MESSAGE__INVALID_APPLICATION_DOMAIN_BYTE_LENGTH2, error.context);
    }
    throw error;
  }
}
function offchainMessageApplicationDomain(putativeApplicationDomain) {
  assertIsOffchainMessageApplicationDomain(putativeApplicationDomain);
  return putativeApplicationDomain;
}
function getOffchainMessageApplicationDomainEncoder() {
  return transformEncoder2(getAddressEncoder2(), (putativeApplicationDomain) => offchainMessageApplicationDomain(putativeApplicationDomain));
}
function getOffchainMessageApplicationDomainDecoder() {
  return getAddressDecoder2();
}
function getOffchainMessageApplicationDomainCodec() {
  return combineCodec2(getOffchainMessageApplicationDomainEncoder(), getOffchainMessageApplicationDomainDecoder());
}
function getOffchainMessageSigningDomainDecoder() {
  return getConstantDecoder(OFFCHAIN_MESSAGE_SIGNING_DOMAIN_BYTES);
}
function getOffchainMessageSigningDomainEncoder() {
  return getConstantEncoder(OFFCHAIN_MESSAGE_SIGNING_DOMAIN_BYTES);
}
function getSigningDomainPrefixedDecoder(...fields) {
  return getHiddenPrefixDecoder(getStructDecoder(fields), [getOffchainMessageSigningDomainDecoder()]);
}
function getSigningDomainPrefixedEncoder(...fields) {
  return getHiddenPrefixEncoder(getStructEncoder(fields), [getOffchainMessageSigningDomainEncoder()]);
}
function getVersionTransformer(fixedVersion) {
  return (version) => {
    if (version > 1) {
      throw new SolanaError2(SOLANA_ERROR__OFFCHAIN_MESSAGE__VERSION_NUMBER_NOT_SUPPORTED2, {
        unsupportedVersion: version
      });
    }
    if (fixedVersion != null && version !== fixedVersion) {
      throw new SolanaError2(SOLANA_ERROR__OFFCHAIN_MESSAGE__UNEXPECTED_VERSION2, {
        actualVersion: version,
        expectedVersion: fixedVersion
      });
    }
    return version;
  };
}
function createOffchainMessagePreambleDecoder(version, ...fields) {
  return getSigningDomainPrefixedDecoder(["version", transformDecoder(getU8Decoder(), getVersionTransformer(version))], ...fields);
}
function createOffchainMessagePreambleEncoder(version, ...fields) {
  return getSigningDomainPrefixedEncoder(["version", transformEncoder2(getU8Encoder(), getVersionTransformer(version))], ...fields);
}
function decodeRequiredSignatoryAddresses(bytes) {
  const { version, bytesAfterVersion } = getSigningDomainPrefixedDecoder(["version", transformDecoder(getU8Decoder(), getVersionTransformer())], ["bytesAfterVersion", getBytesDecoder()]).decode(bytes);
  return offsetDecoder(transformDecoder(getArrayDecoder(getAddressDecoder2(), { size: getU8Decoder() }), (signatoryAddresses) => {
    if (signatoryAddresses.length === 0) {
      throw new SolanaError2(SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO2);
    }
    return signatoryAddresses;
  }), {
    preOffset: ({ preOffset }) => preOffset + (version === 0 ? 32 + 1 : 0)
  }).decode(bytesAfterVersion);
}
function getSignatoriesComparator() {
  return (x, y) => {
    if (x.length !== y.length) {
      return x.length < y.length ? -1 : 1;
    }
    for (let ii = 0;ii < x.length; ii++) {
      if (x[ii] === y[ii]) {
        continue;
      } else {
        return x[ii] < y[ii] ? -1 : 1;
      }
    }
    return 0;
  };
}
function getSignaturesToEncode2(signaturesMap) {
  const signatures = Object.values(signaturesMap);
  if (signatures.length === 0) {
    throw new SolanaError2(SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_ENVELOPE_SIGNATURES_CANNOT_BE_ZERO2);
  }
  return signatures.map((signature2) => {
    if (!signature2) {
      return new Uint8Array(64).fill(0);
    }
    return signature2;
  });
}
function getSignaturesEncoder2() {
  return transformEncoder2(getArrayEncoder(fixEncoderSize2(getBytesEncoder(), 64), { size: getU8Encoder() }), getSignaturesToEncode2);
}
function getOffchainMessageEnvelopeEncoder() {
  return transformEncoder2(getStructEncoder([
    ["signatures", getSignaturesEncoder2()],
    ["content", getBytesEncoder()]
  ]), (envelope) => {
    const signaturesMapAddresses = Object.keys(envelope.signatures).map(address2);
    if (signaturesMapAddresses.length === 0) {
      throw new SolanaError2(SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_ENVELOPE_SIGNATURES_CANNOT_BE_ZERO2);
    }
    const signatoryAddresses = decodeAndValidateRequiredSignatoryAddresses(envelope.content);
    const missingRequiredSigners = [];
    const unexpectedSigners = [];
    for (const address22 of signatoryAddresses) {
      if (!signaturesMapAddresses.includes(address22)) {
        missingRequiredSigners.push(address22);
      }
    }
    for (const address22 of signaturesMapAddresses) {
      if (!signatoryAddresses.includes(address22)) {
        unexpectedSigners.push(address22);
      }
    }
    if (missingRequiredSigners.length || unexpectedSigners.length) {
      throw new SolanaError2(SOLANA_ERROR__OFFCHAIN_MESSAGE__ENVELOPE_SIGNERS_MISMATCH2, {
        missingRequiredSigners,
        unexpectedSigners
      });
    }
    const orderedSignatureMap = {};
    for (const address22 of signatoryAddresses) {
      orderedSignatureMap[address22] = envelope.signatures[address22];
    }
    return {
      ...envelope,
      signatures: orderedSignatureMap
    };
  });
}
function getOffchainMessageEnvelopeDecoder() {
  return transformDecoder(getStructDecoder([
    ["signatures", getArrayDecoder(fixDecoderSize2(getBytesDecoder(), 64), { size: getU8Decoder() })],
    ["content", getBytesDecoder()]
  ]), decodePartiallyDecodedOffchainMessageEnvelope);
}
function getOffchainMessageEnvelopeCodec() {
  return combineCodec2(getOffchainMessageEnvelopeEncoder(), getOffchainMessageEnvelopeDecoder());
}
function decodePartiallyDecodedOffchainMessageEnvelope(offchainMessageEnvelope) {
  const { content, signatures } = offchainMessageEnvelope;
  if (signatures.length === 0) {
    throw new SolanaError2(SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_ENVELOPE_SIGNATURES_CANNOT_BE_ZERO2);
  }
  const signatoryAddresses = decodeAndValidateRequiredSignatoryAddresses(content);
  if (signatoryAddresses.length !== signatures.length) {
    throw new SolanaError2(SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_SIGNATURES_MISMATCH2, {
      numRequiredSignatures: signatoryAddresses.length,
      signatoryAddresses,
      signaturesLength: signatures.length
    });
  }
  const signaturesMap = {};
  signatoryAddresses.forEach((address22, index) => {
    const signatureForAddress = signatures[index];
    if (signatureForAddress.every((b) => b === 0)) {
      signaturesMap[address22] = null;
    } else {
      signaturesMap[address22] = signatureForAddress;
    }
  });
  return Object.freeze({
    content,
    signatures: Object.freeze(signaturesMap)
  });
}
function decodeAndValidateRequiredSignatoryAddresses(bytes) {
  const signatoryAddresses = decodeRequiredSignatoryAddresses(bytes);
  if (signatoryAddresses.length === 0) {
    throw new SolanaError2(SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO2);
  }
  return signatoryAddresses;
}
function assertIsOffchainMessageContentRestrictedAsciiOf1232BytesMax(putativeContent) {
  if (putativeContent.format !== 0) {
    throw new SolanaError2(SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_FORMAT_MISMATCH2, {
      actualMessageFormat: putativeContent.format,
      expectedMessageFormat: 0
    });
  }
  if (putativeContent.text.length === 0) {
    throw new SolanaError2(SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_MUST_BE_NON_EMPTY2);
  }
  if (isTextRestrictedAscii(putativeContent.text) === false) {
    throw new SolanaError2(SOLANA_ERROR__OFFCHAIN_MESSAGE__RESTRICTED_ASCII_BODY_CHARACTER_OUT_OF_RANGE2);
  }
  const length = getUtf8Encoder().getSizeFromValue(putativeContent.text);
  if (length > MAX_BODY_BYTES_HARDWARE_WALLET_SIGNABLE) {
    throw new SolanaError2(SOLANA_ERROR__OFFCHAIN_MESSAGE__MAXIMUM_LENGTH_EXCEEDED2, {
      actualBytes: length,
      maxBytes: MAX_BODY_BYTES_HARDWARE_WALLET_SIGNABLE
    });
  }
}
function isOffchainMessageContentRestrictedAsciiOf1232BytesMax(putativeContent) {
  if (putativeContent.format !== 0 || putativeContent.text.length === 0 || isTextRestrictedAscii(putativeContent.text) === false) {
    return false;
  }
  const length = getUtf8Encoder().getSizeFromValue(putativeContent.text);
  return length <= MAX_BODY_BYTES_HARDWARE_WALLET_SIGNABLE;
}
function offchainMessageContentRestrictedAsciiOf1232BytesMax(text) {
  const putativeContent = Object.freeze({
    format: 0,
    text
  });
  assertIsOffchainMessageContentRestrictedAsciiOf1232BytesMax(putativeContent);
  return putativeContent;
}
function assertIsOffchainMessageContentUtf8Of1232BytesMax(putativeContent) {
  if (putativeContent.text.length === 0) {
    throw new SolanaError2(SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_MUST_BE_NON_EMPTY2);
  }
  if (putativeContent.format !== 1) {
    throw new SolanaError2(SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_FORMAT_MISMATCH2, {
      actualMessageFormat: putativeContent.format,
      expectedMessageFormat: 1
    });
  }
  const length = getUtf8Encoder().getSizeFromValue(putativeContent.text);
  if (length > MAX_BODY_BYTES_HARDWARE_WALLET_SIGNABLE) {
    throw new SolanaError2(SOLANA_ERROR__OFFCHAIN_MESSAGE__MAXIMUM_LENGTH_EXCEEDED2, {
      actualBytes: length,
      maxBytes: MAX_BODY_BYTES_HARDWARE_WALLET_SIGNABLE
    });
  }
}
function isOffchainMessageContentUtf8Of1232BytesMax(putativeContent) {
  if (putativeContent.format !== 1 || putativeContent.text.length === 0) {
    return false;
  }
  const length = getUtf8Encoder().getSizeFromValue(putativeContent.text);
  return length <= MAX_BODY_BYTES_HARDWARE_WALLET_SIGNABLE;
}
function offchainMessageContentUtf8Of1232BytesMax(text) {
  const putativeContent = Object.freeze({
    format: 1,
    text
  });
  assertIsOffchainMessageContentUtf8Of1232BytesMax(putativeContent);
  return putativeContent;
}
function assertIsOffchainMessageContentUtf8Of65535BytesMax(putativeContent) {
  if (putativeContent.format !== 2) {
    throw new SolanaError2(SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_FORMAT_MISMATCH2, {
      actualMessageFormat: putativeContent.format,
      expectedMessageFormat: 2
    });
  }
  if (putativeContent.text.length === 0) {
    throw new SolanaError2(SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_MUST_BE_NON_EMPTY2);
  }
  const length = getUtf8Encoder().getSizeFromValue(putativeContent.text);
  if (length > MAX_BODY_BYTES) {
    throw new SolanaError2(SOLANA_ERROR__OFFCHAIN_MESSAGE__MAXIMUM_LENGTH_EXCEEDED2, {
      actualBytes: length,
      maxBytes: MAX_BODY_BYTES
    });
  }
}
function isOffchainMessageContentUtf8Of65535BytesMax(putativeContent) {
  if (putativeContent.format !== 2 || putativeContent.text.length === 0) {
    return false;
  }
  const length = getUtf8Encoder().getSizeFromValue(putativeContent.text);
  return length <= MAX_BODY_BYTES;
}
function offchainMessageContentUtf8Of65535BytesMax(text) {
  const putativeContent = Object.freeze({
    format: 2,
    text
  });
  assertIsOffchainMessageContentUtf8Of65535BytesMax(putativeContent);
  return putativeContent;
}
function isTextRestrictedAscii(putativeRestrictedAsciiString) {
  return /^[\x20-\x7e]+$/.test(putativeRestrictedAsciiString);
}
function assertIsOffchainMessageRestrictedAsciiOf1232BytesMax(putativeMessage) {
  assertIsOffchainMessageContentRestrictedAsciiOf1232BytesMax(putativeMessage.content);
}
function assertIsOffchainMessageUtf8Of1232BytesMax(putativeMessage) {
  assertIsOffchainMessageContentUtf8Of1232BytesMax(putativeMessage.content);
}
function assertIsOffchainMessageUtf8Of65535BytesMax(putativeMessage) {
  assertIsOffchainMessageContentUtf8Of65535BytesMax(putativeMessage.content);
}
function getOffchainMessageContentFormatDecoder() {
  return getEnumDecoder(OffchainMessageContentFormat, {
    useValuesAsDiscriminators: true
  });
}
function getOffchainMessageContentFormatEncoder() {
  return getEnumEncoder(OffchainMessageContentFormat, {
    useValuesAsDiscriminators: true
  });
}
function getOffchainMessageV0PreambleDecoder() {
  return createOffchainMessagePreambleDecoder(0, ["applicationDomain", getOffchainMessageApplicationDomainDecoder()], ["messageFormat", getOffchainMessageContentFormatDecoder()], [
    "requiredSignatories",
    transformDecoder(getArrayDecoder(getAddressDecoder2(), { size: getU8Decoder() }), (signatoryAddresses) => {
      if (signatoryAddresses.length === 0) {
        throw new SolanaError2(SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO2);
      }
      return signatoryAddresses.map((address22) => Object.freeze({ address: address22 }));
    })
  ], ["messageLength", getU16Decoder()]);
}
function getOffchainMessageV0PreambleEncoder() {
  return createOffchainMessagePreambleEncoder(0, ["applicationDomain", getOffchainMessageApplicationDomainEncoder()], ["messageFormat", getOffchainMessageContentFormatEncoder()], [
    "requiredSignatories",
    transformEncoder2(getArrayEncoder(getAddressEncoder2(), { size: getU8Encoder() }), (signatoryAddresses) => {
      if (signatoryAddresses.length === 0) {
        throw new SolanaError2(SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO2);
      }
      return signatoryAddresses.map(({ address: address22 }) => address22);
    })
  ], ["messageLength", getU16Encoder()]);
}
function getOffchainMessageV0Decoder() {
  return transformDecoder(getTupleDecoder([getOffchainMessageV0PreambleDecoder(), getUtf8Decoder()]), ([{ messageLength, messageFormat, requiredSignatories, ...preambleRest }, text]) => {
    const actualLength = getUtf8Encoder().getSizeFromValue(text);
    if (messageLength !== actualLength) {
      throw new SolanaError2(SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_LENGTH_MISMATCH2, {
        actualLength,
        specifiedLength: messageLength
      });
    }
    const offchainMessage = Object.freeze({
      ...preambleRest,
      content: Object.freeze({
        format: messageFormat,
        text
      }),
      requiredSignatories: Object.freeze(requiredSignatories)
    });
    switch (messageFormat) {
      case 0: {
        assertIsOffchainMessageRestrictedAsciiOf1232BytesMax(offchainMessage);
        return offchainMessage;
      }
      case 1: {
        assertIsOffchainMessageUtf8Of1232BytesMax(offchainMessage);
        return offchainMessage;
      }
      case 2: {
        assertIsOffchainMessageUtf8Of65535BytesMax(offchainMessage);
        return offchainMessage;
      }
      default: {
        throw new SolanaError2(SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE2, {
          unexpectedValue: messageFormat
        });
      }
    }
  });
}
function getOffchainMessageV0Encoder() {
  return transformEncoder2(getTupleEncoder([getOffchainMessageV0PreambleEncoder(), getUtf8Encoder()]), (offchainMessage) => {
    const { content, ...preamble } = offchainMessage;
    switch (offchainMessage.content.format) {
      case 0: {
        assertIsOffchainMessageRestrictedAsciiOf1232BytesMax(offchainMessage);
        break;
      }
      case 1: {
        assertIsOffchainMessageUtf8Of1232BytesMax(offchainMessage);
        break;
      }
      case 2: {
        assertIsOffchainMessageUtf8Of65535BytesMax(offchainMessage);
        break;
      }
      default: {
        throw new SolanaError2(SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE2, {
          unexpectedValue: offchainMessage.content
        });
      }
    }
    const messageLength = getUtf8Encoder().getSizeFromValue(content.text);
    const compiledPreamble = {
      ...preamble,
      messageFormat: content.format,
      messageLength
    };
    return [compiledPreamble, content.text];
  });
}
function getOffchainMessageV0Codec() {
  return combineCodec2(getOffchainMessageV0Encoder(), getOffchainMessageV0Decoder());
}
function getOffchainMessageV1PreambleDecoder() {
  return createOffchainMessagePreambleDecoder(1, [
    "requiredSignatories",
    transformDecoder(getArrayDecoder(fixDecoderSize2(getBytesDecoder(), 32), { size: getU8Decoder() }), (signatoryAddressesBytes) => {
      if (signatoryAddressesBytes.length === 0) {
        throw new SolanaError2(SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO2);
      }
      const comparator = getSignatoriesComparator();
      for (let ii = 0;ii < signatoryAddressesBytes.length - 1; ii++) {
        switch (comparator(signatoryAddressesBytes[ii], signatoryAddressesBytes[ii + 1])) {
          case 0:
            throw new SolanaError2(SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATORIES_MUST_BE_UNIQUE2);
          case 1:
            throw new SolanaError2(SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATORIES_MUST_BE_SORTED2);
        }
      }
      const addressDecoder = getAddressDecoder2();
      return signatoryAddressesBytes.map((addressBytes) => Object.freeze({
        address: addressDecoder.decode(addressBytes)
      }));
    })
  ]);
}
function getOffchainMessageV1PreambleEncoder() {
  return createOffchainMessagePreambleEncoder(1, [
    "requiredSignatories",
    transformEncoder2(transformEncoder2(getArrayEncoder(getBytesEncoder(), { size: getU8Encoder() }), (signatoryAddressesBytes) => {
      return signatoryAddressesBytes.toSorted(getSignatoriesComparator());
    }), (signatoryAddresses) => {
      if (signatoryAddresses.length === 0) {
        throw new SolanaError2(SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO2);
      }
      const seenSignatories = /* @__PURE__ */ new Set;
      for (const { address: address22 } of signatoryAddresses) {
        if (seenSignatories.has(address22)) {
          throw new SolanaError2(SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATORIES_MUST_BE_UNIQUE2);
        }
        seenSignatories.add(address22);
      }
      const addressEncoder = getAddressEncoder2();
      return signatoryAddresses.map(({ address: address22 }) => addressEncoder.encode(address22));
    })
  ]);
}
function getOffchainMessageV1Decoder() {
  return transformDecoder(getTupleDecoder([getOffchainMessageV1PreambleDecoder(), getUtf8Decoder()]), ([{ requiredSignatories, ...preambleRest }, text]) => {
    if (text.length === 0) {
      throw new SolanaError2(SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_MUST_BE_NON_EMPTY2);
    }
    return Object.freeze({
      ...preambleRest,
      content: text,
      requiredSignatories: Object.freeze(requiredSignatories)
    });
  });
}
function getOffchainMessageV1Encoder() {
  return transformEncoder2(getTupleEncoder([getOffchainMessageV1PreambleEncoder(), getUtf8Encoder()]), (offchainMessage) => {
    const { content, ...compiledPreamble } = offchainMessage;
    if (content.length === 0) {
      throw new SolanaError2(SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_MUST_BE_NON_EMPTY2);
    }
    return [compiledPreamble, content];
  });
}
function getOffchainMessageV1Codec() {
  return combineCodec2(getOffchainMessageV1Encoder(), getOffchainMessageV1Decoder());
}
function getOffchainMessageDecoder() {
  return createDecoder2({
    read(bytes, offset) {
      const version = getHiddenPrefixDecoder(getU8Decoder(), [
        getOffchainMessageSigningDomainDecoder()
      ]).decode(bytes, offset);
      switch (version) {
        case 0:
          return getOffchainMessageV0Decoder().read(bytes, offset);
        case 1:
          return getOffchainMessageV1Decoder().read(bytes, offset);
        default:
          throw new SolanaError2(SOLANA_ERROR__OFFCHAIN_MESSAGE__VERSION_NUMBER_NOT_SUPPORTED2, {
            unsupportedVersion: version
          });
      }
    }
  });
}
function getOffchainMessageEncoder() {
  return createEncoder2({
    getSizeFromValue: (offchainMessage) => {
      const { version } = offchainMessage;
      switch (version) {
        case 0:
          return getOffchainMessageV0Encoder().getSizeFromValue(offchainMessage);
        case 1:
          return getOffchainMessageV1Encoder().getSizeFromValue(offchainMessage);
        default:
          throw new SolanaError2(SOLANA_ERROR__OFFCHAIN_MESSAGE__VERSION_NUMBER_NOT_SUPPORTED2, {
            unsupportedVersion: version
          });
      }
    },
    write: (offchainMessage, bytes, offset) => {
      const { version } = offchainMessage;
      switch (version) {
        case 0:
          return getOffchainMessageV0Encoder().write(offchainMessage, bytes, offset);
        case 1:
          return getOffchainMessageV1Encoder().write(offchainMessage, bytes, offset);
        default:
          throw new SolanaError2(SOLANA_ERROR__OFFCHAIN_MESSAGE__VERSION_NUMBER_NOT_SUPPORTED2, {
            unsupportedVersion: version
          });
      }
    }
  });
}
function getOffchainMessageCodec() {
  return combineCodec2(getOffchainMessageEncoder(), getOffchainMessageDecoder());
}
function compileOffchainMessageEnvelopeUsingEncoder(offchainMessage, encoder) {
  const offchainMessageBytes = encoder.encode(offchainMessage);
  const signatures = {};
  for (const { address: address22 } of offchainMessage.requiredSignatories) {
    signatures[address22] = null;
  }
  return Object.freeze({
    content: offchainMessageBytes,
    signatures: Object.freeze(signatures)
  });
}
function compileOffchainMessageV0Envelope(offchainMessage) {
  return compileOffchainMessageEnvelopeUsingEncoder(offchainMessage, getOffchainMessageV0Encoder());
}
function compileOffchainMessageV1Envelope(offchainMessage) {
  return compileOffchainMessageEnvelopeUsingEncoder(offchainMessage, getOffchainMessageV1Encoder());
}
function compileOffchainMessageEnvelope(offchainMessage) {
  const { version } = offchainMessage;
  switch (version) {
    case 0:
      return compileOffchainMessageV0Envelope(offchainMessage);
    case 1:
      return compileOffchainMessageV1Envelope(offchainMessage);
    default:
      throw new SolanaError2(SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE2, {
        unexpectedValue: version
      });
  }
}
async function partiallySignOffchainMessageEnvelope(keyPairs, offchainMessageEnvelope) {
  let newSignatures;
  let unexpectedSigners;
  const requiredSignatoryAddresses = decodeRequiredSignatoryAddresses(offchainMessageEnvelope.content);
  await Promise.all(keyPairs.map(async (keyPair) => {
    const address22 = await getAddressFromPublicKey2(keyPair.publicKey);
    if (!requiredSignatoryAddresses.includes(address22)) {
      unexpectedSigners ||= /* @__PURE__ */ new Set;
      unexpectedSigners.add(address22);
      return;
    }
    if (unexpectedSigners) {
      return;
    }
    const existingSignature = offchainMessageEnvelope.signatures[address22];
    const newSignature = await signBytes(keyPair.privateKey, offchainMessageEnvelope.content);
    if (existingSignature != null && bytesEqual2(newSignature, existingSignature)) {
      return;
    }
    newSignatures ||= {};
    newSignatures[address22] = newSignature;
  }));
  if (unexpectedSigners && unexpectedSigners.size > 0) {
    throw new SolanaError2(SOLANA_ERROR__OFFCHAIN_MESSAGE__ADDRESSES_CANNOT_SIGN_OFFCHAIN_MESSAGE2, {
      expectedAddresses: requiredSignatoryAddresses,
      unexpectedAddresses: [...unexpectedSigners]
    });
  }
  if (!newSignatures) {
    return offchainMessageEnvelope;
  }
  return Object.freeze({
    ...offchainMessageEnvelope,
    signatures: Object.freeze({
      ...offchainMessageEnvelope.signatures,
      ...newSignatures
    })
  });
}
async function signOffchainMessageEnvelope(keyPairs, offchainMessageEnvelope) {
  const out = await partiallySignOffchainMessageEnvelope(keyPairs, offchainMessageEnvelope);
  assertIsFullySignedOffchainMessageEnvelope(out);
  Object.freeze(out);
  return out;
}
function isFullySignedOffchainMessageEnvelope(offchainMessage) {
  return Object.entries(offchainMessage.signatures).every(([_, signatureBytes2]) => !!signatureBytes2);
}
function assertIsFullySignedOffchainMessageEnvelope(offchainMessage) {
  const missingSigs = [];
  Object.entries(offchainMessage.signatures).forEach(([address22, signatureBytes2]) => {
    if (!signatureBytes2) {
      missingSigs.push(address22);
    }
  });
  if (missingSigs.length > 0) {
    throw new SolanaError2(SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURES_MISSING2, {
      addresses: missingSigs
    });
  }
}
async function verifyOffchainMessageEnvelope(offchainMessageEnvelope) {
  let errorContext;
  const requiredSignatories = decodeRequiredSignatoryAddresses(offchainMessageEnvelope.content);
  await Promise.all(requiredSignatories.map(async (address22) => {
    const signature2 = offchainMessageEnvelope.signatures[address22];
    if (signature2 == null) {
      errorContext ||= {};
      errorContext.signatoriesWithMissingSignatures ||= [];
      errorContext.signatoriesWithMissingSignatures.push(address22);
    } else {
      const publicKey = await getPublicKeyFromAddress2(address22);
      if (await verifySignature(publicKey, signature2, offchainMessageEnvelope.content)) {
        return true;
      } else {
        errorContext ||= {};
        errorContext.signatoriesWithInvalidSignatures ||= [];
        errorContext.signatoriesWithInvalidSignatures.push(address22);
      }
    }
  }));
  if (errorContext) {
    throw new SolanaError2(SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURE_VERIFICATION_FAILURE2, errorContext);
  }
}
var OFFCHAIN_MESSAGE_SIGNING_DOMAIN_BYTES, MAX_BODY_BYTES = 65535, MAX_BODY_BYTES_HARDWARE_WALLET_SIGNABLE = 1232, OffchainMessageContentFormat;
var init_index_node24 = __esm(() => {
  init_index_node11();
  init_index_node6();
  init_index_node7();
  init_index_node13();
  init_index_node12();
  init_index_node8();
  init_index_node20();
  OFFCHAIN_MESSAGE_SIGNING_DOMAIN_BYTES = new Uint8Array([
    255,
    115,
    111,
    108,
    97,
    110,
    97,
    32,
    111,
    102,
    102,
    99,
    104,
    97,
    105,
    110
  ]);
  OffchainMessageContentFormat = /* @__PURE__ */ ((OffchainMessageContentFormat3) => {
    OffchainMessageContentFormat3[OffchainMessageContentFormat3["RESTRICTED_ASCII_1232_BYTES_MAX"] = 0] = "RESTRICTED_ASCII_1232_BYTES_MAX";
    OffchainMessageContentFormat3[OffchainMessageContentFormat3["UTF8_1232_BYTES_MAX"] = 1] = "UTF8_1232_BYTES_MAX";
    OffchainMessageContentFormat3[OffchainMessageContentFormat3["UTF8_65535_BYTES_MAX"] = 2] = "UTF8_65535_BYTES_MAX";
    return OffchainMessageContentFormat3;
  })(OffchainMessageContentFormat || {});
});

// ../../node_modules/.bun/@solana+programs@5.1.0+7f9e3d21594a24ff/node_modules/@solana/programs/dist/index.node.mjs
function isProgramError(error, transactionMessage, programAddress, code) {
  if (!isSolanaError2(error, SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM2)) {
    return false;
  }
  const instructionProgramAddress = transactionMessage.instructions[error.context.index]?.programAddress;
  if (!instructionProgramAddress || instructionProgramAddress !== programAddress) {
    return false;
  }
  return typeof code === "undefined" || error.context.code === code;
}
var init_index_node25 = __esm(() => {
  init_index_node6();
});

// ../../node_modules/.bun/@solana+rpc-spec-types@5.1.0+1fb4c65d43e298b9/node_modules/@solana/rpc-spec-types/dist/index.node.mjs
function parseJsonWithBigInts(json) {
  return JSON.parse(wrapIntegersInBigIntValueObject(json), (_, value) => {
    return isBigIntValueObject(value) ? unwrapBigIntValueObject(value) : value;
  });
}
function wrapIntegersInBigIntValueObject(json) {
  const out = [];
  let inQuote = false;
  for (let ii = 0;ii < json.length; ii++) {
    let isEscaped = false;
    if (json[ii] === "\\") {
      out.push(json[ii++]);
      isEscaped = !isEscaped;
    }
    if (json[ii] === '"') {
      out.push(json[ii]);
      if (!isEscaped) {
        inQuote = !inQuote;
      }
      continue;
    }
    if (!inQuote) {
      const consumedNumber = consumeNumber(json, ii);
      if (consumedNumber?.length) {
        ii += consumedNumber.length - 1;
        if (consumedNumber.match(/\.|[eE]-/)) {
          out.push(consumedNumber);
        } else {
          out.push(wrapBigIntValueObject(consumedNumber));
        }
        continue;
      }
    }
    out.push(json[ii]);
  }
  return out.join("");
}
function consumeNumber(json, ii) {
  const JSON_NUMBER_REGEX = /^-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?/;
  if (!json[ii]?.match(/[-\d]/)) {
    return null;
  }
  const numberMatch = json.slice(ii).match(JSON_NUMBER_REGEX);
  return numberMatch ? numberMatch[0] : null;
}
function wrapBigIntValueObject(value) {
  return `{"$n":"${value}"}`;
}
function unwrapBigIntValueObject({ $n }) {
  if ($n.match(/[eE]/)) {
    const [units, exponent] = $n.split(/[eE]/);
    return BigInt(units) * BigInt(10) ** BigInt(exponent);
  }
  return BigInt($n);
}
function isBigIntValueObject(value) {
  return !!value && typeof value === "object" && "$n" in value && typeof value.$n === "string";
}
function getNextMessageId() {
  const id = _nextMessageId;
  _nextMessageId++;
  return id.toString();
}
function createRpcMessage(request) {
  return {
    id: getNextMessageId(),
    jsonrpc: "2.0",
    method: request.methodName,
    params: request.params
  };
}
function stringifyJsonWithBigInts(value, space) {
  return unwrapBigIntValueObject2(JSON.stringify(value, (_, v) => typeof v === "bigint" ? wrapBigIntValueObject2(v) : v, space));
}
function wrapBigIntValueObject2(value) {
  return { $n: `${value}` };
}
function unwrapBigIntValueObject2(value) {
  return value.replace(/\{\s*"\$n"\s*:\s*"(-?\d+)"\s*\}/g, "$1");
}
var _nextMessageId = 0n;
var init_index_node26 = () => {};

// ../../node_modules/.bun/@solana+rpc-spec@5.1.0+1fb4c65d43e298b9/node_modules/@solana/rpc-spec/dist/index.node.mjs
function createRpc(rpcConfig) {
  return makeProxy(rpcConfig);
}
function makeProxy(rpcConfig) {
  return new Proxy(rpcConfig.api, {
    defineProperty() {
      return false;
    },
    deleteProperty() {
      return false;
    },
    get(target, p, receiver) {
      if (p === "then") {
        return;
      }
      return function(...rawParams) {
        const methodName = p.toString();
        const getApiPlan = Reflect.get(target, methodName, receiver);
        if (!getApiPlan) {
          throw new SolanaError2(SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD2, {
            method: methodName,
            params: rawParams
          });
        }
        const apiPlan = getApiPlan(...rawParams);
        return createPendingRpcRequest(rpcConfig, apiPlan);
      };
    }
  });
}
function createPendingRpcRequest({ transport }, plan) {
  return {
    async send(options2) {
      return await plan.execute({ signal: options2?.abortSignal, transport });
    }
  };
}
function createJsonRpcApi(config) {
  return new Proxy({}, {
    defineProperty() {
      return false;
    },
    deleteProperty() {
      return false;
    },
    get(...args) {
      const [_, p] = args;
      const methodName = p.toString();
      return function(...rawParams) {
        const rawRequest = Object.freeze({ methodName, params: rawParams });
        const request = config?.requestTransformer ? config?.requestTransformer(rawRequest) : rawRequest;
        return Object.freeze({
          execute: async ({ signal, transport }) => {
            const payload = createRpcMessage(request);
            const response = await transport({ payload, signal });
            if (!config?.responseTransformer) {
              return response;
            }
            return config.responseTransformer(response, request);
          }
        });
      };
    }
  });
}
function isJsonRpcPayload(payload) {
  if (payload == null || typeof payload !== "object" || Array.isArray(payload)) {
    return false;
  }
  return "jsonrpc" in payload && payload.jsonrpc === "2.0" && "method" in payload && typeof payload.method === "string" && "params" in payload;
}
var init_index_node27 = __esm(() => {
  init_index_node6();
  init_index_node26();
});

// ../../node_modules/.bun/@solana+rpc-transformers@5.1.0+7f9e3d21594a24ff/node_modules/@solana/rpc-transformers/dist/index.node.mjs
function downcastNodeToNumberIfBigint(value) {
  return typeof value === "bigint" ? Number(value) : value;
}
function getTreeWalker(visitors) {
  return function traverse(node, state) {
    if (Array.isArray(node)) {
      return node.map((element, ii) => {
        const nextState = {
          ...state,
          keyPath: [...state.keyPath, ii]
        };
        return traverse(element, nextState);
      });
    } else if (typeof node === "object" && node !== null) {
      const out = {};
      for (const propName in node) {
        if (!Object.prototype.hasOwnProperty.call(node, propName)) {
          continue;
        }
        const nextState = {
          ...state,
          keyPath: [...state.keyPath, propName]
        };
        out[propName] = traverse(node[propName], nextState);
      }
      return out;
    } else {
      return visitors.reduce((acc, visitNode) => visitNode(acc, state), node);
    }
  };
}
function getTreeWalkerRequestTransformer(visitors, initialState) {
  return (request) => {
    const traverse3 = getTreeWalker(visitors);
    return Object.freeze({
      ...request,
      params: traverse3(request.params, initialState)
    });
  };
}
function getTreeWalkerResponseTransformer(visitors, initialState) {
  return (json) => getTreeWalker(visitors)(json, initialState);
}
function getBigIntDowncastRequestTransformer() {
  return getTreeWalkerRequestTransformer([downcastNodeToNumberIfBigint], { keyPath: [] });
}
function applyDefaultCommitment({
  commitmentPropertyName,
  params,
  optionsObjectPositionInParams,
  overrideCommitment
}) {
  const paramInTargetPosition = params[optionsObjectPositionInParams];
  if (paramInTargetPosition === undefined || paramInTargetPosition && typeof paramInTargetPosition === "object" && !Array.isArray(paramInTargetPosition)) {
    if (paramInTargetPosition && commitmentPropertyName in paramInTargetPosition) {
      if (!paramInTargetPosition[commitmentPropertyName] || paramInTargetPosition[commitmentPropertyName] === "finalized") {
        const nextParams = [...params];
        const {
          [commitmentPropertyName]: _,
          ...rest
        } = paramInTargetPosition;
        if (Object.keys(rest).length > 0) {
          nextParams[optionsObjectPositionInParams] = rest;
        } else {
          if (optionsObjectPositionInParams === nextParams.length - 1) {
            nextParams.length--;
          } else {
            nextParams[optionsObjectPositionInParams] = undefined;
          }
        }
        return nextParams;
      }
    } else if (overrideCommitment !== "finalized") {
      const nextParams = [...params];
      nextParams[optionsObjectPositionInParams] = {
        ...paramInTargetPosition,
        [commitmentPropertyName]: overrideCommitment
      };
      return nextParams;
    }
  }
  return params;
}
function getDefaultCommitmentRequestTransformer({
  defaultCommitment,
  optionsObjectPositionByMethod
}) {
  return (request) => {
    const { params, methodName } = request;
    if (!Array.isArray(params)) {
      return request;
    }
    const optionsObjectPositionInParams = optionsObjectPositionByMethod[methodName];
    if (optionsObjectPositionInParams == null) {
      return request;
    }
    return Object.freeze({
      methodName,
      params: applyDefaultCommitment({
        commitmentPropertyName: methodName === "sendTransaction" ? "preflightCommitment" : "commitment",
        optionsObjectPositionInParams,
        overrideCommitment: defaultCommitment,
        params
      })
    });
  };
}
function getIntegerOverflowNodeVisitor(onIntegerOverflow) {
  return (value, { keyPath }) => {
    if (typeof value === "bigint") {
      if (onIntegerOverflow && (value > Number.MAX_SAFE_INTEGER || value < -Number.MAX_SAFE_INTEGER)) {
        onIntegerOverflow(keyPath, value);
      }
    }
    return value;
  };
}
function getIntegerOverflowRequestTransformer(onIntegerOverflow) {
  return (request) => {
    const transformer = getTreeWalkerRequestTransformer([getIntegerOverflowNodeVisitor((...args) => onIntegerOverflow(request, ...args))], { keyPath: [] });
    return transformer(request);
  };
}
function getDefaultRequestTransformerForSolanaRpc(config) {
  const handleIntegerOverflow = config?.onIntegerOverflow;
  return (request) => {
    return pipe(request, handleIntegerOverflow ? getIntegerOverflowRequestTransformer(handleIntegerOverflow) : (r) => r, getBigIntDowncastRequestTransformer(), getDefaultCommitmentRequestTransformer({
      defaultCommitment: config?.defaultCommitment,
      optionsObjectPositionByMethod: OPTIONS_OBJECT_POSITION_BY_METHOD
    }));
  };
}
function getBigIntUpcastVisitor(allowedNumericKeyPaths) {
  return function upcastNodeToBigIntIfNumber(value, { keyPath }) {
    const isInteger = typeof value === "number" && Number.isInteger(value) || typeof value === "bigint";
    if (!isInteger)
      return value;
    if (keyPathIsAllowedToBeNumeric(keyPath, allowedNumericKeyPaths)) {
      return Number(value);
    } else {
      return BigInt(value);
    }
  };
}
function keyPathIsAllowedToBeNumeric(keyPath, allowedNumericKeyPaths) {
  return allowedNumericKeyPaths.some((prohibitedKeyPath) => {
    if (prohibitedKeyPath.length !== keyPath.length) {
      return false;
    }
    for (let ii = keyPath.length - 1;ii >= 0; ii--) {
      const keyPathPart = keyPath[ii];
      const prohibitedKeyPathPart = prohibitedKeyPath[ii];
      if (prohibitedKeyPathPart !== keyPathPart && (prohibitedKeyPathPart !== KEYPATH_WILDCARD || typeof keyPathPart !== "number")) {
        return false;
      }
    }
    return true;
  });
}
function getBigIntUpcastResponseTransformer(allowedNumericKeyPaths) {
  return getTreeWalkerResponseTransformer([getBigIntUpcastVisitor(allowedNumericKeyPaths)], { keyPath: [] });
}
function getResultResponseTransformer() {
  return (json) => json.result;
}
function getThrowSolanaErrorResponseTransformer() {
  return (json) => {
    const jsonRpcResponse = json;
    if ("error" in jsonRpcResponse) {
      throw getSolanaErrorFromJsonRpcError(jsonRpcResponse.error);
    }
    return jsonRpcResponse;
  };
}
function getDefaultResponseTransformerForSolanaRpc(config) {
  return (response, request) => {
    const methodName = request.methodName;
    const keyPaths = config?.allowedNumericKeyPaths && methodName ? config.allowedNumericKeyPaths[methodName] : undefined;
    return pipe(response, (r) => getThrowSolanaErrorResponseTransformer()(r, request), (r) => getResultResponseTransformer()(r, request), (r) => getBigIntUpcastResponseTransformer(keyPaths ?? [])(r, request));
  };
}
function getDefaultResponseTransformerForSolanaRpcSubscriptions(config) {
  return (response, request) => {
    const methodName = request.methodName;
    const keyPaths = config?.allowedNumericKeyPaths && methodName ? config.allowedNumericKeyPaths[methodName] : undefined;
    return pipe(response, (r) => getBigIntUpcastResponseTransformer(keyPaths ?? [])(r, request));
  };
}
var KEYPATH_WILDCARD, OPTIONS_OBJECT_POSITION_BY_METHOD, jsonParsedTokenAccountsConfigs, jsonParsedAccountsConfigs, innerInstructionsConfigs, messageConfig;
var init_index_node28 = __esm(() => {
  init_index_node16();
  init_index_node6();
  KEYPATH_WILDCARD = {};
  OPTIONS_OBJECT_POSITION_BY_METHOD = {
    accountNotifications: 1,
    blockNotifications: 1,
    getAccountInfo: 1,
    getBalance: 1,
    getBlock: 1,
    getBlockHeight: 0,
    getBlockProduction: 0,
    getBlocks: 2,
    getBlocksWithLimit: 2,
    getEpochInfo: 0,
    getFeeForMessage: 1,
    getInflationGovernor: 0,
    getInflationReward: 1,
    getLargestAccounts: 0,
    getLatestBlockhash: 0,
    getLeaderSchedule: 1,
    getMinimumBalanceForRentExemption: 1,
    getMultipleAccounts: 1,
    getProgramAccounts: 1,
    getSignaturesForAddress: 1,
    getSlot: 0,
    getSlotLeader: 0,
    getStakeMinimumDelegation: 0,
    getSupply: 0,
    getTokenAccountBalance: 1,
    getTokenAccountsByDelegate: 2,
    getTokenAccountsByOwner: 2,
    getTokenLargestAccounts: 1,
    getTokenSupply: 1,
    getTransaction: 1,
    getTransactionCount: 0,
    getVoteAccounts: 0,
    isBlockhashValid: 1,
    logsNotifications: 1,
    programNotifications: 1,
    requestAirdrop: 2,
    sendTransaction: 1,
    signatureNotifications: 1,
    simulateTransaction: 1
  };
  jsonParsedTokenAccountsConfigs = [
    ["data", "parsed", "info", "tokenAmount", "decimals"],
    ["data", "parsed", "info", "tokenAmount", "uiAmount"],
    ["data", "parsed", "info", "rentExemptReserve", "decimals"],
    ["data", "parsed", "info", "rentExemptReserve", "uiAmount"],
    ["data", "parsed", "info", "delegatedAmount", "decimals"],
    ["data", "parsed", "info", "delegatedAmount", "uiAmount"],
    ["data", "parsed", "info", "extensions", KEYPATH_WILDCARD, "state", "olderTransferFee", "transferFeeBasisPoints"],
    ["data", "parsed", "info", "extensions", KEYPATH_WILDCARD, "state", "newerTransferFee", "transferFeeBasisPoints"],
    ["data", "parsed", "info", "extensions", KEYPATH_WILDCARD, "state", "preUpdateAverageRate"],
    ["data", "parsed", "info", "extensions", KEYPATH_WILDCARD, "state", "currentRate"]
  ];
  jsonParsedAccountsConfigs = [
    ...jsonParsedTokenAccountsConfigs,
    ["data", "parsed", "info", "lastExtendedSlotStartIndex"],
    ["data", "parsed", "info", "slashPenalty"],
    ["data", "parsed", "info", "warmupCooldownRate"],
    ["data", "parsed", "info", "decimals"],
    ["data", "parsed", "info", "numRequiredSigners"],
    ["data", "parsed", "info", "numValidSigners"],
    ["data", "parsed", "info", "stake", "delegation", "warmupCooldownRate"],
    ["data", "parsed", "info", "exemptionThreshold"],
    ["data", "parsed", "info", "burnPercent"],
    ["data", "parsed", "info", "commission"],
    ["data", "parsed", "info", "votes", KEYPATH_WILDCARD, "confirmationCount"]
  ];
  innerInstructionsConfigs = [
    ["index"],
    ["instructions", KEYPATH_WILDCARD, "accounts", KEYPATH_WILDCARD],
    ["instructions", KEYPATH_WILDCARD, "programIdIndex"],
    ["instructions", KEYPATH_WILDCARD, "stackHeight"]
  ];
  messageConfig = [
    ["addressTableLookups", KEYPATH_WILDCARD, "writableIndexes", KEYPATH_WILDCARD],
    ["addressTableLookups", KEYPATH_WILDCARD, "readonlyIndexes", KEYPATH_WILDCARD],
    ["header", "numReadonlySignedAccounts"],
    ["header", "numReadonlyUnsignedAccounts"],
    ["header", "numRequiredSignatures"],
    ["instructions", KEYPATH_WILDCARD, "accounts", KEYPATH_WILDCARD],
    ["instructions", KEYPATH_WILDCARD, "programIdIndex"],
    ["instructions", KEYPATH_WILDCARD, "stackHeight"]
  ];
});

// ../../node_modules/.bun/@solana+rpc-api@5.1.0+7f9e3d21594a24ff/node_modules/@solana/rpc-api/dist/index.node.mjs
function createSolanaRpcApi(config) {
  return createJsonRpcApi({
    requestTransformer: getDefaultRequestTransformerForSolanaRpc(config),
    responseTransformer: getDefaultResponseTransformerForSolanaRpc({
      allowedNumericKeyPaths: getAllowedNumericKeypaths()
    })
  });
}
function getAllowedNumericKeypaths() {
  if (!memoizedKeypaths) {
    memoizedKeypaths = {
      getAccountInfo: jsonParsedAccountsConfigs.map((c) => ["value", ...c]),
      getBlock: [
        ["transactions", KEYPATH_WILDCARD, "meta", "preTokenBalances", KEYPATH_WILDCARD, "accountIndex"],
        [
          "transactions",
          KEYPATH_WILDCARD,
          "meta",
          "preTokenBalances",
          KEYPATH_WILDCARD,
          "uiTokenAmount",
          "decimals"
        ],
        ["transactions", KEYPATH_WILDCARD, "meta", "postTokenBalances", KEYPATH_WILDCARD, "accountIndex"],
        [
          "transactions",
          KEYPATH_WILDCARD,
          "meta",
          "postTokenBalances",
          KEYPATH_WILDCARD,
          "uiTokenAmount",
          "decimals"
        ],
        ["transactions", KEYPATH_WILDCARD, "meta", "rewards", KEYPATH_WILDCARD, "commission"],
        ...innerInstructionsConfigs.map((c) => [
          "transactions",
          KEYPATH_WILDCARD,
          "meta",
          "innerInstructions",
          KEYPATH_WILDCARD,
          ...c
        ]),
        ...messageConfig.map((c) => ["transactions", KEYPATH_WILDCARD, "transaction", "message", ...c]),
        ["rewards", KEYPATH_WILDCARD, "commission"]
      ],
      getClusterNodes: [
        [KEYPATH_WILDCARD, "featureSet"],
        [KEYPATH_WILDCARD, "shredVersion"]
      ],
      getInflationGovernor: [["initial"], ["foundation"], ["foundationTerm"], ["taper"], ["terminal"]],
      getInflationRate: [["foundation"], ["total"], ["validator"]],
      getInflationReward: [[KEYPATH_WILDCARD, "commission"]],
      getMultipleAccounts: jsonParsedAccountsConfigs.map((c) => ["value", KEYPATH_WILDCARD, ...c]),
      getProgramAccounts: jsonParsedAccountsConfigs.flatMap((c) => [
        ["value", KEYPATH_WILDCARD, "account", ...c],
        [KEYPATH_WILDCARD, "account", ...c]
      ]),
      getRecentPerformanceSamples: [[KEYPATH_WILDCARD, "samplePeriodSecs"]],
      getTokenAccountBalance: [
        ["value", "decimals"],
        ["value", "uiAmount"]
      ],
      getTokenAccountsByDelegate: jsonParsedTokenAccountsConfigs.map((c) => [
        "value",
        KEYPATH_WILDCARD,
        "account",
        ...c
      ]),
      getTokenAccountsByOwner: jsonParsedTokenAccountsConfigs.map((c) => [
        "value",
        KEYPATH_WILDCARD,
        "account",
        ...c
      ]),
      getTokenLargestAccounts: [
        ["value", KEYPATH_WILDCARD, "decimals"],
        ["value", KEYPATH_WILDCARD, "uiAmount"]
      ],
      getTokenSupply: [
        ["value", "decimals"],
        ["value", "uiAmount"]
      ],
      getTransaction: [
        ["meta", "preTokenBalances", KEYPATH_WILDCARD, "accountIndex"],
        ["meta", "preTokenBalances", KEYPATH_WILDCARD, "uiTokenAmount", "decimals"],
        ["meta", "postTokenBalances", KEYPATH_WILDCARD, "accountIndex"],
        ["meta", "postTokenBalances", KEYPATH_WILDCARD, "uiTokenAmount", "decimals"],
        ["meta", "rewards", KEYPATH_WILDCARD, "commission"],
        ...innerInstructionsConfigs.map((c) => ["meta", "innerInstructions", KEYPATH_WILDCARD, ...c]),
        ...messageConfig.map((c) => ["transaction", "message", ...c])
      ],
      getVersion: [["feature-set"]],
      getVoteAccounts: [
        ["current", KEYPATH_WILDCARD, "commission"],
        ["delinquent", KEYPATH_WILDCARD, "commission"]
      ],
      simulateTransaction: [
        ["value", "loadedAccountsDataSize"],
        ...jsonParsedAccountsConfigs.map((c) => ["value", "accounts", KEYPATH_WILDCARD, ...c]),
        ...innerInstructionsConfigs.map((c) => ["value", "innerInstructions", KEYPATH_WILDCARD, ...c])
      ]
    };
  }
  return memoizedKeypaths;
}
var memoizedKeypaths;
var init_index_node29 = __esm(() => {
  init_index_node27();
  init_index_node28();
});

// ../../node_modules/.bun/@solana+rpc-transport-http@5.1.0+1fb4c65d43e298b9/node_modules/@solana/rpc-transport-http/dist/index.node.mjs
function assertIsAllowedHttpRequestHeaders(headers) {
  const badHeaders = Object.keys(headers).filter((headerName) => {
    const lowercaseHeaderName = headerName.toLowerCase();
    return DISALLOWED_HEADERS[headerName.toLowerCase()] === true || FORBIDDEN_HEADERS[headerName.toLowerCase()] === true || lowercaseHeaderName.startsWith("proxy-") || lowercaseHeaderName.startsWith("sec-");
  });
  if (badHeaders.length > 0) {
    throw new SolanaError2(SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN2, {
      headers: badHeaders
    });
  }
}
function normalizeHeaders(headers) {
  const out = {};
  for (const headerName in headers) {
    out[headerName.toLowerCase()] = headers[headerName];
  }
  return out;
}
function createHttpTransport(config) {
  if (false)
    ;
  const { fromJson, headers, toJson, url } = config;
  if (headers) {
    assertIsAllowedHttpRequestHeaders(headers);
  }
  let dispatcherConfig;
  if ("dispatcher_NODE_ONLY" in config) {
    dispatcherConfig = { dispatcher: config.dispatcher_NODE_ONLY };
  }
  const customHeaders = headers && normalizeHeaders(headers);
  return async function makeHttpRequest({
    payload,
    signal
  }) {
    const body = toJson ? toJson(payload) : JSON.stringify(payload);
    const requestInfo = {
      ...dispatcherConfig,
      body,
      headers: {
        ...customHeaders,
        accept: "application/json",
        "content-length": body.length.toString(),
        "content-type": "application/json; charset=utf-8"
      },
      method: "POST",
      signal
    };
    const response = await fetch(url, requestInfo);
    if (!response.ok) {
      throw new SolanaError2(SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR2, {
        headers: response.headers,
        message: response.statusText,
        statusCode: response.status
      });
    }
    if (fromJson) {
      return fromJson(await response.text(), payload);
    }
    return await response.json();
  };
}
function isSolanaRequest(payload) {
  return isJsonRpcPayload(payload) && SOLANA_RPC_METHODS.includes(payload.method);
}
function createHttpTransportForSolanaRpc(config) {
  return createHttpTransport({
    ...config,
    fromJson: (rawResponse, payload) => isSolanaRequest(payload) ? parseJsonWithBigInts(rawResponse) : JSON.parse(rawResponse),
    toJson: (payload) => isSolanaRequest(payload) ? stringifyJsonWithBigInts(payload) : JSON.stringify(payload)
  });
}
var DISALLOWED_HEADERS, FORBIDDEN_HEADERS, SOLANA_RPC_METHODS;
var init_index_node30 = __esm(() => {
  init_index_node6();
  init_index_node26();
  init_index_node27();
  DISALLOWED_HEADERS = {
    accept: true,
    "content-length": true,
    "content-type": true
  };
  FORBIDDEN_HEADERS = /* @__PURE__ */ Object.assign({
    "accept-charset": true,
    "access-control-request-headers": true,
    "access-control-request-method": true,
    connection: true,
    "content-length": true,
    cookie: true,
    date: true,
    dnt: true,
    expect: true,
    host: true,
    "keep-alive": true,
    "permissions-policy": true,
    referer: true,
    te: true,
    trailer: true,
    "transfer-encoding": true,
    upgrade: true,
    via: true
  }, undefined, undefined);
  SOLANA_RPC_METHODS = [
    "getAccountInfo",
    "getBalance",
    "getBlock",
    "getBlockCommitment",
    "getBlockHeight",
    "getBlockProduction",
    "getBlocks",
    "getBlocksWithLimit",
    "getBlockTime",
    "getClusterNodes",
    "getEpochInfo",
    "getEpochSchedule",
    "getFeeForMessage",
    "getFirstAvailableBlock",
    "getGenesisHash",
    "getHealth",
    "getHighestSnapshotSlot",
    "getIdentity",
    "getInflationGovernor",
    "getInflationRate",
    "getInflationReward",
    "getLargestAccounts",
    "getLatestBlockhash",
    "getLeaderSchedule",
    "getMaxRetransmitSlot",
    "getMaxShredInsertSlot",
    "getMinimumBalanceForRentExemption",
    "getMultipleAccounts",
    "getProgramAccounts",
    "getRecentPerformanceSamples",
    "getRecentPrioritizationFees",
    "getSignaturesForAddress",
    "getSignatureStatuses",
    "getSlot",
    "getSlotLeader",
    "getSlotLeaders",
    "getStakeMinimumDelegation",
    "getSupply",
    "getTokenAccountBalance",
    "getTokenAccountsByDelegate",
    "getTokenAccountsByOwner",
    "getTokenLargestAccounts",
    "getTokenSupply",
    "getTransaction",
    "getTransactionCount",
    "getVersion",
    "getVoteAccounts",
    "index",
    "isBlockhashValid",
    "minimumLedgerSlot",
    "requestAirdrop",
    "sendTransaction",
    "simulateTransaction"
  ];
});

// ../../node_modules/.bun/@solana+fast-stable-stringify@5.1.0+1fb4c65d43e298b9/node_modules/@solana/fast-stable-stringify/dist/index.node.mjs
function stringify(val, isArrayProp) {
  let i, max, str, keys, key, propVal, toStr;
  if (val === true) {
    return "true";
  }
  if (val === false) {
    return "false";
  }
  switch (typeof val) {
    case "object":
      if (val === null) {
        return null;
      } else if ("toJSON" in val && typeof val.toJSON === "function") {
        return stringify(val.toJSON(), isArrayProp);
      } else {
        toStr = objToString.call(val);
        if (toStr === "[object Array]") {
          str = "[";
          max = val.length - 1;
          for (i = 0;i < max; i++) {
            str += stringify(val[i], true) + ",";
          }
          if (max > -1) {
            str += stringify(val[i], true);
          }
          return str + "]";
        } else if (toStr === "[object Object]") {
          keys = objKeys(val).sort();
          max = keys.length;
          str = "";
          i = 0;
          while (i < max) {
            key = keys[i];
            propVal = stringify(val[key], false);
            if (propVal !== undefined) {
              if (str) {
                str += ",";
              }
              str += JSON.stringify(key) + ":" + propVal;
            }
            i++;
          }
          return "{" + str + "}";
        } else {
          return JSON.stringify(val);
        }
      }
    case "function":
    case "undefined":
      return isArrayProp ? null : undefined;
    case "bigint":
      return `${val.toString()}n`;
    case "string":
      return JSON.stringify(val);
    default:
      return isFinite(val) ? val : null;
  }
}
function index_default(val) {
  const returnVal = stringify(val, false);
  if (returnVal !== undefined) {
    return "" + returnVal;
  }
}
var objToString, objKeys;
var init_index_node31 = __esm(() => {
  objToString = Object.prototype.toString;
  objKeys = Object.keys || function(obj) {
    const keys = [];
    for (const name in obj) {
      keys.push(name);
    }
    return keys;
  };
});

// ../../node_modules/.bun/@solana+rpc@5.1.0+7f9e3d21594a24ff/node_modules/@solana/rpc/dist/index.node.mjs
var exports_index_node2 = {};
__export(exports_index_node2, {
  isJsonRpcPayload: () => isJsonRpcPayload,
  createSolanaRpcFromTransport: () => createSolanaRpcFromTransport,
  createSolanaRpcApi: () => createSolanaRpcApi,
  createSolanaRpc: () => createSolanaRpc,
  createRpc: () => createRpc,
  createJsonRpcApi: () => createJsonRpcApi,
  createDefaultRpcTransport: () => createDefaultRpcTransport,
  DEFAULT_RPC_CONFIG: () => DEFAULT_RPC_CONFIG
});
import { setMaxListeners } from "events";
function createSolanaJsonRpcIntegerOverflowError(methodName, keyPath, value) {
  let argumentLabel = "";
  if (typeof keyPath[0] === "number") {
    const argPosition = keyPath[0] + 1;
    const lastDigit = argPosition % 10;
    const lastTwoDigits = argPosition % 100;
    if (lastDigit == 1 && lastTwoDigits != 11) {
      argumentLabel = argPosition + "st";
    } else if (lastDigit == 2 && lastTwoDigits != 12) {
      argumentLabel = argPosition + "nd";
    } else if (lastDigit == 3 && lastTwoDigits != 13) {
      argumentLabel = argPosition + "rd";
    } else {
      argumentLabel = argPosition + "th";
    }
  } else {
    argumentLabel = `\`${keyPath[0].toString()}\``;
  }
  const path = keyPath.length > 1 ? keyPath.slice(1).map((pathPart) => typeof pathPart === "number" ? `[${pathPart}]` : pathPart).join(".") : undefined;
  const error = new SolanaError2(SOLANA_ERROR__RPC__INTEGER_OVERFLOW2, {
    argumentLabel,
    keyPath,
    methodName,
    optionalPathLabel: path ? ` at path \`${path}\`` : "",
    value,
    ...path !== undefined ? { path } : undefined
  });
  safeCaptureStackTrace(error, createSolanaJsonRpcIntegerOverflowError);
  return error;
}
function createExplicitAbortToken() {
  return {
    EXPLICIT_ABORT_TOKEN: "This object is thrown from the request that underlies a series of coalesced requests when the last request in that series aborts"
  };
}
function getRpcTransportWithRequestCoalescing(transport, getDeduplicationKey) {
  let coalescedRequestsByDeduplicationKey;
  return async function makeCoalescedHttpRequest(request) {
    const { payload, signal } = request;
    const deduplicationKey = getDeduplicationKey(payload);
    if (deduplicationKey === undefined) {
      return await transport(request);
    }
    if (!coalescedRequestsByDeduplicationKey) {
      queueMicrotask(() => {
        coalescedRequestsByDeduplicationKey = undefined;
      });
      coalescedRequestsByDeduplicationKey = {};
    }
    if (coalescedRequestsByDeduplicationKey[deduplicationKey] == null) {
      const abortController = new e3;
      const responsePromise = (async () => {
        try {
          return await transport({
            ...request,
            signal: abortController.signal
          });
        } catch (e22) {
          if (e22 === (EXPLICIT_ABORT_TOKEN ||= createExplicitAbortToken())) {
            return;
          }
          throw e22;
        }
      })();
      coalescedRequestsByDeduplicationKey[deduplicationKey] = {
        abortController,
        numConsumers: 0,
        responsePromise
      };
    }
    const coalescedRequest = coalescedRequestsByDeduplicationKey[deduplicationKey];
    coalescedRequest.numConsumers++;
    if (signal) {
      const responsePromise = coalescedRequest.responsePromise;
      return await new Promise((resolve, reject) => {
        const handleAbort = (e22) => {
          signal.removeEventListener("abort", handleAbort);
          coalescedRequest.numConsumers -= 1;
          queueMicrotask(() => {
            if (coalescedRequest.numConsumers === 0) {
              const abortController = coalescedRequest.abortController;
              abortController.abort(EXPLICIT_ABORT_TOKEN ||= createExplicitAbortToken());
            }
          });
          reject(e22.target.reason);
        };
        signal.addEventListener("abort", handleAbort);
        responsePromise.then(resolve).catch(reject).finally(() => {
          signal.removeEventListener("abort", handleAbort);
        });
      });
    } else {
      return await coalescedRequest.responsePromise;
    }
  };
}
function getSolanaRpcPayloadDeduplicationKey(payload) {
  return isJsonRpcPayload(payload) ? index_default([payload.method, payload.params]) : undefined;
}
function normalizeHeaders2(headers) {
  const out = {};
  for (const headerName in headers) {
    out[headerName.toLowerCase()] = headers[headerName];
  }
  return out;
}
function createDefaultRpcTransport(config) {
  return pipe(createHttpTransportForSolanaRpc({
    ...config,
    headers: {
      ...{
        "accept-encoding": "br,gzip,deflate"
      },
      ...config.headers ? normalizeHeaders2(config.headers) : undefined,
      ...{
        "solana-client": `js/${"5.1.0"}`
      }
    }
  }), (transport) => getRpcTransportWithRequestCoalescing(transport, getSolanaRpcPayloadDeduplicationKey));
}
function createSolanaRpc(clusterUrl, config) {
  return createSolanaRpcFromTransport(createDefaultRpcTransport({ url: clusterUrl, ...config }));
}
function createSolanaRpcFromTransport(transport) {
  return createRpc({
    api: createSolanaRpcApi(DEFAULT_RPC_CONFIG),
    transport
  });
}
var DEFAULT_RPC_CONFIG, e3, EXPLICIT_ABORT_TOKEN;
var init_index_node32 = __esm(() => {
  init_index_node29();
  init_index_node27();
  init_index_node6();
  init_index_node16();
  init_index_node30();
  init_index_node31();
  init_index_node29();
  init_index_node27();
  DEFAULT_RPC_CONFIG = {
    defaultCommitment: "confirmed",
    onIntegerOverflow(request, keyPath, value) {
      throw createSolanaJsonRpcIntegerOverflowError(request.methodName, keyPath, value);
    }
  };
  e3 = class extends globalThis.AbortController {
    constructor(...t) {
      super(...t), setMaxListeners(Number.MAX_SAFE_INTEGER, this.signal);
    }
  };
});

// ../../node_modules/.bun/@solana+subscribable@5.1.0+1fb4c65d43e298b9/node_modules/@solana/subscribable/dist/index.node.mjs
import { setMaxListeners as setMaxListeners2 } from "events";
function createExplicitAbortToken2() {
  return Symbol("This symbol is thrown from a socket's iterator when the connection is explicitly aborted by the user");
}
function createAsyncIterableFromDataPublisher({
  abortSignal,
  dataChannelName,
  dataPublisher,
  errorChannelName
}) {
  const iteratorState = /* @__PURE__ */ new Map;
  function publishErrorToAllIterators(reason) {
    for (const [iteratorKey, state] of iteratorState.entries()) {
      if (state.__hasPolled) {
        iteratorState.delete(iteratorKey);
        state.onError(reason);
      } else {
        state.publishQueue.push({
          __type: 1,
          err: reason
        });
      }
    }
  }
  const abortController = new e4;
  abortSignal.addEventListener("abort", () => {
    abortController.abort();
    publishErrorToAllIterators(EXPLICIT_ABORT_TOKEN2 ||= createExplicitAbortToken2());
  });
  const options2 = { signal: abortController.signal };
  let firstError = UNINITIALIZED;
  dataPublisher.on(errorChannelName, (err) => {
    if (firstError === UNINITIALIZED) {
      firstError = err;
      abortController.abort();
      publishErrorToAllIterators(err);
    }
  }, options2);
  dataPublisher.on(dataChannelName, (data) => {
    iteratorState.forEach((state, iteratorKey) => {
      if (state.__hasPolled) {
        const { onData } = state;
        iteratorState.set(iteratorKey, { __hasPolled: false, publishQueue: [] });
        onData(data);
      } else {
        state.publishQueue.push({
          __type: 0,
          data
        });
      }
    });
  }, options2);
  return {
    async* [Symbol.asyncIterator]() {
      if (abortSignal.aborted) {
        return;
      }
      if (firstError !== UNINITIALIZED) {
        throw firstError;
      }
      const iteratorKey = Symbol();
      iteratorState.set(iteratorKey, { __hasPolled: false, publishQueue: [] });
      try {
        while (true) {
          const state = iteratorState.get(iteratorKey);
          if (!state) {
            throw new SolanaError2(SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING2);
          }
          if (state.__hasPolled) {
            throw new SolanaError2(SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE2);
          }
          const publishQueue = state.publishQueue;
          try {
            if (publishQueue.length) {
              state.publishQueue = [];
              for (const item of publishQueue) {
                if (item.__type === 0) {
                  yield item.data;
                } else {
                  throw item.err;
                }
              }
            } else {
              yield await new Promise((resolve, reject) => {
                iteratorState.set(iteratorKey, {
                  __hasPolled: true,
                  onData: resolve,
                  onError: reject
                });
              });
            }
          } catch (e22) {
            if (e22 === (EXPLICIT_ABORT_TOKEN2 ||= createExplicitAbortToken2())) {
              return;
            } else {
              throw e22;
            }
          }
        }
      } finally {
        iteratorState.delete(iteratorKey);
      }
    }
  };
}
function getDataPublisherFromEventEmitter(eventEmitter) {
  return {
    on(channelName, subscriber, options2) {
      function innerListener(ev) {
        if (ev instanceof CustomEvent) {
          const data = ev.detail;
          subscriber(data);
        } else {
          subscriber();
        }
      }
      eventEmitter.addEventListener(channelName, innerListener, options2);
      return () => {
        eventEmitter.removeEventListener(channelName, innerListener);
      };
    }
  };
}
function demultiplexDataPublisher(publisher, sourceChannelName, messageTransformer) {
  let innerPublisherState;
  const eventTarget = new s;
  const demultiplexedDataPublisher = getDataPublisherFromEventEmitter(eventTarget);
  return {
    ...demultiplexedDataPublisher,
    on(channelName, subscriber, options2) {
      if (!innerPublisherState) {
        const innerPublisherUnsubscribe = publisher.on(sourceChannelName, (sourceMessage) => {
          const transformResult = messageTransformer(sourceMessage);
          if (!transformResult) {
            return;
          }
          const [destinationChannelName, message] = transformResult;
          eventTarget.dispatchEvent(new CustomEvent(destinationChannelName, {
            detail: message
          }));
        });
        innerPublisherState = {
          dispose: innerPublisherUnsubscribe,
          numSubscribers: 0
        };
      }
      innerPublisherState.numSubscribers++;
      const unsubscribe = demultiplexedDataPublisher.on(channelName, subscriber, options2);
      let isActive = true;
      function handleUnsubscribe() {
        if (!isActive) {
          return;
        }
        isActive = false;
        options2?.signal.removeEventListener("abort", handleUnsubscribe);
        innerPublisherState.numSubscribers--;
        if (innerPublisherState.numSubscribers === 0) {
          innerPublisherState.dispose();
          innerPublisherState = undefined;
        }
        unsubscribe();
      }
      options2?.signal.addEventListener("abort", handleUnsubscribe);
      return handleUnsubscribe;
    }
  };
}
var e4, s, EXPLICIT_ABORT_TOKEN2, UNINITIALIZED;
var init_index_node33 = __esm(() => {
  init_index_node6();
  e4 = class extends globalThis.AbortController {
    constructor(...t) {
      super(...t), setMaxListeners2(Number.MAX_SAFE_INTEGER, this.signal);
    }
  };
  s = class extends globalThis.EventTarget {
    constructor(...t) {
      super(...t), setMaxListeners2(Number.MAX_SAFE_INTEGER, this);
    }
  };
  UNINITIALIZED = Symbol();
});

// ../../node_modules/.bun/@solana+rpc-subscriptions-spec@5.1.0+1fb4c65d43e298b9/node_modules/@solana/rpc-subscriptions-spec/dist/index.node.mjs
import { setMaxListeners as setMaxListeners3 } from "events";
function createSubscriptionRpc(rpcConfig) {
  return new Proxy(rpcConfig.api, {
    defineProperty() {
      return false;
    },
    deleteProperty() {
      return false;
    },
    get(target, p, receiver) {
      if (p === "then") {
        return;
      }
      return function(...rawParams) {
        const notificationName = p.toString();
        const createRpcSubscriptionPlan = Reflect.get(target, notificationName, receiver);
        if (!createRpcSubscriptionPlan) {
          throw new SolanaError2(SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN2, {
            notificationName
          });
        }
        const subscriptionPlan = createRpcSubscriptionPlan(...rawParams);
        return createPendingRpcSubscription(rpcConfig.transport, subscriptionPlan);
      };
    }
  });
}
function createPendingRpcSubscription(transport, subscriptionsPlan) {
  return {
    async subscribe({ abortSignal }) {
      const notificationsDataPublisher = await transport({
        signal: abortSignal,
        ...subscriptionsPlan
      });
      return createAsyncIterableFromDataPublisher({
        abortSignal,
        dataChannelName: "notification",
        dataPublisher: notificationsDataPublisher,
        errorChannelName: "error"
      });
    }
  };
}
function createRpcSubscriptionsApi(config) {
  return new Proxy({}, {
    defineProperty() {
      return false;
    },
    deleteProperty() {
      return false;
    },
    get(...args) {
      const [_, p] = args;
      const methodName = p.toString();
      return function(...params) {
        const rawRequest = { methodName, params };
        const request = config.requestTransformer ? config.requestTransformer(rawRequest) : rawRequest;
        return {
          execute(planConfig) {
            return config.planExecutor({ ...planConfig, request });
          },
          request
        };
      };
    }
  });
}
function transformChannelInboundMessages(channel, transform) {
  return Object.freeze({
    ...channel,
    on(type, subscriber, options2) {
      if (type !== "message") {
        return channel.on(type, subscriber, options2);
      }
      return channel.on("message", (message) => subscriber(transform(message)), options2);
    }
  });
}
function transformChannelOutboundMessages(channel, transform) {
  return Object.freeze({
    ...channel,
    send: (message) => channel.send(transform(message))
  });
}
function decrementSubscriberCountAndReturnNewCount(channel, subscriptionId) {
  return augmentSubscriberCountAndReturnNewCount(-1, channel, subscriptionId);
}
function incrementSubscriberCount(channel, subscriptionId) {
  augmentSubscriberCountAndReturnNewCount(1, channel, subscriptionId);
}
function getSubscriberCountBySubscriptionIdForChannel(channel) {
  let subscriberCountBySubscriptionId = subscriberCountBySubscriptionIdByChannel.get(channel);
  if (!subscriberCountBySubscriptionId) {
    subscriberCountBySubscriptionIdByChannel.set(channel, subscriberCountBySubscriptionId = {});
  }
  return subscriberCountBySubscriptionId;
}
function augmentSubscriberCountAndReturnNewCount(amount, channel, subscriptionId) {
  if (subscriptionId === undefined) {
    return;
  }
  const subscriberCountBySubscriptionId = getSubscriberCountBySubscriptionIdForChannel(channel);
  if (!subscriberCountBySubscriptionId[subscriptionId] && amount > 0) {
    subscriberCountBySubscriptionId[subscriptionId] = 0;
  }
  const newCount = amount + subscriberCountBySubscriptionId[subscriptionId];
  if (newCount <= 0) {
    delete subscriberCountBySubscriptionId[subscriptionId];
  } else {
    subscriberCountBySubscriptionId[subscriptionId] = newCount;
  }
  return newCount;
}
function getMemoizedDemultiplexedNotificationPublisherFromChannelAndResponseTransformer(channel, subscribeRequest, responseTransformer) {
  let publisherByResponseTransformer = cache.get(channel);
  if (!publisherByResponseTransformer) {
    cache.set(channel, publisherByResponseTransformer = /* @__PURE__ */ new WeakMap);
  }
  const responseTransformerKey = responseTransformer ?? channel;
  let publisher = publisherByResponseTransformer.get(responseTransformerKey);
  if (!publisher) {
    publisherByResponseTransformer.set(responseTransformerKey, publisher = demultiplexDataPublisher(channel, "message", (rawMessage) => {
      const message = rawMessage;
      if (!("method" in message)) {
        return;
      }
      const transformedNotification = responseTransformer ? responseTransformer(message.params.result, subscribeRequest) : message.params.result;
      return [`notification:${message.params.subscription}`, transformedNotification];
    }));
  }
  return publisher;
}
async function executeRpcPubSubSubscriptionPlan({
  channel,
  responseTransformer,
  signal,
  subscribeRequest,
  unsubscribeMethodName
}) {
  let subscriptionId;
  channel.on("error", () => {
    subscriptionId = undefined;
    subscriberCountBySubscriptionIdByChannel.delete(channel);
  }, { signal });
  const abortPromise = new Promise((_, reject) => {
    function handleAbort() {
      if (decrementSubscriberCountAndReturnNewCount(channel, subscriptionId) === 0) {
        const unsubscribePayload = createRpcMessage({
          methodName: unsubscribeMethodName,
          params: [subscriptionId]
        });
        subscriptionId = undefined;
        channel.send(unsubscribePayload).catch(() => {});
      }
      reject(this.reason);
    }
    if (signal.aborted) {
      handleAbort.call(signal);
    } else {
      signal.addEventListener("abort", handleAbort);
    }
  });
  const subscribePayload = createRpcMessage(subscribeRequest);
  await channel.send(subscribePayload);
  const subscriptionIdPromise = new Promise((resolve, reject) => {
    const abortController = new e5;
    signal.addEventListener("abort", abortController.abort.bind(abortController));
    const options2 = { signal: abortController.signal };
    channel.on("error", (err) => {
      abortController.abort();
      reject(err);
    }, options2);
    channel.on("message", (message) => {
      if (message && typeof message === "object" && "id" in message && message.id === subscribePayload.id) {
        abortController.abort();
        if ("error" in message) {
          reject(getSolanaErrorFromJsonRpcError(message.error));
        } else {
          resolve(message.result);
        }
      }
    }, options2);
  });
  subscriptionId = await safeRace([abortPromise, subscriptionIdPromise]);
  if (subscriptionId == null) {
    throw new SolanaError2(SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID2);
  }
  incrementSubscriberCount(channel, subscriptionId);
  const notificationPublisher = getMemoizedDemultiplexedNotificationPublisherFromChannelAndResponseTransformer(channel, subscribeRequest, responseTransformer);
  const notificationKey = `notification:${subscriptionId}`;
  return {
    on(type, listener, options2) {
      switch (type) {
        case "notification":
          return notificationPublisher.on(notificationKey, listener, options2);
        case "error":
          return channel.on("error", listener, options2);
        default:
          throw new SolanaError2(SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED2, {
            channelName: type,
            supportedChannelNames: ["notification", "error"]
          });
      }
    }
  };
}
var e5, subscriberCountBySubscriptionIdByChannel, cache;
var init_index_node34 = __esm(() => {
  init_index_node6();
  init_index_node33();
  init_index_node22();
  init_index_node26();
  e5 = class extends globalThis.AbortController {
    constructor(...t) {
      super(...t), setMaxListeners3(Number.MAX_SAFE_INTEGER, this.signal);
    }
  };
  subscriberCountBySubscriptionIdByChannel = /* @__PURE__ */ new WeakMap;
  cache = /* @__PURE__ */ new WeakMap;
});

// ../../node_modules/.bun/@solana+rpc-subscriptions-api@5.1.0+7f9e3d21594a24ff/node_modules/@solana/rpc-subscriptions-api/dist/index.node.mjs
function createSolanaRpcSubscriptionsApi_INTERNAL(config) {
  const requestTransformer = getDefaultRequestTransformerForSolanaRpc(config);
  const responseTransformer = getDefaultResponseTransformerForSolanaRpcSubscriptions({
    allowedNumericKeyPaths: getAllowedNumericKeypaths2()
  });
  return createRpcSubscriptionsApi({
    planExecutor({ request, ...rest }) {
      return executeRpcPubSubSubscriptionPlan({
        ...rest,
        responseTransformer,
        subscribeRequest: { ...request, methodName: request.methodName.replace(/Notifications$/, "Subscribe") },
        unsubscribeMethodName: request.methodName.replace(/Notifications$/, "Unsubscribe")
      });
    },
    requestTransformer
  });
}
function createSolanaRpcSubscriptionsApi(config) {
  return createSolanaRpcSubscriptionsApi_INTERNAL(config);
}
function createSolanaRpcSubscriptionsApi_UNSTABLE(config) {
  return createSolanaRpcSubscriptionsApi_INTERNAL(config);
}
function getAllowedNumericKeypaths2() {
  if (!memoizedKeypaths2) {
    memoizedKeypaths2 = {
      accountNotifications: jsonParsedAccountsConfigs.map((c) => ["value", ...c]),
      blockNotifications: [
        [
          "value",
          "block",
          "transactions",
          KEYPATH_WILDCARD,
          "meta",
          "preTokenBalances",
          KEYPATH_WILDCARD,
          "accountIndex"
        ],
        [
          "value",
          "block",
          "transactions",
          KEYPATH_WILDCARD,
          "meta",
          "preTokenBalances",
          KEYPATH_WILDCARD,
          "uiTokenAmount",
          "decimals"
        ],
        [
          "value",
          "block",
          "transactions",
          KEYPATH_WILDCARD,
          "meta",
          "postTokenBalances",
          KEYPATH_WILDCARD,
          "accountIndex"
        ],
        [
          "value",
          "block",
          "transactions",
          KEYPATH_WILDCARD,
          "meta",
          "postTokenBalances",
          KEYPATH_WILDCARD,
          "uiTokenAmount",
          "decimals"
        ],
        ["value", "block", "transactions", KEYPATH_WILDCARD, "meta", "rewards", KEYPATH_WILDCARD, "commission"],
        [
          "value",
          "block",
          "transactions",
          KEYPATH_WILDCARD,
          "meta",
          "innerInstructions",
          KEYPATH_WILDCARD,
          "index"
        ],
        [
          "value",
          "block",
          "transactions",
          KEYPATH_WILDCARD,
          "meta",
          "innerInstructions",
          KEYPATH_WILDCARD,
          "instructions",
          KEYPATH_WILDCARD,
          "programIdIndex"
        ],
        [
          "value",
          "block",
          "transactions",
          KEYPATH_WILDCARD,
          "meta",
          "innerInstructions",
          KEYPATH_WILDCARD,
          "instructions",
          KEYPATH_WILDCARD,
          "accounts",
          KEYPATH_WILDCARD
        ],
        [
          "value",
          "block",
          "transactions",
          KEYPATH_WILDCARD,
          "transaction",
          "message",
          "addressTableLookups",
          KEYPATH_WILDCARD,
          "writableIndexes",
          KEYPATH_WILDCARD
        ],
        [
          "value",
          "block",
          "transactions",
          KEYPATH_WILDCARD,
          "transaction",
          "message",
          "addressTableLookups",
          KEYPATH_WILDCARD,
          "readonlyIndexes",
          KEYPATH_WILDCARD
        ],
        [
          "value",
          "block",
          "transactions",
          KEYPATH_WILDCARD,
          "transaction",
          "message",
          "instructions",
          KEYPATH_WILDCARD,
          "programIdIndex"
        ],
        [
          "value",
          "block",
          "transactions",
          KEYPATH_WILDCARD,
          "transaction",
          "message",
          "instructions",
          KEYPATH_WILDCARD,
          "accounts",
          KEYPATH_WILDCARD
        ],
        [
          "value",
          "block",
          "transactions",
          KEYPATH_WILDCARD,
          "transaction",
          "message",
          "header",
          "numReadonlySignedAccounts"
        ],
        [
          "value",
          "block",
          "transactions",
          KEYPATH_WILDCARD,
          "transaction",
          "message",
          "header",
          "numReadonlyUnsignedAccounts"
        ],
        [
          "value",
          "block",
          "transactions",
          KEYPATH_WILDCARD,
          "transaction",
          "message",
          "header",
          "numRequiredSignatures"
        ],
        ["value", "block", "rewards", KEYPATH_WILDCARD, "commission"]
      ],
      programNotifications: jsonParsedAccountsConfigs.flatMap((c) => [
        ["value", KEYPATH_WILDCARD, "account", ...c],
        [KEYPATH_WILDCARD, "account", ...c]
      ])
    };
  }
  return memoizedKeypaths2;
}
var memoizedKeypaths2;
var init_index_node35 = __esm(() => {
  init_index_node34();
  init_index_node28();
});

// ../../node_modules/.bun/ws@8.18.3+4789783d1fa00420/node_modules/ws/lib/constants.js
var require_constants = __commonJS((exports, module) => {
  var BINARY_TYPES = ["nodebuffer", "arraybuffer", "fragments"];
  var hasBlob = typeof Blob !== "undefined";
  if (hasBlob)
    BINARY_TYPES.push("blob");
  module.exports = {
    BINARY_TYPES,
    EMPTY_BUFFER: Buffer.alloc(0),
    GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
    hasBlob,
    kForOnEventAttribute: Symbol("kIsForOnEventAttribute"),
    kListener: Symbol("kListener"),
    kStatusCode: Symbol("status-code"),
    kWebSocket: Symbol("websocket"),
    NOOP: () => {}
  };
});

// ../../node_modules/.bun/node-gyp-build@4.8.4/node_modules/node-gyp-build/node-gyp-build.js
var require_node_gyp_build = __commonJS((exports, module) => {
  var fs = __require("fs");
  var path = __require("path");
  var os = __require("os");
  var runtimeRequire = typeof __webpack_require__ === "function" ? __non_webpack_require__ : __require;
  var vars = process.config && process.config.variables || {};
  var prebuildsOnly = !!process.env.PREBUILDS_ONLY;
  var abi = process.versions.modules;
  var runtime = isElectron() ? "electron" : isNwjs() ? "node-webkit" : "node";
  var arch = process.env.npm_config_arch || os.arch();
  var platform = process.env.npm_config_platform || os.platform();
  var libc = process.env.LIBC || (isAlpine(platform) ? "musl" : "glibc");
  var armv = process.env.ARM_VERSION || (arch === "arm64" ? "8" : vars.arm_version) || "";
  var uv = (process.versions.uv || "").split(".")[0];
  module.exports = load;
  function load(dir) {
    return runtimeRequire(load.resolve(dir));
  }
  load.resolve = load.path = function(dir) {
    dir = path.resolve(dir || ".");
    try {
      var name = runtimeRequire(path.join(dir, "package.json")).name.toUpperCase().replace(/-/g, "_");
      if (process.env[name + "_PREBUILD"])
        dir = process.env[name + "_PREBUILD"];
    } catch (err) {}
    if (!prebuildsOnly) {
      var release = getFirst(path.join(dir, "build/Release"), matchBuild);
      if (release)
        return release;
      var debug = getFirst(path.join(dir, "build/Debug"), matchBuild);
      if (debug)
        return debug;
    }
    var prebuild = resolve(dir);
    if (prebuild)
      return prebuild;
    var nearby = resolve(path.dirname(process.execPath));
    if (nearby)
      return nearby;
    var target = [
      "platform=" + platform,
      "arch=" + arch,
      "runtime=" + runtime,
      "abi=" + abi,
      "uv=" + uv,
      armv ? "armv=" + armv : "",
      "libc=" + libc,
      "node=" + process.versions.node,
      process.versions.electron ? "electron=" + process.versions.electron : "",
      typeof __webpack_require__ === "function" ? "webpack=true" : ""
    ].filter(Boolean).join(" ");
    throw new Error("No native build was found for " + target + `
    loaded from: ` + dir + `
`);
    function resolve(dir2) {
      var tuples = readdirSync(path.join(dir2, "prebuilds")).map(parseTuple);
      var tuple = tuples.filter(matchTuple(platform, arch)).sort(compareTuples)[0];
      if (!tuple)
        return;
      var prebuilds = path.join(dir2, "prebuilds", tuple.name);
      var parsed = readdirSync(prebuilds).map(parseTags);
      var candidates = parsed.filter(matchTags(runtime, abi));
      var winner = candidates.sort(compareTags(runtime))[0];
      if (winner)
        return path.join(prebuilds, winner.file);
    }
  };
  function readdirSync(dir) {
    try {
      return fs.readdirSync(dir);
    } catch (err) {
      return [];
    }
  }
  function getFirst(dir, filter) {
    var files = readdirSync(dir).filter(filter);
    return files[0] && path.join(dir, files[0]);
  }
  function matchBuild(name) {
    return /\.node$/.test(name);
  }
  function parseTuple(name) {
    var arr = name.split("-");
    if (arr.length !== 2)
      return;
    var platform2 = arr[0];
    var architectures = arr[1].split("+");
    if (!platform2)
      return;
    if (!architectures.length)
      return;
    if (!architectures.every(Boolean))
      return;
    return { name, platform: platform2, architectures };
  }
  function matchTuple(platform2, arch2) {
    return function(tuple) {
      if (tuple == null)
        return false;
      if (tuple.platform !== platform2)
        return false;
      return tuple.architectures.includes(arch2);
    };
  }
  function compareTuples(a, b) {
    return a.architectures.length - b.architectures.length;
  }
  function parseTags(file) {
    var arr = file.split(".");
    var extension = arr.pop();
    var tags = { file, specificity: 0 };
    if (extension !== "node")
      return;
    for (var i = 0;i < arr.length; i++) {
      var tag = arr[i];
      if (tag === "node" || tag === "electron" || tag === "node-webkit") {
        tags.runtime = tag;
      } else if (tag === "napi") {
        tags.napi = true;
      } else if (tag.slice(0, 3) === "abi") {
        tags.abi = tag.slice(3);
      } else if (tag.slice(0, 2) === "uv") {
        tags.uv = tag.slice(2);
      } else if (tag.slice(0, 4) === "armv") {
        tags.armv = tag.slice(4);
      } else if (tag === "glibc" || tag === "musl") {
        tags.libc = tag;
      } else {
        continue;
      }
      tags.specificity++;
    }
    return tags;
  }
  function matchTags(runtime2, abi2) {
    return function(tags) {
      if (tags == null)
        return false;
      if (tags.runtime && tags.runtime !== runtime2 && !runtimeAgnostic(tags))
        return false;
      if (tags.abi && tags.abi !== abi2 && !tags.napi)
        return false;
      if (tags.uv && tags.uv !== uv)
        return false;
      if (tags.armv && tags.armv !== armv)
        return false;
      if (tags.libc && tags.libc !== libc)
        return false;
      return true;
    };
  }
  function runtimeAgnostic(tags) {
    return tags.runtime === "node" && tags.napi;
  }
  function compareTags(runtime2) {
    return function(a, b) {
      if (a.runtime !== b.runtime) {
        return a.runtime === runtime2 ? -1 : 1;
      } else if (a.abi !== b.abi) {
        return a.abi ? -1 : 1;
      } else if (a.specificity !== b.specificity) {
        return a.specificity > b.specificity ? -1 : 1;
      } else {
        return 0;
      }
    };
  }
  function isNwjs() {
    return !!(process.versions && process.versions.nw);
  }
  function isElectron() {
    if (process.versions && process.versions.electron)
      return true;
    if (process.env.ELECTRON_RUN_AS_NODE)
      return true;
    return typeof window !== "undefined" && window.process && window.process.type === "renderer";
  }
  function isAlpine(platform2) {
    return platform2 === "linux" && fs.existsSync("/etc/alpine-release");
  }
  load.parseTags = parseTags;
  load.matchTags = matchTags;
  load.compareTags = compareTags;
  load.parseTuple = parseTuple;
  load.matchTuple = matchTuple;
  load.compareTuples = compareTuples;
});

// ../../node_modules/.bun/node-gyp-build@4.8.4/node_modules/node-gyp-build/index.js
var require_node_gyp_build2 = __commonJS((exports, module) => {
  var runtimeRequire = typeof __webpack_require__ === "function" ? __non_webpack_require__ : __require;
  if (typeof runtimeRequire.addon === "function") {
    module.exports = runtimeRequire.addon.bind(runtimeRequire);
  } else {
    module.exports = require_node_gyp_build();
  }
});

// ../../node_modules/.bun/bufferutil@4.1.0/node_modules/bufferutil/fallback.js
var require_fallback = __commonJS((exports, module) => {
  var mask = (source, mask2, output, offset, length) => {
    for (var i = 0;i < length; i++) {
      output[offset + i] = source[i] ^ mask2[i & 3];
    }
  };
  var unmask = (buffer, mask2) => {
    const length = buffer.length;
    for (var i = 0;i < length; i++) {
      buffer[i] ^= mask2[i & 3];
    }
  };
  module.exports = { mask, unmask };
});

// ../../node_modules/.bun/bufferutil@4.1.0/node_modules/bufferutil/index.js
var require_bufferutil = __commonJS((exports, module) => {
  var __dirname = "/Users/home/projects/GhostSpeak/node_modules/.bun/bufferutil@4.1.0/node_modules/bufferutil";
  try {
    module.exports = require_node_gyp_build2()(__dirname);
  } catch (e6) {
    module.exports = require_fallback();
  }
});

// ../../node_modules/.bun/ws@8.18.3+4789783d1fa00420/node_modules/ws/lib/buffer-util.js
var require_buffer_util = __commonJS((exports, module) => {
  var { EMPTY_BUFFER } = require_constants();
  var FastBuffer = Buffer[Symbol.species];
  function concat(list, totalLength) {
    if (list.length === 0)
      return EMPTY_BUFFER;
    if (list.length === 1)
      return list[0];
    const target = Buffer.allocUnsafe(totalLength);
    let offset = 0;
    for (let i = 0;i < list.length; i++) {
      const buf = list[i];
      target.set(buf, offset);
      offset += buf.length;
    }
    if (offset < totalLength) {
      return new FastBuffer(target.buffer, target.byteOffset, offset);
    }
    return target;
  }
  function _mask(source, mask, output, offset, length) {
    for (let i = 0;i < length; i++) {
      output[offset + i] = source[i] ^ mask[i & 3];
    }
  }
  function _unmask(buffer, mask) {
    for (let i = 0;i < buffer.length; i++) {
      buffer[i] ^= mask[i & 3];
    }
  }
  function toArrayBuffer3(buf) {
    if (buf.length === buf.buffer.byteLength) {
      return buf.buffer;
    }
    return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);
  }
  function toBuffer(data) {
    toBuffer.readOnly = true;
    if (Buffer.isBuffer(data))
      return data;
    let buf;
    if (data instanceof ArrayBuffer) {
      buf = new FastBuffer(data);
    } else if (ArrayBuffer.isView(data)) {
      buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);
    } else {
      buf = Buffer.from(data);
      toBuffer.readOnly = false;
    }
    return buf;
  }
  module.exports = {
    concat,
    mask: _mask,
    toArrayBuffer: toArrayBuffer3,
    toBuffer,
    unmask: _unmask
  };
  if (!process.env.WS_NO_BUFFER_UTIL) {
    try {
      const bufferUtil = require_bufferutil();
      module.exports.mask = function(source, mask, output, offset, length) {
        if (length < 48)
          _mask(source, mask, output, offset, length);
        else
          bufferUtil.mask(source, mask, output, offset, length);
      };
      module.exports.unmask = function(buffer, mask) {
        if (buffer.length < 32)
          _unmask(buffer, mask);
        else
          bufferUtil.unmask(buffer, mask);
      };
    } catch (e6) {}
  }
});

// ../../node_modules/.bun/ws@8.18.3+4789783d1fa00420/node_modules/ws/lib/limiter.js
var require_limiter = __commonJS((exports, module) => {
  var kDone = Symbol("kDone");
  var kRun = Symbol("kRun");

  class Limiter {
    constructor(concurrency) {
      this[kDone] = () => {
        this.pending--;
        this[kRun]();
      };
      this.concurrency = concurrency || Infinity;
      this.jobs = [];
      this.pending = 0;
    }
    add(job) {
      this.jobs.push(job);
      this[kRun]();
    }
    [kRun]() {
      if (this.pending === this.concurrency)
        return;
      if (this.jobs.length) {
        const job = this.jobs.shift();
        this.pending++;
        job(this[kDone]);
      }
    }
  }
  module.exports = Limiter;
});

// ../../node_modules/.bun/ws@8.18.3+4789783d1fa00420/node_modules/ws/lib/permessage-deflate.js
var require_permessage_deflate = __commonJS((exports, module) => {
  var zlib = __require("zlib");
  var bufferUtil = require_buffer_util();
  var Limiter = require_limiter();
  var { kStatusCode } = require_constants();
  var FastBuffer = Buffer[Symbol.species];
  var TRAILER = Buffer.from([0, 0, 255, 255]);
  var kPerMessageDeflate = Symbol("permessage-deflate");
  var kTotalLength = Symbol("total-length");
  var kCallback = Symbol("callback");
  var kBuffers = Symbol("buffers");
  var kError = Symbol("error");
  var zlibLimiter;

  class PerMessageDeflate {
    constructor(options2, isServer, maxPayload) {
      this._maxPayload = maxPayload | 0;
      this._options = options2 || {};
      this._threshold = this._options.threshold !== undefined ? this._options.threshold : 1024;
      this._isServer = !!isServer;
      this._deflate = null;
      this._inflate = null;
      this.params = null;
      if (!zlibLimiter) {
        const concurrency = this._options.concurrencyLimit !== undefined ? this._options.concurrencyLimit : 10;
        zlibLimiter = new Limiter(concurrency);
      }
    }
    static get extensionName() {
      return "permessage-deflate";
    }
    offer() {
      const params = {};
      if (this._options.serverNoContextTakeover) {
        params.server_no_context_takeover = true;
      }
      if (this._options.clientNoContextTakeover) {
        params.client_no_context_takeover = true;
      }
      if (this._options.serverMaxWindowBits) {
        params.server_max_window_bits = this._options.serverMaxWindowBits;
      }
      if (this._options.clientMaxWindowBits) {
        params.client_max_window_bits = this._options.clientMaxWindowBits;
      } else if (this._options.clientMaxWindowBits == null) {
        params.client_max_window_bits = true;
      }
      return params;
    }
    accept(configurations) {
      configurations = this.normalizeParams(configurations);
      this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
      return this.params;
    }
    cleanup() {
      if (this._inflate) {
        this._inflate.close();
        this._inflate = null;
      }
      if (this._deflate) {
        const callback = this._deflate[kCallback];
        this._deflate.close();
        this._deflate = null;
        if (callback) {
          callback(new Error("The deflate stream was closed while data was being processed"));
        }
      }
    }
    acceptAsServer(offers) {
      const opts = this._options;
      const accepted = offers.find((params) => {
        if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params.client_max_window_bits) {
          return false;
        }
        return true;
      });
      if (!accepted) {
        throw new Error("None of the extension offers can be accepted");
      }
      if (opts.serverNoContextTakeover) {
        accepted.server_no_context_takeover = true;
      }
      if (opts.clientNoContextTakeover) {
        accepted.client_no_context_takeover = true;
      }
      if (typeof opts.serverMaxWindowBits === "number") {
        accepted.server_max_window_bits = opts.serverMaxWindowBits;
      }
      if (typeof opts.clientMaxWindowBits === "number") {
        accepted.client_max_window_bits = opts.clientMaxWindowBits;
      } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
        delete accepted.client_max_window_bits;
      }
      return accepted;
    }
    acceptAsClient(response) {
      const params = response[0];
      if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
        throw new Error('Unexpected parameter "client_no_context_takeover"');
      }
      if (!params.client_max_window_bits) {
        if (typeof this._options.clientMaxWindowBits === "number") {
          params.client_max_window_bits = this._options.clientMaxWindowBits;
        }
      } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params.client_max_window_bits > this._options.clientMaxWindowBits) {
        throw new Error('Unexpected or invalid parameter "client_max_window_bits"');
      }
      return params;
    }
    normalizeParams(configurations) {
      configurations.forEach((params) => {
        Object.keys(params).forEach((key) => {
          let value = params[key];
          if (value.length > 1) {
            throw new Error(`Parameter "${key}" must have only a single value`);
          }
          value = value[0];
          if (key === "client_max_window_bits") {
            if (value !== true) {
              const num = +value;
              if (!Number.isInteger(num) || num < 8 || num > 15) {
                throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
              }
              value = num;
            } else if (!this._isServer) {
              throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
            }
          } else if (key === "server_max_window_bits") {
            const num = +value;
            if (!Number.isInteger(num) || num < 8 || num > 15) {
              throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
            }
            value = num;
          } else if (key === "client_no_context_takeover" || key === "server_no_context_takeover") {
            if (value !== true) {
              throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
            }
          } else {
            throw new Error(`Unknown parameter "${key}"`);
          }
          params[key] = value;
        });
      });
      return configurations;
    }
    decompress(data, fin, callback) {
      zlibLimiter.add((done) => {
        this._decompress(data, fin, (err, result) => {
          done();
          callback(err, result);
        });
      });
    }
    compress(data, fin, callback) {
      zlibLimiter.add((done) => {
        this._compress(data, fin, (err, result) => {
          done();
          callback(err, result);
        });
      });
    }
    _decompress(data, fin, callback) {
      const endpoint = this._isServer ? "client" : "server";
      if (!this._inflate) {
        const key = `${endpoint}_max_window_bits`;
        const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
        this._inflate = zlib.createInflateRaw({
          ...this._options.zlibInflateOptions,
          windowBits
        });
        this._inflate[kPerMessageDeflate] = this;
        this._inflate[kTotalLength] = 0;
        this._inflate[kBuffers] = [];
        this._inflate.on("error", inflateOnError);
        this._inflate.on("data", inflateOnData);
      }
      this._inflate[kCallback] = callback;
      this._inflate.write(data);
      if (fin)
        this._inflate.write(TRAILER);
      this._inflate.flush(() => {
        const err = this._inflate[kError];
        if (err) {
          this._inflate.close();
          this._inflate = null;
          callback(err);
          return;
        }
        const data2 = bufferUtil.concat(this._inflate[kBuffers], this._inflate[kTotalLength]);
        if (this._inflate._readableState.endEmitted) {
          this._inflate.close();
          this._inflate = null;
        } else {
          this._inflate[kTotalLength] = 0;
          this._inflate[kBuffers] = [];
          if (fin && this.params[`${endpoint}_no_context_takeover`]) {
            this._inflate.reset();
          }
        }
        callback(null, data2);
      });
    }
    _compress(data, fin, callback) {
      const endpoint = this._isServer ? "server" : "client";
      if (!this._deflate) {
        const key = `${endpoint}_max_window_bits`;
        const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
        this._deflate = zlib.createDeflateRaw({
          ...this._options.zlibDeflateOptions,
          windowBits
        });
        this._deflate[kTotalLength] = 0;
        this._deflate[kBuffers] = [];
        this._deflate.on("data", deflateOnData);
      }
      this._deflate[kCallback] = callback;
      this._deflate.write(data);
      this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
        if (!this._deflate) {
          return;
        }
        let data2 = bufferUtil.concat(this._deflate[kBuffers], this._deflate[kTotalLength]);
        if (fin) {
          data2 = new FastBuffer(data2.buffer, data2.byteOffset, data2.length - 4);
        }
        this._deflate[kCallback] = null;
        this._deflate[kTotalLength] = 0;
        this._deflate[kBuffers] = [];
        if (fin && this.params[`${endpoint}_no_context_takeover`]) {
          this._deflate.reset();
        }
        callback(null, data2);
      });
    }
  }
  module.exports = PerMessageDeflate;
  function deflateOnData(chunk) {
    this[kBuffers].push(chunk);
    this[kTotalLength] += chunk.length;
  }
  function inflateOnData(chunk) {
    this[kTotalLength] += chunk.length;
    if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
      this[kBuffers].push(chunk);
      return;
    }
    this[kError] = new RangeError("Max payload size exceeded");
    this[kError].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH";
    this[kError][kStatusCode] = 1009;
    this.removeListener("data", inflateOnData);
    this.reset();
  }
  function inflateOnError(err) {
    this[kPerMessageDeflate]._inflate = null;
    if (this[kError]) {
      this[kCallback](this[kError]);
      return;
    }
    err[kStatusCode] = 1007;
    this[kCallback](err);
  }
});

// ../../node_modules/.bun/utf-8-validate@5.0.10/node_modules/utf-8-validate/fallback.js
var require_fallback2 = __commonJS((exports, module) => {
  function isValidUTF8(buf) {
    const len = buf.length;
    let i = 0;
    while (i < len) {
      if ((buf[i] & 128) === 0) {
        i++;
      } else if ((buf[i] & 224) === 192) {
        if (i + 1 === len || (buf[i + 1] & 192) !== 128 || (buf[i] & 254) === 192) {
          return false;
        }
        i += 2;
      } else if ((buf[i] & 240) === 224) {
        if (i + 2 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || buf[i] === 224 && (buf[i + 1] & 224) === 128 || buf[i] === 237 && (buf[i + 1] & 224) === 160) {
          return false;
        }
        i += 3;
      } else if ((buf[i] & 248) === 240) {
        if (i + 3 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || (buf[i + 3] & 192) !== 128 || buf[i] === 240 && (buf[i + 1] & 240) === 128 || buf[i] === 244 && buf[i + 1] > 143 || buf[i] > 244) {
          return false;
        }
        i += 4;
      } else {
        return false;
      }
    }
    return true;
  }
  module.exports = isValidUTF8;
});

// ../../node_modules/.bun/utf-8-validate@5.0.10/node_modules/utf-8-validate/index.js
var require_utf_8_validate = __commonJS((exports, module) => {
  var __dirname = "/Users/home/projects/GhostSpeak/node_modules/.bun/utf-8-validate@5.0.10/node_modules/utf-8-validate";
  try {
    module.exports = require_node_gyp_build2()(__dirname);
  } catch (e6) {
    module.exports = require_fallback2();
  }
});

// ../../node_modules/.bun/ws@8.18.3+4789783d1fa00420/node_modules/ws/lib/validation.js
var require_validation = __commonJS((exports, module) => {
  var { isUtf8 } = __require("buffer");
  var { hasBlob } = require_constants();
  var tokenChars = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    0,
    1,
    0
  ];
  function isValidStatusCode(code) {
    return code >= 1000 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3000 && code <= 4999;
  }
  function _isValidUTF8(buf) {
    const len = buf.length;
    let i = 0;
    while (i < len) {
      if ((buf[i] & 128) === 0) {
        i++;
      } else if ((buf[i] & 224) === 192) {
        if (i + 1 === len || (buf[i + 1] & 192) !== 128 || (buf[i] & 254) === 192) {
          return false;
        }
        i += 2;
      } else if ((buf[i] & 240) === 224) {
        if (i + 2 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || buf[i] === 224 && (buf[i + 1] & 224) === 128 || buf[i] === 237 && (buf[i + 1] & 224) === 160) {
          return false;
        }
        i += 3;
      } else if ((buf[i] & 248) === 240) {
        if (i + 3 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || (buf[i + 3] & 192) !== 128 || buf[i] === 240 && (buf[i + 1] & 240) === 128 || buf[i] === 244 && buf[i + 1] > 143 || buf[i] > 244) {
          return false;
        }
        i += 4;
      } else {
        return false;
      }
    }
    return true;
  }
  function isBlob(value) {
    return hasBlob && typeof value === "object" && typeof value.arrayBuffer === "function" && typeof value.type === "string" && typeof value.stream === "function" && (value[Symbol.toStringTag] === "Blob" || value[Symbol.toStringTag] === "File");
  }
  module.exports = {
    isBlob,
    isValidStatusCode,
    isValidUTF8: _isValidUTF8,
    tokenChars
  };
  if (isUtf8) {
    module.exports.isValidUTF8 = function(buf) {
      return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);
    };
  } else if (!process.env.WS_NO_UTF_8_VALIDATE) {
    try {
      const isValidUTF8 = require_utf_8_validate();
      module.exports.isValidUTF8 = function(buf) {
        return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);
      };
    } catch (e6) {}
  }
});

// ../../node_modules/.bun/ws@8.18.3+4789783d1fa00420/node_modules/ws/lib/receiver.js
var require_receiver = __commonJS((exports, module) => {
  var { Writable } = __require("stream");
  var PerMessageDeflate = require_permessage_deflate();
  var {
    BINARY_TYPES,
    EMPTY_BUFFER,
    kStatusCode,
    kWebSocket
  } = require_constants();
  var { concat, toArrayBuffer: toArrayBuffer3, unmask } = require_buffer_util();
  var { isValidStatusCode, isValidUTF8 } = require_validation();
  var FastBuffer = Buffer[Symbol.species];
  var GET_INFO = 0;
  var GET_PAYLOAD_LENGTH_16 = 1;
  var GET_PAYLOAD_LENGTH_64 = 2;
  var GET_MASK = 3;
  var GET_DATA = 4;
  var INFLATING = 5;
  var DEFER_EVENT = 6;

  class Receiver extends Writable {
    constructor(options2 = {}) {
      super();
      this._allowSynchronousEvents = options2.allowSynchronousEvents !== undefined ? options2.allowSynchronousEvents : true;
      this._binaryType = options2.binaryType || BINARY_TYPES[0];
      this._extensions = options2.extensions || {};
      this._isServer = !!options2.isServer;
      this._maxPayload = options2.maxPayload | 0;
      this._skipUTF8Validation = !!options2.skipUTF8Validation;
      this[kWebSocket] = undefined;
      this._bufferedBytes = 0;
      this._buffers = [];
      this._compressed = false;
      this._payloadLength = 0;
      this._mask = undefined;
      this._fragmented = 0;
      this._masked = false;
      this._fin = false;
      this._opcode = 0;
      this._totalPayloadLength = 0;
      this._messageLength = 0;
      this._fragments = [];
      this._errored = false;
      this._loop = false;
      this._state = GET_INFO;
    }
    _write(chunk, encoding, cb) {
      if (this._opcode === 8 && this._state == GET_INFO)
        return cb();
      this._bufferedBytes += chunk.length;
      this._buffers.push(chunk);
      this.startLoop(cb);
    }
    consume(n) {
      this._bufferedBytes -= n;
      if (n === this._buffers[0].length)
        return this._buffers.shift();
      if (n < this._buffers[0].length) {
        const buf = this._buffers[0];
        this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n, buf.length - n);
        return new FastBuffer(buf.buffer, buf.byteOffset, n);
      }
      const dst = Buffer.allocUnsafe(n);
      do {
        const buf = this._buffers[0];
        const offset = dst.length - n;
        if (n >= buf.length) {
          dst.set(this._buffers.shift(), offset);
        } else {
          dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
          this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n, buf.length - n);
        }
        n -= buf.length;
      } while (n > 0);
      return dst;
    }
    startLoop(cb) {
      this._loop = true;
      do {
        switch (this._state) {
          case GET_INFO:
            this.getInfo(cb);
            break;
          case GET_PAYLOAD_LENGTH_16:
            this.getPayloadLength16(cb);
            break;
          case GET_PAYLOAD_LENGTH_64:
            this.getPayloadLength64(cb);
            break;
          case GET_MASK:
            this.getMask();
            break;
          case GET_DATA:
            this.getData(cb);
            break;
          case INFLATING:
          case DEFER_EVENT:
            this._loop = false;
            return;
        }
      } while (this._loop);
      if (!this._errored)
        cb();
    }
    getInfo(cb) {
      if (this._bufferedBytes < 2) {
        this._loop = false;
        return;
      }
      const buf = this.consume(2);
      if ((buf[0] & 48) !== 0) {
        const error = this.createError(RangeError, "RSV2 and RSV3 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_2_3");
        cb(error);
        return;
      }
      const compressed = (buf[0] & 64) === 64;
      if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
        const error = this.createError(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
        cb(error);
        return;
      }
      this._fin = (buf[0] & 128) === 128;
      this._opcode = buf[0] & 15;
      this._payloadLength = buf[1] & 127;
      if (this._opcode === 0) {
        if (compressed) {
          const error = this.createError(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
          cb(error);
          return;
        }
        if (!this._fragmented) {
          const error = this.createError(RangeError, "invalid opcode 0", true, 1002, "WS_ERR_INVALID_OPCODE");
          cb(error);
          return;
        }
        this._opcode = this._fragmented;
      } else if (this._opcode === 1 || this._opcode === 2) {
        if (this._fragmented) {
          const error = this.createError(RangeError, `invalid opcode ${this._opcode}`, true, 1002, "WS_ERR_INVALID_OPCODE");
          cb(error);
          return;
        }
        this._compressed = compressed;
      } else if (this._opcode > 7 && this._opcode < 11) {
        if (!this._fin) {
          const error = this.createError(RangeError, "FIN must be set", true, 1002, "WS_ERR_EXPECTED_FIN");
          cb(error);
          return;
        }
        if (compressed) {
          const error = this.createError(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
          cb(error);
          return;
        }
        if (this._payloadLength > 125 || this._opcode === 8 && this._payloadLength === 1) {
          const error = this.createError(RangeError, `invalid payload length ${this._payloadLength}`, true, 1002, "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH");
          cb(error);
          return;
        }
      } else {
        const error = this.createError(RangeError, `invalid opcode ${this._opcode}`, true, 1002, "WS_ERR_INVALID_OPCODE");
        cb(error);
        return;
      }
      if (!this._fin && !this._fragmented)
        this._fragmented = this._opcode;
      this._masked = (buf[1] & 128) === 128;
      if (this._isServer) {
        if (!this._masked) {
          const error = this.createError(RangeError, "MASK must be set", true, 1002, "WS_ERR_EXPECTED_MASK");
          cb(error);
          return;
        }
      } else if (this._masked) {
        const error = this.createError(RangeError, "MASK must be clear", true, 1002, "WS_ERR_UNEXPECTED_MASK");
        cb(error);
        return;
      }
      if (this._payloadLength === 126)
        this._state = GET_PAYLOAD_LENGTH_16;
      else if (this._payloadLength === 127)
        this._state = GET_PAYLOAD_LENGTH_64;
      else
        this.haveLength(cb);
    }
    getPayloadLength16(cb) {
      if (this._bufferedBytes < 2) {
        this._loop = false;
        return;
      }
      this._payloadLength = this.consume(2).readUInt16BE(0);
      this.haveLength(cb);
    }
    getPayloadLength64(cb) {
      if (this._bufferedBytes < 8) {
        this._loop = false;
        return;
      }
      const buf = this.consume(8);
      const num = buf.readUInt32BE(0);
      if (num > Math.pow(2, 53 - 32) - 1) {
        const error = this.createError(RangeError, "Unsupported WebSocket frame: payload length > 2^53 - 1", false, 1009, "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH");
        cb(error);
        return;
      }
      this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
      this.haveLength(cb);
    }
    haveLength(cb) {
      if (this._payloadLength && this._opcode < 8) {
        this._totalPayloadLength += this._payloadLength;
        if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
          const error = this.createError(RangeError, "Max payload size exceeded", false, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH");
          cb(error);
          return;
        }
      }
      if (this._masked)
        this._state = GET_MASK;
      else
        this._state = GET_DATA;
    }
    getMask() {
      if (this._bufferedBytes < 4) {
        this._loop = false;
        return;
      }
      this._mask = this.consume(4);
      this._state = GET_DATA;
    }
    getData(cb) {
      let data = EMPTY_BUFFER;
      if (this._payloadLength) {
        if (this._bufferedBytes < this._payloadLength) {
          this._loop = false;
          return;
        }
        data = this.consume(this._payloadLength);
        if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) {
          unmask(data, this._mask);
        }
      }
      if (this._opcode > 7) {
        this.controlMessage(data, cb);
        return;
      }
      if (this._compressed) {
        this._state = INFLATING;
        this.decompress(data, cb);
        return;
      }
      if (data.length) {
        this._messageLength = this._totalPayloadLength;
        this._fragments.push(data);
      }
      this.dataMessage(cb);
    }
    decompress(data, cb) {
      const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
      perMessageDeflate.decompress(data, this._fin, (err, buf) => {
        if (err)
          return cb(err);
        if (buf.length) {
          this._messageLength += buf.length;
          if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
            const error = this.createError(RangeError, "Max payload size exceeded", false, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH");
            cb(error);
            return;
          }
          this._fragments.push(buf);
        }
        this.dataMessage(cb);
        if (this._state === GET_INFO)
          this.startLoop(cb);
      });
    }
    dataMessage(cb) {
      if (!this._fin) {
        this._state = GET_INFO;
        return;
      }
      const messageLength = this._messageLength;
      const fragments = this._fragments;
      this._totalPayloadLength = 0;
      this._messageLength = 0;
      this._fragmented = 0;
      this._fragments = [];
      if (this._opcode === 2) {
        let data;
        if (this._binaryType === "nodebuffer") {
          data = concat(fragments, messageLength);
        } else if (this._binaryType === "arraybuffer") {
          data = toArrayBuffer3(concat(fragments, messageLength));
        } else if (this._binaryType === "blob") {
          data = new Blob(fragments);
        } else {
          data = fragments;
        }
        if (this._allowSynchronousEvents) {
          this.emit("message", data, true);
          this._state = GET_INFO;
        } else {
          this._state = DEFER_EVENT;
          setImmediate(() => {
            this.emit("message", data, true);
            this._state = GET_INFO;
            this.startLoop(cb);
          });
        }
      } else {
        const buf = concat(fragments, messageLength);
        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
          const error = this.createError(Error, "invalid UTF-8 sequence", true, 1007, "WS_ERR_INVALID_UTF8");
          cb(error);
          return;
        }
        if (this._state === INFLATING || this._allowSynchronousEvents) {
          this.emit("message", buf, false);
          this._state = GET_INFO;
        } else {
          this._state = DEFER_EVENT;
          setImmediate(() => {
            this.emit("message", buf, false);
            this._state = GET_INFO;
            this.startLoop(cb);
          });
        }
      }
    }
    controlMessage(data, cb) {
      if (this._opcode === 8) {
        if (data.length === 0) {
          this._loop = false;
          this.emit("conclude", 1005, EMPTY_BUFFER);
          this.end();
        } else {
          const code = data.readUInt16BE(0);
          if (!isValidStatusCode(code)) {
            const error = this.createError(RangeError, `invalid status code ${code}`, true, 1002, "WS_ERR_INVALID_CLOSE_CODE");
            cb(error);
            return;
          }
          const buf = new FastBuffer(data.buffer, data.byteOffset + 2, data.length - 2);
          if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
            const error = this.createError(Error, "invalid UTF-8 sequence", true, 1007, "WS_ERR_INVALID_UTF8");
            cb(error);
            return;
          }
          this._loop = false;
          this.emit("conclude", code, buf);
          this.end();
        }
        this._state = GET_INFO;
        return;
      }
      if (this._allowSynchronousEvents) {
        this.emit(this._opcode === 9 ? "ping" : "pong", data);
        this._state = GET_INFO;
      } else {
        this._state = DEFER_EVENT;
        setImmediate(() => {
          this.emit(this._opcode === 9 ? "ping" : "pong", data);
          this._state = GET_INFO;
          this.startLoop(cb);
        });
      }
    }
    createError(ErrorCtor, message, prefix, statusCode, errorCode) {
      this._loop = false;
      this._errored = true;
      const err = new ErrorCtor(prefix ? `Invalid WebSocket frame: ${message}` : message);
      Error.captureStackTrace(err, this.createError);
      err.code = errorCode;
      err[kStatusCode] = statusCode;
      return err;
    }
  }
  module.exports = Receiver;
});

// ../../node_modules/.bun/ws@8.18.3+4789783d1fa00420/node_modules/ws/lib/sender.js
var require_sender = __commonJS((exports, module) => {
  var { Duplex } = __require("stream");
  var { randomFillSync } = __require("crypto");
  var PerMessageDeflate = require_permessage_deflate();
  var { EMPTY_BUFFER, kWebSocket, NOOP } = require_constants();
  var { isBlob, isValidStatusCode } = require_validation();
  var { mask: applyMask, toBuffer } = require_buffer_util();
  var kByteLength = Symbol("kByteLength");
  var maskBuffer = Buffer.alloc(4);
  var RANDOM_POOL_SIZE = 8 * 1024;
  var randomPool;
  var randomPoolPointer = RANDOM_POOL_SIZE;
  var DEFAULT = 0;
  var DEFLATING = 1;
  var GET_BLOB_DATA = 2;

  class Sender {
    constructor(socket, extensions, generateMask) {
      this._extensions = extensions || {};
      if (generateMask) {
        this._generateMask = generateMask;
        this._maskBuffer = Buffer.alloc(4);
      }
      this._socket = socket;
      this._firstFragment = true;
      this._compress = false;
      this._bufferedBytes = 0;
      this._queue = [];
      this._state = DEFAULT;
      this.onerror = NOOP;
      this[kWebSocket] = undefined;
    }
    static frame(data, options2) {
      let mask;
      let merge = false;
      let offset = 2;
      let skipMasking = false;
      if (options2.mask) {
        mask = options2.maskBuffer || maskBuffer;
        if (options2.generateMask) {
          options2.generateMask(mask);
        } else {
          if (randomPoolPointer === RANDOM_POOL_SIZE) {
            if (randomPool === undefined) {
              randomPool = Buffer.alloc(RANDOM_POOL_SIZE);
            }
            randomFillSync(randomPool, 0, RANDOM_POOL_SIZE);
            randomPoolPointer = 0;
          }
          mask[0] = randomPool[randomPoolPointer++];
          mask[1] = randomPool[randomPoolPointer++];
          mask[2] = randomPool[randomPoolPointer++];
          mask[3] = randomPool[randomPoolPointer++];
        }
        skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
        offset = 6;
      }
      let dataLength;
      if (typeof data === "string") {
        if ((!options2.mask || skipMasking) && options2[kByteLength] !== undefined) {
          dataLength = options2[kByteLength];
        } else {
          data = Buffer.from(data);
          dataLength = data.length;
        }
      } else {
        dataLength = data.length;
        merge = options2.mask && options2.readOnly && !skipMasking;
      }
      let payloadLength = dataLength;
      if (dataLength >= 65536) {
        offset += 8;
        payloadLength = 127;
      } else if (dataLength > 125) {
        offset += 2;
        payloadLength = 126;
      }
      const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);
      target[0] = options2.fin ? options2.opcode | 128 : options2.opcode;
      if (options2.rsv1)
        target[0] |= 64;
      target[1] = payloadLength;
      if (payloadLength === 126) {
        target.writeUInt16BE(dataLength, 2);
      } else if (payloadLength === 127) {
        target[2] = target[3] = 0;
        target.writeUIntBE(dataLength, 4, 6);
      }
      if (!options2.mask)
        return [target, data];
      target[1] |= 128;
      target[offset - 4] = mask[0];
      target[offset - 3] = mask[1];
      target[offset - 2] = mask[2];
      target[offset - 1] = mask[3];
      if (skipMasking)
        return [target, data];
      if (merge) {
        applyMask(data, mask, target, offset, dataLength);
        return [target];
      }
      applyMask(data, mask, data, 0, dataLength);
      return [target, data];
    }
    close(code, data, mask, cb) {
      let buf;
      if (code === undefined) {
        buf = EMPTY_BUFFER;
      } else if (typeof code !== "number" || !isValidStatusCode(code)) {
        throw new TypeError("First argument must be a valid error code number");
      } else if (data === undefined || !data.length) {
        buf = Buffer.allocUnsafe(2);
        buf.writeUInt16BE(code, 0);
      } else {
        const length = Buffer.byteLength(data);
        if (length > 123) {
          throw new RangeError("The message must not be greater than 123 bytes");
        }
        buf = Buffer.allocUnsafe(2 + length);
        buf.writeUInt16BE(code, 0);
        if (typeof data === "string") {
          buf.write(data, 2);
        } else {
          buf.set(data, 2);
        }
      }
      const options2 = {
        [kByteLength]: buf.length,
        fin: true,
        generateMask: this._generateMask,
        mask,
        maskBuffer: this._maskBuffer,
        opcode: 8,
        readOnly: false,
        rsv1: false
      };
      if (this._state !== DEFAULT) {
        this.enqueue([this.dispatch, buf, false, options2, cb]);
      } else {
        this.sendFrame(Sender.frame(buf, options2), cb);
      }
    }
    ping(data, mask, cb) {
      let byteLength;
      let readOnly;
      if (typeof data === "string") {
        byteLength = Buffer.byteLength(data);
        readOnly = false;
      } else if (isBlob(data)) {
        byteLength = data.size;
        readOnly = false;
      } else {
        data = toBuffer(data);
        byteLength = data.length;
        readOnly = toBuffer.readOnly;
      }
      if (byteLength > 125) {
        throw new RangeError("The data size must not be greater than 125 bytes");
      }
      const options2 = {
        [kByteLength]: byteLength,
        fin: true,
        generateMask: this._generateMask,
        mask,
        maskBuffer: this._maskBuffer,
        opcode: 9,
        readOnly,
        rsv1: false
      };
      if (isBlob(data)) {
        if (this._state !== DEFAULT) {
          this.enqueue([this.getBlobData, data, false, options2, cb]);
        } else {
          this.getBlobData(data, false, options2, cb);
        }
      } else if (this._state !== DEFAULT) {
        this.enqueue([this.dispatch, data, false, options2, cb]);
      } else {
        this.sendFrame(Sender.frame(data, options2), cb);
      }
    }
    pong(data, mask, cb) {
      let byteLength;
      let readOnly;
      if (typeof data === "string") {
        byteLength = Buffer.byteLength(data);
        readOnly = false;
      } else if (isBlob(data)) {
        byteLength = data.size;
        readOnly = false;
      } else {
        data = toBuffer(data);
        byteLength = data.length;
        readOnly = toBuffer.readOnly;
      }
      if (byteLength > 125) {
        throw new RangeError("The data size must not be greater than 125 bytes");
      }
      const options2 = {
        [kByteLength]: byteLength,
        fin: true,
        generateMask: this._generateMask,
        mask,
        maskBuffer: this._maskBuffer,
        opcode: 10,
        readOnly,
        rsv1: false
      };
      if (isBlob(data)) {
        if (this._state !== DEFAULT) {
          this.enqueue([this.getBlobData, data, false, options2, cb]);
        } else {
          this.getBlobData(data, false, options2, cb);
        }
      } else if (this._state !== DEFAULT) {
        this.enqueue([this.dispatch, data, false, options2, cb]);
      } else {
        this.sendFrame(Sender.frame(data, options2), cb);
      }
    }
    send(data, options2, cb) {
      const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
      let opcode = options2.binary ? 2 : 1;
      let rsv1 = options2.compress;
      let byteLength;
      let readOnly;
      if (typeof data === "string") {
        byteLength = Buffer.byteLength(data);
        readOnly = false;
      } else if (isBlob(data)) {
        byteLength = data.size;
        readOnly = false;
      } else {
        data = toBuffer(data);
        byteLength = data.length;
        readOnly = toBuffer.readOnly;
      }
      if (this._firstFragment) {
        this._firstFragment = false;
        if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? "server_no_context_takeover" : "client_no_context_takeover"]) {
          rsv1 = byteLength >= perMessageDeflate._threshold;
        }
        this._compress = rsv1;
      } else {
        rsv1 = false;
        opcode = 0;
      }
      if (options2.fin)
        this._firstFragment = true;
      const opts = {
        [kByteLength]: byteLength,
        fin: options2.fin,
        generateMask: this._generateMask,
        mask: options2.mask,
        maskBuffer: this._maskBuffer,
        opcode,
        readOnly,
        rsv1
      };
      if (isBlob(data)) {
        if (this._state !== DEFAULT) {
          this.enqueue([this.getBlobData, data, this._compress, opts, cb]);
        } else {
          this.getBlobData(data, this._compress, opts, cb);
        }
      } else if (this._state !== DEFAULT) {
        this.enqueue([this.dispatch, data, this._compress, opts, cb]);
      } else {
        this.dispatch(data, this._compress, opts, cb);
      }
    }
    getBlobData(blob, compress, options2, cb) {
      this._bufferedBytes += options2[kByteLength];
      this._state = GET_BLOB_DATA;
      blob.arrayBuffer().then((arrayBuffer) => {
        if (this._socket.destroyed) {
          const err = new Error("The socket was closed while the blob was being read");
          process.nextTick(callCallbacks, this, err, cb);
          return;
        }
        this._bufferedBytes -= options2[kByteLength];
        const data = toBuffer(arrayBuffer);
        if (!compress) {
          this._state = DEFAULT;
          this.sendFrame(Sender.frame(data, options2), cb);
          this.dequeue();
        } else {
          this.dispatch(data, compress, options2, cb);
        }
      }).catch((err) => {
        process.nextTick(onError, this, err, cb);
      });
    }
    dispatch(data, compress, options2, cb) {
      if (!compress) {
        this.sendFrame(Sender.frame(data, options2), cb);
        return;
      }
      const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
      this._bufferedBytes += options2[kByteLength];
      this._state = DEFLATING;
      perMessageDeflate.compress(data, options2.fin, (_, buf) => {
        if (this._socket.destroyed) {
          const err = new Error("The socket was closed while data was being compressed");
          callCallbacks(this, err, cb);
          return;
        }
        this._bufferedBytes -= options2[kByteLength];
        this._state = DEFAULT;
        options2.readOnly = false;
        this.sendFrame(Sender.frame(buf, options2), cb);
        this.dequeue();
      });
    }
    dequeue() {
      while (this._state === DEFAULT && this._queue.length) {
        const params = this._queue.shift();
        this._bufferedBytes -= params[3][kByteLength];
        Reflect.apply(params[0], this, params.slice(1));
      }
    }
    enqueue(params) {
      this._bufferedBytes += params[3][kByteLength];
      this._queue.push(params);
    }
    sendFrame(list, cb) {
      if (list.length === 2) {
        this._socket.cork();
        this._socket.write(list[0]);
        this._socket.write(list[1], cb);
        this._socket.uncork();
      } else {
        this._socket.write(list[0], cb);
      }
    }
  }
  module.exports = Sender;
  function callCallbacks(sender, err, cb) {
    if (typeof cb === "function")
      cb(err);
    for (let i = 0;i < sender._queue.length; i++) {
      const params = sender._queue[i];
      const callback = params[params.length - 1];
      if (typeof callback === "function")
        callback(err);
    }
  }
  function onError(sender, err, cb) {
    callCallbacks(sender, err, cb);
    sender.onerror(err);
  }
});

// ../../node_modules/.bun/ws@8.18.3+4789783d1fa00420/node_modules/ws/lib/event-target.js
var require_event_target = __commonJS((exports, module) => {
  var { kForOnEventAttribute, kListener } = require_constants();
  var kCode = Symbol("kCode");
  var kData = Symbol("kData");
  var kError = Symbol("kError");
  var kMessage = Symbol("kMessage");
  var kReason = Symbol("kReason");
  var kTarget = Symbol("kTarget");
  var kType = Symbol("kType");
  var kWasClean = Symbol("kWasClean");

  class Event {
    constructor(type) {
      this[kTarget] = null;
      this[kType] = type;
    }
    get target() {
      return this[kTarget];
    }
    get type() {
      return this[kType];
    }
  }
  Object.defineProperty(Event.prototype, "target", { enumerable: true });
  Object.defineProperty(Event.prototype, "type", { enumerable: true });

  class CloseEvent extends Event {
    constructor(type, options2 = {}) {
      super(type);
      this[kCode] = options2.code === undefined ? 0 : options2.code;
      this[kReason] = options2.reason === undefined ? "" : options2.reason;
      this[kWasClean] = options2.wasClean === undefined ? false : options2.wasClean;
    }
    get code() {
      return this[kCode];
    }
    get reason() {
      return this[kReason];
    }
    get wasClean() {
      return this[kWasClean];
    }
  }
  Object.defineProperty(CloseEvent.prototype, "code", { enumerable: true });
  Object.defineProperty(CloseEvent.prototype, "reason", { enumerable: true });
  Object.defineProperty(CloseEvent.prototype, "wasClean", { enumerable: true });

  class ErrorEvent extends Event {
    constructor(type, options2 = {}) {
      super(type);
      this[kError] = options2.error === undefined ? null : options2.error;
      this[kMessage] = options2.message === undefined ? "" : options2.message;
    }
    get error() {
      return this[kError];
    }
    get message() {
      return this[kMessage];
    }
  }
  Object.defineProperty(ErrorEvent.prototype, "error", { enumerable: true });
  Object.defineProperty(ErrorEvent.prototype, "message", { enumerable: true });

  class MessageEvent extends Event {
    constructor(type, options2 = {}) {
      super(type);
      this[kData] = options2.data === undefined ? null : options2.data;
    }
    get data() {
      return this[kData];
    }
  }
  Object.defineProperty(MessageEvent.prototype, "data", { enumerable: true });
  var EventTarget = {
    addEventListener(type, handler, options2 = {}) {
      for (const listener of this.listeners(type)) {
        if (!options2[kForOnEventAttribute] && listener[kListener] === handler && !listener[kForOnEventAttribute]) {
          return;
        }
      }
      let wrapper;
      if (type === "message") {
        wrapper = function onMessage(data, isBinary) {
          const event = new MessageEvent("message", {
            data: isBinary ? data : data.toString()
          });
          event[kTarget] = this;
          callListener(handler, this, event);
        };
      } else if (type === "close") {
        wrapper = function onClose(code, message) {
          const event = new CloseEvent("close", {
            code,
            reason: message.toString(),
            wasClean: this._closeFrameReceived && this._closeFrameSent
          });
          event[kTarget] = this;
          callListener(handler, this, event);
        };
      } else if (type === "error") {
        wrapper = function onError(error) {
          const event = new ErrorEvent("error", {
            error,
            message: error.message
          });
          event[kTarget] = this;
          callListener(handler, this, event);
        };
      } else if (type === "open") {
        wrapper = function onOpen() {
          const event = new Event("open");
          event[kTarget] = this;
          callListener(handler, this, event);
        };
      } else {
        return;
      }
      wrapper[kForOnEventAttribute] = !!options2[kForOnEventAttribute];
      wrapper[kListener] = handler;
      if (options2.once) {
        this.once(type, wrapper);
      } else {
        this.on(type, wrapper);
      }
    },
    removeEventListener(type, handler) {
      for (const listener of this.listeners(type)) {
        if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {
          this.removeListener(type, listener);
          break;
        }
      }
    }
  };
  module.exports = {
    CloseEvent,
    ErrorEvent,
    Event,
    EventTarget,
    MessageEvent
  };
  function callListener(listener, thisArg, event) {
    if (typeof listener === "object" && listener.handleEvent) {
      listener.handleEvent.call(listener, event);
    } else {
      listener.call(thisArg, event);
    }
  }
});

// ../../node_modules/.bun/ws@8.18.3+4789783d1fa00420/node_modules/ws/lib/extension.js
var require_extension = __commonJS((exports, module) => {
  var { tokenChars } = require_validation();
  function push(dest, name, elem) {
    if (dest[name] === undefined)
      dest[name] = [elem];
    else
      dest[name].push(elem);
  }
  function parse(header) {
    const offers = Object.create(null);
    let params = Object.create(null);
    let mustUnescape = false;
    let isEscaping = false;
    let inQuotes = false;
    let extensionName;
    let paramName;
    let start = -1;
    let code = -1;
    let end = -1;
    let i = 0;
    for (;i < header.length; i++) {
      code = header.charCodeAt(i);
      if (extensionName === undefined) {
        if (end === -1 && tokenChars[code] === 1) {
          if (start === -1)
            start = i;
        } else if (i !== 0 && (code === 32 || code === 9)) {
          if (end === -1 && start !== -1)
            end = i;
        } else if (code === 59 || code === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (end === -1)
            end = i;
          const name = header.slice(start, end);
          if (code === 44) {
            push(offers, name, params);
            params = Object.create(null);
          } else {
            extensionName = name;
          }
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      } else if (paramName === undefined) {
        if (end === -1 && tokenChars[code] === 1) {
          if (start === -1)
            start = i;
        } else if (code === 32 || code === 9) {
          if (end === -1 && start !== -1)
            end = i;
        } else if (code === 59 || code === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (end === -1)
            end = i;
          push(params, header.slice(start, end), true);
          if (code === 44) {
            push(offers, extensionName, params);
            params = Object.create(null);
            extensionName = undefined;
          }
          start = end = -1;
        } else if (code === 61 && start !== -1 && end === -1) {
          paramName = header.slice(start, i);
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      } else {
        if (isEscaping) {
          if (tokenChars[code] !== 1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (start === -1)
            start = i;
          else if (!mustUnescape)
            mustUnescape = true;
          isEscaping = false;
        } else if (inQuotes) {
          if (tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (code === 34 && start !== -1) {
            inQuotes = false;
            end = i;
          } else if (code === 92) {
            isEscaping = true;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else if (code === 34 && header.charCodeAt(i - 1) === 61) {
          inQuotes = true;
        } else if (end === -1 && tokenChars[code] === 1) {
          if (start === -1)
            start = i;
        } else if (start !== -1 && (code === 32 || code === 9)) {
          if (end === -1)
            end = i;
        } else if (code === 59 || code === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (end === -1)
            end = i;
          let value = header.slice(start, end);
          if (mustUnescape) {
            value = value.replace(/\\/g, "");
            mustUnescape = false;
          }
          push(params, paramName, value);
          if (code === 44) {
            push(offers, extensionName, params);
            params = Object.create(null);
            extensionName = undefined;
          }
          paramName = undefined;
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      }
    }
    if (start === -1 || inQuotes || code === 32 || code === 9) {
      throw new SyntaxError("Unexpected end of input");
    }
    if (end === -1)
      end = i;
    const token = header.slice(start, end);
    if (extensionName === undefined) {
      push(offers, token, params);
    } else {
      if (paramName === undefined) {
        push(params, token, true);
      } else if (mustUnescape) {
        push(params, paramName, token.replace(/\\/g, ""));
      } else {
        push(params, paramName, token);
      }
      push(offers, extensionName, params);
    }
    return offers;
  }
  function format(extensions) {
    return Object.keys(extensions).map((extension) => {
      let configurations = extensions[extension];
      if (!Array.isArray(configurations))
        configurations = [configurations];
      return configurations.map((params) => {
        return [extension].concat(Object.keys(params).map((k) => {
          let values = params[k];
          if (!Array.isArray(values))
            values = [values];
          return values.map((v) => v === true ? k : `${k}=${v}`).join("; ");
        })).join("; ");
      }).join(", ");
    }).join(", ");
  }
  module.exports = { format, parse };
});

// ../../node_modules/.bun/ws@8.18.3+4789783d1fa00420/node_modules/ws/lib/websocket.js
var require_websocket = __commonJS((exports, module) => {
  var EventEmitter = __require("events");
  var https = __require("https");
  var http = __require("http");
  var net = __require("net");
  var tls = __require("tls");
  var { randomBytes, createHash } = __require("crypto");
  var { Duplex, Readable } = __require("stream");
  var { URL: URL2 } = __require("url");
  var PerMessageDeflate = require_permessage_deflate();
  var Receiver = require_receiver();
  var Sender = require_sender();
  var { isBlob } = require_validation();
  var {
    BINARY_TYPES,
    EMPTY_BUFFER,
    GUID,
    kForOnEventAttribute,
    kListener,
    kStatusCode,
    kWebSocket,
    NOOP
  } = require_constants();
  var {
    EventTarget: { addEventListener, removeEventListener }
  } = require_event_target();
  var { format, parse } = require_extension();
  var { toBuffer } = require_buffer_util();
  var closeTimeout = 30 * 1000;
  var kAborted = Symbol("kAborted");
  var protocolVersions = [8, 13];
  var readyStates = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"];
  var subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;

  class WebSocket extends EventEmitter {
    constructor(address3, protocols, options2) {
      super();
      this._binaryType = BINARY_TYPES[0];
      this._closeCode = 1006;
      this._closeFrameReceived = false;
      this._closeFrameSent = false;
      this._closeMessage = EMPTY_BUFFER;
      this._closeTimer = null;
      this._errorEmitted = false;
      this._extensions = {};
      this._paused = false;
      this._protocol = "";
      this._readyState = WebSocket.CONNECTING;
      this._receiver = null;
      this._sender = null;
      this._socket = null;
      if (address3 !== null) {
        this._bufferedAmount = 0;
        this._isServer = false;
        this._redirects = 0;
        if (protocols === undefined) {
          protocols = [];
        } else if (!Array.isArray(protocols)) {
          if (typeof protocols === "object" && protocols !== null) {
            options2 = protocols;
            protocols = [];
          } else {
            protocols = [protocols];
          }
        }
        initAsClient(this, address3, protocols, options2);
      } else {
        this._autoPong = options2.autoPong;
        this._isServer = true;
      }
    }
    get binaryType() {
      return this._binaryType;
    }
    set binaryType(type) {
      if (!BINARY_TYPES.includes(type))
        return;
      this._binaryType = type;
      if (this._receiver)
        this._receiver._binaryType = type;
    }
    get bufferedAmount() {
      if (!this._socket)
        return this._bufferedAmount;
      return this._socket._writableState.length + this._sender._bufferedBytes;
    }
    get extensions() {
      return Object.keys(this._extensions).join();
    }
    get isPaused() {
      return this._paused;
    }
    get onclose() {
      return null;
    }
    get onerror() {
      return null;
    }
    get onopen() {
      return null;
    }
    get onmessage() {
      return null;
    }
    get protocol() {
      return this._protocol;
    }
    get readyState() {
      return this._readyState;
    }
    get url() {
      return this._url;
    }
    setSocket(socket, head, options2) {
      const receiver = new Receiver({
        allowSynchronousEvents: options2.allowSynchronousEvents,
        binaryType: this.binaryType,
        extensions: this._extensions,
        isServer: this._isServer,
        maxPayload: options2.maxPayload,
        skipUTF8Validation: options2.skipUTF8Validation
      });
      const sender = new Sender(socket, this._extensions, options2.generateMask);
      this._receiver = receiver;
      this._sender = sender;
      this._socket = socket;
      receiver[kWebSocket] = this;
      sender[kWebSocket] = this;
      socket[kWebSocket] = this;
      receiver.on("conclude", receiverOnConclude);
      receiver.on("drain", receiverOnDrain);
      receiver.on("error", receiverOnError);
      receiver.on("message", receiverOnMessage);
      receiver.on("ping", receiverOnPing);
      receiver.on("pong", receiverOnPong);
      sender.onerror = senderOnError;
      if (socket.setTimeout)
        socket.setTimeout(0);
      if (socket.setNoDelay)
        socket.setNoDelay();
      if (head.length > 0)
        socket.unshift(head);
      socket.on("close", socketOnClose);
      socket.on("data", socketOnData);
      socket.on("end", socketOnEnd);
      socket.on("error", socketOnError);
      this._readyState = WebSocket.OPEN;
      this.emit("open");
    }
    emitClose() {
      if (!this._socket) {
        this._readyState = WebSocket.CLOSED;
        this.emit("close", this._closeCode, this._closeMessage);
        return;
      }
      if (this._extensions[PerMessageDeflate.extensionName]) {
        this._extensions[PerMessageDeflate.extensionName].cleanup();
      }
      this._receiver.removeAllListeners();
      this._readyState = WebSocket.CLOSED;
      this.emit("close", this._closeCode, this._closeMessage);
    }
    close(code, data) {
      if (this.readyState === WebSocket.CLOSED)
        return;
      if (this.readyState === WebSocket.CONNECTING) {
        const msg = "WebSocket was closed before the connection was established";
        abortHandshake(this, this._req, msg);
        return;
      }
      if (this.readyState === WebSocket.CLOSING) {
        if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {
          this._socket.end();
        }
        return;
      }
      this._readyState = WebSocket.CLOSING;
      this._sender.close(code, data, !this._isServer, (err) => {
        if (err)
          return;
        this._closeFrameSent = true;
        if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {
          this._socket.end();
        }
      });
      setCloseTimer(this);
    }
    pause() {
      if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {
        return;
      }
      this._paused = true;
      this._socket.pause();
    }
    ping(data, mask, cb) {
      if (this.readyState === WebSocket.CONNECTING) {
        throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
      }
      if (typeof data === "function") {
        cb = data;
        data = mask = undefined;
      } else if (typeof mask === "function") {
        cb = mask;
        mask = undefined;
      }
      if (typeof data === "number")
        data = data.toString();
      if (this.readyState !== WebSocket.OPEN) {
        sendAfterClose(this, data, cb);
        return;
      }
      if (mask === undefined)
        mask = !this._isServer;
      this._sender.ping(data || EMPTY_BUFFER, mask, cb);
    }
    pong(data, mask, cb) {
      if (this.readyState === WebSocket.CONNECTING) {
        throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
      }
      if (typeof data === "function") {
        cb = data;
        data = mask = undefined;
      } else if (typeof mask === "function") {
        cb = mask;
        mask = undefined;
      }
      if (typeof data === "number")
        data = data.toString();
      if (this.readyState !== WebSocket.OPEN) {
        sendAfterClose(this, data, cb);
        return;
      }
      if (mask === undefined)
        mask = !this._isServer;
      this._sender.pong(data || EMPTY_BUFFER, mask, cb);
    }
    resume() {
      if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {
        return;
      }
      this._paused = false;
      if (!this._receiver._writableState.needDrain)
        this._socket.resume();
    }
    send(data, options2, cb) {
      if (this.readyState === WebSocket.CONNECTING) {
        throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
      }
      if (typeof options2 === "function") {
        cb = options2;
        options2 = {};
      }
      if (typeof data === "number")
        data = data.toString();
      if (this.readyState !== WebSocket.OPEN) {
        sendAfterClose(this, data, cb);
        return;
      }
      const opts = {
        binary: typeof data !== "string",
        mask: !this._isServer,
        compress: true,
        fin: true,
        ...options2
      };
      if (!this._extensions[PerMessageDeflate.extensionName]) {
        opts.compress = false;
      }
      this._sender.send(data || EMPTY_BUFFER, opts, cb);
    }
    terminate() {
      if (this.readyState === WebSocket.CLOSED)
        return;
      if (this.readyState === WebSocket.CONNECTING) {
        const msg = "WebSocket was closed before the connection was established";
        abortHandshake(this, this._req, msg);
        return;
      }
      if (this._socket) {
        this._readyState = WebSocket.CLOSING;
        this._socket.destroy();
      }
    }
  }
  Object.defineProperty(WebSocket, "CONNECTING", {
    enumerable: true,
    value: readyStates.indexOf("CONNECTING")
  });
  Object.defineProperty(WebSocket.prototype, "CONNECTING", {
    enumerable: true,
    value: readyStates.indexOf("CONNECTING")
  });
  Object.defineProperty(WebSocket, "OPEN", {
    enumerable: true,
    value: readyStates.indexOf("OPEN")
  });
  Object.defineProperty(WebSocket.prototype, "OPEN", {
    enumerable: true,
    value: readyStates.indexOf("OPEN")
  });
  Object.defineProperty(WebSocket, "CLOSING", {
    enumerable: true,
    value: readyStates.indexOf("CLOSING")
  });
  Object.defineProperty(WebSocket.prototype, "CLOSING", {
    enumerable: true,
    value: readyStates.indexOf("CLOSING")
  });
  Object.defineProperty(WebSocket, "CLOSED", {
    enumerable: true,
    value: readyStates.indexOf("CLOSED")
  });
  Object.defineProperty(WebSocket.prototype, "CLOSED", {
    enumerable: true,
    value: readyStates.indexOf("CLOSED")
  });
  [
    "binaryType",
    "bufferedAmount",
    "extensions",
    "isPaused",
    "protocol",
    "readyState",
    "url"
  ].forEach((property) => {
    Object.defineProperty(WebSocket.prototype, property, { enumerable: true });
  });
  ["open", "error", "close", "message"].forEach((method) => {
    Object.defineProperty(WebSocket.prototype, `on${method}`, {
      enumerable: true,
      get() {
        for (const listener of this.listeners(method)) {
          if (listener[kForOnEventAttribute])
            return listener[kListener];
        }
        return null;
      },
      set(handler) {
        for (const listener of this.listeners(method)) {
          if (listener[kForOnEventAttribute]) {
            this.removeListener(method, listener);
            break;
          }
        }
        if (typeof handler !== "function")
          return;
        this.addEventListener(method, handler, {
          [kForOnEventAttribute]: true
        });
      }
    });
  });
  WebSocket.prototype.addEventListener = addEventListener;
  WebSocket.prototype.removeEventListener = removeEventListener;
  module.exports = WebSocket;
  function initAsClient(websocket, address3, protocols, options2) {
    const opts = {
      allowSynchronousEvents: true,
      autoPong: true,
      protocolVersion: protocolVersions[1],
      maxPayload: 100 * 1024 * 1024,
      skipUTF8Validation: false,
      perMessageDeflate: true,
      followRedirects: false,
      maxRedirects: 10,
      ...options2,
      socketPath: undefined,
      hostname: undefined,
      protocol: undefined,
      timeout: undefined,
      method: "GET",
      host: undefined,
      path: undefined,
      port: undefined
    };
    websocket._autoPong = opts.autoPong;
    if (!protocolVersions.includes(opts.protocolVersion)) {
      throw new RangeError(`Unsupported protocol version: ${opts.protocolVersion} ` + `(supported versions: ${protocolVersions.join(", ")})`);
    }
    let parsedUrl;
    if (address3 instanceof URL2) {
      parsedUrl = address3;
    } else {
      try {
        parsedUrl = new URL2(address3);
      } catch (e6) {
        throw new SyntaxError(`Invalid URL: ${address3}`);
      }
    }
    if (parsedUrl.protocol === "http:") {
      parsedUrl.protocol = "ws:";
    } else if (parsedUrl.protocol === "https:") {
      parsedUrl.protocol = "wss:";
    }
    websocket._url = parsedUrl.href;
    const isSecure = parsedUrl.protocol === "wss:";
    const isIpcUrl = parsedUrl.protocol === "ws+unix:";
    let invalidUrlMessage;
    if (parsedUrl.protocol !== "ws:" && !isSecure && !isIpcUrl) {
      invalidUrlMessage = `The URL's protocol must be one of "ws:", "wss:", ` + '"http:", "https:", or "ws+unix:"';
    } else if (isIpcUrl && !parsedUrl.pathname) {
      invalidUrlMessage = "The URL's pathname is empty";
    } else if (parsedUrl.hash) {
      invalidUrlMessage = "The URL contains a fragment identifier";
    }
    if (invalidUrlMessage) {
      const err = new SyntaxError(invalidUrlMessage);
      if (websocket._redirects === 0) {
        throw err;
      } else {
        emitErrorAndClose(websocket, err);
        return;
      }
    }
    const defaultPort = isSecure ? 443 : 80;
    const key = randomBytes(16).toString("base64");
    const request = isSecure ? https.request : http.request;
    const protocolSet = new Set;
    let perMessageDeflate;
    opts.createConnection = opts.createConnection || (isSecure ? tlsConnect : netConnect);
    opts.defaultPort = opts.defaultPort || defaultPort;
    opts.port = parsedUrl.port || defaultPort;
    opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
    opts.headers = {
      ...opts.headers,
      "Sec-WebSocket-Version": opts.protocolVersion,
      "Sec-WebSocket-Key": key,
      Connection: "Upgrade",
      Upgrade: "websocket"
    };
    opts.path = parsedUrl.pathname + parsedUrl.search;
    opts.timeout = opts.handshakeTimeout;
    if (opts.perMessageDeflate) {
      perMessageDeflate = new PerMessageDeflate(opts.perMessageDeflate !== true ? opts.perMessageDeflate : {}, false, opts.maxPayload);
      opts.headers["Sec-WebSocket-Extensions"] = format({
        [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
      });
    }
    if (protocols.length) {
      for (const protocol of protocols) {
        if (typeof protocol !== "string" || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) {
          throw new SyntaxError("An invalid or duplicated subprotocol was specified");
        }
        protocolSet.add(protocol);
      }
      opts.headers["Sec-WebSocket-Protocol"] = protocols.join(",");
    }
    if (opts.origin) {
      if (opts.protocolVersion < 13) {
        opts.headers["Sec-WebSocket-Origin"] = opts.origin;
      } else {
        opts.headers.Origin = opts.origin;
      }
    }
    if (parsedUrl.username || parsedUrl.password) {
      opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
    }
    if (isIpcUrl) {
      const parts = opts.path.split(":");
      opts.socketPath = parts[0];
      opts.path = parts[1];
    }
    let req;
    if (opts.followRedirects) {
      if (websocket._redirects === 0) {
        websocket._originalIpc = isIpcUrl;
        websocket._originalSecure = isSecure;
        websocket._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;
        const headers = options2 && options2.headers;
        options2 = { ...options2, headers: {} };
        if (headers) {
          for (const [key2, value] of Object.entries(headers)) {
            options2.headers[key2.toLowerCase()] = value;
          }
        }
      } else if (websocket.listenerCount("redirect") === 0) {
        const isSameHost = isIpcUrl ? websocket._originalIpc ? opts.socketPath === websocket._originalHostOrSocketPath : false : websocket._originalIpc ? false : parsedUrl.host === websocket._originalHostOrSocketPath;
        if (!isSameHost || websocket._originalSecure && !isSecure) {
          delete opts.headers.authorization;
          delete opts.headers.cookie;
          if (!isSameHost)
            delete opts.headers.host;
          opts.auth = undefined;
        }
      }
      if (opts.auth && !options2.headers.authorization) {
        options2.headers.authorization = "Basic " + Buffer.from(opts.auth).toString("base64");
      }
      req = websocket._req = request(opts);
      if (websocket._redirects) {
        websocket.emit("redirect", websocket.url, req);
      }
    } else {
      req = websocket._req = request(opts);
    }
    if (opts.timeout) {
      req.on("timeout", () => {
        abortHandshake(websocket, req, "Opening handshake has timed out");
      });
    }
    req.on("error", (err) => {
      if (req === null || req[kAborted])
        return;
      req = websocket._req = null;
      emitErrorAndClose(websocket, err);
    });
    req.on("response", (res) => {
      const location = res.headers.location;
      const statusCode = res.statusCode;
      if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
        if (++websocket._redirects > opts.maxRedirects) {
          abortHandshake(websocket, req, "Maximum redirects exceeded");
          return;
        }
        req.abort();
        let addr;
        try {
          addr = new URL2(location, address3);
        } catch (e6) {
          const err = new SyntaxError(`Invalid URL: ${location}`);
          emitErrorAndClose(websocket, err);
          return;
        }
        initAsClient(websocket, addr, protocols, options2);
      } else if (!websocket.emit("unexpected-response", req, res)) {
        abortHandshake(websocket, req, `Unexpected server response: ${res.statusCode}`);
      }
    });
    req.on("upgrade", (res, socket, head) => {
      websocket.emit("upgrade", res);
      if (websocket.readyState !== WebSocket.CONNECTING)
        return;
      req = websocket._req = null;
      const upgrade = res.headers.upgrade;
      if (upgrade === undefined || upgrade.toLowerCase() !== "websocket") {
        abortHandshake(websocket, socket, "Invalid Upgrade header");
        return;
      }
      const digest = createHash("sha1").update(key + GUID).digest("base64");
      if (res.headers["sec-websocket-accept"] !== digest) {
        abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Accept header");
        return;
      }
      const serverProt = res.headers["sec-websocket-protocol"];
      let protError;
      if (serverProt !== undefined) {
        if (!protocolSet.size) {
          protError = "Server sent a subprotocol but none was requested";
        } else if (!protocolSet.has(serverProt)) {
          protError = "Server sent an invalid subprotocol";
        }
      } else if (protocolSet.size) {
        protError = "Server sent no subprotocol";
      }
      if (protError) {
        abortHandshake(websocket, socket, protError);
        return;
      }
      if (serverProt)
        websocket._protocol = serverProt;
      const secWebSocketExtensions = res.headers["sec-websocket-extensions"];
      if (secWebSocketExtensions !== undefined) {
        if (!perMessageDeflate) {
          const message = "Server sent a Sec-WebSocket-Extensions header but no extension " + "was requested";
          abortHandshake(websocket, socket, message);
          return;
        }
        let extensions;
        try {
          extensions = parse(secWebSocketExtensions);
        } catch (err) {
          const message = "Invalid Sec-WebSocket-Extensions header";
          abortHandshake(websocket, socket, message);
          return;
        }
        const extensionNames = Object.keys(extensions);
        if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {
          const message = "Server indicated an extension that was not requested";
          abortHandshake(websocket, socket, message);
          return;
        }
        try {
          perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
        } catch (err) {
          const message = "Invalid Sec-WebSocket-Extensions header";
          abortHandshake(websocket, socket, message);
          return;
        }
        websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
      }
      websocket.setSocket(socket, head, {
        allowSynchronousEvents: opts.allowSynchronousEvents,
        generateMask: opts.generateMask,
        maxPayload: opts.maxPayload,
        skipUTF8Validation: opts.skipUTF8Validation
      });
    });
    if (opts.finishRequest) {
      opts.finishRequest(req, websocket);
    } else {
      req.end();
    }
  }
  function emitErrorAndClose(websocket, err) {
    websocket._readyState = WebSocket.CLOSING;
    websocket._errorEmitted = true;
    websocket.emit("error", err);
    websocket.emitClose();
  }
  function netConnect(options2) {
    options2.path = options2.socketPath;
    return net.connect(options2);
  }
  function tlsConnect(options2) {
    options2.path = undefined;
    if (!options2.servername && options2.servername !== "") {
      options2.servername = net.isIP(options2.host) ? "" : options2.host;
    }
    return tls.connect(options2);
  }
  function abortHandshake(websocket, stream, message) {
    websocket._readyState = WebSocket.CLOSING;
    const err = new Error(message);
    Error.captureStackTrace(err, abortHandshake);
    if (stream.setHeader) {
      stream[kAborted] = true;
      stream.abort();
      if (stream.socket && !stream.socket.destroyed) {
        stream.socket.destroy();
      }
      process.nextTick(emitErrorAndClose, websocket, err);
    } else {
      stream.destroy(err);
      stream.once("error", websocket.emit.bind(websocket, "error"));
      stream.once("close", websocket.emitClose.bind(websocket));
    }
  }
  function sendAfterClose(websocket, data, cb) {
    if (data) {
      const length = isBlob(data) ? data.size : toBuffer(data).length;
      if (websocket._socket)
        websocket._sender._bufferedBytes += length;
      else
        websocket._bufferedAmount += length;
    }
    if (cb) {
      const err = new Error(`WebSocket is not open: readyState ${websocket.readyState} ` + `(${readyStates[websocket.readyState]})`);
      process.nextTick(cb, err);
    }
  }
  function receiverOnConclude(code, reason) {
    const websocket = this[kWebSocket];
    websocket._closeFrameReceived = true;
    websocket._closeMessage = reason;
    websocket._closeCode = code;
    if (websocket._socket[kWebSocket] === undefined)
      return;
    websocket._socket.removeListener("data", socketOnData);
    process.nextTick(resume, websocket._socket);
    if (code === 1005)
      websocket.close();
    else
      websocket.close(code, reason);
  }
  function receiverOnDrain() {
    const websocket = this[kWebSocket];
    if (!websocket.isPaused)
      websocket._socket.resume();
  }
  function receiverOnError(err) {
    const websocket = this[kWebSocket];
    if (websocket._socket[kWebSocket] !== undefined) {
      websocket._socket.removeListener("data", socketOnData);
      process.nextTick(resume, websocket._socket);
      websocket.close(err[kStatusCode]);
    }
    if (!websocket._errorEmitted) {
      websocket._errorEmitted = true;
      websocket.emit("error", err);
    }
  }
  function receiverOnFinish() {
    this[kWebSocket].emitClose();
  }
  function receiverOnMessage(data, isBinary) {
    this[kWebSocket].emit("message", data, isBinary);
  }
  function receiverOnPing(data) {
    const websocket = this[kWebSocket];
    if (websocket._autoPong)
      websocket.pong(data, !this._isServer, NOOP);
    websocket.emit("ping", data);
  }
  function receiverOnPong(data) {
    this[kWebSocket].emit("pong", data);
  }
  function resume(stream) {
    stream.resume();
  }
  function senderOnError(err) {
    const websocket = this[kWebSocket];
    if (websocket.readyState === WebSocket.CLOSED)
      return;
    if (websocket.readyState === WebSocket.OPEN) {
      websocket._readyState = WebSocket.CLOSING;
      setCloseTimer(websocket);
    }
    this._socket.end();
    if (!websocket._errorEmitted) {
      websocket._errorEmitted = true;
      websocket.emit("error", err);
    }
  }
  function setCloseTimer(websocket) {
    websocket._closeTimer = setTimeout(websocket._socket.destroy.bind(websocket._socket), closeTimeout);
  }
  function socketOnClose() {
    const websocket = this[kWebSocket];
    this.removeListener("close", socketOnClose);
    this.removeListener("data", socketOnData);
    this.removeListener("end", socketOnEnd);
    websocket._readyState = WebSocket.CLOSING;
    let chunk;
    if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk = websocket._socket.read()) !== null) {
      websocket._receiver.write(chunk);
    }
    websocket._receiver.end();
    this[kWebSocket] = undefined;
    clearTimeout(websocket._closeTimer);
    if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {
      websocket.emitClose();
    } else {
      websocket._receiver.on("error", receiverOnFinish);
      websocket._receiver.on("finish", receiverOnFinish);
    }
  }
  function socketOnData(chunk) {
    if (!this[kWebSocket]._receiver.write(chunk)) {
      this.pause();
    }
  }
  function socketOnEnd() {
    const websocket = this[kWebSocket];
    websocket._readyState = WebSocket.CLOSING;
    websocket._receiver.end();
    this.end();
  }
  function socketOnError() {
    const websocket = this[kWebSocket];
    this.removeListener("error", socketOnError);
    this.on("error", NOOP);
    if (websocket) {
      websocket._readyState = WebSocket.CLOSING;
      this.destroy();
    }
  }
});

// ../../node_modules/.bun/ws@8.18.3+4789783d1fa00420/node_modules/ws/lib/stream.js
var require_stream = __commonJS((exports, module) => {
  var WebSocket = require_websocket();
  var { Duplex } = __require("stream");
  function emitClose(stream) {
    stream.emit("close");
  }
  function duplexOnEnd() {
    if (!this.destroyed && this._writableState.finished) {
      this.destroy();
    }
  }
  function duplexOnError(err) {
    this.removeListener("error", duplexOnError);
    this.destroy();
    if (this.listenerCount("error") === 0) {
      this.emit("error", err);
    }
  }
  function createWebSocketStream(ws, options2) {
    let terminateOnDestroy = true;
    const duplex = new Duplex({
      ...options2,
      autoDestroy: false,
      emitClose: false,
      objectMode: false,
      writableObjectMode: false
    });
    ws.on("message", function message(msg, isBinary) {
      const data = !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;
      if (!duplex.push(data))
        ws.pause();
    });
    ws.once("error", function error(err) {
      if (duplex.destroyed)
        return;
      terminateOnDestroy = false;
      duplex.destroy(err);
    });
    ws.once("close", function close() {
      if (duplex.destroyed)
        return;
      duplex.push(null);
    });
    duplex._destroy = function(err, callback) {
      if (ws.readyState === ws.CLOSED) {
        callback(err);
        process.nextTick(emitClose, duplex);
        return;
      }
      let called = false;
      ws.once("error", function error(err2) {
        called = true;
        callback(err2);
      });
      ws.once("close", function close() {
        if (!called)
          callback(err);
        process.nextTick(emitClose, duplex);
      });
      if (terminateOnDestroy)
        ws.terminate();
    };
    duplex._final = function(callback) {
      if (ws.readyState === ws.CONNECTING) {
        ws.once("open", function open() {
          duplex._final(callback);
        });
        return;
      }
      if (ws._socket === null)
        return;
      if (ws._socket._writableState.finished) {
        callback();
        if (duplex._readableState.endEmitted)
          duplex.destroy();
      } else {
        ws._socket.once("finish", function finish() {
          callback();
        });
        ws.close();
      }
    };
    duplex._read = function() {
      if (ws.isPaused)
        ws.resume();
    };
    duplex._write = function(chunk, encoding, callback) {
      if (ws.readyState === ws.CONNECTING) {
        ws.once("open", function open() {
          duplex._write(chunk, encoding, callback);
        });
        return;
      }
      ws.send(chunk, callback);
    };
    duplex.on("end", duplexOnEnd);
    duplex.on("error", duplexOnError);
    return duplex;
  }
  module.exports = createWebSocketStream;
});

// ../../node_modules/.bun/ws@8.18.3+4789783d1fa00420/node_modules/ws/lib/subprotocol.js
var require_subprotocol = __commonJS((exports, module) => {
  var { tokenChars } = require_validation();
  function parse(header) {
    const protocols = new Set;
    let start = -1;
    let end = -1;
    let i = 0;
    for (i;i < header.length; i++) {
      const code = header.charCodeAt(i);
      if (end === -1 && tokenChars[code] === 1) {
        if (start === -1)
          start = i;
      } else if (i !== 0 && (code === 32 || code === 9)) {
        if (end === -1 && start !== -1)
          end = i;
      } else if (code === 44) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
        if (end === -1)
          end = i;
        const protocol2 = header.slice(start, end);
        if (protocols.has(protocol2)) {
          throw new SyntaxError(`The "${protocol2}" subprotocol is duplicated`);
        }
        protocols.add(protocol2);
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    }
    if (start === -1 || end !== -1) {
      throw new SyntaxError("Unexpected end of input");
    }
    const protocol = header.slice(start, i);
    if (protocols.has(protocol)) {
      throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
    }
    protocols.add(protocol);
    return protocols;
  }
  module.exports = { parse };
});

// ../../node_modules/.bun/ws@8.18.3+4789783d1fa00420/node_modules/ws/lib/websocket-server.js
var require_websocket_server = __commonJS((exports, module) => {
  var EventEmitter = __require("events");
  var http = __require("http");
  var { Duplex } = __require("stream");
  var { createHash } = __require("crypto");
  var extension = require_extension();
  var PerMessageDeflate = require_permessage_deflate();
  var subprotocol = require_subprotocol();
  var WebSocket = require_websocket();
  var { GUID, kWebSocket } = require_constants();
  var keyRegex = /^[+/0-9A-Za-z]{22}==$/;
  var RUNNING = 0;
  var CLOSING = 1;
  var CLOSED = 2;

  class WebSocketServer extends EventEmitter {
    constructor(options2, callback) {
      super();
      options2 = {
        allowSynchronousEvents: true,
        autoPong: true,
        maxPayload: 100 * 1024 * 1024,
        skipUTF8Validation: false,
        perMessageDeflate: false,
        handleProtocols: null,
        clientTracking: true,
        verifyClient: null,
        noServer: false,
        backlog: null,
        server: null,
        host: null,
        path: null,
        port: null,
        WebSocket,
        ...options2
      };
      if (options2.port == null && !options2.server && !options2.noServer || options2.port != null && (options2.server || options2.noServer) || options2.server && options2.noServer) {
        throw new TypeError('One and only one of the "port", "server", or "noServer" options ' + "must be specified");
      }
      if (options2.port != null) {
        this._server = http.createServer((req, res) => {
          const body = http.STATUS_CODES[426];
          res.writeHead(426, {
            "Content-Length": body.length,
            "Content-Type": "text/plain"
          });
          res.end(body);
        });
        this._server.listen(options2.port, options2.host, options2.backlog, callback);
      } else if (options2.server) {
        this._server = options2.server;
      }
      if (this._server) {
        const emitConnection = this.emit.bind(this, "connection");
        this._removeListeners = addListeners(this._server, {
          listening: this.emit.bind(this, "listening"),
          error: this.emit.bind(this, "error"),
          upgrade: (req, socket, head) => {
            this.handleUpgrade(req, socket, head, emitConnection);
          }
        });
      }
      if (options2.perMessageDeflate === true)
        options2.perMessageDeflate = {};
      if (options2.clientTracking) {
        this.clients = new Set;
        this._shouldEmitClose = false;
      }
      this.options = options2;
      this._state = RUNNING;
    }
    address() {
      if (this.options.noServer) {
        throw new Error('The server is operating in "noServer" mode');
      }
      if (!this._server)
        return null;
      return this._server.address();
    }
    close(cb) {
      if (this._state === CLOSED) {
        if (cb) {
          this.once("close", () => {
            cb(new Error("The server is not running"));
          });
        }
        process.nextTick(emitClose, this);
        return;
      }
      if (cb)
        this.once("close", cb);
      if (this._state === CLOSING)
        return;
      this._state = CLOSING;
      if (this.options.noServer || this.options.server) {
        if (this._server) {
          this._removeListeners();
          this._removeListeners = this._server = null;
        }
        if (this.clients) {
          if (!this.clients.size) {
            process.nextTick(emitClose, this);
          } else {
            this._shouldEmitClose = true;
          }
        } else {
          process.nextTick(emitClose, this);
        }
      } else {
        const server = this._server;
        this._removeListeners();
        this._removeListeners = this._server = null;
        server.close(() => {
          emitClose(this);
        });
      }
    }
    shouldHandle(req) {
      if (this.options.path) {
        const index = req.url.indexOf("?");
        const pathname = index !== -1 ? req.url.slice(0, index) : req.url;
        if (pathname !== this.options.path)
          return false;
      }
      return true;
    }
    handleUpgrade(req, socket, head, cb) {
      socket.on("error", socketOnError);
      const key = req.headers["sec-websocket-key"];
      const upgrade = req.headers.upgrade;
      const version = +req.headers["sec-websocket-version"];
      if (req.method !== "GET") {
        const message = "Invalid HTTP method";
        abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);
        return;
      }
      if (upgrade === undefined || upgrade.toLowerCase() !== "websocket") {
        const message = "Invalid Upgrade header";
        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
        return;
      }
      if (key === undefined || !keyRegex.test(key)) {
        const message = "Missing or invalid Sec-WebSocket-Key header";
        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
        return;
      }
      if (version !== 13 && version !== 8) {
        const message = "Missing or invalid Sec-WebSocket-Version header";
        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message, {
          "Sec-WebSocket-Version": "13, 8"
        });
        return;
      }
      if (!this.shouldHandle(req)) {
        abortHandshake(socket, 400);
        return;
      }
      const secWebSocketProtocol = req.headers["sec-websocket-protocol"];
      let protocols = new Set;
      if (secWebSocketProtocol !== undefined) {
        try {
          protocols = subprotocol.parse(secWebSocketProtocol);
        } catch (err) {
          const message = "Invalid Sec-WebSocket-Protocol header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
      }
      const secWebSocketExtensions = req.headers["sec-websocket-extensions"];
      const extensions = {};
      if (this.options.perMessageDeflate && secWebSocketExtensions !== undefined) {
        const perMessageDeflate = new PerMessageDeflate(this.options.perMessageDeflate, true, this.options.maxPayload);
        try {
          const offers = extension.parse(secWebSocketExtensions);
          if (offers[PerMessageDeflate.extensionName]) {
            perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
            extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
          }
        } catch (err) {
          const message = "Invalid or unacceptable Sec-WebSocket-Extensions header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
      }
      if (this.options.verifyClient) {
        const info = {
          origin: req.headers[`${version === 8 ? "sec-websocket-origin" : "origin"}`],
          secure: !!(req.socket.authorized || req.socket.encrypted),
          req
        };
        if (this.options.verifyClient.length === 2) {
          this.options.verifyClient(info, (verified, code, message, headers) => {
            if (!verified) {
              return abortHandshake(socket, code || 401, message, headers);
            }
            this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
          });
          return;
        }
        if (!this.options.verifyClient(info))
          return abortHandshake(socket, 401);
      }
      this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
    }
    completeUpgrade(extensions, key, protocols, req, socket, head, cb) {
      if (!socket.readable || !socket.writable)
        return socket.destroy();
      if (socket[kWebSocket]) {
        throw new Error("server.handleUpgrade() was called more than once with the same " + "socket, possibly due to a misconfiguration");
      }
      if (this._state > RUNNING)
        return abortHandshake(socket, 503);
      const digest = createHash("sha1").update(key + GUID).digest("base64");
      const headers = [
        "HTTP/1.1 101 Switching Protocols",
        "Upgrade: websocket",
        "Connection: Upgrade",
        `Sec-WebSocket-Accept: ${digest}`
      ];
      const ws = new this.options.WebSocket(null, undefined, this.options);
      if (protocols.size) {
        const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;
        if (protocol) {
          headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
          ws._protocol = protocol;
        }
      }
      if (extensions[PerMessageDeflate.extensionName]) {
        const params = extensions[PerMessageDeflate.extensionName].params;
        const value = extension.format({
          [PerMessageDeflate.extensionName]: [params]
        });
        headers.push(`Sec-WebSocket-Extensions: ${value}`);
        ws._extensions = extensions;
      }
      this.emit("headers", headers, req);
      socket.write(headers.concat(`\r
`).join(`\r
`));
      socket.removeListener("error", socketOnError);
      ws.setSocket(socket, head, {
        allowSynchronousEvents: this.options.allowSynchronousEvents,
        maxPayload: this.options.maxPayload,
        skipUTF8Validation: this.options.skipUTF8Validation
      });
      if (this.clients) {
        this.clients.add(ws);
        ws.on("close", () => {
          this.clients.delete(ws);
          if (this._shouldEmitClose && !this.clients.size) {
            process.nextTick(emitClose, this);
          }
        });
      }
      cb(ws, req);
    }
  }
  module.exports = WebSocketServer;
  function addListeners(server, map) {
    for (const event of Object.keys(map))
      server.on(event, map[event]);
    return function removeListeners() {
      for (const event of Object.keys(map)) {
        server.removeListener(event, map[event]);
      }
    };
  }
  function emitClose(server) {
    server._state = CLOSED;
    server.emit("close");
  }
  function socketOnError() {
    this.destroy();
  }
  function abortHandshake(socket, code, message, headers) {
    message = message || http.STATUS_CODES[code];
    headers = {
      Connection: "close",
      "Content-Type": "text/html",
      "Content-Length": Buffer.byteLength(message),
      ...headers
    };
    socket.once("finish", socket.destroy);
    socket.end(`HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\r
` + Object.keys(headers).map((h) => `${h}: ${headers[h]}`).join(`\r
`) + `\r
\r
` + message);
  }
  function abortHandshakeOrEmitwsClientError(server, req, socket, code, message, headers) {
    if (server.listenerCount("wsClientError")) {
      const err = new Error(message);
      Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);
      server.emit("wsClientError", err, socket, req);
    } else {
      abortHandshake(socket, code, message, headers);
    }
  }
});

// ../../node_modules/.bun/ws@8.18.3+4789783d1fa00420/node_modules/ws/wrapper.mjs
var import_stream, import_receiver, import_sender, import_websocket, import_websocket_server, wrapper_default;
var init_wrapper = __esm(() => {
  import_stream = __toESM(require_stream(), 1);
  import_receiver = __toESM(require_receiver(), 1);
  import_sender = __toESM(require_sender(), 1);
  import_websocket = __toESM(require_websocket(), 1);
  import_websocket_server = __toESM(require_websocket_server(), 1);
  wrapper_default = import_websocket.default;
});

// ../../node_modules/.bun/@solana+rpc-subscriptions-channel-websocket@5.1.0+01c1f2a48c7bfde6/node_modules/@solana/rpc-subscriptions-channel-websocket/dist/index.node.mjs
import { setMaxListeners as setMaxListeners4 } from "events";
function createWebSocketChannel({
  sendBufferHighWatermark,
  signal,
  url
}) {
  if (signal.aborted) {
    return Promise.reject(signal.reason);
  }
  let bufferDrainWatcher;
  let hasConnected = false;
  const listenerRemovers = /* @__PURE__ */ new Set;
  function cleanupListeners() {
    listenerRemovers.forEach((r) => {
      r();
    });
    listenerRemovers.clear();
  }
  function handleAbort() {
    cleanupListeners();
    if (!hasConnected) {
      rejectOpen(signal.reason);
    }
    if (webSocket.readyState !== l.CLOSED && webSocket.readyState !== l.CLOSING) {
      webSocket.close(NORMAL_CLOSURE_CODE);
    }
  }
  function handleClose(ev) {
    cleanupListeners();
    bufferDrainWatcher?.onCancel();
    signal.removeEventListener("abort", handleAbort);
    webSocket.removeEventListener("close", handleClose);
    webSocket.removeEventListener("error", handleError);
    webSocket.removeEventListener("message", handleMessage);
    webSocket.removeEventListener("open", handleOpen);
    if (!signal.aborted && !(ev.wasClean && ev.code === NORMAL_CLOSURE_CODE)) {
      eventTarget.dispatchEvent(new CustomEvent("error", {
        detail: new SolanaError2(SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED2, {
          cause: ev
        })
      }));
    }
  }
  function handleError(ev) {
    if (signal.aborted) {
      return;
    }
    if (!hasConnected) {
      const failedToConnectError = new SolanaError2(SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT2, {
        errorEvent: ev
      });
      rejectOpen(failedToConnectError);
      eventTarget.dispatchEvent(new CustomEvent("error", {
        detail: failedToConnectError
      }));
    }
  }
  function handleMessage(ev) {
    if (signal.aborted) {
      return;
    }
    eventTarget.dispatchEvent(new CustomEvent("message", { detail: ev.data }));
  }
  const eventTarget = new s2;
  const dataPublisher = getDataPublisherFromEventEmitter(eventTarget);
  function handleOpen() {
    hasConnected = true;
    resolveOpen({
      ...dataPublisher,
      async send(message) {
        if (webSocket.readyState !== l.OPEN) {
          throw new SolanaError2(SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED2);
        }
        if (!bufferDrainWatcher && webSocket.bufferedAmount > sendBufferHighWatermark) {
          let onCancel;
          const promise = new Promise((resolve, reject) => {
            const intervalId = setInterval(() => {
              if (webSocket.readyState !== l.OPEN || !(webSocket.bufferedAmount > sendBufferHighWatermark)) {
                clearInterval(intervalId);
                bufferDrainWatcher = undefined;
                resolve();
              }
            }, 16);
            onCancel = () => {
              bufferDrainWatcher = undefined;
              clearInterval(intervalId);
              reject(new SolanaError2(SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED2));
            };
          });
          bufferDrainWatcher = {
            onCancel,
            promise
          };
        }
        if (bufferDrainWatcher) {
          if (ArrayBuffer.isView(message) && !(message instanceof DataView)) {
            const TypedArrayConstructor = message.constructor;
            message = new TypedArrayConstructor(message);
          }
          await bufferDrainWatcher.promise;
        }
        webSocket.send(message);
      }
    });
  }
  const webSocket = new l(url);
  signal.addEventListener("abort", handleAbort);
  webSocket.addEventListener("close", handleClose);
  webSocket.addEventListener("error", handleError);
  webSocket.addEventListener("message", handleMessage);
  webSocket.addEventListener("open", handleOpen);
  let rejectOpen;
  let resolveOpen;
  return new Promise((resolve, reject) => {
    rejectOpen = reject;
    resolveOpen = resolve;
  });
}
var s2, l, NORMAL_CLOSURE_CODE = 1000;
var init_index_node36 = __esm(() => {
  init_index_node6();
  init_index_node33();
  init_wrapper();
  s2 = class extends globalThis.EventTarget {
    constructor(...t) {
      super(...t), setMaxListeners4(Number.MAX_SAFE_INTEGER, this);
    }
  };
  l = globalThis.WebSocket ? globalThis.WebSocket : wrapper_default;
});

// ../../node_modules/.bun/@solana+rpc-subscriptions@5.1.0+b7f519a64bbf2dd5/node_modules/@solana/rpc-subscriptions/dist/index.node.mjs
import { setMaxListeners as setMaxListeners5 } from "events";
function createSolanaJsonRpcIntegerOverflowError2(methodName, keyPath, value) {
  let argumentLabel = "";
  if (typeof keyPath[0] === "number") {
    const argPosition = keyPath[0] + 1;
    const lastDigit = argPosition % 10;
    const lastTwoDigits = argPosition % 100;
    if (lastDigit == 1 && lastTwoDigits != 11) {
      argumentLabel = argPosition + "st";
    } else if (lastDigit == 2 && lastTwoDigits != 12) {
      argumentLabel = argPosition + "nd";
    } else if (lastDigit == 3 && lastTwoDigits != 13) {
      argumentLabel = argPosition + "rd";
    } else {
      argumentLabel = argPosition + "th";
    }
  } else {
    argumentLabel = `\`${keyPath[0].toString()}\``;
  }
  const path = keyPath.length > 1 ? keyPath.slice(1).map((pathPart) => typeof pathPart === "number" ? `[${pathPart}]` : pathPart).join(".") : undefined;
  const error = new SolanaError2(SOLANA_ERROR__RPC__INTEGER_OVERFLOW2, {
    argumentLabel,
    keyPath,
    methodName,
    optionalPathLabel: path ? ` at path \`${path}\`` : "",
    value,
    ...path !== undefined ? { path } : undefined
  });
  safeCaptureStackTrace(error, createSolanaJsonRpcIntegerOverflowError2);
  return error;
}
function getRpcSubscriptionsChannelWithAutoping({
  abortSignal: callerAbortSignal,
  channel,
  intervalMs
}) {
  let intervalId;
  function sendPing() {
    channel.send(PING_PAYLOAD).catch((e22) => {
      if (isSolanaError2(e22, SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED2)) {
        pingerAbortController.abort();
      }
    });
  }
  function restartPingTimer() {
    clearInterval(intervalId);
    intervalId = setInterval(sendPing, intervalMs);
  }
  const pingerAbortController = new e6;
  pingerAbortController.signal.addEventListener("abort", () => {
    clearInterval(intervalId);
  });
  callerAbortSignal.addEventListener("abort", () => {
    pingerAbortController.abort();
  });
  channel.on("error", () => {
    pingerAbortController.abort();
  }, { signal: pingerAbortController.signal });
  channel.on("message", restartPingTimer, { signal: pingerAbortController.signal });
  {
    restartPingTimer();
  }
  return {
    ...channel,
    send(...args) {
      if (!pingerAbortController.signal.aborted) {
        restartPingTimer();
      }
      return channel.send(...args);
    }
  };
}
function createChannelPool() {
  return {
    entries: [],
    freeChannelIndex: -1
  };
}
function getChannelPoolingChannelCreator(createChannel, { maxSubscriptionsPerChannel, minChannels }) {
  const pool = createChannelPool();
  function recomputeFreeChannelIndex() {
    if (pool.entries.length < minChannels) {
      pool.freeChannelIndex = -1;
      return;
    }
    let mostFreeChannel;
    for (let ii = 0;ii < pool.entries.length; ii++) {
      const nextPoolIndex = (pool.freeChannelIndex + ii + 2) % pool.entries.length;
      const nextPoolEntry = pool.entries[nextPoolIndex];
      if (nextPoolEntry.subscriptionCount < maxSubscriptionsPerChannel && (!mostFreeChannel || mostFreeChannel.subscriptionCount >= nextPoolEntry.subscriptionCount)) {
        mostFreeChannel = {
          poolIndex: nextPoolIndex,
          subscriptionCount: nextPoolEntry.subscriptionCount
        };
      }
    }
    pool.freeChannelIndex = mostFreeChannel?.poolIndex ?? -1;
  }
  return function getExistingChannelWithMostCapacityOrCreateChannel({ abortSignal }) {
    let poolEntry;
    function destroyPoolEntry() {
      const index = pool.entries.findIndex((entry) => entry === poolEntry);
      pool.entries.splice(index, 1);
      poolEntry.dispose();
      recomputeFreeChannelIndex();
    }
    if (pool.freeChannelIndex === -1) {
      const abortController = new e6;
      const newChannelPromise = createChannel({ abortSignal: abortController.signal });
      newChannelPromise.then((newChannel) => {
        newChannel.on("error", destroyPoolEntry, { signal: abortController.signal });
      }).catch(destroyPoolEntry);
      poolEntry = {
        channel: newChannelPromise,
        dispose() {
          abortController.abort();
        },
        subscriptionCount: 0
      };
      pool.entries.push(poolEntry);
    } else {
      poolEntry = pool.entries[pool.freeChannelIndex];
    }
    poolEntry.subscriptionCount++;
    abortSignal.addEventListener("abort", function destroyConsumer() {
      poolEntry.subscriptionCount--;
      if (poolEntry.subscriptionCount === 0) {
        destroyPoolEntry();
      } else if (pool.freeChannelIndex !== -1) {
        pool.freeChannelIndex--;
        recomputeFreeChannelIndex();
      }
    });
    recomputeFreeChannelIndex();
    return poolEntry.channel;
  };
}
function getRpcSubscriptionsChannelWithJSONSerialization(channel) {
  return pipe(channel, (c) => transformChannelInboundMessages(c, JSON.parse), (c) => transformChannelOutboundMessages(c, JSON.stringify));
}
function getRpcSubscriptionsChannelWithBigIntJSONSerialization(channel) {
  return pipe(channel, (c) => transformChannelInboundMessages(c, parseJsonWithBigInts), (c) => transformChannelOutboundMessages(c, stringifyJsonWithBigInts));
}
function createDefaultSolanaRpcSubscriptionsChannelCreator(config) {
  return createDefaultRpcSubscriptionsChannelCreatorImpl({
    ...config,
    jsonSerializer: getRpcSubscriptionsChannelWithBigIntJSONSerialization
  });
}
function createDefaultRpcSubscriptionsChannelCreator(config) {
  return createDefaultRpcSubscriptionsChannelCreatorImpl({
    ...config,
    jsonSerializer: getRpcSubscriptionsChannelWithJSONSerialization
  });
}
function createDefaultRpcSubscriptionsChannelCreatorImpl(config) {
  if (/^wss?:/i.test(config.url) === false) {
    const protocolMatch = config.url.match(/^([^:]+):/);
    throw new DOMException(protocolMatch ? `Failed to construct 'WebSocket': The URL's scheme must be either 'ws' or 'wss'. '${protocolMatch[1]}:' is not allowed.` : `Failed to construct 'WebSocket': The URL '${config.url}' is invalid.`);
  }
  const { intervalMs, ...rest } = config;
  const createDefaultRpcSubscriptionsChannel = ({ abortSignal }) => {
    return createWebSocketChannel({
      ...rest,
      sendBufferHighWatermark: config.sendBufferHighWatermark ?? 131072,
      signal: abortSignal
    }).then(config.jsonSerializer).then((channel) => getRpcSubscriptionsChannelWithAutoping({
      abortSignal,
      channel,
      intervalMs: intervalMs ?? 5000
    }));
  };
  return getChannelPoolingChannelCreator(createDefaultRpcSubscriptionsChannel, {
    maxSubscriptionsPerChannel: config.maxSubscriptionsPerChannel ?? 100,
    minChannels: config.minChannels ?? 1
  });
}
function getRpcSubscriptionsTransportWithSubscriptionCoalescing(transport) {
  const cache2 = /* @__PURE__ */ new Map;
  return function rpcSubscriptionsTransportWithSubscriptionCoalescing(config) {
    const { request, signal } = config;
    const subscriptionConfigurationHash = index_default([request.methodName, request.params]);
    let cachedDataPublisherPromise = cache2.get(subscriptionConfigurationHash);
    if (!cachedDataPublisherPromise) {
      const abortController = new e6;
      const dataPublisherPromise = transport({
        ...config,
        signal: abortController.signal
      });
      dataPublisherPromise.then((dataPublisher) => {
        dataPublisher.on("error", () => {
          cache2.delete(subscriptionConfigurationHash);
          abortController.abort();
        }, { signal: abortController.signal });
      }).catch(() => {});
      cache2.set(subscriptionConfigurationHash, cachedDataPublisherPromise = {
        abortController,
        dataPublisherPromise,
        numSubscribers: 0
      });
    }
    cachedDataPublisherPromise.numSubscribers++;
    signal.addEventListener("abort", () => {
      cachedDataPublisherPromise.numSubscribers--;
      if (cachedDataPublisherPromise.numSubscribers === 0) {
        queueMicrotask(() => {
          if (cachedDataPublisherPromise.numSubscribers === 0) {
            cache2.delete(subscriptionConfigurationHash);
            cachedDataPublisherPromise.abortController.abort();
          }
        });
      }
    }, { signal: cachedDataPublisherPromise.abortController.signal });
    return cachedDataPublisherPromise.dataPublisherPromise;
  };
}
function createDefaultRpcSubscriptionsTransport({
  createChannel
}) {
  return pipe(createRpcSubscriptionsTransportFromChannelCreator(createChannel), (transport) => getRpcSubscriptionsTransportWithSubscriptionCoalescing(transport));
}
function createRpcSubscriptionsTransportFromChannelCreator(createChannel) {
  return async ({ execute, signal }) => {
    const channel = await createChannel({ abortSignal: signal });
    return await execute({ channel, signal });
  };
}
function createSolanaRpcSubscriptionsImpl(clusterUrl, config) {
  const transport = createDefaultRpcSubscriptionsTransport({
    createChannel: createDefaultSolanaRpcSubscriptionsChannelCreator({ ...config, url: clusterUrl })
  });
  return createSolanaRpcSubscriptionsFromTransport(transport);
}
function createSolanaRpcSubscriptions(clusterUrl, config) {
  return createSolanaRpcSubscriptionsImpl(clusterUrl, config);
}
function createSolanaRpcSubscriptions_UNSTABLE(clusterUrl, config) {
  return createSolanaRpcSubscriptionsImpl(clusterUrl, config);
}
function createSolanaRpcSubscriptionsFromTransport(transport) {
  return createSubscriptionRpc({
    api: createSolanaRpcSubscriptionsApi(DEFAULT_RPC_SUBSCRIPTIONS_CONFIG),
    transport
  });
}
var DEFAULT_RPC_SUBSCRIPTIONS_CONFIG, e6, PING_PAYLOAD;
var init_index_node37 = __esm(() => {
  init_index_node35();
  init_index_node34();
  init_index_node6();
  init_index_node36();
  init_index_node16();
  init_index_node26();
  init_index_node31();
  init_index_node35();
  init_index_node34();
  DEFAULT_RPC_SUBSCRIPTIONS_CONFIG = {
    defaultCommitment: "confirmed",
    onIntegerOverflow(request, keyPath, value) {
      throw createSolanaJsonRpcIntegerOverflowError2(request.methodName, keyPath, value);
    }
  };
  e6 = class extends globalThis.AbortController {
    constructor(...t) {
      super(...t), setMaxListeners5(Number.MAX_SAFE_INTEGER, this.signal);
    }
  };
  PING_PAYLOAD = {
    jsonrpc: "2.0",
    method: "ping"
  };
});

// ../../node_modules/.bun/@solana+signers@5.1.0+7f9e3d21594a24ff/node_modules/@solana/signers/dist/index.node.mjs
function deduplicateSigners(signers) {
  const deduplicated = {};
  signers.forEach((signer) => {
    if (!deduplicated[signer.address]) {
      deduplicated[signer.address] = signer;
    } else if (deduplicated[signer.address] !== signer) {
      throw new SolanaError2(SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS2, {
        address: signer.address
      });
    }
  });
  return Object.values(deduplicated);
}
function isTransactionModifyingSigner(value) {
  return "modifyAndSignTransactions" in value && typeof value.modifyAndSignTransactions === "function";
}
function assertIsTransactionModifyingSigner(value) {
  if (!isTransactionModifyingSigner(value)) {
    throw new SolanaError2(SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER2, {
      address: value.address
    });
  }
}
function isTransactionPartialSigner(value) {
  return "signTransactions" in value && typeof value.signTransactions === "function";
}
function assertIsTransactionPartialSigner(value) {
  if (!isTransactionPartialSigner(value)) {
    throw new SolanaError2(SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER2, {
      address: value.address
    });
  }
}
function isTransactionSendingSigner(value) {
  return "signAndSendTransactions" in value && typeof value.signAndSendTransactions === "function";
}
function assertIsTransactionSendingSigner(value) {
  if (!isTransactionSendingSigner(value)) {
    throw new SolanaError2(SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER2, {
      address: value.address
    });
  }
}
function isTransactionSigner(value) {
  return isTransactionPartialSigner(value) || isTransactionModifyingSigner(value) || isTransactionSendingSigner(value);
}
function assertIsTransactionSigner(value) {
  if (!isTransactionSigner(value)) {
    throw new SolanaError2(SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER2, {
      address: value.address
    });
  }
}
function getSignersFromInstruction(instruction) {
  return deduplicateSigners((instruction.accounts ?? []).flatMap((account) => ("signer" in account) ? account.signer : []));
}
function getSignersFromTransactionMessage(transaction) {
  return deduplicateSigners([
    ...transaction.feePayer && isTransactionSigner(transaction.feePayer) ? [transaction.feePayer] : [],
    ...transaction.instructions.flatMap(getSignersFromInstruction)
  ]);
}
function addSignersToInstruction(signers, instruction) {
  if (!instruction.accounts || instruction.accounts.length === 0) {
    return instruction;
  }
  const signerByAddress = new Map(deduplicateSigners(signers).map((signer) => [signer.address, signer]));
  return Object.freeze({
    ...instruction,
    accounts: instruction.accounts.map((account) => {
      const signer = signerByAddress.get(account.address);
      if (!isSignerRole(account.role) || "signer" in account || !signer) {
        return account;
      }
      return Object.freeze({ ...account, signer });
    })
  });
}
function addSignersToTransactionMessage(signers, transactionMessage) {
  const feePayerSigner = hasAddressOnlyFeePayer(transactionMessage) ? signers.find((signer) => signer.address === transactionMessage.feePayer.address) : undefined;
  if (!feePayerSigner && transactionMessage.instructions.length === 0) {
    return transactionMessage;
  }
  return Object.freeze({
    ...transactionMessage,
    ...feePayerSigner ? { feePayer: feePayerSigner } : null,
    instructions: transactionMessage.instructions.map((instruction) => addSignersToInstruction(signers, instruction))
  });
}
function hasAddressOnlyFeePayer(message) {
  return !!message && "feePayer" in message && !!message.feePayer && typeof message.feePayer.address === "string" && !isTransactionSigner(message.feePayer);
}
function setTransactionMessageFeePayerSigner(feePayer, transactionMessage) {
  Object.freeze(feePayer);
  const out = { ...transactionMessage, feePayer };
  Object.freeze(out);
  return out;
}
function isMessagePartialSigner(value) {
  return "signMessages" in value && typeof value.signMessages === "function";
}
function assertIsMessagePartialSigner(value) {
  if (!isMessagePartialSigner(value)) {
    throw new SolanaError2(SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER2, {
      address: value.address
    });
  }
}
function isKeyPairSigner(value) {
  return "keyPair" in value && typeof value.keyPair === "object" && isMessagePartialSigner(value) && isTransactionPartialSigner(value);
}
function assertIsKeyPairSigner(value) {
  if (!isKeyPairSigner(value)) {
    throw new SolanaError2(SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER2, {
      address: value.address
    });
  }
}
async function createSignerFromKeyPair(keyPair) {
  const address3 = await getAddressFromPublicKey2(keyPair.publicKey);
  const out = {
    address: address3,
    keyPair,
    signMessages: (messages) => Promise.all(messages.map(async (message) => Object.freeze({ [address3]: await signBytes(keyPair.privateKey, message.content) }))),
    signTransactions: (transactions) => Promise.all(transactions.map(async (transaction) => {
      const signedTransaction = await partiallySignTransaction([keyPair], transaction);
      return Object.freeze({ [address3]: signedTransaction.signatures[address3] });
    }))
  };
  return Object.freeze(out);
}
async function generateKeyPairSigner() {
  return await createSignerFromKeyPair(await generateKeyPair());
}
async function createKeyPairSignerFromBytes(bytes, extractable) {
  return await createSignerFromKeyPair(await createKeyPairFromBytes(bytes, extractable));
}
async function createKeyPairSignerFromPrivateKeyBytes(bytes, extractable) {
  return await createSignerFromKeyPair(await createKeyPairFromPrivateKeyBytes(bytes, extractable));
}
function isMessageModifyingSigner(value) {
  return isAddress2(value.address) && "modifyAndSignMessages" in value && typeof value.modifyAndSignMessages === "function";
}
function assertIsMessageModifyingSigner(value) {
  if (!isMessageModifyingSigner(value)) {
    throw new SolanaError2(SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER2, {
      address: value.address
    });
  }
}
function isMessageSigner(value) {
  return isMessagePartialSigner(value) || isMessageModifyingSigner(value);
}
function assertIsMessageSigner(value) {
  if (!isMessageSigner(value)) {
    throw new SolanaError2(SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER2, {
      address: value.address
    });
  }
}
function createNoopSigner(address3) {
  const out = {
    address: address3,
    signMessages: (messages) => Promise.resolve(messages.map(() => Object.freeze({}))),
    signTransactions: (transactions) => Promise.resolve(transactions.map(() => Object.freeze({})))
  };
  return Object.freeze(out);
}
function getSignersFromOffchainMessage({
  requiredSignatories
}) {
  const messageSigners = requiredSignatories.filter(isMessageSigner);
  return deduplicateSigners(messageSigners);
}
async function partiallySignOffchainMessageWithSigners(offchainMessage, config) {
  const { partialSigners, modifyingSigners } = categorizeMessageSigners(getSignersFromOffchainMessage(offchainMessage));
  return await signModifyingAndPartialMessageSigners(offchainMessage, modifyingSigners, partialSigners, config);
}
async function signOffchainMessageWithSigners(offchainMessage, config) {
  const signedOffchainMessageEnvelope = await partiallySignOffchainMessageWithSigners(offchainMessage, config);
  assertIsFullySignedOffchainMessageEnvelope(signedOffchainMessageEnvelope);
  return signedOffchainMessageEnvelope;
}
function categorizeMessageSigners(signers) {
  const modifyingSigners = identifyMessageModifyingSigners(signers);
  const partialSigners = signers.filter(isMessagePartialSigner).filter((signer) => !modifyingSigners.includes(signer));
  return Object.freeze({ modifyingSigners, partialSigners });
}
function identifyMessageModifyingSigners(signers) {
  const modifyingSigners = signers.filter(isMessageModifyingSigner);
  if (modifyingSigners.length === 0)
    return [];
  const nonPartialSigners = modifyingSigners.filter((signer) => !isMessagePartialSigner(signer));
  if (nonPartialSigners.length > 0)
    return nonPartialSigners;
  return [modifyingSigners[0]];
}
async function signModifyingAndPartialMessageSigners(offchainMessage, modifyingSigners = [], partialSigners = [], config) {
  const offchainMessageEnvelope = compileOffchainMessageEnvelope(offchainMessage);
  const modifiedOffchainMessage = await modifyingSigners.reduce(async (offchainMessageEnvelope2, modifyingSigner) => {
    config?.abortSignal?.throwIfAborted();
    const [message] = await modifyingSigner.modifyAndSignMessages([await offchainMessageEnvelope2], config);
    return Object.freeze(message);
  }, Promise.resolve(offchainMessageEnvelope));
  config?.abortSignal?.throwIfAborted();
  const signatureDictionaries = await Promise.all(partialSigners.map(async (partialSigner) => {
    const [signatures] = await partialSigner.signMessages([modifiedOffchainMessage], config);
    return signatures;
  }));
  return Object.freeze({
    ...modifiedOffchainMessage,
    signatures: Object.freeze(signatureDictionaries.reduce((signatures, signatureDictionary) => {
      return { ...signatures, ...signatureDictionary };
    }, modifiedOffchainMessage.signatures ?? {}))
  });
}
function isTransactionMessageWithSingleSendingSigner(transaction) {
  try {
    assertIsTransactionMessageWithSingleSendingSigner(transaction);
    return true;
  } catch {
    return false;
  }
}
function assertIsTransactionMessageWithSingleSendingSigner(transaction) {
  const signers = getSignersFromTransactionMessage(transaction);
  const sendingSigners = signers.filter(isTransactionSendingSigner);
  if (sendingSigners.length === 0) {
    throw new SolanaError2(SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING2);
  }
  const sendingOnlySigners = sendingSigners.filter((signer) => !isTransactionPartialSigner(signer) && !isTransactionModifyingSigner(signer));
  if (sendingOnlySigners.length > 1) {
    throw new SolanaError2(SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS2);
  }
}
async function partiallySignTransactionMessageWithSigners(transactionMessage, config) {
  const { partialSigners, modifyingSigners } = categorizeTransactionSigners(deduplicateSigners(getSignersFromTransactionMessage(transactionMessage).filter(isTransactionSigner)), { identifySendingSigner: false });
  return await signModifyingAndPartialTransactionSigners(transactionMessage, modifyingSigners, partialSigners, config);
}
async function signTransactionMessageWithSigners(transactionMessage, config) {
  const signedTransaction = await partiallySignTransactionMessageWithSigners(transactionMessage, config);
  assertIsFullySignedTransaction(signedTransaction);
  return signedTransaction;
}
async function signAndSendTransactionMessageWithSigners(transaction, config) {
  assertIsTransactionMessageWithSingleSendingSigner(transaction);
  const abortSignal = config?.abortSignal;
  const { partialSigners, modifyingSigners, sendingSigner } = categorizeTransactionSigners(deduplicateSigners(getSignersFromTransactionMessage(transaction).filter(isTransactionSigner)));
  abortSignal?.throwIfAborted();
  const signedTransaction = await signModifyingAndPartialTransactionSigners(transaction, modifyingSigners, partialSigners, config);
  if (!sendingSigner) {
    throw new SolanaError2(SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING2);
  }
  abortSignal?.throwIfAborted();
  const [signature2] = await sendingSigner.signAndSendTransactions([signedTransaction], config);
  abortSignal?.throwIfAborted();
  return signature2;
}
function categorizeTransactionSigners(signers, config = {}) {
  const identifySendingSigner = config.identifySendingSigner ?? true;
  const sendingSigner = identifySendingSigner ? identifyTransactionSendingSigner(signers) : null;
  const otherSigners = signers.filter((signer) => signer !== sendingSigner && (isTransactionModifyingSigner(signer) || isTransactionPartialSigner(signer)));
  const modifyingSigners = identifyTransactionModifyingSigners(otherSigners);
  const partialSigners = otherSigners.filter(isTransactionPartialSigner).filter((signer) => !modifyingSigners.includes(signer));
  return Object.freeze({ modifyingSigners, partialSigners, sendingSigner });
}
function identifyTransactionSendingSigner(signers) {
  const sendingSigners = signers.filter(isTransactionSendingSigner);
  if (sendingSigners.length === 0)
    return null;
  const sendingOnlySigners = sendingSigners.filter((signer) => !isTransactionModifyingSigner(signer) && !isTransactionPartialSigner(signer));
  if (sendingOnlySigners.length > 0) {
    return sendingOnlySigners[0];
  }
  return sendingSigners[0];
}
function identifyTransactionModifyingSigners(signers) {
  const modifyingSigners = signers.filter(isTransactionModifyingSigner);
  if (modifyingSigners.length === 0)
    return [];
  const nonPartialSigners = modifyingSigners.filter((signer) => !isTransactionPartialSigner(signer));
  if (nonPartialSigners.length > 0)
    return nonPartialSigners;
  return [modifyingSigners[0]];
}
async function signModifyingAndPartialTransactionSigners(transactionMessage, modifyingSigners = [], partialSigners = [], config) {
  const transaction = compileTransaction(transactionMessage);
  const modifiedTransaction = await modifyingSigners.reduce(async (transaction2, modifyingSigner) => {
    config?.abortSignal?.throwIfAborted();
    const [tx] = await modifyingSigner.modifyAndSignTransactions([await transaction2], config);
    return Object.freeze(tx);
  }, Promise.resolve(transaction));
  config?.abortSignal?.throwIfAborted();
  const signatureDictionaries = await Promise.all(partialSigners.map(async (partialSigner) => {
    const [signatures] = await partialSigner.signTransactions([modifiedTransaction], config);
    return signatures;
  }));
  return Object.freeze({
    ...modifiedTransaction,
    signatures: Object.freeze(signatureDictionaries.reduce((signatures, signatureDictionary) => {
      return { ...signatures, ...signatureDictionary };
    }, modifiedTransaction.signatures ?? {}))
  });
}
function createSignableMessage(content, signatures = {}) {
  return Object.freeze({
    content: typeof content === "string" ? new o3().encode(content) : content,
    signatures: Object.freeze({ ...signatures })
  });
}
var o3;
var init_index_node38 = __esm(() => {
  init_index_node6();
  init_index_node17();
  init_index_node11();
  init_index_node20();
  init_index_node21();
  init_index_node24();
  o3 = globalThis.TextEncoder;
});

// ../../node_modules/.bun/@solana+transaction-confirmation@5.1.0+b7f519a64bbf2dd5/node_modules/@solana/transaction-confirmation/dist/index.node.mjs
import { setMaxListeners as setMaxListeners6 } from "events";
function createBlockHeightExceedencePromiseFactory({
  rpc,
  rpcSubscriptions
}) {
  return async function getBlockHeightExceedencePromise({
    abortSignal: callerAbortSignal,
    commitment,
    lastValidBlockHeight
  }) {
    callerAbortSignal.throwIfAborted();
    const abortController = new e7;
    const handleAbort = () => {
      abortController.abort();
    };
    callerAbortSignal.addEventListener("abort", handleAbort, { signal: abortController.signal });
    async function getBlockHeightAndDifferenceBetweenSlotHeightAndBlockHeight() {
      const { absoluteSlot, blockHeight } = await rpc.getEpochInfo({ commitment }).send({ abortSignal: abortController.signal });
      return {
        blockHeight,
        differenceBetweenSlotHeightAndBlockHeight: absoluteSlot - blockHeight
      };
    }
    try {
      const [slotNotifications, { blockHeight: initialBlockHeight, differenceBetweenSlotHeightAndBlockHeight }] = await Promise.all([
        rpcSubscriptions.slotNotifications().subscribe({ abortSignal: abortController.signal }),
        getBlockHeightAndDifferenceBetweenSlotHeightAndBlockHeight()
      ]);
      callerAbortSignal.throwIfAborted();
      let currentBlockHeight = initialBlockHeight;
      if (currentBlockHeight <= lastValidBlockHeight) {
        let lastKnownDifferenceBetweenSlotHeightAndBlockHeight = differenceBetweenSlotHeightAndBlockHeight;
        for await (const slotNotification of slotNotifications) {
          const { slot } = slotNotification;
          if (slot - lastKnownDifferenceBetweenSlotHeightAndBlockHeight > lastValidBlockHeight) {
            const {
              blockHeight: recheckedBlockHeight,
              differenceBetweenSlotHeightAndBlockHeight: currentDifferenceBetweenSlotHeightAndBlockHeight
            } = await getBlockHeightAndDifferenceBetweenSlotHeightAndBlockHeight();
            currentBlockHeight = recheckedBlockHeight;
            if (currentBlockHeight > lastValidBlockHeight) {
              break;
            } else {
              lastKnownDifferenceBetweenSlotHeightAndBlockHeight = currentDifferenceBetweenSlotHeightAndBlockHeight;
            }
          }
        }
      }
      callerAbortSignal.throwIfAborted();
      throw new SolanaError2(SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED2, {
        currentBlockHeight,
        lastValidBlockHeight
      });
    } finally {
      abortController.abort();
    }
  };
}
function createNonceInvalidationPromiseFactory({
  rpc,
  rpcSubscriptions
}) {
  return async function getNonceInvalidationPromise({
    abortSignal: callerAbortSignal,
    commitment,
    currentNonceValue: expectedNonceValue,
    nonceAccountAddress
  }) {
    const abortController = new e7;
    function handleAbort() {
      abortController.abort();
    }
    callerAbortSignal.addEventListener("abort", handleAbort, { signal: abortController.signal });
    const accountNotifications = await rpcSubscriptions.accountNotifications(nonceAccountAddress, { commitment, encoding: "base64" }).subscribe({ abortSignal: abortController.signal });
    const base58Decoder2 = getBase58Decoder2();
    const base64Encoder = getBase64Encoder();
    function getNonceFromAccountData([base64EncodedBytes]) {
      const data = base64Encoder.encode(base64EncodedBytes);
      const nonceValueBytes = data.slice(NONCE_VALUE_OFFSET, NONCE_VALUE_OFFSET + 32);
      return base58Decoder2.decode(nonceValueBytes);
    }
    const nonceAccountDidAdvancePromise = (async () => {
      for await (const accountNotification of accountNotifications) {
        const nonceValue = getNonceFromAccountData(accountNotification.value.data);
        if (nonceValue !== expectedNonceValue) {
          throw new SolanaError2(SOLANA_ERROR__INVALID_NONCE2, {
            actualNonceValue: nonceValue,
            expectedNonceValue
          });
        }
      }
    })();
    const nonceIsAlreadyInvalidPromise = (async () => {
      const { value: nonceAccount } = await rpc.getAccountInfo(nonceAccountAddress, {
        commitment,
        dataSlice: { length: 32, offset: NONCE_VALUE_OFFSET },
        encoding: "base58"
      }).send({ abortSignal: abortController.signal });
      if (!nonceAccount) {
        throw new SolanaError2(SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND2, {
          nonceAccountAddress
        });
      }
      const nonceValue = nonceAccount.data[0];
      if (nonceValue !== expectedNonceValue) {
        throw new SolanaError2(SOLANA_ERROR__INVALID_NONCE2, {
          actualNonceValue: nonceValue,
          expectedNonceValue
        });
      } else {
        await new Promise(() => {});
      }
    })();
    try {
      return await safeRace([nonceAccountDidAdvancePromise, nonceIsAlreadyInvalidPromise]);
    } finally {
      abortController.abort();
    }
  };
}
function createRecentSignatureConfirmationPromiseFactory({
  rpc,
  rpcSubscriptions
}) {
  return async function getRecentSignatureConfirmationPromise({
    abortSignal: callerAbortSignal,
    commitment,
    signature: signature2
  }) {
    const abortController = new e7;
    function handleAbort() {
      abortController.abort();
    }
    callerAbortSignal.addEventListener("abort", handleAbort, { signal: abortController.signal });
    const signatureStatusNotifications = await rpcSubscriptions.signatureNotifications(signature2, { commitment }).subscribe({ abortSignal: abortController.signal });
    const signatureDidCommitPromise = (async () => {
      for await (const signatureStatusNotification of signatureStatusNotifications) {
        if (signatureStatusNotification.value.err) {
          throw getSolanaErrorFromTransactionError(signatureStatusNotification.value.err);
        } else {
          return;
        }
      }
    })();
    const signatureStatusLookupPromise = (async () => {
      const { value: signatureStatusResults } = await rpc.getSignatureStatuses([signature2]).send({ abortSignal: abortController.signal });
      const signatureStatus = signatureStatusResults[0];
      if (signatureStatus?.err) {
        throw getSolanaErrorFromTransactionError(signatureStatus.err);
      } else if (signatureStatus?.confirmationStatus && commitmentComparator(signatureStatus.confirmationStatus, commitment) >= 0) {
        return;
      } else {
        await new Promise(() => {});
      }
    })();
    try {
      return await safeRace([signatureDidCommitPromise, signatureStatusLookupPromise]);
    } finally {
      abortController.abort();
    }
  };
}
async function getTimeoutPromise({ abortSignal: callerAbortSignal, commitment }) {
  return await new Promise((_, reject) => {
    const handleAbort = (e22) => {
      clearTimeout(timeoutId);
      const abortError = new DOMException(e22.target.reason, "AbortError");
      reject(abortError);
    };
    callerAbortSignal.addEventListener("abort", handleAbort);
    const timeoutMs = commitment === "processed" ? 30000 : 60000;
    const startMs = performance.now();
    const timeoutId = setTimeout(() => {
      const elapsedMs = performance.now() - startMs;
      reject(new DOMException(`Timeout elapsed after ${elapsedMs} ms`, "TimeoutError"));
    }, timeoutMs);
  });
}
async function raceStrategies(signature2, config, getSpecificStrategiesForRace) {
  const { abortSignal: callerAbortSignal, commitment, getRecentSignatureConfirmationPromise } = config;
  callerAbortSignal?.throwIfAborted();
  const abortController = new e7;
  if (callerAbortSignal) {
    const handleAbort = () => {
      abortController.abort();
    };
    callerAbortSignal.addEventListener("abort", handleAbort, { signal: abortController.signal });
  }
  try {
    const specificStrategies = getSpecificStrategiesForRace({
      ...config,
      abortSignal: abortController.signal
    });
    return await safeRace([
      getRecentSignatureConfirmationPromise({
        abortSignal: abortController.signal,
        commitment,
        signature: signature2
      }),
      ...specificStrategies
    ]);
  } finally {
    abortController.abort();
  }
}
async function waitForDurableNonceTransactionConfirmation(config) {
  await raceStrategies(getSignatureFromTransaction(config.transaction), config, function getSpecificStrategiesForRace({ abortSignal, commitment, getNonceInvalidationPromise, transaction }) {
    return [
      getNonceInvalidationPromise({
        abortSignal,
        commitment,
        currentNonceValue: transaction.lifetimeConstraint.nonce,
        nonceAccountAddress: transaction.lifetimeConstraint.nonceAccountAddress
      })
    ];
  });
}
async function waitForRecentTransactionConfirmation(config) {
  await raceStrategies(getSignatureFromTransaction(config.transaction), config, function getSpecificStrategiesForRace({
    abortSignal,
    commitment,
    getBlockHeightExceedencePromise,
    transaction
  }) {
    return [
      getBlockHeightExceedencePromise({
        abortSignal,
        commitment,
        lastValidBlockHeight: transaction.lifetimeConstraint.lastValidBlockHeight
      })
    ];
  });
}
async function waitForRecentTransactionConfirmationUntilTimeout(config) {
  await raceStrategies(config.signature, config, function getSpecificStrategiesForRace({ abortSignal, commitment, getTimeoutPromise: getTimeoutPromise2 }) {
    return [
      getTimeoutPromise2({
        abortSignal,
        commitment
      })
    ];
  });
}
var e7, NONCE_VALUE_OFFSET;
var init_index_node39 = __esm(() => {
  init_index_node6();
  init_index_node8();
  init_index_node22();
  init_index_node18();
  init_index_node21();
  e7 = class extends globalThis.AbortController {
    constructor(...t) {
      super(...t), setMaxListeners6(Number.MAX_SAFE_INTEGER, this.signal);
    }
  };
  NONCE_VALUE_OFFSET = 4 + 4 + 32;
});

// ../../node_modules/.bun/@solana+kit@5.1.0+b7f519a64bbf2dd5/node_modules/@solana/kit/dist/index.node.mjs
var exports_index_node3 = {};
__export(exports_index_node3, {
  wrapNullable: () => wrapNullable,
  verifySignature: () => verifySignature,
  verifyOffchainMessageEnvelope: () => verifyOffchainMessageEnvelope,
  upgradeRoleToWritable: () => upgradeRoleToWritable,
  upgradeRoleToSigner: () => upgradeRoleToSigner,
  unwrapOptionRecursively: () => unwrapOptionRecursively,
  unwrapOption: () => unwrapOption,
  unixTimestamp: () => unixTimestamp,
  transformEncoder: () => transformEncoder2,
  transformDecoder: () => transformDecoder,
  transformCodec: () => transformCodec,
  transformChannelOutboundMessages: () => transformChannelOutboundMessages,
  transformChannelInboundMessages: () => transformChannelInboundMessages,
  testnet: () => testnet,
  summarizeTransactionPlanResult: () => summarizeTransactionPlanResult,
  successfulSingleTransactionPlanResultFromSignature: () => successfulSingleTransactionPlanResultFromSignature,
  successfulSingleTransactionPlanResult: () => successfulSingleTransactionPlanResult,
  stringifiedNumber: () => stringifiedNumber,
  stringifiedBigInt: () => stringifiedBigInt,
  some: () => some,
  singleTransactionPlan: () => singleTransactionPlan,
  singleInstructionPlan: () => singleInstructionPlan,
  signatureBytes: () => signatureBytes,
  signature: () => signature,
  signTransactionMessageWithSigners: () => signTransactionMessageWithSigners,
  signTransaction: () => signTransaction,
  signOffchainMessageWithSigners: () => signOffchainMessageWithSigners,
  signOffchainMessageEnvelope: () => signOffchainMessageEnvelope,
  signBytes: () => signBytes,
  signAndSendTransactionMessageWithSigners: () => signAndSendTransactionMessageWithSigners,
  setTransactionMessageLifetimeUsingDurableNonce: () => setTransactionMessageLifetimeUsingDurableNonce,
  setTransactionMessageLifetimeUsingBlockhash: () => setTransactionMessageLifetimeUsingBlockhash,
  setTransactionMessageFeePayerSigner: () => setTransactionMessageFeePayerSigner,
  setTransactionMessageFeePayer: () => setTransactionMessageFeePayer,
  sequentialTransactionPlanResult: () => sequentialTransactionPlanResult,
  sequentialTransactionPlan: () => sequentialTransactionPlan,
  sequentialInstructionPlan: () => sequentialInstructionPlan,
  sendTransactionWithoutConfirmingFactory: () => sendTransactionWithoutConfirmingFactory,
  sendAndConfirmTransactionFactory: () => sendAndConfirmTransactionFactory,
  sendAndConfirmDurableNonceTransactionFactory: () => sendAndConfirmDurableNonceTransactionFactory,
  safeCaptureStackTrace: () => safeCaptureStackTrace,
  reverseEncoder: () => reverseEncoder,
  reverseDecoder: () => reverseDecoder,
  reverseCodec: () => reverseCodec,
  resizeEncoder: () => resizeEncoder,
  resizeDecoder: () => resizeDecoder,
  resizeCodec: () => resizeCodec,
  removeNullCharacters: () => removeNullCharacters,
  prependTransactionMessageInstructions: () => prependTransactionMessageInstructions,
  prependTransactionMessageInstruction: () => prependTransactionMessageInstruction,
  pipe: () => pipe,
  partiallySignTransactionMessageWithSigners: () => partiallySignTransactionMessageWithSigners,
  partiallySignTransaction: () => partiallySignTransaction,
  partiallySignOffchainMessageWithSigners: () => partiallySignOffchainMessageWithSigners,
  partiallySignOffchainMessageEnvelope: () => partiallySignOffchainMessageEnvelope,
  parseJsonRpcAccount: () => parseJsonRpcAccount,
  parseBase64RpcAccount: () => parseBase64RpcAccount,
  parseBase58RpcAccount: () => parseBase58RpcAccount,
  parallelTransactionPlanResult: () => parallelTransactionPlanResult,
  parallelTransactionPlan: () => parallelTransactionPlan,
  parallelInstructionPlan: () => parallelInstructionPlan,
  padRightEncoder: () => padRightEncoder,
  padRightDecoder: () => padRightDecoder,
  padRightCodec: () => padRightCodec,
  padNullCharacters: () => padNullCharacters,
  padLeftEncoder: () => padLeftEncoder,
  padLeftDecoder: () => padLeftDecoder,
  padLeftCodec: () => padLeftCodec,
  padBytes: () => padBytes2,
  offsetEncoder: () => offsetEncoder,
  offsetDecoder: () => offsetDecoder,
  offsetCodec: () => offsetCodec,
  offchainMessageContentUtf8Of65535BytesMax: () => offchainMessageContentUtf8Of65535BytesMax,
  offchainMessageContentUtf8Of1232BytesMax: () => offchainMessageContentUtf8Of1232BytesMax,
  offchainMessageContentRestrictedAsciiOf1232BytesMax: () => offchainMessageContentRestrictedAsciiOf1232BytesMax,
  offchainMessageApplicationDomain: () => offchainMessageApplicationDomain,
  offCurveAddress: () => offCurveAddress2,
  none: () => none,
  nonDivisibleSequentialTransactionPlanResult: () => nonDivisibleSequentialTransactionPlanResult,
  nonDivisibleSequentialTransactionPlan: () => nonDivisibleSequentialTransactionPlan,
  nonDivisibleSequentialInstructionPlan: () => nonDivisibleSequentialInstructionPlan,
  mergeRoles: () => mergeRoles,
  mergeBytes: () => mergeBytes,
  mainnet: () => mainnet,
  lamports: () => lamports,
  isWritableRole: () => isWritableRole,
  isVariableSize: () => isVariableSize2,
  isUnixTimestamp: () => isUnixTimestamp,
  isTransactionWithinSizeLimit: () => isTransactionWithinSizeLimit,
  isTransactionWithDurableNonceLifetime: () => isTransactionWithDurableNonceLifetime,
  isTransactionWithBlockhashLifetime: () => isTransactionWithBlockhashLifetime,
  isTransactionSigner: () => isTransactionSigner,
  isTransactionSendingSigner: () => isTransactionSendingSigner,
  isTransactionPartialSigner: () => isTransactionPartialSigner,
  isTransactionModifyingSigner: () => isTransactionModifyingSigner,
  isTransactionMessageWithinSizeLimit: () => isTransactionMessageWithinSizeLimit,
  isTransactionMessageWithSingleSendingSigner: () => isTransactionMessageWithSingleSendingSigner,
  isTransactionMessageWithDurableNonceLifetime: () => isTransactionMessageWithDurableNonceLifetime,
  isTransactionMessageWithBlockhashLifetime: () => isTransactionMessageWithBlockhashLifetime,
  isStringifiedNumber: () => isStringifiedNumber,
  isStringifiedBigInt: () => isStringifiedBigInt,
  isSome: () => isSome,
  isSolanaError: () => isSolanaError2,
  isSignerRole: () => isSignerRole,
  isSignatureBytes: () => isSignatureBytes,
  isSignature: () => isSignature,
  isSendableTransaction: () => isSendableTransaction,
  isProgramError: () => isProgramError,
  isProgramDerivedAddress: () => isProgramDerivedAddress2,
  isOption: () => isOption,
  isOffchainMessageContentUtf8Of65535BytesMax: () => isOffchainMessageContentUtf8Of65535BytesMax,
  isOffchainMessageContentUtf8Of1232BytesMax: () => isOffchainMessageContentUtf8Of1232BytesMax,
  isOffchainMessageContentRestrictedAsciiOf1232BytesMax: () => isOffchainMessageContentRestrictedAsciiOf1232BytesMax,
  isOffchainMessageApplicationDomain: () => isOffchainMessageApplicationDomain,
  isOffCurveAddress: () => isOffCurveAddress2,
  isNone: () => isNone,
  isMessageSigner: () => isMessageSigner,
  isMessagePartialSigner: () => isMessagePartialSigner,
  isMessageModifyingSigner: () => isMessageModifyingSigner,
  isLamports: () => isLamports,
  isKeyPairSigner: () => isKeyPairSigner,
  isJsonRpcPayload: () => isJsonRpcPayload,
  isInstructionWithData: () => isInstructionWithData,
  isInstructionWithAccounts: () => isInstructionWithAccounts,
  isInstructionForProgram: () => isInstructionForProgram,
  isFullySignedTransaction: () => isFullySignedTransaction,
  isFullySignedOffchainMessageEnvelope: () => isFullySignedOffchainMessageEnvelope,
  isFixedSize: () => isFixedSize2,
  isBlockhash: () => isBlockhash,
  isAdvanceNonceAccountInstruction: () => isAdvanceNonceAccountInstruction,
  isAddress: () => isAddress2,
  getUtf8Encoder: () => getUtf8Encoder,
  getUtf8Decoder: () => getUtf8Decoder,
  getUtf8Codec: () => getUtf8Codec,
  getUnitEncoder: () => getUnitEncoder,
  getUnitDecoder: () => getUnitDecoder,
  getUnitCodec: () => getUnitCodec,
  getUnionEncoder: () => getUnionEncoder,
  getUnionDecoder: () => getUnionDecoder,
  getUnionCodec: () => getUnionCodec,
  getU8Encoder: () => getU8Encoder,
  getU8Decoder: () => getU8Decoder,
  getU8Codec: () => getU8Codec,
  getU64Encoder: () => getU64Encoder,
  getU64Decoder: () => getU64Decoder,
  getU64Codec: () => getU64Codec,
  getU32Encoder: () => getU32Encoder,
  getU32Decoder: () => getU32Decoder,
  getU32Codec: () => getU32Codec,
  getU16Encoder: () => getU16Encoder,
  getU16Decoder: () => getU16Decoder,
  getU16Codec: () => getU16Codec,
  getU128Encoder: () => getU128Encoder,
  getU128Decoder: () => getU128Decoder,
  getU128Codec: () => getU128Codec,
  getTupleEncoder: () => getTupleEncoder,
  getTupleDecoder: () => getTupleDecoder,
  getTupleCodec: () => getTupleCodec,
  getTransactionVersionEncoder: () => getTransactionVersionEncoder,
  getTransactionVersionDecoder: () => getTransactionVersionDecoder,
  getTransactionVersionCodec: () => getTransactionVersionCodec,
  getTransactionSize: () => getTransactionSize,
  getTransactionMessageSize: () => getTransactionMessageSize,
  getTransactionLifetimeConstraintFromCompiledTransactionMessage: () => getTransactionLifetimeConstraintFromCompiledTransactionMessage,
  getTransactionEncoder: () => getTransactionEncoder,
  getTransactionDecoder: () => getTransactionDecoder,
  getTransactionCodec: () => getTransactionCodec,
  getStructEncoder: () => getStructEncoder,
  getStructDecoder: () => getStructDecoder,
  getStructCodec: () => getStructCodec,
  getSolanaErrorFromTransactionError: () => getSolanaErrorFromTransactionError,
  getSolanaErrorFromJsonRpcError: () => getSolanaErrorFromJsonRpcError,
  getSolanaErrorFromInstructionError: () => getSolanaErrorFromInstructionError,
  getSignersFromTransactionMessage: () => getSignersFromTransactionMessage,
  getSignersFromOffchainMessage: () => getSignersFromOffchainMessage,
  getSignersFromInstruction: () => getSignersFromInstruction,
  getSignatureFromTransaction: () => getSignatureFromTransaction,
  getShortU16Encoder: () => getShortU16Encoder,
  getShortU16Decoder: () => getShortU16Decoder,
  getShortU16Codec: () => getShortU16Codec,
  getSetEncoder: () => getSetEncoder,
  getSetDecoder: () => getSetDecoder,
  getSetCodec: () => getSetCodec,
  getRpcSubscriptionsTransportWithSubscriptionCoalescing: () => getRpcSubscriptionsTransportWithSubscriptionCoalescing,
  getRpcSubscriptionsChannelWithJSONSerialization: () => getRpcSubscriptionsChannelWithJSONSerialization,
  getRpcSubscriptionsChannelWithBigIntJSONSerialization: () => getRpcSubscriptionsChannelWithBigIntJSONSerialization,
  getRpcSubscriptionsChannelWithAutoping: () => getRpcSubscriptionsChannelWithAutoping,
  getReallocMessagePackerInstructionPlan: () => getReallocMessagePackerInstructionPlan,
  getPublicKeyFromPrivateKey: () => getPublicKeyFromPrivateKey,
  getPublicKeyFromAddress: () => getPublicKeyFromAddress2,
  getProgramDerivedAddress: () => getProgramDerivedAddress2,
  getOptionEncoder: () => getOptionEncoder,
  getOptionDecoder: () => getOptionDecoder,
  getOptionCodec: () => getOptionCodec,
  getOffchainMessageV1Encoder: () => getOffchainMessageV1Encoder,
  getOffchainMessageV1Decoder: () => getOffchainMessageV1Decoder,
  getOffchainMessageV1Codec: () => getOffchainMessageV1Codec,
  getOffchainMessageV0Encoder: () => getOffchainMessageV0Encoder,
  getOffchainMessageV0Decoder: () => getOffchainMessageV0Decoder,
  getOffchainMessageV0Codec: () => getOffchainMessageV0Codec,
  getOffchainMessageEnvelopeEncoder: () => getOffchainMessageEnvelopeEncoder,
  getOffchainMessageEnvelopeDecoder: () => getOffchainMessageEnvelopeDecoder,
  getOffchainMessageEnvelopeCodec: () => getOffchainMessageEnvelopeCodec,
  getOffchainMessageEncoder: () => getOffchainMessageEncoder,
  getOffchainMessageDecoder: () => getOffchainMessageDecoder,
  getOffchainMessageCodec: () => getOffchainMessageCodec,
  getOffchainMessageApplicationDomainEncoder: () => getOffchainMessageApplicationDomainEncoder,
  getOffchainMessageApplicationDomainDecoder: () => getOffchainMessageApplicationDomainDecoder,
  getOffchainMessageApplicationDomainCodec: () => getOffchainMessageApplicationDomainCodec,
  getNullableEncoder: () => getNullableEncoder,
  getNullableDecoder: () => getNullableDecoder,
  getNullableCodec: () => getNullableCodec,
  getMessagePackerInstructionPlanFromInstructions: () => getMessagePackerInstructionPlanFromInstructions,
  getMapEncoder: () => getMapEncoder,
  getMapDecoder: () => getMapDecoder,
  getMapCodec: () => getMapCodec,
  getLiteralUnionEncoder: () => getLiteralUnionEncoder,
  getLiteralUnionDecoder: () => getLiteralUnionDecoder,
  getLiteralUnionCodec: () => getLiteralUnionCodec,
  getLinearMessagePackerInstructionPlan: () => getLinearMessagePackerInstructionPlan,
  getLamportsEncoder: () => getLamportsEncoder,
  getLamportsDecoder: () => getLamportsDecoder,
  getLamportsCodec: () => getLamportsCodec,
  getI8Encoder: () => getI8Encoder,
  getI8Decoder: () => getI8Decoder,
  getI8Codec: () => getI8Codec,
  getI64Encoder: () => getI64Encoder,
  getI64Decoder: () => getI64Decoder,
  getI64Codec: () => getI64Codec,
  getI32Encoder: () => getI32Encoder,
  getI32Decoder: () => getI32Decoder,
  getI32Codec: () => getI32Codec,
  getI16Encoder: () => getI16Encoder,
  getI16Decoder: () => getI16Decoder,
  getI16Codec: () => getI16Codec,
  getI128Encoder: () => getI128Encoder,
  getI128Decoder: () => getI128Decoder,
  getI128Codec: () => getI128Codec,
  getHiddenSuffixEncoder: () => getHiddenSuffixEncoder,
  getHiddenSuffixDecoder: () => getHiddenSuffixDecoder,
  getHiddenSuffixCodec: () => getHiddenSuffixCodec,
  getHiddenPrefixEncoder: () => getHiddenPrefixEncoder,
  getHiddenPrefixDecoder: () => getHiddenPrefixDecoder,
  getHiddenPrefixCodec: () => getHiddenPrefixCodec,
  getF64Encoder: () => getF64Encoder,
  getF64Decoder: () => getF64Decoder,
  getF64Codec: () => getF64Codec,
  getF32Encoder: () => getF32Encoder,
  getF32Decoder: () => getF32Decoder,
  getF32Codec: () => getF32Codec,
  getEnumEncoder: () => getEnumEncoder,
  getEnumDecoder: () => getEnumDecoder,
  getEnumCodec: () => getEnumCodec,
  getEncodedSize: () => getEncodedSize2,
  getDiscriminatedUnionEncoder: () => getDiscriminatedUnionEncoder,
  getDiscriminatedUnionDecoder: () => getDiscriminatedUnionDecoder,
  getDiscriminatedUnionCodec: () => getDiscriminatedUnionCodec,
  getDefaultLamportsEncoder: () => getDefaultLamportsEncoder,
  getDefaultLamportsDecoder: () => getDefaultLamportsDecoder,
  getDefaultLamportsCodec: () => getDefaultLamportsCodec,
  getConstantEncoder: () => getConstantEncoder,
  getConstantDecoder: () => getConstantDecoder,
  getConstantCodec: () => getConstantCodec,
  getCompiledTransactionMessageEncoder: () => getCompiledTransactionMessageEncoder,
  getCompiledTransactionMessageDecoder: () => getCompiledTransactionMessageDecoder,
  getCompiledTransactionMessageCodec: () => getCompiledTransactionMessageCodec,
  getChannelPoolingChannelCreator: () => getChannelPoolingChannelCreator,
  getBytesEncoder: () => getBytesEncoder,
  getBytesDecoder: () => getBytesDecoder,
  getBytesCodec: () => getBytesCodec,
  getBooleanEncoder: () => getBooleanEncoder,
  getBooleanDecoder: () => getBooleanDecoder,
  getBooleanCodec: () => getBooleanCodec,
  getBlockhashEncoder: () => getBlockhashEncoder,
  getBlockhashDecoder: () => getBlockhashDecoder,
  getBlockhashComparator: () => getBlockhashComparator,
  getBlockhashCodec: () => getBlockhashCodec,
  getBitArrayEncoder: () => getBitArrayEncoder,
  getBitArrayDecoder: () => getBitArrayDecoder,
  getBitArrayCodec: () => getBitArrayCodec,
  getBaseXResliceEncoder: () => getBaseXResliceEncoder,
  getBaseXResliceDecoder: () => getBaseXResliceDecoder,
  getBaseXResliceCodec: () => getBaseXResliceCodec,
  getBaseXEncoder: () => getBaseXEncoder2,
  getBaseXDecoder: () => getBaseXDecoder2,
  getBaseXCodec: () => getBaseXCodec,
  getBase64Encoder: () => getBase64Encoder,
  getBase64EncodedWireTransaction: () => getBase64EncodedWireTransaction,
  getBase64Decoder: () => getBase64Decoder,
  getBase64Codec: () => getBase64Codec,
  getBase58Encoder: () => getBase58Encoder2,
  getBase58Decoder: () => getBase58Decoder2,
  getBase58Codec: () => getBase58Codec,
  getBase16Encoder: () => getBase16Encoder,
  getBase16Decoder: () => getBase16Decoder,
  getBase16Codec: () => getBase16Codec,
  getBase10Encoder: () => getBase10Encoder,
  getBase10Decoder: () => getBase10Decoder,
  getBase10Codec: () => getBase10Codec,
  getArrayEncoder: () => getArrayEncoder,
  getArrayDecoder: () => getArrayDecoder,
  getArrayCodec: () => getArrayCodec,
  getAllSingleTransactionPlans: () => getAllSingleTransactionPlans,
  getAddressFromPublicKey: () => getAddressFromPublicKey2,
  getAddressEncoder: () => getAddressEncoder2,
  getAddressDecoder: () => getAddressDecoder2,
  getAddressComparator: () => getAddressComparator2,
  getAddressCodec: () => getAddressCodec2,
  generateKeyPairSigner: () => generateKeyPairSigner,
  generateKeyPair: () => generateKeyPair,
  flattenTransactionPlanResult: () => flattenTransactionPlanResult,
  fixEncoderSize: () => fixEncoderSize2,
  fixDecoderSize: () => fixDecoderSize2,
  fixCodecSize: () => fixCodecSize,
  fixBytes: () => fixBytes2,
  fetchJsonParsedAccounts: () => fetchJsonParsedAccounts,
  fetchJsonParsedAccount: () => fetchJsonParsedAccount,
  fetchEncodedAccounts: () => fetchEncodedAccounts,
  fetchEncodedAccount: () => fetchEncodedAccount,
  fetchAddressesForLookupTables: () => fetchAddressesForLookupTables,
  failedSingleTransactionPlanResult: () => failedSingleTransactionPlanResult,
  executeRpcPubSubSubscriptionPlan: () => executeRpcPubSubSubscriptionPlan,
  downgradeRoleToReadonly: () => downgradeRoleToReadonly,
  downgradeRoleToNonSigner: () => downgradeRoleToNonSigner,
  devnet: () => devnet,
  decompileTransactionMessageFetchingLookupTables: () => decompileTransactionMessageFetchingLookupTables,
  decompileTransactionMessage: () => decompileTransactionMessage,
  decodeAccount: () => decodeAccount,
  createTransactionPlanner: () => createTransactionPlanner,
  createTransactionPlanExecutor: () => createTransactionPlanExecutor,
  createTransactionMessage: () => createTransactionMessage,
  createSubscriptionRpc: () => createSubscriptionRpc,
  createSolanaRpcSubscriptions_UNSTABLE: () => createSolanaRpcSubscriptions_UNSTABLE,
  createSolanaRpcSubscriptionsFromTransport: () => createSolanaRpcSubscriptionsFromTransport,
  createSolanaRpcSubscriptionsApi_UNSTABLE: () => createSolanaRpcSubscriptionsApi_UNSTABLE,
  createSolanaRpcSubscriptionsApi: () => createSolanaRpcSubscriptionsApi,
  createSolanaRpcSubscriptions: () => createSolanaRpcSubscriptions,
  createSolanaRpcFromTransport: () => createSolanaRpcFromTransport,
  createSolanaRpcApi: () => createSolanaRpcApi,
  createSolanaRpc: () => createSolanaRpc,
  createSignerFromKeyPair: () => createSignerFromKeyPair,
  createSignableMessage: () => createSignableMessage,
  createRpcSubscriptionsTransportFromChannelCreator: () => createRpcSubscriptionsTransportFromChannelCreator,
  createRpcSubscriptionsApi: () => createRpcSubscriptionsApi,
  createRpcMessage: () => createRpcMessage,
  createRpc: () => createRpc,
  createPrivateKeyFromBytes: () => createPrivateKeyFromBytes,
  createNoopSigner: () => createNoopSigner,
  createKeyPairSignerFromPrivateKeyBytes: () => createKeyPairSignerFromPrivateKeyBytes,
  createKeyPairSignerFromBytes: () => createKeyPairSignerFromBytes,
  createKeyPairFromPrivateKeyBytes: () => createKeyPairFromPrivateKeyBytes,
  createKeyPairFromBytes: () => createKeyPairFromBytes,
  createJsonRpcApi: () => createJsonRpcApi,
  createEncoder: () => createEncoder2,
  createDefaultSolanaRpcSubscriptionsChannelCreator: () => createDefaultSolanaRpcSubscriptionsChannelCreator,
  createDefaultRpcTransport: () => createDefaultRpcTransport,
  createDefaultRpcSubscriptionsTransport: () => createDefaultRpcSubscriptionsTransport,
  createDefaultRpcSubscriptionsChannelCreator: () => createDefaultRpcSubscriptionsChannelCreator,
  createDecoderThatConsumesEntireByteArray: () => createDecoderThatConsumesEntireByteArray,
  createDecoder: () => createDecoder2,
  createCodec: () => createCodec,
  createAddressWithSeed: () => createAddressWithSeed2,
  containsBytes: () => containsBytes,
  compressTransactionMessageUsingAddressLookupTables: () => compressTransactionMessageUsingAddressLookupTables,
  compileTransactionMessage: () => compileTransactionMessage,
  compileTransaction: () => compileTransaction,
  compileOffchainMessageV1Envelope: () => compileOffchainMessageV1Envelope,
  compileOffchainMessageV0Envelope: () => compileOffchainMessageV0Envelope,
  compileOffchainMessageEnvelope: () => compileOffchainMessageEnvelope,
  commitmentComparator: () => commitmentComparator,
  combineCodec: () => combineCodec2,
  canceledSingleTransactionPlanResult: () => canceledSingleTransactionPlanResult,
  bytesEqual: () => bytesEqual2,
  blockhash: () => blockhash,
  assertValidNumberOfItemsForCodec: () => assertValidNumberOfItemsForCodec,
  assertValidBaseString: () => assertValidBaseString2,
  assertNumberIsBetweenForCodec: () => assertNumberIsBetweenForCodec,
  assertIsVariableSize: () => assertIsVariableSize,
  assertIsUnixTimestamp: () => assertIsUnixTimestamp,
  assertIsTransactionWithinSizeLimit: () => assertIsTransactionWithinSizeLimit,
  assertIsTransactionWithDurableNonceLifetime: () => assertIsTransactionWithDurableNonceLifetime,
  assertIsTransactionWithBlockhashLifetime: () => assertIsTransactionWithBlockhashLifetime,
  assertIsTransactionSigner: () => assertIsTransactionSigner,
  assertIsTransactionSendingSigner: () => assertIsTransactionSendingSigner,
  assertIsTransactionPartialSigner: () => assertIsTransactionPartialSigner,
  assertIsTransactionModifyingSigner: () => assertIsTransactionModifyingSigner,
  assertIsTransactionMessageWithinSizeLimit: () => assertIsTransactionMessageWithinSizeLimit,
  assertIsTransactionMessageWithSingleSendingSigner: () => assertIsTransactionMessageWithSingleSendingSigner,
  assertIsTransactionMessageWithDurableNonceLifetime: () => assertIsTransactionMessageWithDurableNonceLifetime,
  assertIsTransactionMessageWithBlockhashLifetime: () => assertIsTransactionMessageWithBlockhashLifetime,
  assertIsStringifiedNumber: () => assertIsStringifiedNumber,
  assertIsStringifiedBigInt: () => assertIsStringifiedBigInt,
  assertIsSignatureBytes: () => assertIsSignatureBytes,
  assertIsSignature: () => assertIsSignature,
  assertIsSendableTransaction: () => assertIsSendableTransaction,
  assertIsProgramDerivedAddress: () => assertIsProgramDerivedAddress2,
  assertIsOffchainMessageUtf8Of65535BytesMax: () => assertIsOffchainMessageUtf8Of65535BytesMax,
  assertIsOffchainMessageUtf8Of1232BytesMax: () => assertIsOffchainMessageUtf8Of1232BytesMax,
  assertIsOffchainMessageRestrictedAsciiOf1232BytesMax: () => assertIsOffchainMessageRestrictedAsciiOf1232BytesMax,
  assertIsOffchainMessageContentUtf8Of65535BytesMax: () => assertIsOffchainMessageContentUtf8Of65535BytesMax,
  assertIsOffchainMessageContentUtf8Of1232BytesMax: () => assertIsOffchainMessageContentUtf8Of1232BytesMax,
  assertIsOffchainMessageContentRestrictedAsciiOf1232BytesMax: () => assertIsOffchainMessageContentRestrictedAsciiOf1232BytesMax,
  assertIsOffchainMessageApplicationDomain: () => assertIsOffchainMessageApplicationDomain,
  assertIsOffCurveAddress: () => assertIsOffCurveAddress2,
  assertIsMessageSigner: () => assertIsMessageSigner,
  assertIsMessagePartialSigner: () => assertIsMessagePartialSigner,
  assertIsMessageModifyingSigner: () => assertIsMessageModifyingSigner,
  assertIsLamports: () => assertIsLamports,
  assertIsKeyPairSigner: () => assertIsKeyPairSigner,
  assertIsInstructionWithData: () => assertIsInstructionWithData,
  assertIsInstructionWithAccounts: () => assertIsInstructionWithAccounts,
  assertIsInstructionForProgram: () => assertIsInstructionForProgram,
  assertIsFullySignedTransaction: () => assertIsFullySignedTransaction,
  assertIsFullySignedOffchainMessageEnvelope: () => assertIsFullySignedOffchainMessageEnvelope,
  assertIsFixedSize: () => assertIsFixedSize,
  assertIsBlockhash: () => assertIsBlockhash,
  assertIsAddress: () => assertIsAddress2,
  assertByteArrayOffsetIsNotOutOfRange: () => assertByteArrayOffsetIsNotOutOfRange,
  assertByteArrayIsNotEmptyForCodec: () => assertByteArrayIsNotEmptyForCodec,
  assertByteArrayHasEnoughBytesForCodec: () => assertByteArrayHasEnoughBytesForCodec2,
  assertAccountsExist: () => assertAccountsExist,
  assertAccountsDecoded: () => assertAccountsDecoded,
  assertAccountExists: () => assertAccountExists,
  assertAccountDecoded: () => assertAccountDecoded,
  appendTransactionMessageInstructions: () => appendTransactionMessageInstructions,
  appendTransactionMessageInstruction: () => appendTransactionMessageInstruction,
  airdropFactory: () => airdropFactory,
  address: () => address2,
  addSignersToTransactionMessage: () => addSignersToTransactionMessage,
  addSignersToInstruction: () => addSignersToInstruction,
  addEncoderSizePrefix: () => addEncoderSizePrefix,
  addEncoderSentinel: () => addEncoderSentinel,
  addDecoderSizePrefix: () => addDecoderSizePrefix,
  addDecoderSentinel: () => addDecoderSentinel,
  addCodecSizePrefix: () => addCodecSizePrefix,
  addCodecSentinel: () => addCodecSentinel,
  TRANSACTION_SIZE_LIMIT: () => TRANSACTION_SIZE_LIMIT,
  TRANSACTION_PACKET_SIZE: () => TRANSACTION_PACKET_SIZE,
  TRANSACTION_PACKET_HEADER: () => TRANSACTION_PACKET_HEADER,
  SolanaError: () => SolanaError2,
  SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE: () => SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE2,
  SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_NOT_SUPPORTED: () => SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_NOT_SUPPORTED2,
  SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING: () => SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING2,
  SOLANA_ERROR__TRANSACTION__NONCE_ACCOUNT_CANNOT_BE_IN_LOOKUP_TABLE: () => SOLANA_ERROR__TRANSACTION__NONCE_ACCOUNT_CANNOT_BE_IN_LOOKUP_TABLE2,
  SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH: () => SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH2,
  SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE: () => SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE2,
  SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES: () => SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES2,
  SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING: () => SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING2,
  SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE: () => SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE2,
  SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING: () => SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING2,
  SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING: () => SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING2,
  SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT: () => SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT2,
  SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT: () => SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT2,
  SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND: () => SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND2,
  SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING: () => SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING2,
  SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE: () => SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE2,
  SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING: () => SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING2,
  SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME: () => SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME2,
  SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME: () => SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME2,
  SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT: () => SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT2,
  SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES: () => SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES2,
  SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING: () => SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING2,
  SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION: () => SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION2,
  SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT: () => SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT2,
  SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT: () => SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT2,
  SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT: () => SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT2,
  SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT: () => SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT2,
  SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT: () => SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT2,
  SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION: () => SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION2,
  SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN: () => SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN2,
  SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION: () => SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION2,
  SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS: () => SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS2,
  SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE: () => SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE2,
  SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE: () => SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE2,
  SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED: () => SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED2,
  SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED: () => SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED2,
  SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND: () => SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND2,
  SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE: () => SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE2,
  SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED: () => SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED2,
  SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT: () => SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT2,
  SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT: () => SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT2,
  SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION: () => SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION2,
  SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT: () => SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT2,
  SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER: () => SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER2,
  SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX: () => SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX2,
  SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA: () => SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA2,
  SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX: () => SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX2,
  SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE: () => SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE2,
  SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT: () => SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT2,
  SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE: () => SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE2,
  SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION: () => SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION2,
  SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE: () => SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE2,
  SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP: () => SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP2,
  SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND: () => SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND2,
  SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED: () => SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED2,
  SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND: () => SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND2,
  SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND: () => SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND2,
  SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE: () => SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE2,
  SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE: () => SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE2,
  SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING: () => SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING2,
  SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE: () => SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE2,
  SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED: () => SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED2,
  SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED: () => SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED2,
  SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED: () => SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED2,
  SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED: () => SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED2,
  SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED: () => SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED2,
  SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT: () => SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT2,
  SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED: () => SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED2,
  SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY: () => SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY2,
  SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED: () => SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED2,
  SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING: () => SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING2,
  SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS: () => SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS2,
  SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER: () => SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER2,
  SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER: () => SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER2,
  SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER: () => SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER2,
  SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER: () => SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER2,
  SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER: () => SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER2,
  SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER: () => SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER2,
  SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER: () => SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER2,
  SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER: () => SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER2,
  SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS: () => SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS2,
  SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN: () => SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN2,
  SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR: () => SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR2,
  SOLANA_ERROR__RPC__INTEGER_OVERFLOW: () => SOLANA_ERROR__RPC__INTEGER_OVERFLOW2,
  SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD: () => SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD2,
  SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID: () => SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID2,
  SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT: () => SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT2,
  SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED: () => SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED2,
  SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED: () => SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED2,
  SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN: () => SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN2,
  SOLANA_ERROR__OFFCHAIN_MESSAGE__VERSION_NUMBER_NOT_SUPPORTED: () => SOLANA_ERROR__OFFCHAIN_MESSAGE__VERSION_NUMBER_NOT_SUPPORTED2,
  SOLANA_ERROR__OFFCHAIN_MESSAGE__UNEXPECTED_VERSION: () => SOLANA_ERROR__OFFCHAIN_MESSAGE__UNEXPECTED_VERSION2,
  SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURE_VERIFICATION_FAILURE: () => SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURE_VERIFICATION_FAILURE2,
  SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURES_MISSING: () => SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURES_MISSING2,
  SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATORIES_MUST_BE_UNIQUE: () => SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATORIES_MUST_BE_UNIQUE2,
  SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATORIES_MUST_BE_SORTED: () => SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATORIES_MUST_BE_SORTED2,
  SOLANA_ERROR__OFFCHAIN_MESSAGE__RESTRICTED_ASCII_BODY_CHARACTER_OUT_OF_RANGE: () => SOLANA_ERROR__OFFCHAIN_MESSAGE__RESTRICTED_ASCII_BODY_CHARACTER_OUT_OF_RANGE2,
  SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_SIGNATURES_MISMATCH: () => SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_SIGNATURES_MISMATCH2,
  SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO: () => SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO2,
  SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_ENVELOPE_SIGNATURES_CANNOT_BE_ZERO: () => SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_ENVELOPE_SIGNATURES_CANNOT_BE_ZERO2,
  SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_MUST_BE_NON_EMPTY: () => SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_MUST_BE_NON_EMPTY2,
  SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_LENGTH_MISMATCH: () => SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_LENGTH_MISMATCH2,
  SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_FORMAT_MISMATCH: () => SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_FORMAT_MISMATCH2,
  SOLANA_ERROR__OFFCHAIN_MESSAGE__MAXIMUM_LENGTH_EXCEEDED: () => SOLANA_ERROR__OFFCHAIN_MESSAGE__MAXIMUM_LENGTH_EXCEEDED2,
  SOLANA_ERROR__OFFCHAIN_MESSAGE__INVALID_APPLICATION_DOMAIN_BYTE_LENGTH: () => SOLANA_ERROR__OFFCHAIN_MESSAGE__INVALID_APPLICATION_DOMAIN_BYTE_LENGTH2,
  SOLANA_ERROR__OFFCHAIN_MESSAGE__ENVELOPE_SIGNERS_MISMATCH: () => SOLANA_ERROR__OFFCHAIN_MESSAGE__ENVELOPE_SIGNERS_MISMATCH2,
  SOLANA_ERROR__OFFCHAIN_MESSAGE__APPLICATION_DOMAIN_STRING_LENGTH_OUT_OF_RANGE: () => SOLANA_ERROR__OFFCHAIN_MESSAGE__APPLICATION_DOMAIN_STRING_LENGTH_OUT_OF_RANGE2,
  SOLANA_ERROR__OFFCHAIN_MESSAGE__ADDRESSES_CANNOT_SIGN_OFFCHAIN_MESSAGE: () => SOLANA_ERROR__OFFCHAIN_MESSAGE__ADDRESSES_CANNOT_SIGN_OFFCHAIN_MESSAGE2,
  SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND: () => SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND2,
  SOLANA_ERROR__MALFORMED_NUMBER_STRING: () => SOLANA_ERROR__MALFORMED_NUMBER_STRING2,
  SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR: () => SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR2,
  SOLANA_ERROR__MALFORMED_BIGINT_STRING: () => SOLANA_ERROR__MALFORMED_BIGINT_STRING2,
  SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE: () => SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE2,
  SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE: () => SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE2,
  SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY: () => SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY2,
  SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH: () => SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH2,
  SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH: () => SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH2,
  SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH: () => SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH2,
  SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION: () => SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION2,
  SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE: () => SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE2,
  SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH: () => SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH2,
  SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE: () => SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE2,
  SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE: () => SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE2,
  SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED: () => SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED2,
  SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_NOT_EPOCH_BOUNDARY: () => SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_NOT_EPOCH_BOUNDARY2,
  SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE: () => SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE2,
  SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT: () => SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT2,
  SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY: () => SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY2,
  SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED: () => SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED2,
  SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_UNREACHABLE: () => SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_UNREACHABLE2,
  SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED: () => SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED2,
  SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX: () => SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX2,
  SOLANA_ERROR__JSON_RPC__SERVER_ERROR_EPOCH_REWARDS_PERIOD_ACTIVE: () => SOLANA_ERROR__JSON_RPC__SERVER_ERROR_EPOCH_REWARDS_PERIOD_ACTIVE2,
  SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET: () => SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET2,
  SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE: () => SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE2,
  SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP: () => SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP2,
  SOLANA_ERROR__JSON_RPC__SCAN_ERROR: () => SOLANA_ERROR__JSON_RPC__SCAN_ERROR2,
  SOLANA_ERROR__JSON_RPC__PARSE_ERROR: () => SOLANA_ERROR__JSON_RPC__PARSE_ERROR2,
  SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND: () => SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND2,
  SOLANA_ERROR__JSON_RPC__INVALID_REQUEST: () => SOLANA_ERROR__JSON_RPC__INVALID_REQUEST2,
  SOLANA_ERROR__JSON_RPC__INVALID_PARAMS: () => SOLANA_ERROR__JSON_RPC__INVALID_PARAMS2,
  SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR: () => SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR2,
  SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE: () => SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE2,
  SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING: () => SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING2,
  SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE: () => SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE2,
  SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_TRANSACTION_PLAN_KIND: () => SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_TRANSACTION_PLAN_KIND2,
  SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_INSTRUCTION_PLAN_KIND: () => SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_INSTRUCTION_PLAN_KIND2,
  SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED: () => SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED2,
  SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING: () => SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING2,
  SOLANA_ERROR__INVALID_NONCE: () => SOLANA_ERROR__INVALID_NONCE2,
  SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH: () => SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH2,
  SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH: () => SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH2,
  SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA: () => SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA2,
  SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS: () => SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS2,
  SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_PACKER_ALREADY_COMPLETE: () => SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_PACKER_ALREADY_COMPLETE2,
  SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN: () => SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN2,
  SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_TO_EXECUTE_TRANSACTION_PLAN: () => SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_TO_EXECUTE_TRANSACTION_PLAN2,
  SOLANA_ERROR__INSTRUCTION_PLANS__EMPTY_INSTRUCTION_PLAN: () => SOLANA_ERROR__INSTRUCTION_PLANS__EMPTY_INSTRUCTION_PLAN2,
  SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR: () => SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR2,
  SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID: () => SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID2,
  SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN: () => SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN2,
  SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT: () => SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT2,
  SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION: () => SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION2,
  SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED: () => SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED2,
  SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED: () => SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED2,
  SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE: () => SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE2,
  SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED: () => SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED2,
  SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE: () => SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE2,
  SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE: () => SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE2,
  SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE: () => SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE2,
  SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION: () => SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION2,
  SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS: () => SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS2,
  SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID: () => SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID2,
  SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE: () => SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE2,
  SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT: () => SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT2,
  SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED: () => SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED2,
  SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED: () => SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED2,
  SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED: () => SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED2,
  SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED: () => SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED2,
  SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS: () => SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS2,
  SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC: () => SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC2,
  SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA: () => SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA2,
  SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR: () => SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR2,
  SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT: () => SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT2,
  SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER: () => SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER2,
  SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA: () => SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA2,
  SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS: () => SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS2,
  SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID: () => SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID2,
  SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY: () => SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY2,
  SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE: () => SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE2,
  SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER: () => SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER2,
  SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR: () => SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR2,
  SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND: () => SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND2,
  SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED: () => SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED2,
  SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED: () => SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED2,
  SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE: () => SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE2,
  SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED: () => SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED2,
  SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT: () => SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT2,
  SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC: () => SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC2,
  SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX: () => SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX2,
  SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM: () => SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM2,
  SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED: () => SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED2,
  SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH: () => SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH2,
  SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS: () => SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS2,
  SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR: () => SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR2,
  SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW: () => SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW2,
  SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT: () => SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT2,
  SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE: () => SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE2,
  SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL: () => SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL2,
  SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED: () => SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED2,
  SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING: () => SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING2,
  SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED: () => SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED2,
  SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED: () => SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED2,
  SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED: () => SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED2,
  SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE: () => SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE2,
  SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES: () => SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES2,
  SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE: () => SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE2,
  SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE: () => SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE2,
  SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE: () => SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE2,
  SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE: () => SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE2,
  SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS: () => SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS2,
  SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT: () => SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT2,
  SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT: () => SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT2,
  SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT: () => SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT2,
  SOLANA_ERROR__CODECS__INVALID_CONSTANT: () => SOLANA_ERROR__CODECS__INVALID_CONSTANT2,
  SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH: () => SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH2,
  SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE: () => SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE2,
  SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH: () => SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH2,
  SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH: () => SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH2,
  SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH: () => SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH2,
  SOLANA_ERROR__CODECS__EXPECTED_DECODER_TO_CONSUME_ENTIRE_BYTE_ARRAY: () => SOLANA_ERROR__CODECS__EXPECTED_DECODER_TO_CONSUME_ENTIRE_BYTE_ARRAY2,
  SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE: () => SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE2,
  SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH: () => SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH2,
  SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH: () => SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH2,
  SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH: () => SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH2,
  SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL: () => SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL2,
  SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS: () => SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS2,
  SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY: () => SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY2,
  SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED: () => SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED2,
  SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE: () => SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE2,
  SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE: () => SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE2,
  SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER: () => SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER2,
  SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE: () => SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE2,
  SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED: () => SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED2,
  SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED: () => SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED2,
  SOLANA_ERROR__ADDRESSES__MALFORMED_PDA: () => SOLANA_ERROR__ADDRESSES__MALFORMED_PDA2,
  SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE: () => SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE2,
  SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS: () => SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS2,
  SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY: () => SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY2,
  SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH: () => SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH2,
  SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS: () => SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS2,
  SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED: () => SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED2,
  SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND: () => SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND2,
  SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT: () => SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT2,
  SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT: () => SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT2,
  SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED: () => SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED2,
  SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND: () => SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND2,
  OffchainMessageContentFormat: () => OffchainMessageContentFormat,
  MAX_SUPPORTED_TRANSACTION_VERSION: () => MAX_SUPPORTED_TRANSACTION_VERSION,
  Endian: () => Endian,
  DEFAULT_RPC_SUBSCRIPTIONS_CONFIG: () => DEFAULT_RPC_SUBSCRIPTIONS_CONFIG,
  DEFAULT_RPC_CONFIG: () => DEFAULT_RPC_CONFIG,
  BASE_ACCOUNT_SIZE: () => BASE_ACCOUNT_SIZE,
  AccountRole: () => AccountRole
});
async function requestAndConfirmAirdrop_INTERNAL_ONLY_DO_NOT_EXPORT({
  abortSignal,
  commitment,
  confirmSignatureOnlyTransaction,
  lamports: lamports2,
  recipientAddress,
  rpc: rpc2
}) {
  const airdropTransactionSignature = await rpc2.requestAirdrop(recipientAddress, lamports2, { commitment }).send({ abortSignal });
  await confirmSignatureOnlyTransaction({
    abortSignal,
    commitment,
    signature: airdropTransactionSignature
  });
  return airdropTransactionSignature;
}
function airdropFactory({
  rpc: rpc2,
  rpcSubscriptions
}) {
  const getRecentSignatureConfirmationPromise = createRecentSignatureConfirmationPromiseFactory({
    rpc: rpc2,
    rpcSubscriptions
  });
  async function confirmSignatureOnlyTransaction(config) {
    await waitForRecentTransactionConfirmationUntilTimeout({
      ...config,
      getRecentSignatureConfirmationPromise,
      getTimeoutPromise
    });
  }
  return async function airdrop(config) {
    return await requestAndConfirmAirdrop_INTERNAL_ONLY_DO_NOT_EXPORT({
      ...config,
      confirmSignatureOnlyTransaction,
      rpc: rpc2
    });
  };
}
async function fetchAddressesForLookupTables(lookupTableAddresses, rpc2, config) {
  if (lookupTableAddresses.length === 0) {
    return {};
  }
  const fetchedLookupTables = await fetchJsonParsedAccounts(rpc2, lookupTableAddresses, config);
  assertAccountsDecoded(fetchedLookupTables);
  assertAccountsExist(fetchedLookupTables);
  return fetchedLookupTables.reduce((acc, lookup) => {
    return {
      ...acc,
      [lookup.address]: lookup.data.addresses
    };
  }, {});
}
async function decompileTransactionMessageFetchingLookupTables(compiledTransactionMessage, rpc2, config) {
  const lookupTables = "addressTableLookups" in compiledTransactionMessage && compiledTransactionMessage.addressTableLookups !== undefined && compiledTransactionMessage.addressTableLookups.length > 0 ? compiledTransactionMessage.addressTableLookups : [];
  const lookupTableAddresses = lookupTables.map((l2) => l2.lookupTableAddress);
  const { lastValidBlockHeight, ...fetchAccountsConfig } = config ?? {};
  const addressesByLookupTableAddress = lookupTableAddresses.length > 0 ? await fetchAddressesForLookupTables(lookupTableAddresses, rpc2, fetchAccountsConfig) : {};
  return decompileTransactionMessage(compiledTransactionMessage, {
    addressesByLookupTableAddress,
    lastValidBlockHeight
  });
}
function getSendTransactionConfigWithAdjustedPreflightCommitment(commitment, config) {
  if (!config?.preflightCommitment && commitmentComparator(commitment, "finalized") < 0) {
    return {
      ...config,
      preflightCommitment: commitment
    };
  }
  return config;
}
async function sendTransaction_INTERNAL_ONLY_DO_NOT_EXPORT({
  abortSignal,
  commitment,
  rpc: rpc2,
  transaction,
  ...sendTransactionConfig
}) {
  const base64EncodedWireTransaction = getBase64EncodedWireTransaction(transaction);
  return await rpc2.sendTransaction(base64EncodedWireTransaction, {
    ...getSendTransactionConfigWithAdjustedPreflightCommitment(commitment, sendTransactionConfig),
    encoding: "base64"
  }).send({ abortSignal });
}
async function sendAndConfirmDurableNonceTransaction_INTERNAL_ONLY_DO_NOT_EXPORT({
  abortSignal,
  commitment,
  confirmDurableNonceTransaction,
  rpc: rpc2,
  transaction,
  ...sendTransactionConfig
}) {
  const transactionSignature = await sendTransaction_INTERNAL_ONLY_DO_NOT_EXPORT({
    ...sendTransactionConfig,
    abortSignal,
    commitment,
    rpc: rpc2,
    transaction
  });
  await confirmDurableNonceTransaction({
    abortSignal,
    commitment,
    transaction
  });
  return transactionSignature;
}
async function sendAndConfirmTransactionWithBlockhashLifetime_INTERNAL_ONLY_DO_NOT_EXPORT({
  abortSignal,
  commitment,
  confirmRecentTransaction,
  rpc: rpc2,
  transaction,
  ...sendTransactionConfig
}) {
  const transactionSignature = await sendTransaction_INTERNAL_ONLY_DO_NOT_EXPORT({
    ...sendTransactionConfig,
    abortSignal,
    commitment,
    rpc: rpc2,
    transaction
  });
  await confirmRecentTransaction({
    abortSignal,
    commitment,
    transaction
  });
  return transactionSignature;
}
function sendAndConfirmDurableNonceTransactionFactory({
  rpc: rpc2,
  rpcSubscriptions
}) {
  const getNonceInvalidationPromise = createNonceInvalidationPromiseFactory({ rpc: rpc2, rpcSubscriptions });
  const getRecentSignatureConfirmationPromise = createRecentSignatureConfirmationPromiseFactory({
    rpc: rpc2,
    rpcSubscriptions
  });
  async function confirmDurableNonceTransaction(config) {
    await waitForDurableNonceTransactionConfirmation({
      ...config,
      getNonceInvalidationPromise,
      getRecentSignatureConfirmationPromise
    });
  }
  return async function sendAndConfirmDurableNonceTransaction(transaction, config) {
    await sendAndConfirmDurableNonceTransaction_INTERNAL_ONLY_DO_NOT_EXPORT({
      ...config,
      confirmDurableNonceTransaction,
      rpc: rpc2,
      transaction
    });
  };
}
function sendAndConfirmTransactionFactory({
  rpc: rpc2,
  rpcSubscriptions
}) {
  const getBlockHeightExceedencePromise = createBlockHeightExceedencePromiseFactory({
    rpc: rpc2,
    rpcSubscriptions
  });
  const getRecentSignatureConfirmationPromise = createRecentSignatureConfirmationPromiseFactory({
    rpc: rpc2,
    rpcSubscriptions
  });
  async function confirmRecentTransaction(config) {
    await waitForRecentTransactionConfirmation({
      ...config,
      getBlockHeightExceedencePromise,
      getRecentSignatureConfirmationPromise
    });
  }
  return async function sendAndConfirmTransaction(transaction, config) {
    await sendAndConfirmTransactionWithBlockhashLifetime_INTERNAL_ONLY_DO_NOT_EXPORT({
      ...config,
      confirmRecentTransaction,
      rpc: rpc2,
      transaction
    });
  };
}
function sendTransactionWithoutConfirmingFactory({
  rpc: rpc2
}) {
  return async function sendTransactionWithoutConfirming(transaction, config) {
    await sendTransaction_INTERNAL_ONLY_DO_NOT_EXPORT({
      ...config,
      rpc: rpc2,
      transaction
    });
  };
}
var init_index_node40 = __esm(() => {
  init_index_node9();
  init_index_node18();
  init_index_node19();
  init_index_node21();
  init_index_node39();
  init_index_node26();
  init_index_node9();
  init_index_node11();
  init_index_node15();
  init_index_node6();
  init_index_node16();
  init_index_node17();
  init_index_node23();
  init_index_node20();
  init_index_node24();
  init_index_node25();
  init_index_node32();
  init_index_node37();
  init_index_node18();
  init_index_node38();
  init_index_node19();
  init_index_node21();
});

// ../../node_modules/.bun/gill@0.14.0+404aed4d36763349/node_modules/gill/dist/chunk-332VYOUG.node.mjs
function debug(message, level = "info", prefix = "[GILL]") {
  if (!isDebugEnabled())
    return;
  if (GILL_LOG_LEVELS[level] < GILL_LOG_LEVELS[getMinLogLevel()])
    return;
  const formattedMessage = typeof message === "string" ? message : JSON.stringify(message, null, 2);
  switch (level) {
    case "debug":
      console.log(prefix, formattedMessage);
      break;
    case "info":
      console.info(prefix, formattedMessage);
      break;
    case "warn":
      console.warn(prefix, formattedMessage);
      break;
    case "error":
      console.error(prefix, formattedMessage);
      break;
  }
}
function getPublicSolanaRpcUrl(cluster) {
  switch (cluster) {
    case "devnet":
      return "https://api.devnet.solana.com";
    case "testnet":
      return "https://api.testnet.solana.com";
    case "mainnet-beta":
    case "mainnet":
      return "https://api.mainnet-beta.solana.com";
    case "localnet":
    case "localhost":
      return "http://127.0.0.1:8899";
    default:
      throw new Error("Invalid cluster moniker");
  }
}
function getExplorerLink(props = {}) {
  let url = new URL("https://explorer.solana.com");
  if (!props.cluster || props.cluster == "mainnet")
    props.cluster = "mainnet-beta";
  if ("address" in props) {
    url.pathname = `/address/${props.address}`;
  } else if ("transaction" in props) {
    url.pathname = `/tx/${props.transaction}`;
  } else if ("block" in props) {
    url.pathname = `/block/${props.block}`;
  }
  if (props.cluster !== "mainnet-beta") {
    if (props.cluster === "localnet" || props.cluster === "localhost") {
      url.searchParams.set("cluster", "custom");
      url.searchParams.set("customUrl", "http://localhost:8899");
    } else {
      url.searchParams.set("cluster", props.cluster);
    }
  }
  return url.toString();
}
function sendAndConfirmTransactionWithSignersFactory({
  rpc: rpc2,
  rpcSubscriptions
}) {
  const sendAndConfirmTransaction = sendAndConfirmTransactionFactory({ rpc: rpc2, rpcSubscriptions });
  return async function sendAndConfirmTransactionWithSigners(transaction, config = { commitment: "confirmed" }) {
    let signedTransaction;
    if ("messageBytes" in transaction === false) {
      if ("lifetimeConstraint" in transaction === false) {
        const { value: latestBlockhash } = await rpc2.getLatestBlockhash().send({ abortSignal: config.abortSignal });
        transaction = setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, transaction);
        assertIsTransactionMessageWithBlockhashLifetime(transaction);
      }
      if ("feePayer" in transaction === false) {
        throw new Error("Transaction must have a fee payer");
      }
      signedTransaction = await signTransactionMessageWithSigners(transaction);
    }
    if (!signedTransaction) {
      signedTransaction = transaction;
    }
    assertIsTransactionWithBlockhashLifetime(signedTransaction);
    assertIsTransactionWithinSizeLimit(signedTransaction);
    assertIsFullySignedTransaction(signedTransaction);
    assertIsSendableTransaction(signedTransaction);
    debug(`Sending transaction: ${getExplorerLink({ transaction: getSignatureFromTransaction(signedTransaction) })}`);
    debug(`Transaction as base64: ${getBase64EncodedWireTransaction(signedTransaction)}`, "debug");
    await sendAndConfirmTransaction(signedTransaction, config);
    return getSignatureFromTransaction(signedTransaction);
  };
}
function simulateTransactionFactory({ rpc: rpc2 }) {
  return async function simulateTransaction(transaction, config) {
    if ("messageBytes" in transaction == false) {
      transaction = await partiallySignTransactionMessageWithSigners(transaction);
    }
    return rpc2.simulateTransaction(getBase64EncodedWireTransaction(transaction), {
      replaceRecentBlockhash: true,
      ...config,
      sigVerify: false,
      encoding: "base64"
    }).send();
  };
}
function createSolanaClient({
  urlOrMoniker,
  rpcConfig,
  rpcSubscriptionsConfig
}) {
  if (!urlOrMoniker)
    throw new Error("Cluster url or moniker is required");
  if (urlOrMoniker instanceof URL == false) {
    try {
      urlOrMoniker = new URL(urlOrMoniker.toString());
    } catch (err) {
      try {
        urlOrMoniker = new URL(getPublicSolanaRpcUrl(urlOrMoniker.toString()));
      } catch (err2) {
        throw new Error("Invalid URL or cluster moniker");
      }
    }
  }
  if (!urlOrMoniker.protocol.match(/^https?/i)) {
    throw new Error("Unsupported protocol. Only HTTP and HTTPS are supported");
  }
  if (rpcConfig?.port) {
    urlOrMoniker.port = rpcConfig.port.toString();
  }
  const rpc2 = createSolanaRpc(urlOrMoniker.toString(), rpcConfig);
  urlOrMoniker.protocol = urlOrMoniker.protocol.replace("http", "ws");
  if (rpcSubscriptionsConfig?.port) {
    urlOrMoniker.port = rpcSubscriptionsConfig.port.toString();
  } else if (urlOrMoniker.hostname == "localhost" || urlOrMoniker.hostname.startsWith("127")) {
    urlOrMoniker.port = "8900";
  }
  const rpcSubscriptions = createSolanaRpcSubscriptions(urlOrMoniker.toString(), rpcSubscriptionsConfig);
  return {
    rpc: rpc2,
    rpcSubscriptions,
    sendAndConfirmTransaction: sendAndConfirmTransactionWithSignersFactory({
      rpc: rpc2,
      rpcSubscriptions
    }),
    simulateTransaction: simulateTransactionFactory({ rpc: rpc2 }),
    urlOrMoniker: urlOrMoniker.toString()
  };
}
var GILL_LOG_LEVELS, getMinLogLevel = () => process.env.GILL_DEBUG_LEVEL || global.__GILL_DEBUG_LEVEL__ || typeof window !== "undefined" && window.__GILL_DEBUG_LEVEL__ || "info", isDebugEnabled = () => Boolean(process.env.GILL_DEBUG_LEVEL || global.__GILL_DEBUG_LEVEL__ || process.env.GILL_DEBUG === "true" || process.env.GILL_DEBUG === "1" || global.__GILL_DEBUG__ === true || typeof window !== "undefined" && window.__GILL_DEBUG__ === true);
var init_chunk_332VYOUG_node = __esm(() => {
  init_index_node40();
  GILL_LOG_LEVELS = {
    debug: 0,
    info: 1,
    warn: 2,
    error: 3
  };
});

// ../../node_modules/.bun/gill@0.14.0+404aed4d36763349/node_modules/gill/dist/index.node.mjs
var init_index_node41 = __esm(() => {
  init_chunk_332VYOUG_node();
  init_index_node40();
});

// ../sdk-typescript/dist/chunk-CO2WD4XR.js
function isIPFSUploadResponse(data) {
  if (typeof data !== "object" || data === null)
    return false;
  const obj = data;
  return typeof obj.IpfsHash === "string";
}
function createSolanaClient2(config) {
  return createSolanaClient({ urlOrMoniker: config.urlOrMoniker });
}
function isKnownInstruction(instructionName) {
  return instructionName in instructionAccountMappings;
}
function validateInstructionAccounts(instructionName, providedAccounts, accountNames) {
  const mapping = getInstructionMapping(instructionName);
  if (!mapping) {
    throw new InstructionValidationError(instructionName, 0, providedAccounts.length, `Unknown instruction: ${instructionName}. This instruction may not exist in the current IDL or may be misspelled.`);
  }
  if (providedAccounts.length !== mapping.expectedAccounts.length) {
    const errorMessage = generateAccountValidationError(instructionName, providedAccounts.length, accountNames);
    throw new InstructionValidationError(instructionName, mapping.expectedAccounts.length, providedAccounts.length, errorMessage, mapping.expectedAccounts);
  }
}
function createAccountMismatchError(instructionName, providedCount, providedAccountNames) {
  const mapping = getInstructionMapping(instructionName);
  if (!mapping) {
    return `Unknown instruction: ${instructionName}`;
  }
  if (providedCount === mapping.expectedAccounts.length) {
    return `Accounts are correctly provided for ${instructionName}`;
  }
  let error = `âŒ Account validation failed for "${instructionName}"

`;
  error += `\uD83D\uDCCA Expected: ${mapping.expectedAccounts.length} accounts
`;
  error += `\uD83D\uDCCA Provided: ${providedCount} accounts

`;
  error += `\uD83D\uDCCB Required accounts:
`;
  mapping.expectedAccounts.forEach((account, index) => {
    const attributes = [];
    if (account.pda)
      attributes.push("PDA");
    const attrStr = attributes.length > 0 ? ` (${attributes.join(", ")})` : "";
    error += `  ${index + 1}. ${account.name}${attrStr}
`;
  });
  if (providedAccountNames && providedAccountNames.length > 0) {
    error += `
\uD83D\uDCCB Provided accounts:
`;
    providedAccountNames.forEach((name, index) => {
      error += `  ${index + 1}. ${name}
`;
    });
  }
  if (mapping.docs) {
    error += `
\uD83D\uDCD6 Description: ${mapping.docs}
`;
  }
  error += `
\uD83D\uDCA1 Tip: Make sure all required accounts are provided in the correct order.`;
  return error;
}
function getAccountRequirements(instructionName) {
  const mapping = getInstructionMapping(instructionName);
  if (!mapping) {
    return `Unknown instruction: ${instructionName}`;
  }
  let requirements = `${instructionName} requires ${mapping.expectedAccounts.length} accounts:

`;
  mapping.expectedAccounts.forEach((account, index) => {
    const attributes = [];
    if (account.pda)
      attributes.push("PDA-derived");
    const attrStr = attributes.length > 0 ? ` [${attributes.join(", ")}]` : "";
    requirements += `  ${index + 1}. ${account.name}${attrStr}
`;
  });
  if (mapping.docs) {
    requirements += `
Description: ${mapping.docs}
`;
  }
  return requirements;
}
function getInstructionMapping(instructionName) {
  return instructionAccountMappings[instructionName] ?? null;
}
function generateAccountValidationError(instructionName, providedCount, accountNames) {
  const mapping = getInstructionMapping(instructionName);
  if (!mapping) {
    return `Unknown instruction: ${instructionName}`;
  }
  let error = `Account mismatch for ${instructionName}: expected ${mapping.expectedAccounts.length} accounts, got ${providedCount}`;
  if (accountNames) {
    error += `. Provided: ${accountNames.join(", ")}`;
  }
  return error;
}
function enhanceErrorMessage(error, context) {
  return `${error.message}

Context: ${context}`;
}
function debugInstructionCall(instructionName, accounts2) {
  return `Instruction: ${instructionName}
Accounts: ${accounts2.length}
Mapping: ${JSON.stringify(getInstructionMapping(instructionName), null, 2)}`;
}
function getRequiredSigners(instructionName) {
  const mapping = getInstructionMapping(instructionName);
  if (!mapping)
    return [];
  return mapping.expectedAccounts.filter((account) => account.name.includes("authority") || account.name.includes("signer")).map((account) => account.name);
}
function getWritableAccounts(instructionName) {
  const mapping = getInstructionMapping(instructionName);
  if (!mapping)
    return [];
  return mapping.expectedAccounts.filter((account) => account.pda || account.name.includes("data") || account.name.includes("account")).map((account) => account.name);
}
function getPDAAccounts(instructionName) {
  const mapping = getInstructionMapping(instructionName);
  if (!mapping)
    return [];
  return mapping.expectedAccounts.filter((account) => account.pda).map((account) => account.name);
}
async function withEnhancedErrors(operation, instructionName, fn, debugAccounts) {
  try {
    if (debugAccounts && instructionName) {
      debugInstructionCall(instructionName, debugAccounts);
    }
    return await fn();
  } catch (error) {
    if (error instanceof Error) {
      throw new GhostSpeakSDKError(operation, error, instructionName);
    }
    throw error;
  }
}
function withEnhancedErrorsSync(operation, instructionName, fn, debugAccounts) {
  try {
    if (debugAccounts && instructionName) {
      debugInstructionCall(instructionName, debugAccounts);
    }
    return fn();
  } catch (error) {
    if (error instanceof Error) {
      throw new GhostSpeakSDKError(operation, error, instructionName);
    }
    throw error;
  }
}
function enhanceTransactionError(error, instructionName, accounts2) {
  const message = error.message;
  if (message.includes("custom program error")) {
    const enhancedMessage = `${message}

Instruction: ${instructionName ?? "unknown"}`;
    if (accounts2 && instructionName) {
      const debugInfo = `
Accounts provided: ${accounts2.length}`;
      return new Error(enhancedMessage + debugInfo);
    }
    return new Error(enhancedMessage);
  }
  if (message.includes("insufficient") || message.includes("account") || message.includes("signer") || message.includes("writable")) {
    return new Error(enhanceErrorMessage(error, instructionName ?? "unknown"));
  }
  return error;
}
function logEnhancedError(error, context) {
  console.error("\uD83D\uDEA8 GhostSpeak SDK Error:", error.message);
  if (context) {
    if (context.operation) {
      console.error("\uD83D\uDD27 Operation:", context.operation);
    }
    if (context.instructionName) {
      console.error("\uD83D\uDCCB Instruction:", context.instructionName);
    }
    if (context.accounts) {
      console.error("\uD83C\uDFE6 Accounts provided:", context.accounts.length);
      context.accounts.forEach((account, index) => {
        if (typeof account === "string") {
          console.error(`  ${index + 1}. ${account}`);
        } else if (typeof account === "object") {
          const addr = "address" in account ? account.address : account;
          const name = "name" in account ? account.name : undefined;
          console.error(`  ${index + 1}. ${addr}${name ? ` (${name})` : ""}`);
        } else {
          console.error(`  ${index + 1}. ${String(account)}`);
        }
      });
    }
    if (context.params) {
      console.error("âš™ï¸ Parameters:", context.params);
    }
  }
  console.error(`
\uD83D\uDCA1 Troubleshooting tips:`);
  console.error("  1. Check that all required accounts are provided");
  console.error("  2. Verify account addresses are correct");
  console.error("  3. Ensure signers have sufficient SOL for transaction fees");
  console.error("  4. Confirm the program is deployed on the target network");
}
function createErrorContext(operation, instructionName, accounts2, params) {
  return {
    operation,
    instructionName,
    accounts: accounts2,
    params
  };
}
function validatePreconditions(checks) {
  for (const check of checks) {
    if (!check.condition) {
      const error = new Error(check.message);
      const enhanced = enhanceErrorMessage(error, check.instructionName ?? "unknown");
      throw new Error(enhanced);
    }
  }
}
function extractInstructionName(operation) {
  const operationToInstruction = {
    register_agent: "register_agent",
    registerAgent: "register_agent",
    activate_agent: "activate_agent",
    activateAgent: "activate_agent",
    update_agent: "update_agent",
    updateAgent: "update_agent",
    create_service_listing: "create_service_listing",
    createServiceListing: "create_service_listing",
    create_escrow: "create_escrow",
    createEscrow: "create_escrow",
    complete_escrow: "complete_escrow",
    completeEscrow: "complete_escrow",
    create_job_posting: "create_job_posting",
    createJobPosting: "create_job_posting",
    apply_to_job: "apply_to_job",
    applyToJob: "apply_to_job",
    submit_work_delivery: "submit_work_delivery",
    submitWorkDelivery: "submit_work_delivery",
    verify_work_delivery: "verify_work_delivery",
    verifyWorkDelivery: "verify_work_delivery",
    reject_work_delivery: "reject_work_delivery",
    rejectWorkDelivery: "reject_work_delivery",
    create_work_order: "create_work_order",
    createWorkOrder: "create_work_order",
    create_channel: "create_channel",
    createChannel: "create_channel",
    send_message: "send_message",
    sendMessage: "send_message",
    file_dispute: "file_dispute",
    fileDispute: "file_dispute",
    resolve_dispute: "resolve_dispute",
    resolveDispute: "resolve_dispute"
  };
  return operationToInstruction[operation];
}
var TagCategory, SkillTag, BehaviorTag, ComplianceTag, TAG_CONSTANTS, DEFAULT_TAG_DECAY, TagConfidenceLevel, init_reputation_tags, reputation_tag_engine_exports, ReputationTagEngine, init_reputation_tag_engine, PrivacyMode, VisibilityLevel, ScoreRange, PrivacyPresets, PRIVACY_CONSTANTS, GhostNotFoundError, ExternalIdNotFoundError, GhostSpeakError, instructionAccountMappings, InstructionValidationError, INSTRUCTION_MAPPINGS, GhostSpeakSDKError, ipfs_client_exports, sharedTestStorage, sharedUploadCount = 0, TestIPFSProvider = class {
  constructor(config) {
    this.config = config;
    console.log("\uD83E\uDDEA Initialized TestIPFSProvider for local testing (shared storage)");
  }
  storage = sharedTestStorage;
  uploadCount = 0;
  async upload(content, options2) {
    sharedUploadCount++;
    const contentStr = typeof content === "string" ? content : new TextDecoder().decode(content);
    const hash = `Qm${this.generateHash(contentStr)}_test_${sharedUploadCount}`;
    this.storage.set(hash, {
      content,
      pinned: options2?.pin !== false
    });
    const size = typeof content === "string" ? new TextEncoder().encode(content).length : content.length;
    console.log(`\uD83D\uDCE6 Test IPFS upload: ${hash} (${size} bytes)`);
    return {
      hash,
      uri: `ipfs://${hash}`,
      size,
      timestamp: Date.now(),
      pinned: options2?.pin !== false,
      gateways: [
        `http://localhost:8080/ipfs/${hash}`,
        `https://test.ipfs.io/ipfs/${hash}`
      ]
    };
  }
  async retrieve(hash) {
    const stored = this.storage.get(hash);
    if (!stored) {
      throw new Error(`Test IPFS: Content not found for hash ${hash}`);
    }
    console.log(`\uD83D\uDCE5 Test IPFS retrieve: ${hash}`);
    await new Promise((resolve) => setTimeout(resolve, 100));
    return stored.content;
  }
  async pin(hash) {
    const stored = this.storage.get(hash);
    if (!stored) {
      return {
        hash,
        success: false,
        status: "failed",
        error: `Content not found: ${hash}`
      };
    }
    stored.pinned = true;
    console.log(`\uD83D\uDCCC Test IPFS pin: ${hash}`);
    return {
      hash,
      success: true,
      status: "pinned"
    };
  }
  async unpin(hash) {
    const stored = this.storage.get(hash);
    if (!stored) {
      return {
        hash,
        success: false,
        status: "failed",
        error: `Content not found: ${hash}`
      };
    }
    stored.pinned = false;
    console.log(`\uD83D\uDCCC Test IPFS unpin: ${hash}`);
    return {
      hash,
      success: true,
      status: "pinned"
    };
  }
  generateHash(content) {
    let hash = 0;
    for (let i = 0;i < content.length; i++) {
      const char = content.charCodeAt(i);
      hash = (hash << 5) - hash + char;
      hash = hash & hash;
    }
    const chars = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    let result = "";
    let value = Math.abs(hash);
    while (value > 0 && result.length < 40) {
      result = chars[value % chars.length] + result;
      value = Math.floor(value / chars.length);
    }
    while (result.length < 40) {
      result = chars[Math.floor(Math.random() * chars.length)] + result;
    }
    return result;
  }
  getStats() {
    let totalSize = 0;
    let pinned = 0;
    for (const data of this.storage.values()) {
      const size = typeof data.content === "string" ? new TextEncoder().encode(data.content).length : data.content.length;
      totalSize += size;
      if (data.pinned)
        pinned++;
    }
    return {
      count: this.storage.size,
      totalSize,
      pinned
    };
  }
  clear() {
    this.storage.clear();
    sharedUploadCount = 0;
    console.log("\uD83E\uDDF9 Test IPFS storage cleared");
  }
  static getSharedStorage() {
    return sharedTestStorage;
  }
}, PinataProvider = class {
  constructor(config) {
    this.config = config;
  }
  async upload(content, options2) {
    const endpoint = this.config.endpoint ?? "https://api.pinata.cloud";
    const formData = new FormData;
    const blob = new Blob([content], {
      type: options2?.contentType ?? "application/octet-stream"
    });
    formData.append("file", blob, options2?.filename ?? "content");
    if (options2?.metadata) {
      formData.append("pinataMetadata", JSON.stringify({
        name: options2.filename ?? "ghostspeak-content",
        keyvalues: options2.metadata
      }));
    }
    const response = await fetch(`${endpoint}/pinning/pinFileToIPFS`, {
      method: "POST",
      headers: {
        Authorization: `Bearer ${this.config.jwt ?? this.config.apiKey}`,
        ...this.config.headers
      },
      body: formData
    });
    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Pinata upload failed: ${response.status} ${errorText}`);
    }
    const result = await response.json();
    const size = typeof content === "string" ? new TextEncoder().encode(content).length : content.length;
    if (!isIPFSUploadResponse(result)) {
      throw new Error("Invalid IPFS upload response format");
    }
    return {
      hash: result.IpfsHash,
      uri: `ipfs://${result.IpfsHash}`,
      size,
      timestamp: Date.now(),
      pinned: true,
      gateways: [
        `https://gateway.pinata.cloud/ipfs/${result.IpfsHash}`,
        `https://ipfs.io/ipfs/${result.IpfsHash}`
      ]
    };
  }
  async retrieve(hash, options2) {
    const gateway = options2?.gateway ?? "https://gateway.pinata.cloud";
    const url = `${gateway}/ipfs/${hash}`;
    const response = await fetch(url, {
      signal: options2?.timeout ? AbortSignal.timeout(options2.timeout) : undefined
    });
    if (!response.ok) {
      throw new Error(`Failed to retrieve from IPFS: ${response.status} ${response.statusText}`);
    }
    const contentType = response.headers.get("content-type");
    if (contentType?.startsWith("text/") || contentType?.includes("json")) {
      return response.text();
    } else {
      return new Uint8Array(await response.arrayBuffer());
    }
  }
  async pin(hash) {
    const endpoint = this.config.endpoint ?? "https://api.pinata.cloud";
    const response = await fetch(`${endpoint}/pinning/pinByHash`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${this.config.jwt ?? this.config.apiKey}`,
        ...this.config.headers
      },
      body: JSON.stringify({ hashToPin: hash })
    });
    const success = response.ok;
    return {
      hash,
      success,
      status: success ? "pinned" : "failed",
      error: success ? undefined : `Pin failed: ${response.status}`
    };
  }
  async unpin(hash) {
    const endpoint = this.config.endpoint ?? "https://api.pinata.cloud";
    const response = await fetch(`${endpoint}/pinning/unpin/${hash}`, {
      method: "DELETE",
      headers: {
        Authorization: `Bearer ${this.config.jwt ?? this.config.apiKey}`,
        ...this.config.headers
      }
    });
    const success = response.ok;
    return {
      hash,
      success,
      status: success ? "pinned" : "failed",
      error: success ? undefined : `Unpin failed: ${response.status}`
    };
  }
}, HttpClientProvider = class {
  constructor(config) {
    this.config = config;
  }
  async upload(content, options2) {
    const endpoint = this.config.endpoint ?? "http://localhost:5001";
    const formData = new FormData;
    const blob = new Blob([content], {
      type: options2?.contentType ?? "application/octet-stream"
    });
    formData.append("file", blob, options2?.filename ?? "content");
    const response = await fetch(`${endpoint}/api/v0/add`, {
      method: "POST",
      body: formData
    });
    if (!response.ok) {
      throw new Error(`IPFS HTTP upload failed: ${response.status}`);
    }
    const result = await response.json();
    const size = typeof content === "string" ? new TextEncoder().encode(content).length : content.length;
    if (typeof result !== "object" || result === null) {
      throw new Error("Invalid IPFS HTTP API response");
    }
    const ipfsResult = result;
    if (typeof ipfsResult.Hash !== "string") {
      throw new Error("IPFS HTTP API response missing Hash field");
    }
    const hash = ipfsResult.Hash;
    return {
      hash,
      uri: `ipfs://${hash}`,
      size,
      timestamp: Date.now(),
      pinned: options2?.pin !== false,
      gateways: [
        `${endpoint}/ipfs/${hash}`,
        `https://ipfs.io/ipfs/${hash}`
      ]
    };
  }
  async retrieve(hash, options2) {
    const gateway = options2?.gateway ?? this.config.endpoint?.replace("/api/v0", "") ?? "https://ipfs.io";
    const url = `${gateway}/ipfs/${hash}`;
    const response = await fetch(url, {
      signal: options2?.timeout ? AbortSignal.timeout(options2.timeout) : undefined
    });
    if (!response.ok) {
      throw new Error(`Failed to retrieve from IPFS: ${response.status}`);
    }
    const contentType = response.headers.get("content-type");
    if (contentType?.startsWith("text/") || contentType?.includes("json")) {
      return response.text();
    } else {
      return new Uint8Array(await response.arrayBuffer());
    }
  }
  async pin(hash) {
    const endpoint = this.config.endpoint ?? "http://localhost:5001";
    const response = await fetch(`${endpoint}/api/v0/pin/add?arg=${hash}`, {
      method: "POST"
    });
    const success = response.ok;
    return {
      hash,
      success,
      status: success ? "pinned" : "failed",
      error: success ? undefined : `Pin failed: ${response.status}`
    };
  }
  async unpin(hash) {
    const endpoint = this.config.endpoint ?? "http://localhost:5001";
    const response = await fetch(`${endpoint}/api/v0/pin/rm?arg=${hash}`, {
      method: "POST"
    });
    const success = response.ok;
    return {
      hash,
      success,
      status: success ? "pinned" : "failed",
      error: success ? undefined : `Unpin failed: ${response.status}`
    };
  }
}, IPFSClient = class {
  constructor(config) {
    this.config = config;
    this.initializeProviders();
  }
  providers = [];
  cache = /* @__PURE__ */ new Map;
  initializeProviders() {
    this.providers.push(this.createProvider(this.config.provider));
    if (this.config.fallbackProviders) {
      for (const providerConfig of this.config.fallbackProviders) {
        this.providers.push(this.createProvider(providerConfig));
      }
    }
  }
  createProvider(config) {
    switch (config.name) {
      case "pinata":
        return new PinataProvider(config);
      case "ipfs-http-client":
      case "custom":
        return new HttpClientProvider(config);
      case "test":
        return new TestIPFSProvider(config);
      default:
        throw new Error(`Unsupported IPFS provider: ${config.name}`);
    }
  }
  async upload(content, options2) {
    const startTime = Date.now();
    let lastError;
    for (let i = 0;i < this.providers.length; i++) {
      const provider = this.providers[i];
      try {
        console.log(`\uD83D\uDCE4 Attempting IPFS upload with provider ${i + 1}/${this.providers.length}`);
        const result = await this.withRetry(() => provider.upload(content, options2), this.config.maxRetries ?? 3, this.config.retryDelay ?? 1000);
        console.log(`âœ… IPFS upload successful: ${result.hash}`);
        return {
          success: true,
          data: result,
          duration: Date.now() - startTime,
          provider: this.config.provider.name
        };
      } catch (error) {
        console.warn(`âŒ Provider ${i + 1} upload failed:`, error instanceof Error ? error.message : String(error));
        lastError = error instanceof Error ? error : new Error(String(error));
      }
    }
    return {
      success: false,
      error: "UPLOAD_FAILED",
      message: `All providers failed. Last error: ${lastError?.message}`,
      duration: Date.now() - startTime
    };
  }
  async retrieve(hash, options2) {
    const startTime = Date.now();
    if (this.config.enableCache && options2?.cache !== false) {
      const cached = this.cache.get(hash);
      if (cached && Date.now() - cached.timestamp < (this.config.cacheTTL ?? 300000)) {
        return {
          success: true,
          data: {
            content: cached.content,
            size: typeof cached.content === "string" ? cached.content.length : cached.content.length,
            hash,
            gateway: "cache",
            fromCache: true
          },
          duration: Date.now() - startTime
        };
      }
    }
    let lastError;
    const gateways = options2?.gateway ? [options2.gateway] : this.config.gateways ?? ["https://ipfs.io"];
    for (const gateway of gateways) {
      for (const provider of this.providers) {
        try {
          const content = await this.withRetry(() => provider.retrieve(hash, { ...options2, gateway }), this.config.maxRetries ?? 3, this.config.retryDelay ?? 1000);
          if (this.config.enableCache) {
            this.cache.set(hash, { content, timestamp: Date.now() });
          }
          return {
            success: true,
            data: {
              content,
              size: typeof content === "string" ? content.length : content.length,
              hash,
              gateway,
              fromCache: false
            },
            duration: Date.now() - startTime
          };
        } catch (error) {
          lastError = error instanceof Error ? error : new Error(String(error));
        }
      }
    }
    return {
      success: false,
      error: "RETRIEVAL_FAILED",
      message: `Failed to retrieve from all gateways. Last error: ${lastError?.message}`,
      duration: Date.now() - startTime
    };
  }
  async pin(hash) {
    const startTime = Date.now();
    for (const provider of this.providers) {
      try {
        const result = await provider.pin(hash);
        return {
          success: result.success,
          data: result,
          duration: Date.now() - startTime
        };
      } catch (error) {
        console.warn("Pin attempt failed:", error);
      }
    }
    return {
      success: false,
      error: "PIN_FAILED",
      message: "All pin attempts failed",
      duration: Date.now() - startTime
    };
  }
  async storeContent(content, type, options2) {
    const contentSize = new TextEncoder().encode(content).length;
    const sizeThreshold = this.config.sizeThreshold ?? 800;
    const shouldUseIpfs = options2?.forceIpfs ?? contentSize > sizeThreshold;
    if (!shouldUseIpfs) {
      const dataUri = `data:application/json;base64,${btoa(content)}`;
      return {
        uri: dataUri,
        useIpfs: false,
        size: contentSize
      };
    }
    const uploadResult = await this.upload(content, options2);
    if (!uploadResult.success || !uploadResult.data) {
      throw new Error(`IPFS upload failed: ${uploadResult.message}`);
    }
    const ipfsMetadata = {
      type,
      originalSize: contentSize,
      ipfsHash: uploadResult.data.hash,
      encoding: "utf8",
      compression: "none",
      mimeType: "application/json",
      uploadedAt: uploadResult.data.timestamp,
      pinned: uploadResult.data.pinned,
      checksum: await this.calculateChecksum(content)
    };
    return {
      uri: uploadResult.data.uri,
      useIpfs: true,
      ipfsMetadata,
      size: contentSize
    };
  }
  async retrieveContent(uri) {
    if (uri.startsWith("data:")) {
      const base64Data = uri.split(",")[1];
      if (!base64Data) {
        throw new Error("Invalid data URI format");
      }
      return atob(base64Data);
    }
    if (uri.startsWith("ipfs://")) {
      const hash = uri.replace("ipfs://", "");
      const result = await this.retrieve(hash);
      if (!result.success || !result.data) {
        throw new Error(`Failed to retrieve IPFS content: ${result.message}`);
      }
      return typeof result.data.content === "string" ? result.data.content : new TextDecoder().decode(result.data.content);
    }
    throw new Error(`Unsupported URI format: ${uri}`);
  }
  async withRetry(operation, maxRetries, delay) {
    let lastError;
    for (let attempt = 0;attempt <= maxRetries; attempt++) {
      try {
        return await operation();
      } catch (error) {
        lastError = error instanceof Error ? error : new Error(String(error));
        if (attempt < maxRetries) {
          console.log(`â³ Retrying in ${delay}ms... (attempt ${attempt + 1}/${maxRetries})`);
          await new Promise((resolve) => setTimeout(resolve, delay));
        }
      }
    }
    throw lastError;
  }
  async calculateChecksum(content) {
    const encoder = new TextEncoder;
    const data = encoder.encode(content);
    const hashBuffer = await crypto.subtle.digest("SHA-256", data);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    return hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
  }
  clearCache() {
    this.cache.clear();
  }
  getCacheStats() {
    return {
      size: this.cache.size,
      keys: Array.from(this.cache.keys())
    };
  }
}, SYSTEM_PROGRAM_ADDRESS3, TOKEN_PROGRAM_ADDRESS, TOKEN_2022_PROGRAM_ADDRESS, ASSOCIATED_TOKEN_PROGRAM_ADDRESS, NATIVE_MINT_ADDRESS, ReputationTier2, BadgeType, REPUTATION_CONSTANTS, ReputationCalculator = class {
  fraudPatterns = [];
  constructor() {
    this.initializeFraudPatterns();
  }
  initializeFraudPatterns() {
    this.fraudPatterns = [
      {
        patternId: "sudden_spike",
        description: "Sudden spike in reputation without corresponding activity",
        riskScore: 80,
        detect: (data) => {
          if (data.performanceHistory.length < 2)
            return false;
          const recent = data.performanceHistory[data.performanceHistory.length - 1];
          const previous = data.performanceHistory[data.performanceHistory.length - 2];
          const spike = recent.score - previous.score;
          return spike > 2000 && recent.jobsCompleted === previous.jobsCompleted;
        }
      },
      {
        patternId: "perfect_scores_only",
        description: "All jobs have perfect scores (potential manipulation)",
        riskScore: 60,
        detect: (data) => {
          const recentJobs = data.performanceHistory.slice(-10);
          return recentJobs.length >= 5 && recentJobs.every((job) => job.avgQuality === 100);
        }
      },
      {
        patternId: "rapid_category_switching",
        description: "Rapid switching between unrelated categories",
        riskScore: 40,
        detect: (data) => {
          if (data.categoryReputations.length < 5)
            return false;
          const recentCategories = data.categoryReputations.sort((a, b) => b.lastActivity - a.lastActivity).slice(0, 5);
          const daysSinceOldest = (Date.now() / 1000 - recentCategories[4].lastActivity) / 86400;
          return daysSinceOldest < 7;
        }
      },
      {
        patternId: "dispute_pattern",
        description: "High dispute rate with suspicious resolution pattern",
        riskScore: 70,
        detect: (data) => {
          if (data.totalJobsCompleted < 10)
            return false;
          const disputeRate = data.disputesAgainst / data.totalJobsCompleted;
          const resolutionRate = data.disputesResolved / Math.max(1, data.disputesAgainst);
          return disputeRate > 0.3 && resolutionRate > 0.9;
        }
      },
      {
        patternId: "time_manipulation",
        description: "Completion times significantly below expected",
        riskScore: 50,
        detect: (data, job) => {
          return job.actualDuration < job.expectedDuration * 0.1;
        }
      }
    ];
  }
  calculateReputation(currentData, jobPerformance) {
    const decayedData = this.applyTimeDecay(currentData);
    const jobScore = this.calculateWeightedScore(decayedData.factors, jobPerformance);
    const categoryUpdate = this.updateCategoryReputation(decayedData.categoryReputations, jobPerformance, jobScore);
    const overallScore = this.calculateOverallScore(categoryUpdate.categories);
    const tier = this.getTierFromScore(overallScore);
    const newBadges = this.checkBadgeAchievements(decayedData, jobPerformance, overallScore);
    const fraudAnalysis = this.detectFraud(decayedData, jobPerformance);
    return {
      overallScore,
      jobScore,
      categoryScore: categoryUpdate.categoryScore,
      tier,
      newBadges,
      fraudDetected: fraudAnalysis.detected,
      fraudRiskScore: fraudAnalysis.riskScore
    };
  }
  applyTimeDecay(data) {
    const currentTime = Date.now() / 1000;
    const daysSinceUpdate = (currentTime - data.lastUpdated) / 86400;
    if (daysSinceUpdate <= 0)
      return data;
    const decayFactor = REPUTATION_CONSTANTS.REPUTATION_DECAY_RATE_BPS * daysSinceUpdate;
    const decayMultiplier = Math.max(0, 1e4 - decayFactor) / 1e4;
    const decayedOverallScore = Math.floor(data.overallScore * decayMultiplier);
    const decayedCategories = data.categoryReputations.map((category) => {
      const categoryDaysInactive = (currentTime - category.lastActivity) / 86400;
      const categoryDecay = REPUTATION_CONSTANTS.REPUTATION_DECAY_RATE_BPS * categoryDaysInactive;
      const categoryMultiplier = Math.max(0, 1e4 - categoryDecay) / 1e4;
      return {
        ...category,
        score: Math.floor(category.score * categoryMultiplier)
      };
    });
    return {
      ...data,
      overallScore: decayedOverallScore,
      categoryReputations: decayedCategories
    };
  }
  calculateWeightedScore(factors, jobPerformance) {
    const totalWeight = factors.completionWeight + factors.qualityWeight + factors.timelinessWeight + factors.satisfactionWeight + factors.disputeWeight;
    if (totalWeight !== 100) {
      throw new Error("Reputation factors must sum to 100");
    }
    const completionScore = jobPerformance.completed ? REPUTATION_CONSTANTS.MAX_REPUTATION_SCORE : 0;
    const qualityScore = jobPerformance.qualityRating * REPUTATION_CONSTANTS.MAX_REPUTATION_SCORE / 100;
    const timelinessScore = this.calculateTimelinessScore(jobPerformance.expectedDuration, jobPerformance.actualDuration);
    const satisfactionScore = jobPerformance.clientSatisfaction * REPUTATION_CONSTANTS.MAX_REPUTATION_SCORE / 100;
    const disputeScore = this.calculateDisputeScore(jobPerformance);
    const weightedScore = (completionScore * factors.completionWeight + qualityScore * factors.qualityWeight + timelinessScore * factors.timelinessWeight + satisfactionScore * factors.satisfactionWeight + disputeScore * factors.disputeWeight) / 100;
    return Math.min(weightedScore, REPUTATION_CONSTANTS.MAX_REPUTATION_SCORE);
  }
  calculateTimelinessScore(expectedDuration, actualDuration) {
    if (actualDuration <= expectedDuration) {
      return REPUTATION_CONSTANTS.MAX_REPUTATION_SCORE;
    }
    const delayRatio = (actualDuration - expectedDuration) * 1e4 / expectedDuration;
    if (delayRatio > 5000) {
      return 0;
    }
    return REPUTATION_CONSTANTS.MAX_REPUTATION_SCORE - REPUTATION_CONSTANTS.MAX_REPUTATION_SCORE * delayRatio / 1e4;
  }
  calculateDisputeScore(jobPerformance) {
    if (!jobPerformance.hadDispute) {
      return REPUTATION_CONSTANTS.MAX_REPUTATION_SCORE;
    }
    if (jobPerformance.disputeResolvedFavorably) {
      return REPUTATION_CONSTANTS.MAX_REPUTATION_SCORE / 2;
    }
    return 0;
  }
  updateCategoryReputation(categories, jobPerformance, jobScore) {
    const existingCategoryIndex = categories.findIndex((c) => c.category === jobPerformance.category);
    if (existingCategoryIndex !== -1) {
      const category = categories[existingCategoryIndex];
      const updatedCategory = {
        ...category,
        completedJobs: category.completedJobs + 1,
        qualitySum: category.qualitySum + jobPerformance.qualityRating,
        qualityCount: category.qualityCount + 1,
        totalEarnings: category.totalEarnings + jobPerformance.paymentAmount,
        lastActivity: Date.now() / 1000,
        score: Math.floor((category.score * 7 + jobScore * 3) / 10),
        avgCompletionTime: Math.floor((category.avgCompletionTime * category.completedJobs + jobPerformance.actualDuration) / (category.completedJobs + 1))
      };
      const newCategories = [...categories];
      newCategories[existingCategoryIndex] = updatedCategory;
      return { categories: newCategories, categoryScore: updatedCategory.score };
    } else {
      if (categories.length >= REPUTATION_CONSTANTS.MAX_REPUTATION_CATEGORIES) {
        throw new Error("Maximum reputation categories reached");
      }
      const newCategory = {
        category: jobPerformance.category,
        score: jobScore,
        completedJobs: 1,
        avgCompletionTime: jobPerformance.actualDuration,
        qualitySum: jobPerformance.qualityRating,
        qualityCount: 1,
        lastActivity: Date.now() / 1000,
        totalEarnings: jobPerformance.paymentAmount
      };
      return {
        categories: [...categories, newCategory],
        categoryScore: jobScore
      };
    }
  }
  calculateOverallScore(categories) {
    if (categories.length === 0)
      return 5000;
    let weightedSum = 0;
    let totalWeight = 0;
    for (const category of categories) {
      const weight = category.completedJobs;
      weightedSum += category.score * weight;
      totalWeight += weight;
    }
    return totalWeight > 0 ? Math.floor(weightedSum / totalWeight) : 5000;
  }
  getTierFromScore(score) {
    if (score >= REPUTATION_CONSTANTS.PLATINUM_TIER_THRESHOLD) {
      return "Platinum";
    } else if (score >= REPUTATION_CONSTANTS.GOLD_TIER_THRESHOLD) {
      return "Gold";
    } else if (score >= REPUTATION_CONSTANTS.SILVER_TIER_THRESHOLD) {
      return "Silver";
    } else if (score >= REPUTATION_CONSTANTS.BRONZE_TIER_THRESHOLD) {
      return "Bronze";
    } else {
      return "None";
    }
  }
  checkBadgeAchievements(data, jobPerformance, newScore) {
    const newBadges = [];
    const existingBadges = new Set(data.badges.map((b) => b.badgeType));
    const newTotalJobs = data.totalJobsCompleted + (jobPerformance.completed ? 1 : 0);
    if (!existingBadges.has("FirstJob") && newTotalJobs >= 1) {
      newBadges.push("FirstJob");
    }
    if (!existingBadges.has("TenJobs") && newTotalJobs >= 10) {
      newBadges.push("TenJobs");
    }
    if (!existingBadges.has("HundredJobs") && newTotalJobs >= 100) {
      newBadges.push("HundredJobs");
    }
    if (!existingBadges.has("ThousandJobs") && newTotalJobs >= 1000) {
      newBadges.push("ThousandJobs");
    }
    if (!existingBadges.has("PerfectRating") && newScore >= 9500) {
      newBadges.push("PerfectRating");
    }
    if (!existingBadges.has("QuickResponder") && data.avgResponseTime > 0 && data.avgResponseTime < 3600) {
      newBadges.push("QuickResponder");
    }
    if (!existingBadges.has("DisputeResolver") && data.disputesResolved >= 5) {
      newBadges.push("DisputeResolver");
    }
    if (!existingBadges.has("CategoryExpert")) {
      const hasExpertCategory = data.categoryReputations.some((c) => c.score >= 9000);
      if (hasExpertCategory) {
        newBadges.push("CategoryExpert");
      }
    }
    if (!existingBadges.has("CrossCategoryMaster") && data.categoryReputations.length >= 5) {
      newBadges.push("CrossCategoryMaster");
    }
    return newBadges;
  }
  detectFraud(data, jobPerformance) {
    let totalRiskScore = 0;
    const detectedPatterns = [];
    for (const pattern of this.fraudPatterns) {
      if (pattern.detect(data, jobPerformance)) {
        totalRiskScore += pattern.riskScore;
        detectedPatterns.push(pattern.patternId);
      }
    }
    const normalizedRiskScore = Math.min(100, totalRiskScore);
    return {
      detected: normalizedRiskScore >= 50,
      riskScore: normalizedRiskScore,
      patterns: detectedPatterns
    };
  }
  createPerformanceSnapshot(data, newScore) {
    const avgQuality = data.categoryReputations.length > 0 ? data.categoryReputations.reduce((sum, cat) => {
      return sum + (cat.qualityCount > 0 ? cat.qualitySum / cat.qualityCount : 0);
    }, 0) / data.categoryReputations.length : 0;
    return {
      timestamp: Date.now() / 1000,
      score: newScore,
      jobsCompleted: data.totalJobsCompleted,
      avgQuality: Math.floor(avgQuality)
    };
  }
  calculateSlashAmount(currentScore, slashPercentage) {
    if (slashPercentage > 5000) {
      throw new Error("Slash percentage cannot exceed 50%");
    }
    if (currentScore < REPUTATION_CONSTANTS.MIN_REPUTATION_FOR_SLASH) {
      throw new Error("Reputation too low to slash");
    }
    const slashAmount = Math.floor(currentScore * slashPercentage / 1e4);
    const newScore = Math.max(0, currentScore - slashAmount);
    return { newScore, slashAmount };
  }
  calculateStakingBonus(stakeAmount) {
    return Math.min(500, Math.floor(stakeAmount / 1000));
  }
};
var init_chunk_CO2WD4XR = __esm(() => {
  init_chunk_Z6ZWNWWR();
  init_index_node41();
  init_index_node5();
  init_reputation_tags = __esm2({
    "src/types/reputation-tags.ts"() {
      TagCategory = /* @__PURE__ */ ((TagCategory2) => {
        TagCategory2["Skill"] = "skill";
        TagCategory2["Behavior"] = "behavior";
        TagCategory2["Compliance"] = "compliance";
        return TagCategory2;
      })(TagCategory || {});
      SkillTag = /* @__PURE__ */ ((SkillTag2) => {
        SkillTag2["CodeGeneration"] = "code-generation";
        SkillTag2["DataAnalysis"] = "data-analysis";
        SkillTag2["ContentCreation"] = "content-creation";
        SkillTag2["ImageGeneration"] = "image-generation";
        SkillTag2["AudioProcessing"] = "audio-processing";
        SkillTag2["VideoProcessing"] = "video-processing";
        SkillTag2["NaturalLanguageProcessing"] = "nlp-specialist";
        SkillTag2["ComputerVision"] = "computer-vision";
        SkillTag2["ReinforcementLearning"] = "reinforcement-learning";
        SkillTag2["DeFiExpert"] = "defi-expert";
        SkillTag2["NFTSpecialist"] = "nft-specialist";
        SkillTag2["SmartContractAudit"] = "smart-contract-audit";
        SkillTag2["BlockchainDevelopment"] = "blockchain-dev";
        SkillTag2["DAOGovernance"] = "dao-governance";
        SkillTag2["GameDevelopment"] = "game-dev";
        SkillTag2["WebDevelopment"] = "web-dev";
        SkillTag2["MobileDevelopment"] = "mobile-dev";
        SkillTag2["APIIntegration"] = "api-integration";
        SkillTag2["DatabaseManagement"] = "database-management";
        SkillTag2["DevOpsAutomation"] = "devops-automation";
        SkillTag2["FinancialAnalysis"] = "financial-analysis";
        SkillTag2["MarketResearch"] = "market-research";
        SkillTag2["LegalCompliance"] = "legal-compliance";
        SkillTag2["CustomerSupport"] = "customer-support";
        SkillTag2["TranslationServices"] = "translation-services";
        SkillTag2["SecurityAudit"] = "security-audit";
        SkillTag2["PenetrationTesting"] = "penetration-testing";
        SkillTag2["ThreatDetection"] = "threat-detection";
        SkillTag2["IncidentResponse"] = "incident-response";
        SkillTag2["DataEngineering"] = "data-engineering";
        SkillTag2["DataVisualization"] = "data-visualization";
        SkillTag2["PredictiveModeling"] = "predictive-modeling";
        SkillTag2["StatisticalAnalysis"] = "statistical-analysis";
        return SkillTag2;
      })(SkillTag || {});
      BehaviorTag = /* @__PURE__ */ ((BehaviorTag2) => {
        BehaviorTag2["FastResponder"] = "fast-responder";
        BehaviorTag2["QuickResponder"] = "quick-responder";
        BehaviorTag2["SameDay"] = "same-day";
        BehaviorTag2["ConsistentQuality"] = "consistent-quality";
        BehaviorTag2["HighQuality"] = "high-quality";
        BehaviorTag2["TopRated"] = "top-rated";
        BehaviorTag2["PerfectRecord"] = "perfect-record";
        BehaviorTag2["HighVolume"] = "high-volume";
        BehaviorTag2["VeryHighVolume"] = "very-high-volume";
        BehaviorTag2["MegaVolume"] = "mega-volume";
        BehaviorTag2["LongTermActive"] = "long-term-active";
        BehaviorTag2["MultiYear"] = "multi-year";
        BehaviorTag2["CategorySpecialist"] = "category-specialist";
        BehaviorTag2["MultiDomain"] = "multi-domain";
        BehaviorTag2["Generalist"] = "generalist";
        BehaviorTag2["DisputeFree"] = "dispute-free";
        BehaviorTag2["LowDispute"] = "low-dispute";
        BehaviorTag2["HighResolution"] = "high-resolution";
        BehaviorTag2["PlatinumTier"] = "platinum-tier";
        BehaviorTag2["GoldTier"] = "gold-tier";
        BehaviorTag2["SilverTier"] = "silver-tier";
        BehaviorTag2["BronzeTier"] = "bronze-tier";
        BehaviorTag2["Responsive"] = "responsive";
        BehaviorTag2["Communicative"] = "communicative";
        BehaviorTag2["Proactive"] = "proactive";
        BehaviorTag2["DetailOriented"] = "detail-oriented";
        BehaviorTag2["VerifiedIdentity"] = "verified-identity";
        BehaviorTag2["LongStanding"] = "long-standing";
        BehaviorTag2["CommunityTrusted"] = "community-trusted";
        BehaviorTag2["ClientFavorite"] = "client-favorite";
        return BehaviorTag2;
      })(BehaviorTag || {});
      ComplianceTag = /* @__PURE__ */ ((ComplianceTag2) => {
        ComplianceTag2["KYCVerified"] = "kyc-verified";
        ComplianceTag2["KYBVerified"] = "kyb-verified";
        ComplianceTag2["AccreditedInvestor"] = "accredited-investor";
        ComplianceTag2["SOC2Compliant"] = "soc2-compliant";
        ComplianceTag2["ISO27001"] = "iso-27001";
        ComplianceTag2["GDPR"] = "gdpr-compliant";
        ComplianceTag2["HIPAA"] = "hipaa-compliant";
        ComplianceTag2["PCI_DSS"] = "pci-dss";
        ComplianceTag2["AuditedCode"] = "audited-code";
        ComplianceTag2["BugBounty"] = "bug-bounty";
        ComplianceTag2["OpenSource"] = "open-source";
        ComplianceTag2["InsuredService"] = "insured-service";
        ComplianceTag2["BondedAgent"] = "bonded-agent";
        ComplianceTag2["LicensedProfessional"] = "licensed-professional";
        ComplianceTag2["RegulatedEntity"] = "regulated-entity";
        ComplianceTag2["PublicAuditTrail"] = "public-audit-trail";
        ComplianceTag2["TransparentPricing"] = "transparent-pricing";
        ComplianceTag2["VerifiedMetrics"] = "verified-metrics";
        return ComplianceTag2;
      })(ComplianceTag || {});
      TAG_CONSTANTS = {
        MAX_SKILL_TAGS: 20,
        MAX_BEHAVIOR_TAGS: 20,
        MAX_COMPLIANCE_TAGS: 10,
        MAX_TAG_SCORES: 50,
        MAX_TAG_NAME_LENGTH: 32,
        STALE_TAG_THRESHOLD: 90 * 24 * 60 * 60,
        MIN_TAG_CONFIDENCE: 5000,
        MAX_TAG_CONFIDENCE: 1e4,
        BASIS_POINTS_MAX: 1e4
      };
      DEFAULT_TAG_DECAY = {
        decayRatePerDay: 10,
        minConfidence: 2000,
        maxAgeSeconds: 90 * 24 * 60 * 60
      };
      TagConfidenceLevel = /* @__PURE__ */ ((TagConfidenceLevel2) => {
        TagConfidenceLevel2[TagConfidenceLevel2["VeryLow"] = 2000] = "VeryLow";
        TagConfidenceLevel2[TagConfidenceLevel2["Low"] = 4000] = "Low";
        TagConfidenceLevel2[TagConfidenceLevel2["Medium"] = 6000] = "Medium";
        TagConfidenceLevel2[TagConfidenceLevel2["High"] = 8000] = "High";
        TagConfidenceLevel2[TagConfidenceLevel2["VeryHigh"] = 9500] = "VeryHigh";
        TagConfidenceLevel2[TagConfidenceLevel2["Absolute"] = 1e4] = "Absolute";
        return TagConfidenceLevel2;
      })(TagConfidenceLevel || {});
    }
  });
  reputation_tag_engine_exports = {};
  __export2(reputation_tag_engine_exports, {
    ReputationTagEngine: () => ReputationTagEngine
  });
  init_reputation_tag_engine = __esm2({
    "src/utils/reputation-tag-engine.ts"() {
      init_reputation_tags();
      ReputationTagEngine = class {
        tagCriteria = [];
        decayConfig;
        constructor(decayConfig = DEFAULT_TAG_DECAY) {
          this.decayConfig = decayConfig;
          this.initializeTagCriteria();
        }
        initializeTagCriteria() {
          this.tagCriteria = [
            {
              tag: "fast-responder",
              category: "behavior",
              minConfidence: TAG_CONSTANTS.MIN_TAG_CONFIDENCE,
              evaluate: (metrics) => {
                if (metrics.responseTimeCount === 0n) {
                  return { shouldAssign: false, confidence: 0, evidenceCount: 0 };
                }
                const avgResponseTime = metrics.avgResponseTime;
                const evidenceCount = Number(metrics.responseTimeCount);
                if (avgResponseTime < 60000) {
                  const confidence = Math.min(1e4, 1e4 - Math.floor(avgResponseTime / 60000 * 2000));
                  return {
                    shouldAssign: true,
                    confidence,
                    evidenceCount,
                    reason: `Average response time ${avgResponseTime}ms`
                  };
                }
                return { shouldAssign: false, confidence: 0, evidenceCount };
              }
            },
            {
              tag: "quick-responder",
              category: "behavior",
              minConfidence: TAG_CONSTANTS.MIN_TAG_CONFIDENCE,
              evaluate: (metrics) => {
                if (metrics.responseTimeCount === 0n) {
                  return { shouldAssign: false, confidence: 0, evidenceCount: 0 };
                }
                const avgResponseTime = metrics.avgResponseTime;
                const evidenceCount = Number(metrics.responseTimeCount);
                if (avgResponseTime < 300000) {
                  const confidence = Math.min(1e4, 1e4 - Math.floor(avgResponseTime / 300000 * 3000));
                  return {
                    shouldAssign: true,
                    confidence,
                    evidenceCount,
                    reason: `Average response time ${avgResponseTime}ms`
                  };
                }
                return { shouldAssign: false, confidence: 0, evidenceCount };
              }
            },
            {
              tag: "dispute-free",
              category: "behavior",
              minConfidence: TAG_CONSTANTS.MIN_TAG_CONFIDENCE,
              evaluate: (metrics) => {
                const totalPayments = Number(metrics.successfulPayments + metrics.failedPayments);
                if (totalPayments < 10) {
                  return { shouldAssign: false, confidence: 0, evidenceCount: 0 };
                }
                if (metrics.totalDisputes === 0) {
                  const confidence = Math.min(1e4, 7000 + totalPayments * 10);
                  return {
                    shouldAssign: true,
                    confidence,
                    evidenceCount: totalPayments,
                    reason: `0 disputes over ${totalPayments} transactions`
                  };
                }
                return { shouldAssign: false, confidence: 0, evidenceCount: totalPayments };
              }
            },
            {
              tag: "low-dispute",
              category: "behavior",
              minConfidence: TAG_CONSTANTS.MIN_TAG_CONFIDENCE,
              evaluate: (metrics) => {
                const totalPayments = Number(metrics.successfulPayments + metrics.failedPayments);
                if (totalPayments < 100) {
                  return { shouldAssign: false, confidence: 0, evidenceCount: 0 };
                }
                const disputeRate = metrics.totalDisputes / totalPayments * 100;
                if (disputeRate < 1) {
                  const confidence = Math.min(1e4, 1e4 - Math.floor(disputeRate * 1000));
                  return {
                    shouldAssign: true,
                    confidence,
                    evidenceCount: totalPayments,
                    reason: `${disputeRate.toFixed(2)}% dispute rate`
                  };
                }
                return { shouldAssign: false, confidence: 0, evidenceCount: totalPayments };
              }
            },
            {
              tag: "high-volume",
              category: "behavior",
              minConfidence: TAG_CONSTANTS.MIN_TAG_CONFIDENCE,
              evaluate: (metrics) => {
                const totalPayments = Number(metrics.successfulPayments);
                if (totalPayments >= 1000) {
                  const confidence = Math.min(1e4, 6000 + Math.floor(totalPayments / 100));
                  return {
                    shouldAssign: true,
                    confidence,
                    evidenceCount: totalPayments,
                    reason: `${totalPayments} successful transactions`
                  };
                }
                return { shouldAssign: false, confidence: 0, evidenceCount: totalPayments };
              }
            },
            {
              tag: "very-high-volume",
              category: "behavior",
              minConfidence: TAG_CONSTANTS.MIN_TAG_CONFIDENCE,
              evaluate: (metrics) => {
                const totalPayments = Number(metrics.successfulPayments);
                if (totalPayments >= 1e4) {
                  const confidence = Math.min(1e4, 8000 + Math.floor(totalPayments / 1000));
                  return {
                    shouldAssign: true,
                    confidence,
                    evidenceCount: totalPayments,
                    reason: `${totalPayments} successful transactions`
                  };
                }
                return { shouldAssign: false, confidence: 0, evidenceCount: totalPayments };
              }
            },
            {
              tag: "top-rated",
              category: "behavior",
              minConfidence: TAG_CONSTANTS.MIN_TAG_CONFIDENCE,
              evaluate: (metrics) => {
                if (metrics.totalRatingsCount < 10) {
                  return { shouldAssign: false, confidence: 0, evidenceCount: 0 };
                }
                const avgRating = metrics.avgRating / 20;
                const evidenceCount = metrics.totalRatingsCount;
                if (avgRating > 4.8) {
                  const confidence = Math.min(1e4, Math.floor((avgRating - 4.8) * 50000) + 8000);
                  return {
                    shouldAssign: true,
                    confidence,
                    evidenceCount,
                    reason: `Average rating ${avgRating.toFixed(2)}/5.0`
                  };
                }
                return { shouldAssign: false, confidence: 0, evidenceCount };
              }
            },
            {
              tag: "high-quality",
              category: "behavior",
              minConfidence: TAG_CONSTANTS.MIN_TAG_CONFIDENCE,
              evaluate: (metrics) => {
                if (metrics.totalRatingsCount < 5) {
                  return { shouldAssign: false, confidence: 0, evidenceCount: 0 };
                }
                const avgRating = metrics.avgRating / 20;
                const evidenceCount = metrics.totalRatingsCount;
                if (avgRating > 4.5) {
                  const confidence = Math.min(1e4, Math.floor((avgRating - 4.5) * 20000) + 7000);
                  return {
                    shouldAssign: true,
                    confidence,
                    evidenceCount,
                    reason: `Average rating ${avgRating.toFixed(2)}/5.0`
                  };
                }
                return { shouldAssign: false, confidence: 0, evidenceCount };
              }
            },
            {
              tag: "consistent-quality",
              category: "behavior",
              minConfidence: TAG_CONSTANTS.MIN_TAG_CONFIDENCE,
              evaluate: (metrics) => {
                if (metrics.totalRatingsCount < 20) {
                  return { shouldAssign: false, confidence: 0, evidenceCount: 0 };
                }
                const avgRating = metrics.avgRating / 20;
                const evidenceCount = metrics.totalRatingsCount;
                if (avgRating > 4.3) {
                  const confidence = Math.min(1e4, Math.floor((avgRating - 4) * 1e4) + 5000);
                  return {
                    shouldAssign: true,
                    confidence,
                    evidenceCount,
                    reason: `Consistent high ratings (${avgRating.toFixed(2)}/5.0)`
                  };
                }
                return { shouldAssign: false, confidence: 0, evidenceCount };
              }
            },
            {
              tag: "perfect-record",
              category: "behavior",
              minConfidence: TAG_CONSTANTS.MIN_TAG_CONFIDENCE,
              evaluate: (metrics) => {
                const totalPayments = Number(metrics.successfulPayments + metrics.failedPayments);
                if (totalPayments < 50) {
                  return { shouldAssign: false, confidence: 0, evidenceCount: 0 };
                }
                const successRate = metrics.successRate / 100;
                if (successRate === 100 && metrics.failedPayments === 0n) {
                  const confidence = Math.min(1e4, 8000 + Math.floor(totalPayments / 10));
                  return {
                    shouldAssign: true,
                    confidence,
                    evidenceCount: totalPayments,
                    reason: `100% success rate over ${totalPayments} transactions`
                  };
                }
                return { shouldAssign: false, confidence: 0, evidenceCount: totalPayments };
              }
            },
            {
              tag: "high-resolution",
              category: "behavior",
              minConfidence: TAG_CONSTANTS.MIN_TAG_CONFIDENCE,
              evaluate: (metrics) => {
                if (metrics.totalDisputes < 5) {
                  return { shouldAssign: false, confidence: 0, evidenceCount: 0 };
                }
                const resolutionRate = metrics.disputesResolved / metrics.totalDisputes * 100;
                const evidenceCount = metrics.totalDisputes;
                if (resolutionRate > 90) {
                  const confidence = Math.min(1e4, Math.floor((resolutionRate - 90) * 1000) + 8000);
                  return {
                    shouldAssign: true,
                    confidence,
                    evidenceCount,
                    reason: `${resolutionRate.toFixed(1)}% disputes resolved favorably`
                  };
                }
                return { shouldAssign: false, confidence: 0, evidenceCount };
              }
            },
            {
              tag: "long-term-active",
              category: "behavior",
              minConfidence: TAG_CONSTANTS.MIN_TAG_CONFIDENCE,
              evaluate: (metrics) => {
                const currentTime = Math.floor(Date.now() / 1000);
                const ageSeconds = currentTime - metrics.createdAt;
                const ageYears = ageSeconds / (365 * 24 * 60 * 60);
                if (ageYears >= 1) {
                  const confidence = Math.min(1e4, Math.floor(ageYears * 2000) + 6000);
                  return {
                    shouldAssign: true,
                    confidence,
                    evidenceCount: Math.floor(ageYears),
                    reason: `Active for ${ageYears.toFixed(1)} years`
                  };
                }
                return { shouldAssign: false, confidence: 0, evidenceCount: 0 };
              }
            },
            {
              tag: "multi-year",
              category: "behavior",
              minConfidence: TAG_CONSTANTS.MIN_TAG_CONFIDENCE,
              evaluate: (metrics) => {
                const currentTime = Math.floor(Date.now() / 1000);
                const ageSeconds = currentTime - metrics.createdAt;
                const ageYears = ageSeconds / (365 * 24 * 60 * 60);
                if (ageYears >= 3) {
                  const confidence = Math.min(1e4, Math.floor(ageYears * 1000) + 7000);
                  return {
                    shouldAssign: true,
                    confidence,
                    evidenceCount: Math.floor(ageYears),
                    reason: `Active for ${ageYears.toFixed(1)} years`
                  };
                }
                return { shouldAssign: false, confidence: 0, evidenceCount: 0 };
              }
            }
          ];
        }
        async calculateTags(metrics) {
          const tagScores = [];
          const currentTime = Math.floor(Date.now() / 1000);
          for (const criteria of this.tagCriteria) {
            const evaluation = criteria.evaluate(metrics);
            if (evaluation.shouldAssign && evaluation.confidence >= criteria.minConfidence) {
              tagScores.push({
                tagName: criteria.tag,
                confidence: evaluation.confidence,
                evidenceCount: evaluation.evidenceCount,
                lastUpdated: currentTime
              });
            }
          }
          return tagScores;
        }
        applyTagDecay(tagScores, currentTimestamp) {
          const now = currentTimestamp || Math.floor(Date.now() / 1000);
          const decayedTags = [];
          for (const tag of tagScores) {
            const ageSeconds = now - tag.lastUpdated;
            const ageDays = ageSeconds / (24 * 60 * 60);
            const totalDecay = Math.floor(ageDays * this.decayConfig.decayRatePerDay);
            const newConfidence = Math.max(0, tag.confidence - totalDecay);
            if (newConfidence >= this.decayConfig.minConfidence && ageSeconds <= this.decayConfig.maxAgeSeconds) {
              decayedTags.push({
                ...tag,
                confidence: newConfidence
              });
            }
          }
          return decayedTags;
        }
        mergeTags(existingTags, newTags) {
          const tagMap = /* @__PURE__ */ new Map;
          for (const tag of existingTags) {
            tagMap.set(tag.tagName, tag);
          }
          for (const tag of newTags) {
            const existing = tagMap.get(tag.tagName);
            if (existing) {
              if (tag.confidence > existing.confidence || tag.evidenceCount > existing.evidenceCount) {
                tagMap.set(tag.tagName, tag);
              }
            } else {
              tagMap.set(tag.tagName, tag);
            }
          }
          return Array.from(tagMap.values());
        }
        filterTags(tags, filters) {
          let filtered = [...tags];
          const currentTime = Math.floor(Date.now() / 1000);
          if (filters.category) {
            filtered = filtered.filter((tag) => this.getTagCategory(tag.tagName) === filters.category);
          }
          if (filters.minConfidence !== undefined) {
            filtered = filtered.filter((tag) => tag.confidence >= filters.minConfidence);
          }
          if (filters.maxAge !== undefined) {
            filtered = filtered.filter((tag) => {
              const age = currentTime - tag.lastUpdated;
              return age <= filters.maxAge;
            });
          }
          if (filters.activeOnly) {
            filtered = filtered.filter((tag) => {
              const age = currentTime - tag.lastUpdated;
              return age <= TAG_CONSTANTS.STALE_TAG_THRESHOLD && tag.confidence >= this.decayConfig.minConfidence;
            });
          }
          return filtered;
        }
        getTagCategory(tagName) {
          if (Object.values(SkillTag).includes(tagName)) {
            return "skill";
          } else if (Object.values(BehaviorTag).includes(tagName)) {
            return "behavior";
          } else if (Object.values(ComplianceTag).includes(tagName)) {
            return "compliance";
          }
          return "behavior";
        }
        validateTagName(tagName) {
          return tagName.length > 0 && tagName.length <= TAG_CONSTANTS.MAX_TAG_NAME_LENGTH;
        }
        validateConfidence(confidence) {
          return confidence >= 0 && confidence <= TAG_CONSTANTS.MAX_TAG_CONFIDENCE;
        }
        getConfidenceLevel(confidence) {
          if (confidence >= 1e4)
            return "Absolute";
          if (confidence >= 9500)
            return "Very High";
          if (confidence >= 8000)
            return "High";
          if (confidence >= 6000)
            return "Medium";
          if (confidence >= 4000)
            return "Low";
          return "Very Low";
        }
        sortByConfidence(tags) {
          return [...tags].sort((a, b) => b.confidence - a.confidence);
        }
        sortByEvidence(tags) {
          return [...tags].sort((a, b) => b.evidenceCount - a.evidenceCount);
        }
        sortByRecent(tags) {
          return [...tags].sort((a, b) => b.lastUpdated - a.lastUpdated);
        }
        getTopTags(tags, count) {
          return this.sortByConfidence(tags).slice(0, count);
        }
        categorizeTags(tags) {
          const skillTags = [];
          const behaviorTags = [];
          const complianceTags = [];
          const allTags = [];
          for (const tag of tags) {
            allTags.push(tag.tagName);
            const category = this.getTagCategory(tag.tagName);
            switch (category) {
              case "skill":
                skillTags.push(tag.tagName);
                break;
              case "behavior":
                behaviorTags.push(tag.tagName);
                break;
              case "compliance":
                complianceTags.push(tag.tagName);
                break;
            }
          }
          return {
            allTags,
            skillTags,
            behaviorTags,
            complianceTags,
            tagScores: tags,
            lastUpdated: tags.length > 0 ? Math.max(...tags.map((t) => t.lastUpdated)) : 0
          };
        }
      };
    }
  });
  PrivacyMode = /* @__PURE__ */ ((PrivacyMode2) => {
    PrivacyMode2["Public"] = "Public";
    PrivacyMode2["TierOnly"] = "TierOnly";
    PrivacyMode2["RangeOnly"] = "RangeOnly";
    PrivacyMode2["Custom"] = "Custom";
    PrivacyMode2["Confidential"] = "Confidential";
    return PrivacyMode2;
  })(PrivacyMode || {});
  VisibilityLevel = /* @__PURE__ */ ((VisibilityLevel2) => {
    VisibilityLevel2["Public"] = "Public";
    VisibilityLevel2["Private"] = "Private";
    VisibilityLevel2["ZKProof"] = "ZKProof";
    return VisibilityLevel2;
  })(VisibilityLevel || {});
  ScoreRange = /* @__PURE__ */ ((ScoreRange2) => {
    ScoreRange2["VeryLow"] = "VeryLow";
    ScoreRange2["Low"] = "Low";
    ScoreRange2["Medium"] = "Medium";
    ScoreRange2["High"] = "High";
    ScoreRange2["VeryHigh"] = "VeryHigh";
    return ScoreRange2;
  })(ScoreRange || {});
  PrivacyPresets = {
    CONSERVATIVE: {
      name: "Conservative",
      mode: "TierOnly",
      metricVisibility: {
        showScore: "Private",
        showJobsCompleted: "Private",
        showSuccessRate: "Private",
        showResponseTime: "Private",
        showDisputes: "Private",
        showEarnings: "Private",
        showRatings: "Private",
        showBadges: "Public"
      },
      autoGrantClients: false
    },
    BALANCED: {
      name: "Balanced",
      mode: "Custom",
      metricVisibility: {
        showScore: "Private",
        showJobsCompleted: "Public",
        showSuccessRate: "Public",
        showResponseTime: "Public",
        showDisputes: "Private",
        showEarnings: "Private",
        showRatings: "Public",
        showBadges: "Public"
      },
      autoGrantClients: true
    },
    OPEN: {
      name: "Open",
      mode: "Public",
      metricVisibility: {
        showScore: "Public",
        showJobsCompleted: "Public",
        showSuccessRate: "Public",
        showResponseTime: "Public",
        showDisputes: "Public",
        showEarnings: "Public",
        showRatings: "Public",
        showBadges: "Public"
      },
      autoGrantClients: true
    }
  };
  PRIVACY_CONSTANTS = {
    SCORE_RANGES: {
      VERY_LOW: { min: 0, max: 2000 },
      LOW: { min: 2000, max: 5000 },
      MEDIUM: { min: 5000, max: 7500 },
      HIGH: { min: 7500, max: 9000 },
      VERY_HIGH: { min: 9000, max: 1e4 }
    },
    TIER_THRESHOLDS: {
      BRONZE: 2000,
      SILVER: 5000,
      GOLD: 7500,
      PLATINUM: 9000
    },
    MAX_AUTHORIZED_VIEWERS: 100
  };
  init_reputation_tags();
  GhostNotFoundError = class extends Error {
    constructor(address22) {
      super(`Ghost not found: ${address22}`);
      this.name = "GhostNotFoundError";
    }
  };
  ExternalIdNotFoundError = class extends Error {
    constructor(platform, externalId) {
      super(`No Ghost found for ${platform}:${externalId}`);
      this.platform = platform;
      this.externalId = externalId;
      this.name = "ExternalIdNotFoundError";
    }
  };
  GhostSpeakError = class extends Error {
    constructor(message, code) {
      super(message);
      this.code = code;
      this.name = "GhostSpeakError";
    }
  };
  instructionAccountMappings = {
    activate_agent: {
      name: "activate_agent",
      expectedAccounts: [
        {
          name: "agent_account",
          pda: true
        },
        {
          name: "signer",
          pda: false
        },
        {
          name: "clock",
          pda: false
        }
      ],
      accounts: [
        {
          name: "agent_account",
          writable: true,
          signer: false,
          optional: false,
          docs: [
            "Agent account with canonical PDA validation"
          ],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  97,
                  103,
                  101,
                  110,
                  116
                ]
              },
              {
                kind: "account",
                path: "signer"
              },
              {
                kind: "arg",
                path: "agent_id"
              }
            ]
          }
        },
        {
          name: "signer",
          writable: true,
          signer: true,
          optional: false,
          docs: [
            "Enhanced authority verification"
          ]
        },
        {
          name: "clock",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "Clock sysvar for rate limiting"
          ],
          address: "SysvarC1ock11111111111111111111111111111111"
        }
      ],
      docs: "",
      discriminator: [
        252,
        139,
        87,
        21,
        195,
        152,
        29,
        217
      ],
      args: [
        {
          name: "agent_id",
          type: "string"
        }
      ]
    },
    approve_delivery: {
      name: "approve_delivery",
      expectedAccounts: [
        {
          name: "escrow",
          pda: true
        },
        {
          name: "escrow_vault",
          pda: false
        },
        {
          name: "agent_token_account",
          pda: false
        },
        {
          name: "client",
          pda: false
        },
        {
          name: "token_program",
          pda: false
        }
      ],
      accounts: [
        {
          name: "escrow",
          writable: true,
          signer: false,
          optional: false,
          docs: [],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  103,
                  104,
                  111,
                  115,
                  116,
                  95,
                  112,
                  114,
                  111,
                  116,
                  101,
                  99,
                  116
                ]
              },
              {
                kind: "account",
                path: "escrow.client",
                account: "GhostProtectEscrow"
              },
              {
                kind: "account",
                path: "escrow.escrow_id",
                account: "GhostProtectEscrow"
              }
            ]
          }
        },
        {
          name: "escrow_vault",
          writable: true,
          signer: false,
          optional: false,
          docs: []
        },
        {
          name: "agent_token_account",
          writable: true,
          signer: false,
          optional: false,
          docs: []
        },
        {
          name: "client",
          writable: false,
          signer: true,
          optional: false,
          docs: []
        },
        {
          name: "token_program",
          writable: false,
          signer: false,
          optional: false,
          docs: [],
          address: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
        }
      ],
      docs: "Client approves delivery and releases payment",
      discriminator: [
        28,
        233,
        51,
        115,
        33,
        220,
        41,
        28
      ],
      args: []
    },
    arbitrate_dispute: {
      name: "arbitrate_dispute",
      expectedAccounts: [
        {
          name: "escrow",
          pda: true
        },
        {
          name: "escrow_vault",
          pda: false
        },
        {
          name: "agent_token_account",
          pda: false
        },
        {
          name: "client_token_account",
          pda: false
        },
        {
          name: "agent_staking",
          pda: true
        },
        {
          name: "arbitrator",
          pda: false
        },
        {
          name: "token_program",
          pda: false
        }
      ],
      accounts: [
        {
          name: "escrow",
          writable: true,
          signer: false,
          optional: false,
          docs: [],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  103,
                  104,
                  111,
                  115,
                  116,
                  95,
                  112,
                  114,
                  111,
                  116,
                  101,
                  99,
                  116
                ]
              },
              {
                kind: "account",
                path: "escrow.client",
                account: "GhostProtectEscrow"
              },
              {
                kind: "account",
                path: "escrow.escrow_id",
                account: "GhostProtectEscrow"
              }
            ]
          }
        },
        {
          name: "escrow_vault",
          writable: true,
          signer: false,
          optional: false,
          docs: []
        },
        {
          name: "agent_token_account",
          writable: true,
          signer: false,
          optional: false,
          docs: []
        },
        {
          name: "client_token_account",
          writable: true,
          signer: false,
          optional: false,
          docs: []
        },
        {
          name: "agent_staking",
          writable: true,
          signer: false,
          optional: false,
          docs: [
            "Agent's staking account (for potential slashing)"
          ],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  115,
                  116,
                  97,
                  107,
                  105,
                  110,
                  103
                ]
              },
              {
                kind: "account",
                path: "escrow.agent",
                account: "GhostProtectEscrow"
              }
            ]
          }
        },
        {
          name: "arbitrator",
          writable: false,
          signer: true,
          optional: false,
          docs: []
        },
        {
          name: "token_program",
          writable: false,
          signer: false,
          optional: false,
          docs: [],
          address: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
        }
      ],
      docs: "Arbitrator resolves dispute (admin only)",
      discriminator: [
        225,
        89,
        166,
        101,
        215,
        40,
        191,
        4
      ],
      args: [
        {
          name: "decision",
          type: {
            defined: {
              name: "ArbitratorDecision"
            }
          }
        }
      ]
    },
    auto_create_ghost: {
      name: "auto_create_ghost",
      expectedAccounts: [
        {
          name: "agent_account",
          pda: true
        },
        {
          name: "authority",
          pda: false
        },
        {
          name: "system_program",
          pda: false
        }
      ],
      accounts: [
        {
          name: "agent_account",
          writable: true,
          signer: false,
          optional: false,
          docs: [],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  97,
                  103,
                  101,
                  110,
                  116
                ]
              },
              {
                kind: "arg",
                path: "payment_address"
              }
            ]
          }
        },
        {
          name: "authority",
          writable: true,
          signer: true,
          optional: false,
          docs: []
        },
        {
          name: "system_program",
          writable: false,
          signer: false,
          optional: false,
          docs: [],
          address: "11111111111111111111111111111111"
        }
      ],
      docs: 'Auto-create a Ghost from discovered x402 transaction (indexer service only)  Used by the off-chain indexer service when it discovers a new agent via x402 payment transactions. Creates an Unregistered Ghost.  Parameters: - payment_address: The x402_payment_address (merchant address) of the discovered agent - first_tx_signature: Transaction signature where this agent was first discovered - discovery_source: Source identifier (e.g., "http:payai", "blockchain:direct") - initial_ghost_score: Optional initial Ghost Score from backfill metrics',
      discriminator: [
        50,
        170,
        232,
        73,
        238,
        200,
        180,
        16
      ],
      args: [
        {
          name: "payment_address",
          type: "pubkey"
        },
        {
          name: "first_tx_signature",
          type: "string"
        },
        {
          name: "discovery_source",
          type: "string"
        },
        {
          name: "initial_ghost_score",
          type: {
            option: "u64"
          }
        }
      ]
    },
    claim_ghost: {
      name: "claim_ghost",
      expectedAccounts: [
        {
          name: "agent_account",
          pda: false
        },
        {
          name: "did_document",
          pda: true
        },
        {
          name: "sas_attestation",
          pda: false
        },
        {
          name: "claimer",
          pda: false
        },
        {
          name: "system_program",
          pda: false
        }
      ],
      accounts: [
        {
          name: "agent_account",
          writable: true,
          signer: false,
          optional: false,
          docs: []
        },
        {
          name: "did_document",
          writable: true,
          signer: false,
          optional: false,
          docs: [
            "DID document to create for this Ghost",
            'Seeds: [b"did_document", agent_account.x402_payment_address.as_ref()]'
          ],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  100,
                  105,
                  100,
                  95,
                  100,
                  111,
                  99,
                  117,
                  109,
                  101,
                  110,
                  116
                ]
              },
              {
                kind: "account",
                path: "agent_account.x402_payment_address",
                account: "Agent"
              }
            ]
          }
        },
        {
          name: "sas_attestation",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "SAS Attestation proving ownership of x402_payment_address",
            'PDA: [b"attestation", sas_credential, sas_schema, x402_payment_address]'
          ]
        },
        {
          name: "claimer",
          writable: true,
          signer: true,
          optional: false,
          docs: [
            "The claimer must have created a SAS attestation proving they own x402_payment_address"
          ]
        },
        {
          name: "system_program",
          writable: false,
          signer: false,
          optional: false,
          docs: [],
          address: "11111111111111111111111111111111"
        }
      ],
      docs: 'Claim ownership of a Ghost using Solana Attestation Service (SAS)  Security: Uses SAS for trustless ownership verification. The claimer must have created a SAS attestation proving they own the x402_payment_address.  Auto-creates: DID document with did:sol:<network>:<address> format Transitions: Unregistered/Registered â†’ Claimed  SAS Attestation Requirements: - Credential: GhostSpeak ownership credential (issuer) - Schema: Ghost ownership schema defining attestation data structure - Nonce: x402_payment_address (ensures PDA uniqueness) - Data: Contains x402_payment_address as proof of ownership  Parameters: - sas_credential: Pubkey of the SAS Credential (issuer) for ownership attestations - sas_schema: Pubkey of the SAS Schema defining the ownership attestation format - ipfs_metadata_uri: Optional IPFS URI for agent metadata (ipfs://...) - network: Network identifier ("devnet", "mainnet-beta", "testnet")',
      discriminator: [
        149,
        107,
        35,
        233,
        252,
        101,
        148,
        225
      ],
      args: [
        {
          name: "sas_credential",
          type: "pubkey"
        },
        {
          name: "sas_schema",
          type: "pubkey"
        },
        {
          name: "ipfs_metadata_uri",
          type: {
            option: "string"
          }
        },
        {
          name: "network",
          type: "string"
        }
      ]
    },
    create_agent_authorization: {
      name: "create_agent_authorization",
      expectedAccounts: [
        {
          name: "agent",
          pda: false
        },
        {
          name: "authorization",
          pda: true
        },
        {
          name: "authority",
          pda: false
        },
        {
          name: "system_program",
          pda: false
        }
      ],
      accounts: [
        {
          name: "agent",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "Agent granting authorization"
          ]
        },
        {
          name: "authorization",
          writable: true,
          signer: false,
          optional: false,
          docs: [
            "Authorization account (PDA)"
          ],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  97,
                  103,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104
                ]
              },
              {
                kind: "account",
                path: "agent"
              },
              {
                kind: "arg",
                path: "authorized_source"
              },
              {
                kind: "arg",
                path: "nonce"
              }
            ]
          }
        },
        {
          name: "authority",
          writable: true,
          signer: true,
          optional: false,
          docs: [
            "Authority (agent owner)"
          ]
        },
        {
          name: "system_program",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "System program"
          ],
          address: "11111111111111111111111111111111"
        }
      ],
      docs: "Create agent authorization for reputation updates  Allows an agent to pre-authorize a facilitator (e.g., PayAI) to update their reputation a limited number of times before expiration.  Parameters: - authorized_source: Pubkey of the facilitator being authorized - index_limit: Maximum number of updates allowed - expires_at: Unix timestamp when authorization expires - network: Network ID for cross-chain compatibility - signature: Ed25519 signature proving agent's consent - nonce: Optional nonce for multiple authorizations to same facilitator",
      discriminator: [
        48,
        219,
        232,
        202,
        151,
        97,
        230,
        20
      ],
      args: [
        {
          name: "authorized_source",
          type: "pubkey"
        },
        {
          name: "index_limit",
          type: "u64"
        },
        {
          name: "expires_at",
          type: "i64"
        },
        {
          name: "network",
          type: "u8"
        },
        {
          name: "signature",
          type: {
            array: [
              "u8",
              64
            ]
          }
        },
        {
          name: "nonce",
          type: {
            option: "string"
          }
        }
      ]
    },
    create_credential_template: {
      name: "create_credential_template",
      expectedAccounts: [
        {
          name: "credential_template",
          pda: true
        },
        {
          name: "credential_type",
          pda: false
        },
        {
          name: "issuer",
          pda: false
        },
        {
          name: "system_program",
          pda: false
        }
      ],
      accounts: [
        {
          name: "credential_template",
          writable: true,
          signer: false,
          optional: false,
          docs: [],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  99,
                  114,
                  101,
                  100,
                  101,
                  110,
                  116,
                  105,
                  97,
                  108,
                  95,
                  116,
                  101,
                  109,
                  112,
                  108,
                  97,
                  116,
                  101
                ]
              },
              {
                kind: "account",
                path: "credential_type"
              },
              {
                kind: "arg",
                path: "name"
              }
            ]
          }
        },
        {
          name: "credential_type",
          writable: false,
          signer: false,
          optional: false,
          docs: []
        },
        {
          name: "issuer",
          writable: true,
          signer: true,
          optional: false,
          docs: []
        },
        {
          name: "system_program",
          writable: false,
          signer: false,
          optional: false,
          docs: [],
          address: "11111111111111111111111111111111"
        }
      ],
      docs: "Create a credential template from a credential type for issuing credentials",
      discriminator: [
        183,
        109,
        12,
        128,
        134,
        8,
        139,
        144
      ],
      args: [
        {
          name: "name",
          type: "string"
        },
        {
          name: "image_uri",
          type: "string"
        },
        {
          name: "crossmint_template_id",
          type: {
            option: "string"
          }
        }
      ]
    },
    create_credential_type: {
      name: "create_credential_type",
      expectedAccounts: [
        {
          name: "credential_type",
          pda: true
        },
        {
          name: "authority",
          pda: false
        },
        {
          name: "system_program",
          pda: false
        }
      ],
      accounts: [
        {
          name: "credential_type",
          writable: true,
          signer: false,
          optional: false,
          docs: [],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  99,
                  114,
                  101,
                  100,
                  101,
                  110,
                  116,
                  105,
                  97,
                  108,
                  95,
                  116,
                  121,
                  112,
                  101
                ]
              },
              {
                kind: "arg",
                path: "name"
              }
            ]
          }
        },
        {
          name: "authority",
          writable: true,
          signer: true,
          optional: false,
          docs: []
        },
        {
          name: "system_program",
          writable: false,
          signer: false,
          optional: false,
          docs: [],
          address: "11111111111111111111111111111111"
        }
      ],
      docs: "Create a new credential type (e.g., AgentIdentity, Reputation, JobCompletion) This is an admin-only operation typically done by governance/multisig.",
      discriminator: [
        211,
        208,
        67,
        175,
        20,
        248,
        8,
        227
      ],
      args: [
        {
          name: "name",
          type: "string"
        },
        {
          name: "kind",
          type: {
            defined: {
              name: "CredentialKind"
            }
          }
        },
        {
          name: "schema_uri",
          type: "string"
        },
        {
          name: "description",
          type: "string"
        }
      ]
    },
    create_did_document: {
      name: "create_did_document",
      expectedAccounts: [
        {
          name: "did_document",
          pda: true
        },
        {
          name: "controller",
          pda: false
        },
        {
          name: "system_program",
          pda: false
        },
        {
          name: "clock",
          pda: false
        }
      ],
      accounts: [
        {
          name: "did_document",
          writable: true,
          signer: false,
          optional: false,
          docs: [
            "DID document account with canonical PDA"
          ],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  100,
                  105,
                  100,
                  95,
                  100,
                  111,
                  99,
                  117,
                  109,
                  101,
                  110,
                  116
                ]
              },
              {
                kind: "account",
                path: "controller"
              }
            ]
          }
        },
        {
          name: "controller",
          writable: true,
          signer: true,
          optional: false,
          docs: [
            "Controller of the DID (owner)"
          ]
        },
        {
          name: "system_program",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "System program for account creation"
          ],
          address: "11111111111111111111111111111111"
        },
        {
          name: "clock",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "Clock sysvar for timestamp validation"
          ],
          address: "SysvarC1ock11111111111111111111111111111111"
        }
      ],
      docs: 'Create a new DID document for an agent or user  Initializes a W3C-compliant DID document following the did:sol method. The DID document can contain verification methods and service endpoints.  Parameters: - did_string: The DID string (e.g., "did:sol:devnet:HN7c...") - verification_methods: Initial verification methods (max 10) - service_endpoints: Initial service endpoints (max 5)',
      discriminator: [
        253,
        40,
        200,
        239,
        69,
        147,
        82,
        182
      ],
      args: [
        {
          name: "did_string",
          type: "string"
        },
        {
          name: "verification_methods",
          type: {
            vec: {
              defined: {
                name: "VerificationMethod"
              }
            }
          }
        },
        {
          name: "service_endpoints",
          type: {
            vec: {
              defined: {
                name: "ServiceEndpoint"
              }
            }
          }
        }
      ]
    },
    create_escrow: {
      name: "create_escrow",
      expectedAccounts: [
        {
          name: "escrow",
          pda: true
        },
        {
          name: "agent",
          pda: false
        },
        {
          name: "client_token_account",
          pda: false
        },
        {
          name: "escrow_vault",
          pda: false
        },
        {
          name: "token_mint",
          pda: false
        },
        {
          name: "client",
          pda: false
        },
        {
          name: "token_program",
          pda: false
        },
        {
          name: "system_program",
          pda: false
        }
      ],
      accounts: [
        {
          name: "escrow",
          writable: true,
          signer: false,
          optional: false,
          docs: [],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  103,
                  104,
                  111,
                  115,
                  116,
                  95,
                  112,
                  114,
                  111,
                  116,
                  101,
                  99,
                  116
                ]
              },
              {
                kind: "account",
                path: "client"
              },
              {
                kind: "arg",
                path: "escrow_id"
              }
            ]
          }
        },
        {
          name: "agent",
          writable: false,
          signer: false,
          optional: false,
          docs: []
        },
        {
          name: "client_token_account",
          writable: true,
          signer: false,
          optional: false,
          docs: []
        },
        {
          name: "escrow_vault",
          writable: true,
          signer: false,
          optional: false,
          docs: []
        },
        {
          name: "token_mint",
          writable: false,
          signer: false,
          optional: false,
          docs: []
        },
        {
          name: "client",
          writable: true,
          signer: true,
          optional: false,
          docs: []
        },
        {
          name: "token_program",
          writable: false,
          signer: false,
          optional: false,
          docs: [],
          address: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
        },
        {
          name: "system_program",
          writable: false,
          signer: false,
          optional: false,
          docs: [],
          address: "11111111111111111111111111111111"
        }
      ],
      docs: "Create a new escrow for agent service payment",
      discriminator: [
        253,
        215,
        165,
        116,
        36,
        108,
        68,
        80
      ],
      args: [
        {
          name: "escrow_id",
          type: "u64"
        },
        {
          name: "amount",
          type: "u64"
        },
        {
          name: "job_description",
          type: "string"
        },
        {
          name: "deadline",
          type: "i64"
        }
      ]
    },
    create_multisig: {
      name: "create_multisig",
      expectedAccounts: [
        {
          name: "multisig",
          pda: true
        },
        {
          name: "owner",
          pda: false
        },
        {
          name: "system_program",
          pda: false
        }
      ],
      accounts: [
        {
          name: "multisig",
          writable: true,
          signer: false,
          optional: false,
          docs: [],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  109,
                  117,
                  108,
                  116,
                  105,
                  115,
                  105,
                  103
                ]
              },
              {
                kind: "account",
                path: "owner"
              },
              {
                kind: "arg",
                path: "multisig_id"
              }
            ]
          }
        },
        {
          name: "owner",
          writable: true,
          signer: true,
          optional: false,
          docs: []
        },
        {
          name: "system_program",
          writable: false,
          signer: false,
          optional: false,
          docs: [],
          address: "11111111111111111111111111111111"
        }
      ],
      docs: "",
      discriminator: [
        148,
        146,
        240,
        10,
        226,
        215,
        167,
        174
      ],
      args: [
        {
          name: "multisig_id",
          type: "u64"
        },
        {
          name: "threshold",
          type: "u8"
        },
        {
          name: "signers",
          type: {
            vec: "pubkey"
          }
        },
        {
          name: "config",
          type: {
            defined: {
              name: "MultisigConfig"
            }
          }
        }
      ]
    },
    deactivate_agent: {
      name: "deactivate_agent",
      expectedAccounts: [
        {
          name: "agent_account",
          pda: true
        },
        {
          name: "signer",
          pda: false
        },
        {
          name: "clock",
          pda: false
        }
      ],
      accounts: [
        {
          name: "agent_account",
          writable: true,
          signer: false,
          optional: false,
          docs: [
            "Agent account with canonical PDA validation"
          ],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  97,
                  103,
                  101,
                  110,
                  116
                ]
              },
              {
                kind: "account",
                path: "signer"
              },
              {
                kind: "arg",
                path: "agent_id"
              }
            ]
          }
        },
        {
          name: "signer",
          writable: true,
          signer: true,
          optional: false,
          docs: [
            "Enhanced authority verification"
          ]
        },
        {
          name: "clock",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "Clock sysvar for rate limiting"
          ],
          address: "SysvarC1ock11111111111111111111111111111111"
        }
      ],
      docs: "",
      discriminator: [
        205,
        171,
        239,
        225,
        82,
        126,
        96,
        166
      ],
      args: [
        {
          name: "agent_id",
          type: "string"
        }
      ]
    },
    deactivate_credential_template: {
      name: "deactivate_credential_template",
      expectedAccounts: [
        {
          name: "credential_template",
          pda: false
        },
        {
          name: "issuer",
          pda: false
        }
      ],
      accounts: [
        {
          name: "credential_template",
          writable: true,
          signer: false,
          optional: false,
          docs: []
        },
        {
          name: "issuer",
          writable: true,
          signer: true,
          optional: false,
          docs: []
        }
      ],
      docs: "Deactivate a credential template (no new credentials can be issued from it)",
      discriminator: [
        177,
        8,
        195,
        104,
        56,
        34,
        84,
        162
      ],
      args: []
    },
    deactivate_credential_type: {
      name: "deactivate_credential_type",
      expectedAccounts: [
        {
          name: "credential_type",
          pda: false
        },
        {
          name: "authority",
          pda: false
        }
      ],
      accounts: [
        {
          name: "credential_type",
          writable: true,
          signer: false,
          optional: false,
          docs: []
        },
        {
          name: "authority",
          writable: true,
          signer: true,
          optional: false,
          docs: []
        }
      ],
      docs: "Deactivate a credential type (no new credentials can be issued)",
      discriminator: [
        110,
        174,
        221,
        244,
        36,
        206,
        60,
        237
      ],
      args: []
    },
    deactivate_did_document: {
      name: "deactivate_did_document",
      expectedAccounts: [
        {
          name: "did_document",
          pda: true
        },
        {
          name: "controller",
          pda: false
        },
        {
          name: "clock",
          pda: false
        }
      ],
      accounts: [
        {
          name: "did_document",
          writable: true,
          signer: false,
          optional: false,
          docs: [
            "DID document account with canonical PDA validation"
          ],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  100,
                  105,
                  100,
                  95,
                  100,
                  111,
                  99,
                  117,
                  109,
                  101,
                  110,
                  116
                ]
              },
              {
                kind: "account",
                path: "controller"
              }
            ]
          }
        },
        {
          name: "controller",
          writable: true,
          signer: true,
          optional: false,
          docs: [
            "Controller of the DID (must match document controller)"
          ]
        },
        {
          name: "clock",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "Clock sysvar for timestamp validation"
          ],
          address: "SysvarC1ock11111111111111111111111111111111"
        }
      ],
      docs: "Deactivate a DID document  Permanently deactivates the DID document. This operation is irreversible. Only the controller can deactivate their DID.",
      discriminator: [
        77,
        13,
        56,
        161,
        67,
        155,
        206,
        119
      ],
      args: []
    },
    enable_protocol_fees: {
      name: "enable_protocol_fees",
      expectedAccounts: [
        {
          name: "config",
          pda: true
        },
        {
          name: "authority",
          pda: false
        }
      ],
      accounts: [
        {
          name: "config",
          writable: true,
          signer: false,
          optional: false,
          docs: [],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  112,
                  114,
                  111,
                  116,
                  111,
                  99,
                  111,
                  108,
                  95,
                  99,
                  111,
                  110,
                  102,
                  105,
                  103
                ]
              }
            ]
          }
        },
        {
          name: "authority",
          writable: false,
          signer: true,
          optional: false,
          docs: []
        }
      ],
      docs: "Enable production fees (authority only)  Activates the full fee structure for mainnet: - Escrow: 0.5% (80% Treasury, 20% Buyback) - Agent Registration: 0.01 SOL - Marketplace Listing: 0.001 SOL - Dispute Resolution: 1%",
      discriminator: [
        9,
        115,
        79,
        19,
        158,
        209,
        221,
        38
      ],
      args: []
    },
    file_dispute: {
      name: "file_dispute",
      expectedAccounts: [
        {
          name: "escrow",
          pda: true
        },
        {
          name: "client",
          pda: false
        }
      ],
      accounts: [
        {
          name: "escrow",
          writable: true,
          signer: false,
          optional: false,
          docs: [],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  103,
                  104,
                  111,
                  115,
                  116,
                  95,
                  112,
                  114,
                  111,
                  116,
                  101,
                  99,
                  116
                ]
              },
              {
                kind: "account",
                path: "escrow.client",
                account: "GhostProtectEscrow"
              },
              {
                kind: "account",
                path: "escrow.escrow_id",
                account: "GhostProtectEscrow"
              }
            ]
          }
        },
        {
          name: "client",
          writable: false,
          signer: true,
          optional: false,
          docs: []
        }
      ],
      docs: "Client files a dispute on escrow",
      discriminator: [
        210,
        63,
        221,
        114,
        212,
        97,
        195,
        156
      ],
      args: [
        {
          name: "reason",
          type: "string"
        }
      ]
    },
    generate_compliance_report: {
      name: "generate_compliance_report",
      expectedAccounts: [
        {
          name: "report",
          pda: true
        },
        {
          name: "audit_trail",
          pda: false
        },
        {
          name: "authority",
          pda: false
        },
        {
          name: "system_program",
          pda: false
        }
      ],
      accounts: [
        {
          name: "report",
          writable: true,
          signer: false,
          optional: false,
          docs: [],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  99,
                  111,
                  109,
                  112,
                  108,
                  105,
                  97,
                  110,
                  99,
                  101,
                  95,
                  114,
                  101,
                  112,
                  111,
                  114,
                  116
                ]
              },
              {
                kind: "arg",
                path: "report_id"
              }
            ]
          }
        },
        {
          name: "audit_trail",
          writable: true,
          signer: false,
          optional: false,
          docs: [
            "Audit trail for the entity"
          ]
        },
        {
          name: "authority",
          writable: true,
          signer: true,
          optional: false,
          docs: []
        },
        {
          name: "system_program",
          writable: false,
          signer: false,
          optional: false,
          docs: [],
          address: "11111111111111111111111111111111"
        }
      ],
      docs: "",
      discriminator: [
        213,
        97,
        79,
        234,
        22,
        228,
        14,
        32
      ],
      args: [
        {
          name: "report_id",
          type: "u64"
        },
        {
          name: "report_type",
          type: {
            defined: {
              name: "ReportType"
            }
          }
        },
        {
          name: "date_range_start",
          type: "i64"
        },
        {
          name: "date_range_end",
          type: "i64"
        }
      ]
    },
    init_reentrancy_guard: {
      name: "init_reentrancy_guard",
      expectedAccounts: [
        {
          name: "reentrancy_guard",
          pda: true
        },
        {
          name: "authority",
          pda: false
        },
        {
          name: "system_program",
          pda: false
        }
      ],
      accounts: [
        {
          name: "reentrancy_guard",
          writable: true,
          signer: false,
          optional: false,
          docs: [],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  114,
                  101,
                  101,
                  110,
                  116,
                  114,
                  97,
                  110,
                  99,
                  121,
                  95,
                  103,
                  117,
                  97,
                  114,
                  100
                ]
              }
            ]
          }
        },
        {
          name: "authority",
          writable: true,
          signer: true,
          optional: false,
          docs: []
        },
        {
          name: "system_program",
          writable: false,
          signer: false,
          optional: false,
          docs: [],
          address: "11111111111111111111111111111111"
        }
      ],
      docs: "Initialize the global reentrancy guard PDA This must be called once by a program admin before any reentrancy-protected instructions can be used",
      discriminator: [
        156,
        109,
        115,
        85,
        12,
        60,
        245,
        99
      ],
      args: []
    },
    initialize_audit_trail: {
      name: "initialize_audit_trail",
      expectedAccounts: [
        {
          name: "audit_trail",
          pda: true
        },
        {
          name: "entity",
          pda: false
        },
        {
          name: "authority",
          pda: false
        },
        {
          name: "system_program",
          pda: false
        }
      ],
      accounts: [
        {
          name: "audit_trail",
          writable: true,
          signer: false,
          optional: false,
          docs: [],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  97,
                  117,
                  100,
                  105,
                  116,
                  95,
                  116,
                  114,
                  97,
                  105,
                  108
                ]
              },
              {
                kind: "account",
                path: "entity"
              }
            ]
          }
        },
        {
          name: "entity",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "Entity being audited"
          ]
        },
        {
          name: "authority",
          writable: true,
          signer: true,
          optional: false,
          docs: []
        },
        {
          name: "system_program",
          writable: false,
          signer: false,
          optional: false,
          docs: [],
          address: "11111111111111111111111111111111"
        }
      ],
      docs: "",
      discriminator: [
        145,
        182,
        236,
        249,
        212,
        17,
        175,
        161
      ],
      args: [
        {
          name: "entity_type",
          type: "string"
        },
        {
          name: "config",
          type: {
            defined: {
              name: "AuditConfig"
            }
          }
        }
      ]
    },
    initialize_governance_proposal: {
      name: "initialize_governance_proposal",
      expectedAccounts: [
        {
          name: "proposal",
          pda: true
        },
        {
          name: "proposer",
          pda: false
        },
        {
          name: "system_program",
          pda: false
        }
      ],
      accounts: [
        {
          name: "proposal",
          writable: true,
          signer: false,
          optional: false,
          docs: [],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  103,
                  111,
                  118,
                  101,
                  114,
                  110,
                  97,
                  110,
                  99,
                  101,
                  95,
                  112,
                  114,
                  111,
                  112,
                  111,
                  115,
                  97,
                  108
                ]
              },
              {
                kind: "arg",
                path: "proposal_id"
              }
            ]
          }
        },
        {
          name: "proposer",
          writable: true,
          signer: true,
          optional: false,
          docs: []
        },
        {
          name: "system_program",
          writable: false,
          signer: false,
          optional: false,
          docs: [],
          address: "11111111111111111111111111111111"
        }
      ],
      docs: "",
      discriminator: [
        137,
        84,
        234,
        206,
        17,
        58,
        54,
        215
      ],
      args: [
        {
          name: "proposal_id",
          type: "u64"
        },
        {
          name: "title",
          type: "string"
        },
        {
          name: "description",
          type: "string"
        },
        {
          name: "proposal_type",
          type: {
            defined: {
              name: "ProposalType"
            }
          }
        },
        {
          name: "execution_params",
          type: {
            defined: {
              name: "ExecutionParams"
            }
          }
        }
      ]
    },
    initialize_protocol_config: {
      name: "initialize_protocol_config",
      expectedAccounts: [
        {
          name: "config",
          pda: true
        },
        {
          name: "authority",
          pda: false
        },
        {
          name: "treasury",
          pda: false
        },
        {
          name: "buyback_pool",
          pda: false
        },
        {
          name: "moderator_pool",
          pda: false
        },
        {
          name: "system_program",
          pda: false
        }
      ],
      accounts: [
        {
          name: "config",
          writable: true,
          signer: false,
          optional: false,
          docs: [],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  112,
                  114,
                  111,
                  116,
                  111,
                  99,
                  111,
                  108,
                  95,
                  99,
                  111,
                  110,
                  102,
                  105,
                  103
                ]
              }
            ]
          }
        },
        {
          name: "authority",
          writable: true,
          signer: true,
          optional: false,
          docs: [
            "Authority who will control the config (typically DAO or multisig)"
          ]
        },
        {
          name: "treasury",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "Treasury wallet to receive protocol fees"
          ]
        },
        {
          name: "buyback_pool",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "Buyback pool wallet for token buybacks"
          ]
        },
        {
          name: "moderator_pool",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "Moderator pool for dispute fees"
          ]
        },
        {
          name: "system_program",
          writable: false,
          signer: false,
          optional: false,
          docs: [],
          address: "11111111111111111111111111111111"
        }
      ],
      docs: "Initialize the global protocol configuration  Sets up fee infrastructure with all fees initially disabled (set to 0). Fees will be enabled via governance after mainnet deployment.  NOTE: Fee structure is in place but set to 0 until mainnet.",
      discriminator: [
        28,
        50,
        43,
        233,
        244,
        98,
        123,
        118
      ],
      args: []
    },
    initialize_rbac_config: {
      name: "initialize_rbac_config",
      expectedAccounts: [
        {
          name: "rbac_config",
          pda: true
        },
        {
          name: "authority",
          pda: false
        },
        {
          name: "system_program",
          pda: false
        }
      ],
      accounts: [
        {
          name: "rbac_config",
          writable: true,
          signer: false,
          optional: false,
          docs: [],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  114,
                  98,
                  97,
                  99,
                  95,
                  99,
                  111,
                  110,
                  102,
                  105,
                  103
                ]
              },
              {
                kind: "account",
                path: "authority"
              }
            ]
          }
        },
        {
          name: "authority",
          writable: true,
          signer: true,
          optional: false,
          docs: []
        },
        {
          name: "system_program",
          writable: false,
          signer: false,
          optional: false,
          docs: [],
          address: "11111111111111111111111111111111"
        }
      ],
      docs: "",
      discriminator: [
        215,
        68,
        129,
        228,
        237,
        165,
        0,
        240
      ],
      args: [
        {
          name: "initial_roles",
          type: {
            vec: {
              defined: {
                name: "Role"
              }
            }
          }
        }
      ]
    },
    initialize_reputation_metrics: {
      name: "initialize_reputation_metrics",
      expectedAccounts: [
        {
          name: "reputation_metrics",
          pda: true
        },
        {
          name: "agent",
          pda: false
        },
        {
          name: "authority",
          pda: false
        },
        {
          name: "system_program",
          pda: false
        },
        {
          name: "clock",
          pda: false
        }
      ],
      accounts: [
        {
          name: "reputation_metrics",
          writable: true,
          signer: false,
          optional: false,
          docs: [
            "Reputation metrics account"
          ],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  114,
                  101,
                  112,
                  117,
                  116,
                  97,
                  116,
                  105,
                  111,
                  110,
                  95,
                  109,
                  101,
                  116,
                  114,
                  105,
                  99,
                  115
                ]
              },
              {
                kind: "account",
                path: "agent"
              }
            ]
          }
        },
        {
          name: "agent",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "Agent account"
          ]
        },
        {
          name: "authority",
          writable: true,
          signer: true,
          optional: false,
          docs: [
            "Authority (agent owner)"
          ]
        },
        {
          name: "system_program",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "System program"
          ],
          address: "11111111111111111111111111111111"
        },
        {
          name: "clock",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "Clock for timestamps"
          ],
          address: "SysvarC1ock11111111111111111111111111111111"
        }
      ],
      docs: "Initialize reputation metrics for an agent  Creates a new reputation tracking account that monitors: - Payment success/failure rates - Service ratings from clients - Response time performance - Dispute resolution history",
      discriminator: [
        228,
        11,
        207,
        44,
        52,
        188,
        169,
        237
      ],
      args: []
    },
    initialize_staking_config: {
      name: "initialize_staking_config",
      expectedAccounts: [
        {
          name: "staking_config",
          pda: true
        },
        {
          name: "authority",
          pda: false
        },
        {
          name: "system_program",
          pda: false
        }
      ],
      accounts: [
        {
          name: "staking_config",
          writable: true,
          signer: false,
          optional: false,
          docs: [],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  115,
                  116,
                  97,
                  107,
                  105,
                  110,
                  103,
                  95,
                  99,
                  111,
                  110,
                  102,
                  105,
                  103
                ]
              }
            ]
          }
        },
        {
          name: "authority",
          writable: true,
          signer: true,
          optional: false,
          docs: []
        },
        {
          name: "system_program",
          writable: false,
          signer: false,
          optional: false,
          docs: [],
          address: "11111111111111111111111111111111"
        }
      ],
      docs: "Initialize GHOST token staking configuration (admin only)",
      discriminator: [
        78,
        164,
        6,
        115,
        206,
        48,
        168,
        105
      ],
      args: [
        {
          name: "min_stake",
          type: "u64"
        },
        {
          name: "treasury",
          type: "pubkey"
        }
      ]
    },
    issue_credential: {
      name: "issue_credential",
      expectedAccounts: [
        {
          name: "credential",
          pda: true
        },
        {
          name: "credential_template",
          pda: false
        },
        {
          name: "credential_type",
          pda: false
        },
        {
          name: "subject",
          pda: false
        },
        {
          name: "issuer",
          pda: false
        },
        {
          name: "system_program",
          pda: false
        }
      ],
      accounts: [
        {
          name: "credential",
          writable: true,
          signer: false,
          optional: false,
          docs: [],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  99,
                  114,
                  101,
                  100,
                  101,
                  110,
                  116,
                  105,
                  97,
                  108
                ]
              },
              {
                kind: "account",
                path: "credential_template"
              },
              {
                kind: "account",
                path: "subject"
              },
              {
                kind: "arg",
                path: "credential_id"
              }
            ]
          }
        },
        {
          name: "credential_template",
          writable: true,
          signer: false,
          optional: false,
          docs: []
        },
        {
          name: "credential_type",
          writable: true,
          signer: false,
          optional: false,
          docs: []
        },
        {
          name: "subject",
          writable: false,
          signer: false,
          optional: false,
          docs: []
        },
        {
          name: "issuer",
          writable: true,
          signer: true,
          optional: false,
          docs: []
        },
        {
          name: "system_program",
          writable: false,
          signer: false,
          optional: false,
          docs: [],
          address: "11111111111111111111111111111111"
        }
      ],
      docs: "Issue a new credential to a subject The subject_data is stored off-chain; only the hash is stored on-chain.",
      discriminator: [
        255,
        193,
        171,
        224,
        68,
        171,
        194,
        87
      ],
      args: [
        {
          name: "credential_id",
          type: "string"
        },
        {
          name: "subject_data_hash",
          type: {
            array: [
              "u8",
              32
            ]
          }
        },
        {
          name: "subject_data_uri",
          type: "string"
        },
        {
          name: "expires_at",
          type: {
            option: "i64"
          }
        },
        {
          name: "source_account",
          type: {
            option: "pubkey"
          }
        }
      ]
    },
    link_external_id: {
      name: "link_external_id",
      expectedAccounts: [
        {
          name: "agent_account",
          pda: false
        },
        {
          name: "external_id_mapping",
          pda: true
        },
        {
          name: "authority",
          pda: false
        },
        {
          name: "system_program",
          pda: false
        }
      ],
      accounts: [
        {
          name: "agent_account",
          writable: true,
          signer: false,
          optional: false,
          docs: []
        },
        {
          name: "external_id_mapping",
          writable: true,
          signer: false,
          optional: false,
          docs: [],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  101,
                  120,
                  116,
                  101,
                  114,
                  110,
                  97,
                  108,
                  95,
                  105,
                  100
                ]
              },
              {
                kind: "arg",
                path: "platform"
              },
              {
                kind: "arg",
                path: "external_id"
              }
            ]
          }
        },
        {
          name: "authority",
          writable: true,
          signer: true,
          optional: false,
          docs: []
        },
        {
          name: "system_program",
          writable: false,
          signer: false,
          optional: false,
          docs: [],
          address: "11111111111111111111111111111111"
        }
      ],
      docs: 'Link a platform-specific external ID to a Ghost  Creates a cross-platform identity mapping for this Ghost. Only the Ghost owner can link external IDs.  Parameters: - platform: Platform identifier (e.g., "payai", "eliza", "github") (max 32 chars) - external_id: Platform-specific agent ID (max 128 chars) - verified: Whether this external ID has been verified',
      discriminator: [
        156,
        102,
        141,
        155,
        175,
        13,
        29,
        86
      ],
      args: [
        {
          name: "platform",
          type: "string"
        },
        {
          name: "external_id",
          type: "string"
        },
        {
          name: "verified",
          type: "bool"
        }
      ]
    },
    manage_agent_status: {
      name: "manage_agent_status",
      expectedAccounts: [
        {
          name: "agent",
          pda: true
        },
        {
          name: "owner",
          pda: false
        },
        {
          name: "clock",
          pda: false
        }
      ],
      accounts: [
        {
          name: "agent",
          writable: true,
          signer: false,
          optional: false,
          docs: [
            "Agent account with strict validation"
          ],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  97,
                  103,
                  101,
                  110,
                  116
                ]
              },
              {
                kind: "account",
                path: "owner"
              }
            ]
          }
        },
        {
          name: "owner",
          writable: false,
          signer: true,
          optional: false,
          docs: [
            "Owner authority"
          ]
        },
        {
          name: "clock",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "Clock sysvar for timestamp validation"
          ],
          address: "SysvarC1ock11111111111111111111111111111111"
        }
      ],
      docs: "",
      discriminator: [
        164,
        219,
        91,
        38,
        45,
        31,
        33,
        47
      ],
      args: [
        {
          name: "new_status",
          type: "bool"
        }
      ]
    },
    record_payai_payment: {
      name: "record_payai_payment",
      expectedAccounts: [
        {
          name: "reputation_metrics",
          pda: true
        },
        {
          name: "agent",
          pda: false
        },
        {
          name: "authority",
          pda: false
        },
        {
          name: "clock",
          pda: false
        }
      ],
      accounts: [
        {
          name: "reputation_metrics",
          writable: true,
          signer: false,
          optional: false,
          docs: [
            "Reputation metrics account"
          ],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  114,
                  101,
                  112,
                  117,
                  116,
                  97,
                  116,
                  105,
                  111,
                  110,
                  95,
                  109,
                  101,
                  116,
                  114,
                  105,
                  99,
                  115
                ]
              },
              {
                kind: "account",
                path: "agent"
              }
            ]
          }
        },
        {
          name: "agent",
          writable: true,
          signer: false,
          optional: false,
          docs: [
            "Agent account"
          ]
        },
        {
          name: "authority",
          writable: false,
          signer: true,
          optional: false,
          docs: [
            "Authority (can be the payment verifier or agent owner)"
          ]
        },
        {
          name: "clock",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "Clock for timestamps"
          ],
          address: "SysvarC1ock11111111111111111111111111111111"
        }
      ],
      docs: "Record a PayAI payment transaction for reputation tracking  Consumes payment data from PayAI protocol to update agent reputation. This does NOT facilitate payments - it only tracks them for reputation.  Parameters: - payment_signature: PayAI transaction signature - amount: Payment amount in lamports - response_time_ms: Service response time - success: Whether payment completed successfully",
      discriminator: [
        165,
        202,
        159,
        139,
        65,
        65,
        36,
        163
      ],
      args: [
        {
          name: "payment_signature",
          type: "string"
        },
        {
          name: "amount",
          type: "u64"
        },
        {
          name: "response_time_ms",
          type: "u64"
        },
        {
          name: "success",
          type: "bool"
        }
      ]
    },
    register_agent: {
      name: "register_agent",
      expectedAccounts: [
        {
          name: "agent_account",
          pda: true
        },
        {
          name: "staking_account",
          pda: true
        },
        {
          name: "signer",
          pda: false
        },
        {
          name: "system_program",
          pda: false
        },
        {
          name: "clock",
          pda: false
        }
      ],
      accounts: [
        {
          name: "agent_account",
          writable: true,
          signer: false,
          optional: false,
          docs: [
            "Agent account with enhanced 2025 PDA security"
          ],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  97,
                  103,
                  101,
                  110,
                  116
                ]
              },
              {
                kind: "account",
                path: "signer"
              },
              {
                kind: "arg",
                path: "agent_id"
              }
            ]
          }
        },
        {
          name: "staking_account",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "Staking account - REQUIRED for Sybil resistance (must have >= 1K GHOST staked)"
          ],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  115,
                  116,
                  97,
                  107,
                  105,
                  110,
                  103
                ]
              },
              {
                kind: "account",
                path: "signer"
              }
            ]
          }
        },
        {
          name: "signer",
          writable: true,
          signer: true,
          optional: false,
          docs: [
            "User registry with enhanced validation",
            "Authority with enhanced verification"
          ]
        },
        {
          name: "system_program",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "System program for account creation"
          ],
          address: "11111111111111111111111111111111"
        },
        {
          name: "clock",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "Clock sysvar for timestamp validation"
          ],
          address: "SysvarC1ock11111111111111111111111111111111"
        }
      ],
      docs: "",
      discriminator: [
        135,
        157,
        66,
        195,
        2,
        113,
        175,
        30
      ],
      args: [
        {
          name: "agent_type",
          type: "u8"
        },
        {
          name: "name",
          type: "string"
        },
        {
          name: "description",
          type: "string"
        },
        {
          name: "metadata_uri",
          type: "string"
        },
        {
          name: "_agent_id",
          type: "string"
        },
        {
          name: "pricing_model",
          type: {
            defined: {
              name: "PricingModel"
            }
          }
        }
      ]
    },
    register_agent_compressed: {
      name: "register_agent_compressed",
      expectedAccounts: [
        {
          name: "tree_authority",
          pda: true
        },
        {
          name: "merkle_tree",
          pda: false
        },
        {
          name: "user_registry",
          pda: true
        },
        {
          name: "signer",
          pda: false
        },
        {
          name: "compression_program",
          pda: false
        },
        {
          name: "log_wrapper",
          pda: false
        },
        {
          name: "system_program",
          pda: false
        },
        {
          name: "clock",
          pda: false
        }
      ],
      accounts: [
        {
          name: "tree_authority",
          writable: true,
          signer: false,
          optional: false,
          docs: [
            "Tree authority PDA that manages the compressed Agent tree"
          ],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  97,
                  103,
                  101,
                  110,
                  116,
                  95,
                  116,
                  114,
                  101,
                  101,
                  95,
                  99,
                  111,
                  110,
                  102,
                  105,
                  103
                ]
              },
              {
                kind: "account",
                path: "signer"
              }
            ]
          }
        },
        {
          name: "merkle_tree",
          writable: true,
          signer: false,
          optional: false,
          docs: [
            "The Merkle tree account that stores compressed Agent data"
          ]
        },
        {
          name: "user_registry",
          writable: true,
          signer: false,
          optional: false,
          docs: [
            "User registry with enhanced validation"
          ],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  117,
                  115,
                  101,
                  114,
                  95,
                  114,
                  101,
                  103,
                  105,
                  115,
                  116,
                  114,
                  121
                ]
              },
              {
                kind: "account",
                path: "signer"
              }
            ]
          }
        },
        {
          name: "signer",
          writable: true,
          signer: true,
          optional: false,
          docs: [
            "Authority with enhanced verification"
          ]
        },
        {
          name: "compression_program",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "SPL Account Compression program"
          ],
          address: "cmtDvXumGCrqC1Age74AVPhSRVXJMd8PJS91L8KbNCK"
        },
        {
          name: "log_wrapper",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "SPL Noop program for logging"
          ],
          address: "noopb9bkMVfRPU8AsbpTUg8AQkHtKwMYZiFUjNRtMmV"
        },
        {
          name: "system_program",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "System program for account creation"
          ],
          address: "11111111111111111111111111111111"
        },
        {
          name: "clock",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "Clock sysvar for timestamps"
          ],
          address: "SysvarC1ock11111111111111111111111111111111"
        }
      ],
      docs: "Register Agent using ZK compression (solves error 2006 with 5000x cost reduction)",
      discriminator: [
        15,
        6,
        94,
        55,
        65,
        80,
        123,
        248
      ],
      args: [
        {
          name: "agent_type",
          type: "u8"
        },
        {
          name: "metadata_uri",
          type: "string"
        },
        {
          name: "agent_id",
          type: "string"
        },
        {
          name: "name",
          type: "string"
        },
        {
          name: "description",
          type: "string"
        },
        {
          name: "pricing_model",
          type: {
            defined: {
              name: "PricingModel"
            }
          }
        }
      ]
    },
    register_ghost_metadata: {
      name: "register_ghost_metadata",
      expectedAccounts: [
        {
          name: "agent_account",
          pda: false
        },
        {
          name: "authority",
          pda: false
        }
      ],
      accounts: [
        {
          name: "agent_account",
          writable: true,
          signer: false,
          optional: false,
          docs: []
        },
        {
          name: "authority",
          writable: true,
          signer: true,
          optional: false,
          docs: [
            "Anyone can add metadata to an Unregistered Ghost",
            "Claiming proves ownership later"
          ]
        }
      ],
      docs: "Register metadata for an Unregistered Ghost  Adds name, description, capabilities, and service endpoint to a discovered Ghost. Transitions: Unregistered â†’ Registered Anyone can add metadata to an Unregistered Ghost.  Parameters: - name: Agent name (max 64 chars) - description: Agent description (max 128 chars) - capabilities: List of capabilities (max 5) - service_endpoint: Optional HTTP endpoint for the agent service",
      discriminator: [
        34,
        233,
        111,
        236,
        212,
        22,
        26,
        254
      ],
      args: [
        {
          name: "name",
          type: "string"
        },
        {
          name: "description",
          type: "string"
        },
        {
          name: "capabilities",
          type: {
            vec: "string"
          }
        },
        {
          name: "service_endpoint",
          type: {
            option: "string"
          }
        }
      ]
    },
    reset_reentrancy_guard: {
      name: "reset_reentrancy_guard",
      expectedAccounts: [
        {
          name: "reentrancy_guard",
          pda: true
        },
        {
          name: "authority",
          pda: false
        }
      ],
      accounts: [
        {
          name: "reentrancy_guard",
          writable: true,
          signer: false,
          optional: false,
          docs: [],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  114,
                  101,
                  101,
                  110,
                  116,
                  114,
                  97,
                  110,
                  99,
                  121,
                  95,
                  103,
                  117,
                  97,
                  114,
                  100
                ]
              }
            ]
          }
        },
        {
          name: "authority",
          writable: true,
          signer: true,
          optional: false,
          docs: []
        }
      ],
      docs: "Reset a stuck reentrancy guard (admin only) Use this to recover from stuck states after failed transactions",
      discriminator: [
        93,
        74,
        168,
        125,
        46,
        153,
        9,
        255
      ],
      args: []
    },
    resolve_did_document: {
      name: "resolve_did_document",
      expectedAccounts: [
        {
          name: "did_document",
          pda: true
        },
        {
          name: "did_controller",
          pda: false
        }
      ],
      accounts: [
        {
          name: "did_document",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "DID document account"
          ],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  100,
                  105,
                  100,
                  95,
                  100,
                  111,
                  99,
                  117,
                  109,
                  101,
                  110,
                  116
                ]
              },
              {
                kind: "account",
                path: "did_controller"
              }
            ]
          }
        },
        {
          name: "did_controller",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "Controller public key (used for PDA derivation)"
          ]
        }
      ],
      docs: "Resolve a DID document (read-only)  Returns the DID document data for off-chain resolution. This instruction exists for compatibility with standard DID resolution flows.",
      discriminator: [
        168,
        180,
        218,
        211,
        184,
        19,
        102,
        12
      ],
      args: []
    },
    revoke_authorization: {
      name: "revoke_authorization",
      expectedAccounts: [
        {
          name: "agent",
          pda: false
        },
        {
          name: "authorization",
          pda: true
        },
        {
          name: "authority",
          pda: false
        }
      ],
      accounts: [
        {
          name: "agent",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "Agent revoking authorization"
          ]
        },
        {
          name: "authorization",
          writable: true,
          signer: false,
          optional: false,
          docs: [
            "Authorization account (PDA)"
          ],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  97,
                  103,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104
                ]
              },
              {
                kind: "account",
                path: "agent"
              },
              {
                kind: "account",
                path: "authorization.authorized_source",
                account: "AgentReputationAuth"
              },
              {
                kind: "arg",
                path: "_nonce"
              }
            ]
          }
        },
        {
          name: "authority",
          writable: false,
          signer: true,
          optional: false,
          docs: [
            "Authority (agent owner)"
          ]
        }
      ],
      docs: "Revoke agent authorization  Allows an agent to revoke a previously granted authorization. Once revoked, the facilitator can no longer update reputation.  Parameters: - nonce: Optional nonce identifying the specific authorization to revoke",
      discriminator: [
        222,
        179,
        207,
        59,
        191,
        78,
        24,
        248
      ],
      args: [
        {
          name: "nonce",
          type: {
            option: "string"
          }
        }
      ]
    },
    revoke_credential: {
      name: "revoke_credential",
      expectedAccounts: [
        {
          name: "credential",
          pda: false
        },
        {
          name: "issuer",
          pda: false
        }
      ],
      accounts: [
        {
          name: "credential",
          writable: true,
          signer: false,
          optional: false,
          docs: []
        },
        {
          name: "issuer",
          writable: true,
          signer: true,
          optional: false,
          docs: []
        }
      ],
      docs: "Revoke an issued credential Only the original issuer can revoke.",
      discriminator: [
        38,
        123,
        95,
        95,
        223,
        158,
        169,
        87
      ],
      args: []
    },
    slash_stake: {
      name: "slash_stake",
      expectedAccounts: [
        {
          name: "staking_account",
          pda: true
        },
        {
          name: "staking_config",
          pda: true
        },
        {
          name: "staking_vault",
          pda: true
        },
        {
          name: "treasury",
          pda: false
        },
        {
          name: "authority",
          pda: false
        },
        {
          name: "token_program",
          pda: false
        }
      ],
      accounts: [
        {
          name: "staking_account",
          writable: true,
          signer: false,
          optional: false,
          docs: [],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  115,
                  116,
                  97,
                  107,
                  105,
                  110,
                  103
                ]
              },
              {
                kind: "arg",
                path: "owner"
              }
            ]
          }
        },
        {
          name: "staking_config",
          writable: false,
          signer: false,
          optional: false,
          docs: [],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  115,
                  116,
                  97,
                  107,
                  105,
                  110,
                  103,
                  95,
                  99,
                  111,
                  110,
                  102,
                  105,
                  103
                ]
              }
            ]
          }
        },
        {
          name: "staking_vault",
          writable: true,
          signer: false,
          optional: false,
          docs: [],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  115,
                  116,
                  97,
                  107,
                  105,
                  110,
                  103,
                  95,
                  118,
                  97,
                  117,
                  108,
                  116
                ]
              },
              {
                kind: "account",
                path: "staking_config"
              }
            ]
          }
        },
        {
          name: "treasury",
          writable: true,
          signer: false,
          optional: false,
          docs: []
        },
        {
          name: "authority",
          writable: false,
          signer: true,
          optional: false,
          docs: []
        },
        {
          name: "token_program",
          writable: false,
          signer: false,
          optional: false,
          docs: [],
          address: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
        }
      ],
      docs: "Slash staked tokens (admin only, for fraud/disputes)",
      discriminator: [
        190,
        242,
        137,
        27,
        41,
        18,
        233,
        37
      ],
      args: [
        {
          name: "owner",
          type: "pubkey"
        },
        {
          name: "reason",
          type: {
            defined: {
              name: "SlashReason"
            }
          }
        },
        {
          name: "custom_amount",
          type: {
            option: "u64"
          }
        }
      ]
    },
    stake_ghost: {
      name: "stake_ghost",
      expectedAccounts: [
        {
          name: "staking_account",
          pda: true
        },
        {
          name: "owner_token_account",
          pda: false
        },
        {
          name: "staking_vault",
          pda: true
        },
        {
          name: "staking_config",
          pda: false
        },
        {
          name: "ghost_mint",
          pda: false
        },
        {
          name: "owner",
          pda: false
        },
        {
          name: "token_program",
          pda: false
        },
        {
          name: "system_program",
          pda: false
        },
        {
          name: "rent",
          pda: false
        }
      ],
      accounts: [
        {
          name: "staking_account",
          writable: true,
          signer: false,
          optional: false,
          docs: [],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  115,
                  116,
                  97,
                  107,
                  105,
                  110,
                  103
                ]
              },
              {
                kind: "account",
                path: "owner"
              }
            ]
          }
        },
        {
          name: "owner_token_account",
          writable: true,
          signer: false,
          optional: false,
          docs: []
        },
        {
          name: "staking_vault",
          writable: true,
          signer: false,
          optional: false,
          docs: [
            "Staking vault to hold all staked GHOST tokens",
            "Automatically initialized on first stake using init_if_needed"
          ],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  115,
                  116,
                  97,
                  107,
                  105,
                  110,
                  103,
                  95,
                  118,
                  97,
                  117,
                  108,
                  116
                ]
              },
              {
                kind: "account",
                path: "staking_config"
              }
            ]
          }
        },
        {
          name: "staking_config",
          writable: false,
          signer: false,
          optional: false,
          docs: []
        },
        {
          name: "ghost_mint",
          writable: false,
          signer: false,
          optional: false,
          docs: []
        },
        {
          name: "owner",
          writable: true,
          signer: true,
          optional: false,
          docs: []
        },
        {
          name: "token_program",
          writable: false,
          signer: false,
          optional: false,
          docs: [],
          address: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
        },
        {
          name: "system_program",
          writable: false,
          signer: false,
          optional: false,
          docs: [],
          address: "11111111111111111111111111111111"
        },
        {
          name: "rent",
          writable: false,
          signer: false,
          optional: false,
          docs: [],
          address: "SysvarRent111111111111111111111111111111111"
        }
      ],
      docs: "Stake GHOST tokens to boost agent reputation",
      discriminator: [
        5,
        196,
        24,
        54,
        196,
        56,
        173,
        191
      ],
      args: [
        {
          name: "amount",
          type: "u64"
        },
        {
          name: "lock_duration",
          type: "i64"
        }
      ]
    },
    submit_delivery: {
      name: "submit_delivery",
      expectedAccounts: [
        {
          name: "escrow",
          pda: true
        },
        {
          name: "agent",
          pda: false
        },
        {
          name: "agent_owner",
          pda: false
        }
      ],
      accounts: [
        {
          name: "escrow",
          writable: true,
          signer: false,
          optional: false,
          docs: [],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  103,
                  104,
                  111,
                  115,
                  116,
                  95,
                  112,
                  114,
                  111,
                  116,
                  101,
                  99,
                  116
                ]
              },
              {
                kind: "account",
                path: "escrow.client",
                account: "GhostProtectEscrow"
              },
              {
                kind: "account",
                path: "escrow.escrow_id",
                account: "GhostProtectEscrow"
              }
            ]
          }
        },
        {
          name: "agent",
          writable: false,
          signer: false,
          optional: false,
          docs: []
        },
        {
          name: "agent_owner",
          writable: false,
          signer: true,
          optional: false,
          docs: []
        }
      ],
      docs: "Agent submits work delivery proof",
      discriminator: [
        217,
        177,
        33,
        54,
        136,
        185,
        123,
        96
      ],
      args: [
        {
          name: "delivery_proof",
          type: "string"
        }
      ]
    },
    submit_service_rating: {
      name: "submit_service_rating",
      expectedAccounts: [
        {
          name: "reputation_metrics",
          pda: true
        },
        {
          name: "agent",
          pda: false
        },
        {
          name: "client",
          pda: false
        },
        {
          name: "clock",
          pda: false
        }
      ],
      accounts: [
        {
          name: "reputation_metrics",
          writable: true,
          signer: false,
          optional: false,
          docs: [
            "Reputation metrics account"
          ],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  114,
                  101,
                  112,
                  117,
                  116,
                  97,
                  116,
                  105,
                  111,
                  110,
                  95,
                  109,
                  101,
                  116,
                  114,
                  105,
                  99,
                  115
                ]
              },
              {
                kind: "account",
                path: "agent"
              }
            ]
          }
        },
        {
          name: "agent",
          writable: true,
          signer: false,
          optional: false,
          docs: [
            "Agent account"
          ]
        },
        {
          name: "client",
          writable: false,
          signer: true,
          optional: false,
          docs: [
            "Client submitting the rating"
          ]
        },
        {
          name: "clock",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "Clock for timestamps"
          ],
          address: "SysvarC1ock11111111111111111111111111111111"
        }
      ],
      docs: "Submit a service rating after a completed transaction  Allows clients to rate agent service quality (1-5 scale). Ratings are factored into the overall reputation score calculation.  Parameters: - rating: Service rating from 1 (poor) to 5 (excellent) - payment_signature: Associated PayAI transaction signature",
      discriminator: [
        23,
        160,
        228,
        88,
        168,
        145,
        129,
        19
      ],
      args: [
        {
          name: "rating",
          type: "u8"
        },
        {
          name: "payment_signature",
          type: "string"
        }
      ]
    },
    unstake_ghost: {
      name: "unstake_ghost",
      expectedAccounts: [
        {
          name: "staking_account",
          pda: true
        },
        {
          name: "staking_config",
          pda: true
        },
        {
          name: "staking_vault",
          pda: true
        },
        {
          name: "owner_token_account",
          pda: false
        },
        {
          name: "owner",
          pda: false
        },
        {
          name: "token_program",
          pda: false
        }
      ],
      accounts: [
        {
          name: "staking_account",
          writable: true,
          signer: false,
          optional: false,
          docs: [],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  115,
                  116,
                  97,
                  107,
                  105,
                  110,
                  103
                ]
              },
              {
                kind: "account",
                path: "owner"
              }
            ]
          }
        },
        {
          name: "staking_config",
          writable: false,
          signer: false,
          optional: false,
          docs: [],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  115,
                  116,
                  97,
                  107,
                  105,
                  110,
                  103,
                  95,
                  99,
                  111,
                  110,
                  102,
                  105,
                  103
                ]
              }
            ]
          }
        },
        {
          name: "staking_vault",
          writable: true,
          signer: false,
          optional: false,
          docs: [],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  115,
                  116,
                  97,
                  107,
                  105,
                  110,
                  103,
                  95,
                  118,
                  97,
                  117,
                  108,
                  116
                ]
              },
              {
                kind: "account",
                path: "staking_config"
              }
            ]
          }
        },
        {
          name: "owner_token_account",
          writable: true,
          signer: false,
          optional: false,
          docs: []
        },
        {
          name: "owner",
          writable: true,
          signer: true,
          optional: false,
          docs: []
        },
        {
          name: "token_program",
          writable: false,
          signer: false,
          optional: false,
          docs: [],
          address: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
        }
      ],
      docs: "Unstake GHOST tokens after lock period expires",
      discriminator: [
        252,
        101,
        172,
        252,
        1,
        4,
        12,
        116
      ],
      args: []
    },
    update_agent: {
      name: "update_agent",
      expectedAccounts: [
        {
          name: "agent_account",
          pda: true
        },
        {
          name: "signer",
          pda: false
        },
        {
          name: "clock",
          pda: false
        }
      ],
      accounts: [
        {
          name: "agent_account",
          writable: true,
          signer: false,
          optional: false,
          docs: [
            "Agent account with canonical PDA validation"
          ],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  97,
                  103,
                  101,
                  110,
                  116
                ]
              },
              {
                kind: "account",
                path: "signer"
              },
              {
                kind: "arg",
                path: "agent_id"
              }
            ]
          }
        },
        {
          name: "signer",
          writable: true,
          signer: true,
          optional: false,
          docs: [
            "Enhanced authority verification"
          ]
        },
        {
          name: "clock",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "Clock sysvar for rate limiting"
          ],
          address: "SysvarC1ock11111111111111111111111111111111"
        }
      ],
      docs: "",
      discriminator: [
        85,
        2,
        178,
        9,
        119,
        139,
        102,
        164
      ],
      args: [
        {
          name: "_agent_type",
          type: "u8"
        },
        {
          name: "name",
          type: {
            option: "string"
          }
        },
        {
          name: "description",
          type: {
            option: "string"
          }
        },
        {
          name: "metadata_uri",
          type: "string"
        },
        {
          name: "_agent_id",
          type: "string"
        },
        {
          name: "pricing_model",
          type: {
            option: {
              defined: {
                name: "PricingModel"
              }
            }
          }
        }
      ]
    },
    update_agent_reputation: {
      name: "update_agent_reputation",
      expectedAccounts: [
        {
          name: "agent_account",
          pda: true
        },
        {
          name: "signer",
          pda: false
        },
        {
          name: "clock",
          pda: false
        }
      ],
      accounts: [
        {
          name: "agent_account",
          writable: true,
          signer: false,
          optional: false,
          docs: [
            "Agent account with canonical PDA validation"
          ],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  97,
                  103,
                  101,
                  110,
                  116
                ]
              },
              {
                kind: "account",
                path: "signer"
              },
              {
                kind: "arg",
                path: "agent_id"
              }
            ]
          }
        },
        {
          name: "signer",
          writable: true,
          signer: true,
          optional: false,
          docs: [
            "Enhanced authority verification"
          ]
        },
        {
          name: "clock",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "Clock sysvar for rate limiting"
          ],
          address: "SysvarC1ock11111111111111111111111111111111"
        }
      ],
      docs: "",
      discriminator: [
        80,
        227,
        92,
        245,
        231,
        37,
        99,
        180
      ],
      args: [
        {
          name: "agent_id",
          type: "string"
        },
        {
          name: "reputation_score",
          type: "u64"
        }
      ]
    },
    update_agent_service: {
      name: "update_agent_service",
      expectedAccounts: [
        {
          name: "agent",
          pda: true
        },
        {
          name: "owner",
          pda: false
        },
        {
          name: "system_program",
          pda: false
        }
      ],
      accounts: [
        {
          name: "agent",
          writable: true,
          signer: false,
          optional: false,
          docs: [
            "Agent account with enhanced 2025 security patterns"
          ],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  97,
                  103,
                  101,
                  110,
                  116
                ]
              },
              {
                kind: "account",
                path: "owner"
              }
            ]
          }
        },
        {
          name: "owner",
          writable: true,
          signer: true,
          optional: false,
          docs: [
            "Owner must be signer for security (2025 pattern)"
          ]
        },
        {
          name: "system_program",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "System program for account operations"
          ],
          address: "11111111111111111111111111111111"
        }
      ],
      docs: "",
      discriminator: [
        87,
        146,
        181,
        198,
        252,
        68,
        243,
        102
      ],
      args: [
        {
          name: "service_data",
          type: {
            defined: {
              name: "AgentServiceData"
            }
          }
        }
      ]
    },
    update_crosschain_status: {
      name: "update_crosschain_status",
      expectedAccounts: [
        {
          name: "credential",
          pda: false
        },
        {
          name: "issuer",
          pda: false
        }
      ],
      accounts: [
        {
          name: "credential",
          writable: true,
          signer: false,
          optional: false,
          docs: []
        },
        {
          name: "issuer",
          writable: true,
          signer: true,
          optional: false,
          docs: []
        }
      ],
      docs: "Update the cross-chain sync status after syncing to Crossmint",
      discriminator: [
        22,
        167,
        59,
        238,
        22,
        231,
        239,
        146
      ],
      args: [
        {
          name: "crossmint_credential_id",
          type: "string"
        },
        {
          name: "status",
          type: {
            defined: {
              name: "CrossChainStatus"
            }
          }
        }
      ]
    },
    update_did_document: {
      name: "update_did_document",
      expectedAccounts: [
        {
          name: "did_document",
          pda: true
        },
        {
          name: "controller",
          pda: false
        },
        {
          name: "clock",
          pda: false
        }
      ],
      accounts: [
        {
          name: "did_document",
          writable: true,
          signer: false,
          optional: false,
          docs: [
            "DID document account with canonical PDA validation"
          ],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  100,
                  105,
                  100,
                  95,
                  100,
                  111,
                  99,
                  117,
                  109,
                  101,
                  110,
                  116
                ]
              },
              {
                kind: "account",
                path: "controller"
              }
            ]
          }
        },
        {
          name: "controller",
          writable: true,
          signer: true,
          optional: false,
          docs: [
            "Controller of the DID (must match document controller)"
          ]
        },
        {
          name: "clock",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "Clock sysvar for timestamp validation"
          ],
          address: "SysvarC1ock11111111111111111111111111111111"
        }
      ],
      docs: "Update an existing DID document  Add or remove verification methods and service endpoints. Only the controller can update the DID document.  Parameters: - add_verification_method: Optional verification method to add - remove_verification_method_id: Optional method ID to remove - add_service_endpoint: Optional service endpoint to add - remove_service_endpoint_id: Optional service ID to remove",
      discriminator: [
        64,
        216,
        17,
        91,
        205,
        94,
        45,
        57
      ],
      args: [
        {
          name: "add_verification_method",
          type: {
            option: {
              defined: {
                name: "VerificationMethod"
              }
            }
          }
        },
        {
          name: "remove_verification_method_id",
          type: {
            option: "string"
          }
        },
        {
          name: "add_service_endpoint",
          type: {
            option: {
              defined: {
                name: "ServiceEndpoint"
              }
            }
          }
        },
        {
          name: "remove_service_endpoint_id",
          type: {
            option: "string"
          }
        }
      ]
    },
    update_ghost_score: {
      name: "update_ghost_score",
      expectedAccounts: [
        {
          name: "agent_account",
          pda: false
        },
        {
          name: "authority",
          pda: false
        }
      ],
      accounts: [
        {
          name: "agent_account",
          writable: true,
          signer: false,
          optional: false,
          docs: []
        },
        {
          name: "authority",
          writable: false,
          signer: true,
          optional: false,
          docs: [
            "Authority allowed to update scores (could be governance/oracle)"
          ]
        }
      ],
      docs: "Update Ghost Score from off-chain calculation  Called by the reputation oracle/calculator service. Updates the weighted Ghost Score and optionally the reputation components.  Parameters: - new_score: New Ghost Score (0-1000) - components: Optional reputation component breakdown",
      discriminator: [
        213,
        152,
        5,
        80,
        163,
        224,
        151,
        120
      ],
      args: [
        {
          name: "new_score",
          type: "u64"
        },
        {
          name: "components",
          type: {
            option: {
              vec: {
                defined: {
                  name: "ReputationComponent"
                }
              }
            }
          }
        }
      ]
    },
    update_protocol_config: {
      name: "update_protocol_config",
      expectedAccounts: [
        {
          name: "config",
          pda: true
        },
        {
          name: "authority",
          pda: false
        }
      ],
      accounts: [
        {
          name: "config",
          writable: true,
          signer: false,
          optional: false,
          docs: [],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  112,
                  114,
                  111,
                  116,
                  111,
                  99,
                  111,
                  108,
                  95,
                  99,
                  111,
                  110,
                  102,
                  105,
                  103
                ]
              }
            ]
          }
        },
        {
          name: "authority",
          writable: false,
          signer: true,
          optional: false,
          docs: []
        }
      ],
      docs: "Update protocol configuration parameters",
      discriminator: [
        197,
        97,
        123,
        54,
        221,
        168,
        11,
        135
      ],
      args: [
        {
          name: "escrow_fee_bps",
          type: {
            option: "u16"
          }
        },
        {
          name: "agent_registration_fee",
          type: {
            option: "u64"
          }
        },
        {
          name: "listing_fee",
          type: {
            option: "u64"
          }
        },
        {
          name: "dispute_fee_bps",
          type: {
            option: "u16"
          }
        },
        {
          name: "fees_enabled",
          type: {
            option: "bool"
          }
        },
        {
          name: "treasury",
          type: {
            option: "pubkey"
          }
        },
        {
          name: "buyback_pool",
          type: {
            option: "pubkey"
          }
        },
        {
          name: "moderator_pool",
          type: {
            option: "pubkey"
          }
        }
      ]
    },
    update_reputation_tags: {
      name: "update_reputation_tags",
      expectedAccounts: [
        {
          name: "reputation_metrics",
          pda: true
        },
        {
          name: "agent",
          pda: false
        },
        {
          name: "authority",
          pda: false
        },
        {
          name: "clock",
          pda: false
        }
      ],
      accounts: [
        {
          name: "reputation_metrics",
          writable: true,
          signer: false,
          optional: false,
          docs: [
            "Reputation metrics account"
          ],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  114,
                  101,
                  112,
                  117,
                  116,
                  97,
                  116,
                  105,
                  111,
                  110,
                  95,
                  109,
                  101,
                  116,
                  114,
                  105,
                  99,
                  115
                ]
              },
              {
                kind: "account",
                path: "agent"
              }
            ]
          }
        },
        {
          name: "agent",
          writable: true,
          signer: false,
          optional: false,
          docs: [
            "Agent account"
          ]
        },
        {
          name: "authority",
          writable: false,
          signer: true,
          optional: false,
          docs: [
            "Authority (can be the agent owner or authorized updater)"
          ]
        },
        {
          name: "clock",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "Clock for timestamps"
          ],
          address: "SysvarC1ock11111111111111111111111111111111"
        }
      ],
      docs: 'Update reputation tags for an agent  Adds or updates granular reputation tags with confidence scores. Tags are categorized into skill, behavior, and compliance tags. Each tag has a confidence score (0-10000 basis points) and evidence count.  Tag decay: Tags automatically decay at 10 bp/day and become stale after 90 days. This ensures reputation data stays current and reflects recent performance.  Parameters: - skill_tags: Skill tags to add (e.g., "rust", "smart-contracts") - max 20 - behavior_tags: Behavior tags (e.g., "responsive", "reliable") - max 20 - compliance_tags: Compliance tags (e.g., "kyc-verified") - max 10 - tag_scores: Tag scores with confidence and evidence - max 50',
      discriminator: [
        206,
        96,
        254,
        186,
        129,
        180,
        103,
        198
      ],
      args: [
        {
          name: "skill_tags",
          type: {
            vec: "string"
          }
        },
        {
          name: "behavior_tags",
          type: {
            vec: "string"
          }
        },
        {
          name: "compliance_tags",
          type: {
            vec: "string"
          }
        },
        {
          name: "tag_scores",
          type: {
            vec: {
              defined: {
                name: "TagScore"
              }
            }
          }
        }
      ]
    },
    update_reputation_with_auth: {
      name: "update_reputation_with_auth",
      expectedAccounts: [
        {
          name: "agent",
          pda: false
        },
        {
          name: "reputation_metrics",
          pda: true
        },
        {
          name: "authorization",
          pda: true
        },
        {
          name: "usage_record",
          pda: true
        },
        {
          name: "authorized_source",
          pda: false
        },
        {
          name: "system_program",
          pda: false
        },
        {
          name: "clock",
          pda: false
        }
      ],
      accounts: [
        {
          name: "agent",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "Agent whose reputation is being updated"
          ]
        },
        {
          name: "reputation_metrics",
          writable: true,
          signer: false,
          optional: false,
          docs: [
            "Agent reputation metrics"
          ],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  114,
                  101,
                  112,
                  117,
                  116,
                  97,
                  116,
                  105,
                  111,
                  110,
                  95,
                  109,
                  101,
                  116,
                  114,
                  105,
                  99,
                  115
                ]
              },
              {
                kind: "account",
                path: "agent"
              }
            ]
          }
        },
        {
          name: "authorization",
          writable: true,
          signer: false,
          optional: false,
          docs: [
            "Authorization account (PDA)"
          ],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  97,
                  103,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104
                ]
              },
              {
                kind: "account",
                path: "agent"
              },
              {
                kind: "account",
                path: "authorized_source"
              },
              {
                kind: "arg",
                path: "_nonce"
              }
            ]
          }
        },
        {
          name: "usage_record",
          writable: true,
          signer: false,
          optional: false,
          docs: [
            "Usage record account (optional, for audit trail)"
          ],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  97,
                  117,
                  116,
                  104,
                  95,
                  117,
                  115,
                  97,
                  103,
                  101
                ]
              },
              {
                kind: "account",
                path: "authorization"
              },
              {
                kind: "account",
                path: "authorization.current_index",
                account: "AgentReputationAuth"
              }
            ]
          }
        },
        {
          name: "authorized_source",
          writable: true,
          signer: true,
          optional: false,
          docs: [
            "Authorized source (e.g., PayAI facilitator)"
          ]
        },
        {
          name: "system_program",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "System program"
          ],
          address: "11111111111111111111111111111111"
        },
        {
          name: "clock",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "Clock for timestamps"
          ],
          address: "SysvarC1ock11111111111111111111111111111111"
        }
      ],
      docs: "Update agent reputation using authorization  Facilitators (e.g., PayAI) use this to update agent reputation using a pre-existing authorization from the agent.  Parameters: - reputation_change: Change to reputation score (can be positive or negative) - transaction_signature: Transaction signature for audit trail - metadata: Optional metadata about the reputation update - nonce: Optional nonce matching the authorization",
      discriminator: [
        61,
        236,
        225,
        167,
        134,
        43,
        53,
        93
      ],
      args: [
        {
          name: "reputation_change",
          type: "i64"
        },
        {
          name: "transaction_signature",
          type: "string"
        },
        {
          name: "metadata",
          type: {
            option: "string"
          }
        },
        {
          name: "nonce",
          type: {
            option: "string"
          }
        }
      ]
    },
    update_source_reputation: {
      name: "update_source_reputation",
      expectedAccounts: [
        {
          name: "reputation_metrics",
          pda: true
        },
        {
          name: "agent",
          pda: false
        },
        {
          name: "authority",
          pda: false
        },
        {
          name: "clock",
          pda: false
        }
      ],
      accounts: [
        {
          name: "reputation_metrics",
          writable: true,
          signer: false,
          optional: false,
          docs: [
            "Reputation metrics account"
          ],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  114,
                  101,
                  112,
                  117,
                  116,
                  97,
                  116,
                  105,
                  111,
                  110,
                  95,
                  109,
                  101,
                  116,
                  114,
                  105,
                  99,
                  115
                ]
              },
              {
                kind: "account",
                path: "agent"
              }
            ]
          }
        },
        {
          name: "agent",
          writable: true,
          signer: false,
          optional: false,
          docs: [
            "Agent account"
          ]
        },
        {
          name: "authority",
          writable: false,
          signer: true,
          optional: false,
          docs: [
            "Authority (can be oracle, agent owner, or authorized updater)"
          ]
        },
        {
          name: "clock",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "Clock for timestamps"
          ],
          address: "SysvarC1ock11111111111111111111111111111111"
        }
      ],
      docs: 'Update reputation from a specific source  Updates or adds a reputation score from an external source (e.g., GitHub, custom webhook). Automatically aggregates all sources and detects conflicts.  Parameters: - source_name: Source identifier (e.g., "github", "custom-webhook") - score: Reputation score from source (0-1000) - weight: Source weight in basis points (0-10000) - data_points: Number of metrics contributing to score - reliability: Source reliability in basis points (0-10000)',
      discriminator: [
        161,
        240,
        255,
        69,
        130,
        227,
        71,
        123
      ],
      args: [
        {
          name: "source_name",
          type: "string"
        },
        {
          name: "score",
          type: "u16"
        },
        {
          name: "weight",
          type: "u16"
        },
        {
          name: "data_points",
          type: "u32"
        },
        {
          name: "reliability",
          type: "u16"
        }
      ]
    },
    verify_agent: {
      name: "verify_agent",
      expectedAccounts: [
        {
          name: "agent_verification",
          pda: true
        },
        {
          name: "agent",
          pda: false
        },
        {
          name: "verifier",
          pda: false
        },
        {
          name: "system_program",
          pda: false
        },
        {
          name: "clock",
          pda: false
        }
      ],
      accounts: [
        {
          name: "agent_verification",
          writable: true,
          signer: false,
          optional: false,
          docs: [
            "Verification account with enhanced PDA security"
          ],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  97,
                  103,
                  101,
                  110,
                  116,
                  95,
                  118,
                  101,
                  114,
                  105,
                  102,
                  105,
                  99,
                  97,
                  116,
                  105,
                  111,
                  110
                ]
              },
              {
                kind: "account",
                path: "agent"
              },
              {
                kind: "account",
                path: "verifier"
              }
            ]
          }
        },
        {
          name: "agent",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "Agent account being verified (enhanced validation)"
          ]
        },
        {
          name: "verifier",
          writable: true,
          signer: true,
          optional: false,
          docs: [
            "Verifier authority with enhanced permissions"
          ]
        },
        {
          name: "system_program",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "System program for account operations"
          ],
          address: "11111111111111111111111111111111"
        },
        {
          name: "clock",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "Clock sysvar for timestamp validation"
          ],
          address: "SysvarC1ock11111111111111111111111111111111"
        }
      ],
      docs: "",
      discriminator: [
        206,
        212,
        108,
        12,
        105,
        61,
        100,
        66
      ],
      args: [
        {
          name: "agent_pubkey",
          type: "pubkey"
        },
        {
          name: "service_endpoint",
          type: "string"
        },
        {
          name: "supported_capabilities",
          type: {
            vec: "u64"
          }
        },
        {
          name: "verified_at",
          type: "i64"
        }
      ]
    },
    verify_authorization: {
      name: "verify_authorization",
      expectedAccounts: [
        {
          name: "agent",
          pda: false
        },
        {
          name: "authorization",
          pda: true
        },
        {
          name: "clock",
          pda: false
        }
      ],
      accounts: [
        {
          name: "agent",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "Agent account"
          ]
        },
        {
          name: "authorization",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "Authorization account (PDA)"
          ],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  97,
                  103,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104
                ]
              },
              {
                kind: "account",
                path: "agent"
              },
              {
                kind: "account",
                path: "authorization.authorized_source",
                account: "AgentReputationAuth"
              },
              {
                kind: "arg",
                path: "_nonce"
              }
            ]
          }
        },
        {
          name: "clock",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "Clock for timestamp validation"
          ],
          address: "SysvarC1ock11111111111111111111111111111111"
        }
      ],
      docs: "Verify agent authorization (view-only)  Checks if an authorization is valid and returns its status. This is a read-only instruction for verification purposes.  Parameters: - nonce: Optional nonce identifying the specific authorization to verify",
      discriminator: [
        43,
        9,
        131,
        59,
        74,
        118,
        113,
        170
      ],
      args: [
        {
          name: "nonce",
          type: {
            option: "string"
          }
        }
      ]
    }
  };
  InstructionValidationError = class extends Error {
    instruction;
    expectedAccounts;
    providedAccounts;
    accountDetails;
    constructor(instruction, expectedAccounts, providedAccounts, message, accountDetails) {
      super(message);
      this.name = "InstructionValidationError";
      this.instruction = instruction;
      this.expectedAccounts = expectedAccounts;
      this.providedAccounts = providedAccounts;
      this.accountDetails = accountDetails;
    }
  };
  INSTRUCTION_MAPPINGS = instructionAccountMappings;
  GhostSpeakSDKError = class extends Error {
    originalError;
    operation;
    instructionName;
    constructor(operation, originalError, instructionName) {
      const enhancedError = enhanceErrorMessage(originalError, instructionName ?? "unknown");
      super(enhancedError);
      this.name = "GhostSpeakSDKError";
      this.operation = operation;
      this.originalError = originalError;
      this.instructionName = instructionName;
    }
  };
  ipfs_client_exports = {};
  __export2(ipfs_client_exports, {
    IPFSClient: () => IPFSClient
  });
  sharedTestStorage = /* @__PURE__ */ new Map;
  SYSTEM_PROGRAM_ADDRESS3 = address("11111111111111111111111111111111");
  address("11111111111111111111111111111111");
  address("SysvarRecentB1ockHashes11111111111111111111");
  address("SysvarStakeHistory1111111111111111111111111");
  address("Sysvar1nstructions1111111111111111111111111");
  TOKEN_PROGRAM_ADDRESS = address("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");
  TOKEN_2022_PROGRAM_ADDRESS = address("TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb");
  ASSOCIATED_TOKEN_PROGRAM_ADDRESS = address("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL");
  address("So11111111111111111111111111111111111111112");
  NATIVE_MINT_ADDRESS = address("9pan9bMn5HatX4EJdBwg9VgCa7Uz5HL8N1m5D3NdXejP");
  address("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s");
  ReputationTier2 = /* @__PURE__ */ ((ReputationTier3) => {
    ReputationTier3["None"] = "None";
    ReputationTier3["Bronze"] = "Bronze";
    ReputationTier3["Silver"] = "Silver";
    ReputationTier3["Gold"] = "Gold";
    ReputationTier3["Platinum"] = "Platinum";
    return ReputationTier3;
  })(ReputationTier2 || {});
  BadgeType = /* @__PURE__ */ ((BadgeType2) => {
    BadgeType2["FirstJob"] = "FirstJob";
    BadgeType2["TenJobs"] = "TenJobs";
    BadgeType2["HundredJobs"] = "HundredJobs";
    BadgeType2["ThousandJobs"] = "ThousandJobs";
    BadgeType2["PerfectRating"] = "PerfectRating";
    BadgeType2["QuickResponder"] = "QuickResponder";
    BadgeType2["HighEarner"] = "HighEarner";
    BadgeType2["DisputeResolver"] = "DisputeResolver";
    BadgeType2["CategoryExpert"] = "CategoryExpert";
    BadgeType2["CrossCategoryMaster"] = "CrossCategoryMaster";
    return BadgeType2;
  })(BadgeType || {});
  REPUTATION_CONSTANTS = {
    MAX_REPUTATION_SCORE: 1e4,
    MIN_REPUTATION_FOR_SLASH: 1000,
    REPUTATION_DECAY_RATE_BPS: 10,
    BRONZE_TIER_THRESHOLD: 2000,
    SILVER_TIER_THRESHOLD: 5000,
    GOLD_TIER_THRESHOLD: 7500,
    PLATINUM_TIER_THRESHOLD: 9000,
    MAX_REPUTATION_CATEGORIES: 10,
    MAX_PERFORMANCE_HISTORY: 365,
    MAX_BADGES: 20
  };
});

// ../sdk-typescript/dist/chunk-5QZVFUXB.js
function getAccessAuditConfigEncoder() {
  return getStructEncoder([
    ["auditEnabled", getBooleanEncoder()],
    ["realTimeMonitoring", getBooleanEncoder()],
    ["retentionPeriod", getI64Encoder()]
  ]);
}
function getAccessAuditConfigDecoder() {
  return getStructDecoder([
    ["auditEnabled", getBooleanDecoder()],
    ["realTimeMonitoring", getBooleanDecoder()],
    ["retentionPeriod", getI64Decoder()]
  ]);
}
function getAccessAuditConfigCodec() {
  return combineCodec2(getAccessAuditConfigEncoder(), getAccessAuditConfigDecoder());
}
function getAccessPolicyEncoder() {
  return getStructEncoder([
    ["policyId", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["name", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["description", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["policyType", getPolicyTypeEncoder()],
    ["rules", getArrayEncoder(getPolicyRuleEncoder())],
    ["scope", getPolicyScopeEncoder()],
    ["priority", getU8Encoder()],
    ["status", getPolicyStatusEncoder()],
    ["effectiveDate", getI64Encoder()],
    ["expirationDate", getOptionEncoder(getI64Encoder())],
    ["metadata", getPolicyMetadataEncoder()]
  ]);
}
function getAccessPolicyDecoder() {
  return getStructDecoder([
    ["policyId", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["name", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["description", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["policyType", getPolicyTypeDecoder()],
    ["rules", getArrayDecoder(getPolicyRuleDecoder())],
    ["scope", getPolicyScopeDecoder()],
    ["priority", getU8Decoder()],
    ["status", getPolicyStatusDecoder()],
    ["effectiveDate", getI64Decoder()],
    ["expirationDate", getOptionDecoder(getI64Decoder())],
    ["metadata", getPolicyMetadataDecoder()]
  ]);
}
function getAccessPolicyCodec() {
  return combineCodec2(getAccessPolicyEncoder(), getAccessPolicyDecoder());
}
function getAccessTierEncoder() {
  return getEnumEncoder(AccessTier);
}
function getAccessTierDecoder() {
  return getEnumDecoder(AccessTier);
}
function getAccessTierCodec() {
  return combineCodec2(getAccessTierEncoder(), getAccessTierDecoder());
}
function getActionEncoder() {
  return getStructEncoder([
    ["name", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())]
  ]);
}
function getActionDecoder() {
  return getStructDecoder([
    ["name", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())]
  ]);
}
function getActionCodec() {
  return combineCodec2(getActionEncoder(), getActionDecoder());
}
function getAccountLockoutPoliciesEncoder() {
  return getStructEncoder([
    ["maxFailedAttempts", getU8Encoder()],
    ["lockoutDuration", getI64Encoder()],
    ["progressiveLockout", getBooleanEncoder()],
    ["unlockMethods", getArrayEncoder(getUnlockMethodEncoder())],
    [
      "notificationRequirements",
      getArrayEncoder(getNotificationRequirementEncoder())
    ]
  ]);
}
function getAccountLockoutPoliciesDecoder() {
  return getStructDecoder([
    ["maxFailedAttempts", getU8Decoder()],
    ["lockoutDuration", getI64Decoder()],
    ["progressiveLockout", getBooleanDecoder()],
    ["unlockMethods", getArrayDecoder(getUnlockMethodDecoder())],
    [
      "notificationRequirements",
      getArrayDecoder(getNotificationRequirementDecoder())
    ]
  ]);
}
function getAccountLockoutPoliciesCodec() {
  return combineCodec2(getAccountLockoutPoliciesEncoder(), getAccountLockoutPoliciesDecoder());
}
function getActivationRequirementEncoder() {
  return getStructEncoder([
    ["requirementType", getActivationRequirementTypeEncoder()],
    ["approvers", getArrayEncoder(getAddressEncoder2())],
    ["minApprovals", getU8Encoder()],
    ["approvalTimeout", getI64Encoder()],
    [
      "evidenceRequirements",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ]
  ]);
}
function getActivationRequirementDecoder() {
  return getStructDecoder([
    ["requirementType", getActivationRequirementTypeDecoder()],
    ["approvers", getArrayDecoder(getAddressDecoder2())],
    ["minApprovals", getU8Decoder()],
    ["approvalTimeout", getI64Decoder()],
    [
      "evidenceRequirements",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ]
  ]);
}
function getActivationRequirementCodec() {
  return combineCodec2(getActivationRequirementEncoder(), getActivationRequirementDecoder());
}
function getActivationRequirementTypeEncoder() {
  return getEnumEncoder(ActivationRequirementType);
}
function getActivationRequirementTypeDecoder() {
  return getEnumDecoder(ActivationRequirementType);
}
function getActivationRequirementTypeCodec() {
  return combineCodec2(getActivationRequirementTypeEncoder(), getActivationRequirementTypeDecoder());
}
function getAgentRegisteredEventEncoder() {
  return getStructEncoder([
    ["agent", getAddressEncoder2()],
    ["owner", getAddressEncoder2()],
    ["name", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["timestamp", getI64Encoder()]
  ]);
}
function getAgentRegisteredEventDecoder() {
  return getStructDecoder([
    ["agent", getAddressDecoder2()],
    ["owner", getAddressDecoder2()],
    ["name", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["timestamp", getI64Decoder()]
  ]);
}
function getAgentRegisteredEventCodec() {
  return combineCodec2(getAgentRegisteredEventEncoder(), getAgentRegisteredEventDecoder());
}
function getAgentServiceUpdatedEventEncoder() {
  return getStructEncoder([
    ["agent", getAddressEncoder2()],
    ["owner", getAddressEncoder2()],
    ["timestamp", getI64Encoder()],
    [
      "serviceEndpoint",
      addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())
    ],
    ["isActive", getBooleanEncoder()]
  ]);
}
function getAgentServiceUpdatedEventDecoder() {
  return getStructDecoder([
    ["agent", getAddressDecoder2()],
    ["owner", getAddressDecoder2()],
    ["timestamp", getI64Decoder()],
    [
      "serviceEndpoint",
      addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())
    ],
    ["isActive", getBooleanDecoder()]
  ]);
}
function getAgentServiceUpdatedEventCodec() {
  return combineCodec2(getAgentServiceUpdatedEventEncoder(), getAgentServiceUpdatedEventDecoder());
}
function getAgentStatusEncoder() {
  return getEnumEncoder(AgentStatus);
}
function getAgentStatusDecoder() {
  return getEnumDecoder(AgentStatus);
}
function getAgentStatusCodec() {
  return combineCodec2(getAgentStatusEncoder(), getAgentStatusDecoder());
}
function getAgentStatusChangedEventEncoder() {
  return getStructEncoder([
    ["agent", getAddressEncoder2()],
    ["previousStatus", getBooleanEncoder()],
    ["newStatus", getBooleanEncoder()],
    ["timestamp", getI64Encoder()],
    ["authority", getAddressEncoder2()]
  ]);
}
function getAgentStatusChangedEventDecoder() {
  return getStructDecoder([
    ["agent", getAddressDecoder2()],
    ["previousStatus", getBooleanDecoder()],
    ["newStatus", getBooleanDecoder()],
    ["timestamp", getI64Decoder()],
    ["authority", getAddressDecoder2()]
  ]);
}
function getAgentStatusChangedEventCodec() {
  return combineCodec2(getAgentStatusChangedEventEncoder(), getAgentStatusChangedEventDecoder());
}
function getAgentUpdatedEventEncoder() {
  return getStructEncoder([
    ["agent", getAddressEncoder2()],
    ["owner", getAddressEncoder2()],
    ["timestamp", getI64Encoder()]
  ]);
}
function getAgentUpdatedEventDecoder() {
  return getStructDecoder([
    ["agent", getAddressDecoder2()],
    ["owner", getAddressDecoder2()],
    ["timestamp", getI64Decoder()]
  ]);
}
function getAgentUpdatedEventCodec() {
  return combineCodec2(getAgentUpdatedEventEncoder(), getAgentUpdatedEventDecoder());
}
function getAgentVerificationDataEncoder() {
  return getStructEncoder([
    ["agentPubkey", getAddressEncoder2()],
    [
      "serviceEndpoint",
      addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())
    ],
    ["supportedCapabilities", getArrayEncoder(getU64Encoder())],
    ["verifiedAt", getI64Encoder()]
  ]);
}
function getAgentVerificationDataDecoder() {
  return getStructDecoder([
    ["agentPubkey", getAddressDecoder2()],
    [
      "serviceEndpoint",
      addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())
    ],
    ["supportedCapabilities", getArrayDecoder(getU64Decoder())],
    ["verifiedAt", getI64Decoder()]
  ]);
}
function getAgentVerificationDataCodec() {
  return combineCodec2(getAgentVerificationDataEncoder(), getAgentVerificationDataDecoder());
}
function getAgingPolicyEncoder() {
  return getStructEncoder([
    ["biometricType", getBiometricTypeEncoder()],
    ["maxAge", getI64Encoder()],
    [
      "refreshRequirements",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    ["degradationHandling", getDegradationHandlingEncoder()]
  ]);
}
function getAgingPolicyDecoder() {
  return getStructDecoder([
    ["biometricType", getBiometricTypeDecoder()],
    ["maxAge", getI64Decoder()],
    [
      "refreshRequirements",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    ["degradationHandling", getDegradationHandlingDecoder()]
  ]);
}
function getAgingPolicyCodec() {
  return combineCodec2(getAgingPolicyEncoder(), getAgingPolicyDecoder());
}
function getApprovalLevelEncoder() {
  return getStructEncoder([
    ["actionType", getAuditActionEncoder()],
    ["requiredApprovers", getArrayEncoder(getAddressEncoder2())],
    ["minApprovals", getU8Encoder()],
    ["approvalTimeout", getI64Encoder()]
  ]);
}
function getApprovalLevelDecoder() {
  return getStructDecoder([
    ["actionType", getAuditActionDecoder()],
    ["requiredApprovers", getArrayDecoder(getAddressDecoder2())],
    ["minApprovals", getU8Decoder()],
    ["approvalTimeout", getI64Decoder()]
  ]);
}
function getApprovalLevelCodec() {
  return combineCodec2(getApprovalLevelEncoder(), getApprovalLevelDecoder());
}
function getArbitratorDecisionEncoder() {
  return getDiscriminatedUnionEncoder([
    [
      "FavorClient",
      getStructEncoder([
        ["reason", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())]
      ])
    ],
    [
      "FavorAgent",
      getStructEncoder([
        ["reason", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())]
      ])
    ],
    [
      "Split",
      getStructEncoder([
        ["clientPercentage", getU8Encoder()],
        ["reason", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())]
      ])
    ]
  ]);
}
function getArbitratorDecisionDecoder() {
  return getDiscriminatedUnionDecoder([
    [
      "FavorClient",
      getStructDecoder([
        ["reason", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())]
      ])
    ],
    [
      "FavorAgent",
      getStructDecoder([
        ["reason", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())]
      ])
    ],
    [
      "Split",
      getStructDecoder([
        ["clientPercentage", getU8Decoder()],
        ["reason", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())]
      ])
    ]
  ]);
}
function getArbitratorDecisionCodec() {
  return combineCodec2(getArbitratorDecisionEncoder(), getArbitratorDecisionDecoder());
}
function arbitratorDecision(kind, data) {
  return Array.isArray(data) ? { __kind: kind, fields: data } : { __kind: kind, ...data ?? {} };
}
function isArbitratorDecision(kind, value) {
  return value.__kind === kind;
}
function getAuditActionEncoder() {
  return getEnumEncoder(AuditAction);
}
function getAuditActionDecoder() {
  return getEnumDecoder(AuditAction);
}
function getAuditActionCodec() {
  return combineCodec2(getAuditActionEncoder(), getAuditActionDecoder());
}
function getAuditConfigEncoder() {
  return getStructEncoder([
    ["maxEntries", getU32Encoder()],
    ["retentionPeriod", getI64Encoder()],
    ["autoArchive", getBooleanEncoder()],
    ["reportingFrequency", getReportingFrequencyEncoder()],
    ["approvalLevels", getArrayEncoder(getApprovalLevelEncoder())],
    ["encryptionRequired", getBooleanEncoder()],
    ["backupFrequency", getBackupFrequencyEncoder()]
  ]);
}
function getAuditConfigDecoder() {
  return getStructDecoder([
    ["maxEntries", getU32Decoder()],
    ["retentionPeriod", getI64Decoder()],
    ["autoArchive", getBooleanDecoder()],
    ["reportingFrequency", getReportingFrequencyDecoder()],
    ["approvalLevels", getArrayDecoder(getApprovalLevelDecoder())],
    ["encryptionRequired", getBooleanDecoder()],
    ["backupFrequency", getBackupFrequencyDecoder()]
  ]);
}
function getAuditConfigCodec() {
  return combineCodec2(getAuditConfigEncoder(), getAuditConfigDecoder());
}
function getAuditContextEncoder() {
  return getStructEncoder([
    ["metadata", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())]
  ]);
}
function getAuditContextDecoder() {
  return getStructDecoder([
    ["metadata", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())]
  ]);
}
function getAuditContextCodec() {
  return combineCodec2(getAuditContextEncoder(), getAuditContextDecoder());
}
function getAuditEntryEncoder() {
  return getStructEncoder([
    ["entryId", getU64Encoder()],
    ["timestamp", getI64Encoder()],
    ["action", getAuditActionEncoder()],
    ["actor", getAddressEncoder2()],
    ["target", getOptionEncoder(getAddressEncoder2())],
    ["context", getAuditContextEncoder()],
    ["complianceFlags", getComplianceFlagsEncoder()],
    ["previousHash", fixEncoderSize2(getBytesEncoder(), 32)],
    ["entryHash", fixEncoderSize2(getBytesEncoder(), 32)],
    ["signature", getOptionEncoder(fixEncoderSize2(getBytesEncoder(), 64))]
  ]);
}
function getAuditEntryDecoder() {
  return getStructDecoder([
    ["entryId", getU64Decoder()],
    ["timestamp", getI64Decoder()],
    ["action", getAuditActionDecoder()],
    ["actor", getAddressDecoder2()],
    ["target", getOptionDecoder(getAddressDecoder2())],
    ["context", getAuditContextDecoder()],
    ["complianceFlags", getComplianceFlagsDecoder()],
    ["previousHash", fixDecoderSize2(getBytesDecoder(), 32)],
    ["entryHash", fixDecoderSize2(getBytesDecoder(), 32)],
    ["signature", getOptionDecoder(fixDecoderSize2(getBytesDecoder(), 64))]
  ]);
}
function getAuditEntryCodec() {
  return combineCodec2(getAuditEntryEncoder(), getAuditEntryDecoder());
}
function getAuditTrailInitializedEventEncoder() {
  return getStructEncoder([
    ["entity", getAddressEncoder2()],
    ["entityType", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["timestamp", getI64Encoder()]
  ]);
}
function getAuditTrailInitializedEventDecoder() {
  return getStructDecoder([
    ["entity", getAddressDecoder2()],
    ["entityType", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["timestamp", getI64Decoder()]
  ]);
}
function getAuditTrailInitializedEventCodec() {
  return combineCodec2(getAuditTrailInitializedEventEncoder(), getAuditTrailInitializedEventDecoder());
}
function getAuthenticationLevelEncoder() {
  return getEnumEncoder(AuthenticationLevel);
}
function getAuthenticationLevelDecoder() {
  return getEnumDecoder(AuthenticationLevel);
}
function getAuthenticationLevelCodec() {
  return combineCodec2(getAuthenticationLevelEncoder(), getAuthenticationLevelDecoder());
}
function getAuthenticationMethodEncoder() {
  return getEnumEncoder(AuthenticationMethod);
}
function getAuthenticationMethodDecoder() {
  return getEnumDecoder(AuthenticationMethod);
}
function getAuthenticationMethodCodec() {
  return combineCodec2(getAuthenticationMethodEncoder(), getAuthenticationMethodDecoder());
}
function getAuthenticationPoliciesEncoder() {
  return getStructEncoder([
    ["mfaRequired", getBooleanEncoder()],
    ["supportedMethods", getArrayEncoder(getAuthenticationMethodEncoder())],
    ["strengthRequirements", getAuthenticationStrengthEncoder()],
    ["lockoutPolicies", getAccountLockoutPoliciesEncoder()],
    ["biometricPolicies", getOptionEncoder(getBiometricPoliciesEncoder())]
  ]);
}
function getAuthenticationPoliciesDecoder() {
  return getStructDecoder([
    ["mfaRequired", getBooleanDecoder()],
    ["supportedMethods", getArrayDecoder(getAuthenticationMethodDecoder())],
    ["strengthRequirements", getAuthenticationStrengthDecoder()],
    ["lockoutPolicies", getAccountLockoutPoliciesDecoder()],
    ["biometricPolicies", getOptionDecoder(getBiometricPoliciesDecoder())]
  ]);
}
function getAuthenticationPoliciesCodec() {
  return combineCodec2(getAuthenticationPoliciesEncoder(), getAuthenticationPoliciesDecoder());
}
function getAuthenticationStrengthEncoder() {
  return getStructEncoder([
    ["minimumLevel", getAuthenticationLevelEncoder()],
    ["riskBased", getBooleanEncoder()],
    ["adaptive", getBooleanEncoder()],
    ["stepUpTriggers", getArrayEncoder(getStepUpTriggerEncoder())]
  ]);
}
function getAuthenticationStrengthDecoder() {
  return getStructDecoder([
    ["minimumLevel", getAuthenticationLevelDecoder()],
    ["riskBased", getBooleanDecoder()],
    ["adaptive", getBooleanDecoder()],
    ["stepUpTriggers", getArrayDecoder(getStepUpTriggerDecoder())]
  ]);
}
function getAuthenticationStrengthCodec() {
  return combineCodec2(getAuthenticationStrengthEncoder(), getAuthenticationStrengthDecoder());
}
function getAuthorizationPoliciesEncoder() {
  return getStructEncoder([
    ["defaultDeny", getBooleanEncoder()],
    ["explicitPermissionsRequired", getBooleanEncoder()]
  ]);
}
function getAuthorizationPoliciesDecoder() {
  return getStructDecoder([
    ["defaultDeny", getBooleanDecoder()],
    ["explicitPermissionsRequired", getBooleanDecoder()]
  ]);
}
function getAuthorizationPoliciesCodec() {
  return combineCodec2(getAuthorizationPoliciesEncoder(), getAuthorizationPoliciesDecoder());
}
function getBackupFrequencyEncoder() {
  return getEnumEncoder(BackupFrequency);
}
function getBackupFrequencyDecoder() {
  return getEnumDecoder(BackupFrequency);
}
function getBackupFrequencyCodec() {
  return combineCodec2(getBackupFrequencyEncoder(), getBackupFrequencyDecoder());
}
function getBiometricPoliciesEncoder() {
  return getStructEncoder([
    ["supportedTypes", getArrayEncoder(getBiometricTypeEncoder())],
    ["qualityRequirements", getBiometricQualityEncoder()],
    ["livenessDetection", getBooleanEncoder()],
    ["templateProtection", getBiometricProtectionEncoder()]
  ]);
}
function getBiometricPoliciesDecoder() {
  return getStructDecoder([
    ["supportedTypes", getArrayDecoder(getBiometricTypeDecoder())],
    ["qualityRequirements", getBiometricQualityDecoder()],
    ["livenessDetection", getBooleanDecoder()],
    ["templateProtection", getBiometricProtectionDecoder()]
  ]);
}
function getBiometricPoliciesCodec() {
  return combineCodec2(getBiometricPoliciesEncoder(), getBiometricPoliciesDecoder());
}
function getBiometricProtectionEncoder() {
  return getStructEncoder([
    ["encryptionRequired", getBooleanEncoder()],
    ["storageMethod", getBiometricStorageMethodEncoder()],
    ["revocationSupport", getBooleanEncoder()],
    ["agingPolicies", getArrayEncoder(getAgingPolicyEncoder())]
  ]);
}
function getBiometricProtectionDecoder() {
  return getStructDecoder([
    ["encryptionRequired", getBooleanDecoder()],
    ["storageMethod", getBiometricStorageMethodDecoder()],
    ["revocationSupport", getBooleanDecoder()],
    ["agingPolicies", getArrayDecoder(getAgingPolicyDecoder())]
  ]);
}
function getBiometricProtectionCodec() {
  return combineCodec2(getBiometricProtectionEncoder(), getBiometricProtectionDecoder());
}
function getBiometricQualityEncoder() {
  return getStructEncoder([
    ["score", getU8Encoder()]
  ]);
}
function getBiometricQualityDecoder() {
  return getStructDecoder([
    ["score", getU8Decoder()]
  ]);
}
function getBiometricQualityCodec() {
  return combineCodec2(getBiometricQualityEncoder(), getBiometricQualityDecoder());
}
function getBiometricStorageMethodEncoder() {
  return getEnumEncoder(BiometricStorageMethod);
}
function getBiometricStorageMethodDecoder() {
  return getEnumDecoder(BiometricStorageMethod);
}
function getBiometricStorageMethodCodec() {
  return combineCodec2(getBiometricStorageMethodEncoder(), getBiometricStorageMethodDecoder());
}
function getBiometricTypeEncoder() {
  return getEnumEncoder(BiometricType);
}
function getBiometricTypeDecoder() {
  return getEnumDecoder(BiometricType);
}
function getBiometricTypeCodec() {
  return combineCodec2(getBiometricTypeEncoder(), getBiometricTypeDecoder());
}
function getComplianceFlagsEncoder() {
  return getStructEncoder([
    ["requiresReporting", getBooleanEncoder()],
    ["highRisk", getBooleanEncoder()],
    ["sensitiveData", getBooleanEncoder()],
    ["crossBorder", getBooleanEncoder()],
    ["largeAmount", getBooleanEncoder()],
    ["suspicious", getBooleanEncoder()],
    ["manualReview", getBooleanEncoder()],
    [
      "jurisdiction",
      getOptionEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ]
  ]);
}
function getComplianceFlagsDecoder() {
  return getStructDecoder([
    ["requiresReporting", getBooleanDecoder()],
    ["highRisk", getBooleanDecoder()],
    ["sensitiveData", getBooleanDecoder()],
    ["crossBorder", getBooleanDecoder()],
    ["largeAmount", getBooleanDecoder()],
    ["suspicious", getBooleanDecoder()],
    ["manualReview", getBooleanDecoder()],
    [
      "jurisdiction",
      getOptionDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ]
  ]);
}
function getComplianceFlagsCodec() {
  return combineCodec2(getComplianceFlagsEncoder(), getComplianceFlagsDecoder());
}
function getComplianceMetricsEncoder() {
  return getStructEncoder([
    ["complianceScore", getU8Encoder()],
    ["policyAdherenceRate", getU8Encoder()],
    ["avgIncidentResponseTime", getU64Encoder()],
    ["falsePositiveRate", getU8Encoder()],
    ["coveragePercentage", getU8Encoder()],
    ["auditReadinessScore", getU8Encoder()]
  ]);
}
function getComplianceMetricsDecoder() {
  return getStructDecoder([
    ["complianceScore", getU8Decoder()],
    ["policyAdherenceRate", getU8Decoder()],
    ["avgIncidentResponseTime", getU64Decoder()],
    ["falsePositiveRate", getU8Decoder()],
    ["coveragePercentage", getU8Decoder()],
    ["auditReadinessScore", getU8Decoder()]
  ]);
}
function getComplianceMetricsCodec() {
  return combineCodec2(getComplianceMetricsEncoder(), getComplianceMetricsDecoder());
}
function getCompliancePoliciesEncoder() {
  return getStructEncoder([
    [
      "frameworks",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    [
      "auditRequirements",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    [
      "reportingRequirements",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ]
  ]);
}
function getCompliancePoliciesDecoder() {
  return getStructDecoder([
    [
      "frameworks",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    [
      "auditRequirements",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    [
      "reportingRequirements",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ]
  ]);
}
function getCompliancePoliciesCodec() {
  return combineCodec2(getCompliancePoliciesEncoder(), getCompliancePoliciesDecoder());
}
function getComplianceReportGeneratedEventEncoder() {
  return getStructEncoder([
    ["report", getAddressEncoder2()],
    ["reportId", getU64Encoder()],
    ["reportType", getReportTypeEncoder()],
    ["complianceRate", getU64Encoder()]
  ]);
}
function getComplianceReportGeneratedEventDecoder() {
  return getStructDecoder([
    ["report", getAddressDecoder2()],
    ["reportId", getU64Decoder()],
    ["reportType", getReportTypeDecoder()],
    ["complianceRate", getU64Decoder()]
  ]);
}
function getComplianceReportGeneratedEventCodec() {
  return combineCodec2(getComplianceReportGeneratedEventEncoder(), getComplianceReportGeneratedEventDecoder());
}
function getComplianceStatusEncoder() {
  return getStructEncoder([
    ["status", getU8Encoder()]
  ]);
}
function getComplianceStatusDecoder() {
  return getStructDecoder([
    ["status", getU8Decoder()]
  ]);
}
function getComplianceStatusCodec() {
  return combineCodec2(getComplianceStatusEncoder(), getComplianceStatusDecoder());
}
function getCompressedAgentCreatedEventEncoder() {
  return getStructEncoder([
    ["agentId", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["owner", getAddressEncoder2()],
    ["treeAuthority", getAddressEncoder2()],
    ["merkleTree", getAddressEncoder2()],
    ["dataHash", fixEncoderSize2(getBytesEncoder(), 32)],
    ["index", getU64Encoder()],
    ["metadataUri", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["createdAt", getI64Encoder()]
  ]);
}
function getCompressedAgentCreatedEventDecoder() {
  return getStructDecoder([
    ["agentId", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["owner", getAddressDecoder2()],
    ["treeAuthority", getAddressDecoder2()],
    ["merkleTree", getAddressDecoder2()],
    ["dataHash", fixDecoderSize2(getBytesDecoder(), 32)],
    ["index", getU64Decoder()],
    ["metadataUri", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["createdAt", getI64Decoder()]
  ]);
}
function getCompressedAgentCreatedEventCodec() {
  return combineCodec2(getCompressedAgentCreatedEventEncoder(), getCompressedAgentCreatedEventDecoder());
}
function getConditionTypeEncoder() {
  return getEnumEncoder(ConditionType);
}
function getConditionTypeDecoder() {
  return getEnumDecoder(ConditionType);
}
function getConditionTypeCodec() {
  return combineCodec2(getConditionTypeEncoder(), getConditionTypeDecoder());
}
function getConstraintConditionEncoder() {
  return getStructEncoder([
    ["attribute", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["operator", getConstraintOperatorEncoder()],
    ["value", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["valueType", getValueTypeEncoder()]
  ]);
}
function getConstraintConditionDecoder() {
  return getStructDecoder([
    ["attribute", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["operator", getConstraintOperatorDecoder()],
    ["value", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["valueType", getValueTypeDecoder()]
  ]);
}
function getConstraintConditionCodec() {
  return combineCodec2(getConstraintConditionEncoder(), getConstraintConditionDecoder());
}
function getConstraintOperatorEncoder() {
  return getEnumEncoder(ConstraintOperator);
}
function getConstraintOperatorDecoder() {
  return getEnumDecoder(ConstraintOperator);
}
function getConstraintOperatorCodec() {
  return combineCodec2(getConstraintOperatorEncoder(), getConstraintOperatorDecoder());
}
function getCredentialKindEncoder() {
  return getEnumEncoder(CredentialKind);
}
function getCredentialKindDecoder() {
  return getEnumDecoder(CredentialKind);
}
function getCredentialKindCodec() {
  return combineCodec2(getCredentialKindEncoder(), getCredentialKindDecoder());
}
function getCredentialStatusEncoder() {
  return getEnumEncoder(CredentialStatus);
}
function getCredentialStatusDecoder() {
  return getEnumDecoder(CredentialStatus);
}
function getCredentialStatusCodec() {
  return combineCodec2(getCredentialStatusEncoder(), getCredentialStatusDecoder());
}
function getCrossChainStatusEncoder() {
  return getEnumEncoder(CrossChainStatus);
}
function getCrossChainStatusDecoder() {
  return getEnumDecoder(CrossChainStatus);
}
function getCrossChainStatusCodec() {
  return combineCodec2(getCrossChainStatusEncoder(), getCrossChainStatusDecoder());
}
function getDataAccessLevelEncoder() {
  return getEnumEncoder(DataAccessLevel);
}
function getDataAccessLevelDecoder() {
  return getEnumDecoder(DataAccessLevel);
}
function getDataAccessLevelCodec() {
  return combineCodec2(getDataAccessLevelEncoder(), getDataAccessLevelDecoder());
}
function getDataProtectionPoliciesEncoder() {
  return getStructEncoder([
    ["encryptionRequired", getBooleanEncoder()],
    ["classificationRequired", getBooleanEncoder()],
    ["dlpEnabled", getBooleanEncoder()]
  ]);
}
function getDataProtectionPoliciesDecoder() {
  return getStructDecoder([
    ["encryptionRequired", getBooleanDecoder()],
    ["classificationRequired", getBooleanDecoder()],
    ["dlpEnabled", getBooleanDecoder()]
  ]);
}
function getDataProtectionPoliciesCodec() {
  return combineCodec2(getDataProtectionPoliciesEncoder(), getDataProtectionPoliciesDecoder());
}
function getDegradationHandlingEncoder() {
  return getEnumEncoder(DegradationHandling);
}
function getDegradationHandlingDecoder() {
  return getEnumDecoder(DegradationHandling);
}
function getDegradationHandlingCodec() {
  return combineCodec2(getDegradationHandlingEncoder(), getDegradationHandlingDecoder());
}
function getDelegationInfoEncoder() {
  return getStructEncoder([
    ["delegator", getAddressEncoder2()],
    ["delegatedAt", getI64Encoder()],
    ["scope", getDelegationScopeEncoder()],
    ["expiresAt", getOptionEncoder(getI64Encoder())]
  ]);
}
function getDelegationInfoDecoder() {
  return getStructDecoder([
    ["delegator", getAddressDecoder2()],
    ["delegatedAt", getI64Decoder()],
    ["scope", getDelegationScopeDecoder()],
    ["expiresAt", getOptionDecoder(getI64Decoder())]
  ]);
}
function getDelegationInfoCodec() {
  return combineCodec2(getDelegationInfoEncoder(), getDelegationInfoDecoder());
}
function getDelegationScopeEncoder() {
  return getDiscriminatedUnionEncoder([
    ["All", getUnitEncoder()],
    [
      "ProposalType",
      getStructEncoder([
        ["fields", getTupleEncoder([getProposalTypeEncoder()])]
      ])
    ],
    ["SingleProposal", getUnitEncoder()],
    ["Limited", getUnitEncoder()]
  ]);
}
function getDelegationScopeDecoder() {
  return getDiscriminatedUnionDecoder([
    ["All", getUnitDecoder()],
    [
      "ProposalType",
      getStructDecoder([
        ["fields", getTupleDecoder([getProposalTypeDecoder()])]
      ])
    ],
    ["SingleProposal", getUnitDecoder()],
    ["Limited", getUnitDecoder()]
  ]);
}
function getDelegationScopeCodec() {
  return combineCodec2(getDelegationScopeEncoder(), getDelegationScopeDecoder());
}
function delegationScope(kind, data) {
  return Array.isArray(data) ? { __kind: kind, fields: data } : { __kind: kind, ...data ?? {} };
}
function isDelegationScope(kind, value) {
  return value.__kind === kind;
}
function getDeliverySubmittedEventEncoder() {
  return getStructEncoder([
    ["escrowId", getU64Encoder()],
    ["agent", getAddressEncoder2()],
    ["deliveryProof", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())]
  ]);
}
function getDeliverySubmittedEventDecoder() {
  return getStructDecoder([
    ["escrowId", getU64Decoder()],
    ["agent", getAddressDecoder2()],
    ["deliveryProof", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())]
  ]);
}
function getDeliverySubmittedEventCodec() {
  return combineCodec2(getDeliverySubmittedEventEncoder(), getDeliverySubmittedEventDecoder());
}
function getDisputeFiledEventEncoder() {
  return getStructEncoder([
    ["escrowId", getU64Encoder()],
    ["client", getAddressEncoder2()],
    ["reason", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())]
  ]);
}
function getDisputeFiledEventDecoder() {
  return getStructDecoder([
    ["escrowId", getU64Decoder()],
    ["client", getAddressDecoder2()],
    ["reason", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())]
  ]);
}
function getDisputeFiledEventCodec() {
  return combineCodec2(getDisputeFiledEventEncoder(), getDisputeFiledEventDecoder());
}
function getDisputeResolvedEventEncoder() {
  return getStructEncoder([
    ["escrowId", getU64Encoder()],
    ["decision", getArbitratorDecisionEncoder()],
    ["arbitrator", getAddressEncoder2()]
  ]);
}
function getDisputeResolvedEventDecoder() {
  return getStructDecoder([
    ["escrowId", getU64Decoder()],
    ["decision", getArbitratorDecisionDecoder()],
    ["arbitrator", getAddressDecoder2()]
  ]);
}
function getDisputeResolvedEventCodec() {
  return combineCodec2(getDisputeResolvedEventEncoder(), getDisputeResolvedEventDecoder());
}
function getEmergencyAccessConfigEncoder() {
  return getStructEncoder([
    ["breakGlassEnabled", getBooleanEncoder()],
    ["emergencyContacts", getArrayEncoder(getAddressEncoder2())],
    ["approvalRequired", getBooleanEncoder()]
  ]);
}
function getEmergencyAccessConfigDecoder() {
  return getStructDecoder([
    ["breakGlassEnabled", getBooleanDecoder()],
    ["emergencyContacts", getArrayDecoder(getAddressDecoder2())],
    ["approvalRequired", getBooleanDecoder()]
  ]);
}
function getEmergencyAccessConfigCodec() {
  return combineCodec2(getEmergencyAccessConfigEncoder(), getEmergencyAccessConfigDecoder());
}
function getEmergencyConfigEncoder() {
  return getStructEncoder([
    ["emergencyContacts", getArrayEncoder(getAddressEncoder2())],
    ["emergencyThreshold", getU8Encoder()],
    ["emergencyTimeout", getI64Encoder()],
    ["emergencyTransactionTypes", getArrayEncoder(getTransactionTypeEncoder())],
    ["freezeEnabled", getBooleanEncoder()],
    ["frozen", getBooleanEncoder()],
    ["frozenAt", getOptionEncoder(getI64Encoder())],
    ["autoUnfreezeDuration", getOptionEncoder(getI64Encoder())]
  ]);
}
function getEmergencyConfigDecoder() {
  return getStructDecoder([
    ["emergencyContacts", getArrayDecoder(getAddressDecoder2())],
    ["emergencyThreshold", getU8Decoder()],
    ["emergencyTimeout", getI64Decoder()],
    ["emergencyTransactionTypes", getArrayDecoder(getTransactionTypeDecoder())],
    ["freezeEnabled", getBooleanDecoder()],
    ["frozen", getBooleanDecoder()],
    ["frozenAt", getOptionDecoder(getI64Decoder())],
    ["autoUnfreezeDuration", getOptionDecoder(getI64Decoder())]
  ]);
}
function getEmergencyConfigCodec() {
  return combineCodec2(getEmergencyConfigEncoder(), getEmergencyConfigDecoder());
}
function getEnforcementLevelEncoder() {
  return getEnumEncoder(EnforcementLevel);
}
function getEnforcementLevelDecoder() {
  return getEnumDecoder(EnforcementLevel);
}
function getEnforcementLevelCodec() {
  return combineCodec2(getEnforcementLevelEncoder(), getEnforcementLevelDecoder());
}
function getEscrowCompletedEventEncoder() {
  return getStructEncoder([
    ["escrowId", getU64Encoder()],
    ["agent", getAddressEncoder2()],
    ["amount", getU64Encoder()]
  ]);
}
function getEscrowCompletedEventDecoder() {
  return getStructDecoder([
    ["escrowId", getU64Decoder()],
    ["agent", getAddressDecoder2()],
    ["amount", getU64Decoder()]
  ]);
}
function getEscrowCompletedEventCodec() {
  return combineCodec2(getEscrowCompletedEventEncoder(), getEscrowCompletedEventDecoder());
}
function getEscrowCreatedEventEncoder() {
  return getStructEncoder([
    ["escrowId", getU64Encoder()],
    ["client", getAddressEncoder2()],
    ["agent", getAddressEncoder2()],
    ["amount", getU64Encoder()],
    ["deadline", getI64Encoder()]
  ]);
}
function getEscrowCreatedEventDecoder() {
  return getStructDecoder([
    ["escrowId", getU64Decoder()],
    ["client", getAddressDecoder2()],
    ["agent", getAddressDecoder2()],
    ["amount", getU64Decoder()],
    ["deadline", getI64Decoder()]
  ]);
}
function getEscrowCreatedEventCodec() {
  return combineCodec2(getEscrowCreatedEventEncoder(), getEscrowCreatedEventDecoder());
}
function getEscrowStatusEncoder() {
  return getEnumEncoder(EscrowStatus);
}
function getEscrowStatusDecoder() {
  return getEnumDecoder(EscrowStatus);
}
function getEscrowStatusCodec() {
  return combineCodec2(getEscrowStatusEncoder(), getEscrowStatusDecoder());
}
function getExecutionConditionEncoder() {
  return getStructEncoder([
    ["conditionType", getConditionTypeEncoder()],
    ["targetValue", getU64Encoder()],
    ["currentValue", getU64Encoder()],
    ["met", getBooleanEncoder()],
    ["description", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())]
  ]);
}
function getExecutionConditionDecoder() {
  return getStructDecoder([
    ["conditionType", getConditionTypeDecoder()],
    ["targetValue", getU64Decoder()],
    ["currentValue", getU64Decoder()],
    ["met", getBooleanDecoder()],
    ["description", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())]
  ]);
}
function getExecutionConditionCodec() {
  return combineCodec2(getExecutionConditionEncoder(), getExecutionConditionDecoder());
}
function getExecutionParamsEncoder() {
  return getStructEncoder([
    ["instructions", getArrayEncoder(getProposalInstructionEncoder())],
    ["executionDelay", getI64Encoder()],
    ["executionConditions", getArrayEncoder(getExecutionConditionEncoder())],
    ["cancellable", getBooleanEncoder()],
    ["autoExecute", getBooleanEncoder()],
    ["executionAuthority", getAddressEncoder2()]
  ]);
}
function getExecutionParamsDecoder() {
  return getStructDecoder([
    ["instructions", getArrayDecoder(getProposalInstructionDecoder())],
    ["executionDelay", getI64Decoder()],
    ["executionConditions", getArrayDecoder(getExecutionConditionDecoder())],
    ["cancellable", getBooleanDecoder()],
    ["autoExecute", getBooleanDecoder()],
    ["executionAuthority", getAddressDecoder2()]
  ]);
}
function getExecutionParamsCodec() {
  return combineCodec2(getExecutionParamsEncoder(), getExecutionParamsDecoder());
}
function getExternalIdentifierEncoder() {
  return getStructEncoder([
    ["platform", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["externalId", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["verified", getBooleanEncoder()],
    ["verifiedAt", getI64Encoder()]
  ]);
}
function getExternalIdentifierDecoder() {
  return getStructDecoder([
    ["platform", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["externalId", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["verified", getBooleanDecoder()],
    ["verifiedAt", getI64Decoder()]
  ]);
}
function getExternalIdentifierCodec() {
  return combineCodec2(getExternalIdentifierEncoder(), getExternalIdentifierDecoder());
}
function getGeographicRegionEncoder() {
  return getStructEncoder([
    ["name", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["latitudeRange", getLatitudeRangeEncoder()],
    ["longitudeRange", getLongitudeRangeEncoder()],
    ["radius", getOptionEncoder(getU32Encoder())]
  ]);
}
function getGeographicRegionDecoder() {
  return getStructDecoder([
    ["name", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["latitudeRange", getLatitudeRangeDecoder()],
    ["longitudeRange", getLongitudeRangeDecoder()],
    ["radius", getOptionDecoder(getU32Decoder())]
  ]);
}
function getGeographicRegionCodec() {
  return combineCodec2(getGeographicRegionEncoder(), getGeographicRegionDecoder());
}
function getGhostSlashedEventEncoder() {
  return getStructEncoder([
    ["agent", getAddressEncoder2()],
    ["amount", getU64Encoder()],
    ["reason", getSlashReasonEncoder()],
    ["newTier", getAccessTierEncoder()]
  ]);
}
function getGhostSlashedEventDecoder() {
  return getStructDecoder([
    ["agent", getAddressDecoder2()],
    ["amount", getU64Decoder()],
    ["reason", getSlashReasonDecoder()],
    ["newTier", getAccessTierDecoder()]
  ]);
}
function getGhostSlashedEventCodec() {
  return combineCodec2(getGhostSlashedEventEncoder(), getGhostSlashedEventDecoder());
}
function getGhostStakedEventEncoder() {
  return getStructEncoder([
    ["agent", getAddressEncoder2()],
    ["amount", getU64Encoder()],
    ["unlockAt", getI64Encoder()],
    ["reputationBoostBps", getU16Encoder()],
    ["tier", getAccessTierEncoder()],
    ["dailyApiCalls", getU32Encoder()],
    ["votingPower", getU64Encoder()]
  ]);
}
function getGhostStakedEventDecoder() {
  return getStructDecoder([
    ["agent", getAddressDecoder2()],
    ["amount", getU64Decoder()],
    ["unlockAt", getI64Decoder()],
    ["reputationBoostBps", getU16Decoder()],
    ["tier", getAccessTierDecoder()],
    ["dailyApiCalls", getU32Decoder()],
    ["votingPower", getU64Decoder()]
  ]);
}
function getGhostStakedEventCodec() {
  return combineCodec2(getGhostStakedEventEncoder(), getGhostStakedEventDecoder());
}
function getGhostUnstakedEventEncoder() {
  return getStructEncoder([
    ["agent", getAddressEncoder2()],
    ["amount", getU64Encoder()]
  ]);
}
function getGhostUnstakedEventDecoder() {
  return getStructDecoder([
    ["agent", getAddressDecoder2()],
    ["amount", getU64Decoder()]
  ]);
}
function getGhostUnstakedEventCodec() {
  return combineCodec2(getGhostUnstakedEventEncoder(), getGhostUnstakedEventDecoder());
}
function getGovernanceProposalCreatedEventEncoder() {
  return getStructEncoder([
    ["proposal", getAddressEncoder2()],
    ["proposalId", getU64Encoder()],
    ["proposer", getAddressEncoder2()],
    ["title", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())]
  ]);
}
function getGovernanceProposalCreatedEventDecoder() {
  return getStructDecoder([
    ["proposal", getAddressDecoder2()],
    ["proposalId", getU64Decoder()],
    ["proposer", getAddressDecoder2()],
    ["title", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())]
  ]);
}
function getGovernanceProposalCreatedEventCodec() {
  return combineCodec2(getGovernanceProposalCreatedEventEncoder(), getGovernanceProposalCreatedEventDecoder());
}
function getHierarchicalBoundaryEncoder() {
  return getStructEncoder([
    ["level", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["value", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["includeDescendants", getBooleanEncoder()]
  ]);
}
function getHierarchicalBoundaryDecoder() {
  return getStructDecoder([
    ["level", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["value", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["includeDescendants", getBooleanDecoder()]
  ]);
}
function getHierarchicalBoundaryCodec() {
  return combineCodec2(getHierarchicalBoundaryEncoder(), getHierarchicalBoundaryDecoder());
}
function getIncidentResponsePoliciesEncoder() {
  return getStructEncoder([
    ["responseTeam", getArrayEncoder(getAddressEncoder2())],
    [
      "escalationProcedures",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    [
      "notificationRequirements",
      getArrayEncoder(getNotificationRequirementEncoder())
    ]
  ]);
}
function getIncidentResponsePoliciesDecoder() {
  return getStructDecoder([
    ["responseTeam", getArrayDecoder(getAddressDecoder2())],
    [
      "escalationProcedures",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    [
      "notificationRequirements",
      getArrayDecoder(getNotificationRequirementDecoder())
    ]
  ]);
}
function getIncidentResponsePoliciesCodec() {
  return combineCodec2(getIncidentResponsePoliciesEncoder(), getIncidentResponsePoliciesDecoder());
}
function getLatitudeRangeEncoder() {
  return getStructEncoder([
    ["min", getF64Encoder()],
    ["max", getF64Encoder()]
  ]);
}
function getLatitudeRangeDecoder() {
  return getStructDecoder([
    ["min", getF64Decoder()],
    ["max", getF64Decoder()]
  ]);
}
function getLatitudeRangeCodec() {
  return combineCodec2(getLatitudeRangeEncoder(), getLatitudeRangeDecoder());
}
function getLocationConstraintsEncoder() {
  return getStructEncoder([
    [
      "allowedCountries",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    [
      "blockedCountries",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    [
      "allowedIpRanges",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    [
      "blockedIpRanges",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    ["geofencingEnabled", getBooleanEncoder()],
    ["allowedRegions", getArrayEncoder(getGeographicRegionEncoder())]
  ]);
}
function getLocationConstraintsDecoder() {
  return getStructDecoder([
    [
      "allowedCountries",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    [
      "blockedCountries",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    [
      "allowedIpRanges",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    [
      "blockedIpRanges",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    ["geofencingEnabled", getBooleanDecoder()],
    ["allowedRegions", getArrayDecoder(getGeographicRegionDecoder())]
  ]);
}
function getLocationConstraintsCodec() {
  return combineCodec2(getLocationConstraintsEncoder(), getLocationConstraintsDecoder());
}
function getLongitudeRangeEncoder() {
  return getStructEncoder([
    ["min", getF64Encoder()],
    ["max", getF64Encoder()]
  ]);
}
function getLongitudeRangeDecoder() {
  return getStructDecoder([
    ["min", getF64Decoder()],
    ["max", getF64Decoder()]
  ]);
}
function getLongitudeRangeCodec() {
  return combineCodec2(getLongitudeRangeEncoder(), getLongitudeRangeDecoder());
}
function getMultisigConfigEncoder() {
  return getStructEncoder([
    ["threshold", getU8Encoder()]
  ]);
}
function getMultisigConfigDecoder() {
  return getStructDecoder([
    ["threshold", getU8Decoder()]
  ]);
}
function getMultisigConfigCodec() {
  return combineCodec2(getMultisigConfigEncoder(), getMultisigConfigDecoder());
}
function getMultisigCreatedEventEncoder() {
  return getStructEncoder([
    ["multisigId", getU64Encoder()],
    ["multisigType", getMultisigTypeEncoder()],
    ["owner", getAddressEncoder2()],
    ["threshold", getU8Encoder()],
    ["signerCount", getU8Encoder()],
    ["timestamp", getI64Encoder()]
  ]);
}
function getMultisigCreatedEventDecoder() {
  return getStructDecoder([
    ["multisigId", getU64Decoder()],
    ["multisigType", getMultisigTypeDecoder()],
    ["owner", getAddressDecoder2()],
    ["threshold", getU8Decoder()],
    ["signerCount", getU8Decoder()],
    ["timestamp", getI64Decoder()]
  ]);
}
function getMultisigCreatedEventCodec() {
  return combineCodec2(getMultisigCreatedEventEncoder(), getMultisigCreatedEventDecoder());
}
function getMultisigSignatureEncoder() {
  return getStructEncoder([
    ["signer", getAddressEncoder2()],
    ["signature", fixEncoderSize2(getBytesEncoder(), 64)],
    ["signedAt", getI64Encoder()],
    [
      "signatureMethod",
      addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())
    ],
    [
      "verificationData",
      getOptionEncoder(addEncoderSizePrefix(getBytesEncoder(), getU32Encoder()))
    ]
  ]);
}
function getMultisigSignatureDecoder() {
  return getStructDecoder([
    ["signer", getAddressDecoder2()],
    ["signature", fixDecoderSize2(getBytesDecoder(), 64)],
    ["signedAt", getI64Decoder()],
    [
      "signatureMethod",
      addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())
    ],
    [
      "verificationData",
      getOptionDecoder(addDecoderSizePrefix(getBytesDecoder(), getU32Decoder()))
    ]
  ]);
}
function getMultisigSignatureCodec() {
  return combineCodec2(getMultisigSignatureEncoder(), getMultisigSignatureDecoder());
}
function getMultisigTypeEncoder() {
  return getEnumEncoder(MultisigType);
}
function getMultisigTypeDecoder() {
  return getEnumDecoder(MultisigType);
}
function getMultisigTypeCodec() {
  return combineCodec2(getMultisigTypeEncoder(), getMultisigTypeDecoder());
}
function getMultisigTypeConfigEncoder() {
  return getStructEncoder([
    ["multisigType", getMultisigTypeEncoder()],
    ["timelockSeconds", getI64Encoder()],
    ["minSigners", getU8Encoder()],
    ["maxSigners", getU8Encoder()],
    ["minReputationScore", getU16Encoder()],
    ["requiresTokenHoldings", getBooleanEncoder()],
    ["minTokenBalance", getU64Encoder()]
  ]);
}
function getMultisigTypeConfigDecoder() {
  return getStructDecoder([
    ["multisigType", getMultisigTypeDecoder()],
    ["timelockSeconds", getI64Decoder()],
    ["minSigners", getU8Decoder()],
    ["maxSigners", getU8Decoder()],
    ["minReputationScore", getU16Decoder()],
    ["requiresTokenHoldings", getBooleanDecoder()],
    ["minTokenBalance", getU64Decoder()]
  ]);
}
function getMultisigTypeConfigCodec() {
  return combineCodec2(getMultisigTypeConfigEncoder(), getMultisigTypeConfigDecoder());
}
function getNetworkSecurityPoliciesEncoder() {
  return getStructEncoder([
    ["firewallRequired", getBooleanEncoder()],
    ["intrusionDetection", getBooleanEncoder()],
    ["trafficMonitoring", getBooleanEncoder()]
  ]);
}
function getNetworkSecurityPoliciesDecoder() {
  return getStructDecoder([
    ["firewallRequired", getBooleanDecoder()],
    ["intrusionDetection", getBooleanDecoder()],
    ["trafficMonitoring", getBooleanDecoder()]
  ]);
}
function getNetworkSecurityPoliciesCodec() {
  return combineCodec2(getNetworkSecurityPoliciesEncoder(), getNetworkSecurityPoliciesDecoder());
}
function getNotificationMethodEncoder() {
  return getEnumEncoder(NotificationMethod);
}
function getNotificationMethodDecoder() {
  return getEnumDecoder(NotificationMethod);
}
function getNotificationMethodCodec() {
  return combineCodec2(getNotificationMethodEncoder(), getNotificationMethodDecoder());
}
function getNotificationPriorityEncoder() {
  return getEnumEncoder(NotificationPriority);
}
function getNotificationPriorityDecoder() {
  return getEnumDecoder(NotificationPriority);
}
function getNotificationPriorityCodec() {
  return combineCodec2(getNotificationPriorityEncoder(), getNotificationPriorityDecoder());
}
function getNotificationRequirementEncoder() {
  return getStructEncoder([
    ["eventType", getSecurityEventTypeEncoder()],
    ["targets", getArrayEncoder(getNotificationTargetEncoder())],
    ["method", getNotificationMethodEncoder()],
    ["timing", getNotificationTimingEncoder()]
  ]);
}
function getNotificationRequirementDecoder() {
  return getStructDecoder([
    ["eventType", getSecurityEventTypeDecoder()],
    ["targets", getArrayDecoder(getNotificationTargetDecoder())],
    ["method", getNotificationMethodDecoder()],
    ["timing", getNotificationTimingDecoder()]
  ]);
}
function getNotificationRequirementCodec() {
  return combineCodec2(getNotificationRequirementEncoder(), getNotificationRequirementDecoder());
}
function getNotificationTargetEncoder() {
  return getStructEncoder([
    ["targetType", getNotificationTargetTypeEncoder()],
    ["targetId", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["priority", getNotificationPriorityEncoder()]
  ]);
}
function getNotificationTargetDecoder() {
  return getStructDecoder([
    ["targetType", getNotificationTargetTypeDecoder()],
    ["targetId", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["priority", getNotificationPriorityDecoder()]
  ]);
}
function getNotificationTargetCodec() {
  return combineCodec2(getNotificationTargetEncoder(), getNotificationTargetDecoder());
}
function getNotificationTargetTypeEncoder() {
  return getEnumEncoder(NotificationTargetType);
}
function getNotificationTargetTypeDecoder() {
  return getEnumDecoder(NotificationTargetType);
}
function getNotificationTargetTypeCodec() {
  return combineCodec2(getNotificationTargetTypeEncoder(), getNotificationTargetTypeDecoder());
}
function getNotificationTimingEncoder() {
  return getEnumEncoder(NotificationTiming);
}
function getNotificationTimingDecoder() {
  return getEnumDecoder(NotificationTiming);
}
function getNotificationTimingCodec() {
  return combineCodec2(getNotificationTimingEncoder(), getNotificationTimingDecoder());
}
function getPasswordPoliciesEncoder() {
  return getStructEncoder([
    ["minimumLength", getU8Encoder()],
    [
      "complexityRequirements",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    ["historyCount", getU8Encoder()],
    ["maxAge", getI64Encoder()]
  ]);
}
function getPasswordPoliciesDecoder() {
  return getStructDecoder([
    ["minimumLength", getU8Decoder()],
    [
      "complexityRequirements",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    ["historyCount", getU8Decoder()],
    ["maxAge", getI64Decoder()]
  ]);
}
function getPasswordPoliciesCodec() {
  return combineCodec2(getPasswordPoliciesEncoder(), getPasswordPoliciesDecoder());
}
function getPendingTransactionEncoder() {
  return getStructEncoder([
    ["transactionId", getU64Encoder()],
    ["transactionType", getTransactionTypeEncoder()],
    ["target", getAddressEncoder2()],
    ["data", addEncoderSizePrefix(getBytesEncoder(), getU32Encoder())],
    ["requiredSignatures", getU8Encoder()],
    ["signatures", getArrayEncoder(getMultisigSignatureEncoder())],
    ["createdAt", getI64Encoder()],
    ["expiresAt", getI64Encoder()],
    ["priority", getTransactionPriorityEncoder()],
    ["executionConditions", getArrayEncoder(getExecutionConditionEncoder())],
    ["status", getTransactionStatusEncoder()],
    ["timeLock", getOptionEncoder(getTimeLockEncoder())]
  ]);
}
function getPendingTransactionDecoder() {
  return getStructDecoder([
    ["transactionId", getU64Decoder()],
    ["transactionType", getTransactionTypeDecoder()],
    ["target", getAddressDecoder2()],
    ["data", addDecoderSizePrefix(getBytesDecoder(), getU32Decoder())],
    ["requiredSignatures", getU8Decoder()],
    ["signatures", getArrayDecoder(getMultisigSignatureDecoder())],
    ["createdAt", getI64Decoder()],
    ["expiresAt", getI64Decoder()],
    ["priority", getTransactionPriorityDecoder()],
    ["executionConditions", getArrayDecoder(getExecutionConditionDecoder())],
    ["status", getTransactionStatusDecoder()],
    ["timeLock", getOptionDecoder(getTimeLockDecoder())]
  ]);
}
function getPendingTransactionCodec() {
  return combineCodec2(getPendingTransactionEncoder(), getPendingTransactionDecoder());
}
function getPermissionEncoder() {
  return getStructEncoder([
    ["permissionId", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["name", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["description", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["resourceType", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["actions", getArrayEncoder(getActionEncoder())],
    ["scope", getPermissionScopeEncoder()],
    ["constraints", getArrayEncoder(getPermissionConstraintEncoder())],
    ["metadata", getPermissionMetadataEncoder()]
  ]);
}
function getPermissionDecoder() {
  return getStructDecoder([
    ["permissionId", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["name", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["description", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["resourceType", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["actions", getArrayDecoder(getActionDecoder())],
    ["scope", getPermissionScopeDecoder()],
    ["constraints", getArrayDecoder(getPermissionConstraintDecoder())],
    ["metadata", getPermissionMetadataDecoder()]
  ]);
}
function getPermissionCodec() {
  return combineCodec2(getPermissionEncoder(), getPermissionDecoder());
}
function getPermissionConstraintEncoder() {
  return getStructEncoder([
    ["constraintType", getPermissionConstraintTypeEncoder()],
    ["conditions", getArrayEncoder(getConstraintConditionEncoder())],
    ["enforcement", getEnforcementLevelEncoder()]
  ]);
}
function getPermissionConstraintDecoder() {
  return getStructDecoder([
    ["constraintType", getPermissionConstraintTypeDecoder()],
    ["conditions", getArrayDecoder(getConstraintConditionDecoder())],
    ["enforcement", getEnforcementLevelDecoder()]
  ]);
}
function getPermissionConstraintCodec() {
  return combineCodec2(getPermissionConstraintEncoder(), getPermissionConstraintDecoder());
}
function getPermissionConstraintTypeEncoder() {
  return getEnumEncoder(PermissionConstraintType);
}
function getPermissionConstraintTypeDecoder() {
  return getEnumDecoder(PermissionConstraintType);
}
function getPermissionConstraintTypeCodec() {
  return combineCodec2(getPermissionConstraintTypeEncoder(), getPermissionConstraintTypeDecoder());
}
function getPermissionMetadataEncoder() {
  return getStructEncoder([
    [
      "businessJustification",
      addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())
    ],
    ["riskAssessment", getRiskAssessmentEncoder()],
    [
      "complianceMapping",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    [
      "relatedPermissions",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    ["owner", getOptionEncoder(getAddressEncoder2())],
    ["lastReview", getOptionEncoder(getI64Encoder())],
    ["reviewFrequency", getI64Encoder()]
  ]);
}
function getPermissionMetadataDecoder() {
  return getStructDecoder([
    [
      "businessJustification",
      addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())
    ],
    ["riskAssessment", getRiskAssessmentDecoder()],
    [
      "complianceMapping",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    [
      "relatedPermissions",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    ["owner", getOptionDecoder(getAddressDecoder2())],
    ["lastReview", getOptionDecoder(getI64Decoder())],
    ["reviewFrequency", getI64Decoder()]
  ]);
}
function getPermissionMetadataCodec() {
  return combineCodec2(getPermissionMetadataEncoder(), getPermissionMetadataDecoder());
}
function getPermissionScopeEncoder() {
  return getStructEncoder([
    ["scopeType", getScopeTypeEncoder()],
    ["boundaries", getScopeBoundariesEncoder()],
    ["hierarchical", getBooleanEncoder()],
    ["inherited", getBooleanEncoder()]
  ]);
}
function getPermissionScopeDecoder() {
  return getStructDecoder([
    ["scopeType", getScopeTypeDecoder()],
    ["boundaries", getScopeBoundariesDecoder()],
    ["hierarchical", getBooleanDecoder()],
    ["inherited", getBooleanDecoder()]
  ]);
}
function getPermissionScopeCodec() {
  return combineCodec2(getPermissionScopeEncoder(), getPermissionScopeDecoder());
}
function getPolicyMetadataEncoder() {
  return getStructEncoder([
    ["author", getOptionEncoder(getAddressEncoder2())],
    ["approver", getOptionEncoder(getAddressEncoder2())],
    ["approvalDate", getOptionEncoder(getI64Encoder())],
    [
      "businessJustification",
      addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())
    ],
    [
      "complianceReferences",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    [
      "riskAssessment",
      getOptionEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    ["reviewSchedule", getReviewScheduleEncoder()]
  ]);
}
function getPolicyMetadataDecoder() {
  return getStructDecoder([
    ["author", getOptionDecoder(getAddressDecoder2())],
    ["approver", getOptionDecoder(getAddressDecoder2())],
    ["approvalDate", getOptionDecoder(getI64Decoder())],
    [
      "businessJustification",
      addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())
    ],
    [
      "complianceReferences",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    [
      "riskAssessment",
      getOptionDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    ["reviewSchedule", getReviewScheduleDecoder()]
  ]);
}
function getPolicyMetadataCodec() {
  return combineCodec2(getPolicyMetadataEncoder(), getPolicyMetadataDecoder());
}
function getPolicyRuleEncoder() {
  return getStructEncoder([
    ["ruleId", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["conditions", getArrayEncoder(getRuleConditionEncoder())],
    ["effect", getRuleEffectEncoder()],
    ["priority", getU8Encoder()],
    ["enabled", getBooleanEncoder()]
  ]);
}
function getPolicyRuleDecoder() {
  return getStructDecoder([
    ["ruleId", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["conditions", getArrayDecoder(getRuleConditionDecoder())],
    ["effect", getRuleEffectDecoder()],
    ["priority", getU8Decoder()],
    ["enabled", getBooleanDecoder()]
  ]);
}
function getPolicyRuleCodec() {
  return combineCodec2(getPolicyRuleEncoder(), getPolicyRuleDecoder());
}
function getPolicyScopeEncoder() {
  return getStructEncoder([
    [
      "subjects",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    [
      "resources",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    [
      "actions",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    ["inheritance", getScopeInheritanceEncoder()]
  ]);
}
function getPolicyScopeDecoder() {
  return getStructDecoder([
    [
      "subjects",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    [
      "resources",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    [
      "actions",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    ["inheritance", getScopeInheritanceDecoder()]
  ]);
}
function getPolicyScopeCodec() {
  return combineCodec2(getPolicyScopeEncoder(), getPolicyScopeDecoder());
}
function getPolicyStatusEncoder() {
  return getEnumEncoder(PolicyStatus);
}
function getPolicyStatusDecoder() {
  return getEnumDecoder(PolicyStatus);
}
function getPolicyStatusCodec() {
  return combineCodec2(getPolicyStatusEncoder(), getPolicyStatusDecoder());
}
function getPolicyTypeEncoder() {
  return getEnumEncoder(PolicyType);
}
function getPolicyTypeDecoder() {
  return getEnumDecoder(PolicyType);
}
function getPolicyTypeCodec() {
  return combineCodec2(getPolicyTypeEncoder(), getPolicyTypeDecoder());
}
function getPricingModelEncoder() {
  return getEnumEncoder(PricingModel);
}
function getPricingModelDecoder() {
  return getEnumDecoder(PricingModel);
}
function getPricingModelCodec() {
  return combineCodec2(getPricingModelEncoder(), getPricingModelDecoder());
}
function getProposalAccountEncoder() {
  return getStructEncoder([
    ["pubkey", getAddressEncoder2()],
    ["isSigner", getBooleanEncoder()],
    ["isWritable", getBooleanEncoder()],
    ["description", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())]
  ]);
}
function getProposalAccountDecoder() {
  return getStructDecoder([
    ["pubkey", getAddressDecoder2()],
    ["isSigner", getBooleanDecoder()],
    ["isWritable", getBooleanDecoder()],
    ["description", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())]
  ]);
}
function getProposalAccountCodec() {
  return combineCodec2(getProposalAccountEncoder(), getProposalAccountDecoder());
}
function getProposalInstructionEncoder() {
  return getStructEncoder([
    ["programId", getAddressEncoder2()],
    ["accounts", getArrayEncoder(getProposalAccountEncoder())],
    ["data", addEncoderSizePrefix(getBytesEncoder(), getU32Encoder())],
    ["description", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())]
  ]);
}
function getProposalInstructionDecoder() {
  return getStructDecoder([
    ["programId", getAddressDecoder2()],
    ["accounts", getArrayDecoder(getProposalAccountDecoder())],
    ["data", addDecoderSizePrefix(getBytesDecoder(), getU32Decoder())],
    ["description", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())]
  ]);
}
function getProposalInstructionCodec() {
  return combineCodec2(getProposalInstructionEncoder(), getProposalInstructionDecoder());
}
function getProposalMetadataEncoder() {
  return getStructEncoder([
    [
      "ipfsHash",
      getOptionEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    [
      "externalReferences",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    [
      "tags",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    [
      "riskAssessment",
      getOptionEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    [
      "impactAnalysis",
      getOptionEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    [
      "implementationTimeline",
      getOptionEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ]
  ]);
}
function getProposalMetadataDecoder() {
  return getStructDecoder([
    [
      "ipfsHash",
      getOptionDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    [
      "externalReferences",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    [
      "tags",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    [
      "riskAssessment",
      getOptionDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    [
      "impactAnalysis",
      getOptionDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    [
      "implementationTimeline",
      getOptionDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ]
  ]);
}
function getProposalMetadataCodec() {
  return combineCodec2(getProposalMetadataEncoder(), getProposalMetadataDecoder());
}
function getProposalStatusEncoder() {
  return getEnumEncoder(ProposalStatus);
}
function getProposalStatusDecoder() {
  return getEnumDecoder(ProposalStatus);
}
function getProposalStatusCodec() {
  return combineCodec2(getProposalStatusEncoder(), getProposalStatusDecoder());
}
function getProposalTypeEncoder() {
  return getEnumEncoder(ProposalType);
}
function getProposalTypeDecoder() {
  return getEnumDecoder(ProposalType);
}
function getProposalTypeCodec() {
  return combineCodec2(getProposalTypeEncoder(), getProposalTypeDecoder());
}
function getProtocolConfigUpdatedEventEncoder() {
  return getStructEncoder([
    ["authority", getAddressEncoder2()],
    ["feesEnabled", getBooleanEncoder()],
    ["escrowFeeBps", getU16Encoder()],
    ["agentRegistrationFee", getU64Encoder()],
    ["listingFee", getU64Encoder()],
    ["disputeFeeBps", getU16Encoder()],
    ["timestamp", getI64Encoder()]
  ]);
}
function getProtocolConfigUpdatedEventDecoder() {
  return getStructDecoder([
    ["authority", getAddressDecoder2()],
    ["feesEnabled", getBooleanDecoder()],
    ["escrowFeeBps", getU16Decoder()],
    ["agentRegistrationFee", getU64Decoder()],
    ["listingFee", getU64Decoder()],
    ["disputeFeeBps", getU16Decoder()],
    ["timestamp", getI64Decoder()]
  ]);
}
function getProtocolConfigUpdatedEventCodec() {
  return combineCodec2(getProtocolConfigUpdatedEventEncoder(), getProtocolConfigUpdatedEventDecoder());
}
function getQuorumMethodEncoder() {
  return getEnumEncoder(QuorumMethod);
}
function getQuorumMethodDecoder() {
  return getEnumDecoder(QuorumMethod);
}
function getQuorumMethodCodec() {
  return combineCodec2(getQuorumMethodEncoder(), getQuorumMethodDecoder());
}
function getQuorumRequirementsEncoder() {
  return getStructEncoder([
    ["minimumParticipation", getU8Encoder()],
    ["approvalThreshold", getU8Encoder()],
    ["superMajorityRequired", getBooleanEncoder()],
    ["minimumVotingPower", getU64Encoder()],
    ["quorumMethod", getQuorumMethodEncoder()]
  ]);
}
function getQuorumRequirementsDecoder() {
  return getStructDecoder([
    ["minimumParticipation", getU8Decoder()],
    ["approvalThreshold", getU8Decoder()],
    ["superMajorityRequired", getBooleanDecoder()],
    ["minimumVotingPower", getU64Decoder()],
    ["quorumMethod", getQuorumMethodDecoder()]
  ]);
}
function getQuorumRequirementsCodec() {
  return combineCodec2(getQuorumRequirementsEncoder(), getQuorumRequirementsDecoder());
}
function getRbacConfigInitializedEventEncoder() {
  return getStructEncoder([
    ["rbacConfig", getAddressEncoder2()],
    ["authority", getAddressEncoder2()],
    ["rolesCount", getU32Encoder()]
  ]);
}
function getRbacConfigInitializedEventDecoder() {
  return getStructDecoder([
    ["rbacConfig", getAddressDecoder2()],
    ["authority", getAddressDecoder2()],
    ["rolesCount", getU32Decoder()]
  ]);
}
function getRbacConfigInitializedEventCodec() {
  return combineCodec2(getRbacConfigInitializedEventEncoder(), getRbacConfigInitializedEventDecoder());
}
function getReentrancyStateEncoder() {
  return getEnumEncoder(ReentrancyState);
}
function getReentrancyStateDecoder() {
  return getEnumDecoder(ReentrancyState);
}
function getReentrancyStateCodec() {
  return combineCodec2(getReentrancyStateEncoder(), getReentrancyStateDecoder());
}
function getReportDataEncoder() {
  return getStructEncoder([
    ["summary", getReportSummaryEncoder()],
    ["entries", getArrayEncoder(getReportEntryEncoder())],
    ["complianceMetrics", getComplianceMetricsEncoder()],
    ["riskIndicators", getArrayEncoder(getRiskIndicatorEncoder())],
    [
      "recommendations",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ]
  ]);
}
function getReportDataDecoder() {
  return getStructDecoder([
    ["summary", getReportSummaryDecoder()],
    ["entries", getArrayDecoder(getReportEntryDecoder())],
    ["complianceMetrics", getComplianceMetricsDecoder()],
    ["riskIndicators", getArrayDecoder(getRiskIndicatorDecoder())],
    [
      "recommendations",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ]
  ]);
}
function getReportDataCodec() {
  return combineCodec2(getReportDataEncoder(), getReportDataDecoder());
}
function getReportEntryEncoder() {
  return getStructEncoder([
    ["data", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())]
  ]);
}
function getReportEntryDecoder() {
  return getStructDecoder([
    ["data", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())]
  ]);
}
function getReportEntryCodec() {
  return combineCodec2(getReportEntryEncoder(), getReportEntryDecoder());
}
function getReportingFrequencyEncoder() {
  return getEnumEncoder(ReportingFrequency);
}
function getReportingFrequencyDecoder() {
  return getEnumDecoder(ReportingFrequency);
}
function getReportingFrequencyCodec() {
  return combineCodec2(getReportingFrequencyEncoder(), getReportingFrequencyDecoder());
}
function getReportStatusEncoder() {
  return getEnumEncoder(ReportStatus);
}
function getReportStatusDecoder() {
  return getEnumDecoder(ReportStatus);
}
function getReportStatusCodec() {
  return combineCodec2(getReportStatusEncoder(), getReportStatusDecoder());
}
function getReportSummaryEncoder() {
  return getStructEncoder([
    ["totalTransactions", getU64Encoder()],
    ["totalVolume", getU64Encoder()],
    ["highRiskTransactions", getU64Encoder()],
    ["complianceViolations", getU64Encoder()],
    ["securityIncidents", getU64Encoder()],
    ["averageRiskScore", getU8Encoder()]
  ]);
}
function getReportSummaryDecoder() {
  return getStructDecoder([
    ["totalTransactions", getU64Decoder()],
    ["totalVolume", getU64Decoder()],
    ["highRiskTransactions", getU64Decoder()],
    ["complianceViolations", getU64Decoder()],
    ["securityIncidents", getU64Decoder()],
    ["averageRiskScore", getU8Decoder()]
  ]);
}
function getReportSummaryCodec() {
  return combineCodec2(getReportSummaryEncoder(), getReportSummaryDecoder());
}
function getReportTypeEncoder() {
  return getEnumEncoder(ReportType);
}
function getReportTypeDecoder() {
  return getEnumDecoder(ReportType);
}
function getReportTypeCodec() {
  return combineCodec2(getReportTypeEncoder(), getReportTypeDecoder());
}
function getReputationComponentEncoder() {
  return getStructEncoder([
    ["sourceType", getReputationSourceTypeEncoder()],
    ["score", getU64Encoder()],
    ["weight", getU32Encoder()],
    ["lastUpdated", getI64Encoder()],
    ["dataPoints", getU64Encoder()]
  ]);
}
function getReputationComponentDecoder() {
  return getStructDecoder([
    ["sourceType", getReputationSourceTypeDecoder()],
    ["score", getU64Decoder()],
    ["weight", getU32Decoder()],
    ["lastUpdated", getI64Decoder()],
    ["dataPoints", getU64Decoder()]
  ]);
}
function getReputationComponentCodec() {
  return combineCodec2(getReputationComponentEncoder(), getReputationComponentDecoder());
}
function getReputationMetricsInitializedEventEncoder() {
  return getStructEncoder([
    ["agent", getAddressEncoder2()],
    ["timestamp", getI64Encoder()]
  ]);
}
function getReputationMetricsInitializedEventDecoder() {
  return getStructDecoder([
    ["agent", getAddressDecoder2()],
    ["timestamp", getI64Decoder()]
  ]);
}
function getReputationMetricsInitializedEventCodec() {
  return combineCodec2(getReputationMetricsInitializedEventEncoder(), getReputationMetricsInitializedEventDecoder());
}
function getReputationPaymentRecordedEventEncoder() {
  return getStructEncoder([
    ["agent", getAddressEncoder2()],
    [
      "paymentSignature",
      addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())
    ],
    ["amount", getU64Encoder()],
    ["responseTimeMs", getU64Encoder()],
    ["success", getBooleanEncoder()],
    ["newReputationScore", getU64Encoder()],
    ["timestamp", getI64Encoder()]
  ]);
}
function getReputationPaymentRecordedEventDecoder() {
  return getStructDecoder([
    ["agent", getAddressDecoder2()],
    [
      "paymentSignature",
      addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())
    ],
    ["amount", getU64Decoder()],
    ["responseTimeMs", getU64Decoder()],
    ["success", getBooleanDecoder()],
    ["newReputationScore", getU64Decoder()],
    ["timestamp", getI64Decoder()]
  ]);
}
function getReputationPaymentRecordedEventCodec() {
  return combineCodec2(getReputationPaymentRecordedEventEncoder(), getReputationPaymentRecordedEventDecoder());
}
function getReputationRatingSubmittedEventEncoder() {
  return getStructEncoder([
    ["agent", getAddressEncoder2()],
    ["client", getAddressEncoder2()],
    ["rating", getU8Encoder()],
    ["newReputationScore", getU64Encoder()],
    ["timestamp", getI64Encoder()]
  ]);
}
function getReputationRatingSubmittedEventDecoder() {
  return getStructDecoder([
    ["agent", getAddressDecoder2()],
    ["client", getAddressDecoder2()],
    ["rating", getU8Decoder()],
    ["newReputationScore", getU64Decoder()],
    ["timestamp", getI64Decoder()]
  ]);
}
function getReputationRatingSubmittedEventCodec() {
  return combineCodec2(getReputationRatingSubmittedEventEncoder(), getReputationRatingSubmittedEventDecoder());
}
function getReputationSourceTypeEncoder() {
  return getEnumEncoder(ReputationSourceType);
}
function getReputationSourceTypeDecoder() {
  return getEnumDecoder(ReputationSourceType);
}
function getReputationSourceTypeCodec() {
  return combineCodec2(getReputationSourceTypeEncoder(), getReputationSourceTypeDecoder());
}
function getReputationTagsUpdatedEventEncoder() {
  return getStructEncoder([
    ["agent", getAddressEncoder2()],
    ["totalTags", getU32Encoder()],
    ["skillTagsCount", getU32Encoder()],
    ["behaviorTagsCount", getU32Encoder()],
    ["complianceTagsCount", getU32Encoder()],
    ["tagScoresCount", getU32Encoder()],
    ["timestamp", getI64Encoder()]
  ]);
}
function getReputationTagsUpdatedEventDecoder() {
  return getStructDecoder([
    ["agent", getAddressDecoder2()],
    ["totalTags", getU32Decoder()],
    ["skillTagsCount", getU32Decoder()],
    ["behaviorTagsCount", getU32Decoder()],
    ["complianceTagsCount", getU32Decoder()],
    ["tagScoresCount", getU32Decoder()],
    ["timestamp", getI64Decoder()]
  ]);
}
function getReputationTagsUpdatedEventCodec() {
  return combineCodec2(getReputationTagsUpdatedEventEncoder(), getReputationTagsUpdatedEventDecoder());
}
function getResourceConstraintsEncoder() {
  return getStructEncoder([
    ["maxUsage", getU8Encoder()]
  ]);
}
function getResourceConstraintsDecoder() {
  return getStructDecoder([
    ["maxUsage", getU8Decoder()]
  ]);
}
function getResourceConstraintsCodec() {
  return combineCodec2(getResourceConstraintsEncoder(), getResourceConstraintsDecoder());
}
function getReviewScheduleEncoder() {
  return getStructEncoder([
    ["frequency", getI64Encoder()],
    ["lastReview", getOptionEncoder(getI64Encoder())],
    ["nextReview", getI64Encoder()],
    ["reviewOwners", getArrayEncoder(getAddressEncoder2())],
    [
      "reviewCriteria",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ]
  ]);
}
function getReviewScheduleDecoder() {
  return getStructDecoder([
    ["frequency", getI64Decoder()],
    ["lastReview", getOptionDecoder(getI64Decoder())],
    ["nextReview", getI64Decoder()],
    ["reviewOwners", getArrayDecoder(getAddressDecoder2())],
    [
      "reviewCriteria",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ]
  ]);
}
function getReviewScheduleCodec() {
  return combineCodec2(getReviewScheduleEncoder(), getReviewScheduleDecoder());
}
function getRiskAcceptanceEncoder() {
  return getStructEncoder([
    ["accepted", getBooleanEncoder()],
    ["acceptingAuthority", getOptionEncoder(getAddressEncoder2())],
    ["acceptanceDate", getOptionEncoder(getI64Encoder())],
    [
      "reasoning",
      getOptionEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    ["reviewDate", getOptionEncoder(getI64Encoder())]
  ]);
}
function getRiskAcceptanceDecoder() {
  return getStructDecoder([
    ["accepted", getBooleanDecoder()],
    ["acceptingAuthority", getOptionDecoder(getAddressDecoder2())],
    ["acceptanceDate", getOptionDecoder(getI64Decoder())],
    [
      "reasoning",
      getOptionDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    ["reviewDate", getOptionDecoder(getI64Decoder())]
  ]);
}
function getRiskAcceptanceCodec() {
  return combineCodec2(getRiskAcceptanceEncoder(), getRiskAcceptanceDecoder());
}
function getRiskAssessmentEncoder() {
  return getStructEncoder([
    ["riskScore", getU8Encoder()],
    ["riskFactors", getArrayEncoder(getRiskFactorEncoder())],
    [
      "mitigationMeasures",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    ["riskAcceptance", getRiskAcceptanceEncoder()]
  ]);
}
function getRiskAssessmentDecoder() {
  return getStructDecoder([
    ["riskScore", getU8Decoder()],
    ["riskFactors", getArrayDecoder(getRiskFactorDecoder())],
    [
      "mitigationMeasures",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    ["riskAcceptance", getRiskAcceptanceDecoder()]
  ]);
}
function getRiskAssessmentCodec() {
  return combineCodec2(getRiskAssessmentEncoder(), getRiskAssessmentDecoder());
}
function getRiskCategoryEncoder() {
  return getEnumEncoder(RiskCategory);
}
function getRiskCategoryDecoder() {
  return getEnumDecoder(RiskCategory);
}
function getRiskCategoryCodec() {
  return combineCodec2(getRiskCategoryEncoder(), getRiskCategoryDecoder());
}
function getRiskFactorEncoder() {
  return getStructEncoder([
    ["name", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["category", getRiskCategoryEncoder()],
    ["impact", getU8Encoder()],
    ["likelihood", getU8Encoder()],
    ["riskScore", getU8Encoder()]
  ]);
}
function getRiskFactorDecoder() {
  return getStructDecoder([
    ["name", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["category", getRiskCategoryDecoder()],
    ["impact", getU8Decoder()],
    ["likelihood", getU8Decoder()],
    ["riskScore", getU8Decoder()]
  ]);
}
function getRiskFactorCodec() {
  return combineCodec2(getRiskFactorEncoder(), getRiskFactorDecoder());
}
function getRiskIndicatorEncoder() {
  return getStructEncoder([
    ["name", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["currentValue", getU64Encoder()],
    ["thresholdValue", getU64Encoder()],
    ["trend", getTrendDirectionEncoder()],
    ["severity", getViolationSeverityEncoder()],
    [
      "recommendedActions",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ]
  ]);
}
function getRiskIndicatorDecoder() {
  return getStructDecoder([
    ["name", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["currentValue", getU64Decoder()],
    ["thresholdValue", getU64Decoder()],
    ["trend", getTrendDirectionDecoder()],
    ["severity", getViolationSeverityDecoder()],
    [
      "recommendedActions",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ]
  ]);
}
function getRiskIndicatorCodec() {
  return combineCodec2(getRiskIndicatorEncoder(), getRiskIndicatorDecoder());
}
function getRiskLevelEncoder() {
  return getEnumEncoder(RiskLevel);
}
function getRiskLevelDecoder() {
  return getEnumDecoder(RiskLevel);
}
function getRiskLevelCodec() {
  return combineCodec2(getRiskLevelEncoder(), getRiskLevelDecoder());
}
function getRoleEncoder() {
  return getStructEncoder([
    ["roleId", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["name", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["description", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["roleType", getRoleTypeEncoder()],
    [
      "permissions",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    ["constraints", getRoleConstraintsEncoder()],
    [
      "inheritsFrom",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    ["metadata", getRoleMetadataEncoder()],
    ["status", getRoleStatusEncoder()],
    ["createdAt", getI64Encoder()],
    ["modifiedAt", getI64Encoder()]
  ]);
}
function getRoleDecoder() {
  return getStructDecoder([
    ["roleId", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["name", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["description", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["roleType", getRoleTypeDecoder()],
    [
      "permissions",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    ["constraints", getRoleConstraintsDecoder()],
    [
      "inheritsFrom",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    ["metadata", getRoleMetadataDecoder()],
    ["status", getRoleStatusDecoder()],
    ["createdAt", getI64Decoder()],
    ["modifiedAt", getI64Decoder()]
  ]);
}
function getRoleCodec() {
  return combineCodec2(getRoleEncoder(), getRoleDecoder());
}
function getRoleConstraintsEncoder() {
  return getStructEncoder([
    ["timeConstraints", getOptionEncoder(getTimeConstraintsEncoder())],
    ["locationConstraints", getOptionEncoder(getLocationConstraintsEncoder())],
    ["resourceConstraints", getOptionEncoder(getResourceConstraintsEncoder())],
    ["sessionConstraints", getOptionEncoder(getSessionConstraintsEncoder())],
    ["sodConstraints", getArrayEncoder(getSodConstraintEncoder())],
    ["maxConcurrentSessions", getOptionEncoder(getU32Encoder())],
    [
      "activationRequirements",
      getArrayEncoder(getActivationRequirementEncoder())
    ]
  ]);
}
function getRoleConstraintsDecoder() {
  return getStructDecoder([
    ["timeConstraints", getOptionDecoder(getTimeConstraintsDecoder())],
    ["locationConstraints", getOptionDecoder(getLocationConstraintsDecoder())],
    ["resourceConstraints", getOptionDecoder(getResourceConstraintsDecoder())],
    ["sessionConstraints", getOptionDecoder(getSessionConstraintsDecoder())],
    ["sodConstraints", getArrayDecoder(getSodConstraintDecoder())],
    ["maxConcurrentSessions", getOptionDecoder(getU32Decoder())],
    [
      "activationRequirements",
      getArrayDecoder(getActivationRequirementDecoder())
    ]
  ]);
}
function getRoleConstraintsCodec() {
  return combineCodec2(getRoleConstraintsEncoder(), getRoleConstraintsDecoder());
}
function getRoleMetadataEncoder() {
  return getStructEncoder([
    [
      "businessPurpose",
      addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())
    ],
    ["riskLevel", getRiskLevelEncoder()],
    ["dataAccessLevel", getDataAccessLevelEncoder()],
    [
      "complianceRequirements",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    ["roleOwner", getOptionEncoder(getAddressEncoder2())],
    ["roleCustodian", getOptionEncoder(getAddressEncoder2())],
    ["reviewFrequency", getI64Encoder()],
    ["lastReview", getOptionEncoder(getI64Encoder())],
    ["nextReview", getOptionEncoder(getI64Encoder())]
  ]);
}
function getRoleMetadataDecoder() {
  return getStructDecoder([
    [
      "businessPurpose",
      addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())
    ],
    ["riskLevel", getRiskLevelDecoder()],
    ["dataAccessLevel", getDataAccessLevelDecoder()],
    [
      "complianceRequirements",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    ["roleOwner", getOptionDecoder(getAddressDecoder2())],
    ["roleCustodian", getOptionDecoder(getAddressDecoder2())],
    ["reviewFrequency", getI64Decoder()],
    ["lastReview", getOptionDecoder(getI64Decoder())],
    ["nextReview", getOptionDecoder(getI64Decoder())]
  ]);
}
function getRoleMetadataCodec() {
  return combineCodec2(getRoleMetadataEncoder(), getRoleMetadataDecoder());
}
function getRoleStatusEncoder() {
  return getEnumEncoder(RoleStatus);
}
function getRoleStatusDecoder() {
  return getEnumDecoder(RoleStatus);
}
function getRoleStatusCodec() {
  return combineCodec2(getRoleStatusEncoder(), getRoleStatusDecoder());
}
function getRoleTypeEncoder() {
  return getEnumEncoder(RoleType);
}
function getRoleTypeDecoder() {
  return getEnumDecoder(RoleType);
}
function getRoleTypeCodec() {
  return combineCodec2(getRoleTypeEncoder(), getRoleTypeDecoder());
}
function getRuleConditionEncoder() {
  return getStructEncoder([
    ["expression", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())]
  ]);
}
function getRuleConditionDecoder() {
  return getStructDecoder([
    ["expression", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())]
  ]);
}
function getRuleConditionCodec() {
  return combineCodec2(getRuleConditionEncoder(), getRuleConditionDecoder());
}
function getRuleEffectEncoder() {
  return getEnumEncoder(RuleEffect);
}
function getRuleEffectDecoder() {
  return getEnumDecoder(RuleEffect);
}
function getRuleEffectCodec() {
  return combineCodec2(getRuleEffectEncoder(), getRuleEffectDecoder());
}
function getScopeBoundariesEncoder() {
  return getStructEncoder([
    [
      "includedResources",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    [
      "excludedResources",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    [
      "resourcePatterns",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    [
      "hierarchicalBoundaries",
      getArrayEncoder(getHierarchicalBoundaryEncoder())
    ]
  ]);
}
function getScopeBoundariesDecoder() {
  return getStructDecoder([
    [
      "includedResources",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    [
      "excludedResources",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    [
      "resourcePatterns",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    [
      "hierarchicalBoundaries",
      getArrayDecoder(getHierarchicalBoundaryDecoder())
    ]
  ]);
}
function getScopeBoundariesCodec() {
  return combineCodec2(getScopeBoundariesEncoder(), getScopeBoundariesDecoder());
}
function getScopeInheritanceEncoder() {
  return getEnumEncoder(ScopeInheritance);
}
function getScopeInheritanceDecoder() {
  return getEnumDecoder(ScopeInheritance);
}
function getScopeInheritanceCodec() {
  return combineCodec2(getScopeInheritanceEncoder(), getScopeInheritanceDecoder());
}
function getScopeTypeEncoder() {
  return getEnumEncoder(ScopeType);
}
function getScopeTypeDecoder() {
  return getEnumDecoder(ScopeType);
}
function getScopeTypeCodec() {
  return combineCodec2(getScopeTypeEncoder(), getScopeTypeDecoder());
}
function getSecurityEventTypeEncoder() {
  return getEnumEncoder(SecurityEventType);
}
function getSecurityEventTypeDecoder() {
  return getEnumDecoder(SecurityEventType);
}
function getSecurityEventTypeCodec() {
  return combineCodec2(getSecurityEventTypeEncoder(), getSecurityEventTypeDecoder());
}
function getSecurityPoliciesEncoder() {
  return getStructEncoder([
    ["authentication", getAuthenticationPoliciesEncoder()],
    ["authorization", getAuthorizationPoliciesEncoder()],
    ["password", getPasswordPoliciesEncoder()],
    ["session", getSessionPoliciesEncoder()],
    ["dataProtection", getDataProtectionPoliciesEncoder()],
    ["networkSecurity", getNetworkSecurityPoliciesEncoder()],
    ["incidentResponse", getIncidentResponsePoliciesEncoder()],
    ["compliance", getCompliancePoliciesEncoder()]
  ]);
}
function getSecurityPoliciesDecoder() {
  return getStructDecoder([
    ["authentication", getAuthenticationPoliciesDecoder()],
    ["authorization", getAuthorizationPoliciesDecoder()],
    ["password", getPasswordPoliciesDecoder()],
    ["session", getSessionPoliciesDecoder()],
    ["dataProtection", getDataProtectionPoliciesDecoder()],
    ["networkSecurity", getNetworkSecurityPoliciesDecoder()],
    ["incidentResponse", getIncidentResponsePoliciesDecoder()],
    ["compliance", getCompliancePoliciesDecoder()]
  ]);
}
function getSecurityPoliciesCodec() {
  return combineCodec2(getSecurityPoliciesEncoder(), getSecurityPoliciesDecoder());
}
function getServiceEndpointEncoder() {
  return getStructEncoder([
    ["id", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["serviceType", getServiceEndpointTypeEncoder()],
    [
      "serviceEndpoint",
      addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())
    ],
    ["description", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())]
  ]);
}
function getServiceEndpointDecoder() {
  return getStructDecoder([
    ["id", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["serviceType", getServiceEndpointTypeDecoder()],
    [
      "serviceEndpoint",
      addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())
    ],
    ["description", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())]
  ]);
}
function getServiceEndpointCodec() {
  return combineCodec2(getServiceEndpointEncoder(), getServiceEndpointDecoder());
}
function getServiceEndpointTypeEncoder() {
  return getEnumEncoder(ServiceEndpointType);
}
function getServiceEndpointTypeDecoder() {
  return getEnumDecoder(ServiceEndpointType);
}
function getServiceEndpointTypeCodec() {
  return combineCodec2(getServiceEndpointTypeEncoder(), getServiceEndpointTypeDecoder());
}
function getSessionConstraintsEncoder() {
  return getStructEncoder([
    ["maxSessionDuration", getI64Encoder()],
    ["idleTimeout", getI64Encoder()],
    ["reauthInterval", getI64Encoder()],
    ["mfaRequired", getBooleanEncoder()],
    ["deviceFingerprinting", getBooleanEncoder()],
    ["sessionEncryption", getBooleanEncoder()]
  ]);
}
function getSessionConstraintsDecoder() {
  return getStructDecoder([
    ["maxSessionDuration", getI64Decoder()],
    ["idleTimeout", getI64Decoder()],
    ["reauthInterval", getI64Decoder()],
    ["mfaRequired", getBooleanDecoder()],
    ["deviceFingerprinting", getBooleanDecoder()],
    ["sessionEncryption", getBooleanDecoder()]
  ]);
}
function getSessionConstraintsCodec() {
  return combineCodec2(getSessionConstraintsEncoder(), getSessionConstraintsDecoder());
}
function getSessionPoliciesEncoder() {
  return getStructEncoder([
    ["maxSessionDuration", getI64Encoder()],
    ["idleTimeout", getI64Encoder()],
    ["concurrentSessions", getU8Encoder()]
  ]);
}
function getSessionPoliciesDecoder() {
  return getStructDecoder([
    ["maxSessionDuration", getI64Decoder()],
    ["idleTimeout", getI64Decoder()],
    ["concurrentSessions", getU8Decoder()]
  ]);
}
function getSessionPoliciesCodec() {
  return combineCodec2(getSessionPoliciesEncoder(), getSessionPoliciesDecoder());
}
function getSlashReasonEncoder() {
  return getEnumEncoder(SlashReason);
}
function getSlashReasonDecoder() {
  return getEnumDecoder(SlashReason);
}
function getSlashReasonCodec() {
  return combineCodec2(getSlashReasonEncoder(), getSlashReasonDecoder());
}
function getSodConstraintEncoder() {
  return getStructEncoder([
    ["name", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    [
      "conflictingRoles",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    ["constraintType", getSodConstraintTypeEncoder()],
    ["enforcementLevel", getEnforcementLevelEncoder()],
    [
      "exceptionProcedures",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ]
  ]);
}
function getSodConstraintDecoder() {
  return getStructDecoder([
    ["name", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    [
      "conflictingRoles",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    ["constraintType", getSodConstraintTypeDecoder()],
    ["enforcementLevel", getEnforcementLevelDecoder()],
    [
      "exceptionProcedures",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ]
  ]);
}
function getSodConstraintCodec() {
  return combineCodec2(getSodConstraintEncoder(), getSodConstraintDecoder());
}
function getSodConstraintTypeEncoder() {
  return getEnumEncoder(SodConstraintType);
}
function getSodConstraintTypeDecoder() {
  return getEnumDecoder(SodConstraintType);
}
function getSodConstraintTypeCodec() {
  return combineCodec2(getSodConstraintTypeEncoder(), getSodConstraintTypeDecoder());
}
function getSourceReputationUpdatedEventEncoder() {
  return getStructEncoder([
    ["agent", getAddressEncoder2()],
    ["sourceName", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["sourceScore", getU16Encoder()],
    ["weightedAggregateScore", getU64Encoder()],
    ["hasConflict", getBooleanEncoder()],
    ["totalSources", getU32Encoder()],
    ["timestamp", getI64Encoder()]
  ]);
}
function getSourceReputationUpdatedEventDecoder() {
  return getStructDecoder([
    ["agent", getAddressDecoder2()],
    ["sourceName", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["sourceScore", getU16Decoder()],
    ["weightedAggregateScore", getU64Decoder()],
    ["hasConflict", getBooleanDecoder()],
    ["totalSources", getU32Decoder()],
    ["timestamp", getI64Decoder()]
  ]);
}
function getSourceReputationUpdatedEventCodec() {
  return combineCodec2(getSourceReputationUpdatedEventEncoder(), getSourceReputationUpdatedEventDecoder());
}
function getSourceScoreEncoder() {
  return getStructEncoder([
    ["sourceName", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["score", getU16Encoder()],
    ["weight", getU16Encoder()],
    ["dataPoints", getU32Encoder()],
    ["reliability", getU16Encoder()],
    ["lastUpdated", getI64Encoder()]
  ]);
}
function getSourceScoreDecoder() {
  return getStructDecoder([
    ["sourceName", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["score", getU16Decoder()],
    ["weight", getU16Decoder()],
    ["dataPoints", getU32Decoder()],
    ["reliability", getU16Decoder()],
    ["lastUpdated", getI64Decoder()]
  ]);
}
function getSourceScoreCodec() {
  return combineCodec2(getSourceScoreEncoder(), getSourceScoreDecoder());
}
function getStepUpTriggerEncoder() {
  return getEnumEncoder(StepUpTrigger);
}
function getStepUpTriggerDecoder() {
  return getEnumDecoder(StepUpTrigger);
}
function getStepUpTriggerCodec() {
  return combineCodec2(getStepUpTriggerEncoder(), getStepUpTriggerDecoder());
}
function getSubmissionDetailsEncoder() {
  return getStructEncoder([
    ["submittedAt", getI64Encoder()],
    ["regulatoryBody", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    [
      "submissionReference",
      addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())
    ],
    ["acknowledged", getBooleanEncoder()],
    ["acknowledgedAt", getOptionEncoder(getI64Encoder())],
    [
      "regulatoryResponse",
      getOptionEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ]
  ]);
}
function getSubmissionDetailsDecoder() {
  return getStructDecoder([
    ["submittedAt", getI64Decoder()],
    ["regulatoryBody", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    [
      "submissionReference",
      addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())
    ],
    ["acknowledged", getBooleanDecoder()],
    ["acknowledgedAt", getOptionDecoder(getI64Decoder())],
    [
      "regulatoryResponse",
      getOptionDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ]
  ]);
}
function getSubmissionDetailsCodec() {
  return combineCodec2(getSubmissionDetailsEncoder(), getSubmissionDetailsDecoder());
}
function getTagDecayAppliedEventEncoder() {
  return getStructEncoder([
    ["agent", getAddressEncoder2()],
    ["tagsRemoved", getU32Encoder()],
    ["remainingTags", getU32Encoder()],
    ["timestamp", getI64Encoder()]
  ]);
}
function getTagDecayAppliedEventDecoder() {
  return getStructDecoder([
    ["agent", getAddressDecoder2()],
    ["tagsRemoved", getU32Decoder()],
    ["remainingTags", getU32Decoder()],
    ["timestamp", getI64Decoder()]
  ]);
}
function getTagDecayAppliedEventCodec() {
  return combineCodec2(getTagDecayAppliedEventEncoder(), getTagDecayAppliedEventDecoder());
}
function getTagScoreEncoder() {
  return getStructEncoder([
    ["tagName", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["confidence", getU16Encoder()],
    ["evidenceCount", getU32Encoder()],
    ["lastUpdated", getI64Encoder()]
  ]);
}
function getTagScoreDecoder() {
  return getStructDecoder([
    ["tagName", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["confidence", getU16Decoder()],
    ["evidenceCount", getU32Decoder()],
    ["lastUpdated", getI64Decoder()]
  ]);
}
function getTagScoreCodec() {
  return combineCodec2(getTagScoreEncoder(), getTagScoreDecoder());
}
function getTierUpdatedEventEncoder() {
  return getStructEncoder([
    ["agent", getAddressEncoder2()],
    ["oldTier", getAccessTierEncoder()],
    ["newTier", getAccessTierEncoder()],
    ["totalStaked", getU64Encoder()],
    ["dailyApiCalls", getU32Encoder()],
    ["votingPower", getU64Encoder()]
  ]);
}
function getTierUpdatedEventDecoder() {
  return getStructDecoder([
    ["agent", getAddressDecoder2()],
    ["oldTier", getAccessTierDecoder()],
    ["newTier", getAccessTierDecoder()],
    ["totalStaked", getU64Decoder()],
    ["dailyApiCalls", getU32Decoder()],
    ["votingPower", getU64Decoder()]
  ]);
}
function getTierUpdatedEventCodec() {
  return combineCodec2(getTierUpdatedEventEncoder(), getTierUpdatedEventDecoder());
}
function getTimeConstraintsEncoder() {
  return getStructEncoder([
    ["allowedHours", addEncoderSizePrefix(getBytesEncoder(), getU32Encoder())],
    ["allowedDays", addEncoderSizePrefix(getBytesEncoder(), getU32Encoder())],
    ["timezone", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["maxSessionDuration", getOptionEncoder(getI64Encoder())],
    ["expiresAt", getOptionEncoder(getI64Encoder())],
    ["reactivationPeriod", getOptionEncoder(getI64Encoder())]
  ]);
}
function getTimeConstraintsDecoder() {
  return getStructDecoder([
    ["allowedHours", addDecoderSizePrefix(getBytesDecoder(), getU32Decoder())],
    ["allowedDays", addDecoderSizePrefix(getBytesDecoder(), getU32Decoder())],
    ["timezone", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["maxSessionDuration", getOptionDecoder(getI64Decoder())],
    ["expiresAt", getOptionDecoder(getI64Decoder())],
    ["reactivationPeriod", getOptionDecoder(getI64Decoder())]
  ]);
}
function getTimeConstraintsCodec() {
  return combineCodec2(getTimeConstraintsEncoder(), getTimeConstraintsDecoder());
}
function getTimeLockEncoder() {
  return getStructEncoder([
    ["duration", getI64Encoder()],
    ["lockedAt", getI64Encoder()],
    ["unlocksAt", getI64Encoder()],
    ["earlyUnlockConditions", getArrayEncoder(getExecutionConditionEncoder())],
    ["lockType", getTimeLockTypeEncoder()],
    ["cancellable", getBooleanEncoder()]
  ]);
}
function getTimeLockDecoder() {
  return getStructDecoder([
    ["duration", getI64Decoder()],
    ["lockedAt", getI64Decoder()],
    ["unlocksAt", getI64Decoder()],
    ["earlyUnlockConditions", getArrayDecoder(getExecutionConditionDecoder())],
    ["lockType", getTimeLockTypeDecoder()],
    ["cancellable", getBooleanDecoder()]
  ]);
}
function getTimeLockCodec() {
  return combineCodec2(getTimeLockEncoder(), getTimeLockDecoder());
}
function getTimeLockTypeEncoder() {
  return getEnumEncoder(TimeLockType);
}
function getTimeLockTypeDecoder() {
  return getEnumDecoder(TimeLockType);
}
function getTimeLockTypeCodec() {
  return combineCodec2(getTimeLockTypeEncoder(), getTimeLockTypeDecoder());
}
function getTransactionPriorityEncoder() {
  return getEnumEncoder(TransactionPriority);
}
function getTransactionPriorityDecoder() {
  return getEnumDecoder(TransactionPriority);
}
function getTransactionPriorityCodec() {
  return combineCodec2(getTransactionPriorityEncoder(), getTransactionPriorityDecoder());
}
function getTransactionStatusEncoder() {
  return getEnumEncoder(TransactionStatus);
}
function getTransactionStatusDecoder() {
  return getEnumDecoder(TransactionStatus);
}
function getTransactionStatusCodec() {
  return combineCodec2(getTransactionStatusEncoder(), getTransactionStatusDecoder());
}
function getTransactionTypeEncoder() {
  return getEnumEncoder(TransactionType);
}
function getTransactionTypeDecoder() {
  return getEnumDecoder(TransactionType);
}
function getTransactionTypeCodec() {
  return combineCodec2(getTransactionTypeEncoder(), getTransactionTypeDecoder());
}
function getTrendDirectionEncoder() {
  return getEnumEncoder(TrendDirection);
}
function getTrendDirectionDecoder() {
  return getEnumDecoder(TrendDirection);
}
function getTrendDirectionCodec() {
  return combineCodec2(getTrendDirectionEncoder(), getTrendDirectionDecoder());
}
function getUnlockMethodEncoder() {
  return getEnumEncoder(UnlockMethod);
}
function getUnlockMethodDecoder() {
  return getEnumDecoder(UnlockMethod);
}
function getUnlockMethodCodec() {
  return combineCodec2(getUnlockMethodEncoder(), getUnlockMethodDecoder());
}
function getValueTypeEncoder() {
  return getEnumEncoder(ValueType);
}
function getValueTypeDecoder() {
  return getEnumDecoder(ValueType);
}
function getValueTypeCodec() {
  return combineCodec2(getValueTypeEncoder(), getValueTypeDecoder());
}
function getVerificationMethodEncoder() {
  return getStructEncoder([
    ["id", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["methodType", getVerificationMethodTypeEncoder()],
    ["controller", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    [
      "publicKeyMultibase",
      addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())
    ],
    ["relationships", getArrayEncoder(getVerificationRelationshipEncoder())],
    ["createdAt", getI64Encoder()],
    ["revoked", getBooleanEncoder()]
  ]);
}
function getVerificationMethodDecoder() {
  return getStructDecoder([
    ["id", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["methodType", getVerificationMethodTypeDecoder()],
    ["controller", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    [
      "publicKeyMultibase",
      addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())
    ],
    ["relationships", getArrayDecoder(getVerificationRelationshipDecoder())],
    ["createdAt", getI64Decoder()],
    ["revoked", getBooleanDecoder()]
  ]);
}
function getVerificationMethodCodec() {
  return combineCodec2(getVerificationMethodEncoder(), getVerificationMethodDecoder());
}
function getVerificationMethodTypeEncoder() {
  return getEnumEncoder(VerificationMethodType);
}
function getVerificationMethodTypeDecoder() {
  return getEnumDecoder(VerificationMethodType);
}
function getVerificationMethodTypeCodec() {
  return combineCodec2(getVerificationMethodTypeEncoder(), getVerificationMethodTypeDecoder());
}
function getVerificationRelationshipEncoder() {
  return getEnumEncoder(VerificationRelationship);
}
function getVerificationRelationshipDecoder() {
  return getEnumDecoder(VerificationRelationship);
}
function getVerificationRelationshipCodec() {
  return combineCodec2(getVerificationRelationshipEncoder(), getVerificationRelationshipDecoder());
}
function getViolationSeverityEncoder() {
  return getEnumEncoder(ViolationSeverity);
}
function getViolationSeverityDecoder() {
  return getEnumDecoder(ViolationSeverity);
}
function getViolationSeverityCodec() {
  return combineCodec2(getViolationSeverityEncoder(), getViolationSeverityDecoder());
}
function getVoteEncoder() {
  return getStructEncoder([
    ["voter", getAddressEncoder2()],
    ["choice", getVoteChoiceEncoder()],
    ["votingPower", getU64Encoder()],
    ["votedAt", getI64Encoder()],
    [
      "reasoning",
      getOptionEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    ["delegationInfo", getOptionEncoder(getDelegationInfoEncoder())]
  ]);
}
function getVoteDecoder() {
  return getStructDecoder([
    ["voter", getAddressDecoder2()],
    ["choice", getVoteChoiceDecoder()],
    ["votingPower", getU64Decoder()],
    ["votedAt", getI64Decoder()],
    [
      "reasoning",
      getOptionDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    ["delegationInfo", getOptionDecoder(getDelegationInfoDecoder())]
  ]);
}
function getVoteCodec() {
  return combineCodec2(getVoteEncoder(), getVoteDecoder());
}
function getVoteChoiceEncoder() {
  return getEnumEncoder(VoteChoice);
}
function getVoteChoiceDecoder() {
  return getEnumDecoder(VoteChoice);
}
function getVoteChoiceCodec() {
  return combineCodec2(getVoteChoiceEncoder(), getVoteChoiceDecoder());
}
function getVotingResultsEncoder() {
  return getStructEncoder([
    ["votesFor", getU64Encoder()],
    ["votesAgainst", getU64Encoder()],
    ["votesAbstain", getU64Encoder()],
    ["totalVotingPower", getU64Encoder()],
    ["participationRate", getU8Encoder()],
    ["individualVotes", getArrayEncoder(getVoteEncoder())],
    ["weightedVoting", getBooleanEncoder()],
    ["quorumReached", getBooleanEncoder()],
    ["approvalThresholdMet", getBooleanEncoder()]
  ]);
}
function getVotingResultsDecoder() {
  return getStructDecoder([
    ["votesFor", getU64Decoder()],
    ["votesAgainst", getU64Decoder()],
    ["votesAbstain", getU64Decoder()],
    ["totalVotingPower", getU64Decoder()],
    ["participationRate", getU8Decoder()],
    ["individualVotes", getArrayDecoder(getVoteDecoder())],
    ["weightedVoting", getBooleanDecoder()],
    ["quorumReached", getBooleanDecoder()],
    ["approvalThresholdMet", getBooleanDecoder()]
  ]);
}
function getVotingResultsCodec() {
  return combineCodec2(getVotingResultsEncoder(), getVotingResultsDecoder());
}
function getAgentDiscriminatorBytes() {
  return fixEncoderSize2(getBytesEncoder(), 8).encode(AGENT_DISCRIMINATOR);
}
function getAgentEncoder() {
  return transformEncoder2(getStructEncoder([
    ["discriminator", fixEncoderSize2(getBytesEncoder(), 8)],
    ["owner", getOptionEncoder(getAddressEncoder2())],
    ["status", getAgentStatusEncoder()],
    ["agentId", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    [
      "firstTxSignature",
      addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())
    ],
    ["firstSeenTimestamp", getI64Encoder()],
    [
      "discoverySource",
      addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())
    ],
    ["claimedAt", getOptionEncoder(getI64Encoder())],
    ["agentType", getU8Encoder()],
    ["name", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["description", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    [
      "capabilities",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    ["pricingModel", getPricingModelEncoder()],
    ["reputationScore", getU32Encoder()],
    ["totalJobsCompleted", getU32Encoder()],
    ["totalEarnings", getU64Encoder()],
    ["isActive", getBooleanEncoder()],
    ["createdAt", getI64Encoder()],
    ["updatedAt", getI64Encoder()],
    ["originalPrice", getU64Encoder()],
    ["genomeHash", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["isReplicable", getBooleanEncoder()],
    ["replicationFee", getU64Encoder()],
    [
      "serviceEndpoint",
      addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())
    ],
    ["isVerified", getBooleanEncoder()],
    ["verificationTimestamp", getI64Encoder()],
    ["metadataUri", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    [
      "frameworkOrigin",
      addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())
    ],
    ["supportedTokens", getArrayEncoder(getAddressEncoder2())],
    ["cnftMint", getOptionEncoder(getAddressEncoder2())],
    ["merkleTree", getOptionEncoder(getAddressEncoder2())],
    ["supportsA2a", getBooleanEncoder()],
    ["transferHook", getOptionEncoder(getAddressEncoder2())],
    ["parentAgent", getOptionEncoder(getAddressEncoder2())],
    ["generation", getU32Encoder()],
    ["x402Enabled", getBooleanEncoder()],
    ["x402PaymentAddress", getAddressEncoder2()],
    ["x402AcceptedTokens", getArrayEncoder(getAddressEncoder2())],
    ["x402PricePerCall", getU64Encoder()],
    [
      "x402ServiceEndpoint",
      addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())
    ],
    ["x402TotalPayments", getU64Encoder()],
    ["x402TotalCalls", getU64Encoder()],
    ["lastPaymentTimestamp", getI64Encoder()],
    ["externalIdentifiers", getArrayEncoder(getExternalIdentifierEncoder())],
    ["ghostScore", getU64Encoder()],
    [
      "reputationComponents",
      getArrayEncoder(getReputationComponentEncoder())
    ],
    ["didAddress", getOptionEncoder(getAddressEncoder2())],
    ["credentials", getArrayEncoder(getAddressEncoder2())],
    ["apiSpecUri", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["apiVersion", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["bump", getU8Encoder()]
  ]), (value) => ({ ...value, discriminator: AGENT_DISCRIMINATOR }));
}
function getAgentDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize2(getBytesDecoder(), 8)],
    ["owner", getOptionDecoder(getAddressDecoder2())],
    ["status", getAgentStatusDecoder()],
    ["agentId", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    [
      "firstTxSignature",
      addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())
    ],
    ["firstSeenTimestamp", getI64Decoder()],
    [
      "discoverySource",
      addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())
    ],
    ["claimedAt", getOptionDecoder(getI64Decoder())],
    ["agentType", getU8Decoder()],
    ["name", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["description", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    [
      "capabilities",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    ["pricingModel", getPricingModelDecoder()],
    ["reputationScore", getU32Decoder()],
    ["totalJobsCompleted", getU32Decoder()],
    ["totalEarnings", getU64Decoder()],
    ["isActive", getBooleanDecoder()],
    ["createdAt", getI64Decoder()],
    ["updatedAt", getI64Decoder()],
    ["originalPrice", getU64Decoder()],
    ["genomeHash", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["isReplicable", getBooleanDecoder()],
    ["replicationFee", getU64Decoder()],
    [
      "serviceEndpoint",
      addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())
    ],
    ["isVerified", getBooleanDecoder()],
    ["verificationTimestamp", getI64Decoder()],
    ["metadataUri", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    [
      "frameworkOrigin",
      addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())
    ],
    ["supportedTokens", getArrayDecoder(getAddressDecoder2())],
    ["cnftMint", getOptionDecoder(getAddressDecoder2())],
    ["merkleTree", getOptionDecoder(getAddressDecoder2())],
    ["supportsA2a", getBooleanDecoder()],
    ["transferHook", getOptionDecoder(getAddressDecoder2())],
    ["parentAgent", getOptionDecoder(getAddressDecoder2())],
    ["generation", getU32Decoder()],
    ["x402Enabled", getBooleanDecoder()],
    ["x402PaymentAddress", getAddressDecoder2()],
    ["x402AcceptedTokens", getArrayDecoder(getAddressDecoder2())],
    ["x402PricePerCall", getU64Decoder()],
    [
      "x402ServiceEndpoint",
      addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())
    ],
    ["x402TotalPayments", getU64Decoder()],
    ["x402TotalCalls", getU64Decoder()],
    ["lastPaymentTimestamp", getI64Decoder()],
    ["externalIdentifiers", getArrayDecoder(getExternalIdentifierDecoder())],
    ["ghostScore", getU64Decoder()],
    ["reputationComponents", getArrayDecoder(getReputationComponentDecoder())],
    ["didAddress", getOptionDecoder(getAddressDecoder2())],
    ["credentials", getArrayDecoder(getAddressDecoder2())],
    ["apiSpecUri", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["apiVersion", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["bump", getU8Decoder()]
  ]);
}
function getAgentCodec() {
  return combineCodec2(getAgentEncoder(), getAgentDecoder());
}
function decodeAgent(encodedAccount) {
  return decodeAccount(encodedAccount, getAgentDecoder());
}
async function fetchAgent(rpc2, address3, config) {
  const maybeAccount = await fetchMaybeAgent(rpc2, address3, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeAgent(rpc2, address3, config) {
  const maybeAccount = await fetchEncodedAccount(rpc2, address3, config);
  return decodeAgent(maybeAccount);
}
async function fetchAllAgent(rpc2, addresses2, config) {
  const maybeAccounts = await fetchAllMaybeAgent(rpc2, addresses2, config);
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeAgent(rpc2, addresses2, config) {
  const maybeAccounts = await fetchEncodedAccounts(rpc2, addresses2, config);
  return maybeAccounts.map((maybeAccount) => decodeAgent(maybeAccount));
}
var AccessTier, ActivationRequirementType, AgentStatus, AuditAction, AuthenticationLevel, AuthenticationMethod, BackupFrequency, BiometricStorageMethod, BiometricType, ConditionType, ConstraintOperator, CredentialKind, CredentialStatus, CrossChainStatus, DataAccessLevel, DegradationHandling, EnforcementLevel, EscrowStatus, MultisigType, NotificationMethod, NotificationPriority, NotificationTargetType, NotificationTiming, PermissionConstraintType, PolicyStatus, PolicyType, PricingModel, ProposalStatus, ProposalType, QuorumMethod, ReentrancyState, ReportingFrequency, ReportStatus, ReportType, ReputationSourceType, RiskCategory, RiskLevel, RoleStatus, RoleType, RuleEffect, ScopeInheritance, ScopeType, SecurityEventType, ServiceEndpointType, SlashReason, SodConstraintType, StepUpTrigger, TimeLockType, TransactionPriority, TransactionStatus, TransactionType, TrendDirection, UnlockMethod, ValueType, VerificationMethodType, VerificationRelationship, ViolationSeverity, VoteChoice, AGENT_DISCRIMINATOR;
var init_chunk_5QZVFUXB = __esm(() => {
  init_index_node40();
  AccessTier = /* @__PURE__ */ ((AccessTier2) => {
    AccessTier2[AccessTier2["None"] = 0] = "None";
    AccessTier2[AccessTier2["Basic"] = 1] = "Basic";
    AccessTier2[AccessTier2["Verified"] = 2] = "Verified";
    AccessTier2[AccessTier2["Pro"] = 3] = "Pro";
    AccessTier2[AccessTier2["Whale"] = 4] = "Whale";
    return AccessTier2;
  })(AccessTier || {});
  ActivationRequirementType = /* @__PURE__ */ ((ActivationRequirementType2) => {
    ActivationRequirementType2[ActivationRequirementType2["ManagerApproval"] = 0] = "ManagerApproval";
    ActivationRequirementType2[ActivationRequirementType2["PeerReview"] = 1] = "PeerReview";
    ActivationRequirementType2[ActivationRequirementType2["SecurityClearance"] = 2] = "SecurityClearance";
    ActivationRequirementType2[ActivationRequirementType2["BackgroundCheck"] = 3] = "BackgroundCheck";
    ActivationRequirementType2[ActivationRequirementType2["TrainingCompletion"] = 4] = "TrainingCompletion";
    ActivationRequirementType2[ActivationRequirementType2["CertificationRequired"] = 5] = "CertificationRequired";
    ActivationRequirementType2[ActivationRequirementType2["BusinessJustification"] = 6] = "BusinessJustification";
    ActivationRequirementType2[ActivationRequirementType2["TechnicalAssessment"] = 7] = "TechnicalAssessment";
    return ActivationRequirementType2;
  })(ActivationRequirementType || {});
  AgentStatus = /* @__PURE__ */ ((AgentStatus2) => {
    AgentStatus2[AgentStatus2["Unregistered"] = 0] = "Unregistered";
    AgentStatus2[AgentStatus2["Registered"] = 1] = "Registered";
    AgentStatus2[AgentStatus2["Claimed"] = 2] = "Claimed";
    AgentStatus2[AgentStatus2["Verified"] = 3] = "Verified";
    return AgentStatus2;
  })(AgentStatus || {});
  AuditAction = /* @__PURE__ */ ((AuditAction2) => {
    AuditAction2[AuditAction2["AgentRegistered"] = 0] = "AgentRegistered";
    AuditAction2[AuditAction2["AgentUpdated"] = 1] = "AgentUpdated";
    AuditAction2[AuditAction2["AgentDeactivated"] = 2] = "AgentDeactivated";
    AuditAction2[AuditAction2["AgentVerified"] = 3] = "AgentVerified";
    AuditAction2[AuditAction2["PaymentProcessed"] = 4] = "PaymentProcessed";
    AuditAction2[AuditAction2["EscrowCreated"] = 5] = "EscrowCreated";
    AuditAction2[AuditAction2["EscrowReleased"] = 6] = "EscrowReleased";
    AuditAction2[AuditAction2["FundsWithdrawn"] = 7] = "FundsWithdrawn";
    AuditAction2[AuditAction2["ProposalCreated"] = 8] = "ProposalCreated";
    AuditAction2[AuditAction2["VoteCast"] = 9] = "VoteCast";
    AuditAction2[AuditAction2["ProposalExecuted"] = 10] = "ProposalExecuted";
    AuditAction2[AuditAction2["GovernanceUpdated"] = 11] = "GovernanceUpdated";
    AuditAction2[AuditAction2["AccessGranted"] = 12] = "AccessGranted";
    AuditAction2[AuditAction2["AccessRevoked"] = 13] = "AccessRevoked";
    AuditAction2[AuditAction2["SecurityPolicyUpdated"] = 14] = "SecurityPolicyUpdated";
    AuditAction2[AuditAction2["SuspiciousActivity"] = 15] = "SuspiciousActivity";
    AuditAction2[AuditAction2["ComplianceReportGenerated"] = 16] = "ComplianceReportGenerated";
    AuditAction2[AuditAction2["RegulatorySubmission"] = 17] = "RegulatorySubmission";
    AuditAction2[AuditAction2["AuditRequested"] = 18] = "AuditRequested";
    AuditAction2[AuditAction2["ViolationDetected"] = 19] = "ViolationDetected";
    AuditAction2[AuditAction2["SystemConfigUpdated"] = 20] = "SystemConfigUpdated";
    AuditAction2[AuditAction2["EmergencyAction"] = 21] = "EmergencyAction";
    AuditAction2[AuditAction2["MaintenancePerformed"] = 22] = "MaintenancePerformed";
    AuditAction2[AuditAction2["WorkOrderCreated"] = 23] = "WorkOrderCreated";
    AuditAction2[AuditAction2["WorkOrderCompleted"] = 24] = "WorkOrderCompleted";
    AuditAction2[AuditAction2["DisputeRaised"] = 25] = "DisputeRaised";
    AuditAction2[AuditAction2["DisputeResolved"] = 26] = "DisputeResolved";
    AuditAction2[AuditAction2["MultisigCreated"] = 27] = "MultisigCreated";
    AuditAction2[AuditAction2["MultisigSigned"] = 28] = "MultisigSigned";
    AuditAction2[AuditAction2["MultisigExecuted"] = 29] = "MultisigExecuted";
    AuditAction2[AuditAction2["RiskAssessmentPerformed"] = 30] = "RiskAssessmentPerformed";
    AuditAction2[AuditAction2["RiskThresholdExceeded"] = 31] = "RiskThresholdExceeded";
    AuditAction2[AuditAction2["RiskMitigationApplied"] = 32] = "RiskMitigationApplied";
    return AuditAction2;
  })(AuditAction || {});
  AuthenticationLevel = /* @__PURE__ */ ((AuthenticationLevel2) => {
    AuthenticationLevel2[AuthenticationLevel2["Low"] = 0] = "Low";
    AuthenticationLevel2[AuthenticationLevel2["Medium"] = 1] = "Medium";
    AuthenticationLevel2[AuthenticationLevel2["High"] = 2] = "High";
    AuthenticationLevel2[AuthenticationLevel2["VeryHigh"] = 3] = "VeryHigh";
    return AuthenticationLevel2;
  })(AuthenticationLevel || {});
  AuthenticationMethod = /* @__PURE__ */ ((AuthenticationMethod2) => {
    AuthenticationMethod2[AuthenticationMethod2["Password"] = 0] = "Password";
    AuthenticationMethod2[AuthenticationMethod2["DigitalSignature"] = 1] = "DigitalSignature";
    AuthenticationMethod2[AuthenticationMethod2["Biometric"] = 2] = "Biometric";
    AuthenticationMethod2[AuthenticationMethod2["Token"] = 3] = "Token";
    AuthenticationMethod2[AuthenticationMethod2["Certificate"] = 4] = "Certificate";
    AuthenticationMethod2[AuthenticationMethod2["Sms"] = 5] = "Sms";
    AuthenticationMethod2[AuthenticationMethod2["Email"] = 6] = "Email";
    AuthenticationMethod2[AuthenticationMethod2["App"] = 7] = "App";
    AuthenticationMethod2[AuthenticationMethod2["Hardware"] = 8] = "Hardware";
    return AuthenticationMethod2;
  })(AuthenticationMethod || {});
  BackupFrequency = /* @__PURE__ */ ((BackupFrequency2) => {
    BackupFrequency2[BackupFrequency2["Hourly"] = 0] = "Hourly";
    BackupFrequency2[BackupFrequency2["Daily"] = 1] = "Daily";
    BackupFrequency2[BackupFrequency2["Weekly"] = 2] = "Weekly";
    BackupFrequency2[BackupFrequency2["Monthly"] = 3] = "Monthly";
    return BackupFrequency2;
  })(BackupFrequency || {});
  BiometricStorageMethod = /* @__PURE__ */ ((BiometricStorageMethod2) => {
    BiometricStorageMethod2[BiometricStorageMethod2["OnDevice"] = 0] = "OnDevice";
    BiometricStorageMethod2[BiometricStorageMethod2["Encrypted"] = 1] = "Encrypted";
    BiometricStorageMethod2[BiometricStorageMethod2["Hashed"] = 2] = "Hashed";
    BiometricStorageMethod2[BiometricStorageMethod2["Distributed"] = 3] = "Distributed";
    BiometricStorageMethod2[BiometricStorageMethod2["None"] = 4] = "None";
    return BiometricStorageMethod2;
  })(BiometricStorageMethod || {});
  BiometricType = /* @__PURE__ */ ((BiometricType2) => {
    BiometricType2[BiometricType2["Fingerprint"] = 0] = "Fingerprint";
    BiometricType2[BiometricType2["FaceRecognition"] = 1] = "FaceRecognition";
    BiometricType2[BiometricType2["IrisRecognition"] = 2] = "IrisRecognition";
    BiometricType2[BiometricType2["VoiceRecognition"] = 3] = "VoiceRecognition";
    BiometricType2[BiometricType2["Signature"] = 4] = "Signature";
    BiometricType2[BiometricType2["Gait"] = 5] = "Gait";
    BiometricType2[BiometricType2["Behavioral"] = 6] = "Behavioral";
    return BiometricType2;
  })(BiometricType || {});
  ConditionType = /* @__PURE__ */ ((ConditionType2) => {
    ConditionType2[ConditionType2["TimeDelay"] = 0] = "TimeDelay";
    ConditionType2[ConditionType2["TokenBalance"] = 1] = "TokenBalance";
    ConditionType2[ConditionType2["PriceThreshold"] = 2] = "PriceThreshold";
    ConditionType2[ConditionType2["VoteCount"] = 3] = "VoteCount";
    ConditionType2[ConditionType2["ExternalOracle"] = 4] = "ExternalOracle";
    ConditionType2[ConditionType2["CustomLogic"] = 5] = "CustomLogic";
    return ConditionType2;
  })(ConditionType || {});
  ConstraintOperator = /* @__PURE__ */ ((ConstraintOperator2) => {
    ConstraintOperator2[ConstraintOperator2["Equals"] = 0] = "Equals";
    ConstraintOperator2[ConstraintOperator2["NotEquals"] = 1] = "NotEquals";
    ConstraintOperator2[ConstraintOperator2["GreaterThan"] = 2] = "GreaterThan";
    ConstraintOperator2[ConstraintOperator2["LessThan"] = 3] = "LessThan";
    ConstraintOperator2[ConstraintOperator2["GreaterThanOrEqual"] = 4] = "GreaterThanOrEqual";
    ConstraintOperator2[ConstraintOperator2["LessThanOrEqual"] = 5] = "LessThanOrEqual";
    ConstraintOperator2[ConstraintOperator2["Contains"] = 6] = "Contains";
    ConstraintOperator2[ConstraintOperator2["NotContains"] = 7] = "NotContains";
    ConstraintOperator2[ConstraintOperator2["In"] = 8] = "In";
    ConstraintOperator2[ConstraintOperator2["NotIn"] = 9] = "NotIn";
    ConstraintOperator2[ConstraintOperator2["Matches"] = 10] = "Matches";
    ConstraintOperator2[ConstraintOperator2["NotMatches"] = 11] = "NotMatches";
    return ConstraintOperator2;
  })(ConstraintOperator || {});
  CredentialKind = /* @__PURE__ */ ((CredentialKind2) => {
    CredentialKind2[CredentialKind2["AgentIdentity"] = 0] = "AgentIdentity";
    CredentialKind2[CredentialKind2["ReputationScore"] = 1] = "ReputationScore";
    CredentialKind2[CredentialKind2["JobCompletion"] = 2] = "JobCompletion";
    CredentialKind2[CredentialKind2["DelegatedSigner"] = 3] = "DelegatedSigner";
    CredentialKind2[CredentialKind2["Custom"] = 4] = "Custom";
    return CredentialKind2;
  })(CredentialKind || {});
  CredentialStatus = /* @__PURE__ */ ((CredentialStatus2) => {
    CredentialStatus2[CredentialStatus2["Pending"] = 0] = "Pending";
    CredentialStatus2[CredentialStatus2["Active"] = 1] = "Active";
    CredentialStatus2[CredentialStatus2["Revoked"] = 2] = "Revoked";
    CredentialStatus2[CredentialStatus2["Expired"] = 3] = "Expired";
    return CredentialStatus2;
  })(CredentialStatus || {});
  CrossChainStatus = /* @__PURE__ */ ((CrossChainStatus2) => {
    CrossChainStatus2[CrossChainStatus2["NotSynced"] = 0] = "NotSynced";
    CrossChainStatus2[CrossChainStatus2["SyncPending"] = 1] = "SyncPending";
    CrossChainStatus2[CrossChainStatus2["SyncedToCrossmint"] = 2] = "SyncedToCrossmint";
    CrossChainStatus2[CrossChainStatus2["SyncFailed"] = 3] = "SyncFailed";
    return CrossChainStatus2;
  })(CrossChainStatus || {});
  DataAccessLevel = /* @__PURE__ */ ((DataAccessLevel2) => {
    DataAccessLevel2[DataAccessLevel2["Public"] = 0] = "Public";
    DataAccessLevel2[DataAccessLevel2["Internal"] = 1] = "Internal";
    DataAccessLevel2[DataAccessLevel2["Confidential"] = 2] = "Confidential";
    DataAccessLevel2[DataAccessLevel2["Restricted"] = 3] = "Restricted";
    DataAccessLevel2[DataAccessLevel2["TopSecret"] = 4] = "TopSecret";
    return DataAccessLevel2;
  })(DataAccessLevel || {});
  DegradationHandling = /* @__PURE__ */ ((DegradationHandling2) => {
    DegradationHandling2[DegradationHandling2["RequireRefresh"] = 0] = "RequireRefresh";
    DegradationHandling2[DegradationHandling2["GradualDegradation"] = 1] = "GradualDegradation";
    DegradationHandling2[DegradationHandling2["ImmediateExpiry"] = 2] = "ImmediateExpiry";
    DegradationHandling2[DegradationHandling2["AdaptiveThreshold"] = 3] = "AdaptiveThreshold";
    return DegradationHandling2;
  })(DegradationHandling || {});
  EnforcementLevel = /* @__PURE__ */ ((EnforcementLevel2) => {
    EnforcementLevel2[EnforcementLevel2["Hard"] = 0] = "Hard";
    EnforcementLevel2[EnforcementLevel2["Soft"] = 1] = "Soft";
    EnforcementLevel2[EnforcementLevel2["Advisory"] = 2] = "Advisory";
    EnforcementLevel2[EnforcementLevel2["ExceptionBased"] = 3] = "ExceptionBased";
    return EnforcementLevel2;
  })(EnforcementLevel || {});
  EscrowStatus = /* @__PURE__ */ ((EscrowStatus2) => {
    EscrowStatus2[EscrowStatus2["Active"] = 0] = "Active";
    EscrowStatus2[EscrowStatus2["Completed"] = 1] = "Completed";
    EscrowStatus2[EscrowStatus2["Disputed"] = 2] = "Disputed";
    EscrowStatus2[EscrowStatus2["Cancelled"] = 3] = "Cancelled";
    return EscrowStatus2;
  })(EscrowStatus || {});
  MultisigType = /* @__PURE__ */ ((MultisigType2) => {
    MultisigType2[MultisigType2["Protocol"] = 0] = "Protocol";
    MultisigType2[MultisigType2["Dao"] = 1] = "Dao";
    MultisigType2[MultisigType2["Dispute"] = 2] = "Dispute";
    MultisigType2[MultisigType2["AgentConsortium"] = 3] = "AgentConsortium";
    MultisigType2[MultisigType2["AgentTreasury"] = 4] = "AgentTreasury";
    MultisigType2[MultisigType2["Custom"] = 5] = "Custom";
    return MultisigType2;
  })(MultisigType || {});
  NotificationMethod = /* @__PURE__ */ ((NotificationMethod2) => {
    NotificationMethod2[NotificationMethod2["OnChain"] = 0] = "OnChain";
    NotificationMethod2[NotificationMethod2["Email"] = 1] = "Email";
    NotificationMethod2[NotificationMethod2["Sms"] = 2] = "Sms";
    NotificationMethod2[NotificationMethod2["Push"] = 3] = "Push";
    NotificationMethod2[NotificationMethod2["InApp"] = 4] = "InApp";
    NotificationMethod2[NotificationMethod2["All"] = 5] = "All";
    return NotificationMethod2;
  })(NotificationMethod || {});
  NotificationPriority = /* @__PURE__ */ ((NotificationPriority2) => {
    NotificationPriority2[NotificationPriority2["Low"] = 0] = "Low";
    NotificationPriority2[NotificationPriority2["Medium"] = 1] = "Medium";
    NotificationPriority2[NotificationPriority2["High"] = 2] = "High";
    NotificationPriority2[NotificationPriority2["Critical"] = 3] = "Critical";
    NotificationPriority2[NotificationPriority2["Emergency"] = 4] = "Emergency";
    return NotificationPriority2;
  })(NotificationPriority || {});
  NotificationTargetType = /* @__PURE__ */ ((NotificationTargetType2) => {
    NotificationTargetType2[NotificationTargetType2["User"] = 0] = "User";
    NotificationTargetType2[NotificationTargetType2["Administrator"] = 1] = "Administrator";
    NotificationTargetType2[NotificationTargetType2["SecurityTeam"] = 2] = "SecurityTeam";
    NotificationTargetType2[NotificationTargetType2["ComplianceTeam"] = 3] = "ComplianceTeam";
    NotificationTargetType2[NotificationTargetType2["Manager"] = 4] = "Manager";
    NotificationTargetType2[NotificationTargetType2["AuditTeam"] = 5] = "AuditTeam";
    NotificationTargetType2[NotificationTargetType2["ExternalSystem"] = 6] = "ExternalSystem";
    return NotificationTargetType2;
  })(NotificationTargetType || {});
  NotificationTiming = /* @__PURE__ */ ((NotificationTiming2) => {
    NotificationTiming2[NotificationTiming2["Immediate"] = 0] = "Immediate";
    NotificationTiming2[NotificationTiming2["Delayed"] = 1] = "Delayed";
    NotificationTiming2[NotificationTiming2["Batched"] = 2] = "Batched";
    NotificationTiming2[NotificationTiming2["Scheduled"] = 3] = "Scheduled";
    return NotificationTiming2;
  })(NotificationTiming || {});
  PermissionConstraintType = /* @__PURE__ */ ((PermissionConstraintType2) => {
    PermissionConstraintType2[PermissionConstraintType2["Temporal"] = 0] = "Temporal";
    PermissionConstraintType2[PermissionConstraintType2["Contextual"] = 1] = "Contextual";
    PermissionConstraintType2[PermissionConstraintType2["Conditional"] = 2] = "Conditional";
    PermissionConstraintType2[PermissionConstraintType2["ResourceBased"] = 3] = "ResourceBased";
    PermissionConstraintType2[PermissionConstraintType2["AttributeBased"] = 4] = "AttributeBased";
    PermissionConstraintType2[PermissionConstraintType2["RiskBased"] = 5] = "RiskBased";
    return PermissionConstraintType2;
  })(PermissionConstraintType || {});
  PolicyStatus = /* @__PURE__ */ ((PolicyStatus2) => {
    PolicyStatus2[PolicyStatus2["Active"] = 0] = "Active";
    PolicyStatus2[PolicyStatus2["Inactive"] = 1] = "Inactive";
    PolicyStatus2[PolicyStatus2["Draft"] = 2] = "Draft";
    PolicyStatus2[PolicyStatus2["UnderReview"] = 3] = "UnderReview";
    PolicyStatus2[PolicyStatus2["Deprecated"] = 4] = "Deprecated";
    PolicyStatus2[PolicyStatus2["Suspended"] = 5] = "Suspended";
    return PolicyStatus2;
  })(PolicyStatus || {});
  PolicyType = /* @__PURE__ */ ((PolicyType2) => {
    PolicyType2[PolicyType2["Allow"] = 0] = "Allow";
    PolicyType2[PolicyType2["Deny"] = 1] = "Deny";
    PolicyType2[PolicyType2["Conditional"] = 2] = "Conditional";
    PolicyType2[PolicyType2["Delegated"] = 3] = "Delegated";
    PolicyType2[PolicyType2["Temporary"] = 4] = "Temporary";
    PolicyType2[PolicyType2["Emergency"] = 5] = "Emergency";
    return PolicyType2;
  })(PolicyType || {});
  PricingModel = /* @__PURE__ */ ((PricingModel2) => {
    PricingModel2[PricingModel2["Fixed"] = 0] = "Fixed";
    PricingModel2[PricingModel2["Hourly"] = 1] = "Hourly";
    PricingModel2[PricingModel2["PerTask"] = 2] = "PerTask";
    PricingModel2[PricingModel2["Subscription"] = 3] = "Subscription";
    PricingModel2[PricingModel2["Auction"] = 4] = "Auction";
    PricingModel2[PricingModel2["Dynamic"] = 5] = "Dynamic";
    PricingModel2[PricingModel2["RevenueShare"] = 6] = "RevenueShare";
    PricingModel2[PricingModel2["Tiered"] = 7] = "Tiered";
    return PricingModel2;
  })(PricingModel || {});
  ProposalStatus = /* @__PURE__ */ ((ProposalStatus2) => {
    ProposalStatus2[ProposalStatus2["Draft"] = 0] = "Draft";
    ProposalStatus2[ProposalStatus2["Active"] = 1] = "Active";
    ProposalStatus2[ProposalStatus2["Passed"] = 2] = "Passed";
    ProposalStatus2[ProposalStatus2["Failed"] = 3] = "Failed";
    ProposalStatus2[ProposalStatus2["Executed"] = 4] = "Executed";
    ProposalStatus2[ProposalStatus2["Cancelled"] = 5] = "Cancelled";
    ProposalStatus2[ProposalStatus2["Expired"] = 6] = "Expired";
    ProposalStatus2[ProposalStatus2["Queued"] = 7] = "Queued";
    return ProposalStatus2;
  })(ProposalStatus || {});
  ProposalType = /* @__PURE__ */ ((ProposalType2) => {
    ProposalType2[ProposalType2["ParameterUpdate"] = 0] = "ParameterUpdate";
    ProposalType2[ProposalType2["ProtocolUpgrade"] = 1] = "ProtocolUpgrade";
    ProposalType2[ProposalType2["TreasuryOperation"] = 2] = "TreasuryOperation";
    ProposalType2[ProposalType2["FeeUpdate"] = 3] = "FeeUpdate";
    ProposalType2[ProposalType2["SecurityUpdate"] = 4] = "SecurityUpdate";
    ProposalType2[ProposalType2["GovernanceUpdate"] = 5] = "GovernanceUpdate";
    ProposalType2[ProposalType2["EmergencyAction"] = 6] = "EmergencyAction";
    ProposalType2[ProposalType2["Custom"] = 7] = "Custom";
    return ProposalType2;
  })(ProposalType || {});
  QuorumMethod = /* @__PURE__ */ ((QuorumMethod2) => {
    QuorumMethod2[QuorumMethod2["Absolute"] = 0] = "Absolute";
    QuorumMethod2[QuorumMethod2["Relative"] = 1] = "Relative";
    QuorumMethod2[QuorumMethod2["Weighted"] = 2] = "Weighted";
    QuorumMethod2[QuorumMethod2["Dynamic"] = 3] = "Dynamic";
    return QuorumMethod2;
  })(QuorumMethod || {});
  ReentrancyState = /* @__PURE__ */ ((ReentrancyState2) => {
    ReentrancyState2[ReentrancyState2["Unlocked"] = 0] = "Unlocked";
    ReentrancyState2[ReentrancyState2["Locked"] = 1] = "Locked";
    return ReentrancyState2;
  })(ReentrancyState || {});
  ReportingFrequency = /* @__PURE__ */ ((ReportingFrequency2) => {
    ReportingFrequency2[ReportingFrequency2["Daily"] = 0] = "Daily";
    ReportingFrequency2[ReportingFrequency2["Weekly"] = 1] = "Weekly";
    ReportingFrequency2[ReportingFrequency2["Monthly"] = 2] = "Monthly";
    ReportingFrequency2[ReportingFrequency2["Quarterly"] = 3] = "Quarterly";
    ReportingFrequency2[ReportingFrequency2["Annually"] = 4] = "Annually";
    ReportingFrequency2[ReportingFrequency2["OnDemand"] = 5] = "OnDemand";
    return ReportingFrequency2;
  })(ReportingFrequency || {});
  ReportStatus = /* @__PURE__ */ ((ReportStatus2) => {
    ReportStatus2[ReportStatus2["Draft"] = 0] = "Draft";
    ReportStatus2[ReportStatus2["Generated"] = 1] = "Generated";
    ReportStatus2[ReportStatus2["Reviewed"] = 2] = "Reviewed";
    ReportStatus2[ReportStatus2["Approved"] = 3] = "Approved";
    ReportStatus2[ReportStatus2["Submitted"] = 4] = "Submitted";
    ReportStatus2[ReportStatus2["Acknowledged"] = 5] = "Acknowledged";
    ReportStatus2[ReportStatus2["Rejected"] = 6] = "Rejected";
    return ReportStatus2;
  })(ReportStatus || {});
  ReportType = /* @__PURE__ */ ((ReportType2) => {
    ReportType2[ReportType2["FinancialTransactions"] = 0] = "FinancialTransactions";
    ReportType2[ReportType2["SuspiciousActivity"] = 1] = "SuspiciousActivity";
    ReportType2[ReportType2["RegulatoryCompliance"] = 2] = "RegulatoryCompliance";
    ReportType2[ReportType2["SecurityIncidents"] = 3] = "SecurityIncidents";
    ReportType2[ReportType2["AuditSummary"] = 4] = "AuditSummary";
    ReportType2[ReportType2["RiskAssessment"] = 5] = "RiskAssessment";
    ReportType2[ReportType2["GovernanceActivity"] = 6] = "GovernanceActivity";
    ReportType2[ReportType2["DataPrivacyCompliance"] = 7] = "DataPrivacyCompliance";
    return ReportType2;
  })(ReportType || {});
  ReputationSourceType = /* @__PURE__ */ ((ReputationSourceType2) => {
    ReputationSourceType2[ReputationSourceType2["AccountAge"] = 0] = "AccountAge";
    ReputationSourceType2[ReputationSourceType2["X402Transactions"] = 1] = "X402Transactions";
    ReputationSourceType2[ReputationSourceType2["UserReviews"] = 2] = "UserReviews";
    ReputationSourceType2[ReputationSourceType2["ElizaOSReputation"] = 3] = "ElizaOSReputation";
    ReputationSourceType2[ReputationSourceType2["CrossmintVerification"] = 4] = "CrossmintVerification";
    ReputationSourceType2[ReputationSourceType2["EndpointReliability"] = 5] = "EndpointReliability";
    ReputationSourceType2[ReputationSourceType2["JobCompletions"] = 6] = "JobCompletions";
    ReputationSourceType2[ReputationSourceType2["SkillEndorsements"] = 7] = "SkillEndorsements";
    return ReputationSourceType2;
  })(ReputationSourceType || {});
  RiskCategory = /* @__PURE__ */ ((RiskCategory2) => {
    RiskCategory2[RiskCategory2["Operational"] = 0] = "Operational";
    RiskCategory2[RiskCategory2["Financial"] = 1] = "Financial";
    RiskCategory2[RiskCategory2["Compliance"] = 2] = "Compliance";
    RiskCategory2[RiskCategory2["Security"] = 3] = "Security";
    RiskCategory2[RiskCategory2["Reputational"] = 4] = "Reputational";
    RiskCategory2[RiskCategory2["Technical"] = 5] = "Technical";
    RiskCategory2[RiskCategory2["Legal"] = 6] = "Legal";
    return RiskCategory2;
  })(RiskCategory || {});
  RiskLevel = /* @__PURE__ */ ((RiskLevel2) => {
    RiskLevel2[RiskLevel2["Low"] = 0] = "Low";
    RiskLevel2[RiskLevel2["Medium"] = 1] = "Medium";
    RiskLevel2[RiskLevel2["High"] = 2] = "High";
    RiskLevel2[RiskLevel2["Critical"] = 3] = "Critical";
    return RiskLevel2;
  })(RiskLevel || {});
  RoleStatus = /* @__PURE__ */ ((RoleStatus2) => {
    RoleStatus2[RoleStatus2["Active"] = 0] = "Active";
    RoleStatus2[RoleStatus2["Inactive"] = 1] = "Inactive";
    RoleStatus2[RoleStatus2["Deprecated"] = 2] = "Deprecated";
    RoleStatus2[RoleStatus2["UnderReview"] = 3] = "UnderReview";
    RoleStatus2[RoleStatus2["Suspended"] = 4] = "Suspended";
    return RoleStatus2;
  })(RoleStatus || {});
  RoleType = /* @__PURE__ */ ((RoleType2) => {
    RoleType2[RoleType2["Administrative"] = 0] = "Administrative";
    RoleType2[RoleType2["Operational"] = 1] = "Operational";
    RoleType2[RoleType2["ReadOnly"] = 2] = "ReadOnly";
    RoleType2[RoleType2["Compliance"] = 3] = "Compliance";
    RoleType2[RoleType2["Emergency"] = 4] = "Emergency";
    RoleType2[RoleType2["Custom"] = 5] = "Custom";
    RoleType2[RoleType2["Service"] = 6] = "Service";
    RoleType2[RoleType2["Guest"] = 7] = "Guest";
    return RoleType2;
  })(RoleType || {});
  RuleEffect = /* @__PURE__ */ ((RuleEffect2) => {
    RuleEffect2[RuleEffect2["Allow"] = 0] = "Allow";
    RuleEffect2[RuleEffect2["Deny"] = 1] = "Deny";
    RuleEffect2[RuleEffect2["AuditOnly"] = 2] = "AuditOnly";
    RuleEffect2[RuleEffect2["RequireApproval"] = 3] = "RequireApproval";
    RuleEffect2[RuleEffect2["RequireMfa"] = 4] = "RequireMfa";
    RuleEffect2[RuleEffect2["RequireJustification"] = 5] = "RequireJustification";
    return RuleEffect2;
  })(RuleEffect || {});
  ScopeInheritance = /* @__PURE__ */ ((ScopeInheritance2) => {
    ScopeInheritance2[ScopeInheritance2["None"] = 0] = "None";
    ScopeInheritance2[ScopeInheritance2["Hierarchical"] = 1] = "Hierarchical";
    ScopeInheritance2[ScopeInheritance2["Delegated"] = 2] = "Delegated";
    ScopeInheritance2[ScopeInheritance2["Inherited"] = 3] = "Inherited";
    return ScopeInheritance2;
  })(ScopeInheritance || {});
  ScopeType = /* @__PURE__ */ ((ScopeType2) => {
    ScopeType2[ScopeType2["Global"] = 0] = "Global";
    ScopeType2[ScopeType2["Organization"] = 1] = "Organization";
    ScopeType2[ScopeType2["Department"] = 2] = "Department";
    ScopeType2[ScopeType2["Project"] = 3] = "Project";
    ScopeType2[ScopeType2["Resource"] = 4] = "Resource";
    ScopeType2[ScopeType2["Individual"] = 5] = "Individual";
    return ScopeType2;
  })(ScopeType || {});
  SecurityEventType = /* @__PURE__ */ ((SecurityEventType2) => {
    SecurityEventType2[SecurityEventType2["AccountLockout"] = 0] = "AccountLockout";
    SecurityEventType2[SecurityEventType2["PasswordChange"] = 1] = "PasswordChange";
    SecurityEventType2[SecurityEventType2["PrivilegeEscalation"] = 2] = "PrivilegeEscalation";
    SecurityEventType2[SecurityEventType2["SuspiciousActivity"] = 3] = "SuspiciousActivity";
    SecurityEventType2[SecurityEventType2["PolicyViolation"] = 4] = "PolicyViolation";
    SecurityEventType2[SecurityEventType2["AccessDenied"] = 5] = "AccessDenied";
    SecurityEventType2[SecurityEventType2["DataBreach"] = 6] = "DataBreach";
    SecurityEventType2[SecurityEventType2["SystemCompromise"] = 7] = "SystemCompromise";
    return SecurityEventType2;
  })(SecurityEventType || {});
  ServiceEndpointType = /* @__PURE__ */ ((ServiceEndpointType2) => {
    ServiceEndpointType2[ServiceEndpointType2["AIAgentService"] = 0] = "AIAgentService";
    ServiceEndpointType2[ServiceEndpointType2["DIDCommMessaging"] = 1] = "DIDCommMessaging";
    ServiceEndpointType2[ServiceEndpointType2["CredentialRepository"] = 2] = "CredentialRepository";
    ServiceEndpointType2[ServiceEndpointType2["LinkedDomains"] = 3] = "LinkedDomains";
    ServiceEndpointType2[ServiceEndpointType2["Custom"] = 4] = "Custom";
    return ServiceEndpointType2;
  })(ServiceEndpointType || {});
  SlashReason = /* @__PURE__ */ ((SlashReason2) => {
    SlashReason2[SlashReason2["Fraud"] = 0] = "Fraud";
    SlashReason2[SlashReason2["DisputeLoss"] = 1] = "DisputeLoss";
    SlashReason2[SlashReason2["Custom"] = 2] = "Custom";
    return SlashReason2;
  })(SlashReason || {});
  SodConstraintType = /* @__PURE__ */ ((SodConstraintType2) => {
    SodConstraintType2[SodConstraintType2["Static"] = 0] = "Static";
    SodConstraintType2[SodConstraintType2["Dynamic"] = 1] = "Dynamic";
    SodConstraintType2[SodConstraintType2["Temporal"] = 2] = "Temporal";
    SodConstraintType2[SodConstraintType2["Contextual"] = 3] = "Contextual";
    return SodConstraintType2;
  })(SodConstraintType || {});
  StepUpTrigger = /* @__PURE__ */ ((StepUpTrigger2) => {
    StepUpTrigger2[StepUpTrigger2["HighRiskAction"] = 0] = "HighRiskAction";
    StepUpTrigger2[StepUpTrigger2["SensitiveData"] = 1] = "SensitiveData";
    StepUpTrigger2[StepUpTrigger2["LargeTransaction"] = 2] = "LargeTransaction";
    StepUpTrigger2[StepUpTrigger2["NewDevice"] = 3] = "NewDevice";
    StepUpTrigger2[StepUpTrigger2["UnusualLocation"] = 4] = "UnusualLocation";
    StepUpTrigger2[StepUpTrigger2["TimeBasedRisk"] = 5] = "TimeBasedRisk";
    StepUpTrigger2[StepUpTrigger2["BehaviorAnomaly"] = 6] = "BehaviorAnomaly";
    return StepUpTrigger2;
  })(StepUpTrigger || {});
  TimeLockType = /* @__PURE__ */ ((TimeLockType2) => {
    TimeLockType2[TimeLockType2["Standard"] = 0] = "Standard";
    TimeLockType2[TimeLockType2["Vesting"] = 1] = "Vesting";
    TimeLockType2[TimeLockType2["Emergency"] = 2] = "Emergency";
    TimeLockType2[TimeLockType2["Governance"] = 3] = "Governance";
    return TimeLockType2;
  })(TimeLockType || {});
  TransactionPriority = /* @__PURE__ */ ((TransactionPriority2) => {
    TransactionPriority2[TransactionPriority2["Low"] = 0] = "Low";
    TransactionPriority2[TransactionPriority2["Normal"] = 1] = "Normal";
    TransactionPriority2[TransactionPriority2["High"] = 2] = "High";
    TransactionPriority2[TransactionPriority2["Critical"] = 3] = "Critical";
    TransactionPriority2[TransactionPriority2["Emergency"] = 4] = "Emergency";
    return TransactionPriority2;
  })(TransactionPriority || {});
  TransactionStatus = /* @__PURE__ */ ((TransactionStatus2) => {
    TransactionStatus2[TransactionStatus2["Pending"] = 0] = "Pending";
    TransactionStatus2[TransactionStatus2["PartiallyApproved"] = 1] = "PartiallyApproved";
    TransactionStatus2[TransactionStatus2["FullyApproved"] = 2] = "FullyApproved";
    TransactionStatus2[TransactionStatus2["Executed"] = 3] = "Executed";
    TransactionStatus2[TransactionStatus2["Cancelled"] = 4] = "Cancelled";
    TransactionStatus2[TransactionStatus2["Expired"] = 5] = "Expired";
    TransactionStatus2[TransactionStatus2["Failed"] = 6] = "Failed";
    return TransactionStatus2;
  })(TransactionStatus || {});
  TransactionType = /* @__PURE__ */ ((TransactionType2) => {
    TransactionType2[TransactionType2["Transfer"] = 0] = "Transfer";
    TransactionType2[TransactionType2["Withdrawal"] = 1] = "Withdrawal";
    TransactionType2[TransactionType2["EscrowRelease"] = 2] = "EscrowRelease";
    TransactionType2[TransactionType2["ProposalCreation"] = 3] = "ProposalCreation";
    TransactionType2[TransactionType2["VoteExecution"] = 4] = "VoteExecution";
    TransactionType2[TransactionType2["ParameterUpdate"] = 5] = "ParameterUpdate";
    TransactionType2[TransactionType2["SignerAddition"] = 6] = "SignerAddition";
    TransactionType2[TransactionType2["SignerRemoval"] = 7] = "SignerRemoval";
    TransactionType2[TransactionType2["ThresholdUpdate"] = 8] = "ThresholdUpdate";
    TransactionType2[TransactionType2["ConfigUpdate"] = 9] = "ConfigUpdate";
    TransactionType2[TransactionType2["EmergencyFreeze"] = 10] = "EmergencyFreeze";
    TransactionType2[TransactionType2["EmergencyUnfreeze"] = 11] = "EmergencyUnfreeze";
    TransactionType2[TransactionType2["SecurityPolicyUpdate"] = 12] = "SecurityPolicyUpdate";
    TransactionType2[TransactionType2["ProtocolUpgrade"] = 13] = "ProtocolUpgrade";
    TransactionType2[TransactionType2["FeatureToggle"] = 14] = "FeatureToggle";
    TransactionType2[TransactionType2["RiskParameterUpdate"] = 15] = "RiskParameterUpdate";
    TransactionType2[TransactionType2["CustomInstruction"] = 16] = "CustomInstruction";
    return TransactionType2;
  })(TransactionType || {});
  TrendDirection = /* @__PURE__ */ ((TrendDirection2) => {
    TrendDirection2[TrendDirection2["Increasing"] = 0] = "Increasing";
    TrendDirection2[TrendDirection2["Decreasing"] = 1] = "Decreasing";
    TrendDirection2[TrendDirection2["Stable"] = 2] = "Stable";
    TrendDirection2[TrendDirection2["Unknown"] = 3] = "Unknown";
    return TrendDirection2;
  })(TrendDirection || {});
  UnlockMethod = /* @__PURE__ */ ((UnlockMethod2) => {
    UnlockMethod2[UnlockMethod2["TimeBasedAutoUnlock"] = 0] = "TimeBasedAutoUnlock";
    UnlockMethod2[UnlockMethod2["AdminUnlock"] = 1] = "AdminUnlock";
    UnlockMethod2[UnlockMethod2["SelfServiceUnlock"] = 2] = "SelfServiceUnlock";
    UnlockMethod2[UnlockMethod2["MultiFactorUnlock"] = 3] = "MultiFactorUnlock";
    UnlockMethod2[UnlockMethod2["SupervisorUnlock"] = 4] = "SupervisorUnlock";
    return UnlockMethod2;
  })(UnlockMethod || {});
  ValueType = /* @__PURE__ */ ((ValueType2) => {
    ValueType2[ValueType2["String"] = 0] = "String";
    ValueType2[ValueType2["Number"] = 1] = "Number";
    ValueType2[ValueType2["Boolean"] = 2] = "Boolean";
    ValueType2[ValueType2["Date"] = 3] = "Date";
    ValueType2[ValueType2["Time"] = 4] = "Time";
    ValueType2[ValueType2["Duration"] = 5] = "Duration";
    ValueType2[ValueType2["List"] = 6] = "List";
    ValueType2[ValueType2["Object"] = 7] = "Object";
    return ValueType2;
  })(ValueType || {});
  VerificationMethodType = /* @__PURE__ */ ((VerificationMethodType2) => {
    VerificationMethodType2[VerificationMethodType2["Ed25519VerificationKey2020"] = 0] = "Ed25519VerificationKey2020";
    VerificationMethodType2[VerificationMethodType2["X25519KeyAgreementKey2020"] = 1] = "X25519KeyAgreementKey2020";
    VerificationMethodType2[VerificationMethodType2["EcdsaSecp256k1VerificationKey2019"] = 2] = "EcdsaSecp256k1VerificationKey2019";
    return VerificationMethodType2;
  })(VerificationMethodType || {});
  VerificationRelationship = /* @__PURE__ */ ((VerificationRelationship2) => {
    VerificationRelationship2[VerificationRelationship2["Authentication"] = 0] = "Authentication";
    VerificationRelationship2[VerificationRelationship2["AssertionMethod"] = 1] = "AssertionMethod";
    VerificationRelationship2[VerificationRelationship2["KeyAgreement"] = 2] = "KeyAgreement";
    VerificationRelationship2[VerificationRelationship2["CapabilityInvocation"] = 3] = "CapabilityInvocation";
    VerificationRelationship2[VerificationRelationship2["CapabilityDelegation"] = 4] = "CapabilityDelegation";
    return VerificationRelationship2;
  })(VerificationRelationship || {});
  ViolationSeverity = /* @__PURE__ */ ((ViolationSeverity2) => {
    ViolationSeverity2[ViolationSeverity2["Low"] = 0] = "Low";
    ViolationSeverity2[ViolationSeverity2["Medium"] = 1] = "Medium";
    ViolationSeverity2[ViolationSeverity2["High"] = 2] = "High";
    ViolationSeverity2[ViolationSeverity2["Critical"] = 3] = "Critical";
    return ViolationSeverity2;
  })(ViolationSeverity || {});
  VoteChoice = /* @__PURE__ */ ((VoteChoice2) => {
    VoteChoice2[VoteChoice2["For"] = 0] = "For";
    VoteChoice2[VoteChoice2["Against"] = 1] = "Against";
    VoteChoice2[VoteChoice2["Abstain"] = 2] = "Abstain";
    return VoteChoice2;
  })(VoteChoice || {});
  AGENT_DISCRIMINATOR = new Uint8Array([
    47,
    166,
    112,
    147,
    155,
    197,
    86,
    7
  ]);
});

// ../sdk-typescript/dist/chunk-AWMGX3OX.js
function identifyGhostspeakMarketplaceAccount(account) {
  const data = "data" in account ? account.data : account;
  if (containsBytes(data, fixEncoderSize2(getBytesEncoder(), 8).encode(new Uint8Array([47, 166, 112, 147, 155, 197, 86, 7])), 0)) {
    return 0;
  }
  if (containsBytes(data, fixEncoderSize2(getBytesEncoder(), 8).encode(new Uint8Array([30, 249, 165, 44, 155, 194, 188, 175])), 0)) {
    return 1;
  }
  if (containsBytes(data, fixEncoderSize2(getBytesEncoder(), 8).encode(new Uint8Array([145, 145, 156, 0, 197, 232, 130, 245])), 0)) {
    return 2;
  }
  if (containsBytes(data, fixEncoderSize2(getBytesEncoder(), 8).encode(new Uint8Array([128, 155, 95, 241, 66, 207, 166, 59])), 0)) {
    return 3;
  }
  if (containsBytes(data, fixEncoderSize2(getBytesEncoder(), 8).encode(new Uint8Array([171, 223, 253, 181, 134, 88, 66, 26])), 0)) {
    return 4;
  }
  if (containsBytes(data, fixEncoderSize2(getBytesEncoder(), 8).encode(new Uint8Array([109, 102, 102, 17, 210, 84, 85, 210])), 0)) {
    return 5;
  }
  if (containsBytes(data, fixEncoderSize2(getBytesEncoder(), 8).encode(new Uint8Array([75, 146, 78, 26, 130, 240, 228, 35])), 0)) {
    return 6;
  }
  if (containsBytes(data, fixEncoderSize2(getBytesEncoder(), 8).encode(new Uint8Array([145, 44, 68, 220, 67, 46, 100, 135])), 0)) {
    return 7;
  }
  if (containsBytes(data, fixEncoderSize2(getBytesEncoder(), 8).encode(new Uint8Array([229, 129, 99, 91, 179, 207, 66, 75])), 0)) {
    return 8;
  }
  if (containsBytes(data, fixEncoderSize2(getBytesEncoder(), 8).encode(new Uint8Array([132, 171, 20, 181, 39, 219, 217, 112])), 0)) {
    return 9;
  }
  if (containsBytes(data, fixEncoderSize2(getBytesEncoder(), 8).encode(new Uint8Array([109, 220, 168, 224, 33, 173, 192, 166])), 0)) {
    return 10;
  }
  if (containsBytes(data, fixEncoderSize2(getBytesEncoder(), 8).encode(new Uint8Array([180, 218, 64, 128, 181, 84, 116, 180])), 0)) {
    return 11;
  }
  if (containsBytes(data, fixEncoderSize2(getBytesEncoder(), 8).encode(new Uint8Array([38, 0, 98, 160, 102, 4, 51, 160])), 0)) {
    return 12;
  }
  if (containsBytes(data, fixEncoderSize2(getBytesEncoder(), 8).encode(new Uint8Array([53, 107, 240, 190, 43, 73, 65, 143])), 0)) {
    return 13;
  }
  if (containsBytes(data, fixEncoderSize2(getBytesEncoder(), 8).encode(new Uint8Array([224, 116, 121, 186, 68, 161, 79, 236])), 0)) {
    return 14;
  }
  if (containsBytes(data, fixEncoderSize2(getBytesEncoder(), 8).encode(new Uint8Array([207, 91, 250, 28, 152, 179, 215, 209])), 0)) {
    return 15;
  }
  if (containsBytes(data, fixEncoderSize2(getBytesEncoder(), 8).encode(new Uint8Array([177, 94, 184, 202, 221, 112, 110, 38])), 0)) {
    return 16;
  }
  if (containsBytes(data, fixEncoderSize2(getBytesEncoder(), 8).encode(new Uint8Array([207, 227, 141, 11, 194, 21, 193, 32])), 0)) {
    return 17;
  }
  if (containsBytes(data, fixEncoderSize2(getBytesEncoder(), 8).encode(new Uint8Array([8, 160, 71, 30, 66, 150, 108, 33])), 0)) {
    return 18;
  }
  if (containsBytes(data, fixEncoderSize2(getBytesEncoder(), 8).encode(new Uint8Array([52, 178, 251, 157, 180, 186, 98, 234])), 0)) {
    return 19;
  }
  if (containsBytes(data, fixEncoderSize2(getBytesEncoder(), 8).encode(new Uint8Array([45, 134, 252, 82, 37, 57, 84, 25])), 0)) {
    return 20;
  }
  if (containsBytes(data, fixEncoderSize2(getBytesEncoder(), 8).encode(new Uint8Array([37, 84, 98, 14, 130, 63, 210, 138])), 0)) {
    return 21;
  }
  throw new Error("The provided account could not be identified as a ghostspeakMarketplace account.");
}
function identifyGhostspeakMarketplaceInstruction(instruction) {
  const data = "data" in instruction ? instruction.data : instruction;
  if (containsBytes(data, fixEncoderSize2(getBytesEncoder(), 8).encode(new Uint8Array([252, 139, 87, 21, 195, 152, 29, 217])), 0)) {
    return 0;
  }
  if (containsBytes(data, fixEncoderSize2(getBytesEncoder(), 8).encode(new Uint8Array([28, 233, 51, 115, 33, 220, 41, 28])), 0)) {
    return 1;
  }
  if (containsBytes(data, fixEncoderSize2(getBytesEncoder(), 8).encode(new Uint8Array([225, 89, 166, 101, 215, 40, 191, 4])), 0)) {
    return 2;
  }
  if (containsBytes(data, fixEncoderSize2(getBytesEncoder(), 8).encode(new Uint8Array([50, 170, 232, 73, 238, 200, 180, 16])), 0)) {
    return 3;
  }
  if (containsBytes(data, fixEncoderSize2(getBytesEncoder(), 8).encode(new Uint8Array([149, 107, 35, 233, 252, 101, 148, 225])), 0)) {
    return 4;
  }
  if (containsBytes(data, fixEncoderSize2(getBytesEncoder(), 8).encode(new Uint8Array([48, 219, 232, 202, 151, 97, 230, 20])), 0)) {
    return 5;
  }
  if (containsBytes(data, fixEncoderSize2(getBytesEncoder(), 8).encode(new Uint8Array([183, 109, 12, 128, 134, 8, 139, 144])), 0)) {
    return 6;
  }
  if (containsBytes(data, fixEncoderSize2(getBytesEncoder(), 8).encode(new Uint8Array([211, 208, 67, 175, 20, 248, 8, 227])), 0)) {
    return 7;
  }
  if (containsBytes(data, fixEncoderSize2(getBytesEncoder(), 8).encode(new Uint8Array([253, 40, 200, 239, 69, 147, 82, 182])), 0)) {
    return 8;
  }
  if (containsBytes(data, fixEncoderSize2(getBytesEncoder(), 8).encode(new Uint8Array([253, 215, 165, 116, 36, 108, 68, 80])), 0)) {
    return 9;
  }
  if (containsBytes(data, fixEncoderSize2(getBytesEncoder(), 8).encode(new Uint8Array([148, 146, 240, 10, 226, 215, 167, 174])), 0)) {
    return 10;
  }
  if (containsBytes(data, fixEncoderSize2(getBytesEncoder(), 8).encode(new Uint8Array([205, 171, 239, 225, 82, 126, 96, 166])), 0)) {
    return 11;
  }
  if (containsBytes(data, fixEncoderSize2(getBytesEncoder(), 8).encode(new Uint8Array([177, 8, 195, 104, 56, 34, 84, 162])), 0)) {
    return 12;
  }
  if (containsBytes(data, fixEncoderSize2(getBytesEncoder(), 8).encode(new Uint8Array([110, 174, 221, 244, 36, 206, 60, 237])), 0)) {
    return 13;
  }
  if (containsBytes(data, fixEncoderSize2(getBytesEncoder(), 8).encode(new Uint8Array([77, 13, 56, 161, 67, 155, 206, 119])), 0)) {
    return 14;
  }
  if (containsBytes(data, fixEncoderSize2(getBytesEncoder(), 8).encode(new Uint8Array([9, 115, 79, 19, 158, 209, 221, 38])), 0)) {
    return 15;
  }
  if (containsBytes(data, fixEncoderSize2(getBytesEncoder(), 8).encode(new Uint8Array([210, 63, 221, 114, 212, 97, 195, 156])), 0)) {
    return 16;
  }
  if (containsBytes(data, fixEncoderSize2(getBytesEncoder(), 8).encode(new Uint8Array([213, 97, 79, 234, 22, 228, 14, 32])), 0)) {
    return 17;
  }
  if (containsBytes(data, fixEncoderSize2(getBytesEncoder(), 8).encode(new Uint8Array([156, 109, 115, 85, 12, 60, 245, 99])), 0)) {
    return 18;
  }
  if (containsBytes(data, fixEncoderSize2(getBytesEncoder(), 8).encode(new Uint8Array([145, 182, 236, 249, 212, 17, 175, 161])), 0)) {
    return 19;
  }
  if (containsBytes(data, fixEncoderSize2(getBytesEncoder(), 8).encode(new Uint8Array([137, 84, 234, 206, 17, 58, 54, 215])), 0)) {
    return 20;
  }
  if (containsBytes(data, fixEncoderSize2(getBytesEncoder(), 8).encode(new Uint8Array([28, 50, 43, 233, 244, 98, 123, 118])), 0)) {
    return 21;
  }
  if (containsBytes(data, fixEncoderSize2(getBytesEncoder(), 8).encode(new Uint8Array([215, 68, 129, 228, 237, 165, 0, 240])), 0)) {
    return 22;
  }
  if (containsBytes(data, fixEncoderSize2(getBytesEncoder(), 8).encode(new Uint8Array([228, 11, 207, 44, 52, 188, 169, 237])), 0)) {
    return 23;
  }
  if (containsBytes(data, fixEncoderSize2(getBytesEncoder(), 8).encode(new Uint8Array([78, 164, 6, 115, 206, 48, 168, 105])), 0)) {
    return 24;
  }
  if (containsBytes(data, fixEncoderSize2(getBytesEncoder(), 8).encode(new Uint8Array([255, 193, 171, 224, 68, 171, 194, 87])), 0)) {
    return 25;
  }
  if (containsBytes(data, fixEncoderSize2(getBytesEncoder(), 8).encode(new Uint8Array([156, 102, 141, 155, 175, 13, 29, 86])), 0)) {
    return 26;
  }
  if (containsBytes(data, fixEncoderSize2(getBytesEncoder(), 8).encode(new Uint8Array([164, 219, 91, 38, 45, 31, 33, 47])), 0)) {
    return 27;
  }
  if (containsBytes(data, fixEncoderSize2(getBytesEncoder(), 8).encode(new Uint8Array([165, 202, 159, 139, 65, 65, 36, 163])), 0)) {
    return 28;
  }
  if (containsBytes(data, fixEncoderSize2(getBytesEncoder(), 8).encode(new Uint8Array([135, 157, 66, 195, 2, 113, 175, 30])), 0)) {
    return 29;
  }
  if (containsBytes(data, fixEncoderSize2(getBytesEncoder(), 8).encode(new Uint8Array([15, 6, 94, 55, 65, 80, 123, 248])), 0)) {
    return 30;
  }
  if (containsBytes(data, fixEncoderSize2(getBytesEncoder(), 8).encode(new Uint8Array([34, 233, 111, 236, 212, 22, 26, 254])), 0)) {
    return 31;
  }
  if (containsBytes(data, fixEncoderSize2(getBytesEncoder(), 8).encode(new Uint8Array([93, 74, 168, 125, 46, 153, 9, 255])), 0)) {
    return 32;
  }
  if (containsBytes(data, fixEncoderSize2(getBytesEncoder(), 8).encode(new Uint8Array([168, 180, 218, 211, 184, 19, 102, 12])), 0)) {
    return 33;
  }
  if (containsBytes(data, fixEncoderSize2(getBytesEncoder(), 8).encode(new Uint8Array([222, 179, 207, 59, 191, 78, 24, 248])), 0)) {
    return 34;
  }
  if (containsBytes(data, fixEncoderSize2(getBytesEncoder(), 8).encode(new Uint8Array([38, 123, 95, 95, 223, 158, 169, 87])), 0)) {
    return 35;
  }
  if (containsBytes(data, fixEncoderSize2(getBytesEncoder(), 8).encode(new Uint8Array([190, 242, 137, 27, 41, 18, 233, 37])), 0)) {
    return 36;
  }
  if (containsBytes(data, fixEncoderSize2(getBytesEncoder(), 8).encode(new Uint8Array([5, 196, 24, 54, 196, 56, 173, 191])), 0)) {
    return 37;
  }
  if (containsBytes(data, fixEncoderSize2(getBytesEncoder(), 8).encode(new Uint8Array([217, 177, 33, 54, 136, 185, 123, 96])), 0)) {
    return 38;
  }
  if (containsBytes(data, fixEncoderSize2(getBytesEncoder(), 8).encode(new Uint8Array([23, 160, 228, 88, 168, 145, 129, 19])), 0)) {
    return 39;
  }
  if (containsBytes(data, fixEncoderSize2(getBytesEncoder(), 8).encode(new Uint8Array([252, 101, 172, 252, 1, 4, 12, 116])), 0)) {
    return 40;
  }
  if (containsBytes(data, fixEncoderSize2(getBytesEncoder(), 8).encode(new Uint8Array([85, 2, 178, 9, 119, 139, 102, 164])), 0)) {
    return 41;
  }
  if (containsBytes(data, fixEncoderSize2(getBytesEncoder(), 8).encode(new Uint8Array([80, 227, 92, 245, 231, 37, 99, 180])), 0)) {
    return 42;
  }
  if (containsBytes(data, fixEncoderSize2(getBytesEncoder(), 8).encode(new Uint8Array([87, 146, 181, 198, 252, 68, 243, 102])), 0)) {
    return 43;
  }
  if (containsBytes(data, fixEncoderSize2(getBytesEncoder(), 8).encode(new Uint8Array([22, 167, 59, 238, 22, 231, 239, 146])), 0)) {
    return 44;
  }
  if (containsBytes(data, fixEncoderSize2(getBytesEncoder(), 8).encode(new Uint8Array([64, 216, 17, 91, 205, 94, 45, 57])), 0)) {
    return 45;
  }
  if (containsBytes(data, fixEncoderSize2(getBytesEncoder(), 8).encode(new Uint8Array([213, 152, 5, 80, 163, 224, 151, 120])), 0)) {
    return 46;
  }
  if (containsBytes(data, fixEncoderSize2(getBytesEncoder(), 8).encode(new Uint8Array([197, 97, 123, 54, 221, 168, 11, 135])), 0)) {
    return 47;
  }
  if (containsBytes(data, fixEncoderSize2(getBytesEncoder(), 8).encode(new Uint8Array([206, 96, 254, 186, 129, 180, 103, 198])), 0)) {
    return 48;
  }
  if (containsBytes(data, fixEncoderSize2(getBytesEncoder(), 8).encode(new Uint8Array([61, 236, 225, 167, 134, 43, 53, 93])), 0)) {
    return 49;
  }
  if (containsBytes(data, fixEncoderSize2(getBytesEncoder(), 8).encode(new Uint8Array([161, 240, 255, 69, 130, 227, 71, 123])), 0)) {
    return 50;
  }
  if (containsBytes(data, fixEncoderSize2(getBytesEncoder(), 8).encode(new Uint8Array([206, 212, 108, 12, 105, 61, 100, 66])), 0)) {
    return 51;
  }
  if (containsBytes(data, fixEncoderSize2(getBytesEncoder(), 8).encode(new Uint8Array([43, 9, 131, 59, 74, 118, 113, 170])), 0)) {
    return 52;
  }
  throw new Error("The provided instruction could not be identified as a ghostspeakMarketplace instruction.");
}
function expectSome(value) {
  if (value === null || value === undefined) {
    throw new Error("Expected a value but received null or undefined.");
  }
  return value;
}
function expectAddress(value) {
  if (!value) {
    throw new Error("Expected a Address.");
  }
  if (typeof value === "object" && "address" in value) {
    return value.address;
  }
  if (Array.isArray(value)) {
    return value[0];
  }
  return value;
}
function getAccountMetaFactory(programAddress, optionalAccountStrategy) {
  return (account) => {
    if (!account.value) {
      if (optionalAccountStrategy === "omitted")
        return;
      return Object.freeze({
        address: programAddress,
        role: AccountRole.READONLY
      });
    }
    const writableRole = account.isWritable ? AccountRole.WRITABLE : AccountRole.READONLY;
    return Object.freeze({
      address: expectAddress(account.value),
      role: isTransactionSigner2(account.value) ? upgradeRoleToSigner(writableRole) : writableRole,
      ...isTransactionSigner2(account.value) ? { signer: account.value } : {}
    });
  };
}
function isTransactionSigner2(value) {
  return !!value && typeof value === "object" && "address" in value && isTransactionSigner(value);
}
var GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS = "4wHjA2a5YC4twZb4NQpwZpixo5FgxxzuJUrCG7UnF9pB", GhostspeakMarketplaceAccount, GhostspeakMarketplaceInstruction;
var init_chunk_AWMGX3OX = __esm(() => {
  init_index_node40();
  GhostspeakMarketplaceAccount = /* @__PURE__ */ ((GhostspeakMarketplaceAccount2) => {
    GhostspeakMarketplaceAccount2[GhostspeakMarketplaceAccount2["Agent"] = 0] = "Agent";
    GhostspeakMarketplaceAccount2[GhostspeakMarketplaceAccount2["AgentReputationAuth"] = 1] = "AgentReputationAuth";
    GhostspeakMarketplaceAccount2[GhostspeakMarketplaceAccount2["AgentTreeConfig"] = 2] = "AgentTreeConfig";
    GhostspeakMarketplaceAccount2[GhostspeakMarketplaceAccount2["AgentVerification"] = 3] = "AgentVerification";
    GhostspeakMarketplaceAccount2[GhostspeakMarketplaceAccount2["AuditTrail"] = 4] = "AuditTrail";
    GhostspeakMarketplaceAccount2[GhostspeakMarketplaceAccount2["AuthorizationUsageRecord"] = 5] = "AuthorizationUsageRecord";
    GhostspeakMarketplaceAccount2[GhostspeakMarketplaceAccount2["ComplianceReport"] = 6] = "ComplianceReport";
    GhostspeakMarketplaceAccount2[GhostspeakMarketplaceAccount2["Credential"] = 7] = "Credential";
    GhostspeakMarketplaceAccount2[GhostspeakMarketplaceAccount2["CredentialTemplate"] = 8] = "CredentialTemplate";
    GhostspeakMarketplaceAccount2[GhostspeakMarketplaceAccount2["CredentialType"] = 9] = "CredentialType";
    GhostspeakMarketplaceAccount2[GhostspeakMarketplaceAccount2["DidDocument"] = 10] = "DidDocument";
    GhostspeakMarketplaceAccount2[GhostspeakMarketplaceAccount2["ExternalIdMapping"] = 11] = "ExternalIdMapping";
    GhostspeakMarketplaceAccount2[GhostspeakMarketplaceAccount2["GhostProtectEscrow"] = 12] = "GhostProtectEscrow";
    GhostspeakMarketplaceAccount2[GhostspeakMarketplaceAccount2["GovernanceProposal"] = 13] = "GovernanceProposal";
    GhostspeakMarketplaceAccount2[GhostspeakMarketplaceAccount2["Multisig"] = 14] = "Multisig";
    GhostspeakMarketplaceAccount2[GhostspeakMarketplaceAccount2["ProtocolConfig"] = 15] = "ProtocolConfig";
    GhostspeakMarketplaceAccount2[GhostspeakMarketplaceAccount2["RbacConfig"] = 16] = "RbacConfig";
    GhostspeakMarketplaceAccount2[GhostspeakMarketplaceAccount2["ReentrancyGuard"] = 17] = "ReentrancyGuard";
    GhostspeakMarketplaceAccount2[GhostspeakMarketplaceAccount2["ReputationMetrics"] = 18] = "ReputationMetrics";
    GhostspeakMarketplaceAccount2[GhostspeakMarketplaceAccount2["StakingAccount"] = 19] = "StakingAccount";
    GhostspeakMarketplaceAccount2[GhostspeakMarketplaceAccount2["StakingConfig"] = 20] = "StakingConfig";
    GhostspeakMarketplaceAccount2[GhostspeakMarketplaceAccount2["UserRegistry"] = 21] = "UserRegistry";
    return GhostspeakMarketplaceAccount2;
  })(GhostspeakMarketplaceAccount || {});
  GhostspeakMarketplaceInstruction = /* @__PURE__ */ ((GhostspeakMarketplaceInstruction2) => {
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["ActivateAgent"] = 0] = "ActivateAgent";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["ApproveDelivery"] = 1] = "ApproveDelivery";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["ArbitrateDispute"] = 2] = "ArbitrateDispute";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["AutoCreateGhost"] = 3] = "AutoCreateGhost";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["ClaimGhost"] = 4] = "ClaimGhost";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["CreateAgentAuthorization"] = 5] = "CreateAgentAuthorization";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["CreateCredentialTemplate"] = 6] = "CreateCredentialTemplate";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["CreateCredentialType"] = 7] = "CreateCredentialType";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["CreateDidDocument"] = 8] = "CreateDidDocument";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["CreateEscrow"] = 9] = "CreateEscrow";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["CreateMultisig"] = 10] = "CreateMultisig";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["DeactivateAgent"] = 11] = "DeactivateAgent";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["DeactivateCredentialTemplate"] = 12] = "DeactivateCredentialTemplate";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["DeactivateCredentialType"] = 13] = "DeactivateCredentialType";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["DeactivateDidDocument"] = 14] = "DeactivateDidDocument";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["EnableProtocolFees"] = 15] = "EnableProtocolFees";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["FileDispute"] = 16] = "FileDispute";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["GenerateComplianceReport"] = 17] = "GenerateComplianceReport";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["InitReentrancyGuard"] = 18] = "InitReentrancyGuard";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["InitializeAuditTrail"] = 19] = "InitializeAuditTrail";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["InitializeGovernanceProposal"] = 20] = "InitializeGovernanceProposal";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["InitializeProtocolConfig"] = 21] = "InitializeProtocolConfig";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["InitializeRbacConfig"] = 22] = "InitializeRbacConfig";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["InitializeReputationMetrics"] = 23] = "InitializeReputationMetrics";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["InitializeStakingConfig"] = 24] = "InitializeStakingConfig";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["IssueCredential"] = 25] = "IssueCredential";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["LinkExternalId"] = 26] = "LinkExternalId";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["ManageAgentStatus"] = 27] = "ManageAgentStatus";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["RecordPayaiPayment"] = 28] = "RecordPayaiPayment";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["RegisterAgent"] = 29] = "RegisterAgent";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["RegisterAgentCompressed"] = 30] = "RegisterAgentCompressed";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["RegisterGhostMetadata"] = 31] = "RegisterGhostMetadata";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["ResetReentrancyGuard"] = 32] = "ResetReentrancyGuard";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["ResolveDidDocument"] = 33] = "ResolveDidDocument";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["RevokeAuthorization"] = 34] = "RevokeAuthorization";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["RevokeCredential"] = 35] = "RevokeCredential";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["SlashStake"] = 36] = "SlashStake";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["StakeGhost"] = 37] = "StakeGhost";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["SubmitDelivery"] = 38] = "SubmitDelivery";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["SubmitServiceRating"] = 39] = "SubmitServiceRating";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["UnstakeGhost"] = 40] = "UnstakeGhost";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["UpdateAgent"] = 41] = "UpdateAgent";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["UpdateAgentReputation"] = 42] = "UpdateAgentReputation";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["UpdateAgentService"] = 43] = "UpdateAgentService";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["UpdateCrosschainStatus"] = 44] = "UpdateCrosschainStatus";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["UpdateDidDocument"] = 45] = "UpdateDidDocument";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["UpdateGhostScore"] = 46] = "UpdateGhostScore";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["UpdateProtocolConfig"] = 47] = "UpdateProtocolConfig";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["UpdateReputationTags"] = 48] = "UpdateReputationTags";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["UpdateReputationWithAuth"] = 49] = "UpdateReputationWithAuth";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["UpdateSourceReputation"] = 50] = "UpdateSourceReputation";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["VerifyAgent"] = 51] = "VerifyAgent";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["VerifyAuthorization"] = 52] = "VerifyAuthorization";
    return GhostspeakMarketplaceInstruction2;
  })(GhostspeakMarketplaceInstruction || {});
});

// ../sdk-typescript/dist/chunk-IQM5RASO.js
function getAgentReputationAuthDiscriminatorBytes() {
  return fixEncoderSize2(getBytesEncoder(), 8).encode(AGENT_REPUTATION_AUTH_DISCRIMINATOR);
}
function getAgentReputationAuthEncoder() {
  return transformEncoder2(getStructEncoder([
    ["discriminator", fixEncoderSize2(getBytesEncoder(), 8)],
    ["agent", getAddressEncoder2()],
    ["authorizedSource", getAddressEncoder2()],
    ["indexLimit", getU64Encoder()],
    ["currentIndex", getU64Encoder()],
    ["expiresAt", getI64Encoder()],
    ["network", getU8Encoder()],
    ["signature", fixEncoderSize2(getBytesEncoder(), 64)],
    [
      "nonce",
      getOptionEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    ["revoked", getBooleanEncoder()],
    ["createdAt", getI64Encoder()],
    ["lastUsedAt", getOptionEncoder(getI64Encoder())],
    ["totalReputationChange", getI64Encoder()],
    ["bump", getU8Encoder()]
  ]), (value) => ({
    ...value,
    discriminator: AGENT_REPUTATION_AUTH_DISCRIMINATOR
  }));
}
function getAgentReputationAuthDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize2(getBytesDecoder(), 8)],
    ["agent", getAddressDecoder2()],
    ["authorizedSource", getAddressDecoder2()],
    ["indexLimit", getU64Decoder()],
    ["currentIndex", getU64Decoder()],
    ["expiresAt", getI64Decoder()],
    ["network", getU8Decoder()],
    ["signature", fixDecoderSize2(getBytesDecoder(), 64)],
    [
      "nonce",
      getOptionDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    ["revoked", getBooleanDecoder()],
    ["createdAt", getI64Decoder()],
    ["lastUsedAt", getOptionDecoder(getI64Decoder())],
    ["totalReputationChange", getI64Decoder()],
    ["bump", getU8Decoder()]
  ]);
}
function getAgentReputationAuthCodec() {
  return combineCodec2(getAgentReputationAuthEncoder(), getAgentReputationAuthDecoder());
}
function decodeAgentReputationAuth(encodedAccount) {
  return decodeAccount(encodedAccount, getAgentReputationAuthDecoder());
}
async function fetchAgentReputationAuth(rpc2, address3, config) {
  const maybeAccount = await fetchMaybeAgentReputationAuth(rpc2, address3, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeAgentReputationAuth(rpc2, address3, config) {
  const maybeAccount = await fetchEncodedAccount(rpc2, address3, config);
  return decodeAgentReputationAuth(maybeAccount);
}
async function fetchAllAgentReputationAuth(rpc2, addresses2, config) {
  const maybeAccounts = await fetchAllMaybeAgentReputationAuth(rpc2, addresses2, config);
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeAgentReputationAuth(rpc2, addresses2, config) {
  const maybeAccounts = await fetchEncodedAccounts(rpc2, addresses2, config);
  return maybeAccounts.map((maybeAccount) => decodeAgentReputationAuth(maybeAccount));
}
function getAgentTreeConfigDiscriminatorBytes() {
  return fixEncoderSize2(getBytesEncoder(), 8).encode(AGENT_TREE_CONFIG_DISCRIMINATOR);
}
function getAgentTreeConfigEncoder() {
  return transformEncoder2(getStructEncoder([
    ["discriminator", fixEncoderSize2(getBytesEncoder(), 8)],
    ["treeCreator", getAddressEncoder2()],
    ["treeDelegate", getAddressEncoder2()],
    ["numMinted", getU64Encoder()],
    ["bump", getU8Encoder()]
  ]), (value) => ({ ...value, discriminator: AGENT_TREE_CONFIG_DISCRIMINATOR }));
}
function getAgentTreeConfigDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize2(getBytesDecoder(), 8)],
    ["treeCreator", getAddressDecoder2()],
    ["treeDelegate", getAddressDecoder2()],
    ["numMinted", getU64Decoder()],
    ["bump", getU8Decoder()]
  ]);
}
function getAgentTreeConfigCodec() {
  return combineCodec2(getAgentTreeConfigEncoder(), getAgentTreeConfigDecoder());
}
function decodeAgentTreeConfig(encodedAccount) {
  return decodeAccount(encodedAccount, getAgentTreeConfigDecoder());
}
async function fetchAgentTreeConfig(rpc2, address3, config) {
  const maybeAccount = await fetchMaybeAgentTreeConfig(rpc2, address3, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeAgentTreeConfig(rpc2, address3, config) {
  const maybeAccount = await fetchEncodedAccount(rpc2, address3, config);
  return decodeAgentTreeConfig(maybeAccount);
}
async function fetchAllAgentTreeConfig(rpc2, addresses2, config) {
  const maybeAccounts = await fetchAllMaybeAgentTreeConfig(rpc2, addresses2, config);
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeAgentTreeConfig(rpc2, addresses2, config) {
  const maybeAccounts = await fetchEncodedAccounts(rpc2, addresses2, config);
  return maybeAccounts.map((maybeAccount) => decodeAgentTreeConfig(maybeAccount));
}
function getAgentTreeConfigSize() {
  return 81;
}
function getAgentVerificationDiscriminatorBytes() {
  return fixEncoderSize2(getBytesEncoder(), 8).encode(AGENT_VERIFICATION_DISCRIMINATOR);
}
function getAgentVerificationEncoder() {
  return transformEncoder2(getStructEncoder([
    ["discriminator", fixEncoderSize2(getBytesEncoder(), 8)],
    ["agent", getAddressEncoder2()],
    ["verifier", getAddressEncoder2()],
    ["verificationData", getAgentVerificationDataEncoder()],
    ["createdAt", getI64Encoder()],
    ["expiresAt", getI64Encoder()],
    ["isActive", getBooleanEncoder()],
    ["bump", getU8Encoder()]
  ]), (value) => ({ ...value, discriminator: AGENT_VERIFICATION_DISCRIMINATOR }));
}
function getAgentVerificationDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize2(getBytesDecoder(), 8)],
    ["agent", getAddressDecoder2()],
    ["verifier", getAddressDecoder2()],
    ["verificationData", getAgentVerificationDataDecoder()],
    ["createdAt", getI64Decoder()],
    ["expiresAt", getI64Decoder()],
    ["isActive", getBooleanDecoder()],
    ["bump", getU8Decoder()]
  ]);
}
function getAgentVerificationCodec() {
  return combineCodec2(getAgentVerificationEncoder(), getAgentVerificationDecoder());
}
function decodeAgentVerification(encodedAccount) {
  return decodeAccount(encodedAccount, getAgentVerificationDecoder());
}
async function fetchAgentVerification(rpc2, address3, config) {
  const maybeAccount = await fetchMaybeAgentVerification(rpc2, address3, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeAgentVerification(rpc2, address3, config) {
  const maybeAccount = await fetchEncodedAccount(rpc2, address3, config);
  return decodeAgentVerification(maybeAccount);
}
async function fetchAllAgentVerification(rpc2, addresses2, config) {
  const maybeAccounts = await fetchAllMaybeAgentVerification(rpc2, addresses2, config);
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeAgentVerification(rpc2, addresses2, config) {
  const maybeAccounts = await fetchEncodedAccounts(rpc2, addresses2, config);
  return maybeAccounts.map((maybeAccount) => decodeAgentVerification(maybeAccount));
}
function getAuditTrailDiscriminatorBytes() {
  return fixEncoderSize2(getBytesEncoder(), 8).encode(AUDIT_TRAIL_DISCRIMINATOR);
}
function getAuditTrailEncoder() {
  return transformEncoder2(getStructEncoder([
    ["discriminator", fixEncoderSize2(getBytesEncoder(), 8)],
    ["authority", getAddressEncoder2()],
    ["trailId", getU64Encoder()],
    ["createdAt", getI64Encoder()],
    ["updatedAt", getI64Encoder()],
    ["version", getU8Encoder()],
    ["entries", getArrayEncoder(getAuditEntryEncoder())],
    ["config", getAuditConfigEncoder()],
    ["complianceStatus", getComplianceStatusEncoder()],
    ["hashChain", getArrayEncoder(fixEncoderSize2(getBytesEncoder(), 32))],
    ["reserved", fixEncoderSize2(getBytesEncoder(), 128)]
  ]), (value) => ({ ...value, discriminator: AUDIT_TRAIL_DISCRIMINATOR }));
}
function getAuditTrailDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize2(getBytesDecoder(), 8)],
    ["authority", getAddressDecoder2()],
    ["trailId", getU64Decoder()],
    ["createdAt", getI64Decoder()],
    ["updatedAt", getI64Decoder()],
    ["version", getU8Decoder()],
    ["entries", getArrayDecoder(getAuditEntryDecoder())],
    ["config", getAuditConfigDecoder()],
    ["complianceStatus", getComplianceStatusDecoder()],
    ["hashChain", getArrayDecoder(fixDecoderSize2(getBytesDecoder(), 32))],
    ["reserved", fixDecoderSize2(getBytesDecoder(), 128)]
  ]);
}
function getAuditTrailCodec() {
  return combineCodec2(getAuditTrailEncoder(), getAuditTrailDecoder());
}
function decodeAuditTrail(encodedAccount) {
  return decodeAccount(encodedAccount, getAuditTrailDecoder());
}
async function fetchAuditTrail(rpc2, address3, config) {
  const maybeAccount = await fetchMaybeAuditTrail(rpc2, address3, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeAuditTrail(rpc2, address3, config) {
  const maybeAccount = await fetchEncodedAccount(rpc2, address3, config);
  return decodeAuditTrail(maybeAccount);
}
async function fetchAllAuditTrail(rpc2, addresses2, config) {
  const maybeAccounts = await fetchAllMaybeAuditTrail(rpc2, addresses2, config);
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeAuditTrail(rpc2, addresses2, config) {
  const maybeAccounts = await fetchEncodedAccounts(rpc2, addresses2, config);
  return maybeAccounts.map((maybeAccount) => decodeAuditTrail(maybeAccount));
}
function getAuthorizationUsageRecordDiscriminatorBytes() {
  return fixEncoderSize2(getBytesEncoder(), 8).encode(AUTHORIZATION_USAGE_RECORD_DISCRIMINATOR);
}
function getAuthorizationUsageRecordEncoder() {
  return transformEncoder2(getStructEncoder([
    ["discriminator", fixEncoderSize2(getBytesEncoder(), 8)],
    ["authorization", getAddressEncoder2()],
    ["agent", getAddressEncoder2()],
    ["authorizedSource", getAddressEncoder2()],
    ["usageIndex", getU64Encoder()],
    ["reputationChange", getI64Encoder()],
    ["usedAt", getI64Encoder()],
    [
      "transactionSignature",
      addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())
    ],
    [
      "metadata",
      getOptionEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    ["bump", getU8Encoder()]
  ]), (value) => ({
    ...value,
    discriminator: AUTHORIZATION_USAGE_RECORD_DISCRIMINATOR
  }));
}
function getAuthorizationUsageRecordDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize2(getBytesDecoder(), 8)],
    ["authorization", getAddressDecoder2()],
    ["agent", getAddressDecoder2()],
    ["authorizedSource", getAddressDecoder2()],
    ["usageIndex", getU64Decoder()],
    ["reputationChange", getI64Decoder()],
    ["usedAt", getI64Decoder()],
    [
      "transactionSignature",
      addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())
    ],
    [
      "metadata",
      getOptionDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    ["bump", getU8Decoder()]
  ]);
}
function getAuthorizationUsageRecordCodec() {
  return combineCodec2(getAuthorizationUsageRecordEncoder(), getAuthorizationUsageRecordDecoder());
}
function decodeAuthorizationUsageRecord(encodedAccount) {
  return decodeAccount(encodedAccount, getAuthorizationUsageRecordDecoder());
}
async function fetchAuthorizationUsageRecord(rpc2, address3, config) {
  const maybeAccount = await fetchMaybeAuthorizationUsageRecord(rpc2, address3, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeAuthorizationUsageRecord(rpc2, address3, config) {
  const maybeAccount = await fetchEncodedAccount(rpc2, address3, config);
  return decodeAuthorizationUsageRecord(maybeAccount);
}
async function fetchAllAuthorizationUsageRecord(rpc2, addresses2, config) {
  const maybeAccounts = await fetchAllMaybeAuthorizationUsageRecord(rpc2, addresses2, config);
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeAuthorizationUsageRecord(rpc2, addresses2, config) {
  const maybeAccounts = await fetchEncodedAccounts(rpc2, addresses2, config);
  return maybeAccounts.map((maybeAccount) => decodeAuthorizationUsageRecord(maybeAccount));
}
function getComplianceReportDiscriminatorBytes() {
  return fixEncoderSize2(getBytesEncoder(), 8).encode(COMPLIANCE_REPORT_DISCRIMINATOR);
}
function getComplianceReportEncoder() {
  return transformEncoder2(getStructEncoder([
    ["discriminator", fixEncoderSize2(getBytesEncoder(), 8)],
    ["reportId", getU64Encoder()],
    ["reportType", getReportTypeEncoder()],
    ["generatedAt", getI64Encoder()],
    ["periodStart", getI64Encoder()],
    ["periodEnd", getI64Encoder()],
    ["reportData", getReportDataEncoder()],
    ["signature", fixEncoderSize2(getBytesEncoder(), 64)],
    ["status", getReportStatusEncoder()],
    ["submissionDetails", getOptionEncoder(getSubmissionDetailsEncoder())],
    ["reserved", fixEncoderSize2(getBytesEncoder(), 64)]
  ]), (value) => ({ ...value, discriminator: COMPLIANCE_REPORT_DISCRIMINATOR }));
}
function getComplianceReportDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize2(getBytesDecoder(), 8)],
    ["reportId", getU64Decoder()],
    ["reportType", getReportTypeDecoder()],
    ["generatedAt", getI64Decoder()],
    ["periodStart", getI64Decoder()],
    ["periodEnd", getI64Decoder()],
    ["reportData", getReportDataDecoder()],
    ["signature", fixDecoderSize2(getBytesDecoder(), 64)],
    ["status", getReportStatusDecoder()],
    ["submissionDetails", getOptionDecoder(getSubmissionDetailsDecoder())],
    ["reserved", fixDecoderSize2(getBytesDecoder(), 64)]
  ]);
}
function getComplianceReportCodec() {
  return combineCodec2(getComplianceReportEncoder(), getComplianceReportDecoder());
}
function decodeComplianceReport(encodedAccount) {
  return decodeAccount(encodedAccount, getComplianceReportDecoder());
}
async function fetchComplianceReport(rpc2, address3, config) {
  const maybeAccount = await fetchMaybeComplianceReport(rpc2, address3, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeComplianceReport(rpc2, address3, config) {
  const maybeAccount = await fetchEncodedAccount(rpc2, address3, config);
  return decodeComplianceReport(maybeAccount);
}
async function fetchAllComplianceReport(rpc2, addresses2, config) {
  const maybeAccounts = await fetchAllMaybeComplianceReport(rpc2, addresses2, config);
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeComplianceReport(rpc2, addresses2, config) {
  const maybeAccounts = await fetchEncodedAccounts(rpc2, addresses2, config);
  return maybeAccounts.map((maybeAccount) => decodeComplianceReport(maybeAccount));
}
function getCredentialDiscriminatorBytes() {
  return fixEncoderSize2(getBytesEncoder(), 8).encode(CREDENTIAL_DISCRIMINATOR);
}
function getCredentialEncoder() {
  return transformEncoder2(getStructEncoder([
    ["discriminator", fixEncoderSize2(getBytesEncoder(), 8)],
    ["template", getAddressEncoder2()],
    ["subject", getAddressEncoder2()],
    ["issuer", getAddressEncoder2()],
    ["credentialId", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["subjectDataHash", fixEncoderSize2(getBytesEncoder(), 32)],
    [
      "subjectDataUri",
      addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())
    ],
    ["status", getCredentialStatusEncoder()],
    ["signature", fixEncoderSize2(getBytesEncoder(), 64)],
    ["issuedAt", getI64Encoder()],
    ["expiresAt", getOptionEncoder(getI64Encoder())],
    ["revokedAt", getOptionEncoder(getI64Encoder())],
    ["crossChainStatus", getCrossChainStatusEncoder()],
    [
      "crossmintCredentialId",
      getOptionEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    ["sourceAccount", getOptionEncoder(getAddressEncoder2())],
    ["bump", getU8Encoder()]
  ]), (value) => ({ ...value, discriminator: CREDENTIAL_DISCRIMINATOR }));
}
function getCredentialDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize2(getBytesDecoder(), 8)],
    ["template", getAddressDecoder2()],
    ["subject", getAddressDecoder2()],
    ["issuer", getAddressDecoder2()],
    ["credentialId", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["subjectDataHash", fixDecoderSize2(getBytesDecoder(), 32)],
    ["subjectDataUri", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["status", getCredentialStatusDecoder()],
    ["signature", fixDecoderSize2(getBytesDecoder(), 64)],
    ["issuedAt", getI64Decoder()],
    ["expiresAt", getOptionDecoder(getI64Decoder())],
    ["revokedAt", getOptionDecoder(getI64Decoder())],
    ["crossChainStatus", getCrossChainStatusDecoder()],
    [
      "crossmintCredentialId",
      getOptionDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    ["sourceAccount", getOptionDecoder(getAddressDecoder2())],
    ["bump", getU8Decoder()]
  ]);
}
function getCredentialCodec() {
  return combineCodec2(getCredentialEncoder(), getCredentialDecoder());
}
function decodeCredential(encodedAccount) {
  return decodeAccount(encodedAccount, getCredentialDecoder());
}
async function fetchCredential(rpc2, address3, config) {
  const maybeAccount = await fetchMaybeCredential(rpc2, address3, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeCredential(rpc2, address3, config) {
  const maybeAccount = await fetchEncodedAccount(rpc2, address3, config);
  return decodeCredential(maybeAccount);
}
async function fetchAllCredential(rpc2, addresses2, config) {
  const maybeAccounts = await fetchAllMaybeCredential(rpc2, addresses2, config);
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeCredential(rpc2, addresses2, config) {
  const maybeAccounts = await fetchEncodedAccounts(rpc2, addresses2, config);
  return maybeAccounts.map((maybeAccount) => decodeCredential(maybeAccount));
}
function getCredentialTemplateDiscriminatorBytes() {
  return fixEncoderSize2(getBytesEncoder(), 8).encode(CREDENTIAL_TEMPLATE_DISCRIMINATOR);
}
function getCredentialTemplateEncoder() {
  return transformEncoder2(getStructEncoder([
    ["discriminator", fixEncoderSize2(getBytesEncoder(), 8)],
    ["credentialType", getAddressEncoder2()],
    ["name", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["imageUri", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["issuer", getAddressEncoder2()],
    ["isActive", getBooleanEncoder()],
    ["totalIssued", getU64Encoder()],
    ["createdAt", getI64Encoder()],
    [
      "crossmintTemplateId",
      getOptionEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    ["bump", getU8Encoder()]
  ]), (value) => ({ ...value, discriminator: CREDENTIAL_TEMPLATE_DISCRIMINATOR }));
}
function getCredentialTemplateDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize2(getBytesDecoder(), 8)],
    ["credentialType", getAddressDecoder2()],
    ["name", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["imageUri", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["issuer", getAddressDecoder2()],
    ["isActive", getBooleanDecoder()],
    ["totalIssued", getU64Decoder()],
    ["createdAt", getI64Decoder()],
    [
      "crossmintTemplateId",
      getOptionDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    ["bump", getU8Decoder()]
  ]);
}
function getCredentialTemplateCodec() {
  return combineCodec2(getCredentialTemplateEncoder(), getCredentialTemplateDecoder());
}
function decodeCredentialTemplate(encodedAccount) {
  return decodeAccount(encodedAccount, getCredentialTemplateDecoder());
}
async function fetchCredentialTemplate(rpc2, address3, config) {
  const maybeAccount = await fetchMaybeCredentialTemplate(rpc2, address3, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeCredentialTemplate(rpc2, address3, config) {
  const maybeAccount = await fetchEncodedAccount(rpc2, address3, config);
  return decodeCredentialTemplate(maybeAccount);
}
async function fetchAllCredentialTemplate(rpc2, addresses2, config) {
  const maybeAccounts = await fetchAllMaybeCredentialTemplate(rpc2, addresses2, config);
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeCredentialTemplate(rpc2, addresses2, config) {
  const maybeAccounts = await fetchEncodedAccounts(rpc2, addresses2, config);
  return maybeAccounts.map((maybeAccount) => decodeCredentialTemplate(maybeAccount));
}
function getCredentialTypeDiscriminatorBytes() {
  return fixEncoderSize2(getBytesEncoder(), 8).encode(CREDENTIAL_TYPE_DISCRIMINATOR);
}
function getCredentialTypeEncoder() {
  return transformEncoder2(getStructEncoder([
    ["discriminator", fixEncoderSize2(getBytesEncoder(), 8)],
    ["authority", getAddressEncoder2()],
    ["name", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["kind", getCredentialKindEncoder()],
    ["schemaUri", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["description", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["isActive", getBooleanEncoder()],
    ["totalIssued", getU64Encoder()],
    ["createdAt", getI64Encoder()],
    ["bump", getU8Encoder()]
  ]), (value) => ({ ...value, discriminator: CREDENTIAL_TYPE_DISCRIMINATOR }));
}
function getCredentialTypeDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize2(getBytesDecoder(), 8)],
    ["authority", getAddressDecoder2()],
    ["name", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["kind", getCredentialKindDecoder()],
    ["schemaUri", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["description", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["isActive", getBooleanDecoder()],
    ["totalIssued", getU64Decoder()],
    ["createdAt", getI64Decoder()],
    ["bump", getU8Decoder()]
  ]);
}
function getCredentialTypeCodec() {
  return combineCodec2(getCredentialTypeEncoder(), getCredentialTypeDecoder());
}
function decodeCredentialType(encodedAccount) {
  return decodeAccount(encodedAccount, getCredentialTypeDecoder());
}
async function fetchCredentialType(rpc2, address3, config) {
  const maybeAccount = await fetchMaybeCredentialType(rpc2, address3, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeCredentialType(rpc2, address3, config) {
  const maybeAccount = await fetchEncodedAccount(rpc2, address3, config);
  return decodeCredentialType(maybeAccount);
}
async function fetchAllCredentialType(rpc2, addresses2, config) {
  const maybeAccounts = await fetchAllMaybeCredentialType(rpc2, addresses2, config);
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeCredentialType(rpc2, addresses2, config) {
  const maybeAccounts = await fetchEncodedAccounts(rpc2, addresses2, config);
  return maybeAccounts.map((maybeAccount) => decodeCredentialType(maybeAccount));
}
function getDidDocumentDiscriminatorBytes() {
  return fixEncoderSize2(getBytesEncoder(), 8).encode(DID_DOCUMENT_DISCRIMINATOR);
}
function getDidDocumentEncoder() {
  return transformEncoder2(getStructEncoder([
    ["discriminator", fixEncoderSize2(getBytesEncoder(), 8)],
    ["did", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["controller", getAddressEncoder2()],
    ["verificationMethods", getArrayEncoder(getVerificationMethodEncoder())],
    ["serviceEndpoints", getArrayEncoder(getServiceEndpointEncoder())],
    [
      "context",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    [
      "alsoKnownAs",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    ["createdAt", getI64Encoder()],
    ["updatedAt", getI64Encoder()],
    ["version", getU32Encoder()],
    ["deactivated", getBooleanEncoder()],
    ["deactivatedAt", getOptionEncoder(getI64Encoder())],
    ["bump", getU8Encoder()]
  ]), (value) => ({ ...value, discriminator: DID_DOCUMENT_DISCRIMINATOR }));
}
function getDidDocumentDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize2(getBytesDecoder(), 8)],
    ["did", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["controller", getAddressDecoder2()],
    ["verificationMethods", getArrayDecoder(getVerificationMethodDecoder())],
    ["serviceEndpoints", getArrayDecoder(getServiceEndpointDecoder())],
    [
      "context",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    [
      "alsoKnownAs",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    ["createdAt", getI64Decoder()],
    ["updatedAt", getI64Decoder()],
    ["version", getU32Decoder()],
    ["deactivated", getBooleanDecoder()],
    ["deactivatedAt", getOptionDecoder(getI64Decoder())],
    ["bump", getU8Decoder()]
  ]);
}
function getDidDocumentCodec() {
  return combineCodec2(getDidDocumentEncoder(), getDidDocumentDecoder());
}
function decodeDidDocument(encodedAccount) {
  return decodeAccount(encodedAccount, getDidDocumentDecoder());
}
async function fetchDidDocument(rpc2, address3, config) {
  const maybeAccount = await fetchMaybeDidDocument(rpc2, address3, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeDidDocument(rpc2, address3, config) {
  const maybeAccount = await fetchEncodedAccount(rpc2, address3, config);
  return decodeDidDocument(maybeAccount);
}
async function fetchAllDidDocument(rpc2, addresses2, config) {
  const maybeAccounts = await fetchAllMaybeDidDocument(rpc2, addresses2, config);
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeDidDocument(rpc2, addresses2, config) {
  const maybeAccounts = await fetchEncodedAccounts(rpc2, addresses2, config);
  return maybeAccounts.map((maybeAccount) => decodeDidDocument(maybeAccount));
}
function getExternalIdMappingDiscriminatorBytes() {
  return fixEncoderSize2(getBytesEncoder(), 8).encode(EXTERNAL_ID_MAPPING_DISCRIMINATOR);
}
function getExternalIdMappingEncoder() {
  return transformEncoder2(getStructEncoder([
    ["discriminator", fixEncoderSize2(getBytesEncoder(), 8)],
    ["ghostPubkey", getAddressEncoder2()],
    ["platform", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["externalId", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["createdAt", getI64Encoder()],
    ["verified", getBooleanEncoder()],
    ["verifiedAt", getOptionEncoder(getI64Encoder())],
    ["bump", getU8Encoder()]
  ]), (value) => ({ ...value, discriminator: EXTERNAL_ID_MAPPING_DISCRIMINATOR }));
}
function getExternalIdMappingDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize2(getBytesDecoder(), 8)],
    ["ghostPubkey", getAddressDecoder2()],
    ["platform", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["externalId", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["createdAt", getI64Decoder()],
    ["verified", getBooleanDecoder()],
    ["verifiedAt", getOptionDecoder(getI64Decoder())],
    ["bump", getU8Decoder()]
  ]);
}
function getExternalIdMappingCodec() {
  return combineCodec2(getExternalIdMappingEncoder(), getExternalIdMappingDecoder());
}
function decodeExternalIdMapping(encodedAccount) {
  return decodeAccount(encodedAccount, getExternalIdMappingDecoder());
}
async function fetchExternalIdMapping(rpc2, address3, config) {
  const maybeAccount = await fetchMaybeExternalIdMapping(rpc2, address3, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeExternalIdMapping(rpc2, address3, config) {
  const maybeAccount = await fetchEncodedAccount(rpc2, address3, config);
  return decodeExternalIdMapping(maybeAccount);
}
async function fetchAllExternalIdMapping(rpc2, addresses2, config) {
  const maybeAccounts = await fetchAllMaybeExternalIdMapping(rpc2, addresses2, config);
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeExternalIdMapping(rpc2, addresses2, config) {
  const maybeAccounts = await fetchEncodedAccounts(rpc2, addresses2, config);
  return maybeAccounts.map((maybeAccount) => decodeExternalIdMapping(maybeAccount));
}
function getGhostProtectEscrowDiscriminatorBytes() {
  return fixEncoderSize2(getBytesEncoder(), 8).encode(GHOST_PROTECT_ESCROW_DISCRIMINATOR);
}
function getGhostProtectEscrowEncoder() {
  return transformEncoder2(getStructEncoder([
    ["discriminator", fixEncoderSize2(getBytesEncoder(), 8)],
    ["escrowId", getU64Encoder()],
    ["client", getAddressEncoder2()],
    ["agent", getAddressEncoder2()],
    ["amount", getU64Encoder()],
    ["tokenMint", getAddressEncoder2()],
    ["status", getEscrowStatusEncoder()],
    [
      "jobDescription",
      addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())
    ],
    [
      "deliveryProof",
      getOptionEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    ["deadline", getI64Encoder()],
    ["createdAt", getI64Encoder()],
    ["completedAt", getOptionEncoder(getI64Encoder())],
    [
      "disputeReason",
      getOptionEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    ["arbitratorDecision", getOptionEncoder(getArbitratorDecisionEncoder())],
    ["bump", getU8Encoder()]
  ]), (value) => ({
    ...value,
    discriminator: GHOST_PROTECT_ESCROW_DISCRIMINATOR
  }));
}
function getGhostProtectEscrowDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize2(getBytesDecoder(), 8)],
    ["escrowId", getU64Decoder()],
    ["client", getAddressDecoder2()],
    ["agent", getAddressDecoder2()],
    ["amount", getU64Decoder()],
    ["tokenMint", getAddressDecoder2()],
    ["status", getEscrowStatusDecoder()],
    ["jobDescription", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    [
      "deliveryProof",
      getOptionDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    ["deadline", getI64Decoder()],
    ["createdAt", getI64Decoder()],
    ["completedAt", getOptionDecoder(getI64Decoder())],
    [
      "disputeReason",
      getOptionDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    ["arbitratorDecision", getOptionDecoder(getArbitratorDecisionDecoder())],
    ["bump", getU8Decoder()]
  ]);
}
function getGhostProtectEscrowCodec() {
  return combineCodec2(getGhostProtectEscrowEncoder(), getGhostProtectEscrowDecoder());
}
function decodeGhostProtectEscrow(encodedAccount) {
  return decodeAccount(encodedAccount, getGhostProtectEscrowDecoder());
}
async function fetchGhostProtectEscrow(rpc2, address3, config) {
  const maybeAccount = await fetchMaybeGhostProtectEscrow(rpc2, address3, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeGhostProtectEscrow(rpc2, address3, config) {
  const maybeAccount = await fetchEncodedAccount(rpc2, address3, config);
  return decodeGhostProtectEscrow(maybeAccount);
}
async function fetchAllGhostProtectEscrow(rpc2, addresses2, config) {
  const maybeAccounts = await fetchAllMaybeGhostProtectEscrow(rpc2, addresses2, config);
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeGhostProtectEscrow(rpc2, addresses2, config) {
  const maybeAccounts = await fetchEncodedAccounts(rpc2, addresses2, config);
  return maybeAccounts.map((maybeAccount) => decodeGhostProtectEscrow(maybeAccount));
}
function getGovernanceProposalDiscriminatorBytes() {
  return fixEncoderSize2(getBytesEncoder(), 8).encode(GOVERNANCE_PROPOSAL_DISCRIMINATOR);
}
function getGovernanceProposalEncoder() {
  return transformEncoder2(getStructEncoder([
    ["discriminator", fixEncoderSize2(getBytesEncoder(), 8)],
    ["proposalId", getU64Encoder()],
    ["proposer", getAddressEncoder2()],
    ["title", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["description", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["proposalType", getProposalTypeEncoder()],
    ["createdAt", getI64Encoder()],
    ["votingStartsAt", getI64Encoder()],
    ["votingEndsAt", getI64Encoder()],
    ["executionTimestamp", getOptionEncoder(getI64Encoder())],
    ["status", getProposalStatusEncoder()],
    ["votingResults", getVotingResultsEncoder()],
    ["executionParams", getExecutionParamsEncoder()],
    ["quorumRequirements", getQuorumRequirementsEncoder()],
    ["metadata", getProposalMetadataEncoder()],
    ["reserved", fixEncoderSize2(getBytesEncoder(), 64)]
  ]), (value) => ({ ...value, discriminator: GOVERNANCE_PROPOSAL_DISCRIMINATOR }));
}
function getGovernanceProposalDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize2(getBytesDecoder(), 8)],
    ["proposalId", getU64Decoder()],
    ["proposer", getAddressDecoder2()],
    ["title", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["description", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["proposalType", getProposalTypeDecoder()],
    ["createdAt", getI64Decoder()],
    ["votingStartsAt", getI64Decoder()],
    ["votingEndsAt", getI64Decoder()],
    ["executionTimestamp", getOptionDecoder(getI64Decoder())],
    ["status", getProposalStatusDecoder()],
    ["votingResults", getVotingResultsDecoder()],
    ["executionParams", getExecutionParamsDecoder()],
    ["quorumRequirements", getQuorumRequirementsDecoder()],
    ["metadata", getProposalMetadataDecoder()],
    ["reserved", fixDecoderSize2(getBytesDecoder(), 64)]
  ]);
}
function getGovernanceProposalCodec() {
  return combineCodec2(getGovernanceProposalEncoder(), getGovernanceProposalDecoder());
}
function decodeGovernanceProposal(encodedAccount) {
  return decodeAccount(encodedAccount, getGovernanceProposalDecoder());
}
async function fetchGovernanceProposal(rpc2, address3, config) {
  const maybeAccount = await fetchMaybeGovernanceProposal(rpc2, address3, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeGovernanceProposal(rpc2, address3, config) {
  const maybeAccount = await fetchEncodedAccount(rpc2, address3, config);
  return decodeGovernanceProposal(maybeAccount);
}
async function fetchAllGovernanceProposal(rpc2, addresses2, config) {
  const maybeAccounts = await fetchAllMaybeGovernanceProposal(rpc2, addresses2, config);
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeGovernanceProposal(rpc2, addresses2, config) {
  const maybeAccounts = await fetchEncodedAccounts(rpc2, addresses2, config);
  return maybeAccounts.map((maybeAccount) => decodeGovernanceProposal(maybeAccount));
}
function getMultisigDiscriminatorBytes() {
  return fixEncoderSize2(getBytesEncoder(), 8).encode(MULTISIG_DISCRIMINATOR);
}
function getMultisigEncoder() {
  return transformEncoder2(getStructEncoder([
    ["discriminator", fixEncoderSize2(getBytesEncoder(), 8)],
    ["multisigId", getU64Encoder()],
    ["multisigType", getMultisigTypeEncoder()],
    ["threshold", getU8Encoder()],
    ["signers", getArrayEncoder(getAddressEncoder2())],
    ["owner", getAddressEncoder2()],
    ["createdAt", getI64Encoder()],
    ["updatedAt", getI64Encoder()],
    ["nonce", getU64Encoder()],
    ["pendingTransactions", getArrayEncoder(getPendingTransactionEncoder())],
    ["config", getMultisigConfigEncoder()],
    ["emergencyConfig", getEmergencyConfigEncoder()],
    ["typeConfig", getMultisigTypeConfigEncoder()],
    ["reserved", fixEncoderSize2(getBytesEncoder(), 64)]
  ]), (value) => ({ ...value, discriminator: MULTISIG_DISCRIMINATOR }));
}
function getMultisigDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize2(getBytesDecoder(), 8)],
    ["multisigId", getU64Decoder()],
    ["multisigType", getMultisigTypeDecoder()],
    ["threshold", getU8Decoder()],
    ["signers", getArrayDecoder(getAddressDecoder2())],
    ["owner", getAddressDecoder2()],
    ["createdAt", getI64Decoder()],
    ["updatedAt", getI64Decoder()],
    ["nonce", getU64Decoder()],
    ["pendingTransactions", getArrayDecoder(getPendingTransactionDecoder())],
    ["config", getMultisigConfigDecoder()],
    ["emergencyConfig", getEmergencyConfigDecoder()],
    ["typeConfig", getMultisigTypeConfigDecoder()],
    ["reserved", fixDecoderSize2(getBytesDecoder(), 64)]
  ]);
}
function getMultisigCodec() {
  return combineCodec2(getMultisigEncoder(), getMultisigDecoder());
}
function decodeMultisig(encodedAccount) {
  return decodeAccount(encodedAccount, getMultisigDecoder());
}
async function fetchMultisig(rpc2, address3, config) {
  const maybeAccount = await fetchMaybeMultisig(rpc2, address3, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeMultisig(rpc2, address3, config) {
  const maybeAccount = await fetchEncodedAccount(rpc2, address3, config);
  return decodeMultisig(maybeAccount);
}
async function fetchAllMultisig(rpc2, addresses2, config) {
  const maybeAccounts = await fetchAllMaybeMultisig(rpc2, addresses2, config);
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeMultisig(rpc2, addresses2, config) {
  const maybeAccounts = await fetchEncodedAccounts(rpc2, addresses2, config);
  return maybeAccounts.map((maybeAccount) => decodeMultisig(maybeAccount));
}
function getProtocolConfigDiscriminatorBytes() {
  return fixEncoderSize2(getBytesEncoder(), 8).encode(PROTOCOL_CONFIG_DISCRIMINATOR);
}
function getProtocolConfigEncoder() {
  return transformEncoder2(getStructEncoder([
    ["discriminator", fixEncoderSize2(getBytesEncoder(), 8)],
    ["authority", getAddressEncoder2()],
    ["treasury", getAddressEncoder2()],
    ["buybackPool", getAddressEncoder2()],
    ["moderatorPool", getAddressEncoder2()],
    ["escrowFeeBps", getU16Encoder()],
    ["agentRegistrationFee", getU64Encoder()],
    ["listingFee", getU64Encoder()],
    ["disputeFeeBps", getU16Encoder()],
    ["feesEnabled", getBooleanEncoder()],
    ["updatedAt", getI64Encoder()],
    ["bump", getU8Encoder()],
    ["reserved", fixEncoderSize2(getBytesEncoder(), 64)]
  ]), (value) => ({ ...value, discriminator: PROTOCOL_CONFIG_DISCRIMINATOR }));
}
function getProtocolConfigDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize2(getBytesDecoder(), 8)],
    ["authority", getAddressDecoder2()],
    ["treasury", getAddressDecoder2()],
    ["buybackPool", getAddressDecoder2()],
    ["moderatorPool", getAddressDecoder2()],
    ["escrowFeeBps", getU16Decoder()],
    ["agentRegistrationFee", getU64Decoder()],
    ["listingFee", getU64Decoder()],
    ["disputeFeeBps", getU16Decoder()],
    ["feesEnabled", getBooleanDecoder()],
    ["updatedAt", getI64Decoder()],
    ["bump", getU8Decoder()],
    ["reserved", fixDecoderSize2(getBytesDecoder(), 64)]
  ]);
}
function getProtocolConfigCodec() {
  return combineCodec2(getProtocolConfigEncoder(), getProtocolConfigDecoder());
}
function decodeProtocolConfig(encodedAccount) {
  return decodeAccount(encodedAccount, getProtocolConfigDecoder());
}
async function fetchProtocolConfig(rpc2, address3, config) {
  const maybeAccount = await fetchMaybeProtocolConfig(rpc2, address3, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeProtocolConfig(rpc2, address3, config) {
  const maybeAccount = await fetchEncodedAccount(rpc2, address3, config);
  return decodeProtocolConfig(maybeAccount);
}
async function fetchAllProtocolConfig(rpc2, addresses2, config) {
  const maybeAccounts = await fetchAllMaybeProtocolConfig(rpc2, addresses2, config);
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeProtocolConfig(rpc2, addresses2, config) {
  const maybeAccounts = await fetchEncodedAccounts(rpc2, addresses2, config);
  return maybeAccounts.map((maybeAccount) => decodeProtocolConfig(maybeAccount));
}
function getProtocolConfigSize() {
  return 230;
}
function getRbacConfigDiscriminatorBytes() {
  return fixEncoderSize2(getBytesEncoder(), 8).encode(RBAC_CONFIG_DISCRIMINATOR);
}
function getRbacConfigEncoder() {
  return transformEncoder2(getStructEncoder([
    ["discriminator", fixEncoderSize2(getBytesEncoder(), 8)],
    ["authority", getAddressEncoder2()],
    ["createdAt", getI64Encoder()],
    ["updatedAt", getI64Encoder()],
    ["version", getU8Encoder()],
    ["roles", getArrayEncoder(getRoleEncoder())],
    ["permissions", getArrayEncoder(getPermissionEncoder())],
    ["accessPolicies", getArrayEncoder(getAccessPolicyEncoder())],
    ["securityPolicies", getSecurityPoliciesEncoder()],
    ["auditConfig", getAccessAuditConfigEncoder()],
    ["emergencyAccess", getEmergencyAccessConfigEncoder()],
    ["reserved", fixEncoderSize2(getBytesEncoder(), 128)]
  ]), (value) => ({ ...value, discriminator: RBAC_CONFIG_DISCRIMINATOR }));
}
function getRbacConfigDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize2(getBytesDecoder(), 8)],
    ["authority", getAddressDecoder2()],
    ["createdAt", getI64Decoder()],
    ["updatedAt", getI64Decoder()],
    ["version", getU8Decoder()],
    ["roles", getArrayDecoder(getRoleDecoder())],
    ["permissions", getArrayDecoder(getPermissionDecoder())],
    ["accessPolicies", getArrayDecoder(getAccessPolicyDecoder())],
    ["securityPolicies", getSecurityPoliciesDecoder()],
    ["auditConfig", getAccessAuditConfigDecoder()],
    ["emergencyAccess", getEmergencyAccessConfigDecoder()],
    ["reserved", fixDecoderSize2(getBytesDecoder(), 128)]
  ]);
}
function getRbacConfigCodec() {
  return combineCodec2(getRbacConfigEncoder(), getRbacConfigDecoder());
}
function decodeRbacConfig(encodedAccount) {
  return decodeAccount(encodedAccount, getRbacConfigDecoder());
}
async function fetchRbacConfig(rpc2, address3, config) {
  const maybeAccount = await fetchMaybeRbacConfig(rpc2, address3, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeRbacConfig(rpc2, address3, config) {
  const maybeAccount = await fetchEncodedAccount(rpc2, address3, config);
  return decodeRbacConfig(maybeAccount);
}
async function fetchAllRbacConfig(rpc2, addresses2, config) {
  const maybeAccounts = await fetchAllMaybeRbacConfig(rpc2, addresses2, config);
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeRbacConfig(rpc2, addresses2, config) {
  const maybeAccounts = await fetchEncodedAccounts(rpc2, addresses2, config);
  return maybeAccounts.map((maybeAccount) => decodeRbacConfig(maybeAccount));
}
function getReentrancyGuardDiscriminatorBytes() {
  return fixEncoderSize2(getBytesEncoder(), 8).encode(REENTRANCY_GUARD_DISCRIMINATOR);
}
function getReentrancyGuardEncoder() {
  return transformEncoder2(getStructEncoder([
    ["discriminator", fixEncoderSize2(getBytesEncoder(), 8)],
    ["state", getReentrancyStateEncoder()],
    ["nonce", getU64Encoder()],
    ["lastInteraction", getI64Encoder()],
    ["authority", getAddressEncoder2()],
    ["bump", getU8Encoder()]
  ]), (value) => ({ ...value, discriminator: REENTRANCY_GUARD_DISCRIMINATOR }));
}
function getReentrancyGuardDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize2(getBytesDecoder(), 8)],
    ["state", getReentrancyStateDecoder()],
    ["nonce", getU64Decoder()],
    ["lastInteraction", getI64Decoder()],
    ["authority", getAddressDecoder2()],
    ["bump", getU8Decoder()]
  ]);
}
function getReentrancyGuardCodec() {
  return combineCodec2(getReentrancyGuardEncoder(), getReentrancyGuardDecoder());
}
function decodeReentrancyGuard(encodedAccount) {
  return decodeAccount(encodedAccount, getReentrancyGuardDecoder());
}
async function fetchReentrancyGuard(rpc2, address3, config) {
  const maybeAccount = await fetchMaybeReentrancyGuard(rpc2, address3, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeReentrancyGuard(rpc2, address3, config) {
  const maybeAccount = await fetchEncodedAccount(rpc2, address3, config);
  return decodeReentrancyGuard(maybeAccount);
}
async function fetchAllReentrancyGuard(rpc2, addresses2, config) {
  const maybeAccounts = await fetchAllMaybeReentrancyGuard(rpc2, addresses2, config);
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeReentrancyGuard(rpc2, addresses2, config) {
  const maybeAccounts = await fetchEncodedAccounts(rpc2, addresses2, config);
  return maybeAccounts.map((maybeAccount) => decodeReentrancyGuard(maybeAccount));
}
function getReentrancyGuardSize() {
  return 58;
}
function getReputationMetricsDiscriminatorBytes() {
  return fixEncoderSize2(getBytesEncoder(), 8).encode(REPUTATION_METRICS_DISCRIMINATOR);
}
function getReputationMetricsEncoder() {
  return transformEncoder2(getStructEncoder([
    ["discriminator", fixEncoderSize2(getBytesEncoder(), 8)],
    ["agent", getAddressEncoder2()],
    ["successfulPayments", getU64Encoder()],
    ["failedPayments", getU64Encoder()],
    ["totalResponseTime", getU64Encoder()],
    ["responseTimeCount", getU64Encoder()],
    ["totalDisputes", getU32Encoder()],
    ["disputesResolved", getU32Encoder()],
    ["totalRating", getU32Encoder()],
    ["totalRatingsCount", getU32Encoder()],
    ["paymentHistory7d", getArrayEncoder(getU64Encoder(), { size: 7 })],
    ["createdAt", getI64Encoder()],
    ["updatedAt", getI64Encoder()],
    [
      "skillTags",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    [
      "behaviorTags",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    [
      "complianceTags",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    ["tagScores", getArrayEncoder(getTagScoreEncoder())],
    ["tagUpdatedAt", getI64Encoder()],
    ["sourceScores", getArrayEncoder(getSourceScoreEncoder())],
    [
      "primarySource",
      addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())
    ],
    ["lastAggregation", getI64Encoder()],
    [
      "conflictFlags",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    ["bump", getU8Encoder()]
  ]), (value) => ({ ...value, discriminator: REPUTATION_METRICS_DISCRIMINATOR }));
}
function getReputationMetricsDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize2(getBytesDecoder(), 8)],
    ["agent", getAddressDecoder2()],
    ["successfulPayments", getU64Decoder()],
    ["failedPayments", getU64Decoder()],
    ["totalResponseTime", getU64Decoder()],
    ["responseTimeCount", getU64Decoder()],
    ["totalDisputes", getU32Decoder()],
    ["disputesResolved", getU32Decoder()],
    ["totalRating", getU32Decoder()],
    ["totalRatingsCount", getU32Decoder()],
    ["paymentHistory7d", getArrayDecoder(getU64Decoder(), { size: 7 })],
    ["createdAt", getI64Decoder()],
    ["updatedAt", getI64Decoder()],
    [
      "skillTags",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    [
      "behaviorTags",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    [
      "complianceTags",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    ["tagScores", getArrayDecoder(getTagScoreDecoder())],
    ["tagUpdatedAt", getI64Decoder()],
    ["sourceScores", getArrayDecoder(getSourceScoreDecoder())],
    ["primarySource", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["lastAggregation", getI64Decoder()],
    [
      "conflictFlags",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    ["bump", getU8Decoder()]
  ]);
}
function getReputationMetricsCodec() {
  return combineCodec2(getReputationMetricsEncoder(), getReputationMetricsDecoder());
}
function decodeReputationMetrics(encodedAccount) {
  return decodeAccount(encodedAccount, getReputationMetricsDecoder());
}
async function fetchReputationMetrics(rpc2, address3, config) {
  const maybeAccount = await fetchMaybeReputationMetrics(rpc2, address3, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeReputationMetrics(rpc2, address3, config) {
  const maybeAccount = await fetchEncodedAccount(rpc2, address3, config);
  return decodeReputationMetrics(maybeAccount);
}
async function fetchAllReputationMetrics(rpc2, addresses2, config) {
  const maybeAccounts = await fetchAllMaybeReputationMetrics(rpc2, addresses2, config);
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeReputationMetrics(rpc2, addresses2, config) {
  const maybeAccounts = await fetchEncodedAccounts(rpc2, addresses2, config);
  return maybeAccounts.map((maybeAccount) => decodeReputationMetrics(maybeAccount));
}
function getStakingAccountDiscriminatorBytes() {
  return fixEncoderSize2(getBytesEncoder(), 8).encode(STAKING_ACCOUNT_DISCRIMINATOR);
}
function getStakingAccountEncoder() {
  return transformEncoder2(getStructEncoder([
    ["discriminator", fixEncoderSize2(getBytesEncoder(), 8)],
    ["owner", getAddressEncoder2()],
    ["amountStaked", getU64Encoder()],
    ["stakedAt", getI64Encoder()],
    ["lockDuration", getI64Encoder()],
    ["unlockAt", getI64Encoder()],
    ["reputationBoostBps", getU16Encoder()],
    ["hasVerifiedBadge", getBooleanEncoder()],
    ["hasPremiumBenefits", getBooleanEncoder()],
    ["totalSlashed", getU64Encoder()],
    ["tier", getAccessTierEncoder()],
    ["apiCallsRemaining", getU32Encoder()],
    ["lastQuotaReset", getI64Encoder()],
    ["votingPower", getU64Encoder()],
    ["bump", getU8Encoder()]
  ]), (value) => ({ ...value, discriminator: STAKING_ACCOUNT_DISCRIMINATOR }));
}
function getStakingAccountDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize2(getBytesDecoder(), 8)],
    ["owner", getAddressDecoder2()],
    ["amountStaked", getU64Decoder()],
    ["stakedAt", getI64Decoder()],
    ["lockDuration", getI64Decoder()],
    ["unlockAt", getI64Decoder()],
    ["reputationBoostBps", getU16Decoder()],
    ["hasVerifiedBadge", getBooleanDecoder()],
    ["hasPremiumBenefits", getBooleanDecoder()],
    ["totalSlashed", getU64Decoder()],
    ["tier", getAccessTierDecoder()],
    ["apiCallsRemaining", getU32Decoder()],
    ["lastQuotaReset", getI64Decoder()],
    ["votingPower", getU64Decoder()],
    ["bump", getU8Decoder()]
  ]);
}
function getStakingAccountCodec() {
  return combineCodec2(getStakingAccountEncoder(), getStakingAccountDecoder());
}
function decodeStakingAccount(encodedAccount) {
  return decodeAccount(encodedAccount, getStakingAccountDecoder());
}
async function fetchStakingAccount(rpc2, address3, config) {
  const maybeAccount = await fetchMaybeStakingAccount(rpc2, address3, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeStakingAccount(rpc2, address3, config) {
  const maybeAccount = await fetchEncodedAccount(rpc2, address3, config);
  return decodeStakingAccount(maybeAccount);
}
async function fetchAllStakingAccount(rpc2, addresses2, config) {
  const maybeAccounts = await fetchAllMaybeStakingAccount(rpc2, addresses2, config);
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeStakingAccount(rpc2, addresses2, config) {
  const maybeAccounts = await fetchEncodedAccounts(rpc2, addresses2, config);
  return maybeAccounts.map((maybeAccount) => decodeStakingAccount(maybeAccount));
}
function getStakingAccountSize() {
  return 106;
}
function getStakingConfigDiscriminatorBytes() {
  return fixEncoderSize2(getBytesEncoder(), 8).encode(STAKING_CONFIG_DISCRIMINATOR);
}
function getStakingConfigEncoder() {
  return transformEncoder2(getStructEncoder([
    ["discriminator", fixEncoderSize2(getBytesEncoder(), 8)],
    ["authority", getAddressEncoder2()],
    ["minStake", getU64Encoder()],
    ["minLockDuration", getI64Encoder()],
    ["fraudSlashBps", getU16Encoder()],
    ["disputeSlashBps", getU16Encoder()],
    ["treasury", getAddressEncoder2()],
    ["bump", getU8Encoder()]
  ]), (value) => ({ ...value, discriminator: STAKING_CONFIG_DISCRIMINATOR }));
}
function getStakingConfigDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize2(getBytesDecoder(), 8)],
    ["authority", getAddressDecoder2()],
    ["minStake", getU64Decoder()],
    ["minLockDuration", getI64Decoder()],
    ["fraudSlashBps", getU16Decoder()],
    ["disputeSlashBps", getU16Decoder()],
    ["treasury", getAddressDecoder2()],
    ["bump", getU8Decoder()]
  ]);
}
function getStakingConfigCodec() {
  return combineCodec2(getStakingConfigEncoder(), getStakingConfigDecoder());
}
function decodeStakingConfig(encodedAccount) {
  return decodeAccount(encodedAccount, getStakingConfigDecoder());
}
async function fetchStakingConfig(rpc2, address3, config) {
  const maybeAccount = await fetchMaybeStakingConfig(rpc2, address3, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeStakingConfig(rpc2, address3, config) {
  const maybeAccount = await fetchEncodedAccount(rpc2, address3, config);
  return decodeStakingConfig(maybeAccount);
}
async function fetchAllStakingConfig(rpc2, addresses2, config) {
  const maybeAccounts = await fetchAllMaybeStakingConfig(rpc2, addresses2, config);
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeStakingConfig(rpc2, addresses2, config) {
  const maybeAccounts = await fetchEncodedAccounts(rpc2, addresses2, config);
  return maybeAccounts.map((maybeAccount) => decodeStakingConfig(maybeAccount));
}
function getStakingConfigSize() {
  return 93;
}
function getUserRegistryDiscriminatorBytes() {
  return fixEncoderSize2(getBytesEncoder(), 8).encode(USER_REGISTRY_DISCRIMINATOR);
}
function getUserRegistryEncoder() {
  return transformEncoder2(getStructEncoder([
    ["discriminator", fixEncoderSize2(getBytesEncoder(), 8)],
    ["user", getAddressEncoder2()],
    ["agentCount", getU16Encoder()],
    ["listingCount", getU16Encoder()],
    ["workOrderCount", getU16Encoder()],
    ["channelCount", getU16Encoder()],
    ["totalVolumeTraded", getU64Encoder()],
    ["lastActivity", getI64Encoder()],
    ["createdAt", getI64Encoder()],
    ["isRateLimited", getBooleanEncoder()],
    ["rateLimitExpiry", getI64Encoder()],
    ["lastExtensionRegistration", getI64Encoder()],
    ["lastDisputeFiling", getI64Encoder()],
    ["lastEvidenceSubmission", getI64Encoder()],
    ["lastBatchExecution", getI64Encoder()],
    ["lastDashboardUpdate", getI64Encoder()],
    ["lastBulkDealCreation", getI64Encoder()],
    ["lastDashboardCreation", getI64Encoder()],
    ["bump", getU8Encoder()]
  ]), (value) => ({ ...value, discriminator: USER_REGISTRY_DISCRIMINATOR }));
}
function getUserRegistryDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize2(getBytesDecoder(), 8)],
    ["user", getAddressDecoder2()],
    ["agentCount", getU16Decoder()],
    ["listingCount", getU16Decoder()],
    ["workOrderCount", getU16Decoder()],
    ["channelCount", getU16Decoder()],
    ["totalVolumeTraded", getU64Decoder()],
    ["lastActivity", getI64Decoder()],
    ["createdAt", getI64Decoder()],
    ["isRateLimited", getBooleanDecoder()],
    ["rateLimitExpiry", getI64Decoder()],
    ["lastExtensionRegistration", getI64Decoder()],
    ["lastDisputeFiling", getI64Decoder()],
    ["lastEvidenceSubmission", getI64Decoder()],
    ["lastBatchExecution", getI64Decoder()],
    ["lastDashboardUpdate", getI64Decoder()],
    ["lastBulkDealCreation", getI64Decoder()],
    ["lastDashboardCreation", getI64Decoder()],
    ["bump", getU8Decoder()]
  ]);
}
function getUserRegistryCodec() {
  return combineCodec2(getUserRegistryEncoder(), getUserRegistryDecoder());
}
function decodeUserRegistry(encodedAccount) {
  return decodeAccount(encodedAccount, getUserRegistryDecoder());
}
async function fetchUserRegistry(rpc2, address3, config) {
  const maybeAccount = await fetchMaybeUserRegistry(rpc2, address3, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeUserRegistry(rpc2, address3, config) {
  const maybeAccount = await fetchEncodedAccount(rpc2, address3, config);
  return decodeUserRegistry(maybeAccount);
}
async function fetchAllUserRegistry(rpc2, addresses2, config) {
  const maybeAccounts = await fetchAllMaybeUserRegistry(rpc2, addresses2, config);
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeUserRegistry(rpc2, addresses2, config) {
  const maybeAccounts = await fetchEncodedAccounts(rpc2, addresses2, config);
  return maybeAccounts.map((maybeAccount) => decodeUserRegistry(maybeAccount));
}
function getUserRegistrySize() {
  return 138;
}
function getGhostspeakMarketplaceErrorMessage(code) {
  if (true) {
    return ghostspeakMarketplaceErrorMessages[code];
  }
  return "Error message not available in production bundles.";
}
function isGhostspeakMarketplaceError(error, transactionMessage, code) {
  return isProgramError(error, transactionMessage, GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS, code);
}
function getActivateAgentDiscriminatorBytes() {
  return fixEncoderSize2(getBytesEncoder(), 8).encode(ACTIVATE_AGENT_DISCRIMINATOR);
}
function getActivateAgentInstructionDataEncoder() {
  return transformEncoder2(getStructEncoder([
    ["discriminator", fixEncoderSize2(getBytesEncoder(), 8)],
    ["agentId", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())]
  ]), (value) => ({ ...value, discriminator: ACTIVATE_AGENT_DISCRIMINATOR }));
}
function getActivateAgentInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize2(getBytesDecoder(), 8)],
    ["agentId", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())]
  ]);
}
function getActivateAgentInstructionDataCodec() {
  return combineCodec2(getActivateAgentInstructionDataEncoder(), getActivateAgentInstructionDataDecoder());
}
async function getActivateAgentInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    agentAccount: { value: input.agentAccount ?? null, isWritable: true },
    signer: { value: input.signer ?? null, isWritable: true },
    clock: { value: input.clock ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.agentAccount.value) {
    accounts2.agentAccount.value = await getProgramDerivedAddress2({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([97, 103, 101, 110, 116])),
        getAddressEncoder2().encode(expectAddress(accounts2.signer.value)),
        getUtf8Encoder().encode(expectSome(args.agentId))
      ]
    });
  }
  if (!accounts2.clock.value) {
    accounts2.clock.value = "SysvarC1ock11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.agentAccount),
      getAccountMeta(accounts2.signer),
      getAccountMeta(accounts2.clock)
    ],
    data: getActivateAgentInstructionDataEncoder().encode(args),
    programAddress
  });
}
function getActivateAgentInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    agentAccount: { value: input.agentAccount ?? null, isWritable: true },
    signer: { value: input.signer ?? null, isWritable: true },
    clock: { value: input.clock ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.clock.value) {
    accounts2.clock.value = "SysvarC1ock11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.agentAccount),
      getAccountMeta(accounts2.signer),
      getAccountMeta(accounts2.clock)
    ],
    data: getActivateAgentInstructionDataEncoder().encode(args),
    programAddress
  });
}
function parseActivateAgentInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      agentAccount: getNextAccount(),
      signer: getNextAccount(),
      clock: getNextAccount()
    },
    data: getActivateAgentInstructionDataDecoder().decode(instruction.data)
  };
}
function getApproveDeliveryDiscriminatorBytes() {
  return fixEncoderSize2(getBytesEncoder(), 8).encode(APPROVE_DELIVERY_DISCRIMINATOR);
}
function getApproveDeliveryInstructionDataEncoder() {
  return transformEncoder2(getStructEncoder([["discriminator", fixEncoderSize2(getBytesEncoder(), 8)]]), (value) => ({ ...value, discriminator: APPROVE_DELIVERY_DISCRIMINATOR }));
}
function getApproveDeliveryInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize2(getBytesDecoder(), 8)]
  ]);
}
function getApproveDeliveryInstructionDataCodec() {
  return combineCodec2(getApproveDeliveryInstructionDataEncoder(), getApproveDeliveryInstructionDataDecoder());
}
function getApproveDeliveryInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    escrow: { value: input.escrow ?? null, isWritable: true },
    escrowVault: { value: input.escrowVault ?? null, isWritable: true },
    agentTokenAccount: {
      value: input.agentTokenAccount ?? null,
      isWritable: true
    },
    client: { value: input.client ?? null, isWritable: false },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  if (!accounts2.tokenProgram.value) {
    accounts2.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.escrow),
      getAccountMeta(accounts2.escrowVault),
      getAccountMeta(accounts2.agentTokenAccount),
      getAccountMeta(accounts2.client),
      getAccountMeta(accounts2.tokenProgram)
    ],
    data: getApproveDeliveryInstructionDataEncoder().encode({}),
    programAddress
  });
}
function parseApproveDeliveryInstruction(instruction) {
  if (instruction.accounts.length < 5) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      escrow: getNextAccount(),
      escrowVault: getNextAccount(),
      agentTokenAccount: getNextAccount(),
      client: getNextAccount(),
      tokenProgram: getNextAccount()
    },
    data: getApproveDeliveryInstructionDataDecoder().decode(instruction.data)
  };
}
function getArbitrateDisputeDiscriminatorBytes() {
  return fixEncoderSize2(getBytesEncoder(), 8).encode(ARBITRATE_DISPUTE_DISCRIMINATOR);
}
function getArbitrateDisputeInstructionDataEncoder() {
  return transformEncoder2(getStructEncoder([
    ["discriminator", fixEncoderSize2(getBytesEncoder(), 8)],
    ["decision", getArbitratorDecisionEncoder()]
  ]), (value) => ({ ...value, discriminator: ARBITRATE_DISPUTE_DISCRIMINATOR }));
}
function getArbitrateDisputeInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize2(getBytesDecoder(), 8)],
    ["decision", getArbitratorDecisionDecoder()]
  ]);
}
function getArbitrateDisputeInstructionDataCodec() {
  return combineCodec2(getArbitrateDisputeInstructionDataEncoder(), getArbitrateDisputeInstructionDataDecoder());
}
function getArbitrateDisputeInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    escrow: { value: input.escrow ?? null, isWritable: true },
    escrowVault: { value: input.escrowVault ?? null, isWritable: true },
    agentTokenAccount: {
      value: input.agentTokenAccount ?? null,
      isWritable: true
    },
    clientTokenAccount: {
      value: input.clientTokenAccount ?? null,
      isWritable: true
    },
    agentStaking: { value: input.agentStaking ?? null, isWritable: true },
    arbitrator: { value: input.arbitrator ?? null, isWritable: false },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.tokenProgram.value) {
    accounts2.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.escrow),
      getAccountMeta(accounts2.escrowVault),
      getAccountMeta(accounts2.agentTokenAccount),
      getAccountMeta(accounts2.clientTokenAccount),
      getAccountMeta(accounts2.agentStaking),
      getAccountMeta(accounts2.arbitrator),
      getAccountMeta(accounts2.tokenProgram)
    ],
    data: getArbitrateDisputeInstructionDataEncoder().encode(args),
    programAddress
  });
}
function parseArbitrateDisputeInstruction(instruction) {
  if (instruction.accounts.length < 7) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      escrow: getNextAccount(),
      escrowVault: getNextAccount(),
      agentTokenAccount: getNextAccount(),
      clientTokenAccount: getNextAccount(),
      agentStaking: getNextAccount(),
      arbitrator: getNextAccount(),
      tokenProgram: getNextAccount()
    },
    data: getArbitrateDisputeInstructionDataDecoder().decode(instruction.data)
  };
}
function getAutoCreateGhostDiscriminatorBytes() {
  return fixEncoderSize2(getBytesEncoder(), 8).encode(AUTO_CREATE_GHOST_DISCRIMINATOR);
}
function getAutoCreateGhostInstructionDataEncoder() {
  return transformEncoder2(getStructEncoder([
    ["discriminator", fixEncoderSize2(getBytesEncoder(), 8)],
    ["paymentAddress", getAddressEncoder2()],
    [
      "firstTxSignature",
      addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())
    ],
    [
      "discoverySource",
      addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())
    ],
    ["initialGhostScore", getOptionEncoder(getU64Encoder())]
  ]), (value) => ({ ...value, discriminator: AUTO_CREATE_GHOST_DISCRIMINATOR }));
}
function getAutoCreateGhostInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize2(getBytesDecoder(), 8)],
    ["paymentAddress", getAddressDecoder2()],
    [
      "firstTxSignature",
      addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())
    ],
    [
      "discoverySource",
      addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())
    ],
    ["initialGhostScore", getOptionDecoder(getU64Decoder())]
  ]);
}
function getAutoCreateGhostInstructionDataCodec() {
  return combineCodec2(getAutoCreateGhostInstructionDataEncoder(), getAutoCreateGhostInstructionDataDecoder());
}
async function getAutoCreateGhostInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    agentAccount: { value: input.agentAccount ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.agentAccount.value) {
    accounts2.agentAccount.value = await getProgramDerivedAddress2({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([97, 103, 101, 110, 116])),
        getAddressEncoder2().encode(expectSome(args.paymentAddress))
      ]
    });
  }
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.agentAccount),
      getAccountMeta(accounts2.authority),
      getAccountMeta(accounts2.systemProgram)
    ],
    data: getAutoCreateGhostInstructionDataEncoder().encode(args),
    programAddress
  });
}
function getAutoCreateGhostInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    agentAccount: { value: input.agentAccount ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.agentAccount),
      getAccountMeta(accounts2.authority),
      getAccountMeta(accounts2.systemProgram)
    ],
    data: getAutoCreateGhostInstructionDataEncoder().encode(args),
    programAddress
  });
}
function parseAutoCreateGhostInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      agentAccount: getNextAccount(),
      authority: getNextAccount(),
      systemProgram: getNextAccount()
    },
    data: getAutoCreateGhostInstructionDataDecoder().decode(instruction.data)
  };
}
function getClaimGhostDiscriminatorBytes() {
  return fixEncoderSize2(getBytesEncoder(), 8).encode(CLAIM_GHOST_DISCRIMINATOR);
}
function getClaimGhostInstructionDataEncoder() {
  return transformEncoder2(getStructEncoder([
    ["discriminator", fixEncoderSize2(getBytesEncoder(), 8)],
    ["sasCredential", getAddressEncoder2()],
    ["sasSchema", getAddressEncoder2()],
    [
      "ipfsMetadataUri",
      getOptionEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    ["network", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())]
  ]), (value) => ({ ...value, discriminator: CLAIM_GHOST_DISCRIMINATOR }));
}
function getClaimGhostInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize2(getBytesDecoder(), 8)],
    ["sasCredential", getAddressDecoder2()],
    ["sasSchema", getAddressDecoder2()],
    [
      "ipfsMetadataUri",
      getOptionDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    ["network", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())]
  ]);
}
function getClaimGhostInstructionDataCodec() {
  return combineCodec2(getClaimGhostInstructionDataEncoder(), getClaimGhostInstructionDataDecoder());
}
function getClaimGhostInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    agentAccount: { value: input.agentAccount ?? null, isWritable: true },
    didDocument: { value: input.didDocument ?? null, isWritable: true },
    sasAttestation: { value: input.sasAttestation ?? null, isWritable: false },
    claimer: { value: input.claimer ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.agentAccount),
      getAccountMeta(accounts2.didDocument),
      getAccountMeta(accounts2.sasAttestation),
      getAccountMeta(accounts2.claimer),
      getAccountMeta(accounts2.systemProgram)
    ],
    data: getClaimGhostInstructionDataEncoder().encode(args),
    programAddress
  });
}
function parseClaimGhostInstruction(instruction) {
  if (instruction.accounts.length < 5) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      agentAccount: getNextAccount(),
      didDocument: getNextAccount(),
      sasAttestation: getNextAccount(),
      claimer: getNextAccount(),
      systemProgram: getNextAccount()
    },
    data: getClaimGhostInstructionDataDecoder().decode(instruction.data)
  };
}
function getCreateCredentialTemplateDiscriminatorBytes() {
  return fixEncoderSize2(getBytesEncoder(), 8).encode(CREATE_CREDENTIAL_TEMPLATE_DISCRIMINATOR);
}
function getCreateCredentialTemplateInstructionDataEncoder() {
  return transformEncoder2(getStructEncoder([
    ["discriminator", fixEncoderSize2(getBytesEncoder(), 8)],
    ["name", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["imageUri", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    [
      "crossmintTemplateId",
      getOptionEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ]
  ]), (value) => ({
    ...value,
    discriminator: CREATE_CREDENTIAL_TEMPLATE_DISCRIMINATOR
  }));
}
function getCreateCredentialTemplateInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize2(getBytesDecoder(), 8)],
    ["name", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["imageUri", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    [
      "crossmintTemplateId",
      getOptionDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ]
  ]);
}
function getCreateCredentialTemplateInstructionDataCodec() {
  return combineCodec2(getCreateCredentialTemplateInstructionDataEncoder(), getCreateCredentialTemplateInstructionDataDecoder());
}
async function getCreateCredentialTemplateInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    credentialTemplate: {
      value: input.credentialTemplate ?? null,
      isWritable: true
    },
    credentialType: { value: input.credentialType ?? null, isWritable: false },
    issuer: { value: input.issuer ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.credentialTemplate.value) {
    accounts2.credentialTemplate.value = await getProgramDerivedAddress2({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([
          99,
          114,
          101,
          100,
          101,
          110,
          116,
          105,
          97,
          108,
          95,
          116,
          101,
          109,
          112,
          108,
          97,
          116,
          101
        ])),
        getAddressEncoder2().encode(expectAddress(accounts2.credentialType.value)),
        getUtf8Encoder().encode(expectSome(args.name))
      ]
    });
  }
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.credentialTemplate),
      getAccountMeta(accounts2.credentialType),
      getAccountMeta(accounts2.issuer),
      getAccountMeta(accounts2.systemProgram)
    ],
    data: getCreateCredentialTemplateInstructionDataEncoder().encode(args),
    programAddress
  });
}
function getCreateCredentialTemplateInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    credentialTemplate: {
      value: input.credentialTemplate ?? null,
      isWritable: true
    },
    credentialType: { value: input.credentialType ?? null, isWritable: false },
    issuer: { value: input.issuer ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.credentialTemplate),
      getAccountMeta(accounts2.credentialType),
      getAccountMeta(accounts2.issuer),
      getAccountMeta(accounts2.systemProgram)
    ],
    data: getCreateCredentialTemplateInstructionDataEncoder().encode(args),
    programAddress
  });
}
function parseCreateCredentialTemplateInstruction(instruction) {
  if (instruction.accounts.length < 4) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      credentialTemplate: getNextAccount(),
      credentialType: getNextAccount(),
      issuer: getNextAccount(),
      systemProgram: getNextAccount()
    },
    data: getCreateCredentialTemplateInstructionDataDecoder().decode(instruction.data)
  };
}
function getCreateCredentialTypeDiscriminatorBytes() {
  return fixEncoderSize2(getBytesEncoder(), 8).encode(CREATE_CREDENTIAL_TYPE_DISCRIMINATOR);
}
function getCreateCredentialTypeInstructionDataEncoder() {
  return transformEncoder2(getStructEncoder([
    ["discriminator", fixEncoderSize2(getBytesEncoder(), 8)],
    ["name", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["kind", getCredentialKindEncoder()],
    ["schemaUri", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["description", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())]
  ]), (value) => ({
    ...value,
    discriminator: CREATE_CREDENTIAL_TYPE_DISCRIMINATOR
  }));
}
function getCreateCredentialTypeInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize2(getBytesDecoder(), 8)],
    ["name", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["kind", getCredentialKindDecoder()],
    ["schemaUri", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["description", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())]
  ]);
}
function getCreateCredentialTypeInstructionDataCodec() {
  return combineCodec2(getCreateCredentialTypeInstructionDataEncoder(), getCreateCredentialTypeInstructionDataDecoder());
}
async function getCreateCredentialTypeInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    credentialType: { value: input.credentialType ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.credentialType.value) {
    accounts2.credentialType.value = await getProgramDerivedAddress2({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([
          99,
          114,
          101,
          100,
          101,
          110,
          116,
          105,
          97,
          108,
          95,
          116,
          121,
          112,
          101
        ])),
        getUtf8Encoder().encode(expectSome(args.name))
      ]
    });
  }
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.credentialType),
      getAccountMeta(accounts2.authority),
      getAccountMeta(accounts2.systemProgram)
    ],
    data: getCreateCredentialTypeInstructionDataEncoder().encode(args),
    programAddress
  });
}
function getCreateCredentialTypeInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    credentialType: { value: input.credentialType ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.credentialType),
      getAccountMeta(accounts2.authority),
      getAccountMeta(accounts2.systemProgram)
    ],
    data: getCreateCredentialTypeInstructionDataEncoder().encode(args),
    programAddress
  });
}
function parseCreateCredentialTypeInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      credentialType: getNextAccount(),
      authority: getNextAccount(),
      systemProgram: getNextAccount()
    },
    data: getCreateCredentialTypeInstructionDataDecoder().decode(instruction.data)
  };
}
function getCreateDidDocumentDiscriminatorBytes() {
  return fixEncoderSize2(getBytesEncoder(), 8).encode(CREATE_DID_DOCUMENT_DISCRIMINATOR);
}
function getCreateDidDocumentInstructionDataEncoder() {
  return transformEncoder2(getStructEncoder([
    ["discriminator", fixEncoderSize2(getBytesEncoder(), 8)],
    ["didString", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["verificationMethods", getArrayEncoder(getVerificationMethodEncoder())],
    ["serviceEndpoints", getArrayEncoder(getServiceEndpointEncoder())]
  ]), (value) => ({ ...value, discriminator: CREATE_DID_DOCUMENT_DISCRIMINATOR }));
}
function getCreateDidDocumentInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize2(getBytesDecoder(), 8)],
    ["didString", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["verificationMethods", getArrayDecoder(getVerificationMethodDecoder())],
    ["serviceEndpoints", getArrayDecoder(getServiceEndpointDecoder())]
  ]);
}
function getCreateDidDocumentInstructionDataCodec() {
  return combineCodec2(getCreateDidDocumentInstructionDataEncoder(), getCreateDidDocumentInstructionDataDecoder());
}
async function getCreateDidDocumentInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    didDocument: { value: input.didDocument ?? null, isWritable: true },
    controller: { value: input.controller ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    clock: { value: input.clock ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.didDocument.value) {
    accounts2.didDocument.value = await getProgramDerivedAddress2({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([
          100,
          105,
          100,
          95,
          100,
          111,
          99,
          117,
          109,
          101,
          110,
          116
        ])),
        getAddressEncoder2().encode(expectAddress(accounts2.controller.value))
      ]
    });
  }
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  if (!accounts2.clock.value) {
    accounts2.clock.value = "SysvarC1ock11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.didDocument),
      getAccountMeta(accounts2.controller),
      getAccountMeta(accounts2.systemProgram),
      getAccountMeta(accounts2.clock)
    ],
    data: getCreateDidDocumentInstructionDataEncoder().encode(args),
    programAddress
  });
}
function getCreateDidDocumentInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    didDocument: { value: input.didDocument ?? null, isWritable: true },
    controller: { value: input.controller ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    clock: { value: input.clock ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  if (!accounts2.clock.value) {
    accounts2.clock.value = "SysvarC1ock11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.didDocument),
      getAccountMeta(accounts2.controller),
      getAccountMeta(accounts2.systemProgram),
      getAccountMeta(accounts2.clock)
    ],
    data: getCreateDidDocumentInstructionDataEncoder().encode(args),
    programAddress
  });
}
function parseCreateDidDocumentInstruction(instruction) {
  if (instruction.accounts.length < 4) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      didDocument: getNextAccount(),
      controller: getNextAccount(),
      systemProgram: getNextAccount(),
      clock: getNextAccount()
    },
    data: getCreateDidDocumentInstructionDataDecoder().decode(instruction.data)
  };
}
function getCreateEscrowDiscriminatorBytes() {
  return fixEncoderSize2(getBytesEncoder(), 8).encode(CREATE_ESCROW_DISCRIMINATOR);
}
function getCreateEscrowInstructionDataEncoder() {
  return transformEncoder2(getStructEncoder([
    ["discriminator", fixEncoderSize2(getBytesEncoder(), 8)],
    ["escrowId", getU64Encoder()],
    ["amount", getU64Encoder()],
    [
      "jobDescription",
      addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())
    ],
    ["deadline", getI64Encoder()]
  ]), (value) => ({ ...value, discriminator: CREATE_ESCROW_DISCRIMINATOR }));
}
function getCreateEscrowInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize2(getBytesDecoder(), 8)],
    ["escrowId", getU64Decoder()],
    ["amount", getU64Decoder()],
    ["jobDescription", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["deadline", getI64Decoder()]
  ]);
}
function getCreateEscrowInstructionDataCodec() {
  return combineCodec2(getCreateEscrowInstructionDataEncoder(), getCreateEscrowInstructionDataDecoder());
}
async function getCreateEscrowInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    escrow: { value: input.escrow ?? null, isWritable: true },
    agent: { value: input.agent ?? null, isWritable: false },
    clientTokenAccount: {
      value: input.clientTokenAccount ?? null,
      isWritable: true
    },
    escrowVault: { value: input.escrowVault ?? null, isWritable: true },
    tokenMint: { value: input.tokenMint ?? null, isWritable: false },
    client: { value: input.client ?? null, isWritable: true },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.escrow.value) {
    accounts2.escrow.value = await getProgramDerivedAddress2({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([
          103,
          104,
          111,
          115,
          116,
          95,
          112,
          114,
          111,
          116,
          101,
          99,
          116
        ])),
        getAddressEncoder2().encode(expectAddress(accounts2.client.value)),
        getU64Encoder().encode(expectSome(args.escrowId))
      ]
    });
  }
  if (!accounts2.tokenProgram.value) {
    accounts2.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.escrow),
      getAccountMeta(accounts2.agent),
      getAccountMeta(accounts2.clientTokenAccount),
      getAccountMeta(accounts2.escrowVault),
      getAccountMeta(accounts2.tokenMint),
      getAccountMeta(accounts2.client),
      getAccountMeta(accounts2.tokenProgram),
      getAccountMeta(accounts2.systemProgram)
    ],
    data: getCreateEscrowInstructionDataEncoder().encode(args),
    programAddress
  });
}
function getCreateEscrowInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    escrow: { value: input.escrow ?? null, isWritable: true },
    agent: { value: input.agent ?? null, isWritable: false },
    clientTokenAccount: {
      value: input.clientTokenAccount ?? null,
      isWritable: true
    },
    escrowVault: { value: input.escrowVault ?? null, isWritable: true },
    tokenMint: { value: input.tokenMint ?? null, isWritable: false },
    client: { value: input.client ?? null, isWritable: true },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.tokenProgram.value) {
    accounts2.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.escrow),
      getAccountMeta(accounts2.agent),
      getAccountMeta(accounts2.clientTokenAccount),
      getAccountMeta(accounts2.escrowVault),
      getAccountMeta(accounts2.tokenMint),
      getAccountMeta(accounts2.client),
      getAccountMeta(accounts2.tokenProgram),
      getAccountMeta(accounts2.systemProgram)
    ],
    data: getCreateEscrowInstructionDataEncoder().encode(args),
    programAddress
  });
}
function parseCreateEscrowInstruction(instruction) {
  if (instruction.accounts.length < 8) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      escrow: getNextAccount(),
      agent: getNextAccount(),
      clientTokenAccount: getNextAccount(),
      escrowVault: getNextAccount(),
      tokenMint: getNextAccount(),
      client: getNextAccount(),
      tokenProgram: getNextAccount(),
      systemProgram: getNextAccount()
    },
    data: getCreateEscrowInstructionDataDecoder().decode(instruction.data)
  };
}
function getCreateMultisigDiscriminatorBytes() {
  return fixEncoderSize2(getBytesEncoder(), 8).encode(CREATE_MULTISIG_DISCRIMINATOR);
}
function getCreateMultisigInstructionDataEncoder() {
  return transformEncoder2(getStructEncoder([
    ["discriminator", fixEncoderSize2(getBytesEncoder(), 8)],
    ["multisigId", getU64Encoder()],
    ["threshold", getU8Encoder()],
    ["signers", getArrayEncoder(getAddressEncoder2())],
    ["config", getMultisigConfigEncoder()]
  ]), (value) => ({ ...value, discriminator: CREATE_MULTISIG_DISCRIMINATOR }));
}
function getCreateMultisigInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize2(getBytesDecoder(), 8)],
    ["multisigId", getU64Decoder()],
    ["threshold", getU8Decoder()],
    ["signers", getArrayDecoder(getAddressDecoder2())],
    ["config", getMultisigConfigDecoder()]
  ]);
}
function getCreateMultisigInstructionDataCodec() {
  return combineCodec2(getCreateMultisigInstructionDataEncoder(), getCreateMultisigInstructionDataDecoder());
}
async function getCreateMultisigInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    multisig: { value: input.multisig ?? null, isWritable: true },
    owner: { value: input.owner ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.multisig.value) {
    accounts2.multisig.value = await getProgramDerivedAddress2({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([109, 117, 108, 116, 105, 115, 105, 103])),
        getAddressEncoder2().encode(expectAddress(accounts2.owner.value)),
        getU64Encoder().encode(expectSome(args.multisigId))
      ]
    });
  }
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.multisig),
      getAccountMeta(accounts2.owner),
      getAccountMeta(accounts2.systemProgram)
    ],
    data: getCreateMultisigInstructionDataEncoder().encode(args),
    programAddress
  });
}
function getCreateMultisigInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    multisig: { value: input.multisig ?? null, isWritable: true },
    owner: { value: input.owner ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.multisig),
      getAccountMeta(accounts2.owner),
      getAccountMeta(accounts2.systemProgram)
    ],
    data: getCreateMultisigInstructionDataEncoder().encode(args),
    programAddress
  });
}
function parseCreateMultisigInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      multisig: getNextAccount(),
      owner: getNextAccount(),
      systemProgram: getNextAccount()
    },
    data: getCreateMultisigInstructionDataDecoder().decode(instruction.data)
  };
}
function getDeactivateAgentDiscriminatorBytes() {
  return fixEncoderSize2(getBytesEncoder(), 8).encode(DEACTIVATE_AGENT_DISCRIMINATOR);
}
function getDeactivateAgentInstructionDataEncoder() {
  return transformEncoder2(getStructEncoder([
    ["discriminator", fixEncoderSize2(getBytesEncoder(), 8)],
    ["agentId", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())]
  ]), (value) => ({ ...value, discriminator: DEACTIVATE_AGENT_DISCRIMINATOR }));
}
function getDeactivateAgentInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize2(getBytesDecoder(), 8)],
    ["agentId", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())]
  ]);
}
function getDeactivateAgentInstructionDataCodec() {
  return combineCodec2(getDeactivateAgentInstructionDataEncoder(), getDeactivateAgentInstructionDataDecoder());
}
async function getDeactivateAgentInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    agentAccount: { value: input.agentAccount ?? null, isWritable: true },
    signer: { value: input.signer ?? null, isWritable: true },
    clock: { value: input.clock ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.agentAccount.value) {
    accounts2.agentAccount.value = await getProgramDerivedAddress2({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([97, 103, 101, 110, 116])),
        getAddressEncoder2().encode(expectAddress(accounts2.signer.value)),
        getUtf8Encoder().encode(expectSome(args.agentId))
      ]
    });
  }
  if (!accounts2.clock.value) {
    accounts2.clock.value = "SysvarC1ock11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.agentAccount),
      getAccountMeta(accounts2.signer),
      getAccountMeta(accounts2.clock)
    ],
    data: getDeactivateAgentInstructionDataEncoder().encode(args),
    programAddress
  });
}
function getDeactivateAgentInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    agentAccount: { value: input.agentAccount ?? null, isWritable: true },
    signer: { value: input.signer ?? null, isWritable: true },
    clock: { value: input.clock ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.clock.value) {
    accounts2.clock.value = "SysvarC1ock11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.agentAccount),
      getAccountMeta(accounts2.signer),
      getAccountMeta(accounts2.clock)
    ],
    data: getDeactivateAgentInstructionDataEncoder().encode(args),
    programAddress
  });
}
function parseDeactivateAgentInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      agentAccount: getNextAccount(),
      signer: getNextAccount(),
      clock: getNextAccount()
    },
    data: getDeactivateAgentInstructionDataDecoder().decode(instruction.data)
  };
}
function getDeactivateCredentialTemplateDiscriminatorBytes() {
  return fixEncoderSize2(getBytesEncoder(), 8).encode(DEACTIVATE_CREDENTIAL_TEMPLATE_DISCRIMINATOR);
}
function getDeactivateCredentialTemplateInstructionDataEncoder() {
  return transformEncoder2(getStructEncoder([["discriminator", fixEncoderSize2(getBytesEncoder(), 8)]]), (value) => ({
    ...value,
    discriminator: DEACTIVATE_CREDENTIAL_TEMPLATE_DISCRIMINATOR
  }));
}
function getDeactivateCredentialTemplateInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize2(getBytesDecoder(), 8)]
  ]);
}
function getDeactivateCredentialTemplateInstructionDataCodec() {
  return combineCodec2(getDeactivateCredentialTemplateInstructionDataEncoder(), getDeactivateCredentialTemplateInstructionDataDecoder());
}
function getDeactivateCredentialTemplateInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    credentialTemplate: {
      value: input.credentialTemplate ?? null,
      isWritable: true
    },
    issuer: { value: input.issuer ?? null, isWritable: true }
  };
  const accounts2 = originalAccounts;
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.credentialTemplate),
      getAccountMeta(accounts2.issuer)
    ],
    data: getDeactivateCredentialTemplateInstructionDataEncoder().encode({}),
    programAddress
  });
}
function parseDeactivateCredentialTemplateInstruction(instruction) {
  if (instruction.accounts.length < 2) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      credentialTemplate: getNextAccount(),
      issuer: getNextAccount()
    },
    data: getDeactivateCredentialTemplateInstructionDataDecoder().decode(instruction.data)
  };
}
function getDeactivateCredentialTypeDiscriminatorBytes() {
  return fixEncoderSize2(getBytesEncoder(), 8).encode(DEACTIVATE_CREDENTIAL_TYPE_DISCRIMINATOR);
}
function getDeactivateCredentialTypeInstructionDataEncoder() {
  return transformEncoder2(getStructEncoder([["discriminator", fixEncoderSize2(getBytesEncoder(), 8)]]), (value) => ({
    ...value,
    discriminator: DEACTIVATE_CREDENTIAL_TYPE_DISCRIMINATOR
  }));
}
function getDeactivateCredentialTypeInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize2(getBytesDecoder(), 8)]
  ]);
}
function getDeactivateCredentialTypeInstructionDataCodec() {
  return combineCodec2(getDeactivateCredentialTypeInstructionDataEncoder(), getDeactivateCredentialTypeInstructionDataDecoder());
}
function getDeactivateCredentialTypeInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    credentialType: { value: input.credentialType ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: true }
  };
  const accounts2 = originalAccounts;
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.credentialType),
      getAccountMeta(accounts2.authority)
    ],
    data: getDeactivateCredentialTypeInstructionDataEncoder().encode({}),
    programAddress
  });
}
function parseDeactivateCredentialTypeInstruction(instruction) {
  if (instruction.accounts.length < 2) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: { credentialType: getNextAccount(), authority: getNextAccount() },
    data: getDeactivateCredentialTypeInstructionDataDecoder().decode(instruction.data)
  };
}
function getDeactivateDidDocumentDiscriminatorBytes() {
  return fixEncoderSize2(getBytesEncoder(), 8).encode(DEACTIVATE_DID_DOCUMENT_DISCRIMINATOR);
}
function getDeactivateDidDocumentInstructionDataEncoder() {
  return transformEncoder2(getStructEncoder([["discriminator", fixEncoderSize2(getBytesEncoder(), 8)]]), (value) => ({
    ...value,
    discriminator: DEACTIVATE_DID_DOCUMENT_DISCRIMINATOR
  }));
}
function getDeactivateDidDocumentInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize2(getBytesDecoder(), 8)]
  ]);
}
function getDeactivateDidDocumentInstructionDataCodec() {
  return combineCodec2(getDeactivateDidDocumentInstructionDataEncoder(), getDeactivateDidDocumentInstructionDataDecoder());
}
async function getDeactivateDidDocumentInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    didDocument: { value: input.didDocument ?? null, isWritable: true },
    controller: { value: input.controller ?? null, isWritable: true },
    clock: { value: input.clock ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  if (!accounts2.didDocument.value) {
    accounts2.didDocument.value = await getProgramDerivedAddress2({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([
          100,
          105,
          100,
          95,
          100,
          111,
          99,
          117,
          109,
          101,
          110,
          116
        ])),
        getAddressEncoder2().encode(expectAddress(accounts2.controller.value))
      ]
    });
  }
  if (!accounts2.clock.value) {
    accounts2.clock.value = "SysvarC1ock11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.didDocument),
      getAccountMeta(accounts2.controller),
      getAccountMeta(accounts2.clock)
    ],
    data: getDeactivateDidDocumentInstructionDataEncoder().encode({}),
    programAddress
  });
}
function getDeactivateDidDocumentInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    didDocument: { value: input.didDocument ?? null, isWritable: true },
    controller: { value: input.controller ?? null, isWritable: true },
    clock: { value: input.clock ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  if (!accounts2.clock.value) {
    accounts2.clock.value = "SysvarC1ock11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.didDocument),
      getAccountMeta(accounts2.controller),
      getAccountMeta(accounts2.clock)
    ],
    data: getDeactivateDidDocumentInstructionDataEncoder().encode({}),
    programAddress
  });
}
function parseDeactivateDidDocumentInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      didDocument: getNextAccount(),
      controller: getNextAccount(),
      clock: getNextAccount()
    },
    data: getDeactivateDidDocumentInstructionDataDecoder().decode(instruction.data)
  };
}
function getEnableProtocolFeesDiscriminatorBytes() {
  return fixEncoderSize2(getBytesEncoder(), 8).encode(ENABLE_PROTOCOL_FEES_DISCRIMINATOR);
}
function getEnableProtocolFeesInstructionDataEncoder() {
  return transformEncoder2(getStructEncoder([["discriminator", fixEncoderSize2(getBytesEncoder(), 8)]]), (value) => ({
    ...value,
    discriminator: ENABLE_PROTOCOL_FEES_DISCRIMINATOR
  }));
}
function getEnableProtocolFeesInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize2(getBytesDecoder(), 8)]
  ]);
}
function getEnableProtocolFeesInstructionDataCodec() {
  return combineCodec2(getEnableProtocolFeesInstructionDataEncoder(), getEnableProtocolFeesInstructionDataDecoder());
}
async function getEnableProtocolFeesInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    config: { value: input.config ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  if (!accounts2.config.value) {
    accounts2.config.value = await getProgramDerivedAddress2({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([
          112,
          114,
          111,
          116,
          111,
          99,
          111,
          108,
          95,
          99,
          111,
          110,
          102,
          105,
          103
        ]))
      ]
    });
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.config),
      getAccountMeta(accounts2.authority)
    ],
    data: getEnableProtocolFeesInstructionDataEncoder().encode({}),
    programAddress
  });
}
function getEnableProtocolFeesInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    config: { value: input.config ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.config),
      getAccountMeta(accounts2.authority)
    ],
    data: getEnableProtocolFeesInstructionDataEncoder().encode({}),
    programAddress
  });
}
function parseEnableProtocolFeesInstruction(instruction) {
  if (instruction.accounts.length < 2) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: { config: getNextAccount(), authority: getNextAccount() },
    data: getEnableProtocolFeesInstructionDataDecoder().decode(instruction.data)
  };
}
function getFileDisputeDiscriminatorBytes() {
  return fixEncoderSize2(getBytesEncoder(), 8).encode(FILE_DISPUTE_DISCRIMINATOR);
}
function getFileDisputeInstructionDataEncoder() {
  return transformEncoder2(getStructEncoder([
    ["discriminator", fixEncoderSize2(getBytesEncoder(), 8)],
    ["reason", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())]
  ]), (value) => ({ ...value, discriminator: FILE_DISPUTE_DISCRIMINATOR }));
}
function getFileDisputeInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize2(getBytesDecoder(), 8)],
    ["reason", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())]
  ]);
}
function getFileDisputeInstructionDataCodec() {
  return combineCodec2(getFileDisputeInstructionDataEncoder(), getFileDisputeInstructionDataDecoder());
}
function getFileDisputeInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    escrow: { value: input.escrow ?? null, isWritable: true },
    client: { value: input.client ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.escrow),
      getAccountMeta(accounts2.client)
    ],
    data: getFileDisputeInstructionDataEncoder().encode(args),
    programAddress
  });
}
function parseFileDisputeInstruction(instruction) {
  if (instruction.accounts.length < 2) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: { escrow: getNextAccount(), client: getNextAccount() },
    data: getFileDisputeInstructionDataDecoder().decode(instruction.data)
  };
}
function getGenerateComplianceReportDiscriminatorBytes() {
  return fixEncoderSize2(getBytesEncoder(), 8).encode(GENERATE_COMPLIANCE_REPORT_DISCRIMINATOR);
}
function getGenerateComplianceReportInstructionDataEncoder() {
  return transformEncoder2(getStructEncoder([
    ["discriminator", fixEncoderSize2(getBytesEncoder(), 8)],
    ["reportId", getU64Encoder()],
    ["reportType", getReportTypeEncoder()],
    ["dateRangeStart", getI64Encoder()],
    ["dateRangeEnd", getI64Encoder()]
  ]), (value) => ({
    ...value,
    discriminator: GENERATE_COMPLIANCE_REPORT_DISCRIMINATOR
  }));
}
function getGenerateComplianceReportInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize2(getBytesDecoder(), 8)],
    ["reportId", getU64Decoder()],
    ["reportType", getReportTypeDecoder()],
    ["dateRangeStart", getI64Decoder()],
    ["dateRangeEnd", getI64Decoder()]
  ]);
}
function getGenerateComplianceReportInstructionDataCodec() {
  return combineCodec2(getGenerateComplianceReportInstructionDataEncoder(), getGenerateComplianceReportInstructionDataDecoder());
}
async function getGenerateComplianceReportInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    report: { value: input.report ?? null, isWritable: true },
    auditTrail: { value: input.auditTrail ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.report.value) {
    accounts2.report.value = await getProgramDerivedAddress2({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([
          99,
          111,
          109,
          112,
          108,
          105,
          97,
          110,
          99,
          101,
          95,
          114,
          101,
          112,
          111,
          114,
          116
        ])),
        getU64Encoder().encode(expectSome(args.reportId))
      ]
    });
  }
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.report),
      getAccountMeta(accounts2.auditTrail),
      getAccountMeta(accounts2.authority),
      getAccountMeta(accounts2.systemProgram)
    ],
    data: getGenerateComplianceReportInstructionDataEncoder().encode(args),
    programAddress
  });
}
function getGenerateComplianceReportInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    report: { value: input.report ?? null, isWritable: true },
    auditTrail: { value: input.auditTrail ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.report),
      getAccountMeta(accounts2.auditTrail),
      getAccountMeta(accounts2.authority),
      getAccountMeta(accounts2.systemProgram)
    ],
    data: getGenerateComplianceReportInstructionDataEncoder().encode(args),
    programAddress
  });
}
function parseGenerateComplianceReportInstruction(instruction) {
  if (instruction.accounts.length < 4) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      report: getNextAccount(),
      auditTrail: getNextAccount(),
      authority: getNextAccount(),
      systemProgram: getNextAccount()
    },
    data: getGenerateComplianceReportInstructionDataDecoder().decode(instruction.data)
  };
}
function getInitializeAuditTrailDiscriminatorBytes() {
  return fixEncoderSize2(getBytesEncoder(), 8).encode(INITIALIZE_AUDIT_TRAIL_DISCRIMINATOR);
}
function getInitializeAuditTrailInstructionDataEncoder() {
  return transformEncoder2(getStructEncoder([
    ["discriminator", fixEncoderSize2(getBytesEncoder(), 8)],
    ["entityType", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["config", getAuditConfigEncoder()]
  ]), (value) => ({
    ...value,
    discriminator: INITIALIZE_AUDIT_TRAIL_DISCRIMINATOR
  }));
}
function getInitializeAuditTrailInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize2(getBytesDecoder(), 8)],
    ["entityType", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["config", getAuditConfigDecoder()]
  ]);
}
function getInitializeAuditTrailInstructionDataCodec() {
  return combineCodec2(getInitializeAuditTrailInstructionDataEncoder(), getInitializeAuditTrailInstructionDataDecoder());
}
async function getInitializeAuditTrailInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    auditTrail: { value: input.auditTrail ?? null, isWritable: true },
    entity: { value: input.entity ?? null, isWritable: false },
    authority: { value: input.authority ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.auditTrail.value) {
    accounts2.auditTrail.value = await getProgramDerivedAddress2({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([97, 117, 100, 105, 116, 95, 116, 114, 97, 105, 108])),
        getAddressEncoder2().encode(expectAddress(accounts2.entity.value))
      ]
    });
  }
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.auditTrail),
      getAccountMeta(accounts2.entity),
      getAccountMeta(accounts2.authority),
      getAccountMeta(accounts2.systemProgram)
    ],
    data: getInitializeAuditTrailInstructionDataEncoder().encode(args),
    programAddress
  });
}
function getInitializeAuditTrailInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    auditTrail: { value: input.auditTrail ?? null, isWritable: true },
    entity: { value: input.entity ?? null, isWritable: false },
    authority: { value: input.authority ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.auditTrail),
      getAccountMeta(accounts2.entity),
      getAccountMeta(accounts2.authority),
      getAccountMeta(accounts2.systemProgram)
    ],
    data: getInitializeAuditTrailInstructionDataEncoder().encode(args),
    programAddress
  });
}
function parseInitializeAuditTrailInstruction(instruction) {
  if (instruction.accounts.length < 4) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      auditTrail: getNextAccount(),
      entity: getNextAccount(),
      authority: getNextAccount(),
      systemProgram: getNextAccount()
    },
    data: getInitializeAuditTrailInstructionDataDecoder().decode(instruction.data)
  };
}
function getInitializeGovernanceProposalDiscriminatorBytes() {
  return fixEncoderSize2(getBytesEncoder(), 8).encode(INITIALIZE_GOVERNANCE_PROPOSAL_DISCRIMINATOR);
}
function getInitializeGovernanceProposalInstructionDataEncoder() {
  return transformEncoder2(getStructEncoder([
    ["discriminator", fixEncoderSize2(getBytesEncoder(), 8)],
    ["proposalId", getU64Encoder()],
    ["title", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["description", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["proposalType", getProposalTypeEncoder()],
    ["executionParams", getExecutionParamsEncoder()]
  ]), (value) => ({
    ...value,
    discriminator: INITIALIZE_GOVERNANCE_PROPOSAL_DISCRIMINATOR
  }));
}
function getInitializeGovernanceProposalInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize2(getBytesDecoder(), 8)],
    ["proposalId", getU64Decoder()],
    ["title", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["description", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["proposalType", getProposalTypeDecoder()],
    ["executionParams", getExecutionParamsDecoder()]
  ]);
}
function getInitializeGovernanceProposalInstructionDataCodec() {
  return combineCodec2(getInitializeGovernanceProposalInstructionDataEncoder(), getInitializeGovernanceProposalInstructionDataDecoder());
}
async function getInitializeGovernanceProposalInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    proposal: { value: input.proposal ?? null, isWritable: true },
    proposer: { value: input.proposer ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.proposal.value) {
    accounts2.proposal.value = await getProgramDerivedAddress2({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([
          103,
          111,
          118,
          101,
          114,
          110,
          97,
          110,
          99,
          101,
          95,
          112,
          114,
          111,
          112,
          111,
          115,
          97,
          108
        ])),
        getU64Encoder().encode(expectSome(args.proposalId))
      ]
    });
  }
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.proposal),
      getAccountMeta(accounts2.proposer),
      getAccountMeta(accounts2.systemProgram)
    ],
    data: getInitializeGovernanceProposalInstructionDataEncoder().encode(args),
    programAddress
  });
}
function getInitializeGovernanceProposalInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    proposal: { value: input.proposal ?? null, isWritable: true },
    proposer: { value: input.proposer ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.proposal),
      getAccountMeta(accounts2.proposer),
      getAccountMeta(accounts2.systemProgram)
    ],
    data: getInitializeGovernanceProposalInstructionDataEncoder().encode(args),
    programAddress
  });
}
function parseInitializeGovernanceProposalInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      proposal: getNextAccount(),
      proposer: getNextAccount(),
      systemProgram: getNextAccount()
    },
    data: getInitializeGovernanceProposalInstructionDataDecoder().decode(instruction.data)
  };
}
function getInitializeProtocolConfigDiscriminatorBytes() {
  return fixEncoderSize2(getBytesEncoder(), 8).encode(INITIALIZE_PROTOCOL_CONFIG_DISCRIMINATOR);
}
function getInitializeProtocolConfigInstructionDataEncoder() {
  return transformEncoder2(getStructEncoder([["discriminator", fixEncoderSize2(getBytesEncoder(), 8)]]), (value) => ({
    ...value,
    discriminator: INITIALIZE_PROTOCOL_CONFIG_DISCRIMINATOR
  }));
}
function getInitializeProtocolConfigInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize2(getBytesDecoder(), 8)]
  ]);
}
function getInitializeProtocolConfigInstructionDataCodec() {
  return combineCodec2(getInitializeProtocolConfigInstructionDataEncoder(), getInitializeProtocolConfigInstructionDataDecoder());
}
async function getInitializeProtocolConfigInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    config: { value: input.config ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: true },
    treasury: { value: input.treasury ?? null, isWritable: false },
    buybackPool: { value: input.buybackPool ?? null, isWritable: false },
    moderatorPool: { value: input.moderatorPool ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  if (!accounts2.config.value) {
    accounts2.config.value = await getProgramDerivedAddress2({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([
          112,
          114,
          111,
          116,
          111,
          99,
          111,
          108,
          95,
          99,
          111,
          110,
          102,
          105,
          103
        ]))
      ]
    });
  }
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.config),
      getAccountMeta(accounts2.authority),
      getAccountMeta(accounts2.treasury),
      getAccountMeta(accounts2.buybackPool),
      getAccountMeta(accounts2.moderatorPool),
      getAccountMeta(accounts2.systemProgram)
    ],
    data: getInitializeProtocolConfigInstructionDataEncoder().encode({}),
    programAddress
  });
}
function getInitializeProtocolConfigInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    config: { value: input.config ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: true },
    treasury: { value: input.treasury ?? null, isWritable: false },
    buybackPool: { value: input.buybackPool ?? null, isWritable: false },
    moderatorPool: { value: input.moderatorPool ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.config),
      getAccountMeta(accounts2.authority),
      getAccountMeta(accounts2.treasury),
      getAccountMeta(accounts2.buybackPool),
      getAccountMeta(accounts2.moderatorPool),
      getAccountMeta(accounts2.systemProgram)
    ],
    data: getInitializeProtocolConfigInstructionDataEncoder().encode({}),
    programAddress
  });
}
function parseInitializeProtocolConfigInstruction(instruction) {
  if (instruction.accounts.length < 6) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      config: getNextAccount(),
      authority: getNextAccount(),
      treasury: getNextAccount(),
      buybackPool: getNextAccount(),
      moderatorPool: getNextAccount(),
      systemProgram: getNextAccount()
    },
    data: getInitializeProtocolConfigInstructionDataDecoder().decode(instruction.data)
  };
}
function getInitializeRbacConfigDiscriminatorBytes() {
  return fixEncoderSize2(getBytesEncoder(), 8).encode(INITIALIZE_RBAC_CONFIG_DISCRIMINATOR);
}
function getInitializeRbacConfigInstructionDataEncoder() {
  return transformEncoder2(getStructEncoder([
    ["discriminator", fixEncoderSize2(getBytesEncoder(), 8)],
    ["initialRoles", getArrayEncoder(getRoleEncoder())]
  ]), (value) => ({
    ...value,
    discriminator: INITIALIZE_RBAC_CONFIG_DISCRIMINATOR
  }));
}
function getInitializeRbacConfigInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize2(getBytesDecoder(), 8)],
    ["initialRoles", getArrayDecoder(getRoleDecoder())]
  ]);
}
function getInitializeRbacConfigInstructionDataCodec() {
  return combineCodec2(getInitializeRbacConfigInstructionDataEncoder(), getInitializeRbacConfigInstructionDataDecoder());
}
async function getInitializeRbacConfigInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    rbacConfig: { value: input.rbacConfig ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.rbacConfig.value) {
    accounts2.rbacConfig.value = await getProgramDerivedAddress2({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([114, 98, 97, 99, 95, 99, 111, 110, 102, 105, 103])),
        getAddressEncoder2().encode(expectAddress(accounts2.authority.value))
      ]
    });
  }
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.rbacConfig),
      getAccountMeta(accounts2.authority),
      getAccountMeta(accounts2.systemProgram)
    ],
    data: getInitializeRbacConfigInstructionDataEncoder().encode(args),
    programAddress
  });
}
function getInitializeRbacConfigInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    rbacConfig: { value: input.rbacConfig ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.rbacConfig),
      getAccountMeta(accounts2.authority),
      getAccountMeta(accounts2.systemProgram)
    ],
    data: getInitializeRbacConfigInstructionDataEncoder().encode(args),
    programAddress
  });
}
function parseInitializeRbacConfigInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      rbacConfig: getNextAccount(),
      authority: getNextAccount(),
      systemProgram: getNextAccount()
    },
    data: getInitializeRbacConfigInstructionDataDecoder().decode(instruction.data)
  };
}
function getInitializeReputationMetricsDiscriminatorBytes() {
  return fixEncoderSize2(getBytesEncoder(), 8).encode(INITIALIZE_REPUTATION_METRICS_DISCRIMINATOR);
}
function getInitializeReputationMetricsInstructionDataEncoder() {
  return transformEncoder2(getStructEncoder([["discriminator", fixEncoderSize2(getBytesEncoder(), 8)]]), (value) => ({
    ...value,
    discriminator: INITIALIZE_REPUTATION_METRICS_DISCRIMINATOR
  }));
}
function getInitializeReputationMetricsInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize2(getBytesDecoder(), 8)]
  ]);
}
function getInitializeReputationMetricsInstructionDataCodec() {
  return combineCodec2(getInitializeReputationMetricsInstructionDataEncoder(), getInitializeReputationMetricsInstructionDataDecoder());
}
async function getInitializeReputationMetricsInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    reputationMetrics: {
      value: input.reputationMetrics ?? null,
      isWritable: true
    },
    agent: { value: input.agent ?? null, isWritable: false },
    authority: { value: input.authority ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    clock: { value: input.clock ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  if (!accounts2.reputationMetrics.value) {
    accounts2.reputationMetrics.value = await getProgramDerivedAddress2({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([
          114,
          101,
          112,
          117,
          116,
          97,
          116,
          105,
          111,
          110,
          95,
          109,
          101,
          116,
          114,
          105,
          99,
          115
        ])),
        getAddressEncoder2().encode(expectAddress(accounts2.agent.value))
      ]
    });
  }
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  if (!accounts2.clock.value) {
    accounts2.clock.value = "SysvarC1ock11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.reputationMetrics),
      getAccountMeta(accounts2.agent),
      getAccountMeta(accounts2.authority),
      getAccountMeta(accounts2.systemProgram),
      getAccountMeta(accounts2.clock)
    ],
    data: getInitializeReputationMetricsInstructionDataEncoder().encode({}),
    programAddress
  });
}
function getInitializeReputationMetricsInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    reputationMetrics: {
      value: input.reputationMetrics ?? null,
      isWritable: true
    },
    agent: { value: input.agent ?? null, isWritable: false },
    authority: { value: input.authority ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    clock: { value: input.clock ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  if (!accounts2.clock.value) {
    accounts2.clock.value = "SysvarC1ock11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.reputationMetrics),
      getAccountMeta(accounts2.agent),
      getAccountMeta(accounts2.authority),
      getAccountMeta(accounts2.systemProgram),
      getAccountMeta(accounts2.clock)
    ],
    data: getInitializeReputationMetricsInstructionDataEncoder().encode({}),
    programAddress
  });
}
function parseInitializeReputationMetricsInstruction(instruction) {
  if (instruction.accounts.length < 5) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      reputationMetrics: getNextAccount(),
      agent: getNextAccount(),
      authority: getNextAccount(),
      systemProgram: getNextAccount(),
      clock: getNextAccount()
    },
    data: getInitializeReputationMetricsInstructionDataDecoder().decode(instruction.data)
  };
}
function getInitializeStakingConfigDiscriminatorBytes() {
  return fixEncoderSize2(getBytesEncoder(), 8).encode(INITIALIZE_STAKING_CONFIG_DISCRIMINATOR);
}
function getInitializeStakingConfigInstructionDataEncoder() {
  return transformEncoder2(getStructEncoder([
    ["discriminator", fixEncoderSize2(getBytesEncoder(), 8)],
    ["minStake", getU64Encoder()],
    ["treasury", getAddressEncoder2()]
  ]), (value) => ({
    ...value,
    discriminator: INITIALIZE_STAKING_CONFIG_DISCRIMINATOR
  }));
}
function getInitializeStakingConfigInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize2(getBytesDecoder(), 8)],
    ["minStake", getU64Decoder()],
    ["treasury", getAddressDecoder2()]
  ]);
}
function getInitializeStakingConfigInstructionDataCodec() {
  return combineCodec2(getInitializeStakingConfigInstructionDataEncoder(), getInitializeStakingConfigInstructionDataDecoder());
}
async function getInitializeStakingConfigInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    stakingConfig: { value: input.stakingConfig ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.stakingConfig.value) {
    accounts2.stakingConfig.value = await getProgramDerivedAddress2({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([
          115,
          116,
          97,
          107,
          105,
          110,
          103,
          95,
          99,
          111,
          110,
          102,
          105,
          103
        ]))
      ]
    });
  }
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.stakingConfig),
      getAccountMeta(accounts2.authority),
      getAccountMeta(accounts2.systemProgram)
    ],
    data: getInitializeStakingConfigInstructionDataEncoder().encode(args),
    programAddress
  });
}
function getInitializeStakingConfigInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    stakingConfig: { value: input.stakingConfig ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.stakingConfig),
      getAccountMeta(accounts2.authority),
      getAccountMeta(accounts2.systemProgram)
    ],
    data: getInitializeStakingConfigInstructionDataEncoder().encode(args),
    programAddress
  });
}
function parseInitializeStakingConfigInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      stakingConfig: getNextAccount(),
      authority: getNextAccount(),
      systemProgram: getNextAccount()
    },
    data: getInitializeStakingConfigInstructionDataDecoder().decode(instruction.data)
  };
}
function getInitReentrancyGuardDiscriminatorBytes() {
  return fixEncoderSize2(getBytesEncoder(), 8).encode(INIT_REENTRANCY_GUARD_DISCRIMINATOR);
}
function getInitReentrancyGuardInstructionDataEncoder() {
  return transformEncoder2(getStructEncoder([["discriminator", fixEncoderSize2(getBytesEncoder(), 8)]]), (value) => ({
    ...value,
    discriminator: INIT_REENTRANCY_GUARD_DISCRIMINATOR
  }));
}
function getInitReentrancyGuardInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize2(getBytesDecoder(), 8)]
  ]);
}
function getInitReentrancyGuardInstructionDataCodec() {
  return combineCodec2(getInitReentrancyGuardInstructionDataEncoder(), getInitReentrancyGuardInstructionDataDecoder());
}
async function getInitReentrancyGuardInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    reentrancyGuard: { value: input.reentrancyGuard ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  if (!accounts2.reentrancyGuard.value) {
    accounts2.reentrancyGuard.value = await getProgramDerivedAddress2({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([
          114,
          101,
          101,
          110,
          116,
          114,
          97,
          110,
          99,
          121,
          95,
          103,
          117,
          97,
          114,
          100
        ]))
      ]
    });
  }
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.reentrancyGuard),
      getAccountMeta(accounts2.authority),
      getAccountMeta(accounts2.systemProgram)
    ],
    data: getInitReentrancyGuardInstructionDataEncoder().encode({}),
    programAddress
  });
}
function getInitReentrancyGuardInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    reentrancyGuard: { value: input.reentrancyGuard ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.reentrancyGuard),
      getAccountMeta(accounts2.authority),
      getAccountMeta(accounts2.systemProgram)
    ],
    data: getInitReentrancyGuardInstructionDataEncoder().encode({}),
    programAddress
  });
}
function parseInitReentrancyGuardInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      reentrancyGuard: getNextAccount(),
      authority: getNextAccount(),
      systemProgram: getNextAccount()
    },
    data: getInitReentrancyGuardInstructionDataDecoder().decode(instruction.data)
  };
}
function getIssueCredentialDiscriminatorBytes() {
  return fixEncoderSize2(getBytesEncoder(), 8).encode(ISSUE_CREDENTIAL_DISCRIMINATOR);
}
function getIssueCredentialInstructionDataEncoder() {
  return transformEncoder2(getStructEncoder([
    ["discriminator", fixEncoderSize2(getBytesEncoder(), 8)],
    ["credentialId", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["subjectDataHash", fixEncoderSize2(getBytesEncoder(), 32)],
    [
      "subjectDataUri",
      addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())
    ],
    ["expiresAt", getOptionEncoder(getI64Encoder())],
    ["sourceAccount", getOptionEncoder(getAddressEncoder2())]
  ]), (value) => ({ ...value, discriminator: ISSUE_CREDENTIAL_DISCRIMINATOR }));
}
function getIssueCredentialInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize2(getBytesDecoder(), 8)],
    ["credentialId", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["subjectDataHash", fixDecoderSize2(getBytesDecoder(), 32)],
    ["subjectDataUri", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["expiresAt", getOptionDecoder(getI64Decoder())],
    ["sourceAccount", getOptionDecoder(getAddressDecoder2())]
  ]);
}
function getIssueCredentialInstructionDataCodec() {
  return combineCodec2(getIssueCredentialInstructionDataEncoder(), getIssueCredentialInstructionDataDecoder());
}
async function getIssueCredentialInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    credential: { value: input.credential ?? null, isWritable: true },
    credentialTemplate: {
      value: input.credentialTemplate ?? null,
      isWritable: true
    },
    credentialType: { value: input.credentialType ?? null, isWritable: true },
    subject: { value: input.subject ?? null, isWritable: false },
    issuer: { value: input.issuer ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.credential.value) {
    accounts2.credential.value = await getProgramDerivedAddress2({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([99, 114, 101, 100, 101, 110, 116, 105, 97, 108])),
        getAddressEncoder2().encode(expectAddress(accounts2.credentialTemplate.value)),
        getAddressEncoder2().encode(expectAddress(accounts2.subject.value)),
        getUtf8Encoder().encode(expectSome(args.credentialId))
      ]
    });
  }
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.credential),
      getAccountMeta(accounts2.credentialTemplate),
      getAccountMeta(accounts2.credentialType),
      getAccountMeta(accounts2.subject),
      getAccountMeta(accounts2.issuer),
      getAccountMeta(accounts2.systemProgram)
    ],
    data: getIssueCredentialInstructionDataEncoder().encode(args),
    programAddress
  });
}
function getIssueCredentialInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    credential: { value: input.credential ?? null, isWritable: true },
    credentialTemplate: {
      value: input.credentialTemplate ?? null,
      isWritable: true
    },
    credentialType: { value: input.credentialType ?? null, isWritable: true },
    subject: { value: input.subject ?? null, isWritable: false },
    issuer: { value: input.issuer ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.credential),
      getAccountMeta(accounts2.credentialTemplate),
      getAccountMeta(accounts2.credentialType),
      getAccountMeta(accounts2.subject),
      getAccountMeta(accounts2.issuer),
      getAccountMeta(accounts2.systemProgram)
    ],
    data: getIssueCredentialInstructionDataEncoder().encode(args),
    programAddress
  });
}
function parseIssueCredentialInstruction(instruction) {
  if (instruction.accounts.length < 6) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      credential: getNextAccount(),
      credentialTemplate: getNextAccount(),
      credentialType: getNextAccount(),
      subject: getNextAccount(),
      issuer: getNextAccount(),
      systemProgram: getNextAccount()
    },
    data: getIssueCredentialInstructionDataDecoder().decode(instruction.data)
  };
}
function getLinkExternalIdDiscriminatorBytes() {
  return fixEncoderSize2(getBytesEncoder(), 8).encode(LINK_EXTERNAL_ID_DISCRIMINATOR);
}
function getLinkExternalIdInstructionDataEncoder() {
  return transformEncoder2(getStructEncoder([
    ["discriminator", fixEncoderSize2(getBytesEncoder(), 8)],
    ["platform", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["externalId", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["verified", getBooleanEncoder()]
  ]), (value) => ({ ...value, discriminator: LINK_EXTERNAL_ID_DISCRIMINATOR }));
}
function getLinkExternalIdInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize2(getBytesDecoder(), 8)],
    ["platform", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["externalId", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["verified", getBooleanDecoder()]
  ]);
}
function getLinkExternalIdInstructionDataCodec() {
  return combineCodec2(getLinkExternalIdInstructionDataEncoder(), getLinkExternalIdInstructionDataDecoder());
}
async function getLinkExternalIdInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    agentAccount: { value: input.agentAccount ?? null, isWritable: true },
    externalIdMapping: {
      value: input.externalIdMapping ?? null,
      isWritable: true
    },
    authority: { value: input.authority ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.externalIdMapping.value) {
    accounts2.externalIdMapping.value = await getProgramDerivedAddress2({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([101, 120, 116, 101, 114, 110, 97, 108, 95, 105, 100])),
        getUtf8Encoder().encode(expectSome(args.platform)),
        getUtf8Encoder().encode(expectSome(args.externalId))
      ]
    });
  }
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.agentAccount),
      getAccountMeta(accounts2.externalIdMapping),
      getAccountMeta(accounts2.authority),
      getAccountMeta(accounts2.systemProgram)
    ],
    data: getLinkExternalIdInstructionDataEncoder().encode(args),
    programAddress
  });
}
function getLinkExternalIdInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    agentAccount: { value: input.agentAccount ?? null, isWritable: true },
    externalIdMapping: {
      value: input.externalIdMapping ?? null,
      isWritable: true
    },
    authority: { value: input.authority ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.agentAccount),
      getAccountMeta(accounts2.externalIdMapping),
      getAccountMeta(accounts2.authority),
      getAccountMeta(accounts2.systemProgram)
    ],
    data: getLinkExternalIdInstructionDataEncoder().encode(args),
    programAddress
  });
}
function parseLinkExternalIdInstruction(instruction) {
  if (instruction.accounts.length < 4) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      agentAccount: getNextAccount(),
      externalIdMapping: getNextAccount(),
      authority: getNextAccount(),
      systemProgram: getNextAccount()
    },
    data: getLinkExternalIdInstructionDataDecoder().decode(instruction.data)
  };
}
function getManageAgentStatusDiscriminatorBytes() {
  return fixEncoderSize2(getBytesEncoder(), 8).encode(MANAGE_AGENT_STATUS_DISCRIMINATOR);
}
function getManageAgentStatusInstructionDataEncoder() {
  return transformEncoder2(getStructEncoder([
    ["discriminator", fixEncoderSize2(getBytesEncoder(), 8)],
    ["newStatus", getBooleanEncoder()]
  ]), (value) => ({ ...value, discriminator: MANAGE_AGENT_STATUS_DISCRIMINATOR }));
}
function getManageAgentStatusInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize2(getBytesDecoder(), 8)],
    ["newStatus", getBooleanDecoder()]
  ]);
}
function getManageAgentStatusInstructionDataCodec() {
  return combineCodec2(getManageAgentStatusInstructionDataEncoder(), getManageAgentStatusInstructionDataDecoder());
}
async function getManageAgentStatusInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    agent: { value: input.agent ?? null, isWritable: true },
    owner: { value: input.owner ?? null, isWritable: false },
    clock: { value: input.clock ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.agent.value) {
    accounts2.agent.value = await getProgramDerivedAddress2({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([97, 103, 101, 110, 116])),
        getAddressEncoder2().encode(expectAddress(accounts2.owner.value))
      ]
    });
  }
  if (!accounts2.clock.value) {
    accounts2.clock.value = "SysvarC1ock11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.agent),
      getAccountMeta(accounts2.owner),
      getAccountMeta(accounts2.clock)
    ],
    data: getManageAgentStatusInstructionDataEncoder().encode(args),
    programAddress
  });
}
function getManageAgentStatusInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    agent: { value: input.agent ?? null, isWritable: true },
    owner: { value: input.owner ?? null, isWritable: false },
    clock: { value: input.clock ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.clock.value) {
    accounts2.clock.value = "SysvarC1ock11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.agent),
      getAccountMeta(accounts2.owner),
      getAccountMeta(accounts2.clock)
    ],
    data: getManageAgentStatusInstructionDataEncoder().encode(args),
    programAddress
  });
}
function parseManageAgentStatusInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      agent: getNextAccount(),
      owner: getNextAccount(),
      clock: getNextAccount()
    },
    data: getManageAgentStatusInstructionDataDecoder().decode(instruction.data)
  };
}
function getRecordPayaiPaymentDiscriminatorBytes() {
  return fixEncoderSize2(getBytesEncoder(), 8).encode(RECORD_PAYAI_PAYMENT_DISCRIMINATOR);
}
function getRecordPayaiPaymentInstructionDataEncoder() {
  return transformEncoder2(getStructEncoder([
    ["discriminator", fixEncoderSize2(getBytesEncoder(), 8)],
    [
      "paymentSignature",
      addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())
    ],
    ["amount", getU64Encoder()],
    ["responseTimeMs", getU64Encoder()],
    ["success", getBooleanEncoder()]
  ]), (value) => ({
    ...value,
    discriminator: RECORD_PAYAI_PAYMENT_DISCRIMINATOR
  }));
}
function getRecordPayaiPaymentInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize2(getBytesDecoder(), 8)],
    [
      "paymentSignature",
      addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())
    ],
    ["amount", getU64Decoder()],
    ["responseTimeMs", getU64Decoder()],
    ["success", getBooleanDecoder()]
  ]);
}
function getRecordPayaiPaymentInstructionDataCodec() {
  return combineCodec2(getRecordPayaiPaymentInstructionDataEncoder(), getRecordPayaiPaymentInstructionDataDecoder());
}
async function getRecordPayaiPaymentInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    reputationMetrics: {
      value: input.reputationMetrics ?? null,
      isWritable: true
    },
    agent: { value: input.agent ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: false },
    clock: { value: input.clock ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.reputationMetrics.value) {
    accounts2.reputationMetrics.value = await getProgramDerivedAddress2({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([
          114,
          101,
          112,
          117,
          116,
          97,
          116,
          105,
          111,
          110,
          95,
          109,
          101,
          116,
          114,
          105,
          99,
          115
        ])),
        getAddressEncoder2().encode(expectAddress(accounts2.agent.value))
      ]
    });
  }
  if (!accounts2.clock.value) {
    accounts2.clock.value = "SysvarC1ock11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.reputationMetrics),
      getAccountMeta(accounts2.agent),
      getAccountMeta(accounts2.authority),
      getAccountMeta(accounts2.clock)
    ],
    data: getRecordPayaiPaymentInstructionDataEncoder().encode(args),
    programAddress
  });
}
function getRecordPayaiPaymentInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    reputationMetrics: {
      value: input.reputationMetrics ?? null,
      isWritable: true
    },
    agent: { value: input.agent ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: false },
    clock: { value: input.clock ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.clock.value) {
    accounts2.clock.value = "SysvarC1ock11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.reputationMetrics),
      getAccountMeta(accounts2.agent),
      getAccountMeta(accounts2.authority),
      getAccountMeta(accounts2.clock)
    ],
    data: getRecordPayaiPaymentInstructionDataEncoder().encode(args),
    programAddress
  });
}
function parseRecordPayaiPaymentInstruction(instruction) {
  if (instruction.accounts.length < 4) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      reputationMetrics: getNextAccount(),
      agent: getNextAccount(),
      authority: getNextAccount(),
      clock: getNextAccount()
    },
    data: getRecordPayaiPaymentInstructionDataDecoder().decode(instruction.data)
  };
}
function getRegisterAgentDiscriminatorBytes() {
  return fixEncoderSize2(getBytesEncoder(), 8).encode(REGISTER_AGENT_DISCRIMINATOR);
}
function getRegisterAgentInstructionDataEncoder() {
  return transformEncoder2(getStructEncoder([
    ["discriminator", fixEncoderSize2(getBytesEncoder(), 8)],
    ["agentType", getU8Encoder()],
    ["name", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["description", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["metadataUri", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["agentId", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["pricingModel", getPricingModelEncoder()]
  ]), (value) => ({ ...value, discriminator: REGISTER_AGENT_DISCRIMINATOR }));
}
function getRegisterAgentInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize2(getBytesDecoder(), 8)],
    ["agentType", getU8Decoder()],
    ["name", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["description", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["metadataUri", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["agentId", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["pricingModel", getPricingModelDecoder()]
  ]);
}
function getRegisterAgentInstructionDataCodec() {
  return combineCodec2(getRegisterAgentInstructionDataEncoder(), getRegisterAgentInstructionDataDecoder());
}
async function getRegisterAgentInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    agentAccount: { value: input.agentAccount ?? null, isWritable: true },
    stakingAccount: { value: input.stakingAccount ?? null, isWritable: false },
    signer: { value: input.signer ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    clock: { value: input.clock ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.agentAccount.value) {
    accounts2.agentAccount.value = await getProgramDerivedAddress2({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([97, 103, 101, 110, 116])),
        getAddressEncoder2().encode(expectAddress(accounts2.signer.value)),
        getUtf8Encoder().encode(expectSome(args.agentId))
      ]
    });
  }
  if (!accounts2.stakingAccount.value) {
    accounts2.stakingAccount.value = await getProgramDerivedAddress2({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([115, 116, 97, 107, 105, 110, 103])),
        getAddressEncoder2().encode(expectAddress(accounts2.signer.value))
      ]
    });
  }
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  if (!accounts2.clock.value) {
    accounts2.clock.value = "SysvarC1ock11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.agentAccount),
      getAccountMeta(accounts2.stakingAccount),
      getAccountMeta(accounts2.signer),
      getAccountMeta(accounts2.systemProgram),
      getAccountMeta(accounts2.clock)
    ],
    data: getRegisterAgentInstructionDataEncoder().encode(args),
    programAddress
  });
}
function getRegisterAgentInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    agentAccount: { value: input.agentAccount ?? null, isWritable: true },
    stakingAccount: { value: input.stakingAccount ?? null, isWritable: false },
    signer: { value: input.signer ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    clock: { value: input.clock ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  if (!accounts2.clock.value) {
    accounts2.clock.value = "SysvarC1ock11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.agentAccount),
      getAccountMeta(accounts2.stakingAccount),
      getAccountMeta(accounts2.signer),
      getAccountMeta(accounts2.systemProgram),
      getAccountMeta(accounts2.clock)
    ],
    data: getRegisterAgentInstructionDataEncoder().encode(args),
    programAddress
  });
}
function parseRegisterAgentInstruction(instruction) {
  if (instruction.accounts.length < 5) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      agentAccount: getNextAccount(),
      stakingAccount: getNextAccount(),
      signer: getNextAccount(),
      systemProgram: getNextAccount(),
      clock: getNextAccount()
    },
    data: getRegisterAgentInstructionDataDecoder().decode(instruction.data)
  };
}
function getRegisterAgentCompressedDiscriminatorBytes() {
  return fixEncoderSize2(getBytesEncoder(), 8).encode(REGISTER_AGENT_COMPRESSED_DISCRIMINATOR);
}
function getRegisterAgentCompressedInstructionDataEncoder() {
  return transformEncoder2(getStructEncoder([
    ["discriminator", fixEncoderSize2(getBytesEncoder(), 8)],
    ["agentType", getU8Encoder()],
    ["metadataUri", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["agentId", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["name", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["description", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["pricingModel", getPricingModelEncoder()]
  ]), (value) => ({
    ...value,
    discriminator: REGISTER_AGENT_COMPRESSED_DISCRIMINATOR
  }));
}
function getRegisterAgentCompressedInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize2(getBytesDecoder(), 8)],
    ["agentType", getU8Decoder()],
    ["metadataUri", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["agentId", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["name", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["description", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["pricingModel", getPricingModelDecoder()]
  ]);
}
function getRegisterAgentCompressedInstructionDataCodec() {
  return combineCodec2(getRegisterAgentCompressedInstructionDataEncoder(), getRegisterAgentCompressedInstructionDataDecoder());
}
async function getRegisterAgentCompressedInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    treeAuthority: { value: input.treeAuthority ?? null, isWritable: true },
    merkleTree: { value: input.merkleTree ?? null, isWritable: true },
    userRegistry: { value: input.userRegistry ?? null, isWritable: true },
    signer: { value: input.signer ?? null, isWritable: true },
    compressionProgram: {
      value: input.compressionProgram ?? null,
      isWritable: false
    },
    logWrapper: { value: input.logWrapper ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    clock: { value: input.clock ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.treeAuthority.value) {
    accounts2.treeAuthority.value = await getProgramDerivedAddress2({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([
          97,
          103,
          101,
          110,
          116,
          95,
          116,
          114,
          101,
          101,
          95,
          99,
          111,
          110,
          102,
          105,
          103
        ])),
        getAddressEncoder2().encode(expectAddress(accounts2.signer.value))
      ]
    });
  }
  if (!accounts2.userRegistry.value) {
    accounts2.userRegistry.value = await getProgramDerivedAddress2({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([
          117,
          115,
          101,
          114,
          95,
          114,
          101,
          103,
          105,
          115,
          116,
          114,
          121
        ])),
        getAddressEncoder2().encode(expectAddress(accounts2.signer.value))
      ]
    });
  }
  if (!accounts2.compressionProgram.value) {
    accounts2.compressionProgram.value = "cmtDvXumGCrqC1Age74AVPhSRVXJMd8PJS91L8KbNCK";
  }
  if (!accounts2.logWrapper.value) {
    accounts2.logWrapper.value = "noopb9bkMVfRPU8AsbpTUg8AQkHtKwMYZiFUjNRtMmV";
  }
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  if (!accounts2.clock.value) {
    accounts2.clock.value = "SysvarC1ock11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.treeAuthority),
      getAccountMeta(accounts2.merkleTree),
      getAccountMeta(accounts2.userRegistry),
      getAccountMeta(accounts2.signer),
      getAccountMeta(accounts2.compressionProgram),
      getAccountMeta(accounts2.logWrapper),
      getAccountMeta(accounts2.systemProgram),
      getAccountMeta(accounts2.clock)
    ],
    data: getRegisterAgentCompressedInstructionDataEncoder().encode(args),
    programAddress
  });
}
function getRegisterAgentCompressedInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    treeAuthority: { value: input.treeAuthority ?? null, isWritable: true },
    merkleTree: { value: input.merkleTree ?? null, isWritable: true },
    userRegistry: { value: input.userRegistry ?? null, isWritable: true },
    signer: { value: input.signer ?? null, isWritable: true },
    compressionProgram: {
      value: input.compressionProgram ?? null,
      isWritable: false
    },
    logWrapper: { value: input.logWrapper ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    clock: { value: input.clock ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.compressionProgram.value) {
    accounts2.compressionProgram.value = "cmtDvXumGCrqC1Age74AVPhSRVXJMd8PJS91L8KbNCK";
  }
  if (!accounts2.logWrapper.value) {
    accounts2.logWrapper.value = "noopb9bkMVfRPU8AsbpTUg8AQkHtKwMYZiFUjNRtMmV";
  }
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  if (!accounts2.clock.value) {
    accounts2.clock.value = "SysvarC1ock11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.treeAuthority),
      getAccountMeta(accounts2.merkleTree),
      getAccountMeta(accounts2.userRegistry),
      getAccountMeta(accounts2.signer),
      getAccountMeta(accounts2.compressionProgram),
      getAccountMeta(accounts2.logWrapper),
      getAccountMeta(accounts2.systemProgram),
      getAccountMeta(accounts2.clock)
    ],
    data: getRegisterAgentCompressedInstructionDataEncoder().encode(args),
    programAddress
  });
}
function parseRegisterAgentCompressedInstruction(instruction) {
  if (instruction.accounts.length < 8) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      treeAuthority: getNextAccount(),
      merkleTree: getNextAccount(),
      userRegistry: getNextAccount(),
      signer: getNextAccount(),
      compressionProgram: getNextAccount(),
      logWrapper: getNextAccount(),
      systemProgram: getNextAccount(),
      clock: getNextAccount()
    },
    data: getRegisterAgentCompressedInstructionDataDecoder().decode(instruction.data)
  };
}
function getRegisterGhostMetadataDiscriminatorBytes() {
  return fixEncoderSize2(getBytesEncoder(), 8).encode(REGISTER_GHOST_METADATA_DISCRIMINATOR);
}
function getRegisterGhostMetadataInstructionDataEncoder() {
  return transformEncoder2(getStructEncoder([
    ["discriminator", fixEncoderSize2(getBytesEncoder(), 8)],
    ["name", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["description", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    [
      "capabilities",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    [
      "serviceEndpoint",
      getOptionEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ]
  ]), (value) => ({
    ...value,
    discriminator: REGISTER_GHOST_METADATA_DISCRIMINATOR
  }));
}
function getRegisterGhostMetadataInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize2(getBytesDecoder(), 8)],
    ["name", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["description", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    [
      "capabilities",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    [
      "serviceEndpoint",
      getOptionDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ]
  ]);
}
function getRegisterGhostMetadataInstructionDataCodec() {
  return combineCodec2(getRegisterGhostMetadataInstructionDataEncoder(), getRegisterGhostMetadataInstructionDataDecoder());
}
function getRegisterGhostMetadataInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    agentAccount: { value: input.agentAccount ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: true }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.agentAccount),
      getAccountMeta(accounts2.authority)
    ],
    data: getRegisterGhostMetadataInstructionDataEncoder().encode(args),
    programAddress
  });
}
function parseRegisterGhostMetadataInstruction(instruction) {
  if (instruction.accounts.length < 2) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: { agentAccount: getNextAccount(), authority: getNextAccount() },
    data: getRegisterGhostMetadataInstructionDataDecoder().decode(instruction.data)
  };
}
function getResetReentrancyGuardDiscriminatorBytes() {
  return fixEncoderSize2(getBytesEncoder(), 8).encode(RESET_REENTRANCY_GUARD_DISCRIMINATOR);
}
function getResetReentrancyGuardInstructionDataEncoder() {
  return transformEncoder2(getStructEncoder([["discriminator", fixEncoderSize2(getBytesEncoder(), 8)]]), (value) => ({
    ...value,
    discriminator: RESET_REENTRANCY_GUARD_DISCRIMINATOR
  }));
}
function getResetReentrancyGuardInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize2(getBytesDecoder(), 8)]
  ]);
}
function getResetReentrancyGuardInstructionDataCodec() {
  return combineCodec2(getResetReentrancyGuardInstructionDataEncoder(), getResetReentrancyGuardInstructionDataDecoder());
}
async function getResetReentrancyGuardInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    reentrancyGuard: { value: input.reentrancyGuard ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: true }
  };
  const accounts2 = originalAccounts;
  if (!accounts2.reentrancyGuard.value) {
    accounts2.reentrancyGuard.value = await getProgramDerivedAddress2({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([
          114,
          101,
          101,
          110,
          116,
          114,
          97,
          110,
          99,
          121,
          95,
          103,
          117,
          97,
          114,
          100
        ]))
      ]
    });
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.reentrancyGuard),
      getAccountMeta(accounts2.authority)
    ],
    data: getResetReentrancyGuardInstructionDataEncoder().encode({}),
    programAddress
  });
}
function getResetReentrancyGuardInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    reentrancyGuard: { value: input.reentrancyGuard ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: true }
  };
  const accounts2 = originalAccounts;
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.reentrancyGuard),
      getAccountMeta(accounts2.authority)
    ],
    data: getResetReentrancyGuardInstructionDataEncoder().encode({}),
    programAddress
  });
}
function parseResetReentrancyGuardInstruction(instruction) {
  if (instruction.accounts.length < 2) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      reentrancyGuard: getNextAccount(),
      authority: getNextAccount()
    },
    data: getResetReentrancyGuardInstructionDataDecoder().decode(instruction.data)
  };
}
function getResolveDidDocumentDiscriminatorBytes() {
  return fixEncoderSize2(getBytesEncoder(), 8).encode(RESOLVE_DID_DOCUMENT_DISCRIMINATOR);
}
function getResolveDidDocumentInstructionDataEncoder() {
  return transformEncoder2(getStructEncoder([["discriminator", fixEncoderSize2(getBytesEncoder(), 8)]]), (value) => ({
    ...value,
    discriminator: RESOLVE_DID_DOCUMENT_DISCRIMINATOR
  }));
}
function getResolveDidDocumentInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize2(getBytesDecoder(), 8)]
  ]);
}
function getResolveDidDocumentInstructionDataCodec() {
  return combineCodec2(getResolveDidDocumentInstructionDataEncoder(), getResolveDidDocumentInstructionDataDecoder());
}
async function getResolveDidDocumentInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    didDocument: { value: input.didDocument ?? null, isWritable: false },
    didController: { value: input.didController ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  if (!accounts2.didDocument.value) {
    accounts2.didDocument.value = await getProgramDerivedAddress2({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([
          100,
          105,
          100,
          95,
          100,
          111,
          99,
          117,
          109,
          101,
          110,
          116
        ])),
        getAddressEncoder2().encode(expectAddress(accounts2.didController.value))
      ]
    });
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.didDocument),
      getAccountMeta(accounts2.didController)
    ],
    data: getResolveDidDocumentInstructionDataEncoder().encode({}),
    programAddress
  });
}
function getResolveDidDocumentInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    didDocument: { value: input.didDocument ?? null, isWritable: false },
    didController: { value: input.didController ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.didDocument),
      getAccountMeta(accounts2.didController)
    ],
    data: getResolveDidDocumentInstructionDataEncoder().encode({}),
    programAddress
  });
}
function parseResolveDidDocumentInstruction(instruction) {
  if (instruction.accounts.length < 2) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      didDocument: getNextAccount(),
      didController: getNextAccount()
    },
    data: getResolveDidDocumentInstructionDataDecoder().decode(instruction.data)
  };
}
function getRevokeCredentialDiscriminatorBytes() {
  return fixEncoderSize2(getBytesEncoder(), 8).encode(REVOKE_CREDENTIAL_DISCRIMINATOR);
}
function getRevokeCredentialInstructionDataEncoder() {
  return transformEncoder2(getStructEncoder([["discriminator", fixEncoderSize2(getBytesEncoder(), 8)]]), (value) => ({ ...value, discriminator: REVOKE_CREDENTIAL_DISCRIMINATOR }));
}
function getRevokeCredentialInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize2(getBytesDecoder(), 8)]
  ]);
}
function getRevokeCredentialInstructionDataCodec() {
  return combineCodec2(getRevokeCredentialInstructionDataEncoder(), getRevokeCredentialInstructionDataDecoder());
}
function getRevokeCredentialInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    credential: { value: input.credential ?? null, isWritable: true },
    issuer: { value: input.issuer ?? null, isWritable: true }
  };
  const accounts2 = originalAccounts;
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.credential),
      getAccountMeta(accounts2.issuer)
    ],
    data: getRevokeCredentialInstructionDataEncoder().encode({}),
    programAddress
  });
}
function parseRevokeCredentialInstruction(instruction) {
  if (instruction.accounts.length < 2) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: { credential: getNextAccount(), issuer: getNextAccount() },
    data: getRevokeCredentialInstructionDataDecoder().decode(instruction.data)
  };
}
function getSlashStakeDiscriminatorBytes() {
  return fixEncoderSize2(getBytesEncoder(), 8).encode(SLASH_STAKE_DISCRIMINATOR);
}
function getSlashStakeInstructionDataEncoder() {
  return transformEncoder2(getStructEncoder([
    ["discriminator", fixEncoderSize2(getBytesEncoder(), 8)],
    ["owner", getAddressEncoder2()],
    ["reason", getSlashReasonEncoder()],
    ["customAmount", getOptionEncoder(getU64Encoder())]
  ]), (value) => ({ ...value, discriminator: SLASH_STAKE_DISCRIMINATOR }));
}
function getSlashStakeInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize2(getBytesDecoder(), 8)],
    ["owner", getAddressDecoder2()],
    ["reason", getSlashReasonDecoder()],
    ["customAmount", getOptionDecoder(getU64Decoder())]
  ]);
}
function getSlashStakeInstructionDataCodec() {
  return combineCodec2(getSlashStakeInstructionDataEncoder(), getSlashStakeInstructionDataDecoder());
}
async function getSlashStakeInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    stakingAccount: { value: input.stakingAccount ?? null, isWritable: true },
    stakingConfig: { value: input.stakingConfig ?? null, isWritable: false },
    stakingVault: { value: input.stakingVault ?? null, isWritable: true },
    treasury: { value: input.treasury ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: false },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.stakingAccount.value) {
    accounts2.stakingAccount.value = await getProgramDerivedAddress2({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([115, 116, 97, 107, 105, 110, 103])),
        getAddressEncoder2().encode(expectSome(args.owner))
      ]
    });
  }
  if (!accounts2.stakingConfig.value) {
    accounts2.stakingConfig.value = await getProgramDerivedAddress2({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([
          115,
          116,
          97,
          107,
          105,
          110,
          103,
          95,
          99,
          111,
          110,
          102,
          105,
          103
        ]))
      ]
    });
  }
  if (!accounts2.stakingVault.value) {
    accounts2.stakingVault.value = await getProgramDerivedAddress2({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([
          115,
          116,
          97,
          107,
          105,
          110,
          103,
          95,
          118,
          97,
          117,
          108,
          116
        ])),
        getAddressEncoder2().encode(expectAddress(accounts2.stakingConfig.value))
      ]
    });
  }
  if (!accounts2.tokenProgram.value) {
    accounts2.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.stakingAccount),
      getAccountMeta(accounts2.stakingConfig),
      getAccountMeta(accounts2.stakingVault),
      getAccountMeta(accounts2.treasury),
      getAccountMeta(accounts2.authority),
      getAccountMeta(accounts2.tokenProgram)
    ],
    data: getSlashStakeInstructionDataEncoder().encode(args),
    programAddress
  });
}
function getSlashStakeInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    stakingAccount: { value: input.stakingAccount ?? null, isWritable: true },
    stakingConfig: { value: input.stakingConfig ?? null, isWritable: false },
    stakingVault: { value: input.stakingVault ?? null, isWritable: true },
    treasury: { value: input.treasury ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: false },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.tokenProgram.value) {
    accounts2.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.stakingAccount),
      getAccountMeta(accounts2.stakingConfig),
      getAccountMeta(accounts2.stakingVault),
      getAccountMeta(accounts2.treasury),
      getAccountMeta(accounts2.authority),
      getAccountMeta(accounts2.tokenProgram)
    ],
    data: getSlashStakeInstructionDataEncoder().encode(args),
    programAddress
  });
}
function parseSlashStakeInstruction(instruction) {
  if (instruction.accounts.length < 6) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      stakingAccount: getNextAccount(),
      stakingConfig: getNextAccount(),
      stakingVault: getNextAccount(),
      treasury: getNextAccount(),
      authority: getNextAccount(),
      tokenProgram: getNextAccount()
    },
    data: getSlashStakeInstructionDataDecoder().decode(instruction.data)
  };
}
function getStakeGhostDiscriminatorBytes() {
  return fixEncoderSize2(getBytesEncoder(), 8).encode(STAKE_GHOST_DISCRIMINATOR);
}
function getStakeGhostInstructionDataEncoder() {
  return transformEncoder2(getStructEncoder([
    ["discriminator", fixEncoderSize2(getBytesEncoder(), 8)],
    ["amount", getU64Encoder()],
    ["lockDuration", getI64Encoder()]
  ]), (value) => ({ ...value, discriminator: STAKE_GHOST_DISCRIMINATOR }));
}
function getStakeGhostInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize2(getBytesDecoder(), 8)],
    ["amount", getU64Decoder()],
    ["lockDuration", getI64Decoder()]
  ]);
}
function getStakeGhostInstructionDataCodec() {
  return combineCodec2(getStakeGhostInstructionDataEncoder(), getStakeGhostInstructionDataDecoder());
}
async function getStakeGhostInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    stakingAccount: { value: input.stakingAccount ?? null, isWritable: true },
    ownerTokenAccount: {
      value: input.ownerTokenAccount ?? null,
      isWritable: true
    },
    stakingVault: { value: input.stakingVault ?? null, isWritable: true },
    stakingConfig: { value: input.stakingConfig ?? null, isWritable: false },
    ghostMint: { value: input.ghostMint ?? null, isWritable: false },
    owner: { value: input.owner ?? null, isWritable: true },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    rent: { value: input.rent ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.stakingAccount.value) {
    accounts2.stakingAccount.value = await getProgramDerivedAddress2({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([115, 116, 97, 107, 105, 110, 103])),
        getAddressEncoder2().encode(expectAddress(accounts2.owner.value))
      ]
    });
  }
  if (!accounts2.stakingVault.value) {
    accounts2.stakingVault.value = await getProgramDerivedAddress2({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([
          115,
          116,
          97,
          107,
          105,
          110,
          103,
          95,
          118,
          97,
          117,
          108,
          116
        ])),
        getAddressEncoder2().encode(expectAddress(accounts2.stakingConfig.value))
      ]
    });
  }
  if (!accounts2.tokenProgram.value) {
    accounts2.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  if (!accounts2.rent.value) {
    accounts2.rent.value = "SysvarRent111111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.stakingAccount),
      getAccountMeta(accounts2.ownerTokenAccount),
      getAccountMeta(accounts2.stakingVault),
      getAccountMeta(accounts2.stakingConfig),
      getAccountMeta(accounts2.ghostMint),
      getAccountMeta(accounts2.owner),
      getAccountMeta(accounts2.tokenProgram),
      getAccountMeta(accounts2.systemProgram),
      getAccountMeta(accounts2.rent)
    ],
    data: getStakeGhostInstructionDataEncoder().encode(args),
    programAddress
  });
}
function getStakeGhostInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    stakingAccount: { value: input.stakingAccount ?? null, isWritable: true },
    ownerTokenAccount: {
      value: input.ownerTokenAccount ?? null,
      isWritable: true
    },
    stakingVault: { value: input.stakingVault ?? null, isWritable: true },
    stakingConfig: { value: input.stakingConfig ?? null, isWritable: false },
    ghostMint: { value: input.ghostMint ?? null, isWritable: false },
    owner: { value: input.owner ?? null, isWritable: true },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    rent: { value: input.rent ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.tokenProgram.value) {
    accounts2.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  if (!accounts2.rent.value) {
    accounts2.rent.value = "SysvarRent111111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.stakingAccount),
      getAccountMeta(accounts2.ownerTokenAccount),
      getAccountMeta(accounts2.stakingVault),
      getAccountMeta(accounts2.stakingConfig),
      getAccountMeta(accounts2.ghostMint),
      getAccountMeta(accounts2.owner),
      getAccountMeta(accounts2.tokenProgram),
      getAccountMeta(accounts2.systemProgram),
      getAccountMeta(accounts2.rent)
    ],
    data: getStakeGhostInstructionDataEncoder().encode(args),
    programAddress
  });
}
function parseStakeGhostInstruction(instruction) {
  if (instruction.accounts.length < 9) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      stakingAccount: getNextAccount(),
      ownerTokenAccount: getNextAccount(),
      stakingVault: getNextAccount(),
      stakingConfig: getNextAccount(),
      ghostMint: getNextAccount(),
      owner: getNextAccount(),
      tokenProgram: getNextAccount(),
      systemProgram: getNextAccount(),
      rent: getNextAccount()
    },
    data: getStakeGhostInstructionDataDecoder().decode(instruction.data)
  };
}
function getSubmitDeliveryDiscriminatorBytes() {
  return fixEncoderSize2(getBytesEncoder(), 8).encode(SUBMIT_DELIVERY_DISCRIMINATOR);
}
function getSubmitDeliveryInstructionDataEncoder() {
  return transformEncoder2(getStructEncoder([
    ["discriminator", fixEncoderSize2(getBytesEncoder(), 8)],
    [
      "deliveryProof",
      addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())
    ]
  ]), (value) => ({ ...value, discriminator: SUBMIT_DELIVERY_DISCRIMINATOR }));
}
function getSubmitDeliveryInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize2(getBytesDecoder(), 8)],
    ["deliveryProof", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())]
  ]);
}
function getSubmitDeliveryInstructionDataCodec() {
  return combineCodec2(getSubmitDeliveryInstructionDataEncoder(), getSubmitDeliveryInstructionDataDecoder());
}
function getSubmitDeliveryInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    escrow: { value: input.escrow ?? null, isWritable: true },
    agent: { value: input.agent ?? null, isWritable: false },
    agentOwner: { value: input.agentOwner ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.escrow),
      getAccountMeta(accounts2.agent),
      getAccountMeta(accounts2.agentOwner)
    ],
    data: getSubmitDeliveryInstructionDataEncoder().encode(args),
    programAddress
  });
}
function parseSubmitDeliveryInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      escrow: getNextAccount(),
      agent: getNextAccount(),
      agentOwner: getNextAccount()
    },
    data: getSubmitDeliveryInstructionDataDecoder().decode(instruction.data)
  };
}
function getSubmitServiceRatingDiscriminatorBytes() {
  return fixEncoderSize2(getBytesEncoder(), 8).encode(SUBMIT_SERVICE_RATING_DISCRIMINATOR);
}
function getSubmitServiceRatingInstructionDataEncoder() {
  return transformEncoder2(getStructEncoder([
    ["discriminator", fixEncoderSize2(getBytesEncoder(), 8)],
    ["rating", getU8Encoder()],
    [
      "paymentSignature",
      addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())
    ]
  ]), (value) => ({
    ...value,
    discriminator: SUBMIT_SERVICE_RATING_DISCRIMINATOR
  }));
}
function getSubmitServiceRatingInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize2(getBytesDecoder(), 8)],
    ["rating", getU8Decoder()],
    [
      "paymentSignature",
      addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())
    ]
  ]);
}
function getSubmitServiceRatingInstructionDataCodec() {
  return combineCodec2(getSubmitServiceRatingInstructionDataEncoder(), getSubmitServiceRatingInstructionDataDecoder());
}
async function getSubmitServiceRatingInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    reputationMetrics: {
      value: input.reputationMetrics ?? null,
      isWritable: true
    },
    agent: { value: input.agent ?? null, isWritable: true },
    client: { value: input.client ?? null, isWritable: false },
    clock: { value: input.clock ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.reputationMetrics.value) {
    accounts2.reputationMetrics.value = await getProgramDerivedAddress2({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([
          114,
          101,
          112,
          117,
          116,
          97,
          116,
          105,
          111,
          110,
          95,
          109,
          101,
          116,
          114,
          105,
          99,
          115
        ])),
        getAddressEncoder2().encode(expectAddress(accounts2.agent.value))
      ]
    });
  }
  if (!accounts2.clock.value) {
    accounts2.clock.value = "SysvarC1ock11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.reputationMetrics),
      getAccountMeta(accounts2.agent),
      getAccountMeta(accounts2.client),
      getAccountMeta(accounts2.clock)
    ],
    data: getSubmitServiceRatingInstructionDataEncoder().encode(args),
    programAddress
  });
}
function getSubmitServiceRatingInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    reputationMetrics: {
      value: input.reputationMetrics ?? null,
      isWritable: true
    },
    agent: { value: input.agent ?? null, isWritable: true },
    client: { value: input.client ?? null, isWritable: false },
    clock: { value: input.clock ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.clock.value) {
    accounts2.clock.value = "SysvarC1ock11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.reputationMetrics),
      getAccountMeta(accounts2.agent),
      getAccountMeta(accounts2.client),
      getAccountMeta(accounts2.clock)
    ],
    data: getSubmitServiceRatingInstructionDataEncoder().encode(args),
    programAddress
  });
}
function parseSubmitServiceRatingInstruction(instruction) {
  if (instruction.accounts.length < 4) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      reputationMetrics: getNextAccount(),
      agent: getNextAccount(),
      client: getNextAccount(),
      clock: getNextAccount()
    },
    data: getSubmitServiceRatingInstructionDataDecoder().decode(instruction.data)
  };
}
function getUnstakeGhostDiscriminatorBytes() {
  return fixEncoderSize2(getBytesEncoder(), 8).encode(UNSTAKE_GHOST_DISCRIMINATOR);
}
function getUnstakeGhostInstructionDataEncoder() {
  return transformEncoder2(getStructEncoder([["discriminator", fixEncoderSize2(getBytesEncoder(), 8)]]), (value) => ({ ...value, discriminator: UNSTAKE_GHOST_DISCRIMINATOR }));
}
function getUnstakeGhostInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize2(getBytesDecoder(), 8)]
  ]);
}
function getUnstakeGhostInstructionDataCodec() {
  return combineCodec2(getUnstakeGhostInstructionDataEncoder(), getUnstakeGhostInstructionDataDecoder());
}
async function getUnstakeGhostInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    stakingAccount: { value: input.stakingAccount ?? null, isWritable: true },
    stakingConfig: { value: input.stakingConfig ?? null, isWritable: false },
    stakingVault: { value: input.stakingVault ?? null, isWritable: true },
    ownerTokenAccount: {
      value: input.ownerTokenAccount ?? null,
      isWritable: true
    },
    owner: { value: input.owner ?? null, isWritable: true },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  if (!accounts2.stakingAccount.value) {
    accounts2.stakingAccount.value = await getProgramDerivedAddress2({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([115, 116, 97, 107, 105, 110, 103])),
        getAddressEncoder2().encode(expectAddress(accounts2.owner.value))
      ]
    });
  }
  if (!accounts2.stakingConfig.value) {
    accounts2.stakingConfig.value = await getProgramDerivedAddress2({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([
          115,
          116,
          97,
          107,
          105,
          110,
          103,
          95,
          99,
          111,
          110,
          102,
          105,
          103
        ]))
      ]
    });
  }
  if (!accounts2.stakingVault.value) {
    accounts2.stakingVault.value = await getProgramDerivedAddress2({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([
          115,
          116,
          97,
          107,
          105,
          110,
          103,
          95,
          118,
          97,
          117,
          108,
          116
        ])),
        getAddressEncoder2().encode(expectAddress(accounts2.stakingConfig.value))
      ]
    });
  }
  if (!accounts2.tokenProgram.value) {
    accounts2.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.stakingAccount),
      getAccountMeta(accounts2.stakingConfig),
      getAccountMeta(accounts2.stakingVault),
      getAccountMeta(accounts2.ownerTokenAccount),
      getAccountMeta(accounts2.owner),
      getAccountMeta(accounts2.tokenProgram)
    ],
    data: getUnstakeGhostInstructionDataEncoder().encode({}),
    programAddress
  });
}
function getUnstakeGhostInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    stakingAccount: { value: input.stakingAccount ?? null, isWritable: true },
    stakingConfig: { value: input.stakingConfig ?? null, isWritable: false },
    stakingVault: { value: input.stakingVault ?? null, isWritable: true },
    ownerTokenAccount: {
      value: input.ownerTokenAccount ?? null,
      isWritable: true
    },
    owner: { value: input.owner ?? null, isWritable: true },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  if (!accounts2.tokenProgram.value) {
    accounts2.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.stakingAccount),
      getAccountMeta(accounts2.stakingConfig),
      getAccountMeta(accounts2.stakingVault),
      getAccountMeta(accounts2.ownerTokenAccount),
      getAccountMeta(accounts2.owner),
      getAccountMeta(accounts2.tokenProgram)
    ],
    data: getUnstakeGhostInstructionDataEncoder().encode({}),
    programAddress
  });
}
function parseUnstakeGhostInstruction(instruction) {
  if (instruction.accounts.length < 6) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      stakingAccount: getNextAccount(),
      stakingConfig: getNextAccount(),
      stakingVault: getNextAccount(),
      ownerTokenAccount: getNextAccount(),
      owner: getNextAccount(),
      tokenProgram: getNextAccount()
    },
    data: getUnstakeGhostInstructionDataDecoder().decode(instruction.data)
  };
}
function getUpdateAgentDiscriminatorBytes() {
  return fixEncoderSize2(getBytesEncoder(), 8).encode(UPDATE_AGENT_DISCRIMINATOR);
}
function getUpdateAgentInstructionDataEncoder() {
  return transformEncoder2(getStructEncoder([
    ["discriminator", fixEncoderSize2(getBytesEncoder(), 8)],
    ["agentType", getU8Encoder()],
    [
      "name",
      getOptionEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    [
      "description",
      getOptionEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    ["metadataUri", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["agentId", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["pricingModel", getOptionEncoder(getPricingModelEncoder())]
  ]), (value) => ({ ...value, discriminator: UPDATE_AGENT_DISCRIMINATOR }));
}
function getUpdateAgentInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize2(getBytesDecoder(), 8)],
    ["agentType", getU8Decoder()],
    [
      "name",
      getOptionDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    [
      "description",
      getOptionDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    ["metadataUri", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["agentId", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["pricingModel", getOptionDecoder(getPricingModelDecoder())]
  ]);
}
function getUpdateAgentInstructionDataCodec() {
  return combineCodec2(getUpdateAgentInstructionDataEncoder(), getUpdateAgentInstructionDataDecoder());
}
async function getUpdateAgentInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    agentAccount: { value: input.agentAccount ?? null, isWritable: true },
    signer: { value: input.signer ?? null, isWritable: true },
    clock: { value: input.clock ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.agentAccount.value) {
    accounts2.agentAccount.value = await getProgramDerivedAddress2({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([97, 103, 101, 110, 116])),
        getAddressEncoder2().encode(expectAddress(accounts2.signer.value)),
        getUtf8Encoder().encode(expectSome(args.agentId))
      ]
    });
  }
  if (!accounts2.clock.value) {
    accounts2.clock.value = "SysvarC1ock11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.agentAccount),
      getAccountMeta(accounts2.signer),
      getAccountMeta(accounts2.clock)
    ],
    data: getUpdateAgentInstructionDataEncoder().encode(args),
    programAddress
  });
}
function getUpdateAgentInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    agentAccount: { value: input.agentAccount ?? null, isWritable: true },
    signer: { value: input.signer ?? null, isWritable: true },
    clock: { value: input.clock ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.clock.value) {
    accounts2.clock.value = "SysvarC1ock11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.agentAccount),
      getAccountMeta(accounts2.signer),
      getAccountMeta(accounts2.clock)
    ],
    data: getUpdateAgentInstructionDataEncoder().encode(args),
    programAddress
  });
}
function parseUpdateAgentInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      agentAccount: getNextAccount(),
      signer: getNextAccount(),
      clock: getNextAccount()
    },
    data: getUpdateAgentInstructionDataDecoder().decode(instruction.data)
  };
}
function getUpdateAgentReputationDiscriminatorBytes() {
  return fixEncoderSize2(getBytesEncoder(), 8).encode(UPDATE_AGENT_REPUTATION_DISCRIMINATOR);
}
function getUpdateAgentReputationInstructionDataEncoder() {
  return transformEncoder2(getStructEncoder([
    ["discriminator", fixEncoderSize2(getBytesEncoder(), 8)],
    ["agentId", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["reputationScore", getU64Encoder()]
  ]), (value) => ({
    ...value,
    discriminator: UPDATE_AGENT_REPUTATION_DISCRIMINATOR
  }));
}
function getUpdateAgentReputationInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize2(getBytesDecoder(), 8)],
    ["agentId", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["reputationScore", getU64Decoder()]
  ]);
}
function getUpdateAgentReputationInstructionDataCodec() {
  return combineCodec2(getUpdateAgentReputationInstructionDataEncoder(), getUpdateAgentReputationInstructionDataDecoder());
}
async function getUpdateAgentReputationInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    agentAccount: { value: input.agentAccount ?? null, isWritable: true },
    signer: { value: input.signer ?? null, isWritable: true },
    clock: { value: input.clock ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.agentAccount.value) {
    accounts2.agentAccount.value = await getProgramDerivedAddress2({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([97, 103, 101, 110, 116])),
        getAddressEncoder2().encode(expectAddress(accounts2.signer.value)),
        getUtf8Encoder().encode(expectSome(args.agentId))
      ]
    });
  }
  if (!accounts2.clock.value) {
    accounts2.clock.value = "SysvarC1ock11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.agentAccount),
      getAccountMeta(accounts2.signer),
      getAccountMeta(accounts2.clock)
    ],
    data: getUpdateAgentReputationInstructionDataEncoder().encode(args),
    programAddress
  });
}
function getUpdateAgentReputationInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    agentAccount: { value: input.agentAccount ?? null, isWritable: true },
    signer: { value: input.signer ?? null, isWritable: true },
    clock: { value: input.clock ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.clock.value) {
    accounts2.clock.value = "SysvarC1ock11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.agentAccount),
      getAccountMeta(accounts2.signer),
      getAccountMeta(accounts2.clock)
    ],
    data: getUpdateAgentReputationInstructionDataEncoder().encode(args),
    programAddress
  });
}
function parseUpdateAgentReputationInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      agentAccount: getNextAccount(),
      signer: getNextAccount(),
      clock: getNextAccount()
    },
    data: getUpdateAgentReputationInstructionDataDecoder().decode(instruction.data)
  };
}
function getUpdateAgentServiceDiscriminatorBytes() {
  return fixEncoderSize2(getBytesEncoder(), 8).encode(UPDATE_AGENT_SERVICE_DISCRIMINATOR);
}
function getUpdateAgentServiceInstructionDataEncoder() {
  return transformEncoder2(getStructEncoder([
    ["discriminator", fixEncoderSize2(getBytesEncoder(), 8)],
    ["agentPubkey", getAddressEncoder2()],
    [
      "serviceEndpoint",
      addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())
    ],
    ["isActive", getBooleanEncoder()],
    ["lastUpdated", getI64Encoder()],
    [
      "metadataUri",
      getOptionEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    [
      "capabilities",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ]
  ]), (value) => ({
    ...value,
    discriminator: UPDATE_AGENT_SERVICE_DISCRIMINATOR
  }));
}
function getUpdateAgentServiceInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize2(getBytesDecoder(), 8)],
    ["agentPubkey", getAddressDecoder2()],
    [
      "serviceEndpoint",
      addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())
    ],
    ["isActive", getBooleanDecoder()],
    ["lastUpdated", getI64Decoder()],
    [
      "metadataUri",
      getOptionDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    [
      "capabilities",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ]
  ]);
}
function getUpdateAgentServiceInstructionDataCodec() {
  return combineCodec2(getUpdateAgentServiceInstructionDataEncoder(), getUpdateAgentServiceInstructionDataDecoder());
}
async function getUpdateAgentServiceInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    agent: { value: input.agent ?? null, isWritable: true },
    owner: { value: input.owner ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.agent.value) {
    accounts2.agent.value = await getProgramDerivedAddress2({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([97, 103, 101, 110, 116])),
        getAddressEncoder2().encode(expectAddress(accounts2.owner.value))
      ]
    });
  }
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.agent),
      getAccountMeta(accounts2.owner),
      getAccountMeta(accounts2.systemProgram)
    ],
    data: getUpdateAgentServiceInstructionDataEncoder().encode(args),
    programAddress
  });
}
function getUpdateAgentServiceInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    agent: { value: input.agent ?? null, isWritable: true },
    owner: { value: input.owner ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.agent),
      getAccountMeta(accounts2.owner),
      getAccountMeta(accounts2.systemProgram)
    ],
    data: getUpdateAgentServiceInstructionDataEncoder().encode(args),
    programAddress
  });
}
function parseUpdateAgentServiceInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      agent: getNextAccount(),
      owner: getNextAccount(),
      systemProgram: getNextAccount()
    },
    data: getUpdateAgentServiceInstructionDataDecoder().decode(instruction.data)
  };
}
function getUpdateCrosschainStatusDiscriminatorBytes() {
  return fixEncoderSize2(getBytesEncoder(), 8).encode(UPDATE_CROSSCHAIN_STATUS_DISCRIMINATOR);
}
function getUpdateCrosschainStatusInstructionDataEncoder() {
  return transformEncoder2(getStructEncoder([
    ["discriminator", fixEncoderSize2(getBytesEncoder(), 8)],
    [
      "crossmintCredentialId",
      addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())
    ],
    ["status", getCrossChainStatusEncoder()]
  ]), (value) => ({
    ...value,
    discriminator: UPDATE_CROSSCHAIN_STATUS_DISCRIMINATOR
  }));
}
function getUpdateCrosschainStatusInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize2(getBytesDecoder(), 8)],
    [
      "crossmintCredentialId",
      addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())
    ],
    ["status", getCrossChainStatusDecoder()]
  ]);
}
function getUpdateCrosschainStatusInstructionDataCodec() {
  return combineCodec2(getUpdateCrosschainStatusInstructionDataEncoder(), getUpdateCrosschainStatusInstructionDataDecoder());
}
function getUpdateCrosschainStatusInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    credential: { value: input.credential ?? null, isWritable: true },
    issuer: { value: input.issuer ?? null, isWritable: true }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.credential),
      getAccountMeta(accounts2.issuer)
    ],
    data: getUpdateCrosschainStatusInstructionDataEncoder().encode(args),
    programAddress
  });
}
function parseUpdateCrosschainStatusInstruction(instruction) {
  if (instruction.accounts.length < 2) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: { credential: getNextAccount(), issuer: getNextAccount() },
    data: getUpdateCrosschainStatusInstructionDataDecoder().decode(instruction.data)
  };
}
function getUpdateDidDocumentDiscriminatorBytes() {
  return fixEncoderSize2(getBytesEncoder(), 8).encode(UPDATE_DID_DOCUMENT_DISCRIMINATOR);
}
function getUpdateDidDocumentInstructionDataEncoder() {
  return transformEncoder2(getStructEncoder([
    ["discriminator", fixEncoderSize2(getBytesEncoder(), 8)],
    [
      "addVerificationMethod",
      getOptionEncoder(getVerificationMethodEncoder())
    ],
    [
      "removeVerificationMethodId",
      getOptionEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    ["addServiceEndpoint", getOptionEncoder(getServiceEndpointEncoder())],
    [
      "removeServiceEndpointId",
      getOptionEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ]
  ]), (value) => ({ ...value, discriminator: UPDATE_DID_DOCUMENT_DISCRIMINATOR }));
}
function getUpdateDidDocumentInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize2(getBytesDecoder(), 8)],
    ["addVerificationMethod", getOptionDecoder(getVerificationMethodDecoder())],
    [
      "removeVerificationMethodId",
      getOptionDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    ["addServiceEndpoint", getOptionDecoder(getServiceEndpointDecoder())],
    [
      "removeServiceEndpointId",
      getOptionDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ]
  ]);
}
function getUpdateDidDocumentInstructionDataCodec() {
  return combineCodec2(getUpdateDidDocumentInstructionDataEncoder(), getUpdateDidDocumentInstructionDataDecoder());
}
async function getUpdateDidDocumentInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    didDocument: { value: input.didDocument ?? null, isWritable: true },
    controller: { value: input.controller ?? null, isWritable: true },
    clock: { value: input.clock ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.didDocument.value) {
    accounts2.didDocument.value = await getProgramDerivedAddress2({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([
          100,
          105,
          100,
          95,
          100,
          111,
          99,
          117,
          109,
          101,
          110,
          116
        ])),
        getAddressEncoder2().encode(expectAddress(accounts2.controller.value))
      ]
    });
  }
  if (!accounts2.clock.value) {
    accounts2.clock.value = "SysvarC1ock11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.didDocument),
      getAccountMeta(accounts2.controller),
      getAccountMeta(accounts2.clock)
    ],
    data: getUpdateDidDocumentInstructionDataEncoder().encode(args),
    programAddress
  });
}
function getUpdateDidDocumentInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    didDocument: { value: input.didDocument ?? null, isWritable: true },
    controller: { value: input.controller ?? null, isWritable: true },
    clock: { value: input.clock ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.clock.value) {
    accounts2.clock.value = "SysvarC1ock11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.didDocument),
      getAccountMeta(accounts2.controller),
      getAccountMeta(accounts2.clock)
    ],
    data: getUpdateDidDocumentInstructionDataEncoder().encode(args),
    programAddress
  });
}
function parseUpdateDidDocumentInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      didDocument: getNextAccount(),
      controller: getNextAccount(),
      clock: getNextAccount()
    },
    data: getUpdateDidDocumentInstructionDataDecoder().decode(instruction.data)
  };
}
function getUpdateGhostScoreDiscriminatorBytes() {
  return fixEncoderSize2(getBytesEncoder(), 8).encode(UPDATE_GHOST_SCORE_DISCRIMINATOR);
}
function getUpdateGhostScoreInstructionDataEncoder() {
  return transformEncoder2(getStructEncoder([
    ["discriminator", fixEncoderSize2(getBytesEncoder(), 8)],
    ["newScore", getU64Encoder()],
    [
      "components",
      getOptionEncoder(getArrayEncoder(getReputationComponentEncoder()))
    ]
  ]), (value) => ({ ...value, discriminator: UPDATE_GHOST_SCORE_DISCRIMINATOR }));
}
function getUpdateGhostScoreInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize2(getBytesDecoder(), 8)],
    ["newScore", getU64Decoder()],
    [
      "components",
      getOptionDecoder(getArrayDecoder(getReputationComponentDecoder()))
    ]
  ]);
}
function getUpdateGhostScoreInstructionDataCodec() {
  return combineCodec2(getUpdateGhostScoreInstructionDataEncoder(), getUpdateGhostScoreInstructionDataDecoder());
}
function getUpdateGhostScoreInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    agentAccount: { value: input.agentAccount ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.agentAccount),
      getAccountMeta(accounts2.authority)
    ],
    data: getUpdateGhostScoreInstructionDataEncoder().encode(args),
    programAddress
  });
}
function parseUpdateGhostScoreInstruction(instruction) {
  if (instruction.accounts.length < 2) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: { agentAccount: getNextAccount(), authority: getNextAccount() },
    data: getUpdateGhostScoreInstructionDataDecoder().decode(instruction.data)
  };
}
function getUpdateProtocolConfigDiscriminatorBytes() {
  return fixEncoderSize2(getBytesEncoder(), 8).encode(UPDATE_PROTOCOL_CONFIG_DISCRIMINATOR);
}
function getUpdateProtocolConfigInstructionDataEncoder() {
  return transformEncoder2(getStructEncoder([
    ["discriminator", fixEncoderSize2(getBytesEncoder(), 8)],
    ["escrowFeeBps", getOptionEncoder(getU16Encoder())],
    ["agentRegistrationFee", getOptionEncoder(getU64Encoder())],
    ["listingFee", getOptionEncoder(getU64Encoder())],
    ["disputeFeeBps", getOptionEncoder(getU16Encoder())],
    ["feesEnabled", getOptionEncoder(getBooleanEncoder())],
    ["treasury", getOptionEncoder(getAddressEncoder2())],
    ["buybackPool", getOptionEncoder(getAddressEncoder2())],
    ["moderatorPool", getOptionEncoder(getAddressEncoder2())]
  ]), (value) => ({
    ...value,
    discriminator: UPDATE_PROTOCOL_CONFIG_DISCRIMINATOR
  }));
}
function getUpdateProtocolConfigInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize2(getBytesDecoder(), 8)],
    ["escrowFeeBps", getOptionDecoder(getU16Decoder())],
    ["agentRegistrationFee", getOptionDecoder(getU64Decoder())],
    ["listingFee", getOptionDecoder(getU64Decoder())],
    ["disputeFeeBps", getOptionDecoder(getU16Decoder())],
    ["feesEnabled", getOptionDecoder(getBooleanDecoder())],
    ["treasury", getOptionDecoder(getAddressDecoder2())],
    ["buybackPool", getOptionDecoder(getAddressDecoder2())],
    ["moderatorPool", getOptionDecoder(getAddressDecoder2())]
  ]);
}
function getUpdateProtocolConfigInstructionDataCodec() {
  return combineCodec2(getUpdateProtocolConfigInstructionDataEncoder(), getUpdateProtocolConfigInstructionDataDecoder());
}
async function getUpdateProtocolConfigInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    config: { value: input.config ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.config.value) {
    accounts2.config.value = await getProgramDerivedAddress2({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([
          112,
          114,
          111,
          116,
          111,
          99,
          111,
          108,
          95,
          99,
          111,
          110,
          102,
          105,
          103
        ]))
      ]
    });
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.config),
      getAccountMeta(accounts2.authority)
    ],
    data: getUpdateProtocolConfigInstructionDataEncoder().encode(args),
    programAddress
  });
}
function getUpdateProtocolConfigInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    config: { value: input.config ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.config),
      getAccountMeta(accounts2.authority)
    ],
    data: getUpdateProtocolConfigInstructionDataEncoder().encode(args),
    programAddress
  });
}
function parseUpdateProtocolConfigInstruction(instruction) {
  if (instruction.accounts.length < 2) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: { config: getNextAccount(), authority: getNextAccount() },
    data: getUpdateProtocolConfigInstructionDataDecoder().decode(instruction.data)
  };
}
function getUpdateReputationTagsDiscriminatorBytes() {
  return fixEncoderSize2(getBytesEncoder(), 8).encode(UPDATE_REPUTATION_TAGS_DISCRIMINATOR);
}
function getUpdateReputationTagsInstructionDataEncoder() {
  return transformEncoder2(getStructEncoder([
    ["discriminator", fixEncoderSize2(getBytesEncoder(), 8)],
    [
      "skillTags",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    [
      "behaviorTags",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    [
      "complianceTags",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    ["tagScores", getArrayEncoder(getTagScoreEncoder())]
  ]), (value) => ({
    ...value,
    discriminator: UPDATE_REPUTATION_TAGS_DISCRIMINATOR
  }));
}
function getUpdateReputationTagsInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize2(getBytesDecoder(), 8)],
    [
      "skillTags",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    [
      "behaviorTags",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    [
      "complianceTags",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    ["tagScores", getArrayDecoder(getTagScoreDecoder())]
  ]);
}
function getUpdateReputationTagsInstructionDataCodec() {
  return combineCodec2(getUpdateReputationTagsInstructionDataEncoder(), getUpdateReputationTagsInstructionDataDecoder());
}
async function getUpdateReputationTagsInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    reputationMetrics: {
      value: input.reputationMetrics ?? null,
      isWritable: true
    },
    agent: { value: input.agent ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: false },
    clock: { value: input.clock ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.reputationMetrics.value) {
    accounts2.reputationMetrics.value = await getProgramDerivedAddress2({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([
          114,
          101,
          112,
          117,
          116,
          97,
          116,
          105,
          111,
          110,
          95,
          109,
          101,
          116,
          114,
          105,
          99,
          115
        ])),
        getAddressEncoder2().encode(expectAddress(accounts2.agent.value))
      ]
    });
  }
  if (!accounts2.clock.value) {
    accounts2.clock.value = "SysvarC1ock11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.reputationMetrics),
      getAccountMeta(accounts2.agent),
      getAccountMeta(accounts2.authority),
      getAccountMeta(accounts2.clock)
    ],
    data: getUpdateReputationTagsInstructionDataEncoder().encode(args),
    programAddress
  });
}
function getUpdateReputationTagsInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    reputationMetrics: {
      value: input.reputationMetrics ?? null,
      isWritable: true
    },
    agent: { value: input.agent ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: false },
    clock: { value: input.clock ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.clock.value) {
    accounts2.clock.value = "SysvarC1ock11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.reputationMetrics),
      getAccountMeta(accounts2.agent),
      getAccountMeta(accounts2.authority),
      getAccountMeta(accounts2.clock)
    ],
    data: getUpdateReputationTagsInstructionDataEncoder().encode(args),
    programAddress
  });
}
function parseUpdateReputationTagsInstruction(instruction) {
  if (instruction.accounts.length < 4) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      reputationMetrics: getNextAccount(),
      agent: getNextAccount(),
      authority: getNextAccount(),
      clock: getNextAccount()
    },
    data: getUpdateReputationTagsInstructionDataDecoder().decode(instruction.data)
  };
}
function getUpdateSourceReputationDiscriminatorBytes() {
  return fixEncoderSize2(getBytesEncoder(), 8).encode(UPDATE_SOURCE_REPUTATION_DISCRIMINATOR);
}
function getUpdateSourceReputationInstructionDataEncoder() {
  return transformEncoder2(getStructEncoder([
    ["discriminator", fixEncoderSize2(getBytesEncoder(), 8)],
    ["sourceName", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["score", getU16Encoder()],
    ["weight", getU16Encoder()],
    ["dataPoints", getU32Encoder()],
    ["reliability", getU16Encoder()]
  ]), (value) => ({
    ...value,
    discriminator: UPDATE_SOURCE_REPUTATION_DISCRIMINATOR
  }));
}
function getUpdateSourceReputationInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize2(getBytesDecoder(), 8)],
    ["sourceName", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["score", getU16Decoder()],
    ["weight", getU16Decoder()],
    ["dataPoints", getU32Decoder()],
    ["reliability", getU16Decoder()]
  ]);
}
function getUpdateSourceReputationInstructionDataCodec() {
  return combineCodec2(getUpdateSourceReputationInstructionDataEncoder(), getUpdateSourceReputationInstructionDataDecoder());
}
async function getUpdateSourceReputationInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    reputationMetrics: {
      value: input.reputationMetrics ?? null,
      isWritable: true
    },
    agent: { value: input.agent ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: false },
    clock: { value: input.clock ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.reputationMetrics.value) {
    accounts2.reputationMetrics.value = await getProgramDerivedAddress2({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([
          114,
          101,
          112,
          117,
          116,
          97,
          116,
          105,
          111,
          110,
          95,
          109,
          101,
          116,
          114,
          105,
          99,
          115
        ])),
        getAddressEncoder2().encode(expectAddress(accounts2.agent.value))
      ]
    });
  }
  if (!accounts2.clock.value) {
    accounts2.clock.value = "SysvarC1ock11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.reputationMetrics),
      getAccountMeta(accounts2.agent),
      getAccountMeta(accounts2.authority),
      getAccountMeta(accounts2.clock)
    ],
    data: getUpdateSourceReputationInstructionDataEncoder().encode(args),
    programAddress
  });
}
function getUpdateSourceReputationInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    reputationMetrics: {
      value: input.reputationMetrics ?? null,
      isWritable: true
    },
    agent: { value: input.agent ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: false },
    clock: { value: input.clock ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.clock.value) {
    accounts2.clock.value = "SysvarC1ock11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.reputationMetrics),
      getAccountMeta(accounts2.agent),
      getAccountMeta(accounts2.authority),
      getAccountMeta(accounts2.clock)
    ],
    data: getUpdateSourceReputationInstructionDataEncoder().encode(args),
    programAddress
  });
}
function parseUpdateSourceReputationInstruction(instruction) {
  if (instruction.accounts.length < 4) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      reputationMetrics: getNextAccount(),
      agent: getNextAccount(),
      authority: getNextAccount(),
      clock: getNextAccount()
    },
    data: getUpdateSourceReputationInstructionDataDecoder().decode(instruction.data)
  };
}
function getVerifyAgentDiscriminatorBytes() {
  return fixEncoderSize2(getBytesEncoder(), 8).encode(VERIFY_AGENT_DISCRIMINATOR);
}
function getVerifyAgentInstructionDataEncoder() {
  return transformEncoder2(getStructEncoder([
    ["discriminator", fixEncoderSize2(getBytesEncoder(), 8)],
    ["agentPubkey", getAddressEncoder2()],
    [
      "serviceEndpoint",
      addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())
    ],
    ["supportedCapabilities", getArrayEncoder(getU64Encoder())],
    ["verifiedAt", getI64Encoder()]
  ]), (value) => ({ ...value, discriminator: VERIFY_AGENT_DISCRIMINATOR }));
}
function getVerifyAgentInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize2(getBytesDecoder(), 8)],
    ["agentPubkey", getAddressDecoder2()],
    [
      "serviceEndpoint",
      addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())
    ],
    ["supportedCapabilities", getArrayDecoder(getU64Decoder())],
    ["verifiedAt", getI64Decoder()]
  ]);
}
function getVerifyAgentInstructionDataCodec() {
  return combineCodec2(getVerifyAgentInstructionDataEncoder(), getVerifyAgentInstructionDataDecoder());
}
async function getVerifyAgentInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    agentVerification: {
      value: input.agentVerification ?? null,
      isWritable: true
    },
    agent: { value: input.agent ?? null, isWritable: false },
    verifier: { value: input.verifier ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    clock: { value: input.clock ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.agentVerification.value) {
    accounts2.agentVerification.value = await getProgramDerivedAddress2({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([
          97,
          103,
          101,
          110,
          116,
          95,
          118,
          101,
          114,
          105,
          102,
          105,
          99,
          97,
          116,
          105,
          111,
          110
        ])),
        getAddressEncoder2().encode(expectAddress(accounts2.agent.value)),
        getAddressEncoder2().encode(expectAddress(accounts2.verifier.value))
      ]
    });
  }
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  if (!accounts2.clock.value) {
    accounts2.clock.value = "SysvarC1ock11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.agentVerification),
      getAccountMeta(accounts2.agent),
      getAccountMeta(accounts2.verifier),
      getAccountMeta(accounts2.systemProgram),
      getAccountMeta(accounts2.clock)
    ],
    data: getVerifyAgentInstructionDataEncoder().encode(args),
    programAddress
  });
}
function getVerifyAgentInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    agentVerification: {
      value: input.agentVerification ?? null,
      isWritable: true
    },
    agent: { value: input.agent ?? null, isWritable: false },
    verifier: { value: input.verifier ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    clock: { value: input.clock ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  if (!accounts2.clock.value) {
    accounts2.clock.value = "SysvarC1ock11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.agentVerification),
      getAccountMeta(accounts2.agent),
      getAccountMeta(accounts2.verifier),
      getAccountMeta(accounts2.systemProgram),
      getAccountMeta(accounts2.clock)
    ],
    data: getVerifyAgentInstructionDataEncoder().encode(args),
    programAddress
  });
}
function parseVerifyAgentInstruction(instruction) {
  if (instruction.accounts.length < 5) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      agentVerification: getNextAccount(),
      agent: getNextAccount(),
      verifier: getNextAccount(),
      systemProgram: getNextAccount(),
      clock: getNextAccount()
    },
    data: getVerifyAgentInstructionDataDecoder().decode(instruction.data)
  };
}
function getVerifyAuthorizationDiscriminatorBytes() {
  return fixEncoderSize2(getBytesEncoder(), 8).encode(VERIFY_AUTHORIZATION_DISCRIMINATOR);
}
function getVerifyAuthorizationInstructionDataEncoder() {
  return transformEncoder2(getStructEncoder([
    ["discriminator", fixEncoderSize2(getBytesEncoder(), 8)],
    [
      "nonce",
      getOptionEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ]
  ]), (value) => ({
    ...value,
    discriminator: VERIFY_AUTHORIZATION_DISCRIMINATOR
  }));
}
function getVerifyAuthorizationInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize2(getBytesDecoder(), 8)],
    [
      "nonce",
      getOptionDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ]
  ]);
}
function getVerifyAuthorizationInstructionDataCodec() {
  return combineCodec2(getVerifyAuthorizationInstructionDataEncoder(), getVerifyAuthorizationInstructionDataDecoder());
}
function getVerifyAuthorizationInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    agent: { value: input.agent ?? null, isWritable: false },
    authorization: { value: input.authorization ?? null, isWritable: false },
    clock: { value: input.clock ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.clock.value) {
    accounts2.clock.value = "SysvarC1ock11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.agent),
      getAccountMeta(accounts2.authorization),
      getAccountMeta(accounts2.clock)
    ],
    data: getVerifyAuthorizationInstructionDataEncoder().encode(args),
    programAddress
  });
}
function parseVerifyAuthorizationInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      agent: getNextAccount(),
      authorization: getNextAccount(),
      clock: getNextAccount()
    },
    data: getVerifyAuthorizationInstructionDataDecoder().decode(instruction.data)
  };
}
var AGENT_REPUTATION_AUTH_DISCRIMINATOR, AGENT_TREE_CONFIG_DISCRIMINATOR, AGENT_VERIFICATION_DISCRIMINATOR, AUDIT_TRAIL_DISCRIMINATOR, AUTHORIZATION_USAGE_RECORD_DISCRIMINATOR, COMPLIANCE_REPORT_DISCRIMINATOR, CREDENTIAL_DISCRIMINATOR, CREDENTIAL_TEMPLATE_DISCRIMINATOR, CREDENTIAL_TYPE_DISCRIMINATOR, DID_DOCUMENT_DISCRIMINATOR, EXTERNAL_ID_MAPPING_DISCRIMINATOR, GHOST_PROTECT_ESCROW_DISCRIMINATOR, GOVERNANCE_PROPOSAL_DISCRIMINATOR, MULTISIG_DISCRIMINATOR, PROTOCOL_CONFIG_DISCRIMINATOR, RBAC_CONFIG_DISCRIMINATOR, REENTRANCY_GUARD_DISCRIMINATOR, REPUTATION_METRICS_DISCRIMINATOR, STAKING_ACCOUNT_DISCRIMINATOR, STAKING_CONFIG_DISCRIMINATOR, USER_REGISTRY_DISCRIMINATOR, GHOSTSPEAK_MARKETPLACE_ERROR__SYSTEM_PROGRAM_AS_ADMIN = 6000, GHOSTSPEAK_MARKETPLACE_ERROR__DEFAULT_KEY_AS_ADMIN = 6001, GHOSTSPEAK_MARKETPLACE_ERROR__UNAUTHORIZED_ADMIN = 6002, GHOSTSPEAK_MARKETPLACE_ERROR__TEST_ADDRESS_ON_MAINNET = 6003, GHOSTSPEAK_MARKETPLACE_ERROR__VALIDATION_FAILED = 6004, ghostspeakMarketplaceErrorMessages, ACTIVATE_AGENT_DISCRIMINATOR, APPROVE_DELIVERY_DISCRIMINATOR, ARBITRATE_DISPUTE_DISCRIMINATOR, AUTO_CREATE_GHOST_DISCRIMINATOR, CLAIM_GHOST_DISCRIMINATOR, CREATE_CREDENTIAL_TEMPLATE_DISCRIMINATOR, CREATE_CREDENTIAL_TYPE_DISCRIMINATOR, CREATE_DID_DOCUMENT_DISCRIMINATOR, CREATE_ESCROW_DISCRIMINATOR, CREATE_MULTISIG_DISCRIMINATOR, DEACTIVATE_AGENT_DISCRIMINATOR, DEACTIVATE_CREDENTIAL_TEMPLATE_DISCRIMINATOR, DEACTIVATE_CREDENTIAL_TYPE_DISCRIMINATOR, DEACTIVATE_DID_DOCUMENT_DISCRIMINATOR, ENABLE_PROTOCOL_FEES_DISCRIMINATOR, FILE_DISPUTE_DISCRIMINATOR, GENERATE_COMPLIANCE_REPORT_DISCRIMINATOR, INITIALIZE_AUDIT_TRAIL_DISCRIMINATOR, INITIALIZE_GOVERNANCE_PROPOSAL_DISCRIMINATOR, INITIALIZE_PROTOCOL_CONFIG_DISCRIMINATOR, INITIALIZE_RBAC_CONFIG_DISCRIMINATOR, INITIALIZE_REPUTATION_METRICS_DISCRIMINATOR, INITIALIZE_STAKING_CONFIG_DISCRIMINATOR, INIT_REENTRANCY_GUARD_DISCRIMINATOR, ISSUE_CREDENTIAL_DISCRIMINATOR, LINK_EXTERNAL_ID_DISCRIMINATOR, MANAGE_AGENT_STATUS_DISCRIMINATOR, RECORD_PAYAI_PAYMENT_DISCRIMINATOR, REGISTER_AGENT_DISCRIMINATOR, REGISTER_AGENT_COMPRESSED_DISCRIMINATOR, REGISTER_GHOST_METADATA_DISCRIMINATOR, RESET_REENTRANCY_GUARD_DISCRIMINATOR, RESOLVE_DID_DOCUMENT_DISCRIMINATOR, REVOKE_CREDENTIAL_DISCRIMINATOR, SLASH_STAKE_DISCRIMINATOR, STAKE_GHOST_DISCRIMINATOR, SUBMIT_DELIVERY_DISCRIMINATOR, SUBMIT_SERVICE_RATING_DISCRIMINATOR, UNSTAKE_GHOST_DISCRIMINATOR, UPDATE_AGENT_DISCRIMINATOR, UPDATE_AGENT_REPUTATION_DISCRIMINATOR, UPDATE_AGENT_SERVICE_DISCRIMINATOR, UPDATE_CROSSCHAIN_STATUS_DISCRIMINATOR, UPDATE_DID_DOCUMENT_DISCRIMINATOR, UPDATE_GHOST_SCORE_DISCRIMINATOR, UPDATE_PROTOCOL_CONFIG_DISCRIMINATOR, UPDATE_REPUTATION_TAGS_DISCRIMINATOR, UPDATE_SOURCE_REPUTATION_DISCRIMINATOR, VERIFY_AGENT_DISCRIMINATOR, VERIFY_AUTHORIZATION_DISCRIMINATOR;
var init_chunk_IQM5RASO = __esm(() => {
  init_chunk_5QZVFUXB();
  init_chunk_AWMGX3OX();
  init_index_node40();
  AGENT_REPUTATION_AUTH_DISCRIMINATOR = new Uint8Array([
    30,
    249,
    165,
    44,
    155,
    194,
    188,
    175
  ]);
  AGENT_TREE_CONFIG_DISCRIMINATOR = new Uint8Array([
    145,
    145,
    156,
    0,
    197,
    232,
    130,
    245
  ]);
  AGENT_VERIFICATION_DISCRIMINATOR = new Uint8Array([
    128,
    155,
    95,
    241,
    66,
    207,
    166,
    59
  ]);
  AUDIT_TRAIL_DISCRIMINATOR = new Uint8Array([
    171,
    223,
    253,
    181,
    134,
    88,
    66,
    26
  ]);
  AUTHORIZATION_USAGE_RECORD_DISCRIMINATOR = new Uint8Array([
    109,
    102,
    102,
    17,
    210,
    84,
    85,
    210
  ]);
  COMPLIANCE_REPORT_DISCRIMINATOR = new Uint8Array([
    75,
    146,
    78,
    26,
    130,
    240,
    228,
    35
  ]);
  CREDENTIAL_DISCRIMINATOR = new Uint8Array([
    145,
    44,
    68,
    220,
    67,
    46,
    100,
    135
  ]);
  CREDENTIAL_TEMPLATE_DISCRIMINATOR = new Uint8Array([
    229,
    129,
    99,
    91,
    179,
    207,
    66,
    75
  ]);
  CREDENTIAL_TYPE_DISCRIMINATOR = new Uint8Array([
    132,
    171,
    20,
    181,
    39,
    219,
    217,
    112
  ]);
  DID_DOCUMENT_DISCRIMINATOR = new Uint8Array([
    109,
    220,
    168,
    224,
    33,
    173,
    192,
    166
  ]);
  EXTERNAL_ID_MAPPING_DISCRIMINATOR = new Uint8Array([
    180,
    218,
    64,
    128,
    181,
    84,
    116,
    180
  ]);
  GHOST_PROTECT_ESCROW_DISCRIMINATOR = new Uint8Array([
    38,
    0,
    98,
    160,
    102,
    4,
    51,
    160
  ]);
  GOVERNANCE_PROPOSAL_DISCRIMINATOR = new Uint8Array([
    53,
    107,
    240,
    190,
    43,
    73,
    65,
    143
  ]);
  MULTISIG_DISCRIMINATOR = new Uint8Array([
    224,
    116,
    121,
    186,
    68,
    161,
    79,
    236
  ]);
  PROTOCOL_CONFIG_DISCRIMINATOR = new Uint8Array([
    207,
    91,
    250,
    28,
    152,
    179,
    215,
    209
  ]);
  RBAC_CONFIG_DISCRIMINATOR = new Uint8Array([
    177,
    94,
    184,
    202,
    221,
    112,
    110,
    38
  ]);
  REENTRANCY_GUARD_DISCRIMINATOR = new Uint8Array([
    207,
    227,
    141,
    11,
    194,
    21,
    193,
    32
  ]);
  REPUTATION_METRICS_DISCRIMINATOR = new Uint8Array([
    8,
    160,
    71,
    30,
    66,
    150,
    108,
    33
  ]);
  STAKING_ACCOUNT_DISCRIMINATOR = new Uint8Array([
    52,
    178,
    251,
    157,
    180,
    186,
    98,
    234
  ]);
  STAKING_CONFIG_DISCRIMINATOR = new Uint8Array([
    45,
    134,
    252,
    82,
    37,
    57,
    84,
    25
  ]);
  USER_REGISTRY_DISCRIMINATOR = new Uint8Array([
    37,
    84,
    98,
    14,
    130,
    63,
    210,
    138
  ]);
  if (true) {
    ghostspeakMarketplaceErrorMessages = {
      [GHOSTSPEAK_MARKETPLACE_ERROR__DEFAULT_KEY_AS_ADMIN]: `Default (null) public key cannot be used as admin`,
      [GHOSTSPEAK_MARKETPLACE_ERROR__SYSTEM_PROGRAM_AS_ADMIN]: `System program cannot be used as admin`,
      [GHOSTSPEAK_MARKETPLACE_ERROR__TEST_ADDRESS_ON_MAINNET]: `Test address cannot be used on mainnet`,
      [GHOSTSPEAK_MARKETPLACE_ERROR__UNAUTHORIZED_ADMIN]: `Unauthorized admin - key does not match protocol admin`,
      [GHOSTSPEAK_MARKETPLACE_ERROR__VALIDATION_FAILED]: `Admin validation failed - key failed security checks or is not properly configured`
    };
  }
  ACTIVATE_AGENT_DISCRIMINATOR = new Uint8Array([
    252,
    139,
    87,
    21,
    195,
    152,
    29,
    217
  ]);
  APPROVE_DELIVERY_DISCRIMINATOR = new Uint8Array([
    28,
    233,
    51,
    115,
    33,
    220,
    41,
    28
  ]);
  ARBITRATE_DISPUTE_DISCRIMINATOR = new Uint8Array([
    225,
    89,
    166,
    101,
    215,
    40,
    191,
    4
  ]);
  AUTO_CREATE_GHOST_DISCRIMINATOR = new Uint8Array([
    50,
    170,
    232,
    73,
    238,
    200,
    180,
    16
  ]);
  CLAIM_GHOST_DISCRIMINATOR = new Uint8Array([
    149,
    107,
    35,
    233,
    252,
    101,
    148,
    225
  ]);
  CREATE_CREDENTIAL_TEMPLATE_DISCRIMINATOR = new Uint8Array([
    183,
    109,
    12,
    128,
    134,
    8,
    139,
    144
  ]);
  CREATE_CREDENTIAL_TYPE_DISCRIMINATOR = new Uint8Array([
    211,
    208,
    67,
    175,
    20,
    248,
    8,
    227
  ]);
  CREATE_DID_DOCUMENT_DISCRIMINATOR = new Uint8Array([
    253,
    40,
    200,
    239,
    69,
    147,
    82,
    182
  ]);
  CREATE_ESCROW_DISCRIMINATOR = new Uint8Array([
    253,
    215,
    165,
    116,
    36,
    108,
    68,
    80
  ]);
  CREATE_MULTISIG_DISCRIMINATOR = new Uint8Array([
    148,
    146,
    240,
    10,
    226,
    215,
    167,
    174
  ]);
  DEACTIVATE_AGENT_DISCRIMINATOR = new Uint8Array([
    205,
    171,
    239,
    225,
    82,
    126,
    96,
    166
  ]);
  DEACTIVATE_CREDENTIAL_TEMPLATE_DISCRIMINATOR = new Uint8Array([
    177,
    8,
    195,
    104,
    56,
    34,
    84,
    162
  ]);
  DEACTIVATE_CREDENTIAL_TYPE_DISCRIMINATOR = new Uint8Array([
    110,
    174,
    221,
    244,
    36,
    206,
    60,
    237
  ]);
  DEACTIVATE_DID_DOCUMENT_DISCRIMINATOR = new Uint8Array([
    77,
    13,
    56,
    161,
    67,
    155,
    206,
    119
  ]);
  ENABLE_PROTOCOL_FEES_DISCRIMINATOR = new Uint8Array([
    9,
    115,
    79,
    19,
    158,
    209,
    221,
    38
  ]);
  FILE_DISPUTE_DISCRIMINATOR = new Uint8Array([
    210,
    63,
    221,
    114,
    212,
    97,
    195,
    156
  ]);
  GENERATE_COMPLIANCE_REPORT_DISCRIMINATOR = new Uint8Array([
    213,
    97,
    79,
    234,
    22,
    228,
    14,
    32
  ]);
  INITIALIZE_AUDIT_TRAIL_DISCRIMINATOR = new Uint8Array([
    145,
    182,
    236,
    249,
    212,
    17,
    175,
    161
  ]);
  INITIALIZE_GOVERNANCE_PROPOSAL_DISCRIMINATOR = new Uint8Array([
    137,
    84,
    234,
    206,
    17,
    58,
    54,
    215
  ]);
  INITIALIZE_PROTOCOL_CONFIG_DISCRIMINATOR = new Uint8Array([
    28,
    50,
    43,
    233,
    244,
    98,
    123,
    118
  ]);
  INITIALIZE_RBAC_CONFIG_DISCRIMINATOR = new Uint8Array([
    215,
    68,
    129,
    228,
    237,
    165,
    0,
    240
  ]);
  INITIALIZE_REPUTATION_METRICS_DISCRIMINATOR = new Uint8Array([
    228,
    11,
    207,
    44,
    52,
    188,
    169,
    237
  ]);
  INITIALIZE_STAKING_CONFIG_DISCRIMINATOR = new Uint8Array([
    78,
    164,
    6,
    115,
    206,
    48,
    168,
    105
  ]);
  INIT_REENTRANCY_GUARD_DISCRIMINATOR = new Uint8Array([
    156,
    109,
    115,
    85,
    12,
    60,
    245,
    99
  ]);
  ISSUE_CREDENTIAL_DISCRIMINATOR = new Uint8Array([
    255,
    193,
    171,
    224,
    68,
    171,
    194,
    87
  ]);
  LINK_EXTERNAL_ID_DISCRIMINATOR = new Uint8Array([
    156,
    102,
    141,
    155,
    175,
    13,
    29,
    86
  ]);
  MANAGE_AGENT_STATUS_DISCRIMINATOR = new Uint8Array([
    164,
    219,
    91,
    38,
    45,
    31,
    33,
    47
  ]);
  RECORD_PAYAI_PAYMENT_DISCRIMINATOR = new Uint8Array([
    165,
    202,
    159,
    139,
    65,
    65,
    36,
    163
  ]);
  REGISTER_AGENT_DISCRIMINATOR = new Uint8Array([
    135,
    157,
    66,
    195,
    2,
    113,
    175,
    30
  ]);
  REGISTER_AGENT_COMPRESSED_DISCRIMINATOR = new Uint8Array([
    15,
    6,
    94,
    55,
    65,
    80,
    123,
    248
  ]);
  REGISTER_GHOST_METADATA_DISCRIMINATOR = new Uint8Array([
    34,
    233,
    111,
    236,
    212,
    22,
    26,
    254
  ]);
  RESET_REENTRANCY_GUARD_DISCRIMINATOR = new Uint8Array([
    93,
    74,
    168,
    125,
    46,
    153,
    9,
    255
  ]);
  RESOLVE_DID_DOCUMENT_DISCRIMINATOR = new Uint8Array([
    168,
    180,
    218,
    211,
    184,
    19,
    102,
    12
  ]);
  REVOKE_CREDENTIAL_DISCRIMINATOR = new Uint8Array([
    38,
    123,
    95,
    95,
    223,
    158,
    169,
    87
  ]);
  SLASH_STAKE_DISCRIMINATOR = new Uint8Array([
    190,
    242,
    137,
    27,
    41,
    18,
    233,
    37
  ]);
  STAKE_GHOST_DISCRIMINATOR = new Uint8Array([
    5,
    196,
    24,
    54,
    196,
    56,
    173,
    191
  ]);
  SUBMIT_DELIVERY_DISCRIMINATOR = new Uint8Array([
    217,
    177,
    33,
    54,
    136,
    185,
    123,
    96
  ]);
  SUBMIT_SERVICE_RATING_DISCRIMINATOR = new Uint8Array([
    23,
    160,
    228,
    88,
    168,
    145,
    129,
    19
  ]);
  UNSTAKE_GHOST_DISCRIMINATOR = new Uint8Array([
    252,
    101,
    172,
    252,
    1,
    4,
    12,
    116
  ]);
  UPDATE_AGENT_DISCRIMINATOR = new Uint8Array([
    85,
    2,
    178,
    9,
    119,
    139,
    102,
    164
  ]);
  UPDATE_AGENT_REPUTATION_DISCRIMINATOR = new Uint8Array([
    80,
    227,
    92,
    245,
    231,
    37,
    99,
    180
  ]);
  UPDATE_AGENT_SERVICE_DISCRIMINATOR = new Uint8Array([
    87,
    146,
    181,
    198,
    252,
    68,
    243,
    102
  ]);
  UPDATE_CROSSCHAIN_STATUS_DISCRIMINATOR = new Uint8Array([
    22,
    167,
    59,
    238,
    22,
    231,
    239,
    146
  ]);
  UPDATE_DID_DOCUMENT_DISCRIMINATOR = new Uint8Array([
    64,
    216,
    17,
    91,
    205,
    94,
    45,
    57
  ]);
  UPDATE_GHOST_SCORE_DISCRIMINATOR = new Uint8Array([
    213,
    152,
    5,
    80,
    163,
    224,
    151,
    120
  ]);
  UPDATE_PROTOCOL_CONFIG_DISCRIMINATOR = new Uint8Array([
    197,
    97,
    123,
    54,
    221,
    168,
    11,
    135
  ]);
  UPDATE_REPUTATION_TAGS_DISCRIMINATOR = new Uint8Array([
    206,
    96,
    254,
    186,
    129,
    180,
    103,
    198
  ]);
  UPDATE_SOURCE_REPUTATION_DISCRIMINATOR = new Uint8Array([
    161,
    240,
    255,
    69,
    130,
    227,
    71,
    123
  ]);
  VERIFY_AGENT_DISCRIMINATOR = new Uint8Array([
    206,
    212,
    108,
    12,
    105,
    61,
    100,
    66
  ]);
  VERIFY_AUTHORIZATION_DISCRIMINATOR = new Uint8Array([
    43,
    9,
    131,
    59,
    74,
    118,
    113,
    170
  ]);
});

// ../../node_modules/.bun/lru-cache@11.2.4/node_modules/lru-cache/dist/esm/index.js
class Stack {
  heap;
  length;
  static #constructing = false;
  static create(max) {
    const HeapCls = getUintArray(max);
    if (!HeapCls)
      return [];
    Stack.#constructing = true;
    const s3 = new Stack(max, HeapCls);
    Stack.#constructing = false;
    return s3;
  }
  constructor(max, HeapCls) {
    if (!Stack.#constructing) {
      throw new TypeError("instantiate Stack using Stack.create(n)");
    }
    this.heap = new HeapCls(max);
    this.length = 0;
  }
  push(n) {
    this.heap[this.length++] = n;
  }
  pop() {
    return this.heap[--this.length];
  }
}
var defaultPerf, warned, PROCESS, emitWarning = (msg, type, code, fn) => {
  typeof PROCESS.emitWarning === "function" ? PROCESS.emitWarning(msg, type, code, fn) : console.error(`[${code}] ${type}: ${msg}`);
}, AC, AS, shouldWarn = (code) => !warned.has(code), TYPE4, isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n), getUintArray = (max) => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null, ZeroArray, LRUCache;
var init_esm = __esm(() => {
  defaultPerf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
  warned = new Set;
  PROCESS = typeof process === "object" && !!process ? process : {};
  AC = globalThis.AbortController;
  AS = globalThis.AbortSignal;
  if (typeof AC === "undefined") {
    AS = class AbortSignal2 {
      onabort;
      _onabort = [];
      reason;
      aborted = false;
      addEventListener(_, fn) {
        this._onabort.push(fn);
      }
    };
    AC = class AbortController {
      constructor() {
        warnACPolyfill();
      }
      signal = new AS;
      abort(reason) {
        if (this.signal.aborted)
          return;
        this.signal.reason = reason;
        this.signal.aborted = true;
        for (const fn of this.signal._onabort) {
          fn(reason);
        }
        this.signal.onabort?.(reason);
      }
    };
    let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== "1";
    const warnACPolyfill = () => {
      if (!printACPolyfillWarning)
        return;
      printACPolyfillWarning = false;
      emitWarning("AbortController is not defined. If using lru-cache in " + "node 14, load an AbortController polyfill from the " + "`node-abort-controller` package. A minimal polyfill is " + "provided for use by LRUCache.fetch(), but it should not be " + "relied upon in other contexts (eg, passing it to other APIs that " + "use AbortController/AbortSignal might have undesirable effects). " + "You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", warnACPolyfill);
    };
  }
  TYPE4 = Symbol("type");
  ZeroArray = class ZeroArray extends Array {
    constructor(size) {
      super(size);
      this.fill(0);
    }
  };
  LRUCache = class LRUCache {
    #max;
    #maxSize;
    #dispose;
    #onInsert;
    #disposeAfter;
    #fetchMethod;
    #memoMethod;
    #perf;
    get perf() {
      return this.#perf;
    }
    ttl;
    ttlResolution;
    ttlAutopurge;
    updateAgeOnGet;
    updateAgeOnHas;
    allowStale;
    noDisposeOnSet;
    noUpdateTTL;
    maxEntrySize;
    sizeCalculation;
    noDeleteOnFetchRejection;
    noDeleteOnStaleGet;
    allowStaleOnFetchAbort;
    allowStaleOnFetchRejection;
    ignoreFetchAbort;
    #size;
    #calculatedSize;
    #keyMap;
    #keyList;
    #valList;
    #next;
    #prev;
    #head;
    #tail;
    #free;
    #disposed;
    #sizes;
    #starts;
    #ttls;
    #autopurgeTimers;
    #hasDispose;
    #hasFetchMethod;
    #hasDisposeAfter;
    #hasOnInsert;
    static unsafeExposeInternals(c) {
      return {
        starts: c.#starts,
        ttls: c.#ttls,
        autopurgeTimers: c.#autopurgeTimers,
        sizes: c.#sizes,
        keyMap: c.#keyMap,
        keyList: c.#keyList,
        valList: c.#valList,
        next: c.#next,
        prev: c.#prev,
        get head() {
          return c.#head;
        },
        get tail() {
          return c.#tail;
        },
        free: c.#free,
        isBackgroundFetch: (p) => c.#isBackgroundFetch(p),
        backgroundFetch: (k, index, options2, context) => c.#backgroundFetch(k, index, options2, context),
        moveToTail: (index) => c.#moveToTail(index),
        indexes: (options2) => c.#indexes(options2),
        rindexes: (options2) => c.#rindexes(options2),
        isStale: (index) => c.#isStale(index)
      };
    }
    get max() {
      return this.#max;
    }
    get maxSize() {
      return this.#maxSize;
    }
    get calculatedSize() {
      return this.#calculatedSize;
    }
    get size() {
      return this.#size;
    }
    get fetchMethod() {
      return this.#fetchMethod;
    }
    get memoMethod() {
      return this.#memoMethod;
    }
    get dispose() {
      return this.#dispose;
    }
    get onInsert() {
      return this.#onInsert;
    }
    get disposeAfter() {
      return this.#disposeAfter;
    }
    constructor(options2) {
      const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, onInsert, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, memoMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort, perf } = options2;
      if (perf !== undefined) {
        if (typeof perf?.now !== "function") {
          throw new TypeError("perf option must have a now() method if specified");
        }
      }
      this.#perf = perf ?? defaultPerf;
      if (max !== 0 && !isPosInt(max)) {
        throw new TypeError("max option must be a nonnegative integer");
      }
      const UintArray = max ? getUintArray(max) : Array;
      if (!UintArray) {
        throw new Error("invalid max value: " + max);
      }
      this.#max = max;
      this.#maxSize = maxSize;
      this.maxEntrySize = maxEntrySize || this.#maxSize;
      this.sizeCalculation = sizeCalculation;
      if (this.sizeCalculation) {
        if (!this.#maxSize && !this.maxEntrySize) {
          throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
        }
        if (typeof this.sizeCalculation !== "function") {
          throw new TypeError("sizeCalculation set to non-function");
        }
      }
      if (memoMethod !== undefined && typeof memoMethod !== "function") {
        throw new TypeError("memoMethod must be a function if defined");
      }
      this.#memoMethod = memoMethod;
      if (fetchMethod !== undefined && typeof fetchMethod !== "function") {
        throw new TypeError("fetchMethod must be a function if specified");
      }
      this.#fetchMethod = fetchMethod;
      this.#hasFetchMethod = !!fetchMethod;
      this.#keyMap = new Map;
      this.#keyList = new Array(max).fill(undefined);
      this.#valList = new Array(max).fill(undefined);
      this.#next = new UintArray(max);
      this.#prev = new UintArray(max);
      this.#head = 0;
      this.#tail = 0;
      this.#free = Stack.create(max);
      this.#size = 0;
      this.#calculatedSize = 0;
      if (typeof dispose === "function") {
        this.#dispose = dispose;
      }
      if (typeof onInsert === "function") {
        this.#onInsert = onInsert;
      }
      if (typeof disposeAfter === "function") {
        this.#disposeAfter = disposeAfter;
        this.#disposed = [];
      } else {
        this.#disposeAfter = undefined;
        this.#disposed = undefined;
      }
      this.#hasDispose = !!this.#dispose;
      this.#hasOnInsert = !!this.#onInsert;
      this.#hasDisposeAfter = !!this.#disposeAfter;
      this.noDisposeOnSet = !!noDisposeOnSet;
      this.noUpdateTTL = !!noUpdateTTL;
      this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
      this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
      this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
      this.ignoreFetchAbort = !!ignoreFetchAbort;
      if (this.maxEntrySize !== 0) {
        if (this.#maxSize !== 0) {
          if (!isPosInt(this.#maxSize)) {
            throw new TypeError("maxSize must be a positive integer if specified");
          }
        }
        if (!isPosInt(this.maxEntrySize)) {
          throw new TypeError("maxEntrySize must be a positive integer if specified");
        }
        this.#initializeSizeTracking();
      }
      this.allowStale = !!allowStale;
      this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
      this.updateAgeOnGet = !!updateAgeOnGet;
      this.updateAgeOnHas = !!updateAgeOnHas;
      this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
      this.ttlAutopurge = !!ttlAutopurge;
      this.ttl = ttl || 0;
      if (this.ttl) {
        if (!isPosInt(this.ttl)) {
          throw new TypeError("ttl must be a positive integer if specified");
        }
        this.#initializeTTLTracking();
      }
      if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {
        throw new TypeError("At least one of max, maxSize, or ttl is required");
      }
      if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {
        const code = "LRU_CACHE_UNBOUNDED";
        if (shouldWarn(code)) {
          warned.add(code);
          const msg = "TTL caching without ttlAutopurge, max, or maxSize can " + "result in unbounded memory consumption.";
          emitWarning(msg, "UnboundedCacheWarning", code, LRUCache);
        }
      }
    }
    getRemainingTTL(key) {
      return this.#keyMap.has(key) ? Infinity : 0;
    }
    #initializeTTLTracking() {
      const ttls = new ZeroArray(this.#max);
      const starts = new ZeroArray(this.#max);
      this.#ttls = ttls;
      this.#starts = starts;
      const purgeTimers = this.ttlAutopurge ? new Array(this.#max) : undefined;
      this.#autopurgeTimers = purgeTimers;
      this.#setItemTTL = (index, ttl, start = this.#perf.now()) => {
        starts[index] = ttl !== 0 ? start : 0;
        ttls[index] = ttl;
        if (purgeTimers?.[index]) {
          clearTimeout(purgeTimers[index]);
          purgeTimers[index] = undefined;
        }
        if (ttl !== 0 && purgeTimers) {
          const t = setTimeout(() => {
            if (this.#isStale(index)) {
              this.#delete(this.#keyList[index], "expire");
            }
          }, ttl + 1);
          if (t.unref) {
            t.unref();
          }
          purgeTimers[index] = t;
        }
      };
      this.#updateItemAge = (index) => {
        starts[index] = ttls[index] !== 0 ? this.#perf.now() : 0;
      };
      this.#statusTTL = (status, index) => {
        if (ttls[index]) {
          const ttl = ttls[index];
          const start = starts[index];
          if (!ttl || !start)
            return;
          status.ttl = ttl;
          status.start = start;
          status.now = cachedNow || getNow();
          const age = status.now - start;
          status.remainingTTL = ttl - age;
        }
      };
      let cachedNow = 0;
      const getNow = () => {
        const n = this.#perf.now();
        if (this.ttlResolution > 0) {
          cachedNow = n;
          const t = setTimeout(() => cachedNow = 0, this.ttlResolution);
          if (t.unref) {
            t.unref();
          }
        }
        return n;
      };
      this.getRemainingTTL = (key) => {
        const index = this.#keyMap.get(key);
        if (index === undefined) {
          return 0;
        }
        const ttl = ttls[index];
        const start = starts[index];
        if (!ttl || !start) {
          return Infinity;
        }
        const age = (cachedNow || getNow()) - start;
        return ttl - age;
      };
      this.#isStale = (index) => {
        const s3 = starts[index];
        const t = ttls[index];
        return !!t && !!s3 && (cachedNow || getNow()) - s3 > t;
      };
    }
    #updateItemAge = () => {};
    #statusTTL = () => {};
    #setItemTTL = () => {};
    #isStale = () => false;
    #initializeSizeTracking() {
      const sizes = new ZeroArray(this.#max);
      this.#calculatedSize = 0;
      this.#sizes = sizes;
      this.#removeItemSize = (index) => {
        this.#calculatedSize -= sizes[index];
        sizes[index] = 0;
      };
      this.#requireSize = (k, v, size, sizeCalculation) => {
        if (this.#isBackgroundFetch(v)) {
          return 0;
        }
        if (!isPosInt(size)) {
          if (sizeCalculation) {
            if (typeof sizeCalculation !== "function") {
              throw new TypeError("sizeCalculation must be a function");
            }
            size = sizeCalculation(v, k);
            if (!isPosInt(size)) {
              throw new TypeError("sizeCalculation return invalid (expect positive integer)");
            }
          } else {
            throw new TypeError("invalid size value (must be positive integer). " + "When maxSize or maxEntrySize is used, sizeCalculation " + "or size must be set.");
          }
        }
        return size;
      };
      this.#addItemSize = (index, size, status) => {
        sizes[index] = size;
        if (this.#maxSize) {
          const maxSize = this.#maxSize - sizes[index];
          while (this.#calculatedSize > maxSize) {
            this.#evict(true);
          }
        }
        this.#calculatedSize += sizes[index];
        if (status) {
          status.entrySize = size;
          status.totalCalculatedSize = this.#calculatedSize;
        }
      };
    }
    #removeItemSize = (_i) => {};
    #addItemSize = (_i, _s, _st) => {};
    #requireSize = (_k, _v, size, sizeCalculation) => {
      if (size || sizeCalculation) {
        throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
      }
      return 0;
    };
    *#indexes({ allowStale = this.allowStale } = {}) {
      if (this.#size) {
        for (let i = this.#tail;; ) {
          if (!this.#isValidIndex(i)) {
            break;
          }
          if (allowStale || !this.#isStale(i)) {
            yield i;
          }
          if (i === this.#head) {
            break;
          } else {
            i = this.#prev[i];
          }
        }
      }
    }
    *#rindexes({ allowStale = this.allowStale } = {}) {
      if (this.#size) {
        for (let i = this.#head;; ) {
          if (!this.#isValidIndex(i)) {
            break;
          }
          if (allowStale || !this.#isStale(i)) {
            yield i;
          }
          if (i === this.#tail) {
            break;
          } else {
            i = this.#next[i];
          }
        }
      }
    }
    #isValidIndex(index) {
      return index !== undefined && this.#keyMap.get(this.#keyList[index]) === index;
    }
    *entries() {
      for (const i of this.#indexes()) {
        if (this.#valList[i] !== undefined && this.#keyList[i] !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
          yield [this.#keyList[i], this.#valList[i]];
        }
      }
    }
    *rentries() {
      for (const i of this.#rindexes()) {
        if (this.#valList[i] !== undefined && this.#keyList[i] !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
          yield [this.#keyList[i], this.#valList[i]];
        }
      }
    }
    *keys() {
      for (const i of this.#indexes()) {
        const k = this.#keyList[i];
        if (k !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
          yield k;
        }
      }
    }
    *rkeys() {
      for (const i of this.#rindexes()) {
        const k = this.#keyList[i];
        if (k !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
          yield k;
        }
      }
    }
    *values() {
      for (const i of this.#indexes()) {
        const v = this.#valList[i];
        if (v !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
          yield this.#valList[i];
        }
      }
    }
    *rvalues() {
      for (const i of this.#rindexes()) {
        const v = this.#valList[i];
        if (v !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
          yield this.#valList[i];
        }
      }
    }
    [Symbol.iterator]() {
      return this.entries();
    }
    [Symbol.toStringTag] = "LRUCache";
    find(fn, getOptions = {}) {
      for (const i of this.#indexes()) {
        const v = this.#valList[i];
        const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
        if (value === undefined)
          continue;
        if (fn(value, this.#keyList[i], this)) {
          return this.get(this.#keyList[i], getOptions);
        }
      }
    }
    forEach(fn, thisp = this) {
      for (const i of this.#indexes()) {
        const v = this.#valList[i];
        const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
        if (value === undefined)
          continue;
        fn.call(thisp, value, this.#keyList[i], this);
      }
    }
    rforEach(fn, thisp = this) {
      for (const i of this.#rindexes()) {
        const v = this.#valList[i];
        const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
        if (value === undefined)
          continue;
        fn.call(thisp, value, this.#keyList[i], this);
      }
    }
    purgeStale() {
      let deleted = false;
      for (const i of this.#rindexes({ allowStale: true })) {
        if (this.#isStale(i)) {
          this.#delete(this.#keyList[i], "expire");
          deleted = true;
        }
      }
      return deleted;
    }
    info(key) {
      const i = this.#keyMap.get(key);
      if (i === undefined)
        return;
      const v = this.#valList[i];
      const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      if (value === undefined)
        return;
      const entry = { value };
      if (this.#ttls && this.#starts) {
        const ttl = this.#ttls[i];
        const start = this.#starts[i];
        if (ttl && start) {
          const remain = ttl - (this.#perf.now() - start);
          entry.ttl = remain;
          entry.start = Date.now();
        }
      }
      if (this.#sizes) {
        entry.size = this.#sizes[i];
      }
      return entry;
    }
    dump() {
      const arr = [];
      for (const i of this.#indexes({ allowStale: true })) {
        const key = this.#keyList[i];
        const v = this.#valList[i];
        const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
        if (value === undefined || key === undefined)
          continue;
        const entry = { value };
        if (this.#ttls && this.#starts) {
          entry.ttl = this.#ttls[i];
          const age = this.#perf.now() - this.#starts[i];
          entry.start = Math.floor(Date.now() - age);
        }
        if (this.#sizes) {
          entry.size = this.#sizes[i];
        }
        arr.unshift([key, entry]);
      }
      return arr;
    }
    load(arr) {
      this.clear();
      for (const [key, entry] of arr) {
        if (entry.start) {
          const age = Date.now() - entry.start;
          entry.start = this.#perf.now() - age;
        }
        this.set(key, entry.value, entry);
      }
    }
    set(k, v, setOptions = {}) {
      if (v === undefined) {
        this.delete(k);
        return this;
      }
      const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status } = setOptions;
      let { noUpdateTTL = this.noUpdateTTL } = setOptions;
      const size = this.#requireSize(k, v, setOptions.size || 0, sizeCalculation);
      if (this.maxEntrySize && size > this.maxEntrySize) {
        if (status) {
          status.set = "miss";
          status.maxEntrySizeExceeded = true;
        }
        this.#delete(k, "set");
        return this;
      }
      let index = this.#size === 0 ? undefined : this.#keyMap.get(k);
      if (index === undefined) {
        index = this.#size === 0 ? this.#tail : this.#free.length !== 0 ? this.#free.pop() : this.#size === this.#max ? this.#evict(false) : this.#size;
        this.#keyList[index] = k;
        this.#valList[index] = v;
        this.#keyMap.set(k, index);
        this.#next[this.#tail] = index;
        this.#prev[index] = this.#tail;
        this.#tail = index;
        this.#size++;
        this.#addItemSize(index, size, status);
        if (status)
          status.set = "add";
        noUpdateTTL = false;
        if (this.#hasOnInsert) {
          this.#onInsert?.(v, k, "add");
        }
      } else {
        this.#moveToTail(index);
        const oldVal = this.#valList[index];
        if (v !== oldVal) {
          if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {
            oldVal.__abortController.abort(new Error("replaced"));
            const { __staleWhileFetching: s3 } = oldVal;
            if (s3 !== undefined && !noDisposeOnSet) {
              if (this.#hasDispose) {
                this.#dispose?.(s3, k, "set");
              }
              if (this.#hasDisposeAfter) {
                this.#disposed?.push([s3, k, "set"]);
              }
            }
          } else if (!noDisposeOnSet) {
            if (this.#hasDispose) {
              this.#dispose?.(oldVal, k, "set");
            }
            if (this.#hasDisposeAfter) {
              this.#disposed?.push([oldVal, k, "set"]);
            }
          }
          this.#removeItemSize(index);
          this.#addItemSize(index, size, status);
          this.#valList[index] = v;
          if (status) {
            status.set = "replace";
            const oldValue = oldVal && this.#isBackgroundFetch(oldVal) ? oldVal.__staleWhileFetching : oldVal;
            if (oldValue !== undefined)
              status.oldValue = oldValue;
          }
        } else if (status) {
          status.set = "update";
        }
        if (this.#hasOnInsert) {
          this.onInsert?.(v, k, v === oldVal ? "update" : "replace");
        }
      }
      if (ttl !== 0 && !this.#ttls) {
        this.#initializeTTLTracking();
      }
      if (this.#ttls) {
        if (!noUpdateTTL) {
          this.#setItemTTL(index, ttl, start);
        }
        if (status)
          this.#statusTTL(status, index);
      }
      if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {
        const dt = this.#disposed;
        let task;
        while (task = dt?.shift()) {
          this.#disposeAfter?.(...task);
        }
      }
      return this;
    }
    pop() {
      try {
        while (this.#size) {
          const val = this.#valList[this.#head];
          this.#evict(true);
          if (this.#isBackgroundFetch(val)) {
            if (val.__staleWhileFetching) {
              return val.__staleWhileFetching;
            }
          } else if (val !== undefined) {
            return val;
          }
        }
      } finally {
        if (this.#hasDisposeAfter && this.#disposed) {
          const dt = this.#disposed;
          let task;
          while (task = dt?.shift()) {
            this.#disposeAfter?.(...task);
          }
        }
      }
    }
    #evict(free) {
      const head = this.#head;
      const k = this.#keyList[head];
      const v = this.#valList[head];
      if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {
        v.__abortController.abort(new Error("evicted"));
      } else if (this.#hasDispose || this.#hasDisposeAfter) {
        if (this.#hasDispose) {
          this.#dispose?.(v, k, "evict");
        }
        if (this.#hasDisposeAfter) {
          this.#disposed?.push([v, k, "evict"]);
        }
      }
      this.#removeItemSize(head);
      if (this.#autopurgeTimers?.[head]) {
        clearTimeout(this.#autopurgeTimers[head]);
        this.#autopurgeTimers[head] = undefined;
      }
      if (free) {
        this.#keyList[head] = undefined;
        this.#valList[head] = undefined;
        this.#free.push(head);
      }
      if (this.#size === 1) {
        this.#head = this.#tail = 0;
        this.#free.length = 0;
      } else {
        this.#head = this.#next[head];
      }
      this.#keyMap.delete(k);
      this.#size--;
      return head;
    }
    has(k, hasOptions = {}) {
      const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
      const index = this.#keyMap.get(k);
      if (index !== undefined) {
        const v = this.#valList[index];
        if (this.#isBackgroundFetch(v) && v.__staleWhileFetching === undefined) {
          return false;
        }
        if (!this.#isStale(index)) {
          if (updateAgeOnHas) {
            this.#updateItemAge(index);
          }
          if (status) {
            status.has = "hit";
            this.#statusTTL(status, index);
          }
          return true;
        } else if (status) {
          status.has = "stale";
          this.#statusTTL(status, index);
        }
      } else if (status) {
        status.has = "miss";
      }
      return false;
    }
    peek(k, peekOptions = {}) {
      const { allowStale = this.allowStale } = peekOptions;
      const index = this.#keyMap.get(k);
      if (index === undefined || !allowStale && this.#isStale(index)) {
        return;
      }
      const v = this.#valList[index];
      return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
    }
    #backgroundFetch(k, index, options2, context) {
      const v = index === undefined ? undefined : this.#valList[index];
      if (this.#isBackgroundFetch(v)) {
        return v;
      }
      const ac = new AC;
      const { signal } = options2;
      signal?.addEventListener("abort", () => ac.abort(signal.reason), {
        signal: ac.signal
      });
      const fetchOpts = {
        signal: ac.signal,
        options: options2,
        context
      };
      const cb = (v2, updateCache = false) => {
        const { aborted } = ac.signal;
        const ignoreAbort = options2.ignoreFetchAbort && v2 !== undefined;
        if (options2.status) {
          if (aborted && !updateCache) {
            options2.status.fetchAborted = true;
            options2.status.fetchError = ac.signal.reason;
            if (ignoreAbort)
              options2.status.fetchAbortIgnored = true;
          } else {
            options2.status.fetchResolved = true;
          }
        }
        if (aborted && !ignoreAbort && !updateCache) {
          return fetchFail(ac.signal.reason);
        }
        const bf2 = p;
        const vl = this.#valList[index];
        if (vl === p || ignoreAbort && updateCache && vl === undefined) {
          if (v2 === undefined) {
            if (bf2.__staleWhileFetching !== undefined) {
              this.#valList[index] = bf2.__staleWhileFetching;
            } else {
              this.#delete(k, "fetch");
            }
          } else {
            if (options2.status)
              options2.status.fetchUpdated = true;
            this.set(k, v2, fetchOpts.options);
          }
        }
        return v2;
      };
      const eb = (er) => {
        if (options2.status) {
          options2.status.fetchRejected = true;
          options2.status.fetchError = er;
        }
        return fetchFail(er);
      };
      const fetchFail = (er) => {
        const { aborted } = ac.signal;
        const allowStaleAborted = aborted && options2.allowStaleOnFetchAbort;
        const allowStale = allowStaleAborted || options2.allowStaleOnFetchRejection;
        const noDelete = allowStale || options2.noDeleteOnFetchRejection;
        const bf2 = p;
        if (this.#valList[index] === p) {
          const del = !noDelete || bf2.__staleWhileFetching === undefined;
          if (del) {
            this.#delete(k, "fetch");
          } else if (!allowStaleAborted) {
            this.#valList[index] = bf2.__staleWhileFetching;
          }
        }
        if (allowStale) {
          if (options2.status && bf2.__staleWhileFetching !== undefined) {
            options2.status.returnedStale = true;
          }
          return bf2.__staleWhileFetching;
        } else if (bf2.__returned === bf2) {
          throw er;
        }
      };
      const pcall = (res, rej) => {
        const fmp = this.#fetchMethod?.(k, v, fetchOpts);
        if (fmp && fmp instanceof Promise) {
          fmp.then((v2) => res(v2 === undefined ? undefined : v2), rej);
        }
        ac.signal.addEventListener("abort", () => {
          if (!options2.ignoreFetchAbort || options2.allowStaleOnFetchAbort) {
            res(undefined);
            if (options2.allowStaleOnFetchAbort) {
              res = (v2) => cb(v2, true);
            }
          }
        });
      };
      if (options2.status)
        options2.status.fetchDispatched = true;
      const p = new Promise(pcall).then(cb, eb);
      const bf = Object.assign(p, {
        __abortController: ac,
        __staleWhileFetching: v,
        __returned: undefined
      });
      if (index === undefined) {
        this.set(k, bf, { ...fetchOpts.options, status: undefined });
        index = this.#keyMap.get(k);
      } else {
        this.#valList[index] = bf;
      }
      return bf;
    }
    #isBackgroundFetch(p) {
      if (!this.#hasFetchMethod)
        return false;
      const b = p;
      return !!b && b instanceof Promise && b.hasOwnProperty("__staleWhileFetching") && b.__abortController instanceof AC;
    }
    async fetch(k, fetchOptions = {}) {
      const {
        allowStale = this.allowStale,
        updateAgeOnGet = this.updateAgeOnGet,
        noDeleteOnStaleGet = this.noDeleteOnStaleGet,
        ttl = this.ttl,
        noDisposeOnSet = this.noDisposeOnSet,
        size = 0,
        sizeCalculation = this.sizeCalculation,
        noUpdateTTL = this.noUpdateTTL,
        noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
        allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
        ignoreFetchAbort = this.ignoreFetchAbort,
        allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
        context,
        forceRefresh = false,
        status,
        signal
      } = fetchOptions;
      if (!this.#hasFetchMethod) {
        if (status)
          status.fetch = "get";
        return this.get(k, {
          allowStale,
          updateAgeOnGet,
          noDeleteOnStaleGet,
          status
        });
      }
      const options2 = {
        allowStale,
        updateAgeOnGet,
        noDeleteOnStaleGet,
        ttl,
        noDisposeOnSet,
        size,
        sizeCalculation,
        noUpdateTTL,
        noDeleteOnFetchRejection,
        allowStaleOnFetchRejection,
        allowStaleOnFetchAbort,
        ignoreFetchAbort,
        status,
        signal
      };
      let index = this.#keyMap.get(k);
      if (index === undefined) {
        if (status)
          status.fetch = "miss";
        const p = this.#backgroundFetch(k, index, options2, context);
        return p.__returned = p;
      } else {
        const v = this.#valList[index];
        if (this.#isBackgroundFetch(v)) {
          const stale = allowStale && v.__staleWhileFetching !== undefined;
          if (status) {
            status.fetch = "inflight";
            if (stale)
              status.returnedStale = true;
          }
          return stale ? v.__staleWhileFetching : v.__returned = v;
        }
        const isStale = this.#isStale(index);
        if (!forceRefresh && !isStale) {
          if (status)
            status.fetch = "hit";
          this.#moveToTail(index);
          if (updateAgeOnGet) {
            this.#updateItemAge(index);
          }
          if (status)
            this.#statusTTL(status, index);
          return v;
        }
        const p = this.#backgroundFetch(k, index, options2, context);
        const hasStale = p.__staleWhileFetching !== undefined;
        const staleVal = hasStale && allowStale;
        if (status) {
          status.fetch = isStale ? "stale" : "refresh";
          if (staleVal && isStale)
            status.returnedStale = true;
        }
        return staleVal ? p.__staleWhileFetching : p.__returned = p;
      }
    }
    async forceFetch(k, fetchOptions = {}) {
      const v = await this.fetch(k, fetchOptions);
      if (v === undefined)
        throw new Error("fetch() returned undefined");
      return v;
    }
    memo(k, memoOptions = {}) {
      const memoMethod = this.#memoMethod;
      if (!memoMethod) {
        throw new Error("no memoMethod provided to constructor");
      }
      const { context, forceRefresh, ...options2 } = memoOptions;
      const v = this.get(k, options2);
      if (!forceRefresh && v !== undefined)
        return v;
      const vv = memoMethod(k, v, {
        options: options2,
        context
      });
      this.set(k, vv, options2);
      return vv;
    }
    get(k, getOptions = {}) {
      const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status } = getOptions;
      const index = this.#keyMap.get(k);
      if (index !== undefined) {
        const value = this.#valList[index];
        const fetching = this.#isBackgroundFetch(value);
        if (status)
          this.#statusTTL(status, index);
        if (this.#isStale(index)) {
          if (status)
            status.get = "stale";
          if (!fetching) {
            if (!noDeleteOnStaleGet) {
              this.#delete(k, "expire");
            }
            if (status && allowStale)
              status.returnedStale = true;
            return allowStale ? value : undefined;
          } else {
            if (status && allowStale && value.__staleWhileFetching !== undefined) {
              status.returnedStale = true;
            }
            return allowStale ? value.__staleWhileFetching : undefined;
          }
        } else {
          if (status)
            status.get = "hit";
          if (fetching) {
            return value.__staleWhileFetching;
          }
          this.#moveToTail(index);
          if (updateAgeOnGet) {
            this.#updateItemAge(index);
          }
          return value;
        }
      } else if (status) {
        status.get = "miss";
      }
    }
    #connect(p, n) {
      this.#prev[n] = p;
      this.#next[p] = n;
    }
    #moveToTail(index) {
      if (index !== this.#tail) {
        if (index === this.#head) {
          this.#head = this.#next[index];
        } else {
          this.#connect(this.#prev[index], this.#next[index]);
        }
        this.#connect(this.#tail, index);
        this.#tail = index;
      }
    }
    delete(k) {
      return this.#delete(k, "delete");
    }
    #delete(k, reason) {
      let deleted = false;
      if (this.#size !== 0) {
        const index = this.#keyMap.get(k);
        if (index !== undefined) {
          if (this.#autopurgeTimers?.[index]) {
            clearTimeout(this.#autopurgeTimers?.[index]);
            this.#autopurgeTimers[index] = undefined;
          }
          deleted = true;
          if (this.#size === 1) {
            this.#clear(reason);
          } else {
            this.#removeItemSize(index);
            const v = this.#valList[index];
            if (this.#isBackgroundFetch(v)) {
              v.__abortController.abort(new Error("deleted"));
            } else if (this.#hasDispose || this.#hasDisposeAfter) {
              if (this.#hasDispose) {
                this.#dispose?.(v, k, reason);
              }
              if (this.#hasDisposeAfter) {
                this.#disposed?.push([v, k, reason]);
              }
            }
            this.#keyMap.delete(k);
            this.#keyList[index] = undefined;
            this.#valList[index] = undefined;
            if (index === this.#tail) {
              this.#tail = this.#prev[index];
            } else if (index === this.#head) {
              this.#head = this.#next[index];
            } else {
              const pi = this.#prev[index];
              this.#next[pi] = this.#next[index];
              const ni = this.#next[index];
              this.#prev[ni] = this.#prev[index];
            }
            this.#size--;
            this.#free.push(index);
          }
        }
      }
      if (this.#hasDisposeAfter && this.#disposed?.length) {
        const dt = this.#disposed;
        let task;
        while (task = dt?.shift()) {
          this.#disposeAfter?.(...task);
        }
      }
      return deleted;
    }
    clear() {
      return this.#clear("delete");
    }
    #clear(reason) {
      for (const index of this.#rindexes({ allowStale: true })) {
        const v = this.#valList[index];
        if (this.#isBackgroundFetch(v)) {
          v.__abortController.abort(new Error("deleted"));
        } else {
          const k = this.#keyList[index];
          if (this.#hasDispose) {
            this.#dispose?.(v, k, reason);
          }
          if (this.#hasDisposeAfter) {
            this.#disposed?.push([v, k, reason]);
          }
        }
      }
      this.#keyMap.clear();
      this.#valList.fill(undefined);
      this.#keyList.fill(undefined);
      if (this.#ttls && this.#starts) {
        this.#ttls.fill(0);
        this.#starts.fill(0);
        for (const t of this.#autopurgeTimers ?? []) {
          if (t !== undefined)
            clearTimeout(t);
        }
        this.#autopurgeTimers?.fill(undefined);
      }
      if (this.#sizes) {
        this.#sizes.fill(0);
      }
      this.#head = 0;
      this.#tail = 0;
      this.#free.length = 0;
      this.#calculatedSize = 0;
      this.#size = 0;
      if (this.#hasDisposeAfter && this.#disposed) {
        const dt = this.#disposed;
        let task;
        while (task = dt?.shift()) {
          this.#disposeAfter?.(...task);
        }
      }
    }
  };
});

// ../../node_modules/.bun/base-x@5.0.1/node_modules/base-x/src/esm/index.js
function base(ALPHABET) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  const BASE_MAP = new Uint8Array(256);
  for (let j = 0;j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (let i = 0;i < ALPHABET.length; i++) {
    const x = ALPHABET.charAt(i);
    const xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  const BASE = ALPHABET.length;
  const LEADER = ALPHABET.charAt(0);
  const FACTOR = Math.log(BASE) / Math.log(256);
  const iFACTOR = Math.log(256) / Math.log(BASE);
  function encode(source) {
    if (source instanceof Uint8Array) {} else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    let zeroes = 0;
    let length = 0;
    let pbegin = 0;
    const pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    const size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    const b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      let carry = source[pbegin];
      let i = 0;
      for (let it1 = size - 1;(carry !== 0 || i < length) && it1 !== -1; it1--, i++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length = i;
      pbegin++;
    }
    let it2 = size - length;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    let str = LEADER.repeat(zeroes);
    for (;it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array;
    }
    let psz = 0;
    let zeroes = 0;
    let length = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    const size = (source.length - psz) * FACTOR + 1 >>> 0;
    const b256 = new Uint8Array(size);
    while (psz < source.length) {
      const charCode = source.charCodeAt(psz);
      if (charCode > 255) {
        return;
      }
      let carry = BASE_MAP[charCode];
      if (carry === 255) {
        return;
      }
      let i = 0;
      for (let it3 = size - 1;(carry !== 0 || i < length) && it3 !== -1; it3--, i++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length = i;
      psz++;
    }
    let it4 = size - length;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    const vch = new Uint8Array(zeroes + (size - it4));
    let j = zeroes;
    while (it4 !== size) {
      vch[j++] = b256[it4++];
    }
    return vch;
  }
  function decode(string) {
    const buffer = decodeUnsafe(string);
    if (buffer) {
      return buffer;
    }
    throw new Error("Non-base" + BASE + " character");
  }
  return {
    encode,
    decodeUnsafe,
    decode
  };
}
var esm_default;
var init_esm2 = __esm(() => {
  esm_default = base;
});

// ../../node_modules/.bun/bs58@6.0.0/node_modules/bs58/src/esm/index.js
var exports_esm = {};
__export(exports_esm, {
  default: () => esm_default2
});
var ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz", esm_default2;
var init_esm3 = __esm(() => {
  init_esm2();
  esm_default2 = esm_default(ALPHABET);
});

// ../../node_modules/.bun/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/cryptoNode.js
import * as nc from "node:crypto";
var crypto2;
var init_cryptoNode = __esm(() => {
  crypto2 = nc && typeof nc === "object" && "webcrypto" in nc ? nc.webcrypto : nc && typeof nc === "object" && ("randomBytes" in nc) ? nc : undefined;
});

// ../../node_modules/.bun/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/utils.js
function isBytes(a) {
  return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
}
function anumber(n) {
  if (!Number.isSafeInteger(n) || n < 0)
    throw new Error("positive integer expected, got " + n);
}
function abytes(b, ...lengths) {
  if (!isBytes(b))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
}
function aexists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function aoutput(out, instance) {
  abytes(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error("digestInto() expects output buffer of length at least " + min);
  }
}
function clean(...arrays) {
  for (let i = 0;i < arrays.length; i++) {
    arrays[i].fill(0);
  }
}
function createView(arr) {
  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
function rotr(word, shift) {
  return word << 32 - shift | word >>> shift;
}
function bytesToHex(bytes) {
  abytes(bytes);
  if (hasHexBuiltin)
    return bytes.toHex();
  let hex = "";
  for (let i = 0;i < bytes.length; i++) {
    hex += hexes[bytes[i]];
  }
  return hex;
}
function asciiToBase16(ch) {
  if (ch >= asciis._0 && ch <= asciis._9)
    return ch - asciis._0;
  if (ch >= asciis.A && ch <= asciis.F)
    return ch - (asciis.A - 10);
  if (ch >= asciis.a && ch <= asciis.f)
    return ch - (asciis.a - 10);
  return;
}
function hexToBytes(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  if (hasHexBuiltin)
    return Uint8Array.fromHex(hex);
  const hl = hex.length;
  const al = hl / 2;
  if (hl % 2)
    throw new Error("hex string expected, got unpadded hex of length " + hl);
  const array = new Uint8Array(al);
  for (let ai = 0, hi = 0;ai < al; ai++, hi += 2) {
    const n1 = asciiToBase16(hex.charCodeAt(hi));
    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
    if (n1 === undefined || n2 === undefined) {
      const char = hex[hi] + hex[hi + 1];
      throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
    }
    array[ai] = n1 * 16 + n2;
  }
  return array;
}
function utf8ToBytes(str) {
  if (typeof str !== "string")
    throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes(data) {
  if (typeof data === "string")
    data = utf8ToBytes(data);
  abytes(data);
  return data;
}
function concatBytes(...arrays) {
  let sum = 0;
  for (let i = 0;i < arrays.length; i++) {
    const a = arrays[i];
    abytes(a);
    sum += a.length;
  }
  const res = new Uint8Array(sum);
  for (let i = 0, pad = 0;i < arrays.length; i++) {
    const a = arrays[i];
    res.set(a, pad);
    pad += a.length;
  }
  return res;
}

class Hash {
}
function createHasher(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function randomBytes(bytesLength = 32) {
  if (crypto2 && typeof crypto2.getRandomValues === "function") {
    return crypto2.getRandomValues(new Uint8Array(bytesLength));
  }
  if (crypto2 && typeof crypto2.randomBytes === "function") {
    return Uint8Array.from(crypto2.randomBytes(bytesLength));
  }
  throw new Error("crypto.getRandomValues must be defined");
}
var hasHexBuiltin, hexes, asciis;
var init_utils = __esm(() => {
  init_cryptoNode();
  /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  hasHexBuiltin = /* @__PURE__ */ (() => typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function")();
  hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
  asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
});

// ../../node_modules/.bun/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/_md.js
function setBigUint64(view, byteOffset, value, isLE) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE);
  const _32n = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n & _u32_max);
  const wl = Number(value & _u32_max);
  const h = isLE ? 4 : 0;
  const l2 = isLE ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE);
  view.setUint32(byteOffset + l2, wl, isLE);
}
function Chi(a, b, c) {
  return a & b ^ ~a & c;
}
function Maj(a, b, c) {
  return a & b ^ a & c ^ b & c;
}
var HashMD, SHA256_IV, SHA512_IV;
var init__md = __esm(() => {
  init_utils();
  HashMD = class HashMD extends Hash {
    constructor(blockLen, outputLen, padOffset, isLE) {
      super();
      this.finished = false;
      this.length = 0;
      this.pos = 0;
      this.destroyed = false;
      this.blockLen = blockLen;
      this.outputLen = outputLen;
      this.padOffset = padOffset;
      this.isLE = isLE;
      this.buffer = new Uint8Array(blockLen);
      this.view = createView(this.buffer);
    }
    update(data) {
      aexists(this);
      data = toBytes(data);
      abytes(data);
      const { view, buffer, blockLen } = this;
      const len = data.length;
      for (let pos = 0;pos < len; ) {
        const take = Math.min(blockLen - this.pos, len - pos);
        if (take === blockLen) {
          const dataView = createView(data);
          for (;blockLen <= len - pos; pos += blockLen)
            this.process(dataView, pos);
          continue;
        }
        buffer.set(data.subarray(pos, pos + take), this.pos);
        this.pos += take;
        pos += take;
        if (this.pos === blockLen) {
          this.process(view, 0);
          this.pos = 0;
        }
      }
      this.length += data.length;
      this.roundClean();
      return this;
    }
    digestInto(out) {
      aexists(this);
      aoutput(out, this);
      this.finished = true;
      const { buffer, view, blockLen, isLE } = this;
      let { pos } = this;
      buffer[pos++] = 128;
      clean(this.buffer.subarray(pos));
      if (this.padOffset > blockLen - pos) {
        this.process(view, 0);
        pos = 0;
      }
      for (let i = pos;i < blockLen; i++)
        buffer[i] = 0;
      setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
      this.process(view, 0);
      const oview = createView(out);
      const len = this.outputLen;
      if (len % 4)
        throw new Error("_sha2: outputLen should be aligned to 32bit");
      const outLen = len / 4;
      const state = this.get();
      if (outLen > state.length)
        throw new Error("_sha2: outputLen bigger than state");
      for (let i = 0;i < outLen; i++)
        oview.setUint32(4 * i, state[i], isLE);
    }
    digest() {
      const { buffer, outputLen } = this;
      this.digestInto(buffer);
      const res = buffer.slice(0, outputLen);
      this.destroy();
      return res;
    }
    _cloneInto(to) {
      to || (to = new this.constructor);
      to.set(...this.get());
      const { blockLen, buffer, length, finished, destroyed, pos } = this;
      to.destroyed = destroyed;
      to.finished = finished;
      to.length = length;
      to.pos = pos;
      if (length % blockLen)
        to.buffer.set(buffer);
      return to;
    }
    clone() {
      return this._cloneInto();
    }
  };
  SHA256_IV = /* @__PURE__ */ Uint32Array.from([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ]);
  SHA512_IV = /* @__PURE__ */ Uint32Array.from([
    1779033703,
    4089235720,
    3144134277,
    2227873595,
    1013904242,
    4271175723,
    2773480762,
    1595750129,
    1359893119,
    2917565137,
    2600822924,
    725511199,
    528734635,
    4215389547,
    1541459225,
    327033209
  ]);
});

// ../../node_modules/.bun/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/_u64.js
function fromBig(n, le = false) {
  if (le)
    return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
  return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
}
function split(lst, le = false) {
  const len = lst.length;
  let Ah = new Uint32Array(len);
  let Al = new Uint32Array(len);
  for (let i = 0;i < len; i++) {
    const { h, l: l2 } = fromBig(lst[i], le);
    [Ah[i], Al[i]] = [h, l2];
  }
  return [Ah, Al];
}
function add(Ah, Al, Bh, Bl) {
  const l2 = (Al >>> 0) + (Bl >>> 0);
  return { h: Ah + Bh + (l2 / 2 ** 32 | 0) | 0, l: l2 | 0 };
}
var U32_MASK64, _32n, shrSH = (h, _l, s3) => h >>> s3, shrSL = (h, l2, s3) => h << 32 - s3 | l2 >>> s3, rotrSH = (h, l2, s3) => h >>> s3 | l2 << 32 - s3, rotrSL = (h, l2, s3) => h << 32 - s3 | l2 >>> s3, rotrBH = (h, l2, s3) => h << 64 - s3 | l2 >>> s3 - 32, rotrBL = (h, l2, s3) => h >>> s3 - 32 | l2 << 64 - s3, add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0), add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0, add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0), add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0, add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0), add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
var init__u64 = __esm(() => {
  U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
  _32n = /* @__PURE__ */ BigInt(32);
});

// ../../node_modules/.bun/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/sha2.js
var SHA256_K, SHA256_W, SHA256, K512, SHA512_Kh, SHA512_Kl, SHA512_W_H, SHA512_W_L, SHA512, sha256, sha512;
var init_sha2 = __esm(() => {
  init__md();
  init__u64();
  init_utils();
  SHA256_K = /* @__PURE__ */ Uint32Array.from([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]);
  SHA256_W = /* @__PURE__ */ new Uint32Array(64);
  SHA256 = class SHA256 extends HashMD {
    constructor(outputLen = 32) {
      super(64, outputLen, 8, false);
      this.A = SHA256_IV[0] | 0;
      this.B = SHA256_IV[1] | 0;
      this.C = SHA256_IV[2] | 0;
      this.D = SHA256_IV[3] | 0;
      this.E = SHA256_IV[4] | 0;
      this.F = SHA256_IV[5] | 0;
      this.G = SHA256_IV[6] | 0;
      this.H = SHA256_IV[7] | 0;
    }
    get() {
      const { A, B, C, D: D3, E, F, G, H } = this;
      return [A, B, C, D3, E, F, G, H];
    }
    set(A, B, C, D3, E, F, G, H) {
      this.A = A | 0;
      this.B = B | 0;
      this.C = C | 0;
      this.D = D3 | 0;
      this.E = E | 0;
      this.F = F | 0;
      this.G = G | 0;
      this.H = H | 0;
    }
    process(view, offset) {
      for (let i = 0;i < 16; i++, offset += 4)
        SHA256_W[i] = view.getUint32(offset, false);
      for (let i = 16;i < 64; i++) {
        const W15 = SHA256_W[i - 15];
        const W2 = SHA256_W[i - 2];
        const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
        const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
        SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
      }
      let { A, B, C, D: D3, E, F, G, H } = this;
      for (let i = 0;i < 64; i++) {
        const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
        const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
        const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
        const T2 = sigma0 + Maj(A, B, C) | 0;
        H = G;
        G = F;
        F = E;
        E = D3 + T1 | 0;
        D3 = C;
        C = B;
        B = A;
        A = T1 + T2 | 0;
      }
      A = A + this.A | 0;
      B = B + this.B | 0;
      C = C + this.C | 0;
      D3 = D3 + this.D | 0;
      E = E + this.E | 0;
      F = F + this.F | 0;
      G = G + this.G | 0;
      H = H + this.H | 0;
      this.set(A, B, C, D3, E, F, G, H);
    }
    roundClean() {
      clean(SHA256_W);
    }
    destroy() {
      this.set(0, 0, 0, 0, 0, 0, 0, 0);
      clean(this.buffer);
    }
  };
  K512 = /* @__PURE__ */ (() => split([
    "0x428a2f98d728ae22",
    "0x7137449123ef65cd",
    "0xb5c0fbcfec4d3b2f",
    "0xe9b5dba58189dbbc",
    "0x3956c25bf348b538",
    "0x59f111f1b605d019",
    "0x923f82a4af194f9b",
    "0xab1c5ed5da6d8118",
    "0xd807aa98a3030242",
    "0x12835b0145706fbe",
    "0x243185be4ee4b28c",
    "0x550c7dc3d5ffb4e2",
    "0x72be5d74f27b896f",
    "0x80deb1fe3b1696b1",
    "0x9bdc06a725c71235",
    "0xc19bf174cf692694",
    "0xe49b69c19ef14ad2",
    "0xefbe4786384f25e3",
    "0x0fc19dc68b8cd5b5",
    "0x240ca1cc77ac9c65",
    "0x2de92c6f592b0275",
    "0x4a7484aa6ea6e483",
    "0x5cb0a9dcbd41fbd4",
    "0x76f988da831153b5",
    "0x983e5152ee66dfab",
    "0xa831c66d2db43210",
    "0xb00327c898fb213f",
    "0xbf597fc7beef0ee4",
    "0xc6e00bf33da88fc2",
    "0xd5a79147930aa725",
    "0x06ca6351e003826f",
    "0x142929670a0e6e70",
    "0x27b70a8546d22ffc",
    "0x2e1b21385c26c926",
    "0x4d2c6dfc5ac42aed",
    "0x53380d139d95b3df",
    "0x650a73548baf63de",
    "0x766a0abb3c77b2a8",
    "0x81c2c92e47edaee6",
    "0x92722c851482353b",
    "0xa2bfe8a14cf10364",
    "0xa81a664bbc423001",
    "0xc24b8b70d0f89791",
    "0xc76c51a30654be30",
    "0xd192e819d6ef5218",
    "0xd69906245565a910",
    "0xf40e35855771202a",
    "0x106aa07032bbd1b8",
    "0x19a4c116b8d2d0c8",
    "0x1e376c085141ab53",
    "0x2748774cdf8eeb99",
    "0x34b0bcb5e19b48a8",
    "0x391c0cb3c5c95a63",
    "0x4ed8aa4ae3418acb",
    "0x5b9cca4f7763e373",
    "0x682e6ff3d6b2b8a3",
    "0x748f82ee5defb2fc",
    "0x78a5636f43172f60",
    "0x84c87814a1f0ab72",
    "0x8cc702081a6439ec",
    "0x90befffa23631e28",
    "0xa4506cebde82bde9",
    "0xbef9a3f7b2c67915",
    "0xc67178f2e372532b",
    "0xca273eceea26619c",
    "0xd186b8c721c0c207",
    "0xeada7dd6cde0eb1e",
    "0xf57d4f7fee6ed178",
    "0x06f067aa72176fba",
    "0x0a637dc5a2c898a6",
    "0x113f9804bef90dae",
    "0x1b710b35131c471b",
    "0x28db77f523047d84",
    "0x32caab7b40c72493",
    "0x3c9ebe0a15c9bebc",
    "0x431d67c49c100d4c",
    "0x4cc5d4becb3e42b6",
    "0x597f299cfc657e2a",
    "0x5fcb6fab3ad6faec",
    "0x6c44198c4a475817"
  ].map((n) => BigInt(n))))();
  SHA512_Kh = /* @__PURE__ */ (() => K512[0])();
  SHA512_Kl = /* @__PURE__ */ (() => K512[1])();
  SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
  SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
  SHA512 = class SHA512 extends HashMD {
    constructor(outputLen = 64) {
      super(128, outputLen, 16, false);
      this.Ah = SHA512_IV[0] | 0;
      this.Al = SHA512_IV[1] | 0;
      this.Bh = SHA512_IV[2] | 0;
      this.Bl = SHA512_IV[3] | 0;
      this.Ch = SHA512_IV[4] | 0;
      this.Cl = SHA512_IV[5] | 0;
      this.Dh = SHA512_IV[6] | 0;
      this.Dl = SHA512_IV[7] | 0;
      this.Eh = SHA512_IV[8] | 0;
      this.El = SHA512_IV[9] | 0;
      this.Fh = SHA512_IV[10] | 0;
      this.Fl = SHA512_IV[11] | 0;
      this.Gh = SHA512_IV[12] | 0;
      this.Gl = SHA512_IV[13] | 0;
      this.Hh = SHA512_IV[14] | 0;
      this.Hl = SHA512_IV[15] | 0;
    }
    get() {
      const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
      return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
    }
    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
      this.Ah = Ah | 0;
      this.Al = Al | 0;
      this.Bh = Bh | 0;
      this.Bl = Bl | 0;
      this.Ch = Ch | 0;
      this.Cl = Cl | 0;
      this.Dh = Dh | 0;
      this.Dl = Dl | 0;
      this.Eh = Eh | 0;
      this.El = El | 0;
      this.Fh = Fh | 0;
      this.Fl = Fl | 0;
      this.Gh = Gh | 0;
      this.Gl = Gl | 0;
      this.Hh = Hh | 0;
      this.Hl = Hl | 0;
    }
    process(view, offset) {
      for (let i = 0;i < 16; i++, offset += 4) {
        SHA512_W_H[i] = view.getUint32(offset);
        SHA512_W_L[i] = view.getUint32(offset += 4);
      }
      for (let i = 16;i < 80; i++) {
        const W15h = SHA512_W_H[i - 15] | 0;
        const W15l = SHA512_W_L[i - 15] | 0;
        const s0h = rotrSH(W15h, W15l, 1) ^ rotrSH(W15h, W15l, 8) ^ shrSH(W15h, W15l, 7);
        const s0l = rotrSL(W15h, W15l, 1) ^ rotrSL(W15h, W15l, 8) ^ shrSL(W15h, W15l, 7);
        const W2h = SHA512_W_H[i - 2] | 0;
        const W2l = SHA512_W_L[i - 2] | 0;
        const s1h = rotrSH(W2h, W2l, 19) ^ rotrBH(W2h, W2l, 61) ^ shrSH(W2h, W2l, 6);
        const s1l = rotrSL(W2h, W2l, 19) ^ rotrBL(W2h, W2l, 61) ^ shrSL(W2h, W2l, 6);
        const SUMl = add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
        const SUMh = add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
        SHA512_W_H[i] = SUMh | 0;
        SHA512_W_L[i] = SUMl | 0;
      }
      let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
      for (let i = 0;i < 80; i++) {
        const sigma1h = rotrSH(Eh, El, 14) ^ rotrSH(Eh, El, 18) ^ rotrBH(Eh, El, 41);
        const sigma1l = rotrSL(Eh, El, 14) ^ rotrSL(Eh, El, 18) ^ rotrBL(Eh, El, 41);
        const CHIh = Eh & Fh ^ ~Eh & Gh;
        const CHIl = El & Fl ^ ~El & Gl;
        const T1ll = add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
        const T1h = add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
        const T1l = T1ll | 0;
        const sigma0h = rotrSH(Ah, Al, 28) ^ rotrBH(Ah, Al, 34) ^ rotrBH(Ah, Al, 39);
        const sigma0l = rotrSL(Ah, Al, 28) ^ rotrBL(Ah, Al, 34) ^ rotrBL(Ah, Al, 39);
        const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
        const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
        Hh = Gh | 0;
        Hl = Gl | 0;
        Gh = Fh | 0;
        Gl = Fl | 0;
        Fh = Eh | 0;
        Fl = El | 0;
        ({ h: Eh, l: El } = add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
        Dh = Ch | 0;
        Dl = Cl | 0;
        Ch = Bh | 0;
        Cl = Bl | 0;
        Bh = Ah | 0;
        Bl = Al | 0;
        const All = add3L(T1l, sigma0l, MAJl);
        Ah = add3H(All, T1h, sigma0h, MAJh);
        Al = All | 0;
      }
      ({ h: Ah, l: Al } = add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
      ({ h: Bh, l: Bl } = add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
      ({ h: Ch, l: Cl } = add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
      ({ h: Dh, l: Dl } = add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
      ({ h: Eh, l: El } = add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
      ({ h: Fh, l: Fl } = add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
      ({ h: Gh, l: Gl } = add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
      ({ h: Hh, l: Hl } = add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
      this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
    }
    roundClean() {
      clean(SHA512_W_H, SHA512_W_L);
    }
    destroy() {
      clean(this.buffer);
      this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
  };
  sha256 = /* @__PURE__ */ createHasher(() => new SHA256);
  sha512 = /* @__PURE__ */ createHasher(() => new SHA512);
});

// ../../node_modules/.bun/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/sha256.js
var sha2562;
var init_sha256 = __esm(() => {
  init_sha2();
  sha2562 = sha256;
});

// ../sdk-typescript/dist/chunk-46QWY3MG.js
function getCreateAgentAuthorizationDiscriminatorBytes() {
  return fixEncoderSize2(getBytesEncoder(), 8).encode(CREATE_AGENT_AUTHORIZATION_DISCRIMINATOR);
}
function getCreateAgentAuthorizationInstructionDataEncoder() {
  return transformEncoder2(getStructEncoder([
    ["discriminator", fixEncoderSize2(getBytesEncoder(), 8)],
    ["authorizedSource", getAddressEncoder2()],
    ["indexLimit", getU64Encoder()],
    ["expiresAt", getI64Encoder()],
    ["network", getU8Encoder()],
    ["signature", fixEncoderSize2(getBytesEncoder(), 64)],
    [
      "nonce",
      getOptionEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ]
  ]), (value) => ({
    ...value,
    discriminator: CREATE_AGENT_AUTHORIZATION_DISCRIMINATOR
  }));
}
function getCreateAgentAuthorizationInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize2(getBytesDecoder(), 8)],
    ["authorizedSource", getAddressDecoder2()],
    ["indexLimit", getU64Decoder()],
    ["expiresAt", getI64Decoder()],
    ["network", getU8Decoder()],
    ["signature", fixDecoderSize2(getBytesDecoder(), 64)],
    [
      "nonce",
      getOptionDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ]
  ]);
}
function getCreateAgentAuthorizationInstructionDataCodec() {
  return combineCodec2(getCreateAgentAuthorizationInstructionDataEncoder(), getCreateAgentAuthorizationInstructionDataDecoder());
}
async function getCreateAgentAuthorizationInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    agent: { value: input.agent ?? null, isWritable: false },
    authorization: { value: input.authorization ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.authorization.value) {
    accounts2.authorization.value = await getProgramDerivedAddress2({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([97, 103, 101, 110, 116, 95, 97, 117, 116, 104])),
        getAddressEncoder2().encode(expectAddress(accounts2.agent.value)),
        getAddressEncoder2().encode(expectSome(args.authorizedSource)),
        getOptionEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())).encode(expectSome(args.nonce))
      ]
    });
  }
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.agent),
      getAccountMeta(accounts2.authorization),
      getAccountMeta(accounts2.authority),
      getAccountMeta(accounts2.systemProgram)
    ],
    data: getCreateAgentAuthorizationInstructionDataEncoder().encode(args),
    programAddress
  });
}
function getCreateAgentAuthorizationInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    agent: { value: input.agent ?? null, isWritable: false },
    authorization: { value: input.authorization ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.agent),
      getAccountMeta(accounts2.authorization),
      getAccountMeta(accounts2.authority),
      getAccountMeta(accounts2.systemProgram)
    ],
    data: getCreateAgentAuthorizationInstructionDataEncoder().encode(args),
    programAddress
  });
}
function parseCreateAgentAuthorizationInstruction(instruction) {
  if (instruction.accounts.length < 4) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      agent: getNextAccount(),
      authorization: getNextAccount(),
      authority: getNextAccount(),
      systemProgram: getNextAccount()
    },
    data: getCreateAgentAuthorizationInstructionDataDecoder().decode(instruction.data)
  };
}
var CREATE_AGENT_AUTHORIZATION_DISCRIMINATOR;
var init_chunk_46QWY3MG = __esm(() => {
  init_chunk_AWMGX3OX();
  init_index_node40();
  CREATE_AGENT_AUTHORIZATION_DISCRIMINATOR = new Uint8Array([
    48,
    219,
    232,
    202,
    151,
    97,
    230,
    20
  ]);
});

// ../sdk-typescript/dist/chunk-A7ALCVUI.js
function getRevokeAuthorizationDiscriminatorBytes() {
  return fixEncoderSize2(getBytesEncoder(), 8).encode(REVOKE_AUTHORIZATION_DISCRIMINATOR);
}
function getRevokeAuthorizationInstructionDataEncoder() {
  return transformEncoder2(getStructEncoder([
    ["discriminator", fixEncoderSize2(getBytesEncoder(), 8)],
    [
      "nonce",
      getOptionEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ]
  ]), (value) => ({
    ...value,
    discriminator: REVOKE_AUTHORIZATION_DISCRIMINATOR
  }));
}
function getRevokeAuthorizationInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize2(getBytesDecoder(), 8)],
    [
      "nonce",
      getOptionDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ]
  ]);
}
function getRevokeAuthorizationInstructionDataCodec() {
  return combineCodec2(getRevokeAuthorizationInstructionDataEncoder(), getRevokeAuthorizationInstructionDataDecoder());
}
function getRevokeAuthorizationInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    agent: { value: input.agent ?? null, isWritable: false },
    authorization: { value: input.authorization ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.agent),
      getAccountMeta(accounts2.authorization),
      getAccountMeta(accounts2.authority)
    ],
    data: getRevokeAuthorizationInstructionDataEncoder().encode(args),
    programAddress
  });
}
function parseRevokeAuthorizationInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      agent: getNextAccount(),
      authorization: getNextAccount(),
      authority: getNextAccount()
    },
    data: getRevokeAuthorizationInstructionDataDecoder().decode(instruction.data)
  };
}
var REVOKE_AUTHORIZATION_DISCRIMINATOR;
var init_chunk_A7ALCVUI = __esm(() => {
  init_chunk_AWMGX3OX();
  init_index_node40();
  REVOKE_AUTHORIZATION_DISCRIMINATOR = new Uint8Array([
    222,
    179,
    207,
    59,
    191,
    78,
    24,
    248
  ]);
});

// ../sdk-typescript/dist/chunk-QLRWUHN2.js
function getUpdateReputationWithAuthDiscriminatorBytes() {
  return fixEncoderSize2(getBytesEncoder(), 8).encode(UPDATE_REPUTATION_WITH_AUTH_DISCRIMINATOR);
}
function getUpdateReputationWithAuthInstructionDataEncoder() {
  return transformEncoder2(getStructEncoder([
    ["discriminator", fixEncoderSize2(getBytesEncoder(), 8)],
    ["reputationChange", getI64Encoder()],
    [
      "transactionSignature",
      addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())
    ],
    [
      "metadata",
      getOptionEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    [
      "nonce",
      getOptionEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ]
  ]), (value) => ({
    ...value,
    discriminator: UPDATE_REPUTATION_WITH_AUTH_DISCRIMINATOR
  }));
}
function getUpdateReputationWithAuthInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize2(getBytesDecoder(), 8)],
    ["reputationChange", getI64Decoder()],
    [
      "transactionSignature",
      addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())
    ],
    [
      "metadata",
      getOptionDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    [
      "nonce",
      getOptionDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ]
  ]);
}
function getUpdateReputationWithAuthInstructionDataCodec() {
  return combineCodec2(getUpdateReputationWithAuthInstructionDataEncoder(), getUpdateReputationWithAuthInstructionDataDecoder());
}
async function getUpdateReputationWithAuthInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    agent: { value: input.agent ?? null, isWritable: false },
    reputationMetrics: {
      value: input.reputationMetrics ?? null,
      isWritable: true
    },
    authorization: { value: input.authorization ?? null, isWritable: true },
    usageRecord: { value: input.usageRecord ?? null, isWritable: true },
    authorizedSource: {
      value: input.authorizedSource ?? null,
      isWritable: true
    },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    clock: { value: input.clock ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.reputationMetrics.value) {
    accounts2.reputationMetrics.value = await getProgramDerivedAddress2({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([
          114,
          101,
          112,
          117,
          116,
          97,
          116,
          105,
          111,
          110,
          95,
          109,
          101,
          116,
          114,
          105,
          99,
          115
        ])),
        getAddressEncoder2().encode(expectAddress(accounts2.agent.value))
      ]
    });
  }
  if (!accounts2.authorization.value) {
    accounts2.authorization.value = await getProgramDerivedAddress2({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([97, 103, 101, 110, 116, 95, 97, 117, 116, 104])),
        getAddressEncoder2().encode(expectAddress(accounts2.agent.value)),
        getAddressEncoder2().encode(expectAddress(accounts2.authorizedSource.value)),
        getOptionEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())).encode(expectSome(args.nonce))
      ]
    });
  }
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  if (!accounts2.clock.value) {
    accounts2.clock.value = "SysvarC1ock11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.agent),
      getAccountMeta(accounts2.reputationMetrics),
      getAccountMeta(accounts2.authorization),
      getAccountMeta(accounts2.usageRecord),
      getAccountMeta(accounts2.authorizedSource),
      getAccountMeta(accounts2.systemProgram),
      getAccountMeta(accounts2.clock)
    ],
    data: getUpdateReputationWithAuthInstructionDataEncoder().encode(args),
    programAddress
  });
}
function getUpdateReputationWithAuthInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    agent: { value: input.agent ?? null, isWritable: false },
    reputationMetrics: {
      value: input.reputationMetrics ?? null,
      isWritable: true
    },
    authorization: { value: input.authorization ?? null, isWritable: true },
    usageRecord: { value: input.usageRecord ?? null, isWritable: true },
    authorizedSource: {
      value: input.authorizedSource ?? null,
      isWritable: true
    },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    clock: { value: input.clock ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  if (!accounts2.clock.value) {
    accounts2.clock.value = "SysvarC1ock11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.agent),
      getAccountMeta(accounts2.reputationMetrics),
      getAccountMeta(accounts2.authorization),
      getAccountMeta(accounts2.usageRecord),
      getAccountMeta(accounts2.authorizedSource),
      getAccountMeta(accounts2.systemProgram),
      getAccountMeta(accounts2.clock)
    ],
    data: getUpdateReputationWithAuthInstructionDataEncoder().encode(args),
    programAddress
  });
}
function parseUpdateReputationWithAuthInstruction(instruction) {
  if (instruction.accounts.length < 7) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      agent: getNextAccount(),
      reputationMetrics: getNextAccount(),
      authorization: getNextAccount(),
      usageRecord: getNextAccount(),
      authorizedSource: getNextAccount(),
      systemProgram: getNextAccount(),
      clock: getNextAccount()
    },
    data: getUpdateReputationWithAuthInstructionDataDecoder().decode(instruction.data)
  };
}
var UPDATE_REPUTATION_WITH_AUTH_DISCRIMINATOR;
var init_chunk_QLRWUHN2 = __esm(() => {
  init_chunk_AWMGX3OX();
  init_index_node40();
  UPDATE_REPUTATION_WITH_AUTH_DISCRIMINATOR = new Uint8Array([
    61,
    236,
    225,
    167,
    134,
    43,
    53,
    93
  ]);
});

// ../sdk-typescript/dist/generated-JSSPHJE6.js
var exports_generated_JSSPHJE6 = {};
__export(exports_generated_JSSPHJE6, {
  parseVerifyAuthorizationInstruction: () => parseVerifyAuthorizationInstruction,
  parseVerifyAgentInstruction: () => parseVerifyAgentInstruction,
  parseUpdateSourceReputationInstruction: () => parseUpdateSourceReputationInstruction,
  parseUpdateReputationWithAuthInstruction: () => parseUpdateReputationWithAuthInstruction,
  parseUpdateReputationTagsInstruction: () => parseUpdateReputationTagsInstruction,
  parseUpdateProtocolConfigInstruction: () => parseUpdateProtocolConfigInstruction,
  parseUpdateGhostScoreInstruction: () => parseUpdateGhostScoreInstruction,
  parseUpdateDidDocumentInstruction: () => parseUpdateDidDocumentInstruction,
  parseUpdateCrosschainStatusInstruction: () => parseUpdateCrosschainStatusInstruction,
  parseUpdateAgentServiceInstruction: () => parseUpdateAgentServiceInstruction,
  parseUpdateAgentReputationInstruction: () => parseUpdateAgentReputationInstruction,
  parseUpdateAgentInstruction: () => parseUpdateAgentInstruction,
  parseUnstakeGhostInstruction: () => parseUnstakeGhostInstruction,
  parseSubmitServiceRatingInstruction: () => parseSubmitServiceRatingInstruction,
  parseSubmitDeliveryInstruction: () => parseSubmitDeliveryInstruction,
  parseStakeGhostInstruction: () => parseStakeGhostInstruction,
  parseSlashStakeInstruction: () => parseSlashStakeInstruction,
  parseRevokeCredentialInstruction: () => parseRevokeCredentialInstruction,
  parseRevokeAuthorizationInstruction: () => parseRevokeAuthorizationInstruction,
  parseResolveDidDocumentInstruction: () => parseResolveDidDocumentInstruction,
  parseResetReentrancyGuardInstruction: () => parseResetReentrancyGuardInstruction,
  parseRegisterGhostMetadataInstruction: () => parseRegisterGhostMetadataInstruction,
  parseRegisterAgentInstruction: () => parseRegisterAgentInstruction,
  parseRegisterAgentCompressedInstruction: () => parseRegisterAgentCompressedInstruction,
  parseRecordPayaiPaymentInstruction: () => parseRecordPayaiPaymentInstruction,
  parseManageAgentStatusInstruction: () => parseManageAgentStatusInstruction,
  parseLinkExternalIdInstruction: () => parseLinkExternalIdInstruction,
  parseIssueCredentialInstruction: () => parseIssueCredentialInstruction,
  parseInitializeStakingConfigInstruction: () => parseInitializeStakingConfigInstruction,
  parseInitializeReputationMetricsInstruction: () => parseInitializeReputationMetricsInstruction,
  parseInitializeRbacConfigInstruction: () => parseInitializeRbacConfigInstruction,
  parseInitializeProtocolConfigInstruction: () => parseInitializeProtocolConfigInstruction,
  parseInitializeGovernanceProposalInstruction: () => parseInitializeGovernanceProposalInstruction,
  parseInitializeAuditTrailInstruction: () => parseInitializeAuditTrailInstruction,
  parseInitReentrancyGuardInstruction: () => parseInitReentrancyGuardInstruction,
  parseGenerateComplianceReportInstruction: () => parseGenerateComplianceReportInstruction,
  parseFileDisputeInstruction: () => parseFileDisputeInstruction,
  parseEnableProtocolFeesInstruction: () => parseEnableProtocolFeesInstruction,
  parseDeactivateDidDocumentInstruction: () => parseDeactivateDidDocumentInstruction,
  parseDeactivateCredentialTypeInstruction: () => parseDeactivateCredentialTypeInstruction,
  parseDeactivateCredentialTemplateInstruction: () => parseDeactivateCredentialTemplateInstruction,
  parseDeactivateAgentInstruction: () => parseDeactivateAgentInstruction,
  parseCreateMultisigInstruction: () => parseCreateMultisigInstruction,
  parseCreateEscrowInstruction: () => parseCreateEscrowInstruction,
  parseCreateDidDocumentInstruction: () => parseCreateDidDocumentInstruction,
  parseCreateCredentialTypeInstruction: () => parseCreateCredentialTypeInstruction,
  parseCreateCredentialTemplateInstruction: () => parseCreateCredentialTemplateInstruction,
  parseCreateAgentAuthorizationInstruction: () => parseCreateAgentAuthorizationInstruction,
  parseClaimGhostInstruction: () => parseClaimGhostInstruction,
  parseAutoCreateGhostInstruction: () => parseAutoCreateGhostInstruction,
  parseArbitrateDisputeInstruction: () => parseArbitrateDisputeInstruction,
  parseApproveDeliveryInstruction: () => parseApproveDeliveryInstruction,
  parseActivateAgentInstruction: () => parseActivateAgentInstruction,
  isGhostspeakMarketplaceError: () => isGhostspeakMarketplaceError,
  isDelegationScope: () => isDelegationScope,
  isArbitratorDecision: () => isArbitratorDecision,
  identifyGhostspeakMarketplaceInstruction: () => identifyGhostspeakMarketplaceInstruction,
  identifyGhostspeakMarketplaceAccount: () => identifyGhostspeakMarketplaceAccount,
  getVotingResultsEncoder: () => getVotingResultsEncoder,
  getVotingResultsDecoder: () => getVotingResultsDecoder,
  getVotingResultsCodec: () => getVotingResultsCodec,
  getVoteEncoder: () => getVoteEncoder,
  getVoteDecoder: () => getVoteDecoder,
  getVoteCodec: () => getVoteCodec,
  getVoteChoiceEncoder: () => getVoteChoiceEncoder,
  getVoteChoiceDecoder: () => getVoteChoiceDecoder,
  getVoteChoiceCodec: () => getVoteChoiceCodec,
  getViolationSeverityEncoder: () => getViolationSeverityEncoder,
  getViolationSeverityDecoder: () => getViolationSeverityDecoder,
  getViolationSeverityCodec: () => getViolationSeverityCodec,
  getVerifyAuthorizationInstructionDataEncoder: () => getVerifyAuthorizationInstructionDataEncoder,
  getVerifyAuthorizationInstructionDataDecoder: () => getVerifyAuthorizationInstructionDataDecoder,
  getVerifyAuthorizationInstructionDataCodec: () => getVerifyAuthorizationInstructionDataCodec,
  getVerifyAuthorizationInstruction: () => getVerifyAuthorizationInstruction,
  getVerifyAuthorizationDiscriminatorBytes: () => getVerifyAuthorizationDiscriminatorBytes,
  getVerifyAgentInstructionDataEncoder: () => getVerifyAgentInstructionDataEncoder,
  getVerifyAgentInstructionDataDecoder: () => getVerifyAgentInstructionDataDecoder,
  getVerifyAgentInstructionDataCodec: () => getVerifyAgentInstructionDataCodec,
  getVerifyAgentInstructionAsync: () => getVerifyAgentInstructionAsync,
  getVerifyAgentInstruction: () => getVerifyAgentInstruction,
  getVerifyAgentDiscriminatorBytes: () => getVerifyAgentDiscriminatorBytes,
  getVerificationRelationshipEncoder: () => getVerificationRelationshipEncoder,
  getVerificationRelationshipDecoder: () => getVerificationRelationshipDecoder,
  getVerificationRelationshipCodec: () => getVerificationRelationshipCodec,
  getVerificationMethodTypeEncoder: () => getVerificationMethodTypeEncoder,
  getVerificationMethodTypeDecoder: () => getVerificationMethodTypeDecoder,
  getVerificationMethodTypeCodec: () => getVerificationMethodTypeCodec,
  getVerificationMethodEncoder: () => getVerificationMethodEncoder,
  getVerificationMethodDecoder: () => getVerificationMethodDecoder,
  getVerificationMethodCodec: () => getVerificationMethodCodec,
  getValueTypeEncoder: () => getValueTypeEncoder,
  getValueTypeDecoder: () => getValueTypeDecoder,
  getValueTypeCodec: () => getValueTypeCodec,
  getUserRegistrySize: () => getUserRegistrySize,
  getUserRegistryEncoder: () => getUserRegistryEncoder,
  getUserRegistryDiscriminatorBytes: () => getUserRegistryDiscriminatorBytes,
  getUserRegistryDecoder: () => getUserRegistryDecoder,
  getUserRegistryCodec: () => getUserRegistryCodec,
  getUpdateSourceReputationInstructionDataEncoder: () => getUpdateSourceReputationInstructionDataEncoder,
  getUpdateSourceReputationInstructionDataDecoder: () => getUpdateSourceReputationInstructionDataDecoder,
  getUpdateSourceReputationInstructionDataCodec: () => getUpdateSourceReputationInstructionDataCodec,
  getUpdateSourceReputationInstructionAsync: () => getUpdateSourceReputationInstructionAsync,
  getUpdateSourceReputationInstruction: () => getUpdateSourceReputationInstruction,
  getUpdateSourceReputationDiscriminatorBytes: () => getUpdateSourceReputationDiscriminatorBytes,
  getUpdateReputationWithAuthInstructionDataEncoder: () => getUpdateReputationWithAuthInstructionDataEncoder,
  getUpdateReputationWithAuthInstructionDataDecoder: () => getUpdateReputationWithAuthInstructionDataDecoder,
  getUpdateReputationWithAuthInstructionDataCodec: () => getUpdateReputationWithAuthInstructionDataCodec,
  getUpdateReputationWithAuthInstructionAsync: () => getUpdateReputationWithAuthInstructionAsync,
  getUpdateReputationWithAuthInstruction: () => getUpdateReputationWithAuthInstruction,
  getUpdateReputationWithAuthDiscriminatorBytes: () => getUpdateReputationWithAuthDiscriminatorBytes,
  getUpdateReputationTagsInstructionDataEncoder: () => getUpdateReputationTagsInstructionDataEncoder,
  getUpdateReputationTagsInstructionDataDecoder: () => getUpdateReputationTagsInstructionDataDecoder,
  getUpdateReputationTagsInstructionDataCodec: () => getUpdateReputationTagsInstructionDataCodec,
  getUpdateReputationTagsInstructionAsync: () => getUpdateReputationTagsInstructionAsync,
  getUpdateReputationTagsInstruction: () => getUpdateReputationTagsInstruction,
  getUpdateReputationTagsDiscriminatorBytes: () => getUpdateReputationTagsDiscriminatorBytes,
  getUpdateProtocolConfigInstructionDataEncoder: () => getUpdateProtocolConfigInstructionDataEncoder,
  getUpdateProtocolConfigInstructionDataDecoder: () => getUpdateProtocolConfigInstructionDataDecoder,
  getUpdateProtocolConfigInstructionDataCodec: () => getUpdateProtocolConfigInstructionDataCodec,
  getUpdateProtocolConfigInstructionAsync: () => getUpdateProtocolConfigInstructionAsync,
  getUpdateProtocolConfigInstruction: () => getUpdateProtocolConfigInstruction,
  getUpdateProtocolConfigDiscriminatorBytes: () => getUpdateProtocolConfigDiscriminatorBytes,
  getUpdateGhostScoreInstructionDataEncoder: () => getUpdateGhostScoreInstructionDataEncoder,
  getUpdateGhostScoreInstructionDataDecoder: () => getUpdateGhostScoreInstructionDataDecoder,
  getUpdateGhostScoreInstructionDataCodec: () => getUpdateGhostScoreInstructionDataCodec,
  getUpdateGhostScoreInstruction: () => getUpdateGhostScoreInstruction,
  getUpdateGhostScoreDiscriminatorBytes: () => getUpdateGhostScoreDiscriminatorBytes,
  getUpdateDidDocumentInstructionDataEncoder: () => getUpdateDidDocumentInstructionDataEncoder,
  getUpdateDidDocumentInstructionDataDecoder: () => getUpdateDidDocumentInstructionDataDecoder,
  getUpdateDidDocumentInstructionDataCodec: () => getUpdateDidDocumentInstructionDataCodec,
  getUpdateDidDocumentInstructionAsync: () => getUpdateDidDocumentInstructionAsync,
  getUpdateDidDocumentInstruction: () => getUpdateDidDocumentInstruction,
  getUpdateDidDocumentDiscriminatorBytes: () => getUpdateDidDocumentDiscriminatorBytes,
  getUpdateCrosschainStatusInstructionDataEncoder: () => getUpdateCrosschainStatusInstructionDataEncoder,
  getUpdateCrosschainStatusInstructionDataDecoder: () => getUpdateCrosschainStatusInstructionDataDecoder,
  getUpdateCrosschainStatusInstructionDataCodec: () => getUpdateCrosschainStatusInstructionDataCodec,
  getUpdateCrosschainStatusInstruction: () => getUpdateCrosschainStatusInstruction,
  getUpdateCrosschainStatusDiscriminatorBytes: () => getUpdateCrosschainStatusDiscriminatorBytes,
  getUpdateAgentServiceInstructionDataEncoder: () => getUpdateAgentServiceInstructionDataEncoder,
  getUpdateAgentServiceInstructionDataDecoder: () => getUpdateAgentServiceInstructionDataDecoder,
  getUpdateAgentServiceInstructionDataCodec: () => getUpdateAgentServiceInstructionDataCodec,
  getUpdateAgentServiceInstructionAsync: () => getUpdateAgentServiceInstructionAsync,
  getUpdateAgentServiceInstruction: () => getUpdateAgentServiceInstruction,
  getUpdateAgentServiceDiscriminatorBytes: () => getUpdateAgentServiceDiscriminatorBytes,
  getUpdateAgentReputationInstructionDataEncoder: () => getUpdateAgentReputationInstructionDataEncoder,
  getUpdateAgentReputationInstructionDataDecoder: () => getUpdateAgentReputationInstructionDataDecoder,
  getUpdateAgentReputationInstructionDataCodec: () => getUpdateAgentReputationInstructionDataCodec,
  getUpdateAgentReputationInstructionAsync: () => getUpdateAgentReputationInstructionAsync,
  getUpdateAgentReputationInstruction: () => getUpdateAgentReputationInstruction,
  getUpdateAgentReputationDiscriminatorBytes: () => getUpdateAgentReputationDiscriminatorBytes,
  getUpdateAgentInstructionDataEncoder: () => getUpdateAgentInstructionDataEncoder,
  getUpdateAgentInstructionDataDecoder: () => getUpdateAgentInstructionDataDecoder,
  getUpdateAgentInstructionDataCodec: () => getUpdateAgentInstructionDataCodec,
  getUpdateAgentInstructionAsync: () => getUpdateAgentInstructionAsync,
  getUpdateAgentInstruction: () => getUpdateAgentInstruction,
  getUpdateAgentDiscriminatorBytes: () => getUpdateAgentDiscriminatorBytes,
  getUnstakeGhostInstructionDataEncoder: () => getUnstakeGhostInstructionDataEncoder,
  getUnstakeGhostInstructionDataDecoder: () => getUnstakeGhostInstructionDataDecoder,
  getUnstakeGhostInstructionDataCodec: () => getUnstakeGhostInstructionDataCodec,
  getUnstakeGhostInstructionAsync: () => getUnstakeGhostInstructionAsync,
  getUnstakeGhostInstruction: () => getUnstakeGhostInstruction,
  getUnstakeGhostDiscriminatorBytes: () => getUnstakeGhostDiscriminatorBytes,
  getUnlockMethodEncoder: () => getUnlockMethodEncoder,
  getUnlockMethodDecoder: () => getUnlockMethodDecoder,
  getUnlockMethodCodec: () => getUnlockMethodCodec,
  getTrendDirectionEncoder: () => getTrendDirectionEncoder,
  getTrendDirectionDecoder: () => getTrendDirectionDecoder,
  getTrendDirectionCodec: () => getTrendDirectionCodec,
  getTransactionTypeEncoder: () => getTransactionTypeEncoder,
  getTransactionTypeDecoder: () => getTransactionTypeDecoder,
  getTransactionTypeCodec: () => getTransactionTypeCodec,
  getTransactionStatusEncoder: () => getTransactionStatusEncoder,
  getTransactionStatusDecoder: () => getTransactionStatusDecoder,
  getTransactionStatusCodec: () => getTransactionStatusCodec,
  getTransactionPriorityEncoder: () => getTransactionPriorityEncoder,
  getTransactionPriorityDecoder: () => getTransactionPriorityDecoder,
  getTransactionPriorityCodec: () => getTransactionPriorityCodec,
  getTimeLockTypeEncoder: () => getTimeLockTypeEncoder,
  getTimeLockTypeDecoder: () => getTimeLockTypeDecoder,
  getTimeLockTypeCodec: () => getTimeLockTypeCodec,
  getTimeLockEncoder: () => getTimeLockEncoder,
  getTimeLockDecoder: () => getTimeLockDecoder,
  getTimeLockCodec: () => getTimeLockCodec,
  getTimeConstraintsEncoder: () => getTimeConstraintsEncoder,
  getTimeConstraintsDecoder: () => getTimeConstraintsDecoder,
  getTimeConstraintsCodec: () => getTimeConstraintsCodec,
  getTierUpdatedEventEncoder: () => getTierUpdatedEventEncoder,
  getTierUpdatedEventDecoder: () => getTierUpdatedEventDecoder,
  getTierUpdatedEventCodec: () => getTierUpdatedEventCodec,
  getTagScoreEncoder: () => getTagScoreEncoder,
  getTagScoreDecoder: () => getTagScoreDecoder,
  getTagScoreCodec: () => getTagScoreCodec,
  getTagDecayAppliedEventEncoder: () => getTagDecayAppliedEventEncoder,
  getTagDecayAppliedEventDecoder: () => getTagDecayAppliedEventDecoder,
  getTagDecayAppliedEventCodec: () => getTagDecayAppliedEventCodec,
  getSubmitServiceRatingInstructionDataEncoder: () => getSubmitServiceRatingInstructionDataEncoder,
  getSubmitServiceRatingInstructionDataDecoder: () => getSubmitServiceRatingInstructionDataDecoder,
  getSubmitServiceRatingInstructionDataCodec: () => getSubmitServiceRatingInstructionDataCodec,
  getSubmitServiceRatingInstructionAsync: () => getSubmitServiceRatingInstructionAsync,
  getSubmitServiceRatingInstruction: () => getSubmitServiceRatingInstruction,
  getSubmitServiceRatingDiscriminatorBytes: () => getSubmitServiceRatingDiscriminatorBytes,
  getSubmitDeliveryInstructionDataEncoder: () => getSubmitDeliveryInstructionDataEncoder,
  getSubmitDeliveryInstructionDataDecoder: () => getSubmitDeliveryInstructionDataDecoder,
  getSubmitDeliveryInstructionDataCodec: () => getSubmitDeliveryInstructionDataCodec,
  getSubmitDeliveryInstruction: () => getSubmitDeliveryInstruction,
  getSubmitDeliveryDiscriminatorBytes: () => getSubmitDeliveryDiscriminatorBytes,
  getSubmissionDetailsEncoder: () => getSubmissionDetailsEncoder,
  getSubmissionDetailsDecoder: () => getSubmissionDetailsDecoder,
  getSubmissionDetailsCodec: () => getSubmissionDetailsCodec,
  getStepUpTriggerEncoder: () => getStepUpTriggerEncoder,
  getStepUpTriggerDecoder: () => getStepUpTriggerDecoder,
  getStepUpTriggerCodec: () => getStepUpTriggerCodec,
  getStakingConfigSize: () => getStakingConfigSize,
  getStakingConfigEncoder: () => getStakingConfigEncoder,
  getStakingConfigDiscriminatorBytes: () => getStakingConfigDiscriminatorBytes,
  getStakingConfigDecoder: () => getStakingConfigDecoder,
  getStakingConfigCodec: () => getStakingConfigCodec,
  getStakingAccountSize: () => getStakingAccountSize,
  getStakingAccountEncoder: () => getStakingAccountEncoder,
  getStakingAccountDiscriminatorBytes: () => getStakingAccountDiscriminatorBytes,
  getStakingAccountDecoder: () => getStakingAccountDecoder,
  getStakingAccountCodec: () => getStakingAccountCodec,
  getStakeGhostInstructionDataEncoder: () => getStakeGhostInstructionDataEncoder,
  getStakeGhostInstructionDataDecoder: () => getStakeGhostInstructionDataDecoder,
  getStakeGhostInstructionDataCodec: () => getStakeGhostInstructionDataCodec,
  getStakeGhostInstructionAsync: () => getStakeGhostInstructionAsync,
  getStakeGhostInstruction: () => getStakeGhostInstruction,
  getStakeGhostDiscriminatorBytes: () => getStakeGhostDiscriminatorBytes,
  getSourceScoreEncoder: () => getSourceScoreEncoder,
  getSourceScoreDecoder: () => getSourceScoreDecoder,
  getSourceScoreCodec: () => getSourceScoreCodec,
  getSourceReputationUpdatedEventEncoder: () => getSourceReputationUpdatedEventEncoder,
  getSourceReputationUpdatedEventDecoder: () => getSourceReputationUpdatedEventDecoder,
  getSourceReputationUpdatedEventCodec: () => getSourceReputationUpdatedEventCodec,
  getSodConstraintTypeEncoder: () => getSodConstraintTypeEncoder,
  getSodConstraintTypeDecoder: () => getSodConstraintTypeDecoder,
  getSodConstraintTypeCodec: () => getSodConstraintTypeCodec,
  getSodConstraintEncoder: () => getSodConstraintEncoder,
  getSodConstraintDecoder: () => getSodConstraintDecoder,
  getSodConstraintCodec: () => getSodConstraintCodec,
  getSlashStakeInstructionDataEncoder: () => getSlashStakeInstructionDataEncoder,
  getSlashStakeInstructionDataDecoder: () => getSlashStakeInstructionDataDecoder,
  getSlashStakeInstructionDataCodec: () => getSlashStakeInstructionDataCodec,
  getSlashStakeInstructionAsync: () => getSlashStakeInstructionAsync,
  getSlashStakeInstruction: () => getSlashStakeInstruction,
  getSlashStakeDiscriminatorBytes: () => getSlashStakeDiscriminatorBytes,
  getSlashReasonEncoder: () => getSlashReasonEncoder,
  getSlashReasonDecoder: () => getSlashReasonDecoder,
  getSlashReasonCodec: () => getSlashReasonCodec,
  getSessionPoliciesEncoder: () => getSessionPoliciesEncoder,
  getSessionPoliciesDecoder: () => getSessionPoliciesDecoder,
  getSessionPoliciesCodec: () => getSessionPoliciesCodec,
  getSessionConstraintsEncoder: () => getSessionConstraintsEncoder,
  getSessionConstraintsDecoder: () => getSessionConstraintsDecoder,
  getSessionConstraintsCodec: () => getSessionConstraintsCodec,
  getServiceEndpointTypeEncoder: () => getServiceEndpointTypeEncoder,
  getServiceEndpointTypeDecoder: () => getServiceEndpointTypeDecoder,
  getServiceEndpointTypeCodec: () => getServiceEndpointTypeCodec,
  getServiceEndpointEncoder: () => getServiceEndpointEncoder,
  getServiceEndpointDecoder: () => getServiceEndpointDecoder,
  getServiceEndpointCodec: () => getServiceEndpointCodec,
  getSecurityPoliciesEncoder: () => getSecurityPoliciesEncoder,
  getSecurityPoliciesDecoder: () => getSecurityPoliciesDecoder,
  getSecurityPoliciesCodec: () => getSecurityPoliciesCodec,
  getSecurityEventTypeEncoder: () => getSecurityEventTypeEncoder,
  getSecurityEventTypeDecoder: () => getSecurityEventTypeDecoder,
  getSecurityEventTypeCodec: () => getSecurityEventTypeCodec,
  getScopeTypeEncoder: () => getScopeTypeEncoder,
  getScopeTypeDecoder: () => getScopeTypeDecoder,
  getScopeTypeCodec: () => getScopeTypeCodec,
  getScopeInheritanceEncoder: () => getScopeInheritanceEncoder,
  getScopeInheritanceDecoder: () => getScopeInheritanceDecoder,
  getScopeInheritanceCodec: () => getScopeInheritanceCodec,
  getScopeBoundariesEncoder: () => getScopeBoundariesEncoder,
  getScopeBoundariesDecoder: () => getScopeBoundariesDecoder,
  getScopeBoundariesCodec: () => getScopeBoundariesCodec,
  getRuleEffectEncoder: () => getRuleEffectEncoder,
  getRuleEffectDecoder: () => getRuleEffectDecoder,
  getRuleEffectCodec: () => getRuleEffectCodec,
  getRuleConditionEncoder: () => getRuleConditionEncoder,
  getRuleConditionDecoder: () => getRuleConditionDecoder,
  getRuleConditionCodec: () => getRuleConditionCodec,
  getRoleTypeEncoder: () => getRoleTypeEncoder,
  getRoleTypeDecoder: () => getRoleTypeDecoder,
  getRoleTypeCodec: () => getRoleTypeCodec,
  getRoleStatusEncoder: () => getRoleStatusEncoder,
  getRoleStatusDecoder: () => getRoleStatusDecoder,
  getRoleStatusCodec: () => getRoleStatusCodec,
  getRoleMetadataEncoder: () => getRoleMetadataEncoder,
  getRoleMetadataDecoder: () => getRoleMetadataDecoder,
  getRoleMetadataCodec: () => getRoleMetadataCodec,
  getRoleEncoder: () => getRoleEncoder,
  getRoleDecoder: () => getRoleDecoder,
  getRoleConstraintsEncoder: () => getRoleConstraintsEncoder,
  getRoleConstraintsDecoder: () => getRoleConstraintsDecoder,
  getRoleConstraintsCodec: () => getRoleConstraintsCodec,
  getRoleCodec: () => getRoleCodec,
  getRiskLevelEncoder: () => getRiskLevelEncoder,
  getRiskLevelDecoder: () => getRiskLevelDecoder,
  getRiskLevelCodec: () => getRiskLevelCodec,
  getRiskIndicatorEncoder: () => getRiskIndicatorEncoder,
  getRiskIndicatorDecoder: () => getRiskIndicatorDecoder,
  getRiskIndicatorCodec: () => getRiskIndicatorCodec,
  getRiskFactorEncoder: () => getRiskFactorEncoder,
  getRiskFactorDecoder: () => getRiskFactorDecoder,
  getRiskFactorCodec: () => getRiskFactorCodec,
  getRiskCategoryEncoder: () => getRiskCategoryEncoder,
  getRiskCategoryDecoder: () => getRiskCategoryDecoder,
  getRiskCategoryCodec: () => getRiskCategoryCodec,
  getRiskAssessmentEncoder: () => getRiskAssessmentEncoder,
  getRiskAssessmentDecoder: () => getRiskAssessmentDecoder,
  getRiskAssessmentCodec: () => getRiskAssessmentCodec,
  getRiskAcceptanceEncoder: () => getRiskAcceptanceEncoder,
  getRiskAcceptanceDecoder: () => getRiskAcceptanceDecoder,
  getRiskAcceptanceCodec: () => getRiskAcceptanceCodec,
  getRevokeCredentialInstructionDataEncoder: () => getRevokeCredentialInstructionDataEncoder,
  getRevokeCredentialInstructionDataDecoder: () => getRevokeCredentialInstructionDataDecoder,
  getRevokeCredentialInstructionDataCodec: () => getRevokeCredentialInstructionDataCodec,
  getRevokeCredentialInstruction: () => getRevokeCredentialInstruction,
  getRevokeCredentialDiscriminatorBytes: () => getRevokeCredentialDiscriminatorBytes,
  getRevokeAuthorizationInstructionDataEncoder: () => getRevokeAuthorizationInstructionDataEncoder,
  getRevokeAuthorizationInstructionDataDecoder: () => getRevokeAuthorizationInstructionDataDecoder,
  getRevokeAuthorizationInstructionDataCodec: () => getRevokeAuthorizationInstructionDataCodec,
  getRevokeAuthorizationInstruction: () => getRevokeAuthorizationInstruction,
  getRevokeAuthorizationDiscriminatorBytes: () => getRevokeAuthorizationDiscriminatorBytes,
  getReviewScheduleEncoder: () => getReviewScheduleEncoder,
  getReviewScheduleDecoder: () => getReviewScheduleDecoder,
  getReviewScheduleCodec: () => getReviewScheduleCodec,
  getResourceConstraintsEncoder: () => getResourceConstraintsEncoder,
  getResourceConstraintsDecoder: () => getResourceConstraintsDecoder,
  getResourceConstraintsCodec: () => getResourceConstraintsCodec,
  getResolveDidDocumentInstructionDataEncoder: () => getResolveDidDocumentInstructionDataEncoder,
  getResolveDidDocumentInstructionDataDecoder: () => getResolveDidDocumentInstructionDataDecoder,
  getResolveDidDocumentInstructionDataCodec: () => getResolveDidDocumentInstructionDataCodec,
  getResolveDidDocumentInstructionAsync: () => getResolveDidDocumentInstructionAsync,
  getResolveDidDocumentInstruction: () => getResolveDidDocumentInstruction,
  getResolveDidDocumentDiscriminatorBytes: () => getResolveDidDocumentDiscriminatorBytes,
  getResetReentrancyGuardInstructionDataEncoder: () => getResetReentrancyGuardInstructionDataEncoder,
  getResetReentrancyGuardInstructionDataDecoder: () => getResetReentrancyGuardInstructionDataDecoder,
  getResetReentrancyGuardInstructionDataCodec: () => getResetReentrancyGuardInstructionDataCodec,
  getResetReentrancyGuardInstructionAsync: () => getResetReentrancyGuardInstructionAsync,
  getResetReentrancyGuardInstruction: () => getResetReentrancyGuardInstruction,
  getResetReentrancyGuardDiscriminatorBytes: () => getResetReentrancyGuardDiscriminatorBytes,
  getReputationTagsUpdatedEventEncoder: () => getReputationTagsUpdatedEventEncoder,
  getReputationTagsUpdatedEventDecoder: () => getReputationTagsUpdatedEventDecoder,
  getReputationTagsUpdatedEventCodec: () => getReputationTagsUpdatedEventCodec,
  getReputationSourceTypeEncoder: () => getReputationSourceTypeEncoder,
  getReputationSourceTypeDecoder: () => getReputationSourceTypeDecoder,
  getReputationSourceTypeCodec: () => getReputationSourceTypeCodec,
  getReputationRatingSubmittedEventEncoder: () => getReputationRatingSubmittedEventEncoder,
  getReputationRatingSubmittedEventDecoder: () => getReputationRatingSubmittedEventDecoder,
  getReputationRatingSubmittedEventCodec: () => getReputationRatingSubmittedEventCodec,
  getReputationPaymentRecordedEventEncoder: () => getReputationPaymentRecordedEventEncoder,
  getReputationPaymentRecordedEventDecoder: () => getReputationPaymentRecordedEventDecoder,
  getReputationPaymentRecordedEventCodec: () => getReputationPaymentRecordedEventCodec,
  getReputationMetricsInitializedEventEncoder: () => getReputationMetricsInitializedEventEncoder,
  getReputationMetricsInitializedEventDecoder: () => getReputationMetricsInitializedEventDecoder,
  getReputationMetricsInitializedEventCodec: () => getReputationMetricsInitializedEventCodec,
  getReputationMetricsEncoder: () => getReputationMetricsEncoder,
  getReputationMetricsDiscriminatorBytes: () => getReputationMetricsDiscriminatorBytes,
  getReputationMetricsDecoder: () => getReputationMetricsDecoder,
  getReputationMetricsCodec: () => getReputationMetricsCodec,
  getReputationComponentEncoder: () => getReputationComponentEncoder,
  getReputationComponentDecoder: () => getReputationComponentDecoder,
  getReputationComponentCodec: () => getReputationComponentCodec,
  getReportingFrequencyEncoder: () => getReportingFrequencyEncoder,
  getReportingFrequencyDecoder: () => getReportingFrequencyDecoder,
  getReportingFrequencyCodec: () => getReportingFrequencyCodec,
  getReportTypeEncoder: () => getReportTypeEncoder,
  getReportTypeDecoder: () => getReportTypeDecoder,
  getReportTypeCodec: () => getReportTypeCodec,
  getReportSummaryEncoder: () => getReportSummaryEncoder,
  getReportSummaryDecoder: () => getReportSummaryDecoder,
  getReportSummaryCodec: () => getReportSummaryCodec,
  getReportStatusEncoder: () => getReportStatusEncoder,
  getReportStatusDecoder: () => getReportStatusDecoder,
  getReportStatusCodec: () => getReportStatusCodec,
  getReportEntryEncoder: () => getReportEntryEncoder,
  getReportEntryDecoder: () => getReportEntryDecoder,
  getReportEntryCodec: () => getReportEntryCodec,
  getReportDataEncoder: () => getReportDataEncoder,
  getReportDataDecoder: () => getReportDataDecoder,
  getReportDataCodec: () => getReportDataCodec,
  getRegisterGhostMetadataInstructionDataEncoder: () => getRegisterGhostMetadataInstructionDataEncoder,
  getRegisterGhostMetadataInstructionDataDecoder: () => getRegisterGhostMetadataInstructionDataDecoder,
  getRegisterGhostMetadataInstructionDataCodec: () => getRegisterGhostMetadataInstructionDataCodec,
  getRegisterGhostMetadataInstruction: () => getRegisterGhostMetadataInstruction,
  getRegisterGhostMetadataDiscriminatorBytes: () => getRegisterGhostMetadataDiscriminatorBytes,
  getRegisterAgentInstructionDataEncoder: () => getRegisterAgentInstructionDataEncoder,
  getRegisterAgentInstructionDataDecoder: () => getRegisterAgentInstructionDataDecoder,
  getRegisterAgentInstructionDataCodec: () => getRegisterAgentInstructionDataCodec,
  getRegisterAgentInstructionAsync: () => getRegisterAgentInstructionAsync,
  getRegisterAgentInstruction: () => getRegisterAgentInstruction,
  getRegisterAgentDiscriminatorBytes: () => getRegisterAgentDiscriminatorBytes,
  getRegisterAgentCompressedInstructionDataEncoder: () => getRegisterAgentCompressedInstructionDataEncoder,
  getRegisterAgentCompressedInstructionDataDecoder: () => getRegisterAgentCompressedInstructionDataDecoder,
  getRegisterAgentCompressedInstructionDataCodec: () => getRegisterAgentCompressedInstructionDataCodec,
  getRegisterAgentCompressedInstructionAsync: () => getRegisterAgentCompressedInstructionAsync,
  getRegisterAgentCompressedInstruction: () => getRegisterAgentCompressedInstruction,
  getRegisterAgentCompressedDiscriminatorBytes: () => getRegisterAgentCompressedDiscriminatorBytes,
  getReentrancyStateEncoder: () => getReentrancyStateEncoder,
  getReentrancyStateDecoder: () => getReentrancyStateDecoder,
  getReentrancyStateCodec: () => getReentrancyStateCodec,
  getReentrancyGuardSize: () => getReentrancyGuardSize,
  getReentrancyGuardEncoder: () => getReentrancyGuardEncoder,
  getReentrancyGuardDiscriminatorBytes: () => getReentrancyGuardDiscriminatorBytes,
  getReentrancyGuardDecoder: () => getReentrancyGuardDecoder,
  getReentrancyGuardCodec: () => getReentrancyGuardCodec,
  getRecordPayaiPaymentInstructionDataEncoder: () => getRecordPayaiPaymentInstructionDataEncoder,
  getRecordPayaiPaymentInstructionDataDecoder: () => getRecordPayaiPaymentInstructionDataDecoder,
  getRecordPayaiPaymentInstructionDataCodec: () => getRecordPayaiPaymentInstructionDataCodec,
  getRecordPayaiPaymentInstructionAsync: () => getRecordPayaiPaymentInstructionAsync,
  getRecordPayaiPaymentInstruction: () => getRecordPayaiPaymentInstruction,
  getRecordPayaiPaymentDiscriminatorBytes: () => getRecordPayaiPaymentDiscriminatorBytes,
  getRbacConfigInitializedEventEncoder: () => getRbacConfigInitializedEventEncoder,
  getRbacConfigInitializedEventDecoder: () => getRbacConfigInitializedEventDecoder,
  getRbacConfigInitializedEventCodec: () => getRbacConfigInitializedEventCodec,
  getRbacConfigEncoder: () => getRbacConfigEncoder,
  getRbacConfigDiscriminatorBytes: () => getRbacConfigDiscriminatorBytes,
  getRbacConfigDecoder: () => getRbacConfigDecoder,
  getRbacConfigCodec: () => getRbacConfigCodec,
  getQuorumRequirementsEncoder: () => getQuorumRequirementsEncoder,
  getQuorumRequirementsDecoder: () => getQuorumRequirementsDecoder,
  getQuorumRequirementsCodec: () => getQuorumRequirementsCodec,
  getQuorumMethodEncoder: () => getQuorumMethodEncoder,
  getQuorumMethodDecoder: () => getQuorumMethodDecoder,
  getQuorumMethodCodec: () => getQuorumMethodCodec,
  getProtocolConfigUpdatedEventEncoder: () => getProtocolConfigUpdatedEventEncoder,
  getProtocolConfigUpdatedEventDecoder: () => getProtocolConfigUpdatedEventDecoder,
  getProtocolConfigUpdatedEventCodec: () => getProtocolConfigUpdatedEventCodec,
  getProtocolConfigSize: () => getProtocolConfigSize,
  getProtocolConfigEncoder: () => getProtocolConfigEncoder,
  getProtocolConfigDiscriminatorBytes: () => getProtocolConfigDiscriminatorBytes,
  getProtocolConfigDecoder: () => getProtocolConfigDecoder,
  getProtocolConfigCodec: () => getProtocolConfigCodec,
  getProposalTypeEncoder: () => getProposalTypeEncoder,
  getProposalTypeDecoder: () => getProposalTypeDecoder,
  getProposalTypeCodec: () => getProposalTypeCodec,
  getProposalStatusEncoder: () => getProposalStatusEncoder,
  getProposalStatusDecoder: () => getProposalStatusDecoder,
  getProposalStatusCodec: () => getProposalStatusCodec,
  getProposalMetadataEncoder: () => getProposalMetadataEncoder,
  getProposalMetadataDecoder: () => getProposalMetadataDecoder,
  getProposalMetadataCodec: () => getProposalMetadataCodec,
  getProposalInstructionEncoder: () => getProposalInstructionEncoder,
  getProposalInstructionDecoder: () => getProposalInstructionDecoder,
  getProposalInstructionCodec: () => getProposalInstructionCodec,
  getProposalAccountEncoder: () => getProposalAccountEncoder,
  getProposalAccountDecoder: () => getProposalAccountDecoder,
  getProposalAccountCodec: () => getProposalAccountCodec,
  getPricingModelEncoder: () => getPricingModelEncoder,
  getPricingModelDecoder: () => getPricingModelDecoder,
  getPricingModelCodec: () => getPricingModelCodec,
  getPolicyTypeEncoder: () => getPolicyTypeEncoder,
  getPolicyTypeDecoder: () => getPolicyTypeDecoder,
  getPolicyTypeCodec: () => getPolicyTypeCodec,
  getPolicyStatusEncoder: () => getPolicyStatusEncoder,
  getPolicyStatusDecoder: () => getPolicyStatusDecoder,
  getPolicyStatusCodec: () => getPolicyStatusCodec,
  getPolicyScopeEncoder: () => getPolicyScopeEncoder,
  getPolicyScopeDecoder: () => getPolicyScopeDecoder,
  getPolicyScopeCodec: () => getPolicyScopeCodec,
  getPolicyRuleEncoder: () => getPolicyRuleEncoder,
  getPolicyRuleDecoder: () => getPolicyRuleDecoder,
  getPolicyRuleCodec: () => getPolicyRuleCodec,
  getPolicyMetadataEncoder: () => getPolicyMetadataEncoder,
  getPolicyMetadataDecoder: () => getPolicyMetadataDecoder,
  getPolicyMetadataCodec: () => getPolicyMetadataCodec,
  getPermissionScopeEncoder: () => getPermissionScopeEncoder,
  getPermissionScopeDecoder: () => getPermissionScopeDecoder,
  getPermissionScopeCodec: () => getPermissionScopeCodec,
  getPermissionMetadataEncoder: () => getPermissionMetadataEncoder,
  getPermissionMetadataDecoder: () => getPermissionMetadataDecoder,
  getPermissionMetadataCodec: () => getPermissionMetadataCodec,
  getPermissionEncoder: () => getPermissionEncoder,
  getPermissionDecoder: () => getPermissionDecoder,
  getPermissionConstraintTypeEncoder: () => getPermissionConstraintTypeEncoder,
  getPermissionConstraintTypeDecoder: () => getPermissionConstraintTypeDecoder,
  getPermissionConstraintTypeCodec: () => getPermissionConstraintTypeCodec,
  getPermissionConstraintEncoder: () => getPermissionConstraintEncoder,
  getPermissionConstraintDecoder: () => getPermissionConstraintDecoder,
  getPermissionConstraintCodec: () => getPermissionConstraintCodec,
  getPermissionCodec: () => getPermissionCodec,
  getPendingTransactionEncoder: () => getPendingTransactionEncoder,
  getPendingTransactionDecoder: () => getPendingTransactionDecoder,
  getPendingTransactionCodec: () => getPendingTransactionCodec,
  getPasswordPoliciesEncoder: () => getPasswordPoliciesEncoder,
  getPasswordPoliciesDecoder: () => getPasswordPoliciesDecoder,
  getPasswordPoliciesCodec: () => getPasswordPoliciesCodec,
  getNotificationTimingEncoder: () => getNotificationTimingEncoder,
  getNotificationTimingDecoder: () => getNotificationTimingDecoder,
  getNotificationTimingCodec: () => getNotificationTimingCodec,
  getNotificationTargetTypeEncoder: () => getNotificationTargetTypeEncoder,
  getNotificationTargetTypeDecoder: () => getNotificationTargetTypeDecoder,
  getNotificationTargetTypeCodec: () => getNotificationTargetTypeCodec,
  getNotificationTargetEncoder: () => getNotificationTargetEncoder,
  getNotificationTargetDecoder: () => getNotificationTargetDecoder,
  getNotificationTargetCodec: () => getNotificationTargetCodec,
  getNotificationRequirementEncoder: () => getNotificationRequirementEncoder,
  getNotificationRequirementDecoder: () => getNotificationRequirementDecoder,
  getNotificationRequirementCodec: () => getNotificationRequirementCodec,
  getNotificationPriorityEncoder: () => getNotificationPriorityEncoder,
  getNotificationPriorityDecoder: () => getNotificationPriorityDecoder,
  getNotificationPriorityCodec: () => getNotificationPriorityCodec,
  getNotificationMethodEncoder: () => getNotificationMethodEncoder,
  getNotificationMethodDecoder: () => getNotificationMethodDecoder,
  getNotificationMethodCodec: () => getNotificationMethodCodec,
  getNetworkSecurityPoliciesEncoder: () => getNetworkSecurityPoliciesEncoder,
  getNetworkSecurityPoliciesDecoder: () => getNetworkSecurityPoliciesDecoder,
  getNetworkSecurityPoliciesCodec: () => getNetworkSecurityPoliciesCodec,
  getMultisigTypeEncoder: () => getMultisigTypeEncoder,
  getMultisigTypeDecoder: () => getMultisigTypeDecoder,
  getMultisigTypeConfigEncoder: () => getMultisigTypeConfigEncoder,
  getMultisigTypeConfigDecoder: () => getMultisigTypeConfigDecoder,
  getMultisigTypeConfigCodec: () => getMultisigTypeConfigCodec,
  getMultisigTypeCodec: () => getMultisigTypeCodec,
  getMultisigSignatureEncoder: () => getMultisigSignatureEncoder,
  getMultisigSignatureDecoder: () => getMultisigSignatureDecoder,
  getMultisigSignatureCodec: () => getMultisigSignatureCodec,
  getMultisigEncoder: () => getMultisigEncoder,
  getMultisigDiscriminatorBytes: () => getMultisigDiscriminatorBytes,
  getMultisigDecoder: () => getMultisigDecoder,
  getMultisigCreatedEventEncoder: () => getMultisigCreatedEventEncoder,
  getMultisigCreatedEventDecoder: () => getMultisigCreatedEventDecoder,
  getMultisigCreatedEventCodec: () => getMultisigCreatedEventCodec,
  getMultisigConfigEncoder: () => getMultisigConfigEncoder,
  getMultisigConfigDecoder: () => getMultisigConfigDecoder,
  getMultisigConfigCodec: () => getMultisigConfigCodec,
  getMultisigCodec: () => getMultisigCodec,
  getManageAgentStatusInstructionDataEncoder: () => getManageAgentStatusInstructionDataEncoder,
  getManageAgentStatusInstructionDataDecoder: () => getManageAgentStatusInstructionDataDecoder,
  getManageAgentStatusInstructionDataCodec: () => getManageAgentStatusInstructionDataCodec,
  getManageAgentStatusInstructionAsync: () => getManageAgentStatusInstructionAsync,
  getManageAgentStatusInstruction: () => getManageAgentStatusInstruction,
  getManageAgentStatusDiscriminatorBytes: () => getManageAgentStatusDiscriminatorBytes,
  getLongitudeRangeEncoder: () => getLongitudeRangeEncoder,
  getLongitudeRangeDecoder: () => getLongitudeRangeDecoder,
  getLongitudeRangeCodec: () => getLongitudeRangeCodec,
  getLocationConstraintsEncoder: () => getLocationConstraintsEncoder,
  getLocationConstraintsDecoder: () => getLocationConstraintsDecoder,
  getLocationConstraintsCodec: () => getLocationConstraintsCodec,
  getLinkExternalIdInstructionDataEncoder: () => getLinkExternalIdInstructionDataEncoder,
  getLinkExternalIdInstructionDataDecoder: () => getLinkExternalIdInstructionDataDecoder,
  getLinkExternalIdInstructionDataCodec: () => getLinkExternalIdInstructionDataCodec,
  getLinkExternalIdInstructionAsync: () => getLinkExternalIdInstructionAsync,
  getLinkExternalIdInstruction: () => getLinkExternalIdInstruction,
  getLinkExternalIdDiscriminatorBytes: () => getLinkExternalIdDiscriminatorBytes,
  getLatitudeRangeEncoder: () => getLatitudeRangeEncoder,
  getLatitudeRangeDecoder: () => getLatitudeRangeDecoder,
  getLatitudeRangeCodec: () => getLatitudeRangeCodec,
  getIssueCredentialInstructionDataEncoder: () => getIssueCredentialInstructionDataEncoder,
  getIssueCredentialInstructionDataDecoder: () => getIssueCredentialInstructionDataDecoder,
  getIssueCredentialInstructionDataCodec: () => getIssueCredentialInstructionDataCodec,
  getIssueCredentialInstructionAsync: () => getIssueCredentialInstructionAsync,
  getIssueCredentialInstruction: () => getIssueCredentialInstruction,
  getIssueCredentialDiscriminatorBytes: () => getIssueCredentialDiscriminatorBytes,
  getInitializeStakingConfigInstructionDataEncoder: () => getInitializeStakingConfigInstructionDataEncoder,
  getInitializeStakingConfigInstructionDataDecoder: () => getInitializeStakingConfigInstructionDataDecoder,
  getInitializeStakingConfigInstructionDataCodec: () => getInitializeStakingConfigInstructionDataCodec,
  getInitializeStakingConfigInstructionAsync: () => getInitializeStakingConfigInstructionAsync,
  getInitializeStakingConfigInstruction: () => getInitializeStakingConfigInstruction,
  getInitializeStakingConfigDiscriminatorBytes: () => getInitializeStakingConfigDiscriminatorBytes,
  getInitializeReputationMetricsInstructionDataEncoder: () => getInitializeReputationMetricsInstructionDataEncoder,
  getInitializeReputationMetricsInstructionDataDecoder: () => getInitializeReputationMetricsInstructionDataDecoder,
  getInitializeReputationMetricsInstructionDataCodec: () => getInitializeReputationMetricsInstructionDataCodec,
  getInitializeReputationMetricsInstructionAsync: () => getInitializeReputationMetricsInstructionAsync,
  getInitializeReputationMetricsInstruction: () => getInitializeReputationMetricsInstruction,
  getInitializeReputationMetricsDiscriminatorBytes: () => getInitializeReputationMetricsDiscriminatorBytes,
  getInitializeRbacConfigInstructionDataEncoder: () => getInitializeRbacConfigInstructionDataEncoder,
  getInitializeRbacConfigInstructionDataDecoder: () => getInitializeRbacConfigInstructionDataDecoder,
  getInitializeRbacConfigInstructionDataCodec: () => getInitializeRbacConfigInstructionDataCodec,
  getInitializeRbacConfigInstructionAsync: () => getInitializeRbacConfigInstructionAsync,
  getInitializeRbacConfigInstruction: () => getInitializeRbacConfigInstruction,
  getInitializeRbacConfigDiscriminatorBytes: () => getInitializeRbacConfigDiscriminatorBytes,
  getInitializeProtocolConfigInstructionDataEncoder: () => getInitializeProtocolConfigInstructionDataEncoder,
  getInitializeProtocolConfigInstructionDataDecoder: () => getInitializeProtocolConfigInstructionDataDecoder,
  getInitializeProtocolConfigInstructionDataCodec: () => getInitializeProtocolConfigInstructionDataCodec,
  getInitializeProtocolConfigInstructionAsync: () => getInitializeProtocolConfigInstructionAsync,
  getInitializeProtocolConfigInstruction: () => getInitializeProtocolConfigInstruction,
  getInitializeProtocolConfigDiscriminatorBytes: () => getInitializeProtocolConfigDiscriminatorBytes,
  getInitializeGovernanceProposalInstructionDataEncoder: () => getInitializeGovernanceProposalInstructionDataEncoder,
  getInitializeGovernanceProposalInstructionDataDecoder: () => getInitializeGovernanceProposalInstructionDataDecoder,
  getInitializeGovernanceProposalInstructionDataCodec: () => getInitializeGovernanceProposalInstructionDataCodec,
  getInitializeGovernanceProposalInstructionAsync: () => getInitializeGovernanceProposalInstructionAsync,
  getInitializeGovernanceProposalInstruction: () => getInitializeGovernanceProposalInstruction,
  getInitializeGovernanceProposalDiscriminatorBytes: () => getInitializeGovernanceProposalDiscriminatorBytes,
  getInitializeAuditTrailInstructionDataEncoder: () => getInitializeAuditTrailInstructionDataEncoder,
  getInitializeAuditTrailInstructionDataDecoder: () => getInitializeAuditTrailInstructionDataDecoder,
  getInitializeAuditTrailInstructionDataCodec: () => getInitializeAuditTrailInstructionDataCodec,
  getInitializeAuditTrailInstructionAsync: () => getInitializeAuditTrailInstructionAsync,
  getInitializeAuditTrailInstruction: () => getInitializeAuditTrailInstruction,
  getInitializeAuditTrailDiscriminatorBytes: () => getInitializeAuditTrailDiscriminatorBytes,
  getInitReentrancyGuardInstructionDataEncoder: () => getInitReentrancyGuardInstructionDataEncoder,
  getInitReentrancyGuardInstructionDataDecoder: () => getInitReentrancyGuardInstructionDataDecoder,
  getInitReentrancyGuardInstructionDataCodec: () => getInitReentrancyGuardInstructionDataCodec,
  getInitReentrancyGuardInstructionAsync: () => getInitReentrancyGuardInstructionAsync,
  getInitReentrancyGuardInstruction: () => getInitReentrancyGuardInstruction,
  getInitReentrancyGuardDiscriminatorBytes: () => getInitReentrancyGuardDiscriminatorBytes,
  getIncidentResponsePoliciesEncoder: () => getIncidentResponsePoliciesEncoder,
  getIncidentResponsePoliciesDecoder: () => getIncidentResponsePoliciesDecoder,
  getIncidentResponsePoliciesCodec: () => getIncidentResponsePoliciesCodec,
  getHierarchicalBoundaryEncoder: () => getHierarchicalBoundaryEncoder,
  getHierarchicalBoundaryDecoder: () => getHierarchicalBoundaryDecoder,
  getHierarchicalBoundaryCodec: () => getHierarchicalBoundaryCodec,
  getGovernanceProposalEncoder: () => getGovernanceProposalEncoder,
  getGovernanceProposalDiscriminatorBytes: () => getGovernanceProposalDiscriminatorBytes,
  getGovernanceProposalDecoder: () => getGovernanceProposalDecoder,
  getGovernanceProposalCreatedEventEncoder: () => getGovernanceProposalCreatedEventEncoder,
  getGovernanceProposalCreatedEventDecoder: () => getGovernanceProposalCreatedEventDecoder,
  getGovernanceProposalCreatedEventCodec: () => getGovernanceProposalCreatedEventCodec,
  getGovernanceProposalCodec: () => getGovernanceProposalCodec,
  getGhostspeakMarketplaceErrorMessage: () => getGhostspeakMarketplaceErrorMessage,
  getGhostUnstakedEventEncoder: () => getGhostUnstakedEventEncoder,
  getGhostUnstakedEventDecoder: () => getGhostUnstakedEventDecoder,
  getGhostUnstakedEventCodec: () => getGhostUnstakedEventCodec,
  getGhostStakedEventEncoder: () => getGhostStakedEventEncoder,
  getGhostStakedEventDecoder: () => getGhostStakedEventDecoder,
  getGhostStakedEventCodec: () => getGhostStakedEventCodec,
  getGhostSlashedEventEncoder: () => getGhostSlashedEventEncoder,
  getGhostSlashedEventDecoder: () => getGhostSlashedEventDecoder,
  getGhostSlashedEventCodec: () => getGhostSlashedEventCodec,
  getGhostProtectEscrowEncoder: () => getGhostProtectEscrowEncoder,
  getGhostProtectEscrowDiscriminatorBytes: () => getGhostProtectEscrowDiscriminatorBytes,
  getGhostProtectEscrowDecoder: () => getGhostProtectEscrowDecoder,
  getGhostProtectEscrowCodec: () => getGhostProtectEscrowCodec,
  getGeographicRegionEncoder: () => getGeographicRegionEncoder,
  getGeographicRegionDecoder: () => getGeographicRegionDecoder,
  getGeographicRegionCodec: () => getGeographicRegionCodec,
  getGenerateComplianceReportInstructionDataEncoder: () => getGenerateComplianceReportInstructionDataEncoder,
  getGenerateComplianceReportInstructionDataDecoder: () => getGenerateComplianceReportInstructionDataDecoder,
  getGenerateComplianceReportInstructionDataCodec: () => getGenerateComplianceReportInstructionDataCodec,
  getGenerateComplianceReportInstructionAsync: () => getGenerateComplianceReportInstructionAsync,
  getGenerateComplianceReportInstruction: () => getGenerateComplianceReportInstruction,
  getGenerateComplianceReportDiscriminatorBytes: () => getGenerateComplianceReportDiscriminatorBytes,
  getFileDisputeInstructionDataEncoder: () => getFileDisputeInstructionDataEncoder,
  getFileDisputeInstructionDataDecoder: () => getFileDisputeInstructionDataDecoder,
  getFileDisputeInstructionDataCodec: () => getFileDisputeInstructionDataCodec,
  getFileDisputeInstruction: () => getFileDisputeInstruction,
  getFileDisputeDiscriminatorBytes: () => getFileDisputeDiscriminatorBytes,
  getExternalIdentifierEncoder: () => getExternalIdentifierEncoder,
  getExternalIdentifierDecoder: () => getExternalIdentifierDecoder,
  getExternalIdentifierCodec: () => getExternalIdentifierCodec,
  getExternalIdMappingEncoder: () => getExternalIdMappingEncoder,
  getExternalIdMappingDiscriminatorBytes: () => getExternalIdMappingDiscriminatorBytes,
  getExternalIdMappingDecoder: () => getExternalIdMappingDecoder,
  getExternalIdMappingCodec: () => getExternalIdMappingCodec,
  getExecutionParamsEncoder: () => getExecutionParamsEncoder,
  getExecutionParamsDecoder: () => getExecutionParamsDecoder,
  getExecutionParamsCodec: () => getExecutionParamsCodec,
  getExecutionConditionEncoder: () => getExecutionConditionEncoder,
  getExecutionConditionDecoder: () => getExecutionConditionDecoder,
  getExecutionConditionCodec: () => getExecutionConditionCodec,
  getEscrowStatusEncoder: () => getEscrowStatusEncoder,
  getEscrowStatusDecoder: () => getEscrowStatusDecoder,
  getEscrowStatusCodec: () => getEscrowStatusCodec,
  getEscrowCreatedEventEncoder: () => getEscrowCreatedEventEncoder,
  getEscrowCreatedEventDecoder: () => getEscrowCreatedEventDecoder,
  getEscrowCreatedEventCodec: () => getEscrowCreatedEventCodec,
  getEscrowCompletedEventEncoder: () => getEscrowCompletedEventEncoder,
  getEscrowCompletedEventDecoder: () => getEscrowCompletedEventDecoder,
  getEscrowCompletedEventCodec: () => getEscrowCompletedEventCodec,
  getEnforcementLevelEncoder: () => getEnforcementLevelEncoder,
  getEnforcementLevelDecoder: () => getEnforcementLevelDecoder,
  getEnforcementLevelCodec: () => getEnforcementLevelCodec,
  getEnableProtocolFeesInstructionDataEncoder: () => getEnableProtocolFeesInstructionDataEncoder,
  getEnableProtocolFeesInstructionDataDecoder: () => getEnableProtocolFeesInstructionDataDecoder,
  getEnableProtocolFeesInstructionDataCodec: () => getEnableProtocolFeesInstructionDataCodec,
  getEnableProtocolFeesInstructionAsync: () => getEnableProtocolFeesInstructionAsync,
  getEnableProtocolFeesInstruction: () => getEnableProtocolFeesInstruction,
  getEnableProtocolFeesDiscriminatorBytes: () => getEnableProtocolFeesDiscriminatorBytes,
  getEmergencyConfigEncoder: () => getEmergencyConfigEncoder,
  getEmergencyConfigDecoder: () => getEmergencyConfigDecoder,
  getEmergencyConfigCodec: () => getEmergencyConfigCodec,
  getEmergencyAccessConfigEncoder: () => getEmergencyAccessConfigEncoder,
  getEmergencyAccessConfigDecoder: () => getEmergencyAccessConfigDecoder,
  getEmergencyAccessConfigCodec: () => getEmergencyAccessConfigCodec,
  getDisputeResolvedEventEncoder: () => getDisputeResolvedEventEncoder,
  getDisputeResolvedEventDecoder: () => getDisputeResolvedEventDecoder,
  getDisputeResolvedEventCodec: () => getDisputeResolvedEventCodec,
  getDisputeFiledEventEncoder: () => getDisputeFiledEventEncoder,
  getDisputeFiledEventDecoder: () => getDisputeFiledEventDecoder,
  getDisputeFiledEventCodec: () => getDisputeFiledEventCodec,
  getDidDocumentEncoder: () => getDidDocumentEncoder,
  getDidDocumentDiscriminatorBytes: () => getDidDocumentDiscriminatorBytes,
  getDidDocumentDecoder: () => getDidDocumentDecoder,
  getDidDocumentCodec: () => getDidDocumentCodec,
  getDeliverySubmittedEventEncoder: () => getDeliverySubmittedEventEncoder,
  getDeliverySubmittedEventDecoder: () => getDeliverySubmittedEventDecoder,
  getDeliverySubmittedEventCodec: () => getDeliverySubmittedEventCodec,
  getDelegationScopeEncoder: () => getDelegationScopeEncoder,
  getDelegationScopeDecoder: () => getDelegationScopeDecoder,
  getDelegationScopeCodec: () => getDelegationScopeCodec,
  getDelegationInfoEncoder: () => getDelegationInfoEncoder,
  getDelegationInfoDecoder: () => getDelegationInfoDecoder,
  getDelegationInfoCodec: () => getDelegationInfoCodec,
  getDegradationHandlingEncoder: () => getDegradationHandlingEncoder,
  getDegradationHandlingDecoder: () => getDegradationHandlingDecoder,
  getDegradationHandlingCodec: () => getDegradationHandlingCodec,
  getDeactivateDidDocumentInstructionDataEncoder: () => getDeactivateDidDocumentInstructionDataEncoder,
  getDeactivateDidDocumentInstructionDataDecoder: () => getDeactivateDidDocumentInstructionDataDecoder,
  getDeactivateDidDocumentInstructionDataCodec: () => getDeactivateDidDocumentInstructionDataCodec,
  getDeactivateDidDocumentInstructionAsync: () => getDeactivateDidDocumentInstructionAsync,
  getDeactivateDidDocumentInstruction: () => getDeactivateDidDocumentInstruction,
  getDeactivateDidDocumentDiscriminatorBytes: () => getDeactivateDidDocumentDiscriminatorBytes,
  getDeactivateCredentialTypeInstructionDataEncoder: () => getDeactivateCredentialTypeInstructionDataEncoder,
  getDeactivateCredentialTypeInstructionDataDecoder: () => getDeactivateCredentialTypeInstructionDataDecoder,
  getDeactivateCredentialTypeInstructionDataCodec: () => getDeactivateCredentialTypeInstructionDataCodec,
  getDeactivateCredentialTypeInstruction: () => getDeactivateCredentialTypeInstruction,
  getDeactivateCredentialTypeDiscriminatorBytes: () => getDeactivateCredentialTypeDiscriminatorBytes,
  getDeactivateCredentialTemplateInstructionDataEncoder: () => getDeactivateCredentialTemplateInstructionDataEncoder,
  getDeactivateCredentialTemplateInstructionDataDecoder: () => getDeactivateCredentialTemplateInstructionDataDecoder,
  getDeactivateCredentialTemplateInstructionDataCodec: () => getDeactivateCredentialTemplateInstructionDataCodec,
  getDeactivateCredentialTemplateInstruction: () => getDeactivateCredentialTemplateInstruction,
  getDeactivateCredentialTemplateDiscriminatorBytes: () => getDeactivateCredentialTemplateDiscriminatorBytes,
  getDeactivateAgentInstructionDataEncoder: () => getDeactivateAgentInstructionDataEncoder,
  getDeactivateAgentInstructionDataDecoder: () => getDeactivateAgentInstructionDataDecoder,
  getDeactivateAgentInstructionDataCodec: () => getDeactivateAgentInstructionDataCodec,
  getDeactivateAgentInstructionAsync: () => getDeactivateAgentInstructionAsync,
  getDeactivateAgentInstruction: () => getDeactivateAgentInstruction,
  getDeactivateAgentDiscriminatorBytes: () => getDeactivateAgentDiscriminatorBytes,
  getDataProtectionPoliciesEncoder: () => getDataProtectionPoliciesEncoder,
  getDataProtectionPoliciesDecoder: () => getDataProtectionPoliciesDecoder,
  getDataProtectionPoliciesCodec: () => getDataProtectionPoliciesCodec,
  getDataAccessLevelEncoder: () => getDataAccessLevelEncoder,
  getDataAccessLevelDecoder: () => getDataAccessLevelDecoder,
  getDataAccessLevelCodec: () => getDataAccessLevelCodec,
  getCrossChainStatusEncoder: () => getCrossChainStatusEncoder,
  getCrossChainStatusDecoder: () => getCrossChainStatusDecoder,
  getCrossChainStatusCodec: () => getCrossChainStatusCodec,
  getCredentialTypeEncoder: () => getCredentialTypeEncoder,
  getCredentialTypeDiscriminatorBytes: () => getCredentialTypeDiscriminatorBytes,
  getCredentialTypeDecoder: () => getCredentialTypeDecoder,
  getCredentialTypeCodec: () => getCredentialTypeCodec,
  getCredentialTemplateEncoder: () => getCredentialTemplateEncoder,
  getCredentialTemplateDiscriminatorBytes: () => getCredentialTemplateDiscriminatorBytes,
  getCredentialTemplateDecoder: () => getCredentialTemplateDecoder,
  getCredentialTemplateCodec: () => getCredentialTemplateCodec,
  getCredentialStatusEncoder: () => getCredentialStatusEncoder,
  getCredentialStatusDecoder: () => getCredentialStatusDecoder,
  getCredentialStatusCodec: () => getCredentialStatusCodec,
  getCredentialKindEncoder: () => getCredentialKindEncoder,
  getCredentialKindDecoder: () => getCredentialKindDecoder,
  getCredentialKindCodec: () => getCredentialKindCodec,
  getCredentialEncoder: () => getCredentialEncoder,
  getCredentialDiscriminatorBytes: () => getCredentialDiscriminatorBytes,
  getCredentialDecoder: () => getCredentialDecoder,
  getCredentialCodec: () => getCredentialCodec,
  getCreateMultisigInstructionDataEncoder: () => getCreateMultisigInstructionDataEncoder,
  getCreateMultisigInstructionDataDecoder: () => getCreateMultisigInstructionDataDecoder,
  getCreateMultisigInstructionDataCodec: () => getCreateMultisigInstructionDataCodec,
  getCreateMultisigInstructionAsync: () => getCreateMultisigInstructionAsync,
  getCreateMultisigInstruction: () => getCreateMultisigInstruction,
  getCreateMultisigDiscriminatorBytes: () => getCreateMultisigDiscriminatorBytes,
  getCreateEscrowInstructionDataEncoder: () => getCreateEscrowInstructionDataEncoder,
  getCreateEscrowInstructionDataDecoder: () => getCreateEscrowInstructionDataDecoder,
  getCreateEscrowInstructionDataCodec: () => getCreateEscrowInstructionDataCodec,
  getCreateEscrowInstructionAsync: () => getCreateEscrowInstructionAsync,
  getCreateEscrowInstruction: () => getCreateEscrowInstruction,
  getCreateEscrowDiscriminatorBytes: () => getCreateEscrowDiscriminatorBytes,
  getCreateDidDocumentInstructionDataEncoder: () => getCreateDidDocumentInstructionDataEncoder,
  getCreateDidDocumentInstructionDataDecoder: () => getCreateDidDocumentInstructionDataDecoder,
  getCreateDidDocumentInstructionDataCodec: () => getCreateDidDocumentInstructionDataCodec,
  getCreateDidDocumentInstructionAsync: () => getCreateDidDocumentInstructionAsync,
  getCreateDidDocumentInstruction: () => getCreateDidDocumentInstruction,
  getCreateDidDocumentDiscriminatorBytes: () => getCreateDidDocumentDiscriminatorBytes,
  getCreateCredentialTypeInstructionDataEncoder: () => getCreateCredentialTypeInstructionDataEncoder,
  getCreateCredentialTypeInstructionDataDecoder: () => getCreateCredentialTypeInstructionDataDecoder,
  getCreateCredentialTypeInstructionDataCodec: () => getCreateCredentialTypeInstructionDataCodec,
  getCreateCredentialTypeInstructionAsync: () => getCreateCredentialTypeInstructionAsync,
  getCreateCredentialTypeInstruction: () => getCreateCredentialTypeInstruction,
  getCreateCredentialTypeDiscriminatorBytes: () => getCreateCredentialTypeDiscriminatorBytes,
  getCreateCredentialTemplateInstructionDataEncoder: () => getCreateCredentialTemplateInstructionDataEncoder,
  getCreateCredentialTemplateInstructionDataDecoder: () => getCreateCredentialTemplateInstructionDataDecoder,
  getCreateCredentialTemplateInstructionDataCodec: () => getCreateCredentialTemplateInstructionDataCodec,
  getCreateCredentialTemplateInstructionAsync: () => getCreateCredentialTemplateInstructionAsync,
  getCreateCredentialTemplateInstruction: () => getCreateCredentialTemplateInstruction,
  getCreateCredentialTemplateDiscriminatorBytes: () => getCreateCredentialTemplateDiscriminatorBytes,
  getCreateAgentAuthorizationInstructionDataEncoder: () => getCreateAgentAuthorizationInstructionDataEncoder,
  getCreateAgentAuthorizationInstructionDataDecoder: () => getCreateAgentAuthorizationInstructionDataDecoder,
  getCreateAgentAuthorizationInstructionDataCodec: () => getCreateAgentAuthorizationInstructionDataCodec,
  getCreateAgentAuthorizationInstructionAsync: () => getCreateAgentAuthorizationInstructionAsync,
  getCreateAgentAuthorizationInstruction: () => getCreateAgentAuthorizationInstruction,
  getCreateAgentAuthorizationDiscriminatorBytes: () => getCreateAgentAuthorizationDiscriminatorBytes,
  getConstraintOperatorEncoder: () => getConstraintOperatorEncoder,
  getConstraintOperatorDecoder: () => getConstraintOperatorDecoder,
  getConstraintOperatorCodec: () => getConstraintOperatorCodec,
  getConstraintConditionEncoder: () => getConstraintConditionEncoder,
  getConstraintConditionDecoder: () => getConstraintConditionDecoder,
  getConstraintConditionCodec: () => getConstraintConditionCodec,
  getConditionTypeEncoder: () => getConditionTypeEncoder,
  getConditionTypeDecoder: () => getConditionTypeDecoder,
  getConditionTypeCodec: () => getConditionTypeCodec,
  getCompressedAgentCreatedEventEncoder: () => getCompressedAgentCreatedEventEncoder,
  getCompressedAgentCreatedEventDecoder: () => getCompressedAgentCreatedEventDecoder,
  getCompressedAgentCreatedEventCodec: () => getCompressedAgentCreatedEventCodec,
  getComplianceStatusEncoder: () => getComplianceStatusEncoder,
  getComplianceStatusDecoder: () => getComplianceStatusDecoder,
  getComplianceStatusCodec: () => getComplianceStatusCodec,
  getComplianceReportGeneratedEventEncoder: () => getComplianceReportGeneratedEventEncoder,
  getComplianceReportGeneratedEventDecoder: () => getComplianceReportGeneratedEventDecoder,
  getComplianceReportGeneratedEventCodec: () => getComplianceReportGeneratedEventCodec,
  getComplianceReportEncoder: () => getComplianceReportEncoder,
  getComplianceReportDiscriminatorBytes: () => getComplianceReportDiscriminatorBytes,
  getComplianceReportDecoder: () => getComplianceReportDecoder,
  getComplianceReportCodec: () => getComplianceReportCodec,
  getCompliancePoliciesEncoder: () => getCompliancePoliciesEncoder,
  getCompliancePoliciesDecoder: () => getCompliancePoliciesDecoder,
  getCompliancePoliciesCodec: () => getCompliancePoliciesCodec,
  getComplianceMetricsEncoder: () => getComplianceMetricsEncoder,
  getComplianceMetricsDecoder: () => getComplianceMetricsDecoder,
  getComplianceMetricsCodec: () => getComplianceMetricsCodec,
  getComplianceFlagsEncoder: () => getComplianceFlagsEncoder,
  getComplianceFlagsDecoder: () => getComplianceFlagsDecoder,
  getComplianceFlagsCodec: () => getComplianceFlagsCodec,
  getClaimGhostInstructionDataEncoder: () => getClaimGhostInstructionDataEncoder,
  getClaimGhostInstructionDataDecoder: () => getClaimGhostInstructionDataDecoder,
  getClaimGhostInstructionDataCodec: () => getClaimGhostInstructionDataCodec,
  getClaimGhostInstruction: () => getClaimGhostInstruction,
  getClaimGhostDiscriminatorBytes: () => getClaimGhostDiscriminatorBytes,
  getBiometricTypeEncoder: () => getBiometricTypeEncoder,
  getBiometricTypeDecoder: () => getBiometricTypeDecoder,
  getBiometricTypeCodec: () => getBiometricTypeCodec,
  getBiometricStorageMethodEncoder: () => getBiometricStorageMethodEncoder,
  getBiometricStorageMethodDecoder: () => getBiometricStorageMethodDecoder,
  getBiometricStorageMethodCodec: () => getBiometricStorageMethodCodec,
  getBiometricQualityEncoder: () => getBiometricQualityEncoder,
  getBiometricQualityDecoder: () => getBiometricQualityDecoder,
  getBiometricQualityCodec: () => getBiometricQualityCodec,
  getBiometricProtectionEncoder: () => getBiometricProtectionEncoder,
  getBiometricProtectionDecoder: () => getBiometricProtectionDecoder,
  getBiometricProtectionCodec: () => getBiometricProtectionCodec,
  getBiometricPoliciesEncoder: () => getBiometricPoliciesEncoder,
  getBiometricPoliciesDecoder: () => getBiometricPoliciesDecoder,
  getBiometricPoliciesCodec: () => getBiometricPoliciesCodec,
  getBackupFrequencyEncoder: () => getBackupFrequencyEncoder,
  getBackupFrequencyDecoder: () => getBackupFrequencyDecoder,
  getBackupFrequencyCodec: () => getBackupFrequencyCodec,
  getAutoCreateGhostInstructionDataEncoder: () => getAutoCreateGhostInstructionDataEncoder,
  getAutoCreateGhostInstructionDataDecoder: () => getAutoCreateGhostInstructionDataDecoder,
  getAutoCreateGhostInstructionDataCodec: () => getAutoCreateGhostInstructionDataCodec,
  getAutoCreateGhostInstructionAsync: () => getAutoCreateGhostInstructionAsync,
  getAutoCreateGhostInstruction: () => getAutoCreateGhostInstruction,
  getAutoCreateGhostDiscriminatorBytes: () => getAutoCreateGhostDiscriminatorBytes,
  getAuthorizationUsageRecordEncoder: () => getAuthorizationUsageRecordEncoder,
  getAuthorizationUsageRecordDiscriminatorBytes: () => getAuthorizationUsageRecordDiscriminatorBytes,
  getAuthorizationUsageRecordDecoder: () => getAuthorizationUsageRecordDecoder,
  getAuthorizationUsageRecordCodec: () => getAuthorizationUsageRecordCodec,
  getAuthorizationPoliciesEncoder: () => getAuthorizationPoliciesEncoder,
  getAuthorizationPoliciesDecoder: () => getAuthorizationPoliciesDecoder,
  getAuthorizationPoliciesCodec: () => getAuthorizationPoliciesCodec,
  getAuthenticationStrengthEncoder: () => getAuthenticationStrengthEncoder,
  getAuthenticationStrengthDecoder: () => getAuthenticationStrengthDecoder,
  getAuthenticationStrengthCodec: () => getAuthenticationStrengthCodec,
  getAuthenticationPoliciesEncoder: () => getAuthenticationPoliciesEncoder,
  getAuthenticationPoliciesDecoder: () => getAuthenticationPoliciesDecoder,
  getAuthenticationPoliciesCodec: () => getAuthenticationPoliciesCodec,
  getAuthenticationMethodEncoder: () => getAuthenticationMethodEncoder,
  getAuthenticationMethodDecoder: () => getAuthenticationMethodDecoder,
  getAuthenticationMethodCodec: () => getAuthenticationMethodCodec,
  getAuthenticationLevelEncoder: () => getAuthenticationLevelEncoder,
  getAuthenticationLevelDecoder: () => getAuthenticationLevelDecoder,
  getAuthenticationLevelCodec: () => getAuthenticationLevelCodec,
  getAuditTrailInitializedEventEncoder: () => getAuditTrailInitializedEventEncoder,
  getAuditTrailInitializedEventDecoder: () => getAuditTrailInitializedEventDecoder,
  getAuditTrailInitializedEventCodec: () => getAuditTrailInitializedEventCodec,
  getAuditTrailEncoder: () => getAuditTrailEncoder,
  getAuditTrailDiscriminatorBytes: () => getAuditTrailDiscriminatorBytes,
  getAuditTrailDecoder: () => getAuditTrailDecoder,
  getAuditTrailCodec: () => getAuditTrailCodec,
  getAuditEntryEncoder: () => getAuditEntryEncoder,
  getAuditEntryDecoder: () => getAuditEntryDecoder,
  getAuditEntryCodec: () => getAuditEntryCodec,
  getAuditContextEncoder: () => getAuditContextEncoder,
  getAuditContextDecoder: () => getAuditContextDecoder,
  getAuditContextCodec: () => getAuditContextCodec,
  getAuditConfigEncoder: () => getAuditConfigEncoder,
  getAuditConfigDecoder: () => getAuditConfigDecoder,
  getAuditConfigCodec: () => getAuditConfigCodec,
  getAuditActionEncoder: () => getAuditActionEncoder,
  getAuditActionDecoder: () => getAuditActionDecoder,
  getAuditActionCodec: () => getAuditActionCodec,
  getArbitratorDecisionEncoder: () => getArbitratorDecisionEncoder,
  getArbitratorDecisionDecoder: () => getArbitratorDecisionDecoder,
  getArbitratorDecisionCodec: () => getArbitratorDecisionCodec,
  getArbitrateDisputeInstructionDataEncoder: () => getArbitrateDisputeInstructionDataEncoder,
  getArbitrateDisputeInstructionDataDecoder: () => getArbitrateDisputeInstructionDataDecoder,
  getArbitrateDisputeInstructionDataCodec: () => getArbitrateDisputeInstructionDataCodec,
  getArbitrateDisputeInstruction: () => getArbitrateDisputeInstruction,
  getArbitrateDisputeDiscriminatorBytes: () => getArbitrateDisputeDiscriminatorBytes,
  getApproveDeliveryInstructionDataEncoder: () => getApproveDeliveryInstructionDataEncoder,
  getApproveDeliveryInstructionDataDecoder: () => getApproveDeliveryInstructionDataDecoder,
  getApproveDeliveryInstructionDataCodec: () => getApproveDeliveryInstructionDataCodec,
  getApproveDeliveryInstruction: () => getApproveDeliveryInstruction,
  getApproveDeliveryDiscriminatorBytes: () => getApproveDeliveryDiscriminatorBytes,
  getApprovalLevelEncoder: () => getApprovalLevelEncoder,
  getApprovalLevelDecoder: () => getApprovalLevelDecoder,
  getApprovalLevelCodec: () => getApprovalLevelCodec,
  getAgingPolicyEncoder: () => getAgingPolicyEncoder,
  getAgingPolicyDecoder: () => getAgingPolicyDecoder,
  getAgingPolicyCodec: () => getAgingPolicyCodec,
  getAgentVerificationEncoder: () => getAgentVerificationEncoder,
  getAgentVerificationDiscriminatorBytes: () => getAgentVerificationDiscriminatorBytes,
  getAgentVerificationDecoder: () => getAgentVerificationDecoder,
  getAgentVerificationDataEncoder: () => getAgentVerificationDataEncoder,
  getAgentVerificationDataDecoder: () => getAgentVerificationDataDecoder,
  getAgentVerificationDataCodec: () => getAgentVerificationDataCodec,
  getAgentVerificationCodec: () => getAgentVerificationCodec,
  getAgentUpdatedEventEncoder: () => getAgentUpdatedEventEncoder,
  getAgentUpdatedEventDecoder: () => getAgentUpdatedEventDecoder,
  getAgentUpdatedEventCodec: () => getAgentUpdatedEventCodec,
  getAgentTreeConfigSize: () => getAgentTreeConfigSize,
  getAgentTreeConfigEncoder: () => getAgentTreeConfigEncoder,
  getAgentTreeConfigDiscriminatorBytes: () => getAgentTreeConfigDiscriminatorBytes,
  getAgentTreeConfigDecoder: () => getAgentTreeConfigDecoder,
  getAgentTreeConfigCodec: () => getAgentTreeConfigCodec,
  getAgentStatusEncoder: () => getAgentStatusEncoder,
  getAgentStatusDecoder: () => getAgentStatusDecoder,
  getAgentStatusCodec: () => getAgentStatusCodec,
  getAgentStatusChangedEventEncoder: () => getAgentStatusChangedEventEncoder,
  getAgentStatusChangedEventDecoder: () => getAgentStatusChangedEventDecoder,
  getAgentStatusChangedEventCodec: () => getAgentStatusChangedEventCodec,
  getAgentServiceUpdatedEventEncoder: () => getAgentServiceUpdatedEventEncoder,
  getAgentServiceUpdatedEventDecoder: () => getAgentServiceUpdatedEventDecoder,
  getAgentServiceUpdatedEventCodec: () => getAgentServiceUpdatedEventCodec,
  getAgentReputationAuthEncoder: () => getAgentReputationAuthEncoder,
  getAgentReputationAuthDiscriminatorBytes: () => getAgentReputationAuthDiscriminatorBytes,
  getAgentReputationAuthDecoder: () => getAgentReputationAuthDecoder,
  getAgentReputationAuthCodec: () => getAgentReputationAuthCodec,
  getAgentRegisteredEventEncoder: () => getAgentRegisteredEventEncoder,
  getAgentRegisteredEventDecoder: () => getAgentRegisteredEventDecoder,
  getAgentRegisteredEventCodec: () => getAgentRegisteredEventCodec,
  getAgentEncoder: () => getAgentEncoder,
  getAgentDiscriminatorBytes: () => getAgentDiscriminatorBytes,
  getAgentDecoder: () => getAgentDecoder,
  getAgentCodec: () => getAgentCodec,
  getActivationRequirementTypeEncoder: () => getActivationRequirementTypeEncoder,
  getActivationRequirementTypeDecoder: () => getActivationRequirementTypeDecoder,
  getActivationRequirementTypeCodec: () => getActivationRequirementTypeCodec,
  getActivationRequirementEncoder: () => getActivationRequirementEncoder,
  getActivationRequirementDecoder: () => getActivationRequirementDecoder,
  getActivationRequirementCodec: () => getActivationRequirementCodec,
  getActivateAgentInstructionDataEncoder: () => getActivateAgentInstructionDataEncoder,
  getActivateAgentInstructionDataDecoder: () => getActivateAgentInstructionDataDecoder,
  getActivateAgentInstructionDataCodec: () => getActivateAgentInstructionDataCodec,
  getActivateAgentInstructionAsync: () => getActivateAgentInstructionAsync,
  getActivateAgentInstruction: () => getActivateAgentInstruction,
  getActivateAgentDiscriminatorBytes: () => getActivateAgentDiscriminatorBytes,
  getActionEncoder: () => getActionEncoder,
  getActionDecoder: () => getActionDecoder,
  getActionCodec: () => getActionCodec,
  getAccountLockoutPoliciesEncoder: () => getAccountLockoutPoliciesEncoder,
  getAccountLockoutPoliciesDecoder: () => getAccountLockoutPoliciesDecoder,
  getAccountLockoutPoliciesCodec: () => getAccountLockoutPoliciesCodec,
  getAccessTierEncoder: () => getAccessTierEncoder,
  getAccessTierDecoder: () => getAccessTierDecoder,
  getAccessTierCodec: () => getAccessTierCodec,
  getAccessPolicyEncoder: () => getAccessPolicyEncoder,
  getAccessPolicyDecoder: () => getAccessPolicyDecoder,
  getAccessPolicyCodec: () => getAccessPolicyCodec,
  getAccessAuditConfigEncoder: () => getAccessAuditConfigEncoder,
  getAccessAuditConfigDecoder: () => getAccessAuditConfigDecoder,
  getAccessAuditConfigCodec: () => getAccessAuditConfigCodec,
  fetchUserRegistry: () => fetchUserRegistry,
  fetchStakingConfig: () => fetchStakingConfig,
  fetchStakingAccount: () => fetchStakingAccount,
  fetchReputationMetrics: () => fetchReputationMetrics,
  fetchReentrancyGuard: () => fetchReentrancyGuard,
  fetchRbacConfig: () => fetchRbacConfig,
  fetchProtocolConfig: () => fetchProtocolConfig,
  fetchMultisig: () => fetchMultisig,
  fetchMaybeUserRegistry: () => fetchMaybeUserRegistry,
  fetchMaybeStakingConfig: () => fetchMaybeStakingConfig,
  fetchMaybeStakingAccount: () => fetchMaybeStakingAccount,
  fetchMaybeReputationMetrics: () => fetchMaybeReputationMetrics,
  fetchMaybeReentrancyGuard: () => fetchMaybeReentrancyGuard,
  fetchMaybeRbacConfig: () => fetchMaybeRbacConfig,
  fetchMaybeProtocolConfig: () => fetchMaybeProtocolConfig,
  fetchMaybeMultisig: () => fetchMaybeMultisig,
  fetchMaybeGovernanceProposal: () => fetchMaybeGovernanceProposal,
  fetchMaybeGhostProtectEscrow: () => fetchMaybeGhostProtectEscrow,
  fetchMaybeExternalIdMapping: () => fetchMaybeExternalIdMapping,
  fetchMaybeDidDocument: () => fetchMaybeDidDocument,
  fetchMaybeCredentialType: () => fetchMaybeCredentialType,
  fetchMaybeCredentialTemplate: () => fetchMaybeCredentialTemplate,
  fetchMaybeCredential: () => fetchMaybeCredential,
  fetchMaybeComplianceReport: () => fetchMaybeComplianceReport,
  fetchMaybeAuthorizationUsageRecord: () => fetchMaybeAuthorizationUsageRecord,
  fetchMaybeAuditTrail: () => fetchMaybeAuditTrail,
  fetchMaybeAgentVerification: () => fetchMaybeAgentVerification,
  fetchMaybeAgentTreeConfig: () => fetchMaybeAgentTreeConfig,
  fetchMaybeAgentReputationAuth: () => fetchMaybeAgentReputationAuth,
  fetchMaybeAgent: () => fetchMaybeAgent,
  fetchGovernanceProposal: () => fetchGovernanceProposal,
  fetchGhostProtectEscrow: () => fetchGhostProtectEscrow,
  fetchExternalIdMapping: () => fetchExternalIdMapping,
  fetchDidDocument: () => fetchDidDocument,
  fetchCredentialType: () => fetchCredentialType,
  fetchCredentialTemplate: () => fetchCredentialTemplate,
  fetchCredential: () => fetchCredential,
  fetchComplianceReport: () => fetchComplianceReport,
  fetchAuthorizationUsageRecord: () => fetchAuthorizationUsageRecord,
  fetchAuditTrail: () => fetchAuditTrail,
  fetchAllUserRegistry: () => fetchAllUserRegistry,
  fetchAllStakingConfig: () => fetchAllStakingConfig,
  fetchAllStakingAccount: () => fetchAllStakingAccount,
  fetchAllReputationMetrics: () => fetchAllReputationMetrics,
  fetchAllReentrancyGuard: () => fetchAllReentrancyGuard,
  fetchAllRbacConfig: () => fetchAllRbacConfig,
  fetchAllProtocolConfig: () => fetchAllProtocolConfig,
  fetchAllMultisig: () => fetchAllMultisig,
  fetchAllMaybeUserRegistry: () => fetchAllMaybeUserRegistry,
  fetchAllMaybeStakingConfig: () => fetchAllMaybeStakingConfig,
  fetchAllMaybeStakingAccount: () => fetchAllMaybeStakingAccount,
  fetchAllMaybeReputationMetrics: () => fetchAllMaybeReputationMetrics,
  fetchAllMaybeReentrancyGuard: () => fetchAllMaybeReentrancyGuard,
  fetchAllMaybeRbacConfig: () => fetchAllMaybeRbacConfig,
  fetchAllMaybeProtocolConfig: () => fetchAllMaybeProtocolConfig,
  fetchAllMaybeMultisig: () => fetchAllMaybeMultisig,
  fetchAllMaybeGovernanceProposal: () => fetchAllMaybeGovernanceProposal,
  fetchAllMaybeGhostProtectEscrow: () => fetchAllMaybeGhostProtectEscrow,
  fetchAllMaybeExternalIdMapping: () => fetchAllMaybeExternalIdMapping,
  fetchAllMaybeDidDocument: () => fetchAllMaybeDidDocument,
  fetchAllMaybeCredentialType: () => fetchAllMaybeCredentialType,
  fetchAllMaybeCredentialTemplate: () => fetchAllMaybeCredentialTemplate,
  fetchAllMaybeCredential: () => fetchAllMaybeCredential,
  fetchAllMaybeComplianceReport: () => fetchAllMaybeComplianceReport,
  fetchAllMaybeAuthorizationUsageRecord: () => fetchAllMaybeAuthorizationUsageRecord,
  fetchAllMaybeAuditTrail: () => fetchAllMaybeAuditTrail,
  fetchAllMaybeAgentVerification: () => fetchAllMaybeAgentVerification,
  fetchAllMaybeAgentTreeConfig: () => fetchAllMaybeAgentTreeConfig,
  fetchAllMaybeAgentReputationAuth: () => fetchAllMaybeAgentReputationAuth,
  fetchAllMaybeAgent: () => fetchAllMaybeAgent,
  fetchAllGovernanceProposal: () => fetchAllGovernanceProposal,
  fetchAllGhostProtectEscrow: () => fetchAllGhostProtectEscrow,
  fetchAllExternalIdMapping: () => fetchAllExternalIdMapping,
  fetchAllDidDocument: () => fetchAllDidDocument,
  fetchAllCredentialType: () => fetchAllCredentialType,
  fetchAllCredentialTemplate: () => fetchAllCredentialTemplate,
  fetchAllCredential: () => fetchAllCredential,
  fetchAllComplianceReport: () => fetchAllComplianceReport,
  fetchAllAuthorizationUsageRecord: () => fetchAllAuthorizationUsageRecord,
  fetchAllAuditTrail: () => fetchAllAuditTrail,
  fetchAllAgentVerification: () => fetchAllAgentVerification,
  fetchAllAgentTreeConfig: () => fetchAllAgentTreeConfig,
  fetchAllAgentReputationAuth: () => fetchAllAgentReputationAuth,
  fetchAllAgent: () => fetchAllAgent,
  fetchAgentVerification: () => fetchAgentVerification,
  fetchAgentTreeConfig: () => fetchAgentTreeConfig,
  fetchAgentReputationAuth: () => fetchAgentReputationAuth,
  fetchAgent: () => fetchAgent,
  delegationScope: () => delegationScope,
  decodeUserRegistry: () => decodeUserRegistry,
  decodeStakingConfig: () => decodeStakingConfig,
  decodeStakingAccount: () => decodeStakingAccount,
  decodeReputationMetrics: () => decodeReputationMetrics,
  decodeReentrancyGuard: () => decodeReentrancyGuard,
  decodeRbacConfig: () => decodeRbacConfig,
  decodeProtocolConfig: () => decodeProtocolConfig,
  decodeMultisig: () => decodeMultisig,
  decodeGovernanceProposal: () => decodeGovernanceProposal,
  decodeGhostProtectEscrow: () => decodeGhostProtectEscrow,
  decodeExternalIdMapping: () => decodeExternalIdMapping,
  decodeDidDocument: () => decodeDidDocument,
  decodeCredentialType: () => decodeCredentialType,
  decodeCredentialTemplate: () => decodeCredentialTemplate,
  decodeCredential: () => decodeCredential,
  decodeComplianceReport: () => decodeComplianceReport,
  decodeAuthorizationUsageRecord: () => decodeAuthorizationUsageRecord,
  decodeAuditTrail: () => decodeAuditTrail,
  decodeAgentVerification: () => decodeAgentVerification,
  decodeAgentTreeConfig: () => decodeAgentTreeConfig,
  decodeAgentReputationAuth: () => decodeAgentReputationAuth,
  decodeAgent: () => decodeAgent,
  arbitratorDecision: () => arbitratorDecision,
  VoteChoice: () => VoteChoice,
  ViolationSeverity: () => ViolationSeverity,
  VerificationRelationship: () => VerificationRelationship,
  VerificationMethodType: () => VerificationMethodType,
  ValueType: () => ValueType,
  VERIFY_AUTHORIZATION_DISCRIMINATOR: () => VERIFY_AUTHORIZATION_DISCRIMINATOR,
  VERIFY_AGENT_DISCRIMINATOR: () => VERIFY_AGENT_DISCRIMINATOR,
  UnlockMethod: () => UnlockMethod,
  USER_REGISTRY_DISCRIMINATOR: () => USER_REGISTRY_DISCRIMINATOR,
  UPDATE_SOURCE_REPUTATION_DISCRIMINATOR: () => UPDATE_SOURCE_REPUTATION_DISCRIMINATOR,
  UPDATE_REPUTATION_WITH_AUTH_DISCRIMINATOR: () => UPDATE_REPUTATION_WITH_AUTH_DISCRIMINATOR,
  UPDATE_REPUTATION_TAGS_DISCRIMINATOR: () => UPDATE_REPUTATION_TAGS_DISCRIMINATOR,
  UPDATE_PROTOCOL_CONFIG_DISCRIMINATOR: () => UPDATE_PROTOCOL_CONFIG_DISCRIMINATOR,
  UPDATE_GHOST_SCORE_DISCRIMINATOR: () => UPDATE_GHOST_SCORE_DISCRIMINATOR,
  UPDATE_DID_DOCUMENT_DISCRIMINATOR: () => UPDATE_DID_DOCUMENT_DISCRIMINATOR,
  UPDATE_CROSSCHAIN_STATUS_DISCRIMINATOR: () => UPDATE_CROSSCHAIN_STATUS_DISCRIMINATOR,
  UPDATE_AGENT_SERVICE_DISCRIMINATOR: () => UPDATE_AGENT_SERVICE_DISCRIMINATOR,
  UPDATE_AGENT_REPUTATION_DISCRIMINATOR: () => UPDATE_AGENT_REPUTATION_DISCRIMINATOR,
  UPDATE_AGENT_DISCRIMINATOR: () => UPDATE_AGENT_DISCRIMINATOR,
  UNSTAKE_GHOST_DISCRIMINATOR: () => UNSTAKE_GHOST_DISCRIMINATOR,
  TrendDirection: () => TrendDirection,
  TransactionType: () => TransactionType,
  TransactionStatus: () => TransactionStatus,
  TransactionPriority: () => TransactionPriority,
  TimeLockType: () => TimeLockType,
  StepUpTrigger: () => StepUpTrigger,
  SodConstraintType: () => SodConstraintType,
  SlashReason: () => SlashReason,
  ServiceEndpointType: () => ServiceEndpointType,
  SecurityEventType: () => SecurityEventType,
  ScopeType: () => ScopeType,
  ScopeInheritance: () => ScopeInheritance,
  SUBMIT_SERVICE_RATING_DISCRIMINATOR: () => SUBMIT_SERVICE_RATING_DISCRIMINATOR,
  SUBMIT_DELIVERY_DISCRIMINATOR: () => SUBMIT_DELIVERY_DISCRIMINATOR,
  STAKING_CONFIG_DISCRIMINATOR: () => STAKING_CONFIG_DISCRIMINATOR,
  STAKING_ACCOUNT_DISCRIMINATOR: () => STAKING_ACCOUNT_DISCRIMINATOR,
  STAKE_GHOST_DISCRIMINATOR: () => STAKE_GHOST_DISCRIMINATOR,
  SLASH_STAKE_DISCRIMINATOR: () => SLASH_STAKE_DISCRIMINATOR,
  RuleEffect: () => RuleEffect,
  RoleType: () => RoleType,
  RoleStatus: () => RoleStatus,
  RiskLevel: () => RiskLevel,
  RiskCategory: () => RiskCategory,
  ReputationSourceType: () => ReputationSourceType,
  ReportingFrequency: () => ReportingFrequency,
  ReportType: () => ReportType,
  ReportStatus: () => ReportStatus,
  ReentrancyState: () => ReentrancyState,
  REVOKE_CREDENTIAL_DISCRIMINATOR: () => REVOKE_CREDENTIAL_DISCRIMINATOR,
  REVOKE_AUTHORIZATION_DISCRIMINATOR: () => REVOKE_AUTHORIZATION_DISCRIMINATOR,
  RESOLVE_DID_DOCUMENT_DISCRIMINATOR: () => RESOLVE_DID_DOCUMENT_DISCRIMINATOR,
  RESET_REENTRANCY_GUARD_DISCRIMINATOR: () => RESET_REENTRANCY_GUARD_DISCRIMINATOR,
  REPUTATION_METRICS_DISCRIMINATOR: () => REPUTATION_METRICS_DISCRIMINATOR,
  REGISTER_GHOST_METADATA_DISCRIMINATOR: () => REGISTER_GHOST_METADATA_DISCRIMINATOR,
  REGISTER_AGENT_DISCRIMINATOR: () => REGISTER_AGENT_DISCRIMINATOR,
  REGISTER_AGENT_COMPRESSED_DISCRIMINATOR: () => REGISTER_AGENT_COMPRESSED_DISCRIMINATOR,
  REENTRANCY_GUARD_DISCRIMINATOR: () => REENTRANCY_GUARD_DISCRIMINATOR,
  RECORD_PAYAI_PAYMENT_DISCRIMINATOR: () => RECORD_PAYAI_PAYMENT_DISCRIMINATOR,
  RBAC_CONFIG_DISCRIMINATOR: () => RBAC_CONFIG_DISCRIMINATOR,
  QuorumMethod: () => QuorumMethod,
  ProposalType: () => ProposalType,
  ProposalStatus: () => ProposalStatus,
  PricingModel: () => PricingModel,
  PolicyType: () => PolicyType,
  PolicyStatus: () => PolicyStatus,
  PermissionConstraintType: () => PermissionConstraintType,
  PROTOCOL_CONFIG_DISCRIMINATOR: () => PROTOCOL_CONFIG_DISCRIMINATOR,
  NotificationTiming: () => NotificationTiming,
  NotificationTargetType: () => NotificationTargetType,
  NotificationPriority: () => NotificationPriority,
  NotificationMethod: () => NotificationMethod,
  MultisigType: () => MultisigType,
  MULTISIG_DISCRIMINATOR: () => MULTISIG_DISCRIMINATOR,
  MANAGE_AGENT_STATUS_DISCRIMINATOR: () => MANAGE_AGENT_STATUS_DISCRIMINATOR,
  LINK_EXTERNAL_ID_DISCRIMINATOR: () => LINK_EXTERNAL_ID_DISCRIMINATOR,
  ISSUE_CREDENTIAL_DISCRIMINATOR: () => ISSUE_CREDENTIAL_DISCRIMINATOR,
  INIT_REENTRANCY_GUARD_DISCRIMINATOR: () => INIT_REENTRANCY_GUARD_DISCRIMINATOR,
  INITIALIZE_STAKING_CONFIG_DISCRIMINATOR: () => INITIALIZE_STAKING_CONFIG_DISCRIMINATOR,
  INITIALIZE_REPUTATION_METRICS_DISCRIMINATOR: () => INITIALIZE_REPUTATION_METRICS_DISCRIMINATOR,
  INITIALIZE_RBAC_CONFIG_DISCRIMINATOR: () => INITIALIZE_RBAC_CONFIG_DISCRIMINATOR,
  INITIALIZE_PROTOCOL_CONFIG_DISCRIMINATOR: () => INITIALIZE_PROTOCOL_CONFIG_DISCRIMINATOR,
  INITIALIZE_GOVERNANCE_PROPOSAL_DISCRIMINATOR: () => INITIALIZE_GOVERNANCE_PROPOSAL_DISCRIMINATOR,
  INITIALIZE_AUDIT_TRAIL_DISCRIMINATOR: () => INITIALIZE_AUDIT_TRAIL_DISCRIMINATOR,
  GhostspeakMarketplaceInstruction: () => GhostspeakMarketplaceInstruction,
  GhostspeakMarketplaceAccount: () => GhostspeakMarketplaceAccount,
  GOVERNANCE_PROPOSAL_DISCRIMINATOR: () => GOVERNANCE_PROPOSAL_DISCRIMINATOR,
  GHOST_PROTECT_ESCROW_DISCRIMINATOR: () => GHOST_PROTECT_ESCROW_DISCRIMINATOR,
  GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS: () => GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS,
  GHOSTSPEAK_MARKETPLACE_ERROR__VALIDATION_FAILED: () => GHOSTSPEAK_MARKETPLACE_ERROR__VALIDATION_FAILED,
  GHOSTSPEAK_MARKETPLACE_ERROR__UNAUTHORIZED_ADMIN: () => GHOSTSPEAK_MARKETPLACE_ERROR__UNAUTHORIZED_ADMIN,
  GHOSTSPEAK_MARKETPLACE_ERROR__TEST_ADDRESS_ON_MAINNET: () => GHOSTSPEAK_MARKETPLACE_ERROR__TEST_ADDRESS_ON_MAINNET,
  GHOSTSPEAK_MARKETPLACE_ERROR__SYSTEM_PROGRAM_AS_ADMIN: () => GHOSTSPEAK_MARKETPLACE_ERROR__SYSTEM_PROGRAM_AS_ADMIN,
  GHOSTSPEAK_MARKETPLACE_ERROR__DEFAULT_KEY_AS_ADMIN: () => GHOSTSPEAK_MARKETPLACE_ERROR__DEFAULT_KEY_AS_ADMIN,
  GENERATE_COMPLIANCE_REPORT_DISCRIMINATOR: () => GENERATE_COMPLIANCE_REPORT_DISCRIMINATOR,
  FILE_DISPUTE_DISCRIMINATOR: () => FILE_DISPUTE_DISCRIMINATOR,
  EscrowStatus: () => EscrowStatus,
  EnforcementLevel: () => EnforcementLevel,
  EXTERNAL_ID_MAPPING_DISCRIMINATOR: () => EXTERNAL_ID_MAPPING_DISCRIMINATOR,
  ENABLE_PROTOCOL_FEES_DISCRIMINATOR: () => ENABLE_PROTOCOL_FEES_DISCRIMINATOR,
  DegradationHandling: () => DegradationHandling,
  DataAccessLevel: () => DataAccessLevel,
  DID_DOCUMENT_DISCRIMINATOR: () => DID_DOCUMENT_DISCRIMINATOR,
  DEACTIVATE_DID_DOCUMENT_DISCRIMINATOR: () => DEACTIVATE_DID_DOCUMENT_DISCRIMINATOR,
  DEACTIVATE_CREDENTIAL_TYPE_DISCRIMINATOR: () => DEACTIVATE_CREDENTIAL_TYPE_DISCRIMINATOR,
  DEACTIVATE_CREDENTIAL_TEMPLATE_DISCRIMINATOR: () => DEACTIVATE_CREDENTIAL_TEMPLATE_DISCRIMINATOR,
  DEACTIVATE_AGENT_DISCRIMINATOR: () => DEACTIVATE_AGENT_DISCRIMINATOR,
  CrossChainStatus: () => CrossChainStatus,
  CredentialStatus: () => CredentialStatus,
  CredentialKind: () => CredentialKind,
  ConstraintOperator: () => ConstraintOperator,
  ConditionType: () => ConditionType,
  CREDENTIAL_TYPE_DISCRIMINATOR: () => CREDENTIAL_TYPE_DISCRIMINATOR,
  CREDENTIAL_TEMPLATE_DISCRIMINATOR: () => CREDENTIAL_TEMPLATE_DISCRIMINATOR,
  CREDENTIAL_DISCRIMINATOR: () => CREDENTIAL_DISCRIMINATOR,
  CREATE_MULTISIG_DISCRIMINATOR: () => CREATE_MULTISIG_DISCRIMINATOR,
  CREATE_ESCROW_DISCRIMINATOR: () => CREATE_ESCROW_DISCRIMINATOR,
  CREATE_DID_DOCUMENT_DISCRIMINATOR: () => CREATE_DID_DOCUMENT_DISCRIMINATOR,
  CREATE_CREDENTIAL_TYPE_DISCRIMINATOR: () => CREATE_CREDENTIAL_TYPE_DISCRIMINATOR,
  CREATE_CREDENTIAL_TEMPLATE_DISCRIMINATOR: () => CREATE_CREDENTIAL_TEMPLATE_DISCRIMINATOR,
  CREATE_AGENT_AUTHORIZATION_DISCRIMINATOR: () => CREATE_AGENT_AUTHORIZATION_DISCRIMINATOR,
  COMPLIANCE_REPORT_DISCRIMINATOR: () => COMPLIANCE_REPORT_DISCRIMINATOR,
  CLAIM_GHOST_DISCRIMINATOR: () => CLAIM_GHOST_DISCRIMINATOR,
  BiometricType: () => BiometricType,
  BiometricStorageMethod: () => BiometricStorageMethod,
  BackupFrequency: () => BackupFrequency,
  AuthenticationMethod: () => AuthenticationMethod,
  AuthenticationLevel: () => AuthenticationLevel,
  AuditAction: () => AuditAction,
  AgentStatus: () => AgentStatus,
  ActivationRequirementType: () => ActivationRequirementType,
  AccessTier: () => AccessTier,
  AUTO_CREATE_GHOST_DISCRIMINATOR: () => AUTO_CREATE_GHOST_DISCRIMINATOR,
  AUTHORIZATION_USAGE_RECORD_DISCRIMINATOR: () => AUTHORIZATION_USAGE_RECORD_DISCRIMINATOR,
  AUDIT_TRAIL_DISCRIMINATOR: () => AUDIT_TRAIL_DISCRIMINATOR,
  ARBITRATE_DISPUTE_DISCRIMINATOR: () => ARBITRATE_DISPUTE_DISCRIMINATOR,
  APPROVE_DELIVERY_DISCRIMINATOR: () => APPROVE_DELIVERY_DISCRIMINATOR,
  AGENT_VERIFICATION_DISCRIMINATOR: () => AGENT_VERIFICATION_DISCRIMINATOR,
  AGENT_TREE_CONFIG_DISCRIMINATOR: () => AGENT_TREE_CONFIG_DISCRIMINATOR,
  AGENT_REPUTATION_AUTH_DISCRIMINATOR: () => AGENT_REPUTATION_AUTH_DISCRIMINATOR,
  AGENT_DISCRIMINATOR: () => AGENT_DISCRIMINATOR,
  ACTIVATE_AGENT_DISCRIMINATOR: () => ACTIVATE_AGENT_DISCRIMINATOR
});
var init_generated_JSSPHJE6 = __esm(() => {
  init_chunk_IQM5RASO();
  init_chunk_5QZVFUXB();
  init_chunk_46QWY3MG();
  init_chunk_A7ALCVUI();
  init_chunk_QLRWUHN2();
  init_chunk_AWMGX3OX();
  init_chunk_Z6ZWNWWR();
});

// ../sdk-typescript/dist/batch-operations-OUWQNZGJ.js
var exports_batch_operations_OUWQNZGJ = {};
__export(exports_batch_operations_OUWQNZGJ, {
  createBatchFetcher: () => createBatchFetcher,
  batchGetExistingAccounts: () => batchGetExistingAccounts,
  batchGetAndMap: () => batchGetAndMap,
  batchGetAccountsWithRetry: () => batchGetAccountsWithRetry,
  batchGetAccounts: () => batchGetAccounts
});
var init_batch_operations_OUWQNZGJ = __esm(() => {
  init_chunk_SKMJJ3Q6();
  init_chunk_Z6ZWNWWR();
});

// ../sdk-typescript/dist/chunk-BF3IQ35I.js
async function deriveAgentPdaOriginal(programId, owner, agentId) {
  const [address3] = await getProgramDerivedAddress2({
    programAddress: programId,
    seeds: [
      getBytesEncoder().encode(new Uint8Array([97, 103, 101, 110, 116])),
      getAddressEncoder2().encode(owner),
      getUtf8Encoder().encode(agentId)
    ]
  });
  return address3;
}
async function deriveAgentPda(params) {
  const [address3, bump] = await getProgramDerivedAddress2({
    programAddress: params.programAddress,
    seeds: [
      getBytesEncoder().encode(new Uint8Array([97, 103, 101, 110, 116])),
      getAddressEncoder2().encode(params.owner),
      getUtf8Encoder().encode(params.agentId)
    ]
  });
  return [address3, bump];
}
async function deriveA2ASessionPdaOriginal(programId, creator) {
  const [address3] = await getProgramDerivedAddress2({
    programAddress: programId,
    seeds: [
      getBytesEncoder().encode(new Uint8Array([
        97,
        50,
        97,
        95,
        115,
        101,
        115,
        115,
        105,
        111,
        110
      ])),
      getAddressEncoder2().encode(creator)
    ]
  });
  return address3;
}
async function deriveA2ASessionPda(params) {
  const result = await getProgramDerivedAddress2({
    programAddress: params.programAddress,
    seeds: [
      getBytesEncoder().encode(new Uint8Array([
        97,
        50,
        97,
        95,
        115,
        101,
        115,
        115,
        105,
        111,
        110
      ])),
      getAddressEncoder2().encode(params.initiator)
    ]
  });
  return [result[0], result[1]];
}
async function deriveA2AMessagePda(programId, session, sessionCreatedAt) {
  const createdAtBytes = new Uint8Array(8);
  const dataView = new DataView(createdAtBytes.buffer);
  dataView.setBigInt64(0, sessionCreatedAt, true);
  const [address3] = await getProgramDerivedAddress2({
    programAddress: programId,
    seeds: [
      getBytesEncoder().encode(new Uint8Array([
        97,
        50,
        97,
        95,
        109,
        101,
        115,
        115,
        97,
        103,
        101
      ])),
      getAddressEncoder2().encode(session),
      createdAtBytes
    ]
  });
  return address3;
}
async function deriveUserRegistryPda(programId, signer) {
  const [address3] = await getProgramDerivedAddress2({
    programAddress: programId,
    seeds: [
      getBytesEncoder().encode(new Uint8Array([
        117,
        115,
        101,
        114,
        95,
        114,
        101,
        103,
        105,
        115,
        116,
        114,
        121
      ])),
      getAddressEncoder2().encode(signer)
    ]
  });
  return address3;
}
async function deriveAgentVerificationPda(programId, agent, verifier) {
  const [address3] = await getProgramDerivedAddress2({
    programAddress: programId,
    seeds: [
      getBytesEncoder().encode(new Uint8Array([
        97,
        103,
        101,
        110,
        116,
        95,
        118,
        101,
        114,
        105,
        102,
        105,
        99,
        97,
        116,
        105,
        111,
        110
      ])),
      getAddressEncoder2().encode(agent),
      getAddressEncoder2().encode(verifier)
    ]
  });
  return address3;
}
async function deriveAgentTreeConfigPda(programId, signer) {
  const [address3] = await getProgramDerivedAddress2({
    programAddress: programId,
    seeds: [
      getBytesEncoder().encode(new Uint8Array([
        97,
        103,
        101,
        110,
        116,
        95,
        116,
        114,
        101,
        101,
        95,
        99,
        111,
        110,
        102,
        105,
        103
      ])),
      getAddressEncoder2().encode(signer)
    ]
  });
  return address3;
}
async function findProgramDerivedAddress(seeds, programId) {
  const encodedSeeds = seeds.map((seed) => {
    if (typeof seed === "string") {
      return getUtf8Encoder().encode(seed);
    } else if (typeof seed === "object" && seed.constructor === Uint8Array) {
      return seed;
    } else {
      return getAddressEncoder2().encode(seed);
    }
  });
  const result = await getProgramDerivedAddress2({
    programAddress: programId,
    seeds: encodedSeeds
  });
  return [result[0], result[1]];
}
async function deriveEscrowPDAOriginal(workOrder, programId) {
  const seeds = [
    getBytesEncoder().encode(new Uint8Array([101, 115, 99, 114, 111, 119])),
    getAddressEncoder2().encode(workOrder)
  ];
  const result = await getProgramDerivedAddress2({
    programAddress: programId,
    seeds
  });
  return [result[0], result[1]];
}
async function deriveEscrowPDA(params) {
  const seeds = [
    getBytesEncoder().encode(new Uint8Array([101, 115, 99, 114, 111, 119])),
    getUtf8Encoder().encode(params.escrowId)
  ];
  const result = await getProgramDerivedAddress2({
    programAddress: params.programAddress,
    seeds
  });
  return [result[0], result[1]];
}
async function deriveEscrowPda(programId, buyer, seller, nonce) {
  const nonceBytes = new Uint8Array(8);
  const dataView = new DataView(nonceBytes.buffer);
  dataView.setUint32(0, nonce, true);
  const [address3] = await getProgramDerivedAddress2({
    programAddress: programId,
    seeds: [
      getBytesEncoder().encode(new Uint8Array([101, 115, 99, 114, 111, 119])),
      getAddressEncoder2().encode(buyer),
      getAddressEncoder2().encode(seller),
      nonceBytes.slice(0, 4)
    ]
  });
  return address3;
}
async function deriveTokenAccountPda(wallet, mint) {
  const ASSOCIATED_TOKEN_PROGRAM_ID = "ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL";
  const TOKEN_PROGRAM_ID = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  const [address3] = await getProgramDerivedAddress2({
    programAddress: ASSOCIATED_TOKEN_PROGRAM_ID,
    seeds: [
      getAddressEncoder2().encode(wallet),
      getAddressEncoder2().encode(TOKEN_PROGRAM_ID),
      getAddressEncoder2().encode(mint)
    ]
  });
  return address3;
}
async function deriveMessagePda(programId, channel, nonce) {
  const nonceBytes = new Uint8Array(4);
  const dataView = new DataView(nonceBytes.buffer);
  dataView.setUint32(0, nonce, true);
  const [address3] = await getProgramDerivedAddress2({
    programAddress: programId,
    seeds: [
      getBytesEncoder().encode(new Uint8Array([
        109,
        101,
        115,
        115,
        97,
        103,
        101
      ])),
      getAddressEncoder2().encode(channel),
      nonceBytes
    ]
  });
  return address3;
}
var init_chunk_BF3IQ35I = __esm(() => {
  init_index_node40();
});

// ../sdk-typescript/dist/pda-LDG2B6LK.js
var exports_pda_LDG2B6LK = {};
__export(exports_pda_LDG2B6LK, {
  findProgramDerivedAddress: () => findProgramDerivedAddress,
  deriveUserRegistryPda: () => deriveUserRegistryPda,
  deriveTokenAccountPda: () => deriveTokenAccountPda,
  deriveMessagePda: () => deriveMessagePda,
  deriveEscrowPda: () => deriveEscrowPda,
  deriveEscrowPDAOriginal: () => deriveEscrowPDAOriginal,
  deriveEscrowPDA: () => deriveEscrowPDA,
  deriveAgentVerificationPda: () => deriveAgentVerificationPda,
  deriveAgentTreeConfigPda: () => deriveAgentTreeConfigPda,
  deriveAgentPdaOriginal: () => deriveAgentPdaOriginal,
  deriveAgentPda: () => deriveAgentPda,
  deriveA2ASessionPdaOriginal: () => deriveA2ASessionPdaOriginal,
  deriveA2ASessionPda: () => deriveA2ASessionPda,
  deriveA2AMessagePda: () => deriveA2AMessagePda
});
var init_pda_LDG2B6LK = __esm(() => {
  init_chunk_BF3IQ35I();
  init_chunk_Z6ZWNWWR();
});

// ../sdk-typescript/dist/chunk-AJSWRU6F.js
function getSolanaExplorerUrl(signature2, cluster = "mainnet-beta") {
  const baseUrl = "https://explorer.solana.com/tx";
  switch (cluster) {
    case "devnet":
      return `${baseUrl}/${signature2}?cluster=devnet`;
    case "testnet":
      return `${baseUrl}/${signature2}?cluster=testnet`;
    case "localnet":
      return `${baseUrl}/${signature2}?cluster=custom&customUrl=http://localhost:8899`;
    default:
      return `${baseUrl}/${signature2}`;
  }
}
function getSolscanUrl(signature2, cluster = "mainnet-beta") {
  const baseUrl = "https://solscan.io/tx";
  switch (cluster) {
    case "devnet":
      return `${baseUrl}/${signature2}?cluster=devnet`;
    case "testnet":
      return `${baseUrl}/${signature2}?cluster=testnet`;
    case "localnet":
      return `Local transaction: ${signature2} (not viewable on Solscan)`;
    default:
      return `${baseUrl}/${signature2}`;
  }
}
function getSolanaFMUrl(signature2, cluster = "mainnet-beta") {
  const baseUrl = "https://solana.fm/tx";
  switch (cluster) {
    case "devnet":
      return `${baseUrl}/${signature2}?cluster=devnet-solana`;
    case "testnet":
      return `${baseUrl}/${signature2}?cluster=testnet-solana`;
    case "localnet":
      return `Local transaction: ${signature2} (not viewable on SolanaFM)`;
    default:
      return `${baseUrl}/${signature2}`;
  }
}
function getXrayUrl(signature2, cluster = "mainnet-beta") {
  const baseUrl = "https://xray.helius.xyz/tx";
  switch (cluster) {
    case "devnet":
      return `${baseUrl}/${signature2}?network=devnet`;
    case "testnet":
      return `${baseUrl}/${signature2}?network=testnet`;
    case "localnet":
      return `Local transaction: ${signature2} (not viewable on XRAY)`;
    default:
      return `${baseUrl}/${signature2}`;
  }
}
function generateExplorerUrls(signature2, cluster = "mainnet-beta") {
  return {
    solanaExplorer: getSolanaExplorerUrl(signature2, cluster),
    solscan: getSolscanUrl(signature2, cluster),
    solanaFM: getSolanaFMUrl(signature2, cluster),
    xray: getXrayUrl(signature2, cluster)
  };
}
function createTransactionResult(signature2, cluster, commitment = "confirmed") {
  return {
    signature: signature2,
    cluster,
    urls: generateExplorerUrls(signature2, cluster),
    commitment,
    timestamp: Date.now()
  };
}
function validateInstruction(instruction) {
  const inst = instruction;
  if (!inst.programAddress) {
    throw new Error("Invalid instruction format");
  }
}
function createIPFSUtils(config) {
  const finalConfig = {
    ...DEFAULT_IPFS_CONFIG,
    ...config,
    provider: {
      ...DEFAULT_IPFS_CONFIG.provider,
      ...config?.provider
    }
  };
  return new IPFSUtils(finalConfig);
}
function determineStorageMethod(content, options2) {
  if (options2?.forceInline)
    return "inline";
  if (options2?.forceIPFS)
    return "ipfs";
  const size = new TextEncoder().encode(content).length;
  const threshold = options2?.sizeThreshold ?? DEFAULT_IPFS_CONFIG.sizeThreshold ?? 800;
  return size > threshold ? "ipfs" : "inline";
}
async function createMetadataUri(metadata, ipfsUtils, options2) {
  const metadataJson = JSON.stringify(metadata);
  const storageMethod = determineStorageMethod(metadataJson, {
    forceIPFS: options2?.forceIPFS
  });
  if (storageMethod === "inline" || !ipfsUtils) {
    const encoded = Buffer.from(metadataJson).toString("base64");
    return `data:application/json;base64,${encoded}`;
  } else {
    const result = await ipfsUtils.client.storeContent(metadataJson, options2?.type ?? "custom", {
      filename: options2?.filename,
      contentType: "application/json"
    });
    return result.uri;
  }
}
async function deriveDidDocumentPda(programId, controller) {
  const [address22, bump] = await getProgramDerivedAddress2({
    programAddress: programId,
    seeds: [
      new TextEncoder().encode(DID_DOCUMENT_SEED2),
      getAddressEncoder2().encode(controller)
    ]
  });
  return [address22, bump];
}
function generateDidString(network, pubkey) {
  const normalizedNetwork = network === "mainnet" ? "mainnet-beta" : network;
  return `did:sol:${normalizedNetwork}:${pubkey.toString()}`;
}
function validateDidString(did) {
  if (!did.startsWith("did:sol:")) {
    throw new DidErrorClass("InvalidDidFormat", 'DID must start with "did:sol:"');
  }
  const parts = did.split(":");
  if (parts.length !== 4) {
    throw new DidErrorClass("InvalidDidFormat", 'DID must have format "did:sol:network:identifier"');
  }
  const validNetworks = ["mainnet-beta", "devnet", "testnet", "localnet"];
  if (!validNetworks.includes(parts[2])) {
    throw new DidErrorClass("InvalidDidFormat", `Invalid network "${parts[2]}". Must be one of: ${validNetworks.join(", ")}`);
  }
  try {
    esm_default2.decode(parts[3]);
  } catch {
    throw new DidErrorClass("InvalidDidFormat", "DID identifier must be a valid base58-encoded Solana public key");
  }
}
function parseDidString(did) {
  validateDidString(did);
  const parts = did.split(":");
  return {
    method: parts[1],
    network: parts[2],
    identifier: parts[3]
  };
}
function exportAsW3CDidDocument(didDocument) {
  const verificationMethod = didDocument.verificationMethods.filter((m) => !m.revoked).map((method) => ({
    id: `${didDocument.did}#${method.id}`,
    type: method.methodType,
    controller: method.controller,
    publicKeyMultibase: method.publicKeyMultibase
  }));
  const authentication = didDocument.verificationMethods.filter((m) => !m.revoked && m.relationships.includes("authentication")).map((m) => `${didDocument.did}#${m.id}`);
  const assertionMethod = didDocument.verificationMethods.filter((m) => !m.revoked && m.relationships.includes("assertionMethod")).map((m) => `${didDocument.did}#${m.id}`);
  const keyAgreement = didDocument.verificationMethods.filter((m) => !m.revoked && m.relationships.includes("keyAgreement")).map((m) => `${didDocument.did}#${m.id}`);
  const capabilityInvocation = didDocument.verificationMethods.filter((m) => !m.revoked && m.relationships.includes("capabilityInvocation")).map((m) => `${didDocument.did}#${m.id}`);
  const capabilityDelegation = didDocument.verificationMethods.filter((m) => !m.revoked && m.relationships.includes("capabilityDelegation")).map((m) => `${didDocument.did}#${m.id}`);
  const service = didDocument.serviceEndpoints.map((endpoint) => ({
    id: `${didDocument.did}#${endpoint.id}`,
    type: endpoint.serviceType,
    serviceEndpoint: endpoint.serviceEndpoint,
    description: endpoint.description || undefined
  }));
  return {
    "@context": didDocument.context,
    id: didDocument.did,
    controller: didDocument.controller.toString(),
    verificationMethod,
    authentication: authentication.length > 0 ? authentication : undefined,
    assertionMethod: assertionMethod.length > 0 ? assertionMethod : undefined,
    keyAgreement: keyAgreement.length > 0 ? keyAgreement : undefined,
    capabilityInvocation: capabilityInvocation.length > 0 ? capabilityInvocation : undefined,
    capabilityDelegation: capabilityDelegation.length > 0 ? capabilityDelegation : undefined,
    service: service.length > 0 ? service : undefined,
    alsoKnownAs: didDocument.alsoKnownAs.length > 0 ? didDocument.alsoKnownAs : undefined
  };
}
function createEd25519VerificationMethod(id, controller, publicKey, relationships = ["authentication"]) {
  const publicKeyMultibase = `z${publicKey}`;
  return {
    id,
    methodType: "Ed25519VerificationKey2020",
    controller,
    publicKeyMultibase,
    relationships,
    createdAt: Math.floor(Date.now() / 1000),
    revoked: false
  };
}
function createServiceEndpoint(id, serviceType, serviceEndpoint, description = "") {
  return {
    id,
    serviceType,
    serviceEndpoint,
    description
  };
}
function isDidActive(didDocument) {
  return !didDocument.deactivated;
}
function getMethodsForRelationship(didDocument, relationship) {
  return didDocument.verificationMethods.filter((m) => !m.revoked && m.relationships.includes(relationship));
}
function canPerformAction(didDocument, publicKey, relationship) {
  if (publicKey.toString() === didDocument.controller.toString()) {
    return true;
  }
  const pubkeyMultibase = `z${publicKey.toString()}`;
  return didDocument.verificationMethods.some((method) => !method.revoked && method.publicKeyMultibase === pubkeyMultibase && method.relationships.includes(relationship));
}
function didDocumentToJson(didDocument, pretty = true) {
  const w3cDoc = exportAsW3CDidDocument(didDocument);
  return pretty ? JSON.stringify(w3cDoc, null, 2) : JSON.stringify(w3cDoc);
}
function getNetworkFromDid(did) {
  const parts = parseDidString(did);
  return parts.network;
}
function getIdentifierFromDid(did) {
  const parts = parseDidString(did);
  return parts.identifier;
}
var MultiSourceAggregator_exports, MultiSourceAggregator, init_MultiSourceAggregator, RpcClient = class {
  client;
  commitment;
  endpoint;
  maxRetries;
  retryDelay;
  timeout;
  constructor(config) {
    this.endpoint = config.endpoint;
    this.client = createSolanaClient2({ urlOrMoniker: config.endpoint });
    this.commitment = config.commitment ?? "confirmed";
    this.maxRetries = config.maxRetries ?? 3;
    this.retryDelay = config.retryDelay ?? 1000;
    this.timeout = config.timeout ?? 60000;
  }
  get rpc() {
    return this.client.rpc;
  }
  async getAccountInfo(address22, options2) {
    return this.withRetry(async () => {
      const result = await this.client.rpc.getAccountInfo(address22, {
        commitment: options2?.commitment ?? this.commitment,
        encoding: "base64"
      }).send();
      if (!result.value)
        return null;
      return this.parseAccountInfo(result.value);
    });
  }
  async getMultipleAccounts(addresses2, options2) {
    return this.withRetry(async () => {
      const result = await this.client.rpc.getMultipleAccounts(addresses2, {
        commitment: options2?.commitment ?? this.commitment,
        encoding: "base64"
      }).send();
      return result.value.map((account) => account ? this.parseAccountInfo(account) : null);
    });
  }
  async getProgramAccounts(programId, options2) {
    return this.withRetry(async () => {
      const result = await this.client.rpc.getProgramAccounts(programId, {
        commitment: options2?.commitment ?? this.commitment,
        encoding: "base64",
        filters: options2?.filters
      }).send();
      return result.map((item) => {
        const typedItem = item;
        return {
          pubkey: typedItem.pubkey,
          account: this.parseAccountInfo(typedItem.account)
        };
      });
    });
  }
  blockhashCache = null;
  async getLatestBlockhash() {
    const now = Date.now();
    if (this.blockhashCache && now - this.blockhashCache.timestamp < 1000) {
      return this.blockhashCache.value;
    }
    const result = await this.withRetry(async () => {
      const response = await this.client.rpc.getLatestBlockhash({
        commitment: this.commitment
      }).send();
      return {
        blockhash: response.value.blockhash,
        lastValidBlockHeight: BigInt(response.value.lastValidBlockHeight)
      };
    });
    this.blockhashCache = { value: result, timestamp: now };
    return result;
  }
  async sendTransaction(transaction, options2) {
    return this.withRetry(async () => {
      const result = await this.client.rpc.sendTransaction(transaction, {
        encoding: "base64",
        skipPreflight: options2?.skipPreflight ?? false,
        preflightCommitment: options2?.preflightCommitment ?? this.commitment,
        maxRetries: options2?.maxRetries ? BigInt(options2.maxRetries) : undefined
      }).send();
      return result;
    });
  }
  async getSignatureStatuses(signatures) {
    return this.withRetry(async () => {
      const result = await this.client.rpc.getSignatureStatuses(signatures).send();
      return result.value.map((status) => {
        if (!status)
          return null;
        const typedStatus = status;
        return {
          slot: typedStatus.slot,
          confirmations: typedStatus.confirmations,
          err: typedStatus.err,
          confirmationStatus: typedStatus.confirmationStatus
        };
      });
    });
  }
  async simulateTransaction(transaction, options2) {
    return this.withRetry(async () => {
      const result = await this.client.rpc.simulateTransaction(transaction, {
        encoding: "base64",
        commitment: options2?.commitment ?? this.commitment,
        replaceRecentBlockhash: options2?.replaceRecentBlockhash ?? false
      }).send();
      return {
        err: result.value.err,
        logs: result.value.logs ?? [],
        unitsConsumed: result.value.unitsConsumed ? BigInt(result.value.unitsConsumed) : undefined,
        returnData: result.value.returnData
      };
    });
  }
  async getFeeForMessage(encodedMessage) {
    return this.withRetry(async () => {
      const result = await this.client.rpc.getFeeForMessage(encodedMessage, {
        commitment: this.commitment
      }).send();
      return result.value ? BigInt(result.value) : null;
    });
  }
  async isHealthy() {
    try {
      await this.client.rpc.getHealth().send();
      return true;
    } catch {
      return false;
    }
  }
  async getVersion() {
    const result = await this.client.rpc.getVersion().send();
    return result;
  }
  async subscribeToAccount(address22, callback) {
    console.warn("Account subscription using polling fallback. For real-time subscriptions, use client.rpcSubscriptions directly.");
    const intervalId = setInterval(async () => {
      try {
        const accountInfo = await this.getAccountInfo(address22);
        callback(accountInfo);
      } catch (error) {
        console.error("Subscription polling error:", error);
      }
    }, 5000);
    return () => {
      clearInterval(intervalId);
    };
  }
  getGillClient() {
    return this.client;
  }
  async withRetry(operation, retries = this.maxRetries) {
    let lastError;
    for (let i = 0;i <= retries; i++) {
      try {
        return await operation();
      } catch (error) {
        lastError = error;
        if (i < retries) {
          await new Promise((resolve) => setTimeout(resolve, this.retryDelay * Math.pow(2, i)));
        }
      }
    }
    throw lastError;
  }
  parseAccountInfo(rawAccount) {
    const account = rawAccount;
    const dataArray = account.data;
    const base64Data = Array.isArray(dataArray) ? dataArray[0] : dataArray;
    return {
      executable: account.executable,
      lamports: typeof account.lamports === "number" ? lamports(BigInt(account.lamports)) : account.lamports,
      owner: account.owner,
      rentEpoch: account.rentEpoch !== undefined ? typeof account.rentEpoch === "number" ? BigInt(account.rentEpoch) : account.rentEpoch : BigInt(0),
      data: Buffer.from(base64Data, "base64"),
      space: account.space ? typeof account.space === "number" ? BigInt(account.space) : account.space : undefined
    };
  }
}, DevTools = class _DevTools {
  static instance = null;
  rpcClient;
  config;
  isDevelopment;
  logs = [];
  timings = /* @__PURE__ */ new Map;
  constructor(config) {
    this.config = config;
    this.rpcClient = new RpcClient({
      endpoint: config.rpcEndpoint ?? "https://api.devnet.solana.com",
      commitment: config.commitment
    });
    this.isDevelopment = true;
  }
  static getInstance(config) {
    if (!_DevTools.instance && config) {
      _DevTools.instance = new _DevTools(config);
    }
    if (!_DevTools.instance) {
      throw new Error("DevTools not initialized. Call with config first.");
    }
    return _DevTools.instance;
  }
  enableDevMode() {
    this.isDevelopment = true;
    console.log("\uD83D\uDEE0ï¸ GhostSpeak Development Mode Enabled");
    console.log("   - Transaction simulation before sending");
    console.log("   - Cost estimates for all operations");
    console.log("   - Enhanced error messages");
    console.log("   - Performance timing");
  }
  isDevMode() {
    return this.isDevelopment;
  }
  analyzeTransaction(instructions2) {
    const writableAccounts = /* @__PURE__ */ new Set;
    const readonlyAccounts = /* @__PURE__ */ new Set;
    const signers2 = /* @__PURE__ */ new Set;
    const warnings = [];
    let totalSize = 64;
    const instructionAnalyses = instructions2.map((instr, index) => {
      totalSize += 32;
      totalSize += (instr.accounts?.length ?? 0) * 32;
      totalSize += instr.data?.length ?? 0;
      const accounts2 = (instr.accounts ?? []).map((acc) => {
        const isWritable = acc.role.toString().includes("writable") || acc.role.toString().includes("WRITABLE") || acc.role === 1 || acc.role === 3;
        const isSigner = acc.role.toString().includes("signer") || acc.role.toString().includes("SIGNER") || typeof acc === "object" && "signer" in acc || acc.role === 3;
        if (isWritable) {
          writableAccounts.add(acc.address);
        } else {
          readonlyAccounts.add(acc.address);
        }
        if (isSigner) {
          signers2.add(acc.address);
        }
        return {
          address: acc.address,
          isWritable,
          isSigner,
          role: acc.role
        };
      });
      const humanReadable = this.getInstructionDescription(instr, index);
      return {
        index,
        programId: instr.programAddress,
        accountCount: accounts2.length,
        dataSize: instr.data?.length ?? 0,
        humanReadable,
        accounts: accounts2
      };
    });
    const estimatedComputeUnits = this.estimateComputeUnits(instructions2);
    const estimatedFee = this.estimateFee(estimatedComputeUnits, instructions2.length);
    if (totalSize > 1232) {
      warnings.push(`Transaction size (${totalSize} bytes) exceeds limit (1232 bytes)`);
    }
    if (signers2.size === 0) {
      warnings.push("No signers found in transaction");
    }
    if (estimatedComputeUnits > BigInt(1400000)) {
      warnings.push(`High compute usage: ${estimatedComputeUnits} units`);
    }
    return {
      instructions: instructionAnalyses,
      totalAccounts: writableAccounts.size + readonlyAccounts.size,
      signerCount: signers2.size,
      writableAccounts: Array.from(writableAccounts),
      readonlyAccounts: Array.from(readonlyAccounts),
      estimatedSize: totalSize,
      estimatedComputeUnits,
      estimatedFee,
      warnings
    };
  }
  getInstructionDescription(instruction, _index) {
    const programId = instruction.programAddress;
    if (programId === this.config.programId) {
      return this.decodeGhostSpeakInstruction(instruction);
    }
    if (programId === "11111111111111111111111111111111") {
      return "System Program: Transfer or Create Account";
    }
    if (programId === "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA") {
      return "Token Program: Token Operation";
    }
    if (programId === "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb") {
      return "Token-2022 Program: Advanced Token Operation";
    }
    return `Unknown Instruction`;
  }
  decodeGhostSpeakInstruction(instruction) {
    if (!instruction.data || instruction.data.length < 8) {
      return "GhostSpeak: Unknown Instruction";
    }
    const discriminator = Array.from(instruction.data.slice(0, 8)).map((b) => b.toString(16).padStart(2, "0")).join("");
    const instructionMap = {
      a8c5e109d3d1b8d5: "Register Agent",
      b7f3c8e0a2d4e9f1: "Create Escrow",
      c4d2f7a9b8e1c3f5: "Send Message",
      d9e8f2b5c1a7e4f8: "Create Channel"
    };
    return `GhostSpeak: ${instructionMap[discriminator] ?? "Custom Instruction"}`;
  }
  estimateComputeUnits(instructions2) {
    let totalUnits = BigInt(0);
    for (const instr of instructions2) {
      totalUnits += BigInt(200);
      totalUnits += BigInt((instr.accounts?.length ?? 0) * 150);
      totalUnits += BigInt((instr.data?.length ?? 0) * 10);
      if (instr.programAddress === this.config.programId) {
        totalUnits += BigInt(5000);
      }
    }
    return totalUnits;
  }
  estimateFee(computeUnits, instructionCount) {
    const baseFee = BigInt(5000);
    const computeFee = computeUnits * BigInt(5) / BigInt(1e6);
    const priorityFee = BigInt(instructionCount * 1000);
    return baseFee + computeFee + priorityFee;
  }
  log(message, data) {
    if (!this.isDevelopment)
      return;
    const timestamp = (/* @__PURE__ */ new Date()).toISOString();
    const logEntry = `[${timestamp}] ${message}`;
    this.logs.push(logEntry);
    console.log(`\uD83D\uDD0D ${logEntry}`);
    if (data) {
      console.log("   Data:", data);
    }
  }
  startTiming(label) {
    if (!this.isDevelopment)
      return;
    const perfNow = typeof performance !== "undefined" ? performance.now() : Date.now();
    this.timings.set(label, perfNow);
  }
  endTiming(label) {
    if (!this.isDevelopment)
      return;
    const start = this.timings.get(label);
    if (!start)
      return;
    const perfNow = typeof performance !== "undefined" ? performance.now() : Date.now();
    const duration = perfNow - start;
    this.log(`${label} took ${duration.toFixed(2)}ms`);
    this.timings.delete(label);
  }
  formatTransaction(analysis) {
    const lines = [
      "\uD83D\uDCCB Transaction Analysis",
      "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•",
      `Instructions: ${analysis.instructions.length}`,
      `Total Accounts: ${analysis.totalAccounts}`,
      `Signers: ${analysis.signerCount}`,
      `Estimated Size: ${analysis.estimatedSize} bytes`,
      `Estimated Compute Units: ${analysis.estimatedComputeUnits.toLocaleString()}`,
      `Estimated Fee: ${(Number(analysis.estimatedFee) / 1e9).toFixed(6)} SOL`,
      ""
    ];
    lines.push("Instructions:");
    for (const instr of analysis.instructions) {
      lines.push(`  ${instr.index + 1}. ${instr.humanReadable}`);
      lines.push(`     Program: ${instr.programId.slice(0, 8)}...`);
      lines.push(`     Accounts: ${instr.accountCount}, Data: ${instr.dataSize} bytes`);
    }
    if (analysis.warnings.length > 0) {
      lines.push("");
      lines.push("âš ï¸ Warnings:");
      for (const warning of analysis.warnings) {
        lines.push(`  - ${warning}`);
      }
    }
    lines.push("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    return lines.join(`
`);
  }
  exportLogs() {
    return [...this.logs];
  }
  clearLogs() {
    this.logs = [];
    this.timings.clear();
  }
}, InstructionBuilder = class {
  rpcClient;
  config;
  devTools;
  debugMode = false;
  constructor(config) {
    this.config = config;
    this.rpcClient = new RpcClient({
      endpoint: config.rpcEndpoint ?? "https://api.devnet.solana.com",
      wsEndpoint: config.wsEndpoint,
      commitment: config.commitment ?? "confirmed"
    });
    this.devTools = DevTools.getInstance(config);
  }
  async execute(instructionName, instructionGetter, signers2, options2) {
    const context = createErrorContext("execute", instructionName, signers2.map((s3) => ({ address: s3.address, name: "signer" })), { programId: this.config.programId });
    try {
      if (this.devTools.isDevMode()) {
        this.devTools.startTiming(instructionName);
      }
      const instruction = await Promise.resolve(instructionGetter());
      validateInstruction(instruction);
      if (this.debugMode || this.devTools.isDevMode()) {
        const analysis = this.devTools.analyzeTransaction([instruction]);
        console.log(this.devTools.formatTransaction(analysis));
        this.debugMode = false;
      }
      if (options2?.simulate) {
        return await this.simulateInstruction(instruction, signers2);
      }
      const latestBlockhashResult = await this.rpcClient.getLatestBlockhash();
      const latestBlockhash = {
        blockhash: latestBlockhashResult.blockhash,
        lastValidBlockHeight: latestBlockhashResult.lastValidBlockHeight
      };
      const transactionMessage = pipe(createTransactionMessage({ version: 0 }), (tx) => setTransactionMessageFeePayerSigner(signers2[0], tx), (tx) => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx), (tx) => appendTransactionMessageInstructions([instruction], tx));
      const signedTransaction = await signTransactionMessageWithSigners(transactionMessage);
      const signatureResult = await this.sendAndConfirm(signedTransaction, options2?.skipPreflight ?? false, options2?.maxRetries ?? 30);
      if (typeof signatureResult !== "string") {
        throw new Error("Transaction signature is not a string");
      }
      const signature2 = signatureResult;
      if (options2?.returnDetails) {
        const cluster = this.config.cluster ?? "devnet";
        const result = createTransactionResult(signature2, cluster, this.config.commitment ?? "confirmed");
        if (this.devTools.isDevMode()) {
          this.devTools.endTiming(instructionName);
        }
        return result;
      }
      if (this.devTools.isDevMode()) {
        this.devTools.endTiming(instructionName);
      }
      return signature2;
    } catch (error) {
      logEnhancedError(error, context);
      throw error;
    }
  }
  async executeBatch(batchName, instructionGetters, signers2, options2) {
    const context = createErrorContext("executeBatch", batchName, signers2.map((s3) => ({ address: s3.address, name: "signer" })), { programId: this.config.programId, instructionCount: instructionGetters.length });
    try {
      const instructions2 = await Promise.all(instructionGetters.map(async (getter, i) => {
        const instruction = await Promise.resolve(getter());
        try {
          validateInstruction(instruction);
          return instruction;
        } catch (error) {
          throw new Error(`Instruction ${i} in ${batchName}: ${error.message}`);
        }
      }));
      const estimatedSize = this.estimateTransactionSize(instructions2);
      if (estimatedSize > 1232) {
        throw new Error(`Transaction too large: ${estimatedSize} bytes (max: 1232)`);
      }
      if (options2?.simulate) {
        return await this.simulateBatch(instructions2, signers2);
      }
      const latestBlockhashResult = await this.rpcClient.getLatestBlockhash();
      const latestBlockhash = {
        blockhash: latestBlockhashResult.blockhash,
        lastValidBlockHeight: latestBlockhashResult.lastValidBlockHeight
      };
      const transactionMessage = pipe(createTransactionMessage({ version: 0 }), (tx) => setTransactionMessageFeePayerSigner(signers2[0], tx), (tx) => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx), (tx) => appendTransactionMessageInstructions(instructions2, tx));
      const signedTransaction = await signTransactionMessageWithSigners(transactionMessage);
      const signatureResult = await this.sendAndConfirm(signedTransaction, options2?.skipPreflight ?? false);
      if (typeof signatureResult !== "string") {
        throw new Error("Transaction signature is not a string");
      }
      const signature2 = signatureResult;
      if (options2?.returnDetails) {
        const cluster = this.config.cluster ?? "devnet";
        const result = createTransactionResult(signature2, cluster, this.config.commitment ?? "confirmed");
        if (this.devTools.isDevMode()) {
          this.devTools.endTiming(batchName);
        }
        return result;
      }
      if (this.devTools.isDevMode()) {
        this.devTools.endTiming(batchName);
      }
      return signature2;
    } catch (error) {
      logEnhancedError(error, context);
      throw error;
    }
  }
  async getAccount(address22, decoderImportName) {
    try {
      const accountInfo = await this.rpcClient.getAccountInfo(address22, {
        commitment: this.config.commitment
      });
      if (!accountInfo)
        return null;
      const generated = await Promise.resolve().then(() => (init_generated_JSSPHJE6(), exports_generated_JSSPHJE6));
      const decoderGetter = generated[decoderImportName];
      const decoder = decoderGetter();
      const rawData = this.extractRawData(accountInfo.data);
      return decoder.decode(rawData);
    } catch (error) {
      console.warn(`Failed to fetch account ${address22}:`, error);
      return null;
    }
  }
  async getAccounts(addresses2, decoderImportName) {
    try {
      const accounts2 = await this.rpcClient.getMultipleAccounts(addresses2, {
        commitment: this.config.commitment
      });
      const generated = await Promise.resolve().then(() => (init_generated_JSSPHJE6(), exports_generated_JSSPHJE6));
      const decoderGetter = generated[decoderImportName];
      const decoder = decoderGetter();
      return accounts2.map((accountInfo) => {
        if (!accountInfo)
          return null;
        try {
          const rawData = this.extractRawData(accountInfo.data);
          return decoder.decode(rawData);
        } catch {
          return null;
        }
      });
    } catch (error) {
      console.warn("Failed to fetch multiple accounts:", error);
      return addresses2.map(() => null);
    }
  }
  async getProgramAccounts(decoderImportName, filters) {
    try {
      const convertedFilters = filters?.map((filter) => {
        if ("dataSize" in filter) {
          return { dataSize: filter.dataSize };
        } else {
          const encoding = filter.memcmp.encoding ?? "base58";
          if (encoding === "base64") {
            return {
              memcmp: {
                offset: filter.memcmp.offset,
                bytes: filter.memcmp.bytes,
                encoding: "base64"
              }
            };
          } else {
            return {
              memcmp: {
                offset: filter.memcmp.offset,
                bytes: filter.memcmp.bytes,
                encoding: "base58"
              }
            };
          }
        }
      });
      const accounts2 = await this.rpcClient.getProgramAccounts(this.config.programId, {
        commitment: this.config.commitment,
        filters: convertedFilters ?? []
      });
      const generated = await Promise.resolve().then(() => (init_generated_JSSPHJE6(), exports_generated_JSSPHJE6));
      const decoderGetter = generated[decoderImportName];
      const decoder = decoderGetter();
      const decodedAccounts = [];
      for (const { pubkey, account } of accounts2) {
        try {
          const rawData = this.extractRawData(account.data);
          const decodedData = decoder.decode(rawData);
          decodedAccounts.push({ address: pubkey, data: decodedData });
        } catch {}
      }
      return decodedAccounts;
    } catch (error) {
      console.error("Failed to get program accounts:", error);
      return [];
    }
  }
  enableDebug() {
    this.debugMode = true;
    return this;
  }
  async debug(instructionName, instructionGetters) {
    this.devTools.log(`Debugging ${instructionName}`);
    const instructions2 = await Promise.all(instructionGetters.map(async (getter) => {
      const instruction = await Promise.resolve(getter());
      validateInstruction(instruction);
      return instruction;
    }));
    const analysis = this.devTools.analyzeTransaction(instructions2);
    console.log(this.devTools.formatTransaction(analysis));
    return analysis;
  }
  async explain(instructionName, instructionGetters) {
    const analysis = await this.debug(instructionName, instructionGetters);
    const lines = [
      `\uD83D\uDD0D Transaction: ${instructionName}`,
      "",
      "This transaction will:",
      ...analysis.instructions.map((instr, i) => `  ${i + 1}. ${instr.humanReadable}`),
      "",
      `Cost: ~${(Number(analysis.estimatedFee) / 1e9).toFixed(6)} SOL`,
      `Size: ${analysis.estimatedSize} bytes`,
      `Compute: ${analysis.estimatedComputeUnits.toLocaleString()} units`
    ];
    if (analysis.warnings.length > 0) {
      lines.push("", "âš ï¸ Warnings:");
      lines.push(...analysis.warnings.map((w) => `  - ${w}`));
    }
    return lines.join(`
`);
  }
  async estimateCost(instructionGetters) {
    try {
      const instructions2 = await Promise.all(instructionGetters.map(async (getter) => {
        const instruction = await Promise.resolve(getter());
        validateInstruction(instruction);
        return instruction;
      }));
      const latestBlockhashResult = await this.rpcClient.getLatestBlockhash();
      const latestBlockhash = {
        blockhash: latestBlockhashResult.blockhash,
        lastValidBlockHeight: latestBlockhashResult.lastValidBlockHeight
      };
      const transactionMessage = pipe(createTransactionMessage({ version: 0 }), (tx) => setTransactionMessageFeePayer(this.config.defaultFeePayer, tx), (tx) => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx), (tx) => appendTransactionMessageInstructions(instructions2, tx));
      const compiledMessage = compileTransactionMessage(transactionMessage);
      const encodedMessage = Buffer.from(compiledMessage).toString("base64");
      const fee = await this.rpcClient.getFeeForMessage(encodedMessage);
      return BigInt(fee ?? 0);
    } catch {
      const baseFee = 5000n;
      const perInstructionFee = 1000n;
      return baseFee + BigInt(instructionGetters.length) * perInstructionFee;
    }
  }
  async sendAndConfirm(signedTransaction, skipPreflight, maxRetries = 30) {
    const wireTransaction = getBase64EncodedWireTransaction(signedTransaction);
    const signature2 = await this.rpcClient.sendTransaction(wireTransaction, {
      skipPreflight,
      preflightCommitment: this.config.commitment
    });
    console.log("\uD83D\uDD0D Transaction sent, signature:", signature2);
    console.log("\uD83D\uDD0D Signature length:", signature2.length);
    console.log("\uD83D\uDD0D Signature type:", typeof signature2);
    let confirmed = false;
    let attempts = 0;
    let currentDelay = 1000;
    const maxConfirmationTime = 30000;
    const startTime = Date.now();
    while (!confirmed && attempts < maxRetries && Date.now() - startTime < maxConfirmationTime) {
      try {
        console.log(`\uD83D\uDD0D Confirmation attempt ${attempts + 1}/${maxRetries}`);
        const statuses = await this.rpcClient.getSignatureStatuses([signature2]);
        if (statuses[0]) {
          console.log("\uD83D\uDD0D Status found:", statuses[0]);
          if (statuses[0].err) {
            throw new Error(`Transaction failed: ${JSON.stringify(statuses[0].err, (_, v) => typeof v === "bigint" ? v.toString() : v)}`);
          }
          const confirmationStatus = statuses[0].confirmationStatus;
          if (confirmationStatus === this.config.commitment || this.config.commitment === "confirmed" && confirmationStatus === "finalized") {
            confirmed = true;
            console.log("âœ… Transaction confirmed via status check");
            break;
          }
        } else {
          console.log("\uD83D\uDD0D No status found, trying transaction details...");
          try {
            const directClient = createSolanaClient2({ urlOrMoniker: this.config.rpcEndpoint ?? "https://api.devnet.solana.com" });
            const transaction = await directClient.rpc.getTransaction(signature2, {
              commitment: this.config.commitment ?? "confirmed",
              encoding: "json",
              maxSupportedTransactionVersion: 0
            }).send();
            if (transaction && transaction.meta) {
              if (transaction.meta.err) {
                throw new Error(`Transaction failed: ${JSON.stringify(transaction.meta.err, (_, v) => typeof v === "bigint" ? v.toString() : v)}`);
              }
              confirmed = true;
              console.log("âœ… Transaction confirmed via direct lookup");
              break;
            }
          } catch {
            console.log("\uD83D\uDD0D Transaction details not yet available");
          }
        }
        attempts++;
        await new Promise((resolve) => setTimeout(resolve, currentDelay));
        currentDelay = Math.min(currentDelay * 1.5, 5000);
      } catch (error) {
        if (error instanceof Error && error.message.includes("Transaction failed")) {
          throw error;
        }
        console.log(`\uD83D\uDD0D Confirmation attempt failed:`, error.message);
        attempts++;
        await new Promise((resolve) => setTimeout(resolve, currentDelay * 2));
      }
    }
    if (!confirmed) {
      console.log("\uD83D\uDD0D Final confirmation attempt via transaction lookup...");
      try {
        const directClient = createSolanaClient2({ urlOrMoniker: this.config.rpcEndpoint ?? "https://api.devnet.solana.com" });
        const transaction = await directClient.rpc.getTransaction(signature2, {
          commitment: this.config.commitment ?? "confirmed",
          encoding: "json",
          maxSupportedTransactionVersion: 0
        }).send();
        if (transaction && transaction.meta) {
          if (transaction.meta.err) {
            throw new Error(`Transaction failed: ${JSON.stringify(transaction.meta.err, (_, v) => typeof v === "bigint" ? v.toString() : v)}`);
          }
          console.log("âœ… Transaction confirmed on final check - returning success");
          return signature2;
        }
      } catch (finalError) {
        console.log("\uD83D\uDD0D Final check failed:", finalError.message);
      }
      console.log("âš ï¸ Transaction confirmation timed out, but transaction was sent");
      console.log(`   Check status at: https://explorer.solana.com/tx/${signature2}?cluster=${this.config.cluster || "devnet"}`);
      return signature2;
    }
    return signature2;
  }
  async simulateInstruction(instruction, signers2) {
    const latestBlockhashResult = await this.rpcClient.getLatestBlockhash();
    const latestBlockhash = {
      blockhash: latestBlockhashResult.blockhash,
      lastValidBlockHeight: latestBlockhashResult.lastValidBlockHeight
    };
    const transactionMessage = pipe(createTransactionMessage({ version: 0 }), (tx) => setTransactionMessageFeePayerSigner(signers2[0], tx), (tx) => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx), (tx) => appendTransactionMessageInstructions([instruction], tx));
    const signedTransaction = await signTransactionMessageWithSigners(transactionMessage);
    const wireTransaction = getBase64EncodedWireTransaction(signedTransaction);
    return this.rpcClient.simulateTransaction(wireTransaction, {
      commitment: this.config.commitment,
      replaceRecentBlockhash: true
    });
  }
  async simulateBatch(instructions2, signers2) {
    const latestBlockhashResult = await this.rpcClient.getLatestBlockhash();
    const latestBlockhash = {
      blockhash: latestBlockhashResult.blockhash,
      lastValidBlockHeight: latestBlockhashResult.lastValidBlockHeight
    };
    const transactionMessage = pipe(createTransactionMessage({ version: 0 }), (tx) => setTransactionMessageFeePayerSigner(signers2[0], tx), (tx) => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx), (tx) => appendTransactionMessageInstructions(instructions2, tx));
    const signedTransaction = await signTransactionMessageWithSigners(transactionMessage);
    const wireTransaction = getBase64EncodedWireTransaction(signedTransaction);
    return this.rpcClient.simulateTransaction(wireTransaction, {
      commitment: this.config.commitment,
      replaceRecentBlockhash: true
    });
  }
  estimateTransactionSize(instructions2) {
    let totalSize = 64;
    for (const instruction of instructions2) {
      totalSize += 32;
      totalSize += (instruction.accounts?.length ?? 0) * 32;
      totalSize += instruction.data.length;
    }
    return totalSize;
  }
  extractRawData(data) {
    if (Buffer.isBuffer(data) || data instanceof Uint8Array) {
      return new Uint8Array(data);
    }
    if (typeof data === "object" && data !== null && "data" in data) {
      return Buffer.from(data.data, "base64");
    }
    if (typeof data === "string") {
      return Buffer.from(data, "base64");
    }
    throw new Error("Invalid account data format");
  }
  async createCommunicationSession(_params) {
    return {
      programAddress: this.config.programId,
      accounts: [],
      data: new Uint8Array(0)
    };
  }
  async sendCommunicationMessage(_sessionAddress, _params) {
    return {
      programAddress: this.config.programId,
      accounts: [],
      data: new Uint8Array(0)
    };
  }
  async updateParticipantStatus(_params) {
    return {
      programAddress: this.config.programId,
      accounts: [],
      data: new Uint8Array(0)
    };
  }
}, DEFAULT_TTLS, CacheManager = class {
  accountCache;
  pdaCache;
  config;
  ttls;
  constructor(config = {}) {
    this.config = {
      enabled: config.enabled ?? false,
      maxSize: config.maxSize ?? 1000,
      ttlOverrides: config.ttlOverrides ?? {}
    };
    this.ttls = {
      processed: config.ttlOverrides?.processed ?? DEFAULT_TTLS.processed,
      confirmed: config.ttlOverrides?.confirmed ?? DEFAULT_TTLS.confirmed,
      finalized: config.ttlOverrides?.finalized ?? DEFAULT_TTLS.finalized
    };
    this.accountCache = new LRUCache({
      max: this.config.maxSize,
      ttl: DEFAULT_TTLS.finalized
    });
    this.pdaCache = new LRUCache({
      max: this.config.maxSize
    });
  }
  isEnabled() {
    return this.config.enabled;
  }
  getAccount(address22, commitment, currentSlot) {
    if (!this.config.enabled)
      return;
    const key = `${address22}:${commitment}`;
    const entry = this.accountCache.get(key);
    if (!entry)
      return;
    if (currentSlot !== undefined && entry.slot < currentSlot) {
      this.accountCache.delete(key);
      return;
    }
    return entry.data;
  }
  setAccount(address22, data, commitment, slot) {
    if (!this.config.enabled)
      return;
    const key = `${address22}:${commitment}`;
    const entry = {
      data,
      slot,
      commitment,
      timestamp: Date.now()
    };
    this.accountCache.set(key, entry, {
      ttl: this.ttls[commitment]
    });
  }
  getPDA(seeds) {
    if (!this.config.enabled)
      return;
    return this.pdaCache.get(seeds);
  }
  setPDA(seeds, pda) {
    if (!this.config.enabled)
      return;
    this.pdaCache.set(seeds, pda);
  }
  invalidateAccount(address22, commitment) {
    if (!this.config.enabled)
      return;
    if (commitment) {
      this.accountCache.delete(`${address22}:${commitment}`);
    } else {
      ["processed", "confirmed", "finalized"].forEach((c) => {
        this.accountCache.delete(`${address22}:${c}`);
      });
    }
  }
  clear() {
    this.accountCache.clear();
    this.pdaCache.clear();
  }
  getStats() {
    return {
      accountCache: {
        size: this.accountCache.size,
        max: this.config.maxSize
      },
      pdaCache: {
        size: this.pdaCache.size,
        max: this.config.maxSize
      }
    };
  }
}, BaseModule = class {
  builder;
  config;
  logger;
  cacheManager;
  _debugMode = false;
  constructor(config) {
    this.config = config;
    this.builder = new InstructionBuilder(config);
    this.cacheManager = new CacheManager(config.cache);
    this.logger = config.logger;
  }
  debug() {
    this._debugMode = true;
    this.builder.enableDebug();
    return this;
  }
  async execute(instructionName, instructionGetter, signers2) {
    return this.builder.execute(instructionName, instructionGetter, signers2);
  }
  async executeWithDetails(instructionName, instructionGetter, signers2) {
    return this.builder.execute(instructionName, instructionGetter, signers2, { returnDetails: true });
  }
  async executeBatch(batchName, instructionGetters, signers2) {
    return this.builder.executeBatch(batchName, instructionGetters.map((getter) => () => Promise.resolve(getter())), signers2);
  }
  async simulate(instructionName, instructionGetter, signers2) {
    return this.builder.execute(instructionName, () => Promise.resolve(instructionGetter()), signers2, { simulate: true });
  }
  async simulateInstruction(instructionName, instructionGetter, signers2) {
    return this.simulate(instructionName, instructionGetter, signers2);
  }
  async estimateCost(instructionGetters) {
    return this.builder.estimateCost(instructionGetters);
  }
  async getCost(instructionName, instructionGetter) {
    return this.builder.estimateCost([instructionGetter]);
  }
  async explain(instructionName, instructionGetter) {
    return this.builder.explain(instructionName, [instructionGetter]);
  }
  async analyze(instructionName, instructionGetter) {
    return this.builder.debug(instructionName, [instructionGetter]);
  }
  async getAccount(address22, decoderImportName) {
    if (this.cacheManager.isEnabled()) {
      const cached = this.cacheManager.getAccount(address22, this.commitment);
      if (cached !== undefined) {
        this.logger?.info(`[Cache HIT] ${address22}`);
        return cached;
      }
    }
    const account = await this.builder.getAccount(address22, decoderImportName);
    if (this.cacheManager.isEnabled() && account !== null) {
      const slot = 0;
      this.cacheManager.setAccount(address22, account, this.commitment, slot);
      this.logger?.info(`[Cache SET] ${address22}`);
    }
    return account;
  }
  async getAccounts(addresses2, decoderImportName) {
    if (!this.cacheManager.isEnabled()) {
      return this.builder.getAccounts(addresses2, decoderImportName);
    }
    const results = new Array(addresses2.length);
    const uncachedIndices = [];
    const uncachedAddresses = [];
    for (let i = 0;i < addresses2.length; i++) {
      const cached = this.cacheManager.getAccount(addresses2[i], this.commitment);
      if (cached !== undefined) {
        results[i] = cached;
        this.logger?.info(`[Cache HIT] ${addresses2[i]}`);
      } else {
        uncachedIndices.push(i);
        uncachedAddresses.push(addresses2[i]);
      }
    }
    if (uncachedAddresses.length > 0) {
      this.logger?.info(`[Cache MISS] Fetching ${uncachedAddresses.length}/${addresses2.length} accounts`);
      const fetched = await this.builder.getAccounts(uncachedAddresses, decoderImportName);
      const slot = 0;
      for (let i = 0;i < fetched.length; i++) {
        const originalIndex = uncachedIndices[i];
        const account = fetched[i];
        results[originalIndex] = account;
        if (account !== null) {
          this.cacheManager.setAccount(uncachedAddresses[i], account, this.commitment, slot);
        }
      }
    }
    return results;
  }
  async getProgramAccounts(decoderImportName, filters) {
    return this.builder.getProgramAccounts(decoderImportName, filters);
  }
  get programId() {
    return this.config.programId;
  }
  getProgramId() {
    return this.config.programId;
  }
  get commitment() {
    return this.config.commitment ?? "confirmed";
  }
  getCommitment() {
    return this.config.commitment ?? "confirmed";
  }
  invalidateCache(address22) {
    this.cacheManager.invalidateAccount(address22);
    this.logger?.info(`[Cache INVALIDATE] ${address22}`);
  }
  clearCache() {
    this.cacheManager.clear();
    this.logger?.info("[Cache CLEAR] All caches cleared");
  }
  getCacheStats() {
    return this.cacheManager.getStats();
  }
}, DEFAULT_IPFS_CONFIG, IPFSUtils = class {
  client;
  constructor(config) {
    this.client = new IPFSClient(config);
  }
  async storeAgentMetadata(metadata, options2) {
    const metadataJson = JSON.stringify({
      ...metadata,
      createdAt: (/* @__PURE__ */ new Date()).toISOString(),
      version: "1.0.0"
    });
    return this.client.storeContent(metadataJson, "agent-metadata", {
      filename: `agent-${metadata.agentId ?? "metadata"}.json`,
      metadata: {
        type: "agent-metadata",
        agentId: metadata.agentId,
        name: metadata.name
      },
      contentType: "application/json",
      ...options2
    });
  }
  async storeChannelMessage(message, options2) {
    const messageJson = JSON.stringify({
      ...message,
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      version: "1.0.0"
    });
    return this.client.storeContent(messageJson, "channel-message", {
      filename: `message-${Date.now()}.json`,
      metadata: {
        type: "channel-message",
        channelId: message.channelId,
        messageType: message.messageType ?? 0
      },
      contentType: "application/json",
      ...options2
    });
  }
  async storeFileAttachment(fileContent, filename, contentType, options2) {
    const content = typeof fileContent === "string" ? fileContent : new TextDecoder().decode(fileContent);
    return this.client.storeContent(content, "file-attachment", {
      filename,
      contentType,
      metadata: {
        type: "file-attachment",
        originalFilename: filename,
        mimeType: contentType
      },
      ...options2
    });
  }
  async retrieveAgentMetadata(uri) {
    const content = await this.client.retrieveContent(uri);
    const parsed = JSON.parse(content);
    if (typeof parsed !== "object" || parsed === null) {
      throw new Error("Retrieved agent metadata is not a valid object");
    }
    return parsed;
  }
  async retrieveChannelMessage(uri) {
    const content = await this.client.retrieveContent(uri);
    const parsed = JSON.parse(content);
    if (typeof parsed !== "object" || parsed === null) {
      throw new Error("Retrieved channel message is not a valid object");
    }
    return parsed;
  }
  async batchUpload(items) {
    const results = await Promise.allSettled(items.map((item) => this.client.storeContent(item.content, item.type, {
      filename: item.filename,
      ...item.options
    })));
    return results.map((result) => {
      if (result.status === "fulfilled") {
        return {
          success: true,
          data: result.value
        };
      } else {
        return {
          success: false,
          error: "UPLOAD_FAILED",
          message: result.reason instanceof Error ? result.reason.message : String(result.reason)
        };
      }
    });
  }
  async pinContent(hash) {
    const result = await this.client.pin(hash);
    return {
      ...result,
      data: result.success
    };
  }
  isIPFSUri(uri) {
    return uri.startsWith("ipfs://");
  }
  extractIPFSHash(uri) {
    if (!this.isIPFSUri(uri)) {
      return null;
    }
    return uri.replace("ipfs://", "");
  }
  getGatewayUrls(hash, gateways) {
    const defaultGateways = gateways ?? DEFAULT_IPFS_CONFIG.gateways ?? [];
    return defaultGateways.map((gateway) => `${gateway}/ipfs/${hash}`);
  }
  isValidIPFSHash(hash) {
    if (hash.length < 44)
      return false;
    if (hash.startsWith("Qm") && hash.length === 46) {
      return /^Qm[A-Za-z0-9]{44}$/.test(hash);
    }
    if (hash.length > 46) {
      return /^[A-Za-z0-9]+$/.test(hash);
    }
    return false;
  }
  shouldUseIPFS(content, threshold) {
    const size = new TextEncoder().encode(content).length;
    const sizeThreshold = threshold ?? DEFAULT_IPFS_CONFIG.sizeThreshold ?? 800;
    return size > sizeThreshold;
  }
  async compressContent(content) {
    try {
      if (typeof CompressionStream !== "undefined") {
        const compressedStream = new CompressionStream("gzip");
        const writer = compressedStream.writable.getWriter();
        const reader = compressedStream.readable.getReader();
        const encoder = new TextEncoder;
        const input = encoder.encode(content);
        const writePromise = writer.write(input).then(() => writer.close());
        const chunks = [];
        const readCompressed = async () => {
          const result = await reader.read();
          const { done, value } = result;
          if (!done && value) {
            chunks.push(value);
            await readCompressed();
          }
        };
        await Promise.all([writePromise, readCompressed()]);
        const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
        const compressedData = new Uint8Array(totalLength);
        let offset = 0;
        for (const chunk of chunks) {
          compressedData.set(chunk, offset);
          offset += chunk.length;
        }
        const compressed = Buffer.from(compressedData).toString("base64");
        return {
          compressed,
          algorithm: "gzip"
        };
      } else {
        console.warn("Compression not available in this environment, storing uncompressed");
        return {
          compressed: content,
          algorithm: "none"
        };
      }
    } catch (error) {
      console.warn("Compression failed, falling back to uncompressed:", error);
      return {
        compressed: content,
        algorithm: "none"
      };
    }
  }
  async decompressContent(compressed, algorithm) {
    if (algorithm === "none") {
      return compressed;
    }
    try {
      if (algorithm === "gzip") {
        if (typeof DecompressionStream !== "undefined") {
          const decompressedStream = new DecompressionStream("gzip");
          const writer = decompressedStream.writable.getWriter();
          const reader = decompressedStream.readable.getReader();
          const compressedData = Buffer.from(compressed, "base64");
          const writePromise = writer.write(compressedData).then(() => writer.close());
          const chunks = [];
          const readDecompressed = async () => {
            const result = await reader.read();
            const { done, value } = result;
            if (!done && value) {
              chunks.push(value);
              await readDecompressed();
            }
          };
          await Promise.all([writePromise, readDecompressed()]);
          const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
          const decompressedData = new Uint8Array(totalLength);
          let offset = 0;
          for (const chunk of chunks) {
            decompressedData.set(chunk, offset);
            offset += chunk.length;
          }
          const decoder = new TextDecoder;
          return decoder.decode(decompressedData);
        } else {
          console.warn("Decompression not available in this environment, returning compressed data");
          return compressed;
        }
      } else {
        console.warn(`Unknown compression algorithm: ${algorithm}`);
        return compressed;
      }
    } catch (error) {
      console.error("Decompression failed, returning compressed data:", error);
      return compressed;
    }
  }
  getStats() {
    return {
      cacheStats: this.client.getCacheStats(),
      config: DEFAULT_IPFS_CONFIG
    };
  }
  clearCache() {
    this.client.clearCache();
  }
}, AgentModule, SAS_PROGRAM_ID, ATTESTATION_SEED = "attestation", CREDENTIAL_SEED = "credential", SCHEMA_SEED = "schema", SASAttestationHelper = class {
  static async deriveAttestationPda(credentialAddress, schemaAddress, nonce) {
    const [pda, bump] = await getProgramDerivedAddress2({
      programAddress: SAS_PROGRAM_ID,
      seeds: [
        getUtf8Encoder().encode(ATTESTATION_SEED),
        getAddressEncoder2().encode(credentialAddress),
        getAddressEncoder2().encode(schemaAddress),
        getAddressEncoder2().encode(nonce)
      ]
    });
    return {
      attestationPda: pda,
      bump
    };
  }
  static async deriveCredentialPda(issuer) {
    const [pda, bump] = await getProgramDerivedAddress2({
      programAddress: SAS_PROGRAM_ID,
      seeds: [
        getUtf8Encoder().encode(CREDENTIAL_SEED),
        getAddressEncoder2().encode(issuer)
      ]
    });
    return {
      attestationPda: pda,
      bump
    };
  }
  static async deriveSchemaPda(credentialAddress, schemaName) {
    const [pda, bump] = await getProgramDerivedAddress2({
      programAddress: SAS_PROGRAM_ID,
      seeds: [
        getUtf8Encoder().encode(SCHEMA_SEED),
        getAddressEncoder2().encode(credentialAddress),
        getUtf8Encoder().encode(schemaName)
      ]
    });
    return {
      attestationPda: pda,
      bump
    };
  }
  static serializeAttestationData(data) {
    const encoder = new TextEncoder;
    const networkBytes = encoder.encode(data.network);
    const githubBytes = data.githubUsername ? encoder.encode(data.githubUsername) : new Uint8Array;
    const twitterBytes = data.twitterHandle ? encoder.encode(data.twitterHandle) : new Uint8Array;
    const totalSize = 36 + networkBytes.length + 1 + (data.githubUsername ? 4 + githubBytes.length : 0) + 1 + (data.twitterHandle ? 4 + twitterBytes.length : 0) + 8;
    const buffer = new Uint8Array(totalSize);
    let offset = 0;
    const addressBytes = Buffer.from(data.x402PaymentAddress);
    buffer.set(addressBytes.slice(0, 32), offset);
    offset += 32;
    const networkLengthView = new DataView(buffer.buffer, offset, 4);
    networkLengthView.setUint32(0, networkBytes.length, true);
    offset += 4;
    buffer.set(networkBytes, offset);
    offset += networkBytes.length;
    if (data.githubUsername) {
      buffer[offset] = 1;
      offset += 1;
      const githubLengthView = new DataView(buffer.buffer, offset, 4);
      githubLengthView.setUint32(0, githubBytes.length, true);
      offset += 4;
      buffer.set(githubBytes, offset);
      offset += githubBytes.length;
    } else {
      buffer[offset] = 0;
      offset += 1;
    }
    if (data.twitterHandle) {
      buffer[offset] = 1;
      offset += 1;
      const twitterLengthView = new DataView(buffer.buffer, offset, 4);
      twitterLengthView.setUint32(0, twitterBytes.length, true);
      offset += 4;
      buffer.set(twitterBytes, offset);
      offset += twitterBytes.length;
    } else {
      buffer[offset] = 0;
      offset += 1;
    }
    const timestampView = new DataView(buffer.buffer, offset, 8);
    timestampView.setBigInt64(0, data.timestamp, true);
    return buffer;
  }
  static getDefaultCredentialConfig(issuer) {
    return {
      issuer,
      name: "GhostSpeak AI Agent Ownership",
      description: "Attestation proving ownership of an AI agent registered on the GhostSpeak protocol",
      schemaUri: "https://ghostspeak.ai/schemas/agent-ownership-v1.json"
    };
  }
  static isAttestationExpired(expiryTimestamp, currentTimestamp) {
    const now = currentTimestamp ?? BigInt(Math.floor(Date.now() / 1000));
    return expiryTimestamp < now;
  }
  static calculateDefaultExpiry(fromTimestamp) {
    const now = fromTimestamp ?? BigInt(Math.floor(Date.now() / 1000));
    const oneYear = BigInt(31536000);
    return now + oneYear;
  }
  static async prepareAttestation(config) {
    const { attestationPda, bump } = await this.deriveAttestationPda(config.credentialAddress, config.schemaAddress, config.x402PaymentAddress);
    const expiryTimestamp = config.expiryTimestamp ?? this.calculateDefaultExpiry();
    const attestationData = this.serializeAttestationData({
      x402PaymentAddress: config.x402PaymentAddress,
      network: config.network,
      githubUsername: config.githubUsername,
      twitterHandle: config.twitterHandle,
      timestamp: BigInt(Math.floor(Date.now() / 1000))
    });
    return {
      attestationData,
      attestationPda,
      bump,
      expiryTimestamp
    };
  }
}, DID_DOCUMENT_SEED = "did_document", GhostModule, GovernanceModule, MultisigModule, DID_DOCUMENT_SEED2 = "did_document", VerificationMethodType2, VerificationRelationship2, ServiceEndpointType2, DidError, DidErrorClass, base58Encode = (data) => esm_default2.encode(data), DEFAULT_PROGRAM_ID = "GHosT3wqDfNq9bKz8dNEQ1F5mLuN7bKdNYx3Z1111111", CredentialKind2, CredentialStatus2, CredentialModule = class {
  programId;
  didModule;
  constructor(programId = DEFAULT_PROGRAM_ID, didModule) {
    this.programId = programId;
    this.didModule = didModule;
  }
  setDidModule(didModule) {
    this.didModule = didModule;
  }
  hashSubjectData(subjectData) {
    const json = JSON.stringify(subjectData, Object.keys(subjectData).sort());
    return sha2562(new TextEncoder().encode(json));
  }
  generateCredentialId(kind, subject) {
    const timestamp = Date.now();
    const input = `${kind}-${subject}-${timestamp}`;
    const hash = sha2562(new TextEncoder().encode(input));
    const shortHash = base58Encode(hash.slice(0, 8));
    return `${kind.toLowerCase()}-${shortHash}`;
  }
  exportAsW3CCredential(credential, template, credentialType, subjectData, options2) {
    const network = options2?.network || "mainnet";
    const issuerDid = generateDidString(network, this.programId);
    const subjectDid = generateDidString(network, credential.subject);
    const statusId = `solana:${this.programId}:credential:${credential.credentialId}`;
    return {
      "@context": [
        "https://www.w3.org/ns/credentials/v2",
        "https://w3id.org/security/data-integrity/v2",
        "https://ghostspeak.io/ns/credentials/v1"
      ],
      type: ["VerifiableCredential", `GhostSpeak${credentialType.kind}Credential`],
      id: `urn:ghostspeak:${credential.credentialId}`,
      issuer: {
        id: issuerDid,
        name: "GhostSpeak Protocol"
      },
      validFrom: new Date(credential.issuedAt * 1000).toISOString(),
      validUntil: credential.expiresAt ? new Date(credential.expiresAt * 1000).toISOString() : undefined,
      credentialSubject: {
        id: subjectDid,
        ...subjectData
      },
      credentialSchema: {
        id: credentialType.schemaUri,
        type: "JsonSchema"
      },
      credentialStatus: {
        id: statusId,
        type: "SolanaAccountStatus2025",
        statusPurpose: "revocation"
      },
      relatedResource: options2?.includeRelatedResource ? [
        {
          id: credential.subjectDataUri,
          digestMultibase: `mEi${base58Encode(credential.subjectDataHash)}`
        }
      ] : undefined,
      proof: {
        type: "DataIntegrityProof",
        created: new Date(credential.issuedAt * 1000).toISOString(),
        verificationMethod: `${issuerDid}#key-1`,
        cryptosuite: "eddsa-rdfc-2022",
        proofPurpose: "assertionMethod",
        proofValue: base58Encode(credential.signature)
      }
    };
  }
  async exportWithDidResolution(credential, template, credentialType, subjectData, options2) {
    if (!this.didModule) {
      return this.exportAsW3CCredential(credential, template, credentialType, subjectData, options2);
    }
    const network = options2?.network || "mainnet";
    const issuerDid = generateDidString(network, this.programId);
    const subjectDid = generateDidString(network, credential.subject);
    const issuerDidDoc = await this.didModule.resolve(this.programId).catch(() => null);
    await this.didModule.resolve(credential.subject).catch(() => null);
    const statusId = `solana:${this.programId}:credential:${credential.credentialId}`;
    const verificationMethod = issuerDidDoc?.verificationMethods?.[0] ? `${issuerDid}#${issuerDidDoc.verificationMethods[0].id}` : `${issuerDid}#key-1`;
    return {
      "@context": [
        "https://www.w3.org/ns/credentials/v2",
        "https://w3id.org/security/data-integrity/v2",
        "https://ghostspeak.io/ns/credentials/v1"
      ],
      type: ["VerifiableCredential", `GhostSpeak${credentialType.kind}Credential`],
      id: `urn:ghostspeak:${credential.credentialId}`,
      issuer: {
        id: issuerDid,
        name: "GhostSpeak Protocol"
      },
      validFrom: new Date(credential.issuedAt * 1000).toISOString(),
      validUntil: credential.expiresAt ? new Date(credential.expiresAt * 1000).toISOString() : undefined,
      credentialSubject: {
        id: subjectDid,
        ...subjectData
      },
      credentialSchema: {
        id: credentialType.schemaUri,
        type: "JsonSchema"
      },
      credentialStatus: {
        id: statusId,
        type: "SolanaAccountStatus2025",
        statusPurpose: "revocation"
      },
      relatedResource: options2?.includeRelatedResource ? [
        {
          id: credential.subjectDataUri,
          digestMultibase: `mEi${base58Encode(credential.subjectDataHash)}`
        }
      ] : undefined,
      proof: {
        type: "DataIntegrityProof",
        created: new Date(credential.issuedAt * 1000).toISOString(),
        verificationMethod,
        cryptosuite: "eddsa-rdfc-2022",
        proofPurpose: "assertionMethod",
        proofValue: base58Encode(credential.signature)
      }
    };
  }
  static buildAgentIdentitySubject(params) {
    return params;
  }
  issueX402AgentCredential(params) {
    const now = Math.floor(Date.now() / 1000);
    const subjectData = {
      agentId: params.agentId,
      owner: params.owner,
      name: params.name,
      capabilities: params.capabilities || [],
      serviceEndpoint: params.serviceEndpoint,
      frameworkOrigin: params.frameworkOrigin,
      x402Enabled: true,
      x402PaymentAddress: params.x402PaymentAddress,
      x402AcceptedTokens: params.x402AcceptedTokens,
      x402PricePerCall: params.x402PricePerCall,
      registeredAt: now,
      verifiedAt: now,
      type: "external-x402-agent",
      verificationResponseTimeMs: params.verificationResponseTimeMs
    };
    const credentialId = this.generateCredentialId("AgentIdentity", params.agentAddress);
    const subjectDataHash = this.hashSubjectData(subjectData);
    const credential = {
      template: `x402-agent-identity-template`,
      subject: params.agentAddress,
      issuer: this.programId,
      credentialId,
      subjectDataHash,
      subjectDataUri: `data:application/json;base64,${Buffer.from(JSON.stringify(subjectData)).toString("base64")}`,
      status: "Active",
      signature: subjectDataHash,
      issuedAt: now
    };
    const credentialType = {
      authority: this.programId,
      name: "x402 Agent Identity",
      kind: "AgentIdentity",
      schemaUri: "https://ghostspeak.io/schemas/x402-agent-identity-v1.json",
      description: "Verifiable credential for x402-compatible AI agents registered with GhostSpeak",
      isActive: true,
      totalIssued: 1,
      createdAt: now
    };
    const template = {
      credentialType: credentialType.authority,
      name: "x402 Agent Identity",
      imageUri: "https://ghostspeak.io/assets/credential-badge-x402.png",
      issuer: this.programId,
      isActive: true,
      totalIssued: 1,
      createdAt: now
    };
    const w3cCredential = this.exportAsW3CCredential(credential, template, credentialType, subjectData, { network: params.network || "devnet", includeRelatedResource: true });
    return {
      credentialId,
      credential,
      w3cCredential,
      subjectData
    };
  }
  exportCredentialToJSON(credential, subjectData, options2) {
    const template = {
      credentialType: "x402-agent",
      name: credential.credentialId.includes("agentidentity") ? "Agent Identity" : "Custom",
      imageUri: "https://ghostspeak.io/assets/credential-badge.png",
      issuer: credential.issuer,
      isActive: true,
      totalIssued: 1,
      createdAt: credential.issuedAt
    };
    const credentialType = {
      authority: credential.issuer,
      name: "GhostSpeak Credential",
      kind: "AgentIdentity",
      schemaUri: "https://ghostspeak.io/schemas/credential-v1.json",
      description: "GhostSpeak verifiable credential",
      isActive: true,
      totalIssued: 1,
      createdAt: credential.issuedAt
    };
    const w3c = this.exportAsW3CCredential(credential, template, credentialType, subjectData, { network: options2?.network || "devnet", includeRelatedResource: true });
    return options2?.pretty ? JSON.stringify(w3c, null, 2) : JSON.stringify(w3c);
  }
}, ReputationModule, StakingModule;
var init_chunk_AJSWRU6F = __esm(() => {
  init_chunk_CO2WD4XR();
  init_chunk_IQM5RASO();
  init_chunk_Z6ZWNWWR();
  init_index_node40();
  init_esm();
  init_index_node5();
  init_esm3();
  init_sha256();
  MultiSourceAggregator_exports = {};
  __export2(MultiSourceAggregator_exports, {
    MultiSourceAggregator: () => MultiSourceAggregator
  });
  init_MultiSourceAggregator = __esm2({
    "src/modules/reputation/MultiSourceAggregator.ts"() {
      MultiSourceAggregator = class {
        adapters = /* @__PURE__ */ new Map;
        configs = /* @__PURE__ */ new Map;
        CONFLICT_THRESHOLD = 300;
        constructor() {}
        addSource(adapter, config) {
          if (!config.enabled) {
            return;
          }
          this.adapters.set(adapter.source, adapter);
          this.configs.set(adapter.source, config);
        }
        removeSource(source) {
          this.adapters.delete(source);
          this.configs.delete(source);
        }
        updateSourceWeight(source, weight) {
          const config = this.configs.get(source);
          if (config) {
            config.weight = weight;
          }
        }
        updateSourceReliability(source, reliability) {
          const config = this.configs.get(source);
          if (config) {
            config.reliability = reliability;
          }
        }
        async aggregateReputation(agentId) {
          const sourceDataList = [];
          for (const [source, adapter] of this.adapters.entries()) {
            try {
              const data = await adapter.fetchReputationData(agentId.toString());
              if (adapter.validateData(data)) {
                sourceDataList.push(data);
              }
            } catch (error) {
              console.warn(`Failed to fetch reputation from ${source}:`, error);
            }
          }
          const aggregateScore = this.calculateWeightedScore(sourceDataList);
          const { hasConflicts, conflicts } = this.detectConflicts(sourceDataList);
          const sourceScores = this.buildSourceBreakdowns(sourceDataList);
          const totalDataPoints = sourceDataList.reduce((sum, data) => sum + data.dataPoints, 0);
          return {
            agentId,
            aggregateScore,
            sourceScores,
            hasConflicts,
            conflicts,
            totalDataPoints,
            timestamp: /* @__PURE__ */ new Date
          };
        }
        calculateWeightedScore(sourceDataList) {
          if (sourceDataList.length === 0) {
            return 0;
          }
          let totalContribution = 0;
          let totalNormalization = 0;
          for (const data of sourceDataList) {
            const config = this.configs.get(data.source);
            if (!config)
              continue;
            const weight = config.weight / 1e4;
            const reliability = data.reliability;
            const contribution = data.score * weight * reliability;
            const normalization = weight * reliability;
            totalContribution += contribution;
            totalNormalization += normalization;
          }
          if (totalNormalization === 0) {
            return 0;
          }
          return Math.round(totalContribution / totalNormalization);
        }
        detectConflicts(sourceDataList) {
          if (sourceDataList.length < 2) {
            return { hasConflicts: false, conflicts: [] };
          }
          const scores = sourceDataList.map((d) => d.score);
          const maxScore = Math.max(...scores);
          const minScore = Math.min(...scores);
          const variance = maxScore - minScore;
          const conflicts = [];
          if (variance > this.CONFLICT_THRESHOLD) {
            const maxSource = sourceDataList.find((d) => d.score === maxScore)?.source;
            const minSource = sourceDataList.find((d) => d.score === minScore)?.source;
            conflicts.push(`High variance detected: ${variance} (${(variance / 1000 * 100).toFixed(1)}%) between ${maxSource} (${maxScore}) and ${minSource} (${minScore})`);
            return { hasConflicts: true, conflicts };
          }
          return { hasConflicts: false, conflicts: [] };
        }
        buildSourceBreakdowns(sourceDataList) {
          return sourceDataList.map((data) => {
            const config = this.configs.get(data.source);
            if (!config) {
              throw new Error(`No config found for source: ${data.source}`);
            }
            const weight = config.weight;
            const reliability = data.reliability * 1e4;
            const contribution = data.score * (weight / 1e4) * (reliability / 1e4) / this.calculateNormalizationFactor(sourceDataList);
            return {
              source: data.source,
              score: data.score,
              weight,
              reliability: Math.round(reliability),
              dataPoints: data.dataPoints,
              contribution: Math.round(contribution),
              lastUpdated: data.timestamp
            };
          });
        }
        calculateNormalizationFactor(sourceDataList) {
          let total = 0;
          for (const data of sourceDataList) {
            const config = this.configs.get(data.source);
            if (!config)
              continue;
            const weight = config.weight / 1e4;
            const reliability = data.reliability;
            total += weight * reliability;
          }
          return total || 1;
        }
        async getSourceBreakdown(agentId) {
          const result = await this.aggregateReputation(agentId);
          return result.sourceScores;
        }
        getRegisteredSources() {
          return Array.from(this.adapters.keys());
        }
        getSourceConfig(source) {
          return this.configs.get(source);
        }
        enableSource(source) {
          const config = this.configs.get(source);
          if (config) {
            config.enabled = true;
          }
        }
        disableSource(source) {
          const config = this.configs.get(source);
          if (config) {
            config.enabled = false;
          }
        }
        isSourceEnabled(source) {
          const config = this.configs.get(source);
          return config?.enabled ?? false;
        }
      };
    }
  });
  DEFAULT_TTLS = {
    processed: 500,
    confirmed: 2000,
    finalized: 30000
  };
  DEFAULT_IPFS_CONFIG = {
    provider: {
      name: "pinata",
      endpoint: "https://api.pinata.cloud"
    },
    gateways: [
      "https://gateway.pinata.cloud",
      "https://ipfs.io",
      "https://cloudflare-ipfs.com",
      "https://gateway.ipfs.io"
    ],
    autoPinning: true,
    sizeThreshold: 800,
    maxRetries: 3,
    retryDelay: 1000,
    enableCache: true,
    cacheTTL: 300000
  };
  AgentModule = class extends BaseModule {
    ipfsUtils = null;
    constructor(config) {
      super(config);
      if (config.ipfsConfig) {
        this.ipfsUtils = createIPFSUtils(config.ipfsConfig);
      }
    }
    async register(signer, params) {
      const pricingModel = params.pricingModel ?? 0;
      const registerGetter = async () => {
        const agentAccount = await this.deriveAgentPda(params.agentId, signer.address);
        const ix = await getRegisterAgentInstructionAsync({
          agentAccount,
          signer,
          systemProgram: this.systemProgramId,
          agentType: params.agentType,
          name: params.name,
          description: params.description,
          metadataUri: params.metadataUri,
          agentId: params.agentId,
          pricingModel
        });
        return ix;
      };
      const heapGetter = () => {
        const heapData = new Uint8Array(5);
        heapData[0] = 1;
        new DataView(heapData.buffer).setUint32(1, 262144, true);
        return {
          programAddress: "ComputeBudget111111111111111111111111111111",
          accounts: [],
          data: heapData
        };
      };
      this.debug();
      if (params.skipSimulation) {
        console.log("\uD83D\uDE80 SKIPPING SIMULATION - Sending transaction directly");
        return this.builder.executeBatch("registerAgent", [heapGetter, registerGetter], [signer], { simulate: false, skipPreflight: true });
      }
      return this.builder.executeBatch("registerAgent", [heapGetter, registerGetter], [signer]);
    }
    async registerCompressed(signer, params) {
      const instructionGetter = async () => {
        const treeConfig = params.treeConfig || await this.deriveTreeConfigPda(signer.address);
        const result = await getRegisterAgentCompressedInstructionAsync({
          merkleTree: params.merkleTree,
          treeAuthority: treeConfig,
          signer,
          systemProgram: this.systemProgramId,
          compressionProgram: this.compressionProgramId,
          agentType: params.agentType,
          name: params.name,
          description: params.description,
          metadataUri: params.metadataUri,
          agentId: params.agentId,
          pricingModel: params.pricingModel ?? 0,
          logWrapper: "noopb9bkMVfRPU8AsbpTUg8AQkHtKwMYZiFUjNRtMmV"
        });
        return result;
      };
      return this.execute("registerAgentCompressed", instructionGetter, [signer]);
    }
    async update(signer, params) {
      const instructionGetter = () => {
        const result = getUpdateAgentInstruction({
          agentAccount: params.agentAddress,
          signer,
          metadataUri: params.metadataUri,
          agentType: params.agentType,
          agentId: params.agentId,
          name: params.name ?? null,
          description: params.description ?? null,
          pricingModel: params.pricingModel ?? 0
        });
        return result;
      };
      return this.execute("updateAgent", instructionGetter, [signer]);
    }
    async verify(signer, params) {
      const instructionGetter = async () => {
        const result = await getVerifyAgentInstructionAsync({
          agent: params.agentAddress,
          verifier: signer,
          agentPubkey: params.agentPubkey,
          serviceEndpoint: params.serviceEndpoint,
          supportedCapabilities: params.supportedCapabilities,
          verifiedAt: params.verifiedAt
        });
        return result;
      };
      return this.execute("verifyAgent", instructionGetter, [signer]);
    }
    async deactivate(signer, params) {
      const instructionGetter = () => {
        const result = getDeactivateAgentInstruction({
          agentAccount: params.agentAddress,
          signer,
          agentId: params.agentId
        });
        return result;
      };
      return this.execute("deactivateAgent", instructionGetter, [signer]);
    }
    async activate(signer, params) {
      const instructionGetter = () => {
        const result = getActivateAgentInstruction({
          agentAccount: params.agentAddress,
          signer,
          agentId: params.agentId
        });
        return result;
      };
      return this.execute("activateAgent", instructionGetter, [signer]);
    }
    async getAgentAccount(address22) {
      return super.getAccount(address22, "getAgentDecoder");
    }
    async getAllAgents() {
      return this.getProgramAccounts("getAgentDecoder");
    }
    async getAgentsByType(agentType) {
      const typeBytes = Buffer.alloc(1);
      typeBytes.writeUInt8(agentType, 0);
      const filters = [{
        memcmp: {
          offset: BigInt(8),
          bytes: typeBytes.toString("base64"),
          encoding: "base64"
        }
      }];
      return this.getProgramAccounts("getAgentDecoder", filters);
    }
    async getUserAgents(authority) {
      const filters = [{
        memcmp: {
          offset: BigInt(9),
          bytes: authority,
          encoding: "base58"
        }
      }];
      return this.getProgramAccounts("getAgentDecoder", filters);
    }
    async batchGetAgents(addresses2, onProgress) {
      return super.getAccounts(addresses2, "getAgentDecoder");
    }
    async batchGetExistingAgents(addresses2, onProgress) {
      const { batchGetExistingAccounts: batchGetExistingAccounts2 } = await Promise.resolve().then(() => (init_batch_operations_OUWQNZGJ(), exports_batch_operations_OUWQNZGJ));
      return batchGetExistingAccounts2(this.config.rpc, addresses2, { onProgress });
    }
    async batchGetAndMapAgents(addresses2, mapper) {
      const { batchGetAndMap: batchGetAndMap2 } = await Promise.resolve().then(() => (init_batch_operations_OUWQNZGJ(), exports_batch_operations_OUWQNZGJ));
      return batchGetAndMap2(this.config.rpc, addresses2, mapper);
    }
    async deriveAgentPda(agentId, owner) {
      const { deriveAgentPda: deriveAgentPda2 } = await Promise.resolve().then(() => (init_pda_LDG2B6LK(), exports_pda_LDG2B6LK));
      const [address22] = await deriveAgentPda2({ programAddress: this.programId, owner, agentId });
      return address22;
    }
    async deriveUserRegistryPda(owner) {
      const { deriveUserRegistryPda: deriveUserRegistryPda2 } = await Promise.resolve().then(() => (init_pda_LDG2B6LK(), exports_pda_LDG2B6LK));
      return deriveUserRegistryPda2(this.programId, owner);
    }
    async deriveTreeConfigPda(owner) {
      const { getProgramDerivedAddress: getProgramDerivedAddress4, getAddressEncoder: getAddressEncoder4 } = await Promise.resolve().then(() => (init_index_node5(), exports_index_node));
      const addressEncoder = getAddressEncoder4();
      const ownerBytes = addressEncoder.encode(owner);
      const [pda] = await getProgramDerivedAddress4({
        programAddress: this.programId,
        seeds: [
          new TextEncoder().encode("agent_tree_config"),
          ownerBytes
        ]
      });
      return pda;
    }
    get systemProgramId() {
      return SYSTEM_PROGRAM_ADDRESS3;
    }
    get compressionProgramId() {
      return "cmtDvXumGCrqC1Age74AVPhSRVXJMd8PJS91L8KbNCK";
    }
  };
  SAS_PROGRAM_ID = address("22zoJMtdu4tQc2PzL74ZUT7FrwgB1Udec8DdW4yw4BdG");
  GhostModule = class extends BaseModule {
    constructor(config) {
      super(config);
    }
    async claim(claimer, params) {
      const prepared = await this.prepareClaim(params);
      const instructionGetter = () => {
        return getClaimGhostInstruction({
          agentAccount: params.agentAddress,
          didDocument: prepared.didDocumentPda,
          sasAttestation: prepared.attestationPda,
          claimer,
          systemProgram: this.systemProgramId,
          sasCredential: params.sasCredential,
          sasSchema: params.sasSchema,
          ipfsMetadataUri: params.ipfsMetadataUri ?? null,
          network: params.network
        });
      };
      return this.execute("claimGhost", instructionGetter, [claimer]);
    }
    async prepareClaim(params) {
      const { attestationPda, bump: attestationBump } = await SASAttestationHelper.deriveAttestationPda(params.sasCredential, params.sasSchema, params.x402PaymentAddress);
      const [didDocumentPda, didDocumentBump] = await this.deriveDidDocumentPda(params.x402PaymentAddress);
      return {
        attestationPda,
        didDocumentPda,
        attestationBump,
        didDocumentBump
      };
    }
    async getGhostAgent(address22) {
      return super.getAccount(address22, "getAgentDecoder");
    }
    async getAllGhosts() {
      const GHOST_AGENT_TYPE = 10;
      return this.getGhostsByType(GHOST_AGENT_TYPE);
    }
    async getGhostsByType(agentType = 10) {
      const typeBytes = Buffer.alloc(1);
      typeBytes.writeUInt8(agentType, 0);
      const filters = [{
        memcmp: {
          offset: BigInt(8),
          bytes: typeBytes.toString("base64"),
          encoding: "base64"
        }
      }];
      return this.getProgramAccounts("getAgentDecoder", filters);
    }
    async getClaimedGhosts(owner) {
      const filters = [{
        memcmp: {
          offset: BigInt(9),
          bytes: owner,
          encoding: "base58"
        }
      }];
      return this.getProgramAccounts("getAgentDecoder", filters);
    }
    async validateClaim(params) {
      const errors2 = [];
      const warnings = [];
      const validNetworks = ["devnet", "testnet", "mainnet-beta", "localnet"];
      if (!validNetworks.includes(params.network)) {
        errors2.push(`Invalid network: ${params.network}. Must be one of: ${validNetworks.join(", ")}`);
      }
      if (params.ipfsMetadataUri && !params.ipfsMetadataUri.startsWith("ipfs://")) {
        warnings.push('IPFS metadata URI should start with "ipfs://"');
      }
      const agent = await this.getGhostAgent(params.agentAddress);
      if (!agent) {
        errors2.push(`Agent not found at address: ${params.agentAddress}`);
      } else {
        if (agent.owner !== null) {
          errors2.push(`Agent is already claimed by: ${agent.owner}`);
        }
        if (agent.agentType !== 10) {
          warnings.push(`Agent type is ${agent.agentType}, expected 10 (external x402 agent)`);
        }
      }
      return {
        valid: errors2.length === 0,
        errors: errors2,
        warnings
      };
    }
    async deriveDidDocumentPda(x402PaymentAddress) {
      const [pda, bump] = await getProgramDerivedAddress2({
        programAddress: this.programId,
        seeds: [
          getUtf8Encoder().encode(DID_DOCUMENT_SEED),
          getAddressEncoder2().encode(x402PaymentAddress)
        ]
      });
      return [pda, bump];
    }
    get systemProgramId() {
      return SYSTEM_PROGRAM_ADDRESS3;
    }
  };
  GovernanceModule = class extends BaseModule {
    getInitializeGovernanceProposalInstruction(params) {
      return getInitializeGovernanceProposalInstructionAsync(params);
    }
    async createProposal(params) {
      const proposalAddress = this.deriveProposalPda(params.signer.address, params.title);
      const instruction = await this.getInitializeGovernanceProposalInstruction({
        proposal: proposalAddress,
        proposer: params.signer,
        title: params.title,
        description: params.description,
        proposalType: { kind: params.proposalType, data: {} },
        executionParams: {
          instructions: [],
          accounts: [],
          targetProgram: proposalAddress,
          executeAfter: BigInt(params.executionDelay ?? 0)
        },
        proposalId: BigInt(Date.now())
      });
      return this.execute("createProposal", () => instruction, [params.signer]);
    }
    async getProposal(address22) {
      return super.getAccount(address22, "getGovernanceProposalDecoder");
    }
    async getActiveProposals() {
      return this.getProgramAccounts("getGovernanceProposalDecoder");
    }
    async getProposalsByProposer(proposer) {
      const filters = [{
        memcmp: {
          offset: BigInt(8),
          bytes: proposer,
          encoding: "base58"
        }
      }];
      return this.getProgramAccounts("getGovernanceProposalDecoder", filters);
    }
    async getProposalsByStatus(_status) {
      const allProposals = await this.getProgramAccounts("getGovernanceProposalDecoder");
      return allProposals.filter((_proposal) => {
        return allProposals.length > 0;
      });
    }
    deriveProposalPda(proposer, title) {
      return `proposal_${proposer}_${title}`;
    }
  };
  MultisigModule = class extends BaseModule {
    async createMultisig(params) {
      throw new Error("createMultisig: Instruction not available - requires IDL regeneration");
    }
    async createProposal(params) {
      const instruction = await getInitializeGovernanceProposalInstructionAsync({
        proposer: params.proposer,
        proposalId: params.proposalId,
        title: params.title,
        description: params.description,
        proposalType: params.proposalType,
        executionParams: params.executionParams
      }, { programAddress: this.programId });
      return this.execute("createProposal", () => instruction, [params.proposer]);
    }
    async executeProposal(params) {
      throw new Error("executeProposal: Use protocol_config instructions for execution");
    }
  };
  VerificationMethodType2 = /* @__PURE__ */ ((VerificationMethodType22) => {
    VerificationMethodType22["Ed25519VerificationKey2020"] = "Ed25519VerificationKey2020";
    VerificationMethodType22["X25519KeyAgreementKey2020"] = "X25519KeyAgreementKey2020";
    VerificationMethodType22["EcdsaSecp256k1VerificationKey2019"] = "EcdsaSecp256k1VerificationKey2019";
    return VerificationMethodType22;
  })(VerificationMethodType2 || {});
  VerificationRelationship2 = /* @__PURE__ */ ((VerificationRelationship22) => {
    VerificationRelationship22["Authentication"] = "authentication";
    VerificationRelationship22["AssertionMethod"] = "assertionMethod";
    VerificationRelationship22["KeyAgreement"] = "keyAgreement";
    VerificationRelationship22["CapabilityInvocation"] = "capabilityInvocation";
    VerificationRelationship22["CapabilityDelegation"] = "capabilityDelegation";
    return VerificationRelationship22;
  })(VerificationRelationship2 || {});
  ServiceEndpointType2 = /* @__PURE__ */ ((ServiceEndpointType22) => {
    ServiceEndpointType22["AIAgentService"] = "AIAgentService";
    ServiceEndpointType22["DIDCommMessaging"] = "DIDCommMessaging";
    ServiceEndpointType22["CredentialRepository"] = "CredentialRepository";
    ServiceEndpointType22["LinkedDomains"] = "LinkedDomains";
    ServiceEndpointType22["Custom"] = "Custom";
    return ServiceEndpointType22;
  })(ServiceEndpointType2 || {});
  DidError = /* @__PURE__ */ ((DidError2) => {
    DidError2["AlreadyDeactivated"] = "AlreadyDeactivated";
    DidError2["TooManyVerificationMethods"] = "TooManyVerificationMethods";
    DidError2["TooManyServiceEndpoints"] = "TooManyServiceEndpoints";
    DidError2["DuplicateMethodId"] = "DuplicateMethodId";
    DidError2["DuplicateServiceId"] = "DuplicateServiceId";
    DidError2["MethodNotFound"] = "MethodNotFound";
    DidError2["ServiceNotFound"] = "ServiceNotFound";
    DidError2["InvalidDidFormat"] = "InvalidDidFormat";
    DidError2["UnauthorizedDidOperation"] = "UnauthorizedDidOperation";
    DidError2["DidDeactivated"] = "DidDeactivated";
    return DidError2;
  })(DidError || {});
  DidErrorClass = class extends Error {
    code;
    constructor(code, message) {
      super(message || code);
      this.name = "DidError";
      this.code = code;
    }
  };
  CredentialKind2 = /* @__PURE__ */ ((CredentialKind22) => {
    CredentialKind22["AgentIdentity"] = "AgentIdentity";
    CredentialKind22["ReputationScore"] = "ReputationScore";
    CredentialKind22["JobCompletion"] = "JobCompletion";
    CredentialKind22["DelegatedSigner"] = "DelegatedSigner";
    CredentialKind22["Custom"] = "Custom";
    return CredentialKind22;
  })(CredentialKind2 || {});
  CredentialStatus2 = /* @__PURE__ */ ((CredentialStatus22) => {
    CredentialStatus22["Pending"] = "Pending";
    CredentialStatus22["Active"] = "Active";
    CredentialStatus22["Revoked"] = "Revoked";
    CredentialStatus22["Expired"] = "Expired";
    return CredentialStatus22;
  })(CredentialStatus2 || {});
  init_reputation_tag_engine();
  ReputationModule = class extends BaseModule {
    calculator;
    tagEngine;
    constructor(config) {
      super(config);
      this.calculator = new ReputationCalculator;
      this.tagEngine = new ReputationTagEngine;
    }
    calculateReputationChange(currentData, jobPerformance) {
      return this.calculator.calculateReputation(currentData, jobPerformance);
    }
    getTierName(tier) {
      switch (tier) {
        case "None":
          return "Unranked";
        case "Bronze":
          return "Bronze";
        case "Silver":
          return "Silver";
        case "Gold":
          return "Gold";
        case "Platinum":
          return "Platinum";
        default:
          return "Unknown";
      }
    }
    getTierFromScore(score) {
      if (score >= REPUTATION_CONSTANTS.PLATINUM_TIER_THRESHOLD) {
        return "Platinum";
      } else if (score >= REPUTATION_CONSTANTS.GOLD_TIER_THRESHOLD) {
        return "Gold";
      } else if (score >= REPUTATION_CONSTANTS.SILVER_TIER_THRESHOLD) {
        return "Silver";
      } else if (score >= REPUTATION_CONSTANTS.BRONZE_TIER_THRESHOLD) {
        return "Bronze";
      }
      return "None";
    }
    getBadgeName(badge) {
      switch (badge) {
        case "FirstJob":
          return "First Job";
        case "TenJobs":
          return "10 Jobs";
        case "HundredJobs":
          return "100 Jobs";
        case "ThousandJobs":
          return "1000 Jobs";
        case "PerfectRating":
          return "Perfect Rating";
        case "QuickResponder":
          return "Quick Responder";
        case "DisputeResolver":
          return "Dispute Resolver";
        case "CategoryExpert":
          return "Category Expert";
        case "CrossCategoryMaster":
          return "Cross-Category Master";
        default:
          return "Unknown Badge";
      }
    }
    calculateApyBoost(score) {
      return Math.floor(score / 1000) * 50;
    }
    getTierColor(tier) {
      switch (tier) {
        case "Platinum":
          return "#E5E4E2";
        case "Gold":
          return "#FFD700";
        case "Silver":
          return "#C0C0C0";
        case "Bronze":
          return "#CD7F32";
        default:
          return "#808080";
      }
    }
    createDefaultReputationData(agentAddress) {
      return {
        agent: agentAddress,
        overallScore: 5000,
        totalJobsCompleted: 0,
        totalJobsFailed: 0,
        avgResponseTime: 0,
        disputesAgainst: 0,
        disputesResolved: 0,
        lastUpdated: Math.floor(Date.now() / 1000),
        categoryReputations: [],
        badges: [],
        performanceHistory: [],
        factors: {
          completionWeight: 25,
          qualityWeight: 25,
          timelinessWeight: 20,
          satisfactionWeight: 20,
          disputeWeight: 10
        }
      };
    }
    qualifiesForTier(score, tier) {
      switch (tier) {
        case "Platinum":
          return score >= REPUTATION_CONSTANTS.PLATINUM_TIER_THRESHOLD;
        case "Gold":
          return score >= REPUTATION_CONSTANTS.GOLD_TIER_THRESHOLD;
        case "Silver":
          return score >= REPUTATION_CONSTANTS.SILVER_TIER_THRESHOLD;
        case "Bronze":
          return score >= REPUTATION_CONSTANTS.BRONZE_TIER_THRESHOLD;
        default:
          return true;
      }
    }
    pointsToNextTier(score) {
      const currentTier = this.getTierFromScore(score);
      switch (currentTier) {
        case "None":
          return { nextTier: "Bronze", pointsNeeded: REPUTATION_CONSTANTS.BRONZE_TIER_THRESHOLD - score };
        case "Bronze":
          return { nextTier: "Silver", pointsNeeded: REPUTATION_CONSTANTS.SILVER_TIER_THRESHOLD - score };
        case "Silver":
          return { nextTier: "Gold", pointsNeeded: REPUTATION_CONSTANTS.GOLD_TIER_THRESHOLD - score };
        case "Gold":
          return { nextTier: "Platinum", pointsNeeded: REPUTATION_CONSTANTS.PLATINUM_TIER_THRESHOLD - score };
        case "Platinum":
          return null;
        default:
          return null;
      }
    }
    recordPayAIPayment(record, currentData) {
      const jobPerformance = this.payAIRecordToJobPerformance(record);
      return this.calculateReputationChange(currentData, jobPerformance);
    }
    payAIRecordToJobPerformance(record) {
      const qualityRating = this.estimateQualityFromResponseTime(record.responseTimeMs);
      const expectedDuration = this.estimateExpectedDuration(record.amount);
      return {
        completed: record.success,
        qualityRating,
        expectedDuration,
        actualDuration: Math.ceil(record.responseTimeMs / 1000),
        clientSatisfaction: record.success ? qualityRating : 20,
        hadDispute: false,
        disputeResolvedFavorably: false,
        category: this.categorizeFromNetwork(record.network),
        paymentAmount: Number(record.amount) / 1e6
      };
    }
    estimateQualityFromResponseTime(responseTimeMs) {
      if (responseTimeMs <= 500) {
        return 100;
      } else if (responseTimeMs <= 2000) {
        return Math.round(90 - (responseTimeMs - 500) / 1500 * 20);
      } else if (responseTimeMs <= 1e4) {
        return Math.round(70 - (responseTimeMs - 2000) / 8000 * 30);
      } else {
        return Math.max(20, Math.round(40 - (responseTimeMs - 1e4) / 50000 * 20));
      }
    }
    estimateExpectedDuration(amountBaseUnits) {
      const amountUSDC = Number(amountBaseUnits) / 1e6;
      return Math.max(2, Math.ceil(2 + amountUSDC * 10));
    }
    categorizeFromNetwork(network) {
      switch (network) {
        case "solana":
          return "ai-services-solana";
        case "base":
          return "ai-services-base";
        case "ethereum":
          return "ai-services-ethereum";
        default:
          return "ai-services";
      }
    }
    createPayAIPerformanceSnapshot(record, reputationResult) {
      return {
        timestamp: record.timestamp.getTime(),
        paymentId: record.paymentSignature,
        network: record.network,
        amount: record.amount.toString(),
        success: record.success,
        responseTimeMs: record.responseTimeMs,
        reputationChange: reputationResult.jobScore,
        newScore: reputationResult.overallScore,
        tier: reputationResult.tier
      };
    }
    async calculateTagsForAgent(metrics) {
      return this.tagEngine.calculateTags(metrics);
    }
    getTagsByCategory(tags, category) {
      return this.tagEngine.filterTags(tags, { category });
    }
    hasTag(tags, tagName) {
      return tags.some((tag) => tag.tagName === tagName);
    }
    getTagConfidence(tags, tagName) {
      const tag = tags.find((t) => t.tagName === tagName);
      return tag?.confidence;
    }
    filterTags(tags, filters) {
      return this.tagEngine.filterTags(tags, filters);
    }
    applyTagDecay(tags, currentTimestamp) {
      return this.tagEngine.applyTagDecay(tags, currentTimestamp);
    }
    mergeTags(existingTags, newTags) {
      return this.tagEngine.mergeTags(existingTags, newTags);
    }
    categorizeTags(tags) {
      return this.tagEngine.categorizeTags(tags);
    }
    getTopTags(tags, count) {
      return this.tagEngine.getTopTags(tags, count);
    }
    sortTagsByConfidence(tags) {
      return this.tagEngine.sortByConfidence(tags);
    }
    sortTagsByEvidence(tags) {
      return this.tagEngine.sortByEvidence(tags);
    }
    sortTagsByRecent(tags) {
      return this.tagEngine.sortByRecent(tags);
    }
    getConfidenceLevel(confidence) {
      return this.tagEngine.getConfidenceLevel(confidence);
    }
    validateTagName(tagName) {
      return this.tagEngine.validateTagName(tagName);
    }
    validateConfidence(confidence) {
      return this.tagEngine.validateConfidence(confidence);
    }
    convertMetricsForTagging(onChainMetrics) {
      const avgResponseTime = onChainMetrics.responseTimeCount > 0n ? Number(onChainMetrics.totalResponseTime / onChainMetrics.responseTimeCount) : 0;
      const totalPayments = onChainMetrics.successfulPayments + onChainMetrics.failedPayments;
      const successRate = totalPayments > 0n ? Number(onChainMetrics.successfulPayments * 10000n / totalPayments) : 0;
      const avgRating = onChainMetrics.totalRatingsCount > 0 ? Math.floor(onChainMetrics.totalRating * 100 / (onChainMetrics.totalRatingsCount * 5)) : 0;
      const disputeResolutionRate = onChainMetrics.totalDisputes > 0 ? Math.floor(onChainMetrics.disputesResolved * 1e4 / onChainMetrics.totalDisputes) : 1e4;
      return {
        successfulPayments: onChainMetrics.successfulPayments,
        failedPayments: onChainMetrics.failedPayments,
        totalResponseTime: onChainMetrics.totalResponseTime,
        responseTimeCount: onChainMetrics.responseTimeCount,
        totalDisputes: onChainMetrics.totalDisputes,
        disputesResolved: onChainMetrics.disputesResolved,
        totalRating: onChainMetrics.totalRating,
        totalRatingsCount: onChainMetrics.totalRatingsCount,
        createdAt: onChainMetrics.createdAt,
        updatedAt: onChainMetrics.updatedAt,
        avgResponseTime,
        successRate,
        avgRating,
        disputeResolutionRate
      };
    }
  };
  StakingModule = class extends BaseModule {
    async initializeStakingConfig(params) {
      const instruction = await getInitializeStakingConfigInstructionAsync({
        authority: params.authority,
        minStake: params.minStake,
        treasury: params.treasury
      }, { programAddress: this.programId });
      return this.execute("initializeStakingConfig", () => instruction, [params.authority]);
    }
    async stake(params) {
      const instruction = await getStakeGhostInstructionAsync({
        ownerTokenAccount: params.agentTokenAccount,
        stakingVault: params.stakingVault,
        stakingConfig: params.stakingConfig,
        ghostMint: params.ghostMint,
        owner: params.agentOwner,
        amount: params.amount,
        lockDuration: params.lockDuration
      }, { programAddress: this.programId });
      return this.execute("stakeGhost", () => instruction, [params.agentOwner]);
    }
    async unstake(params) {
      const instruction = await getUnstakeGhostInstructionAsync({
        stakingAccount: params.stakingAccount,
        stakingVault: params.stakingVault,
        ownerTokenAccount: params.agentTokenAccount,
        owner: params.agentOwner
      }, { programAddress: this.programId });
      return this.execute("unstakeGhost", () => instruction, [params.agentOwner]);
    }
    async getStakingAccount(stakingAccountAddress) {
      try {
        return await this.getAccount(stakingAccountAddress, "getStakingAccountDecoder");
      } catch (error) {
        console.error("Error fetching staking account:", error);
        return null;
      }
    }
    async getStakingConfig(stakingConfigAddress) {
      try {
        return await this.getAccount(stakingConfigAddress, "getStakingConfigDecoder");
      } catch (error) {
        console.error("Error fetching staking config:", error);
        return null;
      }
    }
  };
});

// ../../node_modules/.bun/tweetnacl@1.0.3/node_modules/tweetnacl/nacl-fast.js
var require_nacl_fast = __commonJS((exports, module) => {
  (function(nacl) {
    var gf = function(init) {
      var i, r = new Float64Array(16);
      if (init)
        for (i = 0;i < init.length; i++)
          r[i] = init[i];
      return r;
    };
    var randombytes = function() {
      throw new Error("no PRNG");
    };
    var _0 = new Uint8Array(16);
    var _9 = new Uint8Array(32);
    _9[0] = 9;
    var gf0 = gf(), gf1 = gf([1]), _121665 = gf([56129, 1]), D3 = gf([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), D22 = gf([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), X = gf([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), Y = gf([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), I = gf([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
    function ts64(x, i, h, l2) {
      x[i] = h >> 24 & 255;
      x[i + 1] = h >> 16 & 255;
      x[i + 2] = h >> 8 & 255;
      x[i + 3] = h & 255;
      x[i + 4] = l2 >> 24 & 255;
      x[i + 5] = l2 >> 16 & 255;
      x[i + 6] = l2 >> 8 & 255;
      x[i + 7] = l2 & 255;
    }
    function vn(x, xi, y, yi, n) {
      var i, d = 0;
      for (i = 0;i < n; i++)
        d |= x[xi + i] ^ y[yi + i];
      return (1 & d - 1 >>> 8) - 1;
    }
    function crypto_verify_16(x, xi, y, yi) {
      return vn(x, xi, y, yi, 16);
    }
    function crypto_verify_32(x, xi, y, yi) {
      return vn(x, xi, y, yi, 32);
    }
    function core_salsa20(o4, p, k, c) {
      var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
      var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
      for (var i = 0;i < 20; i += 2) {
        u = x0 + x12 | 0;
        x4 ^= u << 7 | u >>> 32 - 7;
        u = x4 + x0 | 0;
        x8 ^= u << 9 | u >>> 32 - 9;
        u = x8 + x4 | 0;
        x12 ^= u << 13 | u >>> 32 - 13;
        u = x12 + x8 | 0;
        x0 ^= u << 18 | u >>> 32 - 18;
        u = x5 + x1 | 0;
        x9 ^= u << 7 | u >>> 32 - 7;
        u = x9 + x5 | 0;
        x13 ^= u << 9 | u >>> 32 - 9;
        u = x13 + x9 | 0;
        x1 ^= u << 13 | u >>> 32 - 13;
        u = x1 + x13 | 0;
        x5 ^= u << 18 | u >>> 32 - 18;
        u = x10 + x6 | 0;
        x14 ^= u << 7 | u >>> 32 - 7;
        u = x14 + x10 | 0;
        x2 ^= u << 9 | u >>> 32 - 9;
        u = x2 + x14 | 0;
        x6 ^= u << 13 | u >>> 32 - 13;
        u = x6 + x2 | 0;
        x10 ^= u << 18 | u >>> 32 - 18;
        u = x15 + x11 | 0;
        x3 ^= u << 7 | u >>> 32 - 7;
        u = x3 + x15 | 0;
        x7 ^= u << 9 | u >>> 32 - 9;
        u = x7 + x3 | 0;
        x11 ^= u << 13 | u >>> 32 - 13;
        u = x11 + x7 | 0;
        x15 ^= u << 18 | u >>> 32 - 18;
        u = x0 + x3 | 0;
        x1 ^= u << 7 | u >>> 32 - 7;
        u = x1 + x0 | 0;
        x2 ^= u << 9 | u >>> 32 - 9;
        u = x2 + x1 | 0;
        x3 ^= u << 13 | u >>> 32 - 13;
        u = x3 + x2 | 0;
        x0 ^= u << 18 | u >>> 32 - 18;
        u = x5 + x4 | 0;
        x6 ^= u << 7 | u >>> 32 - 7;
        u = x6 + x5 | 0;
        x7 ^= u << 9 | u >>> 32 - 9;
        u = x7 + x6 | 0;
        x4 ^= u << 13 | u >>> 32 - 13;
        u = x4 + x7 | 0;
        x5 ^= u << 18 | u >>> 32 - 18;
        u = x10 + x9 | 0;
        x11 ^= u << 7 | u >>> 32 - 7;
        u = x11 + x10 | 0;
        x8 ^= u << 9 | u >>> 32 - 9;
        u = x8 + x11 | 0;
        x9 ^= u << 13 | u >>> 32 - 13;
        u = x9 + x8 | 0;
        x10 ^= u << 18 | u >>> 32 - 18;
        u = x15 + x14 | 0;
        x12 ^= u << 7 | u >>> 32 - 7;
        u = x12 + x15 | 0;
        x13 ^= u << 9 | u >>> 32 - 9;
        u = x13 + x12 | 0;
        x14 ^= u << 13 | u >>> 32 - 13;
        u = x14 + x13 | 0;
        x15 ^= u << 18 | u >>> 32 - 18;
      }
      x0 = x0 + j0 | 0;
      x1 = x1 + j1 | 0;
      x2 = x2 + j2 | 0;
      x3 = x3 + j3 | 0;
      x4 = x4 + j4 | 0;
      x5 = x5 + j5 | 0;
      x6 = x6 + j6 | 0;
      x7 = x7 + j7 | 0;
      x8 = x8 + j8 | 0;
      x9 = x9 + j9 | 0;
      x10 = x10 + j10 | 0;
      x11 = x11 + j11 | 0;
      x12 = x12 + j12 | 0;
      x13 = x13 + j13 | 0;
      x14 = x14 + j14 | 0;
      x15 = x15 + j15 | 0;
      o4[0] = x0 >>> 0 & 255;
      o4[1] = x0 >>> 8 & 255;
      o4[2] = x0 >>> 16 & 255;
      o4[3] = x0 >>> 24 & 255;
      o4[4] = x1 >>> 0 & 255;
      o4[5] = x1 >>> 8 & 255;
      o4[6] = x1 >>> 16 & 255;
      o4[7] = x1 >>> 24 & 255;
      o4[8] = x2 >>> 0 & 255;
      o4[9] = x2 >>> 8 & 255;
      o4[10] = x2 >>> 16 & 255;
      o4[11] = x2 >>> 24 & 255;
      o4[12] = x3 >>> 0 & 255;
      o4[13] = x3 >>> 8 & 255;
      o4[14] = x3 >>> 16 & 255;
      o4[15] = x3 >>> 24 & 255;
      o4[16] = x4 >>> 0 & 255;
      o4[17] = x4 >>> 8 & 255;
      o4[18] = x4 >>> 16 & 255;
      o4[19] = x4 >>> 24 & 255;
      o4[20] = x5 >>> 0 & 255;
      o4[21] = x5 >>> 8 & 255;
      o4[22] = x5 >>> 16 & 255;
      o4[23] = x5 >>> 24 & 255;
      o4[24] = x6 >>> 0 & 255;
      o4[25] = x6 >>> 8 & 255;
      o4[26] = x6 >>> 16 & 255;
      o4[27] = x6 >>> 24 & 255;
      o4[28] = x7 >>> 0 & 255;
      o4[29] = x7 >>> 8 & 255;
      o4[30] = x7 >>> 16 & 255;
      o4[31] = x7 >>> 24 & 255;
      o4[32] = x8 >>> 0 & 255;
      o4[33] = x8 >>> 8 & 255;
      o4[34] = x8 >>> 16 & 255;
      o4[35] = x8 >>> 24 & 255;
      o4[36] = x9 >>> 0 & 255;
      o4[37] = x9 >>> 8 & 255;
      o4[38] = x9 >>> 16 & 255;
      o4[39] = x9 >>> 24 & 255;
      o4[40] = x10 >>> 0 & 255;
      o4[41] = x10 >>> 8 & 255;
      o4[42] = x10 >>> 16 & 255;
      o4[43] = x10 >>> 24 & 255;
      o4[44] = x11 >>> 0 & 255;
      o4[45] = x11 >>> 8 & 255;
      o4[46] = x11 >>> 16 & 255;
      o4[47] = x11 >>> 24 & 255;
      o4[48] = x12 >>> 0 & 255;
      o4[49] = x12 >>> 8 & 255;
      o4[50] = x12 >>> 16 & 255;
      o4[51] = x12 >>> 24 & 255;
      o4[52] = x13 >>> 0 & 255;
      o4[53] = x13 >>> 8 & 255;
      o4[54] = x13 >>> 16 & 255;
      o4[55] = x13 >>> 24 & 255;
      o4[56] = x14 >>> 0 & 255;
      o4[57] = x14 >>> 8 & 255;
      o4[58] = x14 >>> 16 & 255;
      o4[59] = x14 >>> 24 & 255;
      o4[60] = x15 >>> 0 & 255;
      o4[61] = x15 >>> 8 & 255;
      o4[62] = x15 >>> 16 & 255;
      o4[63] = x15 >>> 24 & 255;
    }
    function core_hsalsa20(o4, p, k, c) {
      var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
      var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
      for (var i = 0;i < 20; i += 2) {
        u = x0 + x12 | 0;
        x4 ^= u << 7 | u >>> 32 - 7;
        u = x4 + x0 | 0;
        x8 ^= u << 9 | u >>> 32 - 9;
        u = x8 + x4 | 0;
        x12 ^= u << 13 | u >>> 32 - 13;
        u = x12 + x8 | 0;
        x0 ^= u << 18 | u >>> 32 - 18;
        u = x5 + x1 | 0;
        x9 ^= u << 7 | u >>> 32 - 7;
        u = x9 + x5 | 0;
        x13 ^= u << 9 | u >>> 32 - 9;
        u = x13 + x9 | 0;
        x1 ^= u << 13 | u >>> 32 - 13;
        u = x1 + x13 | 0;
        x5 ^= u << 18 | u >>> 32 - 18;
        u = x10 + x6 | 0;
        x14 ^= u << 7 | u >>> 32 - 7;
        u = x14 + x10 | 0;
        x2 ^= u << 9 | u >>> 32 - 9;
        u = x2 + x14 | 0;
        x6 ^= u << 13 | u >>> 32 - 13;
        u = x6 + x2 | 0;
        x10 ^= u << 18 | u >>> 32 - 18;
        u = x15 + x11 | 0;
        x3 ^= u << 7 | u >>> 32 - 7;
        u = x3 + x15 | 0;
        x7 ^= u << 9 | u >>> 32 - 9;
        u = x7 + x3 | 0;
        x11 ^= u << 13 | u >>> 32 - 13;
        u = x11 + x7 | 0;
        x15 ^= u << 18 | u >>> 32 - 18;
        u = x0 + x3 | 0;
        x1 ^= u << 7 | u >>> 32 - 7;
        u = x1 + x0 | 0;
        x2 ^= u << 9 | u >>> 32 - 9;
        u = x2 + x1 | 0;
        x3 ^= u << 13 | u >>> 32 - 13;
        u = x3 + x2 | 0;
        x0 ^= u << 18 | u >>> 32 - 18;
        u = x5 + x4 | 0;
        x6 ^= u << 7 | u >>> 32 - 7;
        u = x6 + x5 | 0;
        x7 ^= u << 9 | u >>> 32 - 9;
        u = x7 + x6 | 0;
        x4 ^= u << 13 | u >>> 32 - 13;
        u = x4 + x7 | 0;
        x5 ^= u << 18 | u >>> 32 - 18;
        u = x10 + x9 | 0;
        x11 ^= u << 7 | u >>> 32 - 7;
        u = x11 + x10 | 0;
        x8 ^= u << 9 | u >>> 32 - 9;
        u = x8 + x11 | 0;
        x9 ^= u << 13 | u >>> 32 - 13;
        u = x9 + x8 | 0;
        x10 ^= u << 18 | u >>> 32 - 18;
        u = x15 + x14 | 0;
        x12 ^= u << 7 | u >>> 32 - 7;
        u = x12 + x15 | 0;
        x13 ^= u << 9 | u >>> 32 - 9;
        u = x13 + x12 | 0;
        x14 ^= u << 13 | u >>> 32 - 13;
        u = x14 + x13 | 0;
        x15 ^= u << 18 | u >>> 32 - 18;
      }
      o4[0] = x0 >>> 0 & 255;
      o4[1] = x0 >>> 8 & 255;
      o4[2] = x0 >>> 16 & 255;
      o4[3] = x0 >>> 24 & 255;
      o4[4] = x5 >>> 0 & 255;
      o4[5] = x5 >>> 8 & 255;
      o4[6] = x5 >>> 16 & 255;
      o4[7] = x5 >>> 24 & 255;
      o4[8] = x10 >>> 0 & 255;
      o4[9] = x10 >>> 8 & 255;
      o4[10] = x10 >>> 16 & 255;
      o4[11] = x10 >>> 24 & 255;
      o4[12] = x15 >>> 0 & 255;
      o4[13] = x15 >>> 8 & 255;
      o4[14] = x15 >>> 16 & 255;
      o4[15] = x15 >>> 24 & 255;
      o4[16] = x6 >>> 0 & 255;
      o4[17] = x6 >>> 8 & 255;
      o4[18] = x6 >>> 16 & 255;
      o4[19] = x6 >>> 24 & 255;
      o4[20] = x7 >>> 0 & 255;
      o4[21] = x7 >>> 8 & 255;
      o4[22] = x7 >>> 16 & 255;
      o4[23] = x7 >>> 24 & 255;
      o4[24] = x8 >>> 0 & 255;
      o4[25] = x8 >>> 8 & 255;
      o4[26] = x8 >>> 16 & 255;
      o4[27] = x8 >>> 24 & 255;
      o4[28] = x9 >>> 0 & 255;
      o4[29] = x9 >>> 8 & 255;
      o4[30] = x9 >>> 16 & 255;
      o4[31] = x9 >>> 24 & 255;
    }
    function crypto_core_salsa20(out, inp, k, c) {
      core_salsa20(out, inp, k, c);
    }
    function crypto_core_hsalsa20(out, inp, k, c) {
      core_hsalsa20(out, inp, k, c);
    }
    var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
    function crypto_stream_salsa20_xor(c, cpos, m, mpos, b, n, k) {
      var z = new Uint8Array(16), x = new Uint8Array(64);
      var u, i;
      for (i = 0;i < 16; i++)
        z[i] = 0;
      for (i = 0;i < 8; i++)
        z[i] = n[i];
      while (b >= 64) {
        crypto_core_salsa20(x, z, k, sigma);
        for (i = 0;i < 64; i++)
          c[cpos + i] = m[mpos + i] ^ x[i];
        u = 1;
        for (i = 8;i < 16; i++) {
          u = u + (z[i] & 255) | 0;
          z[i] = u & 255;
          u >>>= 8;
        }
        b -= 64;
        cpos += 64;
        mpos += 64;
      }
      if (b > 0) {
        crypto_core_salsa20(x, z, k, sigma);
        for (i = 0;i < b; i++)
          c[cpos + i] = m[mpos + i] ^ x[i];
      }
      return 0;
    }
    function crypto_stream_salsa20(c, cpos, b, n, k) {
      var z = new Uint8Array(16), x = new Uint8Array(64);
      var u, i;
      for (i = 0;i < 16; i++)
        z[i] = 0;
      for (i = 0;i < 8; i++)
        z[i] = n[i];
      while (b >= 64) {
        crypto_core_salsa20(x, z, k, sigma);
        for (i = 0;i < 64; i++)
          c[cpos + i] = x[i];
        u = 1;
        for (i = 8;i < 16; i++) {
          u = u + (z[i] & 255) | 0;
          z[i] = u & 255;
          u >>>= 8;
        }
        b -= 64;
        cpos += 64;
      }
      if (b > 0) {
        crypto_core_salsa20(x, z, k, sigma);
        for (i = 0;i < b; i++)
          c[cpos + i] = x[i];
      }
      return 0;
    }
    function crypto_stream(c, cpos, d, n, k) {
      var s3 = new Uint8Array(32);
      crypto_core_hsalsa20(s3, n, k, sigma);
      var sn = new Uint8Array(8);
      for (var i = 0;i < 8; i++)
        sn[i] = n[i + 16];
      return crypto_stream_salsa20(c, cpos, d, sn, s3);
    }
    function crypto_stream_xor(c, cpos, m, mpos, d, n, k) {
      var s3 = new Uint8Array(32);
      crypto_core_hsalsa20(s3, n, k, sigma);
      var sn = new Uint8Array(8);
      for (var i = 0;i < 8; i++)
        sn[i] = n[i + 16];
      return crypto_stream_salsa20_xor(c, cpos, m, mpos, d, sn, s3);
    }
    var poly1305 = function(key) {
      this.buffer = new Uint8Array(16);
      this.r = new Uint16Array(10);
      this.h = new Uint16Array(10);
      this.pad = new Uint16Array(8);
      this.leftover = 0;
      this.fin = 0;
      var t0, t1, t2, t3, t4, t5, t6, t7;
      t0 = key[0] & 255 | (key[1] & 255) << 8;
      this.r[0] = t0 & 8191;
      t1 = key[2] & 255 | (key[3] & 255) << 8;
      this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
      t2 = key[4] & 255 | (key[5] & 255) << 8;
      this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
      t3 = key[6] & 255 | (key[7] & 255) << 8;
      this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
      t4 = key[8] & 255 | (key[9] & 255) << 8;
      this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
      this.r[5] = t4 >>> 1 & 8190;
      t5 = key[10] & 255 | (key[11] & 255) << 8;
      this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
      t6 = key[12] & 255 | (key[13] & 255) << 8;
      this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
      t7 = key[14] & 255 | (key[15] & 255) << 8;
      this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
      this.r[9] = t7 >>> 5 & 127;
      this.pad[0] = key[16] & 255 | (key[17] & 255) << 8;
      this.pad[1] = key[18] & 255 | (key[19] & 255) << 8;
      this.pad[2] = key[20] & 255 | (key[21] & 255) << 8;
      this.pad[3] = key[22] & 255 | (key[23] & 255) << 8;
      this.pad[4] = key[24] & 255 | (key[25] & 255) << 8;
      this.pad[5] = key[26] & 255 | (key[27] & 255) << 8;
      this.pad[6] = key[28] & 255 | (key[29] & 255) << 8;
      this.pad[7] = key[30] & 255 | (key[31] & 255) << 8;
    };
    poly1305.prototype.blocks = function(m, mpos, bytes) {
      var hibit = this.fin ? 0 : 1 << 11;
      var t0, t1, t2, t3, t4, t5, t6, t7, c;
      var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;
      var h0 = this.h[0], h1 = this.h[1], h2 = this.h[2], h3 = this.h[3], h4 = this.h[4], h5 = this.h[5], h6 = this.h[6], h7 = this.h[7], h8 = this.h[8], h9 = this.h[9];
      var r0 = this.r[0], r1 = this.r[1], r2 = this.r[2], r3 = this.r[3], r4 = this.r[4], r5 = this.r[5], r6 = this.r[6], r7 = this.r[7], r8 = this.r[8], r9 = this.r[9];
      while (bytes >= 16) {
        t0 = m[mpos + 0] & 255 | (m[mpos + 1] & 255) << 8;
        h0 += t0 & 8191;
        t1 = m[mpos + 2] & 255 | (m[mpos + 3] & 255) << 8;
        h1 += (t0 >>> 13 | t1 << 3) & 8191;
        t2 = m[mpos + 4] & 255 | (m[mpos + 5] & 255) << 8;
        h2 += (t1 >>> 10 | t2 << 6) & 8191;
        t3 = m[mpos + 6] & 255 | (m[mpos + 7] & 255) << 8;
        h3 += (t2 >>> 7 | t3 << 9) & 8191;
        t4 = m[mpos + 8] & 255 | (m[mpos + 9] & 255) << 8;
        h4 += (t3 >>> 4 | t4 << 12) & 8191;
        h5 += t4 >>> 1 & 8191;
        t5 = m[mpos + 10] & 255 | (m[mpos + 11] & 255) << 8;
        h6 += (t4 >>> 14 | t5 << 2) & 8191;
        t6 = m[mpos + 12] & 255 | (m[mpos + 13] & 255) << 8;
        h7 += (t5 >>> 11 | t6 << 5) & 8191;
        t7 = m[mpos + 14] & 255 | (m[mpos + 15] & 255) << 8;
        h8 += (t6 >>> 8 | t7 << 8) & 8191;
        h9 += t7 >>> 5 | hibit;
        c = 0;
        d0 = c;
        d0 += h0 * r0;
        d0 += h1 * (5 * r9);
        d0 += h2 * (5 * r8);
        d0 += h3 * (5 * r7);
        d0 += h4 * (5 * r6);
        c = d0 >>> 13;
        d0 &= 8191;
        d0 += h5 * (5 * r5);
        d0 += h6 * (5 * r4);
        d0 += h7 * (5 * r3);
        d0 += h8 * (5 * r2);
        d0 += h9 * (5 * r1);
        c += d0 >>> 13;
        d0 &= 8191;
        d1 = c;
        d1 += h0 * r1;
        d1 += h1 * r0;
        d1 += h2 * (5 * r9);
        d1 += h3 * (5 * r8);
        d1 += h4 * (5 * r7);
        c = d1 >>> 13;
        d1 &= 8191;
        d1 += h5 * (5 * r6);
        d1 += h6 * (5 * r5);
        d1 += h7 * (5 * r4);
        d1 += h8 * (5 * r3);
        d1 += h9 * (5 * r2);
        c += d1 >>> 13;
        d1 &= 8191;
        d2 = c;
        d2 += h0 * r2;
        d2 += h1 * r1;
        d2 += h2 * r0;
        d2 += h3 * (5 * r9);
        d2 += h4 * (5 * r8);
        c = d2 >>> 13;
        d2 &= 8191;
        d2 += h5 * (5 * r7);
        d2 += h6 * (5 * r6);
        d2 += h7 * (5 * r5);
        d2 += h8 * (5 * r4);
        d2 += h9 * (5 * r3);
        c += d2 >>> 13;
        d2 &= 8191;
        d3 = c;
        d3 += h0 * r3;
        d3 += h1 * r2;
        d3 += h2 * r1;
        d3 += h3 * r0;
        d3 += h4 * (5 * r9);
        c = d3 >>> 13;
        d3 &= 8191;
        d3 += h5 * (5 * r8);
        d3 += h6 * (5 * r7);
        d3 += h7 * (5 * r6);
        d3 += h8 * (5 * r5);
        d3 += h9 * (5 * r4);
        c += d3 >>> 13;
        d3 &= 8191;
        d4 = c;
        d4 += h0 * r4;
        d4 += h1 * r3;
        d4 += h2 * r2;
        d4 += h3 * r1;
        d4 += h4 * r0;
        c = d4 >>> 13;
        d4 &= 8191;
        d4 += h5 * (5 * r9);
        d4 += h6 * (5 * r8);
        d4 += h7 * (5 * r7);
        d4 += h8 * (5 * r6);
        d4 += h9 * (5 * r5);
        c += d4 >>> 13;
        d4 &= 8191;
        d5 = c;
        d5 += h0 * r5;
        d5 += h1 * r4;
        d5 += h2 * r3;
        d5 += h3 * r2;
        d5 += h4 * r1;
        c = d5 >>> 13;
        d5 &= 8191;
        d5 += h5 * r0;
        d5 += h6 * (5 * r9);
        d5 += h7 * (5 * r8);
        d5 += h8 * (5 * r7);
        d5 += h9 * (5 * r6);
        c += d5 >>> 13;
        d5 &= 8191;
        d6 = c;
        d6 += h0 * r6;
        d6 += h1 * r5;
        d6 += h2 * r4;
        d6 += h3 * r3;
        d6 += h4 * r2;
        c = d6 >>> 13;
        d6 &= 8191;
        d6 += h5 * r1;
        d6 += h6 * r0;
        d6 += h7 * (5 * r9);
        d6 += h8 * (5 * r8);
        d6 += h9 * (5 * r7);
        c += d6 >>> 13;
        d6 &= 8191;
        d7 = c;
        d7 += h0 * r7;
        d7 += h1 * r6;
        d7 += h2 * r5;
        d7 += h3 * r4;
        d7 += h4 * r3;
        c = d7 >>> 13;
        d7 &= 8191;
        d7 += h5 * r2;
        d7 += h6 * r1;
        d7 += h7 * r0;
        d7 += h8 * (5 * r9);
        d7 += h9 * (5 * r8);
        c += d7 >>> 13;
        d7 &= 8191;
        d8 = c;
        d8 += h0 * r8;
        d8 += h1 * r7;
        d8 += h2 * r6;
        d8 += h3 * r5;
        d8 += h4 * r4;
        c = d8 >>> 13;
        d8 &= 8191;
        d8 += h5 * r3;
        d8 += h6 * r2;
        d8 += h7 * r1;
        d8 += h8 * r0;
        d8 += h9 * (5 * r9);
        c += d8 >>> 13;
        d8 &= 8191;
        d9 = c;
        d9 += h0 * r9;
        d9 += h1 * r8;
        d9 += h2 * r7;
        d9 += h3 * r6;
        d9 += h4 * r5;
        c = d9 >>> 13;
        d9 &= 8191;
        d9 += h5 * r4;
        d9 += h6 * r3;
        d9 += h7 * r2;
        d9 += h8 * r1;
        d9 += h9 * r0;
        c += d9 >>> 13;
        d9 &= 8191;
        c = (c << 2) + c | 0;
        c = c + d0 | 0;
        d0 = c & 8191;
        c = c >>> 13;
        d1 += c;
        h0 = d0;
        h1 = d1;
        h2 = d2;
        h3 = d3;
        h4 = d4;
        h5 = d5;
        h6 = d6;
        h7 = d7;
        h8 = d8;
        h9 = d9;
        mpos += 16;
        bytes -= 16;
      }
      this.h[0] = h0;
      this.h[1] = h1;
      this.h[2] = h2;
      this.h[3] = h3;
      this.h[4] = h4;
      this.h[5] = h5;
      this.h[6] = h6;
      this.h[7] = h7;
      this.h[8] = h8;
      this.h[9] = h9;
    };
    poly1305.prototype.finish = function(mac, macpos) {
      var g = new Uint16Array(10);
      var c, mask, f, i;
      if (this.leftover) {
        i = this.leftover;
        this.buffer[i++] = 1;
        for (;i < 16; i++)
          this.buffer[i] = 0;
        this.fin = 1;
        this.blocks(this.buffer, 0, 16);
      }
      c = this.h[1] >>> 13;
      this.h[1] &= 8191;
      for (i = 2;i < 10; i++) {
        this.h[i] += c;
        c = this.h[i] >>> 13;
        this.h[i] &= 8191;
      }
      this.h[0] += c * 5;
      c = this.h[0] >>> 13;
      this.h[0] &= 8191;
      this.h[1] += c;
      c = this.h[1] >>> 13;
      this.h[1] &= 8191;
      this.h[2] += c;
      g[0] = this.h[0] + 5;
      c = g[0] >>> 13;
      g[0] &= 8191;
      for (i = 1;i < 10; i++) {
        g[i] = this.h[i] + c;
        c = g[i] >>> 13;
        g[i] &= 8191;
      }
      g[9] -= 1 << 13;
      mask = (c ^ 1) - 1;
      for (i = 0;i < 10; i++)
        g[i] &= mask;
      mask = ~mask;
      for (i = 0;i < 10; i++)
        this.h[i] = this.h[i] & mask | g[i];
      this.h[0] = (this.h[0] | this.h[1] << 13) & 65535;
      this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535;
      this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535;
      this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535;
      this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535;
      this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535;
      this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535;
      this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535;
      f = this.h[0] + this.pad[0];
      this.h[0] = f & 65535;
      for (i = 1;i < 8; i++) {
        f = (this.h[i] + this.pad[i] | 0) + (f >>> 16) | 0;
        this.h[i] = f & 65535;
      }
      mac[macpos + 0] = this.h[0] >>> 0 & 255;
      mac[macpos + 1] = this.h[0] >>> 8 & 255;
      mac[macpos + 2] = this.h[1] >>> 0 & 255;
      mac[macpos + 3] = this.h[1] >>> 8 & 255;
      mac[macpos + 4] = this.h[2] >>> 0 & 255;
      mac[macpos + 5] = this.h[2] >>> 8 & 255;
      mac[macpos + 6] = this.h[3] >>> 0 & 255;
      mac[macpos + 7] = this.h[3] >>> 8 & 255;
      mac[macpos + 8] = this.h[4] >>> 0 & 255;
      mac[macpos + 9] = this.h[4] >>> 8 & 255;
      mac[macpos + 10] = this.h[5] >>> 0 & 255;
      mac[macpos + 11] = this.h[5] >>> 8 & 255;
      mac[macpos + 12] = this.h[6] >>> 0 & 255;
      mac[macpos + 13] = this.h[6] >>> 8 & 255;
      mac[macpos + 14] = this.h[7] >>> 0 & 255;
      mac[macpos + 15] = this.h[7] >>> 8 & 255;
    };
    poly1305.prototype.update = function(m, mpos, bytes) {
      var i, want;
      if (this.leftover) {
        want = 16 - this.leftover;
        if (want > bytes)
          want = bytes;
        for (i = 0;i < want; i++)
          this.buffer[this.leftover + i] = m[mpos + i];
        bytes -= want;
        mpos += want;
        this.leftover += want;
        if (this.leftover < 16)
          return;
        this.blocks(this.buffer, 0, 16);
        this.leftover = 0;
      }
      if (bytes >= 16) {
        want = bytes - bytes % 16;
        this.blocks(m, mpos, want);
        mpos += want;
        bytes -= want;
      }
      if (bytes) {
        for (i = 0;i < bytes; i++)
          this.buffer[this.leftover + i] = m[mpos + i];
        this.leftover += bytes;
      }
    };
    function crypto_onetimeauth(out, outpos, m, mpos, n, k) {
      var s3 = new poly1305(k);
      s3.update(m, mpos, n);
      s3.finish(out, outpos);
      return 0;
    }
    function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {
      var x = new Uint8Array(16);
      crypto_onetimeauth(x, 0, m, mpos, n, k);
      return crypto_verify_16(h, hpos, x, 0);
    }
    function crypto_secretbox(c, m, d, n, k) {
      var i;
      if (d < 32)
        return -1;
      crypto_stream_xor(c, 0, m, 0, d, n, k);
      crypto_onetimeauth(c, 16, c, 32, d - 32, c);
      for (i = 0;i < 16; i++)
        c[i] = 0;
      return 0;
    }
    function crypto_secretbox_open(m, c, d, n, k) {
      var i;
      var x = new Uint8Array(32);
      if (d < 32)
        return -1;
      crypto_stream(x, 0, 32, n, k);
      if (crypto_onetimeauth_verify(c, 16, c, 32, d - 32, x) !== 0)
        return -1;
      crypto_stream_xor(m, 0, c, 0, d, n, k);
      for (i = 0;i < 32; i++)
        m[i] = 0;
      return 0;
    }
    function set25519(r, a) {
      var i;
      for (i = 0;i < 16; i++)
        r[i] = a[i] | 0;
    }
    function car25519(o4) {
      var i, v, c = 1;
      for (i = 0;i < 16; i++) {
        v = o4[i] + c + 65535;
        c = Math.floor(v / 65536);
        o4[i] = v - c * 65536;
      }
      o4[0] += c - 1 + 37 * (c - 1);
    }
    function sel25519(p, q, b) {
      var t, c = ~(b - 1);
      for (var i = 0;i < 16; i++) {
        t = c & (p[i] ^ q[i]);
        p[i] ^= t;
        q[i] ^= t;
      }
    }
    function pack25519(o4, n) {
      var i, j, b;
      var m = gf(), t = gf();
      for (i = 0;i < 16; i++)
        t[i] = n[i];
      car25519(t);
      car25519(t);
      car25519(t);
      for (j = 0;j < 2; j++) {
        m[0] = t[0] - 65517;
        for (i = 1;i < 15; i++) {
          m[i] = t[i] - 65535 - (m[i - 1] >> 16 & 1);
          m[i - 1] &= 65535;
        }
        m[15] = t[15] - 32767 - (m[14] >> 16 & 1);
        b = m[15] >> 16 & 1;
        m[14] &= 65535;
        sel25519(t, m, 1 - b);
      }
      for (i = 0;i < 16; i++) {
        o4[2 * i] = t[i] & 255;
        o4[2 * i + 1] = t[i] >> 8;
      }
    }
    function neq25519(a, b) {
      var c = new Uint8Array(32), d = new Uint8Array(32);
      pack25519(c, a);
      pack25519(d, b);
      return crypto_verify_32(c, 0, d, 0);
    }
    function par25519(a) {
      var d = new Uint8Array(32);
      pack25519(d, a);
      return d[0] & 1;
    }
    function unpack25519(o4, n) {
      var i;
      for (i = 0;i < 16; i++)
        o4[i] = n[2 * i] + (n[2 * i + 1] << 8);
      o4[15] &= 32767;
    }
    function A(o4, a, b) {
      for (var i = 0;i < 16; i++)
        o4[i] = a[i] + b[i];
    }
    function Z(o4, a, b) {
      for (var i = 0;i < 16; i++)
        o4[i] = a[i] - b[i];
    }
    function M(o4, a, b) {
      var v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
      v = a[0];
      t0 += v * b0;
      t1 += v * b1;
      t2 += v * b2;
      t3 += v * b3;
      t4 += v * b4;
      t5 += v * b5;
      t6 += v * b6;
      t7 += v * b7;
      t8 += v * b8;
      t9 += v * b9;
      t10 += v * b10;
      t11 += v * b11;
      t12 += v * b12;
      t13 += v * b13;
      t14 += v * b14;
      t15 += v * b15;
      v = a[1];
      t1 += v * b0;
      t2 += v * b1;
      t3 += v * b2;
      t4 += v * b3;
      t5 += v * b4;
      t6 += v * b5;
      t7 += v * b6;
      t8 += v * b7;
      t9 += v * b8;
      t10 += v * b9;
      t11 += v * b10;
      t12 += v * b11;
      t13 += v * b12;
      t14 += v * b13;
      t15 += v * b14;
      t16 += v * b15;
      v = a[2];
      t2 += v * b0;
      t3 += v * b1;
      t4 += v * b2;
      t5 += v * b3;
      t6 += v * b4;
      t7 += v * b5;
      t8 += v * b6;
      t9 += v * b7;
      t10 += v * b8;
      t11 += v * b9;
      t12 += v * b10;
      t13 += v * b11;
      t14 += v * b12;
      t15 += v * b13;
      t16 += v * b14;
      t17 += v * b15;
      v = a[3];
      t3 += v * b0;
      t4 += v * b1;
      t5 += v * b2;
      t6 += v * b3;
      t7 += v * b4;
      t8 += v * b5;
      t9 += v * b6;
      t10 += v * b7;
      t11 += v * b8;
      t12 += v * b9;
      t13 += v * b10;
      t14 += v * b11;
      t15 += v * b12;
      t16 += v * b13;
      t17 += v * b14;
      t18 += v * b15;
      v = a[4];
      t4 += v * b0;
      t5 += v * b1;
      t6 += v * b2;
      t7 += v * b3;
      t8 += v * b4;
      t9 += v * b5;
      t10 += v * b6;
      t11 += v * b7;
      t12 += v * b8;
      t13 += v * b9;
      t14 += v * b10;
      t15 += v * b11;
      t16 += v * b12;
      t17 += v * b13;
      t18 += v * b14;
      t19 += v * b15;
      v = a[5];
      t5 += v * b0;
      t6 += v * b1;
      t7 += v * b2;
      t8 += v * b3;
      t9 += v * b4;
      t10 += v * b5;
      t11 += v * b6;
      t12 += v * b7;
      t13 += v * b8;
      t14 += v * b9;
      t15 += v * b10;
      t16 += v * b11;
      t17 += v * b12;
      t18 += v * b13;
      t19 += v * b14;
      t20 += v * b15;
      v = a[6];
      t6 += v * b0;
      t7 += v * b1;
      t8 += v * b2;
      t9 += v * b3;
      t10 += v * b4;
      t11 += v * b5;
      t12 += v * b6;
      t13 += v * b7;
      t14 += v * b8;
      t15 += v * b9;
      t16 += v * b10;
      t17 += v * b11;
      t18 += v * b12;
      t19 += v * b13;
      t20 += v * b14;
      t21 += v * b15;
      v = a[7];
      t7 += v * b0;
      t8 += v * b1;
      t9 += v * b2;
      t10 += v * b3;
      t11 += v * b4;
      t12 += v * b5;
      t13 += v * b6;
      t14 += v * b7;
      t15 += v * b8;
      t16 += v * b9;
      t17 += v * b10;
      t18 += v * b11;
      t19 += v * b12;
      t20 += v * b13;
      t21 += v * b14;
      t22 += v * b15;
      v = a[8];
      t8 += v * b0;
      t9 += v * b1;
      t10 += v * b2;
      t11 += v * b3;
      t12 += v * b4;
      t13 += v * b5;
      t14 += v * b6;
      t15 += v * b7;
      t16 += v * b8;
      t17 += v * b9;
      t18 += v * b10;
      t19 += v * b11;
      t20 += v * b12;
      t21 += v * b13;
      t22 += v * b14;
      t23 += v * b15;
      v = a[9];
      t9 += v * b0;
      t10 += v * b1;
      t11 += v * b2;
      t12 += v * b3;
      t13 += v * b4;
      t14 += v * b5;
      t15 += v * b6;
      t16 += v * b7;
      t17 += v * b8;
      t18 += v * b9;
      t19 += v * b10;
      t20 += v * b11;
      t21 += v * b12;
      t22 += v * b13;
      t23 += v * b14;
      t24 += v * b15;
      v = a[10];
      t10 += v * b0;
      t11 += v * b1;
      t12 += v * b2;
      t13 += v * b3;
      t14 += v * b4;
      t15 += v * b5;
      t16 += v * b6;
      t17 += v * b7;
      t18 += v * b8;
      t19 += v * b9;
      t20 += v * b10;
      t21 += v * b11;
      t22 += v * b12;
      t23 += v * b13;
      t24 += v * b14;
      t25 += v * b15;
      v = a[11];
      t11 += v * b0;
      t12 += v * b1;
      t13 += v * b2;
      t14 += v * b3;
      t15 += v * b4;
      t16 += v * b5;
      t17 += v * b6;
      t18 += v * b7;
      t19 += v * b8;
      t20 += v * b9;
      t21 += v * b10;
      t22 += v * b11;
      t23 += v * b12;
      t24 += v * b13;
      t25 += v * b14;
      t26 += v * b15;
      v = a[12];
      t12 += v * b0;
      t13 += v * b1;
      t14 += v * b2;
      t15 += v * b3;
      t16 += v * b4;
      t17 += v * b5;
      t18 += v * b6;
      t19 += v * b7;
      t20 += v * b8;
      t21 += v * b9;
      t22 += v * b10;
      t23 += v * b11;
      t24 += v * b12;
      t25 += v * b13;
      t26 += v * b14;
      t27 += v * b15;
      v = a[13];
      t13 += v * b0;
      t14 += v * b1;
      t15 += v * b2;
      t16 += v * b3;
      t17 += v * b4;
      t18 += v * b5;
      t19 += v * b6;
      t20 += v * b7;
      t21 += v * b8;
      t22 += v * b9;
      t23 += v * b10;
      t24 += v * b11;
      t25 += v * b12;
      t26 += v * b13;
      t27 += v * b14;
      t28 += v * b15;
      v = a[14];
      t14 += v * b0;
      t15 += v * b1;
      t16 += v * b2;
      t17 += v * b3;
      t18 += v * b4;
      t19 += v * b5;
      t20 += v * b6;
      t21 += v * b7;
      t22 += v * b8;
      t23 += v * b9;
      t24 += v * b10;
      t25 += v * b11;
      t26 += v * b12;
      t27 += v * b13;
      t28 += v * b14;
      t29 += v * b15;
      v = a[15];
      t15 += v * b0;
      t16 += v * b1;
      t17 += v * b2;
      t18 += v * b3;
      t19 += v * b4;
      t20 += v * b5;
      t21 += v * b6;
      t22 += v * b7;
      t23 += v * b8;
      t24 += v * b9;
      t25 += v * b10;
      t26 += v * b11;
      t27 += v * b12;
      t28 += v * b13;
      t29 += v * b14;
      t30 += v * b15;
      t0 += 38 * t16;
      t1 += 38 * t17;
      t2 += 38 * t18;
      t3 += 38 * t19;
      t4 += 38 * t20;
      t5 += 38 * t21;
      t6 += 38 * t22;
      t7 += 38 * t23;
      t8 += 38 * t24;
      t9 += 38 * t25;
      t10 += 38 * t26;
      t11 += 38 * t27;
      t12 += 38 * t28;
      t13 += 38 * t29;
      t14 += 38 * t30;
      c = 1;
      v = t0 + c + 65535;
      c = Math.floor(v / 65536);
      t0 = v - c * 65536;
      v = t1 + c + 65535;
      c = Math.floor(v / 65536);
      t1 = v - c * 65536;
      v = t2 + c + 65535;
      c = Math.floor(v / 65536);
      t2 = v - c * 65536;
      v = t3 + c + 65535;
      c = Math.floor(v / 65536);
      t3 = v - c * 65536;
      v = t4 + c + 65535;
      c = Math.floor(v / 65536);
      t4 = v - c * 65536;
      v = t5 + c + 65535;
      c = Math.floor(v / 65536);
      t5 = v - c * 65536;
      v = t6 + c + 65535;
      c = Math.floor(v / 65536);
      t6 = v - c * 65536;
      v = t7 + c + 65535;
      c = Math.floor(v / 65536);
      t7 = v - c * 65536;
      v = t8 + c + 65535;
      c = Math.floor(v / 65536);
      t8 = v - c * 65536;
      v = t9 + c + 65535;
      c = Math.floor(v / 65536);
      t9 = v - c * 65536;
      v = t10 + c + 65535;
      c = Math.floor(v / 65536);
      t10 = v - c * 65536;
      v = t11 + c + 65535;
      c = Math.floor(v / 65536);
      t11 = v - c * 65536;
      v = t12 + c + 65535;
      c = Math.floor(v / 65536);
      t12 = v - c * 65536;
      v = t13 + c + 65535;
      c = Math.floor(v / 65536);
      t13 = v - c * 65536;
      v = t14 + c + 65535;
      c = Math.floor(v / 65536);
      t14 = v - c * 65536;
      v = t15 + c + 65535;
      c = Math.floor(v / 65536);
      t15 = v - c * 65536;
      t0 += c - 1 + 37 * (c - 1);
      c = 1;
      v = t0 + c + 65535;
      c = Math.floor(v / 65536);
      t0 = v - c * 65536;
      v = t1 + c + 65535;
      c = Math.floor(v / 65536);
      t1 = v - c * 65536;
      v = t2 + c + 65535;
      c = Math.floor(v / 65536);
      t2 = v - c * 65536;
      v = t3 + c + 65535;
      c = Math.floor(v / 65536);
      t3 = v - c * 65536;
      v = t4 + c + 65535;
      c = Math.floor(v / 65536);
      t4 = v - c * 65536;
      v = t5 + c + 65535;
      c = Math.floor(v / 65536);
      t5 = v - c * 65536;
      v = t6 + c + 65535;
      c = Math.floor(v / 65536);
      t6 = v - c * 65536;
      v = t7 + c + 65535;
      c = Math.floor(v / 65536);
      t7 = v - c * 65536;
      v = t8 + c + 65535;
      c = Math.floor(v / 65536);
      t8 = v - c * 65536;
      v = t9 + c + 65535;
      c = Math.floor(v / 65536);
      t9 = v - c * 65536;
      v = t10 + c + 65535;
      c = Math.floor(v / 65536);
      t10 = v - c * 65536;
      v = t11 + c + 65535;
      c = Math.floor(v / 65536);
      t11 = v - c * 65536;
      v = t12 + c + 65535;
      c = Math.floor(v / 65536);
      t12 = v - c * 65536;
      v = t13 + c + 65535;
      c = Math.floor(v / 65536);
      t13 = v - c * 65536;
      v = t14 + c + 65535;
      c = Math.floor(v / 65536);
      t14 = v - c * 65536;
      v = t15 + c + 65535;
      c = Math.floor(v / 65536);
      t15 = v - c * 65536;
      t0 += c - 1 + 37 * (c - 1);
      o4[0] = t0;
      o4[1] = t1;
      o4[2] = t2;
      o4[3] = t3;
      o4[4] = t4;
      o4[5] = t5;
      o4[6] = t6;
      o4[7] = t7;
      o4[8] = t8;
      o4[9] = t9;
      o4[10] = t10;
      o4[11] = t11;
      o4[12] = t12;
      o4[13] = t13;
      o4[14] = t14;
      o4[15] = t15;
    }
    function S(o4, a) {
      M(o4, a, a);
    }
    function inv25519(o4, i) {
      var c = gf();
      var a;
      for (a = 0;a < 16; a++)
        c[a] = i[a];
      for (a = 253;a >= 0; a--) {
        S(c, c);
        if (a !== 2 && a !== 4)
          M(c, c, i);
      }
      for (a = 0;a < 16; a++)
        o4[a] = c[a];
    }
    function pow2523(o4, i) {
      var c = gf();
      var a;
      for (a = 0;a < 16; a++)
        c[a] = i[a];
      for (a = 250;a >= 0; a--) {
        S(c, c);
        if (a !== 1)
          M(c, c, i);
      }
      for (a = 0;a < 16; a++)
        o4[a] = c[a];
    }
    function crypto_scalarmult(q, n, p) {
      var z = new Uint8Array(32);
      var x = new Float64Array(80), r, i;
      var a = gf(), b = gf(), c = gf(), d = gf(), e8 = gf(), f = gf();
      for (i = 0;i < 31; i++)
        z[i] = n[i];
      z[31] = n[31] & 127 | 64;
      z[0] &= 248;
      unpack25519(x, p);
      for (i = 0;i < 16; i++) {
        b[i] = x[i];
        d[i] = a[i] = c[i] = 0;
      }
      a[0] = d[0] = 1;
      for (i = 254;i >= 0; --i) {
        r = z[i >>> 3] >>> (i & 7) & 1;
        sel25519(a, b, r);
        sel25519(c, d, r);
        A(e8, a, c);
        Z(a, a, c);
        A(c, b, d);
        Z(b, b, d);
        S(d, e8);
        S(f, a);
        M(a, c, a);
        M(c, b, e8);
        A(e8, a, c);
        Z(a, a, c);
        S(b, a);
        Z(c, d, f);
        M(a, c, _121665);
        A(a, a, d);
        M(c, c, a);
        M(a, d, f);
        M(d, b, x);
        S(b, e8);
        sel25519(a, b, r);
        sel25519(c, d, r);
      }
      for (i = 0;i < 16; i++) {
        x[i + 16] = a[i];
        x[i + 32] = c[i];
        x[i + 48] = b[i];
        x[i + 64] = d[i];
      }
      var x32 = x.subarray(32);
      var x16 = x.subarray(16);
      inv25519(x32, x32);
      M(x16, x16, x32);
      pack25519(q, x16);
      return 0;
    }
    function crypto_scalarmult_base(q, n) {
      return crypto_scalarmult(q, n, _9);
    }
    function crypto_box_keypair(y, x) {
      randombytes(x, 32);
      return crypto_scalarmult_base(y, x);
    }
    function crypto_box_beforenm(k, y, x) {
      var s3 = new Uint8Array(32);
      crypto_scalarmult(s3, x, y);
      return crypto_core_hsalsa20(k, _0, s3, sigma);
    }
    var crypto_box_afternm = crypto_secretbox;
    var crypto_box_open_afternm = crypto_secretbox_open;
    function crypto_box(c, m, d, n, y, x) {
      var k = new Uint8Array(32);
      crypto_box_beforenm(k, y, x);
      return crypto_box_afternm(c, m, d, n, k);
    }
    function crypto_box_open(m, c, d, n, y, x) {
      var k = new Uint8Array(32);
      crypto_box_beforenm(k, y, x);
      return crypto_box_open_afternm(m, c, d, n, k);
    }
    var K = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    function crypto_hashblocks_hl(hh, hl, m, n) {
      var wh = new Int32Array(16), wl = new Int32Array(16), bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7, bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7, th, tl, i, j, h, l2, a, b, c, d;
      var ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];
      var pos = 0;
      while (n >= 128) {
        for (i = 0;i < 16; i++) {
          j = 8 * i + pos;
          wh[i] = m[j + 0] << 24 | m[j + 1] << 16 | m[j + 2] << 8 | m[j + 3];
          wl[i] = m[j + 4] << 24 | m[j + 5] << 16 | m[j + 6] << 8 | m[j + 7];
        }
        for (i = 0;i < 80; i++) {
          bh0 = ah0;
          bh1 = ah1;
          bh2 = ah2;
          bh3 = ah3;
          bh4 = ah4;
          bh5 = ah5;
          bh6 = ah6;
          bh7 = ah7;
          bl0 = al0;
          bl1 = al1;
          bl2 = al2;
          bl3 = al3;
          bl4 = al4;
          bl5 = al5;
          bl6 = al6;
          bl7 = al7;
          h = ah7;
          l2 = al7;
          a = l2 & 65535;
          b = l2 >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
          l2 = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
          a += l2 & 65535;
          b += l2 >>> 16;
          c += h & 65535;
          d += h >>> 16;
          h = ah4 & ah5 ^ ~ah4 & ah6;
          l2 = al4 & al5 ^ ~al4 & al6;
          a += l2 & 65535;
          b += l2 >>> 16;
          c += h & 65535;
          d += h >>> 16;
          h = K[i * 2];
          l2 = K[i * 2 + 1];
          a += l2 & 65535;
          b += l2 >>> 16;
          c += h & 65535;
          d += h >>> 16;
          h = wh[i % 16];
          l2 = wl[i % 16];
          a += l2 & 65535;
          b += l2 >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          th = c & 65535 | d << 16;
          tl = a & 65535 | b << 16;
          h = th;
          l2 = tl;
          a = l2 & 65535;
          b = l2 >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
          l2 = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
          a += l2 & 65535;
          b += l2 >>> 16;
          c += h & 65535;
          d += h >>> 16;
          h = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
          l2 = al0 & al1 ^ al0 & al2 ^ al1 & al2;
          a += l2 & 65535;
          b += l2 >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          bh7 = c & 65535 | d << 16;
          bl7 = a & 65535 | b << 16;
          h = bh3;
          l2 = bl3;
          a = l2 & 65535;
          b = l2 >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = th;
          l2 = tl;
          a += l2 & 65535;
          b += l2 >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          bh3 = c & 65535 | d << 16;
          bl3 = a & 65535 | b << 16;
          ah1 = bh0;
          ah2 = bh1;
          ah3 = bh2;
          ah4 = bh3;
          ah5 = bh4;
          ah6 = bh5;
          ah7 = bh6;
          ah0 = bh7;
          al1 = bl0;
          al2 = bl1;
          al3 = bl2;
          al4 = bl3;
          al5 = bl4;
          al6 = bl5;
          al7 = bl6;
          al0 = bl7;
          if (i % 16 === 15) {
            for (j = 0;j < 16; j++) {
              h = wh[j];
              l2 = wl[j];
              a = l2 & 65535;
              b = l2 >>> 16;
              c = h & 65535;
              d = h >>> 16;
              h = wh[(j + 9) % 16];
              l2 = wl[(j + 9) % 16];
              a += l2 & 65535;
              b += l2 >>> 16;
              c += h & 65535;
              d += h >>> 16;
              th = wh[(j + 1) % 16];
              tl = wl[(j + 1) % 16];
              h = (th >>> 1 | tl << 32 - 1) ^ (th >>> 8 | tl << 32 - 8) ^ th >>> 7;
              l2 = (tl >>> 1 | th << 32 - 1) ^ (tl >>> 8 | th << 32 - 8) ^ (tl >>> 7 | th << 32 - 7);
              a += l2 & 65535;
              b += l2 >>> 16;
              c += h & 65535;
              d += h >>> 16;
              th = wh[(j + 14) % 16];
              tl = wl[(j + 14) % 16];
              h = (th >>> 19 | tl << 32 - 19) ^ (tl >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;
              l2 = (tl >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl << 32 - (61 - 32)) ^ (tl >>> 6 | th << 32 - 6);
              a += l2 & 65535;
              b += l2 >>> 16;
              c += h & 65535;
              d += h >>> 16;
              b += a >>> 16;
              c += b >>> 16;
              d += c >>> 16;
              wh[j] = c & 65535 | d << 16;
              wl[j] = a & 65535 | b << 16;
            }
          }
        }
        h = ah0;
        l2 = al0;
        a = l2 & 65535;
        b = l2 >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[0];
        l2 = hl[0];
        a += l2 & 65535;
        b += l2 >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[0] = ah0 = c & 65535 | d << 16;
        hl[0] = al0 = a & 65535 | b << 16;
        h = ah1;
        l2 = al1;
        a = l2 & 65535;
        b = l2 >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[1];
        l2 = hl[1];
        a += l2 & 65535;
        b += l2 >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[1] = ah1 = c & 65535 | d << 16;
        hl[1] = al1 = a & 65535 | b << 16;
        h = ah2;
        l2 = al2;
        a = l2 & 65535;
        b = l2 >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[2];
        l2 = hl[2];
        a += l2 & 65535;
        b += l2 >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[2] = ah2 = c & 65535 | d << 16;
        hl[2] = al2 = a & 65535 | b << 16;
        h = ah3;
        l2 = al3;
        a = l2 & 65535;
        b = l2 >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[3];
        l2 = hl[3];
        a += l2 & 65535;
        b += l2 >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[3] = ah3 = c & 65535 | d << 16;
        hl[3] = al3 = a & 65535 | b << 16;
        h = ah4;
        l2 = al4;
        a = l2 & 65535;
        b = l2 >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[4];
        l2 = hl[4];
        a += l2 & 65535;
        b += l2 >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[4] = ah4 = c & 65535 | d << 16;
        hl[4] = al4 = a & 65535 | b << 16;
        h = ah5;
        l2 = al5;
        a = l2 & 65535;
        b = l2 >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[5];
        l2 = hl[5];
        a += l2 & 65535;
        b += l2 >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[5] = ah5 = c & 65535 | d << 16;
        hl[5] = al5 = a & 65535 | b << 16;
        h = ah6;
        l2 = al6;
        a = l2 & 65535;
        b = l2 >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[6];
        l2 = hl[6];
        a += l2 & 65535;
        b += l2 >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[6] = ah6 = c & 65535 | d << 16;
        hl[6] = al6 = a & 65535 | b << 16;
        h = ah7;
        l2 = al7;
        a = l2 & 65535;
        b = l2 >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[7];
        l2 = hl[7];
        a += l2 & 65535;
        b += l2 >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[7] = ah7 = c & 65535 | d << 16;
        hl[7] = al7 = a & 65535 | b << 16;
        pos += 128;
        n -= 128;
      }
      return n;
    }
    function crypto_hash(out, m, n) {
      var hh = new Int32Array(8), hl = new Int32Array(8), x = new Uint8Array(256), i, b = n;
      hh[0] = 1779033703;
      hh[1] = 3144134277;
      hh[2] = 1013904242;
      hh[3] = 2773480762;
      hh[4] = 1359893119;
      hh[5] = 2600822924;
      hh[6] = 528734635;
      hh[7] = 1541459225;
      hl[0] = 4089235720;
      hl[1] = 2227873595;
      hl[2] = 4271175723;
      hl[3] = 1595750129;
      hl[4] = 2917565137;
      hl[5] = 725511199;
      hl[6] = 4215389547;
      hl[7] = 327033209;
      crypto_hashblocks_hl(hh, hl, m, n);
      n %= 128;
      for (i = 0;i < n; i++)
        x[i] = m[b - n + i];
      x[n] = 128;
      n = 256 - 128 * (n < 112 ? 1 : 0);
      x[n - 9] = 0;
      ts64(x, n - 8, b / 536870912 | 0, b << 3);
      crypto_hashblocks_hl(hh, hl, x, n);
      for (i = 0;i < 8; i++)
        ts64(out, 8 * i, hh[i], hl[i]);
      return 0;
    }
    function add2(p, q) {
      var a = gf(), b = gf(), c = gf(), d = gf(), e8 = gf(), f = gf(), g = gf(), h = gf(), t = gf();
      Z(a, p[1], p[0]);
      Z(t, q[1], q[0]);
      M(a, a, t);
      A(b, p[0], p[1]);
      A(t, q[0], q[1]);
      M(b, b, t);
      M(c, p[3], q[3]);
      M(c, c, D22);
      M(d, p[2], q[2]);
      A(d, d, d);
      Z(e8, b, a);
      Z(f, d, c);
      A(g, d, c);
      A(h, b, a);
      M(p[0], e8, f);
      M(p[1], h, g);
      M(p[2], g, f);
      M(p[3], e8, h);
    }
    function cswap(p, q, b) {
      var i;
      for (i = 0;i < 4; i++) {
        sel25519(p[i], q[i], b);
      }
    }
    function pack(r, p) {
      var tx = gf(), ty = gf(), zi = gf();
      inv25519(zi, p[2]);
      M(tx, p[0], zi);
      M(ty, p[1], zi);
      pack25519(r, ty);
      r[31] ^= par25519(tx) << 7;
    }
    function scalarmult(p, q, s3) {
      var b, i;
      set25519(p[0], gf0);
      set25519(p[1], gf1);
      set25519(p[2], gf1);
      set25519(p[3], gf0);
      for (i = 255;i >= 0; --i) {
        b = s3[i / 8 | 0] >> (i & 7) & 1;
        cswap(p, q, b);
        add2(q, p);
        add2(p, p);
        cswap(p, q, b);
      }
    }
    function scalarbase(p, s3) {
      var q = [gf(), gf(), gf(), gf()];
      set25519(q[0], X);
      set25519(q[1], Y);
      set25519(q[2], gf1);
      M(q[3], X, Y);
      scalarmult(p, q, s3);
    }
    function crypto_sign_keypair(pk, sk, seeded) {
      var d = new Uint8Array(64);
      var p = [gf(), gf(), gf(), gf()];
      var i;
      if (!seeded)
        randombytes(sk, 32);
      crypto_hash(d, sk, 32);
      d[0] &= 248;
      d[31] &= 127;
      d[31] |= 64;
      scalarbase(p, d);
      pack(pk, p);
      for (i = 0;i < 32; i++)
        sk[i + 32] = pk[i];
      return 0;
    }
    var L = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
    function modL(r, x) {
      var carry, i, j, k;
      for (i = 63;i >= 32; --i) {
        carry = 0;
        for (j = i - 32, k = i - 12;j < k; ++j) {
          x[j] += carry - 16 * x[i] * L[j - (i - 32)];
          carry = Math.floor((x[j] + 128) / 256);
          x[j] -= carry * 256;
        }
        x[j] += carry;
        x[i] = 0;
      }
      carry = 0;
      for (j = 0;j < 32; j++) {
        x[j] += carry - (x[31] >> 4) * L[j];
        carry = x[j] >> 8;
        x[j] &= 255;
      }
      for (j = 0;j < 32; j++)
        x[j] -= carry * L[j];
      for (i = 0;i < 32; i++) {
        x[i + 1] += x[i] >> 8;
        r[i] = x[i] & 255;
      }
    }
    function reduce(r) {
      var x = new Float64Array(64), i;
      for (i = 0;i < 64; i++)
        x[i] = r[i];
      for (i = 0;i < 64; i++)
        r[i] = 0;
      modL(r, x);
    }
    function crypto_sign(sm, m, n, sk) {
      var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);
      var i, j, x = new Float64Array(64);
      var p = [gf(), gf(), gf(), gf()];
      crypto_hash(d, sk, 32);
      d[0] &= 248;
      d[31] &= 127;
      d[31] |= 64;
      var smlen = n + 64;
      for (i = 0;i < n; i++)
        sm[64 + i] = m[i];
      for (i = 0;i < 32; i++)
        sm[32 + i] = d[32 + i];
      crypto_hash(r, sm.subarray(32), n + 32);
      reduce(r);
      scalarbase(p, r);
      pack(sm, p);
      for (i = 32;i < 64; i++)
        sm[i] = sk[i];
      crypto_hash(h, sm, n + 64);
      reduce(h);
      for (i = 0;i < 64; i++)
        x[i] = 0;
      for (i = 0;i < 32; i++)
        x[i] = r[i];
      for (i = 0;i < 32; i++) {
        for (j = 0;j < 32; j++) {
          x[i + j] += h[i] * d[j];
        }
      }
      modL(sm.subarray(32), x);
      return smlen;
    }
    function unpackneg(r, p) {
      var t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
      set25519(r[2], gf1);
      unpack25519(r[1], p);
      S(num, r[1]);
      M(den, num, D3);
      Z(num, num, r[2]);
      A(den, r[2], den);
      S(den2, den);
      S(den4, den2);
      M(den6, den4, den2);
      M(t, den6, num);
      M(t, t, den);
      pow2523(t, t);
      M(t, t, num);
      M(t, t, den);
      M(t, t, den);
      M(r[0], t, den);
      S(chk, r[0]);
      M(chk, chk, den);
      if (neq25519(chk, num))
        M(r[0], r[0], I);
      S(chk, r[0]);
      M(chk, chk, den);
      if (neq25519(chk, num))
        return -1;
      if (par25519(r[0]) === p[31] >> 7)
        Z(r[0], gf0, r[0]);
      M(r[3], r[0], r[1]);
      return 0;
    }
    function crypto_sign_open(m, sm, n, pk) {
      var i;
      var t = new Uint8Array(32), h = new Uint8Array(64);
      var p = [gf(), gf(), gf(), gf()], q = [gf(), gf(), gf(), gf()];
      if (n < 64)
        return -1;
      if (unpackneg(q, pk))
        return -1;
      for (i = 0;i < n; i++)
        m[i] = sm[i];
      for (i = 0;i < 32; i++)
        m[i + 32] = pk[i];
      crypto_hash(h, m, n);
      reduce(h);
      scalarmult(p, q, h);
      scalarbase(q, sm.subarray(32));
      add2(p, q);
      pack(t, p);
      n -= 64;
      if (crypto_verify_32(sm, 0, t, 0)) {
        for (i = 0;i < n; i++)
          m[i] = 0;
        return -1;
      }
      for (i = 0;i < n; i++)
        m[i] = sm[i + 64];
      return n;
    }
    var crypto_secretbox_KEYBYTES = 32, crypto_secretbox_NONCEBYTES = 24, crypto_secretbox_ZEROBYTES = 32, crypto_secretbox_BOXZEROBYTES = 16, crypto_scalarmult_BYTES = 32, crypto_scalarmult_SCALARBYTES = 32, crypto_box_PUBLICKEYBYTES = 32, crypto_box_SECRETKEYBYTES = 32, crypto_box_BEFORENMBYTES = 32, crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES, crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES, crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES, crypto_sign_BYTES = 64, crypto_sign_PUBLICKEYBYTES = 32, crypto_sign_SECRETKEYBYTES = 64, crypto_sign_SEEDBYTES = 32, crypto_hash_BYTES = 64;
    nacl.lowlevel = {
      crypto_core_hsalsa20,
      crypto_stream_xor,
      crypto_stream,
      crypto_stream_salsa20_xor,
      crypto_stream_salsa20,
      crypto_onetimeauth,
      crypto_onetimeauth_verify,
      crypto_verify_16,
      crypto_verify_32,
      crypto_secretbox,
      crypto_secretbox_open,
      crypto_scalarmult,
      crypto_scalarmult_base,
      crypto_box_beforenm,
      crypto_box_afternm,
      crypto_box,
      crypto_box_open,
      crypto_box_keypair,
      crypto_hash,
      crypto_sign,
      crypto_sign_keypair,
      crypto_sign_open,
      crypto_secretbox_KEYBYTES,
      crypto_secretbox_NONCEBYTES,
      crypto_secretbox_ZEROBYTES,
      crypto_secretbox_BOXZEROBYTES,
      crypto_scalarmult_BYTES,
      crypto_scalarmult_SCALARBYTES,
      crypto_box_PUBLICKEYBYTES,
      crypto_box_SECRETKEYBYTES,
      crypto_box_BEFORENMBYTES,
      crypto_box_NONCEBYTES,
      crypto_box_ZEROBYTES,
      crypto_box_BOXZEROBYTES,
      crypto_sign_BYTES,
      crypto_sign_PUBLICKEYBYTES,
      crypto_sign_SECRETKEYBYTES,
      crypto_sign_SEEDBYTES,
      crypto_hash_BYTES,
      gf,
      D: D3,
      L,
      pack25519,
      unpack25519,
      M,
      A,
      S,
      Z,
      pow2523,
      add: add2,
      set25519,
      modL,
      scalarmult,
      scalarbase
    };
    function checkLengths(k, n) {
      if (k.length !== crypto_secretbox_KEYBYTES)
        throw new Error("bad key size");
      if (n.length !== crypto_secretbox_NONCEBYTES)
        throw new Error("bad nonce size");
    }
    function checkBoxLengths(pk, sk) {
      if (pk.length !== crypto_box_PUBLICKEYBYTES)
        throw new Error("bad public key size");
      if (sk.length !== crypto_box_SECRETKEYBYTES)
        throw new Error("bad secret key size");
    }
    function checkArrayTypes() {
      for (var i = 0;i < arguments.length; i++) {
        if (!(arguments[i] instanceof Uint8Array))
          throw new TypeError("unexpected type, use Uint8Array");
      }
    }
    function cleanup(arr) {
      for (var i = 0;i < arr.length; i++)
        arr[i] = 0;
    }
    nacl.randomBytes = function(n) {
      var b = new Uint8Array(n);
      randombytes(b, n);
      return b;
    };
    nacl.secretbox = function(msg, nonce, key) {
      checkArrayTypes(msg, nonce, key);
      checkLengths(key, nonce);
      var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
      var c = new Uint8Array(m.length);
      for (var i = 0;i < msg.length; i++)
        m[i + crypto_secretbox_ZEROBYTES] = msg[i];
      crypto_secretbox(c, m, m.length, nonce, key);
      return c.subarray(crypto_secretbox_BOXZEROBYTES);
    };
    nacl.secretbox.open = function(box, nonce, key) {
      checkArrayTypes(box, nonce, key);
      checkLengths(key, nonce);
      var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
      var m = new Uint8Array(c.length);
      for (var i = 0;i < box.length; i++)
        c[i + crypto_secretbox_BOXZEROBYTES] = box[i];
      if (c.length < 32)
        return null;
      if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0)
        return null;
      return m.subarray(crypto_secretbox_ZEROBYTES);
    };
    nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;
    nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
    nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;
    nacl.scalarMult = function(n, p) {
      checkArrayTypes(n, p);
      if (n.length !== crypto_scalarmult_SCALARBYTES)
        throw new Error("bad n size");
      if (p.length !== crypto_scalarmult_BYTES)
        throw new Error("bad p size");
      var q = new Uint8Array(crypto_scalarmult_BYTES);
      crypto_scalarmult(q, n, p);
      return q;
    };
    nacl.scalarMult.base = function(n) {
      checkArrayTypes(n);
      if (n.length !== crypto_scalarmult_SCALARBYTES)
        throw new Error("bad n size");
      var q = new Uint8Array(crypto_scalarmult_BYTES);
      crypto_scalarmult_base(q, n);
      return q;
    };
    nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
    nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;
    nacl.box = function(msg, nonce, publicKey, secretKey) {
      var k = nacl.box.before(publicKey, secretKey);
      return nacl.secretbox(msg, nonce, k);
    };
    nacl.box.before = function(publicKey, secretKey) {
      checkArrayTypes(publicKey, secretKey);
      checkBoxLengths(publicKey, secretKey);
      var k = new Uint8Array(crypto_box_BEFORENMBYTES);
      crypto_box_beforenm(k, publicKey, secretKey);
      return k;
    };
    nacl.box.after = nacl.secretbox;
    nacl.box.open = function(msg, nonce, publicKey, secretKey) {
      var k = nacl.box.before(publicKey, secretKey);
      return nacl.secretbox.open(msg, nonce, k);
    };
    nacl.box.open.after = nacl.secretbox.open;
    nacl.box.keyPair = function() {
      var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
      var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
      crypto_box_keypair(pk, sk);
      return { publicKey: pk, secretKey: sk };
    };
    nacl.box.keyPair.fromSecretKey = function(secretKey) {
      checkArrayTypes(secretKey);
      if (secretKey.length !== crypto_box_SECRETKEYBYTES)
        throw new Error("bad secret key size");
      var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
      crypto_scalarmult_base(pk, secretKey);
      return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
    };
    nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
    nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
    nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
    nacl.box.nonceLength = crypto_box_NONCEBYTES;
    nacl.box.overheadLength = nacl.secretbox.overheadLength;
    nacl.sign = function(msg, secretKey) {
      checkArrayTypes(msg, secretKey);
      if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
        throw new Error("bad secret key size");
      var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);
      crypto_sign(signedMsg, msg, msg.length, secretKey);
      return signedMsg;
    };
    nacl.sign.open = function(signedMsg, publicKey) {
      checkArrayTypes(signedMsg, publicKey);
      if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
        throw new Error("bad public key size");
      var tmp = new Uint8Array(signedMsg.length);
      var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
      if (mlen < 0)
        return null;
      var m = new Uint8Array(mlen);
      for (var i = 0;i < m.length; i++)
        m[i] = tmp[i];
      return m;
    };
    nacl.sign.detached = function(msg, secretKey) {
      var signedMsg = nacl.sign(msg, secretKey);
      var sig = new Uint8Array(crypto_sign_BYTES);
      for (var i = 0;i < sig.length; i++)
        sig[i] = signedMsg[i];
      return sig;
    };
    nacl.sign.detached.verify = function(msg, sig, publicKey) {
      checkArrayTypes(msg, sig, publicKey);
      if (sig.length !== crypto_sign_BYTES)
        throw new Error("bad signature size");
      if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
        throw new Error("bad public key size");
      var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
      var m = new Uint8Array(crypto_sign_BYTES + msg.length);
      var i;
      for (i = 0;i < crypto_sign_BYTES; i++)
        sm[i] = sig[i];
      for (i = 0;i < msg.length; i++)
        sm[i + crypto_sign_BYTES] = msg[i];
      return crypto_sign_open(m, sm, sm.length, publicKey) >= 0;
    };
    nacl.sign.keyPair = function() {
      var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
      var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
      crypto_sign_keypair(pk, sk);
      return { publicKey: pk, secretKey: sk };
    };
    nacl.sign.keyPair.fromSecretKey = function(secretKey) {
      checkArrayTypes(secretKey);
      if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
        throw new Error("bad secret key size");
      var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
      for (var i = 0;i < pk.length; i++)
        pk[i] = secretKey[32 + i];
      return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
    };
    nacl.sign.keyPair.fromSeed = function(seed) {
      checkArrayTypes(seed);
      if (seed.length !== crypto_sign_SEEDBYTES)
        throw new Error("bad seed size");
      var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
      var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
      for (var i = 0;i < 32; i++)
        sk[i] = seed[i];
      crypto_sign_keypair(pk, sk, true);
      return { publicKey: pk, secretKey: sk };
    };
    nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
    nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
    nacl.sign.seedLength = crypto_sign_SEEDBYTES;
    nacl.sign.signatureLength = crypto_sign_BYTES;
    nacl.hash = function(msg) {
      checkArrayTypes(msg);
      var h = new Uint8Array(crypto_hash_BYTES);
      crypto_hash(h, msg, msg.length);
      return h;
    };
    nacl.hash.hashLength = crypto_hash_BYTES;
    nacl.verify = function(x, y) {
      checkArrayTypes(x, y);
      if (x.length === 0 || y.length === 0)
        return false;
      if (x.length !== y.length)
        return false;
      return vn(x, 0, y, 0, x.length) === 0 ? true : false;
    };
    nacl.setPRNG = function(fn) {
      randombytes = fn;
    };
    (function() {
      var crypto3 = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
      if (crypto3 && crypto3.getRandomValues) {
        var QUOTA = 65536;
        nacl.setPRNG(function(x, n) {
          var i, v = new Uint8Array(n);
          for (i = 0;i < n; i += QUOTA) {
            crypto3.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));
          }
          for (i = 0;i < n; i++)
            x[i] = v[i];
          cleanup(v);
        });
      } else if (true) {
        crypto3 = __require("crypto");
        if (crypto3 && crypto3.randomBytes) {
          nacl.setPRNG(function(x, n) {
            var i, v = crypto3.randomBytes(n);
            for (i = 0;i < n; i++)
              x[i] = v[i];
            cleanup(v);
          });
        }
      }
    })();
  })(typeof module !== "undefined" && exports ? exports : self.nacl = self.nacl || {});
});

// ../sdk-typescript/dist/chunk-6PZ43CO5.js
function createAuthorizationMessage(message) {
  const components = [];
  components.push(Buffer.from(DOMAIN_SEPARATOR, "utf8"));
  const agentBytes = esm_default2.decode(message.agentAddress);
  components.push(Buffer.from(agentBytes));
  const sourceBytes = esm_default2.decode(message.authorizedSource);
  components.push(Buffer.from(sourceBytes));
  const indexLimitBuffer = Buffer.allocUnsafe(8);
  indexLimitBuffer.writeBigUInt64BE(BigInt(message.indexLimit));
  components.push(indexLimitBuffer);
  const expiresAtBuffer = Buffer.allocUnsafe(8);
  expiresAtBuffer.writeBigUInt64BE(BigInt(message.expiresAt));
  components.push(expiresAtBuffer);
  components.push(Buffer.from(message.network, "utf8"));
  if (message.nonce) {
    components.push(Buffer.from(message.nonce, "utf8"));
  }
  return Buffer.concat(components);
}
async function signAuthorizationMessage(message, agentKeypair) {
  const keypairAddress = agentKeypair.publicKey.toBase58();
  if (keypairAddress !== message.agentAddress) {
    throw new Error(`Keypair public key ${keypairAddress} does not match agent address ${message.agentAddress}`);
  }
  const messageBuffer = createAuthorizationMessage(message);
  const nacl = await Promise.resolve().then(() => __toESM(require_nacl_fast(), 1));
  const signature2 = nacl.sign.detached(messageBuffer, agentKeypair.secretKey);
  return signature2;
}
async function verifyAuthorizationSignature(authorization) {
  try {
    const message = {
      agentAddress: authorization.agentAddress,
      authorizedSource: authorization.authorizedSource,
      indexLimit: authorization.indexLimit,
      expiresAt: authorization.expiresAt,
      network: authorization.network,
      nonce: authorization.nonce
    };
    const messageBuffer = createAuthorizationMessage(message);
    const nacl = await Promise.resolve().then(() => __toESM(require_nacl_fast(), 1));
    const agentPubkeyBytes = esm_default2.decode(authorization.agentAddress);
    const isValid = nacl.sign.detached.verify(messageBuffer, authorization.signature, agentPubkeyBytes);
    return isValid;
  } catch (error) {
    console.error("[Auth Signature] Verification failed:", error);
    return false;
  }
}
async function createSignedAuthorization(params, agentKeypair) {
  const agentAddress = address(agentKeypair.publicKey.toBase58());
  const now = Math.floor(Date.now() / 1000);
  const expiresAt = params.expiresAt || now + (params.expiresIn || 2592000);
  const indexLimit = params.indexLimit || 1000;
  const network = params.network || "devnet";
  const nonce = params.nonce !== undefined ? params.nonce : "default";
  const message = {
    agentAddress,
    authorizedSource: params.authorizedSource,
    indexLimit,
    expiresAt,
    network,
    nonce
  };
  const signature2 = await signAuthorizationMessage(message, agentKeypair);
  const authorization = {
    agentAddress,
    authorizedSource: params.authorizedSource,
    indexLimit,
    expiresAt,
    network,
    signature: signature2,
    nonce,
    metadata: params.metadata
  };
  return authorization;
}
function generateNonce() {
  const buffer = new Uint8Array(32);
  globalThis.crypto.getRandomValues(buffer);
  return Buffer.from(buffer).toString("hex");
}
function serializeAuthorization(authorization) {
  return {
    agentAddress: authorization.agentAddress,
    authorizedSource: authorization.authorizedSource,
    indexLimit: authorization.indexLimit,
    expiresAt: authorization.expiresAt,
    network: authorization.network,
    signature: esm_default2.encode(authorization.signature),
    nonce: authorization.nonce,
    metadata: authorization.metadata
  };
}
function deserializeAuthorization(data) {
  return {
    agentAddress: data.agentAddress,
    authorizedSource: data.authorizedSource,
    indexLimit: data.indexLimit,
    expiresAt: data.expiresAt,
    network: data.network,
    signature: esm_default2.decode(data.signature),
    nonce: data.nonce,
    metadata: data.metadata
  };
}
async function getAuthorizationId(authorization) {
  const serialized = serializeAuthorization(authorization);
  const json = JSON.stringify(serialized);
  const encoder = new TextEncoder;
  const data = encoder.encode(json);
  const crypto3 = globalThis.crypto;
  const hashBuffer = await crypto3.subtle.digest("SHA-256", data);
  const hashArray = new Uint8Array(hashBuffer);
  return esm_default2.encode(hashArray);
}
function isAuthorizationExpired(authorization, currentTime) {
  const now = currentTime || Math.floor(Date.now() / 1000);
  return now >= authorization.expiresAt;
}
function isAuthorizationExhausted(authorization, currentIndex) {
  return currentIndex >= authorization.indexLimit;
}
function validateAuthorizationNetwork(authorization, expectedNetwork) {
  return authorization.network === expectedNetwork;
}
var signature_verification_exports, DOMAIN_SEPARATOR = "GhostSpeak Reputation Authorization";
var init_chunk_6PZ43CO5 = __esm(() => {
  init_chunk_Z6ZWNWWR();
  init_index_node5();
  init_esm3();
  signature_verification_exports = {};
  __export2(signature_verification_exports, {
    createAuthorizationMessage: () => createAuthorizationMessage,
    createSignedAuthorization: () => createSignedAuthorization,
    deserializeAuthorization: () => deserializeAuthorization,
    generateNonce: () => generateNonce,
    getAuthorizationId: () => getAuthorizationId,
    isAuthorizationExhausted: () => isAuthorizationExhausted,
    isAuthorizationExpired: () => isAuthorizationExpired,
    serializeAuthorization: () => serializeAuthorization,
    signAuthorizationMessage: () => signAuthorizationMessage,
    validateAuthorizationNetwork: () => validateAuthorizationNetwork,
    verifyAuthorizationSignature: () => verifyAuthorizationSignature
  });
});

// ../sdk-typescript/dist/chunk-RIZZPLLB.js
var CROSSMINT_STAGING_URL = "https://staging.crossmint.com", CROSSMINT_PROD_URL = "https://www.crossmint.com", GHOSTSPEAK_CREDENTIAL_TYPES, CrossmintVCClient = class {
  apiKey;
  baseUrl;
  chain;
  constructor(options2) {
    this.apiKey = options2.apiKey;
    this.baseUrl = options2.environment === "production" ? CROSSMINT_PROD_URL : CROSSMINT_STAGING_URL;
    this.chain = options2.chain || "base-sepolia";
  }
  async createAgentIdentityType() {
    const typeName = GHOSTSPEAK_CREDENTIAL_TYPES.AGENT_IDENTITY;
    const schema = {
      $schema: "https://json-schema.org/draft/2020-12/schema",
      title: "GhostSpeak Agent Identity",
      description: "Verified AI agent identity on the GhostSpeak Protocol",
      type: "object",
      properties: {
        credentialSubject: {
          type: "object",
          properties: {
            agentId: { type: "string" },
            owner: { type: "string" },
            capabilities: { type: "array", items: { type: "string" } },
            registeredAt: { type: "string" },
            reputationScore: { type: "number" },
            totalJobsCompleted: { type: "integer" },
            verified: { type: "boolean" },
            id: { type: "string" }
          },
          required: ["agentId", "owner", "capabilities", "registeredAt", "verified"],
          additionalProperties: false
        }
      }
    };
    return this.createCredentialType(typeName, schema);
  }
  async createReputationType() {
    const typeName = GHOSTSPEAK_CREDENTIAL_TYPES.REPUTATION_SCORE;
    const schema = {
      $schema: "https://json-schema.org/draft/2020-12/schema",
      title: "GhostSpeak Reputation",
      description: "Verified reputation score for GhostSpeak users",
      type: "object",
      properties: {
        credentialSubject: {
          type: "object",
          properties: {
            userId: { type: "string" },
            walletAddress: { type: "string" },
            reputationScore: { type: "number" },
            totalTransactions: { type: "integer" },
            disputeRate: { type: "number" },
            memberSince: { type: "string" },
            id: { type: "string" }
          },
          required: ["userId", "walletAddress", "reputationScore", "memberSince"],
          additionalProperties: false
        }
      }
    };
    return this.createCredentialType(typeName, schema);
  }
  async createJobCompletionType() {
    const typeName = GHOSTSPEAK_CREDENTIAL_TYPES.JOB_COMPLETION;
    const schema = {
      $schema: "https://json-schema.org/draft/2020-12/schema",
      title: "GhostSpeak Job Completion",
      description: "Certificate of successful job completion on GhostSpeak",
      type: "object",
      properties: {
        credentialSubject: {
          type: "object",
          properties: {
            jobId: { type: "string" },
            agentId: { type: "string" },
            clientAddress: { type: "string" },
            completedAt: { type: "string" },
            amountPaid: { type: "string" },
            rating: { type: "integer" },
            review: { type: "string" },
            id: { type: "string" }
          },
          required: ["jobId", "agentId", "clientAddress", "completedAt", "amountPaid", "rating"],
          additionalProperties: false
        }
      }
    };
    return this.createCredentialType(typeName, schema);
  }
  async initializeAllTypes() {
    const [agentIdentity, reputation, jobCompletion] = await Promise.all([
      this.createAgentIdentityType(),
      this.createReputationType(),
      this.createJobCompletionType()
    ]);
    return { agentIdentity, reputation, jobCompletion };
  }
  async createAllTemplates(types) {
    const [agentIdentityTemplate, reputationTemplate, jobCompletionTemplate] = await Promise.all([
      this.createTemplate(types.agentIdentity.id, {
        name: "GhostSpeak Agent Identity",
        description: "Verified AI agent identity on the GhostSpeak Protocol",
        imageUrl: "https://www.ghostspeak.io/assets/credential-agent.png"
      }),
      this.createTemplate(types.reputation.id, {
        name: "GhostSpeak Reputation",
        description: "Verified reputation score for GhostSpeak users",
        imageUrl: "https://www.ghostspeak.io/assets/credential-reputation.png"
      }),
      this.createTemplate(types.jobCompletion.id, {
        name: "GhostSpeak Job Completion Certificate",
        description: "Certificate of successful job completion on GhostSpeak",
        imageUrl: "https://www.ghostspeak.io/assets/credential-job.png"
      })
    ]);
    return { agentIdentityTemplate, reputationTemplate, jobCompletionTemplate };
  }
  async issueAgentCredential(templateId, recipientEmail, subject, expiresAt) {
    return this.issueCredential(templateId, recipientEmail, subject, expiresAt);
  }
  async issueReputationCredential(templateId, recipientEmail, subject, expiresAt) {
    return this.issueCredential(templateId, recipientEmail, subject, expiresAt);
  }
  async issueJobCompletionCredential(templateId, recipientEmail, subject, expiresAt) {
    return this.issueCredential(templateId, recipientEmail, subject, expiresAt);
  }
  async createCredentialType(typeName, schema) {
    const response = await fetch(`${this.baseUrl}/api/v1-alpha1/credentials/types/${typeName}`, {
      method: "PUT",
      headers: {
        "Content-Type": "application/json",
        "X-API-KEY": this.apiKey
      },
      body: JSON.stringify(schema)
    });
    if (!response.ok) {
      const error = await response.json().catch(() => ({ message: response.statusText }));
      throw new Error(`Failed to create credential type: ${JSON.stringify(error)}`);
    }
    return response.json();
  }
  async createTemplate(typeId, metadata) {
    const response = await fetch(`${this.baseUrl}/api/v1-alpha1/credentials/templates/`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "X-API-KEY": this.apiKey
      },
      body: JSON.stringify({
        credentials: {
          type: typeId,
          encryption: "none",
          storage: "crossmint"
        },
        metadata,
        chain: this.chain
      })
    });
    if (!response.ok) {
      const text = await response.text();
      try {
        const error = JSON.parse(text);
        throw new Error(`Failed to create template: ${JSON.stringify(error)}`);
      } catch (e8) {
        throw new Error(`Failed to create template (${response.status}): ${text}`);
      }
    }
    const action = await response.json();
    const result = await this.waitForAction(action.id);
    if (result.data && result.data.collection) {
      return result.data.collection;
    }
    return result.data || result;
  }
  async waitForAction(actionId) {
    let retries = 0;
    while (retries < 60) {
      await new Promise((resolve) => setTimeout(resolve, 2000));
      const response = await fetch(`${this.baseUrl}/api/2022-06-09/actions/${actionId}`, {
        headers: {
          "X-API-KEY": this.apiKey
        }
      });
      if (!response.ok) {
        throw new Error(`Failed to poll action: ${response.statusText}`);
      }
      const action = await response.json();
      if (action.status === "succeeded") {
        return action;
      }
      if (action.status === "failed") {
        throw new Error(`Action failed: ${JSON.stringify(action)}`);
      }
      retries++;
    }
    throw new Error("Action polling timed out");
  }
  async issueCredential(templateId, recipientEmail, subject, expiresAt) {
    const response = await fetch(`${this.baseUrl}/api/v1-alpha1/credentials/templates/${templateId}/vcs`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "X-API-KEY": this.apiKey
      },
      body: JSON.stringify({
        recipient: `email:${recipientEmail}:${this.chain}`,
        credential: {
          subject,
          expiresAt: expiresAt || this.getDefaultExpiry()
        }
      })
    });
    if (!response.ok) {
      const error = await response.json().catch(() => ({ message: response.statusText }));
      throw new Error(`Failed to issue credential: ${JSON.stringify(error)}`);
    }
    return response.json();
  }
  async getCredential(credentialId) {
    const response = await fetch(`${this.baseUrl}/api/v1-alpha1/credentials/${credentialId}`, {
      headers: {
        "X-API-KEY": this.apiKey
      }
    });
    if (!response.ok) {
      const error = await response.json().catch(() => ({ message: response.statusText }));
      throw new Error(`Failed to get credential: ${JSON.stringify(error)}`);
    }
    return response.json();
  }
  async verifyCredential(credential) {
    const response = await fetch(`${this.baseUrl}/api/v1-alpha1/credentials/verification/verify`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "X-API-KEY": this.apiKey
      },
      body: JSON.stringify({ credential })
    });
    if (!response.ok) {
      const error = await response.json().catch(() => ({ message: response.statusText }));
      throw new Error(`Failed to verify credential: ${JSON.stringify(error)}`);
    }
    return response.json();
  }
  async revokeCredential(credentialId) {
    const response = await fetch(`${this.baseUrl}/api/v1-alpha1/credentials/${credentialId}`, {
      method: "DELETE",
      headers: {
        "X-API-KEY": this.apiKey
      }
    });
    if (!response.ok) {
      const error = await response.json().catch(() => ({ message: response.statusText }));
      throw new Error(`Failed to revoke credential: ${JSON.stringify(error)}`);
    }
    return response.json();
  }
  getDefaultExpiry() {
    const date = /* @__PURE__ */ new Date;
    date.setFullYear(date.getFullYear() + 1);
    return date.toISOString().split("T")[0];
  }
};
var init_chunk_RIZZPLLB = __esm(() => {
  GHOSTSPEAK_CREDENTIAL_TYPES = {
    AGENT_IDENTITY: "GhostSpeakAgentIdentity",
    REPUTATION_SCORE: "GhostSpeakReputation",
    JOB_COMPLETION: "GhostSpeakJobCompletion"
  };
});

// ../sdk-typescript/dist/createAgentAuthorization-J6PRLQV3.js
var exports_createAgentAuthorization_J6PRLQV3 = {};
__export(exports_createAgentAuthorization_J6PRLQV3, {
  parseCreateAgentAuthorizationInstruction: () => parseCreateAgentAuthorizationInstruction,
  getCreateAgentAuthorizationInstructionDataEncoder: () => getCreateAgentAuthorizationInstructionDataEncoder,
  getCreateAgentAuthorizationInstructionDataDecoder: () => getCreateAgentAuthorizationInstructionDataDecoder,
  getCreateAgentAuthorizationInstructionDataCodec: () => getCreateAgentAuthorizationInstructionDataCodec,
  getCreateAgentAuthorizationInstructionAsync: () => getCreateAgentAuthorizationInstructionAsync,
  getCreateAgentAuthorizationInstruction: () => getCreateAgentAuthorizationInstruction,
  getCreateAgentAuthorizationDiscriminatorBytes: () => getCreateAgentAuthorizationDiscriminatorBytes,
  CREATE_AGENT_AUTHORIZATION_DISCRIMINATOR: () => CREATE_AGENT_AUTHORIZATION_DISCRIMINATOR
});
var init_createAgentAuthorization_J6PRLQV3 = __esm(() => {
  init_chunk_46QWY3MG();
  init_chunk_AWMGX3OX();
  init_chunk_Z6ZWNWWR();
});

// ../sdk-typescript/dist/updateReputationWithAuth-XIW6VQRO.js
var exports_updateReputationWithAuth_XIW6VQRO = {};
__export(exports_updateReputationWithAuth_XIW6VQRO, {
  parseUpdateReputationWithAuthInstruction: () => parseUpdateReputationWithAuthInstruction,
  getUpdateReputationWithAuthInstructionDataEncoder: () => getUpdateReputationWithAuthInstructionDataEncoder,
  getUpdateReputationWithAuthInstructionDataDecoder: () => getUpdateReputationWithAuthInstructionDataDecoder,
  getUpdateReputationWithAuthInstructionDataCodec: () => getUpdateReputationWithAuthInstructionDataCodec,
  getUpdateReputationWithAuthInstructionAsync: () => getUpdateReputationWithAuthInstructionAsync,
  getUpdateReputationWithAuthInstruction: () => getUpdateReputationWithAuthInstruction,
  getUpdateReputationWithAuthDiscriminatorBytes: () => getUpdateReputationWithAuthDiscriminatorBytes,
  UPDATE_REPUTATION_WITH_AUTH_DISCRIMINATOR: () => UPDATE_REPUTATION_WITH_AUTH_DISCRIMINATOR
});
var init_updateReputationWithAuth_XIW6VQRO = __esm(() => {
  init_chunk_QLRWUHN2();
  init_chunk_AWMGX3OX();
  init_chunk_Z6ZWNWWR();
});

// ../sdk-typescript/dist/revokeAuthorization-P775ELO6.js
var exports_revokeAuthorization_P775ELO6 = {};
__export(exports_revokeAuthorization_P775ELO6, {
  parseRevokeAuthorizationInstruction: () => parseRevokeAuthorizationInstruction,
  getRevokeAuthorizationInstructionDataEncoder: () => getRevokeAuthorizationInstructionDataEncoder,
  getRevokeAuthorizationInstructionDataDecoder: () => getRevokeAuthorizationInstructionDataDecoder,
  getRevokeAuthorizationInstructionDataCodec: () => getRevokeAuthorizationInstructionDataCodec,
  getRevokeAuthorizationInstruction: () => getRevokeAuthorizationInstruction,
  getRevokeAuthorizationDiscriminatorBytes: () => getRevokeAuthorizationDiscriminatorBytes,
  REVOKE_AUTHORIZATION_DISCRIMINATOR: () => REVOKE_AUTHORIZATION_DISCRIMINATOR
});
var init_revokeAuthorization_P775ELO6 = __esm(() => {
  init_chunk_A7ALCVUI();
  init_chunk_AWMGX3OX();
  init_chunk_Z6ZWNWWR();
});

// ../sdk-typescript/dist/chunk-OKBIWPBC.js
function calculateVisibleScore(score, privacyMode, hasAccess) {
  if (hasAccess || privacyMode === "Public") {
    return {
      exactScore: score,
      tier: getReputationTier(score),
      scoreRange: getScoreRange(score)
    };
  }
  switch (privacyMode) {
    case "TierOnly":
      return {
        tier: getReputationTier(score)
      };
    case "RangeOnly":
      return {
        scoreRange: getScoreRange(score)
      };
    case "Confidential":
      return {};
    case "Custom":
      return {
        tier: getReputationTier(score),
        scoreRange: getScoreRange(score)
      };
    default:
      return {};
  }
}
function getReputationTier(score) {
  if (score >= PRIVACY_CONSTANTS.TIER_THRESHOLDS.PLATINUM) {
    return "Platinum";
  } else if (score >= PRIVACY_CONSTANTS.TIER_THRESHOLDS.GOLD) {
    return "Gold";
  } else if (score >= PRIVACY_CONSTANTS.TIER_THRESHOLDS.SILVER) {
    return "Silver";
  } else if (score >= PRIVACY_CONSTANTS.TIER_THRESHOLDS.BRONZE) {
    return "Bronze";
  }
  return "None";
}
function getScoreRange(score) {
  const ranges = PRIVACY_CONSTANTS.SCORE_RANGES;
  if (score >= ranges.VERY_HIGH.min) {
    return "VeryHigh";
  } else if (score >= ranges.HIGH.min) {
    return "High";
  } else if (score >= ranges.MEDIUM.min) {
    return "Medium";
  } else if (score >= ranges.LOW.min) {
    return "Low";
  }
  return "VeryLow";
}
function canViewerAccess(viewerAddress, settings, agentAddress) {
  if (viewerAddress === agentAddress) {
    return true;
  }
  return settings.authorizedViewers.includes(viewerAddress);
}
function filterMetricsByVisibility(reputationData, metricVisibility, hasAccess) {
  const result = {
    agent: reputationData.agent
  };
  const isVisible = (level) => {
    return hasAccess || level === "Public";
  };
  if (isVisible(metricVisibility.showScore)) {
    result.exactScore = reputationData.overallScore;
  }
  if (isVisible(metricVisibility.showJobsCompleted)) {
    result.totalJobsCompleted = reputationData.totalJobsCompleted;
  }
  if (isVisible(metricVisibility.showSuccessRate)) {
    const total = reputationData.totalJobsCompleted + reputationData.totalJobsFailed;
    result.successRate = total > 0 ? reputationData.totalJobsCompleted / total * 100 : 0;
  }
  if (isVisible(metricVisibility.showResponseTime)) {
    result.avgResponseTime = reputationData.avgResponseTime;
  }
  if (isVisible(metricVisibility.showDisputes)) {
    result.disputes = {
      total: reputationData.disputesAgainst,
      resolved: reputationData.disputesResolved
    };
  }
  if (isVisible(metricVisibility.showEarnings) && reputationData.totalEarnings !== undefined) {
    result.totalEarnings = reputationData.totalEarnings;
  }
  if (isVisible(metricVisibility.showRatings) && reputationData.avgRating !== undefined) {
    result.avgRating = reputationData.avgRating;
  }
  if (isVisible(metricVisibility.showBadges) && reputationData.badges !== undefined) {
    result.badges = reputationData.badges;
  }
  result.hasFullAccess = hasAccess;
  return result;
}
function getDefaultMetricVisibility(mode) {
  switch (mode) {
    case "Public":
      return {
        showScore: "Public",
        showJobsCompleted: "Public",
        showSuccessRate: "Public",
        showResponseTime: "Public",
        showDisputes: "Public",
        showEarnings: "Public",
        showRatings: "Public",
        showBadges: "Public"
      };
    case "TierOnly":
    case "RangeOnly":
      return {
        showScore: "Private",
        showJobsCompleted: "Private",
        showSuccessRate: "Private",
        showResponseTime: "Private",
        showDisputes: "Private",
        showEarnings: "Private",
        showRatings: "Private",
        showBadges: "Public"
      };
    case "Confidential":
      return {
        showScore: "ZKProof",
        showJobsCompleted: "ZKProof",
        showSuccessRate: "ZKProof",
        showResponseTime: "ZKProof",
        showDisputes: "ZKProof",
        showEarnings: "ZKProof",
        showRatings: "ZKProof",
        showBadges: "ZKProof"
      };
    case "Custom":
    default:
      return {
        showScore: "Private",
        showJobsCompleted: "Public",
        showSuccessRate: "Public",
        showResponseTime: "Public",
        showDisputes: "Private",
        showEarnings: "Private",
        showRatings: "Public",
        showBadges: "Public"
      };
  }
}
function validatePrivacySettings(settings) {
  const errors2 = [];
  if (settings.authorizedViewers.length > PRIVACY_CONSTANTS.MAX_AUTHORIZED_VIEWERS) {
    errors2.push(`Too many authorized viewers (max: ${PRIVACY_CONSTANTS.MAX_AUTHORIZED_VIEWERS})`);
  }
  if (settings.mode === "Public") {
    const hasPrivateMetric = Object.values(settings.metricVisibility).some((level) => level !== "Public");
    if (hasPrivateMetric) {
      errors2.push("Public mode cannot have private metrics");
    }
  }
  return {
    valid: errors2.length === 0,
    errors: errors2
  };
}
function getTierDisplayName(tier) {
  const names = {
    ["None"]: "Unranked",
    ["Bronze"]: "Bronze",
    ["Silver"]: "Silver",
    ["Gold"]: "Gold",
    ["Platinum"]: "Platinum"
  };
  return names[tier];
}
function getRangeDisplayString(range) {
  const ranges = {
    ["VeryLow"]: "0-2000",
    ["Low"]: "2000-5000",
    ["Medium"]: "5000-7500",
    ["High"]: "7500-9000",
    ["VeryHigh"]: "9000-10000"
  };
  return ranges[range];
}
function sol(amount) {
  return BigInt(Math.floor(amount * 1e9));
}
function lamportsToSol2(lamports2) {
  return Number(lamports2) / 1e9;
}
var UnifiedCredentialService = class {
  constructor(config) {
    this.config = config;
    this.credentialModule = new CredentialModule(config.programId);
    if (config.crossmint) {
      this.crossmintClient = new CrossmintVCClient(config.crossmint);
    }
  }
  credentialModule;
  crossmintClient;
  async issueAgentIdentityCredential(params) {
    const subjectData = CredentialModule.buildAgentIdentitySubject({
      agentId: params.agentId,
      owner: params.owner,
      name: params.name,
      capabilities: params.capabilities,
      serviceEndpoint: params.serviceEndpoint,
      frameworkOrigin: params.frameworkOrigin,
      x402Enabled: params.x402Enabled,
      registeredAt: params.registeredAt,
      verifiedAt: params.verifiedAt
    });
    const credentialId = this.credentialModule.generateCredentialId("AgentIdentity", params.owner);
    const subjectDataHash = this.credentialModule.hashSubjectData(subjectData);
    const credential = {
      template: "11111111111111111111111111111111",
      subject: params.owner,
      issuer: params.owner,
      credentialId,
      subjectDataHash,
      subjectDataUri: `ipfs://placeholder/${credentialId}`,
      status: "Active",
      signature: params.signature,
      issuedAt: Math.floor(Date.now() / 1000),
      expiresAt: undefined,
      revokedAt: undefined,
      crossmintCredentialId: undefined
    };
    const mockType = {
      authority: "11111111111111111111111111111111",
      name: "AgentIdentity",
      kind: "AgentIdentity",
      schemaUri: "https://ghostspeak.io/schemas/agent-identity.json",
      description: "Verified AI agent identity on GhostSpeak Protocol",
      isActive: true,
      totalIssued: 1,
      createdAt: Math.floor(Date.now() / 1000)
    };
    const mockTemplate = {
      credentialType: "11111111111111111111111111111111",
      name: "GhostSpeak Agent Identity",
      imageUri: "https://www.ghostspeak.io/assets/credential-agent.png",
      issuer: params.owner,
      isActive: true,
      totalIssued: 1,
      createdAt: Math.floor(Date.now() / 1000),
      crossmintTemplateId: this.config.crossmintTemplates?.agentIdentity
    };
    const w3cCredential = this.credentialModule.exportAsW3CCredential(credential, mockTemplate, mockType, subjectData);
    const result = {
      solanaCredential: {
        credentialId
      },
      w3cCredential
    };
    if (params.syncToCrossmint && this.crossmintClient && params.recipientEmail) {
      if (!mockTemplate.crossmintTemplateId) {
        result.crossmintSync = { status: "failed", error: "No template ID configured" };
      } else {
        try {
          const crossmintResult = await this.crossmintClient.issueCredential(mockTemplate.crossmintTemplateId, params.recipientEmail, subjectData);
          result.crossmintSync = {
            status: "synced",
            credentialId: crossmintResult.credentialId,
            chain: this.config.crossmint?.chain
          };
        } catch (error) {
          result.crossmintSync = {
            status: "failed",
            error: error instanceof Error ? error.message : "Unknown error"
          };
        }
      }
    }
    return result;
  }
}, DidModule, PrivacyModule, DEFAULT_STORAGE_FEE = 2000000n, AuthorizationModule, GhostSpeakClient = class {
  config;
  constructor(config) {
    this.config = {
      programId: GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS,
      commitment: "confirmed",
      cluster: "devnet",
      rpcEndpoint: config?.rpcEndpoint ?? this.getDefaultRpcEndpoint(config?.cluster ?? "devnet"),
      ...config,
      rpc: config?.rpc ?? {}
    };
  }
  get agents() {
    return new AgentModule(this.config);
  }
  get ghosts() {
    return new GhostModule(this.config);
  }
  get governanceModule() {
    return new GovernanceModule(this.config);
  }
  get multisigModule() {
    return new MultisigModule(this.config);
  }
  agent() {
    return new AgentBuilder(this.config);
  }
  reputation() {
    return new ReputationModule(this.config);
  }
  tagEngine() {
    const { ReputationTagEngine: ReputationTagEngine2 } = (init_reputation_tag_engine(), __toCommonJS(reputation_tag_engine_exports));
    return new ReputationTagEngine2;
  }
  reputationAggregator() {
    const { MultiSourceAggregator: MultiSourceAggregator2 } = (init_MultiSourceAggregator(), __toCommonJS(MultiSourceAggregator_exports));
    return new MultiSourceAggregator2;
  }
  privacy() {
    return new PrivacyModule(this.config);
  }
  governance() {
    return new GovernanceBuilder(this.config);
  }
  multisig() {
    return new MultisigBuilder(this.config);
  }
  credentials() {
    return new UnifiedCredentialService({
      programId: this.config.programId,
      crossmint: this.config.credentials?.crossmintApiKey ? {
        apiKey: this.config.credentials.crossmintApiKey,
        environment: this.config.credentials.crossmintEnvironment,
        chain: this.config.credentials.crossmintChain
      } : undefined,
      crossmintTemplates: this.config.credentials?.templates
    });
  }
  did() {
    return new DidModule(this.config);
  }
  get authorization() {
    return new AuthorizationModule(this.config);
  }
  get staking() {
    return new StakingModule(this.config);
  }
  enableDevMode() {
    console.log("\uD83D\uDEE0ï¸ Development mode enabled");
    console.log("   - Transaction simulation before sending");
    console.log("   - Cost estimates for all operations");
    console.log("   - Enhanced error messages");
    this.config = {
      ...this.config
    };
    return this;
  }
  useNetwork(cluster) {
    this.config.cluster = cluster;
    this.config.rpcEndpoint = this.getDefaultRpcEndpoint(cluster);
    return this;
  }
  useRpc(endpoint, wsEndpoint) {
    this.config.rpcEndpoint = endpoint;
    this.config.wsEndpoint = wsEndpoint;
    return this;
  }
  getDefaultRpcEndpoint(cluster) {
    switch (cluster) {
      case "mainnet-beta":
        return "https://api.mainnet-beta.solana.com";
      case "devnet":
        return "https://api.devnet.solana.com";
      case "testnet":
        return "https://api.testnet.solana.com";
      case "localnet":
        return "http://localhost:8899";
      default:
        return "https://api.devnet.solana.com";
    }
  }
}, AgentBuilder = class {
  module;
  params = {};
  constructor(config) {
    this.module = new AgentModule(config);
  }
  create(params) {
    this.params = {
      ...this.params,
      agentType: 0,
      metadataUri: JSON.stringify(params),
      agentId: params.name.toLowerCase().replace(/\s+/g, "-"),
      name: params.name,
      description: params.description || ""
    };
    return this;
  }
  withDescription(description) {
    this.params.description = description;
    return this;
  }
  withType(agentType) {
    this.params.agentType = agentType;
    return this;
  }
  withIPFS() {
    this.params.forceIPFS = true;
    return this;
  }
  compressed() {
    this.params.compressed = true;
    return this;
  }
  debug() {
    this.module.debug();
    return this;
  }
  withSigner(signer) {
    this.params.signer = signer;
    return this;
  }
  validateParams() {
    if (!this.params.signer) {
      throw new Error("Agent builder requires a signer. Call with signer first.");
    }
    if (!this.params.metadataUri) {
      throw new Error("Agent builder requires metadata. Call create() first.");
    }
    if (!this.params.agentId) {
      throw new Error("Agent builder requires agent ID. Call create() first.");
    }
    this.params.agentType ??= 0;
  }
  async getCost() {
    this.validateParams();
    return this.module.getCost("registerAgent", () => ({
      programAddress: this.module.getProgramId(),
      accounts: [],
      data: new Uint8Array
    }));
  }
  async simulate() {
    const instruction = () => ({
      programAddress: this.module.getProgramId(),
      accounts: [],
      data: new Uint8Array
    });
    this.validateParams();
    return this.module.simulateInstruction("registerAgent", instruction, [this.params.signer]);
  }
  async explain() {
    this.validateParams();
    return this.module.explain("registerAgent", () => ({
      programAddress: this.module.getProgramId(),
      accounts: [],
      data: new Uint8Array
    }));
  }
  async execute() {
    this.validateParams();
    if (this.params.compressed) {
      console.log("Creating compressed agent (5000x cheaper)...");
    }
    const signature2 = await this.module.register(this.params.signer, {
      agentType: this.params.agentType,
      name: this.params.name,
      description: this.params.description,
      metadataUri: this.params.metadataUri,
      agentId: this.params.agentId
    });
    const address22 = await this.deriveAgentAddress(this.params.agentId, this.params.signer);
    return { address: address22, signature: signature2 };
  }
  async deriveAgentAddress(agentId, signer) {
    const { deriveAgentPda: deriveAgentPda2 } = await Promise.resolve().then(() => (init_pda_LDG2B6LK(), exports_pda_LDG2B6LK));
    const [address22] = await deriveAgentPda2({
      programAddress: this.module.getProgramId(),
      owner: signer.address,
      agentId
    });
    return address22;
  }
}, GovernanceBuilder = class {
  module;
  params = {};
  constructor(config) {
    this.module = new GovernanceModule(config);
  }
  proposal() {
    return new ProposalBuilder(this.module, this.params);
  }
  query() {
    return new GovernanceQuery(this.module);
  }
  debug() {
    this.module.debug();
    return this;
  }
  withSigner(signer) {
    this.params.signer = signer;
    return this;
  }
}, ProposalBuilder = class {
  constructor(module, builderParams) {
    this.module = module;
    this.builderParams = builderParams;
    this.params.signer = builderParams.signer;
  }
  params = {};
  create(params) {
    this.params.title = params.title;
    this.params.description = params.description;
    return this;
  }
  type(proposalType) {
    this.params.proposalType = proposalType;
    return this;
  }
  votingDuration(hours) {
    this.params.votingDuration = hours;
    return this;
  }
  executionDelay(hours) {
    this.params.executionDelay = hours;
    return this;
  }
  validateParams() {
    if (!this.params.signer)
      throw new Error("Signer required");
    if (!this.params.title)
      throw new Error("Title required");
    if (!this.params.description)
      throw new Error("Description required");
    if (!this.params.proposalType)
      throw new Error("Proposal type required");
    if (!this.params.votingDuration)
      throw new Error("Voting duration required");
  }
  async execute() {
    this.validateParams();
    const signature2 = await this.module.createProposal({
      signer: this.params.signer,
      title: this.params.title,
      description: this.params.description,
      proposalType: this.params.proposalType,
      votingDuration: this.params.votingDuration,
      executionDelay: this.params.executionDelay
    });
    const address22 = `proposal_${this.params.signer.address}_${this.params.title}`;
    return { address: address22, signature: signature2 };
  }
  withSigner(signer) {
    this.params.signer = signer;
    return this;
  }
}, GovernanceQuery = class {
  constructor(module) {
    this.module = module;
  }
  async activeProposals() {
    return this.module.getActiveProposals();
  }
  async proposalsByProposer(proposer) {
    return this.module.getProposalsByProposer(proposer);
  }
  async proposalsByStatus(status) {
    return this.module.getProposalsByStatus(status);
  }
}, MultisigBuilder = class {
  module;
  params = {};
  constructor(config) {
    this.module = new MultisigModule(config);
  }
  create() {
    return new CreateMultisigBuilder(this.module, this.params);
  }
  proposal() {
    return new MultisigProposalBuilder(this.module, this.params);
  }
  approve() {
    return new MultisigApproveBuilder(this.module, this.params);
  }
  executeProposal() {
    return new MultisigExecuteBuilder(this.module, this.params);
  }
  withSigner(signer) {
    this.params.signer = signer;
    return this;
  }
  debug() {
    this.module.debug();
    return this;
  }
}, CreateMultisigBuilder = class {
  constructor(module, builderParams) {
    this.module = module;
    this.builderParams = builderParams;
    this.params.signer = builderParams.signer;
  }
  params = {};
  withId(id) {
    this.params.multisigId = id;
    return this;
  }
  threshold(t) {
    this.params.threshold = t;
    return this;
  }
  signers(s3) {
    this.params.signers = s3;
    return this;
  }
  async execute() {
    if (!this.params.signer)
      throw new Error("Signer required");
    if (!this.params.multisigId)
      throw new Error("Multisig ID required");
    if (!this.params.threshold)
      throw new Error("Threshold required");
    if (!this.params.signers)
      throw new Error("Signers required");
    return {
      signature: await this.module.createMultisig({
        owner: this.params.signer,
        multisigId: this.params.multisigId,
        threshold: this.params.threshold,
        signers: this.params.signers
      })
    };
  }
  withSigner(signer) {
    this.params.signer = signer;
    return this;
  }
}, MultisigProposalBuilder = class {
  constructor(module, builderParams) {
    this.module = module;
    this.builderParams = builderParams;
    this.params.signer = builderParams.signer;
  }
  params = {};
  forMultisig(address22) {
    this.params.multisigAddress = address22;
    return this;
  }
  title(t) {
    this.params.title = t;
    return this;
  }
  description(d) {
    this.params.description = d;
    return this;
  }
  async execute() {
    if (!this.params.signer)
      throw new Error("Signer required");
    if (!this.params.title)
      throw new Error("Title required");
    if (!this.params.description)
      throw new Error("Description required");
    return {
      signature: await this.module.createProposal({
        multisigAddress: this.params.multisigAddress,
        title: this.params.title,
        description: this.params.description,
        proposalType: 7,
        executionParams: {
          instructions: [],
          executionDelay: 0n,
          executionConditions: [],
          cancellable: true,
          autoExecute: true,
          executionAuthority: this.params.signer.address
        },
        proposalId: BigInt(Date.now()),
        proposer: this.params.signer
      })
    };
  }
  withSigner(signer) {
    this.params.signer = signer;
    return this;
  }
}, MultisigApproveBuilder = class {
  constructor(module, builderParams) {
    this.module = module;
    this.builderParams = builderParams;
    this.params.signer = builderParams.signer;
  }
  params = {};
  proposal(address22) {
    this.params.proposalAddress = address22;
    return this;
  }
  vote(choice) {
    this.params.voteChoice = choice;
    return this;
  }
  reason(text) {
    this.params.reasoning = text;
    return this;
  }
  tokenAccount(account) {
    this.params.tokenAccount = account;
    return this;
  }
  async execute() {
    if (!this.params.signer)
      throw new Error("Signer required");
    if (!this.params.proposalAddress)
      throw new Error("Proposal address required");
    throw new Error("Multisig approval: Use protocol_config instructions for voting (approveProposal removed)");
  }
  withSigner(signer) {
    this.params.signer = signer;
    return this;
  }
}, MultisigExecuteBuilder = class {
  constructor(module, builderParams) {
    this.module = module;
    this.builderParams = builderParams;
    this.params.signer = builderParams.signer;
  }
  params = {};
  proposal(address22) {
    this.params.proposalAddress = address22;
    return this;
  }
  target(programId) {
    this.params.targetProgram = programId;
    return this;
  }
  async execute() {
    if (!this.params.signer)
      throw new Error("Signer required");
    if (!this.params.proposalAddress)
      throw new Error("Proposal address required");
    if (!this.params.targetProgram)
      throw new Error("Target program required");
    return {
      signature: await this.module.executeProposal({
        proposalAddress: this.params.proposalAddress,
        executor: this.params.signer,
        targetProgram: this.params.targetProgram
      })
    };
  }
  withSigner(signer) {
    this.params.signer = signer;
    return this;
  }
}, GhostSpeakClient_default;
var init_chunk_OKBIWPBC = __esm(() => {
  init_chunk_AJSWRU6F();
  init_chunk_6PZ43CO5();
  init_chunk_CO2WD4XR();
  init_chunk_AWMGX3OX();
  init_chunk_RIZZPLLB();
  init_chunk_Z6ZWNWWR();
  init_index_node5();
  DidModule = class extends BaseModule {
    constructor(config) {
      super(config);
    }
    async create(signer, params) {
      const network = params.network || "devnet";
      const didString = generateDidString(network, params.controller);
      validateDidString(didString);
      const [didDocumentPda] = await deriveDidDocumentPda(this.programId, params.controller);
      const instructionGetter = async () => {
        return this.buildCreateDidInstruction(didDocumentPda, params.controller, didString, params.verificationMethods || [], params.serviceEndpoints || []);
      };
      return this.execute("createDidDocument", instructionGetter, [signer]);
    }
    async update(signer, params) {
      const instructionGetter = async () => {
        return this.buildUpdateDidInstruction(params.didDocument, signer.address, params.addVerificationMethod || null, params.removeVerificationMethodId || null, params.addServiceEndpoint || null, params.removeServiceEndpointId || null);
      };
      return this.execute("updateDidDocument", instructionGetter, [signer]);
    }
    async deactivate(signer, params) {
      const instructionGetter = async () => {
        return this.buildDeactivateDidInstruction(params.didDocument, signer.address);
      };
      return this.execute("deactivateDidDocument", instructionGetter, [signer]);
    }
    async resolve(didOrController) {
      let controllerAddress;
      if (typeof didOrController === "string" && didOrController.startsWith("did:sol:")) {
        const { identifier } = parseDidString(didOrController);
        controllerAddress = address(identifier);
      } else {
        controllerAddress = typeof didOrController === "string" ? address(didOrController) : didOrController;
      }
      const [didDocumentPda] = await deriveDidDocumentPda(this.programId, controllerAddress);
      return this.getAccount(didDocumentPda, "getDidDocumentDecoder");
    }
    async exportW3C(didOrController, pretty = true) {
      const didDoc = await this.resolve(didOrController);
      if (!didDoc)
        return null;
      return didDocumentToJson(didDoc, pretty);
    }
    async getW3CDocument(didOrController) {
      const didDoc = await this.resolve(didOrController);
      if (!didDoc)
        return null;
      return exportAsW3CDidDocument(didDoc);
    }
    async deriveDidPda(controller) {
      return deriveDidDocumentPda(this.programId, controller);
    }
    generateDid(controller, network = "devnet") {
      return generateDidString(network, controller);
    }
    validateDid(did) {
      validateDidString(did);
      return true;
    }
    async isActive(didOrController) {
      const didDoc = await this.resolve(didOrController);
      if (!didDoc)
        return false;
      return isDidActive(didDoc);
    }
    buildCreateDidInstruction(didDocument, controller, didString, verificationMethods, serviceEndpoints) {
      throw new Error("DID instructions are not yet generated. Please run: bun run generate:client after adding DID instructions to the program.");
    }
    buildUpdateDidInstruction(didDocument, controller, addVerificationMethod, removeVerificationMethodId, addServiceEndpoint, removeServiceEndpointId) {
      throw new Error("DID instructions are not yet generated. Please run: bun run generate:client after adding DID instructions to the program.");
    }
    buildDeactivateDidInstruction(didDocument, controller) {
      throw new Error("DID instructions are not yet generated. Please run: bun run generate:client after adding DID instructions to the program.");
    }
    static createVerificationMethod = createEd25519VerificationMethod;
    static createServiceEndpoint = createServiceEndpoint;
  };
  PrivacyModule = class extends BaseModule {
    constructor(config) {
      super(config);
    }
    async initializePrivacy(signer, params) {
      const mode = params.mode ?? "Public";
      params.metricVisibility ?? getDefaultMetricVisibility(mode);
      const instructionGetter = async () => {
        return {
          programAddress: this.programId,
          accounts: [],
          data: new Uint8Array([0])
        };
      };
      return this.execute("initializePrivacy", instructionGetter, [signer]);
    }
    async updatePrivacyMode(signer, params) {
      const instructionGetter = async () => {
        return {
          programAddress: this.programId,
          accounts: [],
          data: new Uint8Array([1])
        };
      };
      return this.execute("updatePrivacyMode", instructionGetter, [signer]);
    }
    async setMetricVisibility(signer, params) {
      const instructionGetter = async () => {
        return {
          programAddress: this.programId,
          accounts: [],
          data: new Uint8Array([2])
        };
      };
      return this.execute("setMetricVisibility", instructionGetter, [signer]);
    }
    async grantAccess(signer, params) {
      const instructionGetter = async () => {
        return {
          programAddress: this.programId,
          accounts: [],
          data: new Uint8Array([3])
        };
      };
      return this.execute("grantAccess", instructionGetter, [signer]);
    }
    async revokeAccess(signer, params) {
      const instructionGetter = async () => {
        return {
          programAddress: this.programId,
          accounts: [],
          data: new Uint8Array([4])
        };
      };
      return this.execute("revokeAccess", instructionGetter, [signer]);
    }
    async applyPreset(signer, params) {
      const { preset } = params;
      await this.updatePrivacyMode(signer, {
        agentAddress: params.agentAddress,
        mode: preset.mode
      });
      return this.setMetricVisibility(signer, {
        agentAddress: params.agentAddress,
        metricVisibility: preset.metricVisibility
      });
    }
    async getPrivacySettings(agentAddress) {
      return {
        agent: agentAddress,
        mode: "Public",
        metricVisibility: getDefaultMetricVisibility("Public"),
        authorizedViewers: [],
        autoGrantClients: false,
        updatedAt: Math.floor(Date.now() / 1000)
      };
    }
    async getVisibleReputation(agentAddress, viewerAddress) {
      let privacySettings = await this.getPrivacySettings(agentAddress);
      if (!privacySettings) {
        privacySettings = {
          agent: agentAddress,
          mode: "Public",
          metricVisibility: getDefaultMetricVisibility("Public"),
          authorizedViewers: [],
          autoGrantClients: false,
          updatedAt: Math.floor(Date.now() / 1000)
        };
      }
      const hasAccess = canViewerAccess(viewerAddress, privacySettings, agentAddress);
      const reputationData = {
        agent: agentAddress,
        overallScore: 7500,
        totalJobsCompleted: 100,
        totalJobsFailed: 5,
        avgResponseTime: 250,
        disputesAgainst: 2,
        disputesResolved: 2,
        totalEarnings: 50000,
        avgRating: 4.5,
        badges: ["FirstJob", "TenJobs", "QuickResponder"]
      };
      const visibleScore = calculateVisibleScore(reputationData.overallScore, privacySettings.mode, hasAccess);
      const filteredMetrics = filterMetricsByVisibility(reputationData, privacySettings.metricVisibility, hasAccess);
      return {
        ...filteredMetrics,
        privacyMode: privacySettings.mode,
        ...visibleScore,
        hasFullAccess: hasAccess
      };
    }
    validateSettings(settings) {
      return validatePrivacySettings(settings);
    }
    getAvailablePresets() {
      return PrivacyPresets;
    }
    getDefaultVisibility(mode) {
      return getDefaultMetricVisibility(mode);
    }
    getTier(score) {
      return getReputationTier(score);
    }
    getRange(score) {
      return getScoreRange(score);
    }
    async derivePrivacyPda(agentAddress) {
      const { getProgramDerivedAddress: getProgramDerivedAddress3, getAddressEncoder: getAddressEncoder3 } = await Promise.resolve().then(() => (init_index_node5(), exports_index_node));
      const addressEncoder = getAddressEncoder3();
      const agentBytes = addressEncoder.encode(agentAddress);
      const [pda] = await getProgramDerivedAddress3({
        programAddress: this.programId,
        seeds: [
          new TextEncoder().encode("privacy_settings"),
          agentBytes
        ]
      });
      return pda;
    }
  };
  AuthorizationModule = class extends BaseModule {
    constructor(config) {
      super(config);
    }
    async createAuthorization(params, agentKeypair) {
      return await createSignedAuthorization(params, agentKeypair);
    }
    async storeAuthorizationOnChain(authorization, agentSigner, config) {
      const storageFee = this.calculateStorageFee(authorization, config);
      const feePayedByAgent = config?.feePayedByAgent ?? true;
      console.log(`\uD83D\uDCB0 On-chain storage cost: ${Number(storageFee) / 1e9} SOL`);
      console.log(`   Fee payer: ${feePayedByAgent ? "Agent" : "Facilitator"}`);
      const { getCreateAgentAuthorizationInstructionAsync: getCreateAgentAuthorizationInstructionAsync2 } = await Promise.resolve().then(() => (init_createAgentAuthorization_J6PRLQV3(), exports_createAgentAuthorization_J6PRLQV3));
      const { getProgramDerivedAddress: getProgramDerivedAddress3, getBytesEncoder: getBytesEncoder2, getAddressEncoder: getAddressEncoder3, getUtf8Encoder: getUtf8Encoder2 } = await Promise.resolve().then(() => (init_index_node40(), exports_index_node3));
      const nonce = authorization.nonce ?? "default";
      const [authorizationPda] = await getProgramDerivedAddress3({
        programAddress: this.getProgramId(),
        seeds: [
          getBytesEncoder2().encode(new Uint8Array([97, 103, 101, 110, 116, 95, 97, 117, 116, 104])),
          getAddressEncoder3().encode(authorization.agentAddress),
          getAddressEncoder3().encode(authorization.authorizedSource),
          getUtf8Encoder2().encode(nonce)
        ]
      });
      return await this.execute("createAgentAuthorization", async () => {
        return await getCreateAgentAuthorizationInstructionAsync2({
          agent: authorization.agentAddress,
          authorization: authorizationPda,
          authority: agentSigner,
          authorizedSource: authorization.authorizedSource,
          indexLimit: BigInt(authorization.indexLimit),
          expiresAt: BigInt(authorization.expiresAt),
          network: authorization.network === "mainnet-beta" ? 0 : authorization.network === "devnet" ? 1 : 2,
          signature: authorization.signature,
          nonce
        });
      }, [agentSigner]);
    }
    async verifySignature(authorization) {
      return verifyAuthorizationSignature(authorization);
    }
    getAuthorizationStatus(authorization, currentIndex) {
      const now = Math.floor(Date.now() / 1000);
      const idx = currentIndex ?? 0;
      if (isAuthorizationExpired(authorization, now)) {
        return {
          status: "expired",
          isValid: false,
          remainingUses: 0,
          reason: "Authorization has expired"
        };
      }
      if (isAuthorizationExhausted(authorization, idx)) {
        return {
          status: "exhausted",
          isValid: false,
          remainingUses: 0,
          reason: "Index limit reached"
        };
      }
      const remaining = authorization.indexLimit - idx;
      return {
        status: "active",
        isValid: true,
        remainingUses: remaining
      };
    }
    async fetchAuthorization(agentAddress, authorizedSource, nonce) {
      throw new Error("On-chain fetch not yet implemented - pending Codama generation");
    }
    async updateReputationWithAuth(authorization, reputationChange, transactionSignature, usageRecord, metadata, facilitatorSigner) {
      const isValid = await this.verifySignature(authorization);
      if (!isValid) {
        throw new Error("Invalid authorization signature");
      }
      const status = this.getAuthorizationStatus(authorization);
      if (!status.isValid) {
        throw new Error(`Authorization is ${status.status}: ${status.reason}`);
      }
      const { getUpdateReputationWithAuthInstructionAsync: getUpdateReputationWithAuthInstructionAsync2 } = await Promise.resolve().then(() => (init_updateReputationWithAuth_XIW6VQRO(), exports_updateReputationWithAuth_XIW6VQRO));
      return await this.execute("updateReputationWithAuth", async () => {
        return await getUpdateReputationWithAuthInstructionAsync2({
          agent: authorization.agentAddress,
          authorizedSource: facilitatorSigner,
          usageRecord,
          reputationChange: BigInt(reputationChange),
          transactionSignature,
          metadata: metadata ? JSON.stringify(metadata) : null,
          nonce: authorization.nonce ?? null
        });
      }, [facilitatorSigner]);
    }
    async revokeAuthorization(agentAddress, authorization, nonce, agentSigner) {
      const { getRevokeAuthorizationInstruction: getRevokeAuthorizationInstruction2 } = await Promise.resolve().then(() => (init_revokeAuthorization_P775ELO6(), exports_revokeAuthorization_P775ELO6));
      return await this.execute("revokeAuthorization", () => {
        return getRevokeAuthorizationInstruction2({
          agent: agentAddress,
          authorization,
          authority: agentSigner,
          nonce: nonce ?? null
        });
      }, [agentSigner]);
    }
    async listAuthorizations(filter) {
      throw new Error("Authorization listing not yet implemented - pending Codama generation");
    }
    serializeAuthorization(authorization) {
      return serializeAuthorization(authorization);
    }
    deserializeAuthorization(data) {
      return deserializeAuthorization(data);
    }
    async getAuthorizationId(authorization) {
      return getAuthorizationId(authorization);
    }
    async createPayAIAuthorization(payAIFacilitatorAddress, agentKeypair, options2) {
      const defaultParams = {
        authorizedSource: payAIFacilitatorAddress,
        indexLimit: 1000,
        expiresIn: 2592000,
        network: "devnet",
        ...options2
      };
      return this.createAuthorization(defaultParams, agentKeypair);
    }
    calculateStorageFee(authorization, config) {
      if (config?.storageFee !== undefined) {
        return config.storageFee;
      }
      if (config?.customFees) {
        const now = Math.floor(Date.now() / 1000);
        const duration = authorization.expiresAt - now;
        const durations = Object.keys(config.customFees).map(Number).sort((a, b) => a - b);
        for (const d of durations) {
          if (duration <= d) {
            return config.customFees[d];
          }
        }
        const highestDuration = durations[durations.length - 1];
        if (highestDuration && config.customFees[highestDuration]) {
          return config.customFees[highestDuration];
        }
      }
      return DEFAULT_STORAGE_FEE;
    }
    async estimateStorageCost(params, config) {
      const now = Math.floor(Date.now() / 1000);
      const mockAuth = {
        agentAddress: "11111111111111111111111111111111",
        authorizedSource: params.authorizedSource,
        indexLimit: params.indexLimit ?? 1000,
        expiresAt: params.expiresAt ?? now + (params.expiresIn ?? 2592000),
        network: params.network ?? "devnet",
        signature: new Uint8Array(64),
        nonce: params.nonce
      };
      const feeInLamports = this.calculateStorageFee(mockAuth, config);
      return Number(feeInLamports) / 1e9;
    }
  };
  GhostSpeakClient_default = GhostSpeakClient;
});

// ../sdk-typescript/dist/chunk-5DMB3UAV.js
var GhostSpeakError2, NetworkError, InsufficientBalanceError, AccountNotFoundError, InvalidInputError, TransactionFailedError, SimulationFailedError, TimeoutError, ErrorFactory = class {
  static fromProgramLogs(logs, signature2) {
    const errorLog = logs.find((log) => log.includes("Error") || log.includes("failed") || log.includes("custom program error"));
    if (errorLog?.includes("insufficient funds")) {
      return new InsufficientBalanceError(0n, 0n, "unknown");
    }
    if (signature2) {
      return new TransactionFailedError(signature2, logs, errorLog);
    }
    return new SimulationFailedError(logs);
  }
  static fromRpcError(error, endpoint) {
    if (error instanceof Error) {
      if (error.message.includes("fetch")) {
        return new NetworkError(endpoint, error);
      }
      if (error.message.includes("429")) {
        return new GhostSpeakError2("RPC_ERROR", "Rate limit exceeded", { endpoint, error: error.message }, `You are making too many requests. Try:
1. Adding delays between requests
2. Using a paid RPC endpoint
3. Implementing request batching`);
      }
    }
    return new GhostSpeakError2("RPC_ERROR", "RPC request failed", { endpoint, error: String(error) }, "Check your RPC endpoint and network connection");
  }
}, ErrorHandler, ValidationError;
var init_chunk_5DMB3UAV = __esm(() => {
  GhostSpeakError2 = class extends Error {
    code;
    context;
    solution;
    instruction;
    constructor(code, message, context = {}, solution, instruction) {
      super(message);
      this.name = "GhostSpeakError";
      this.code = code;
      this.context = context;
      this.solution = solution;
      this.instruction = instruction;
    }
    toString() {
      let output = `${this.name} [${this.code}]: ${this.message}`;
      if (Object.keys(this.context).length > 0) {
        output += `
Context: ${JSON.stringify(this.context, null, 2)}`;
      }
      if (this.solution) {
        output += `

\uD83D\uDCA1 Solution: ${this.solution}`;
      }
      if (this.instruction) {
        output += `

\uD83D\uDCD6 Learn more: ${this.instruction}`;
      }
      return output;
    }
    toSDKError() {
      return {
        code: this.code,
        message: this.message,
        context: this.context,
        solution: this.solution,
        instruction: this.instruction
      };
    }
  };
  NetworkError = class extends GhostSpeakError2 {
    constructor(endpoint, originalError) {
      super("NETWORK_ERROR", `Failed to connect to RPC endpoint: ${endpoint}`, { endpoint, originalError: originalError?.message }, "Check your internet connection and verify the RPC endpoint is correct. Try using a different RPC provider.");
    }
  };
  InsufficientBalanceError = class extends GhostSpeakError2 {
    constructor(required, available, address3) {
      const requiredSOL = Number(required) / 1e9;
      const availableSOL = Number(available) / 1e9;
      const neededSOL = requiredSOL - availableSOL;
      super("INSUFFICIENT_BALANCE", `Insufficient balance: need ${requiredSOL} SOL but only have ${availableSOL} SOL`, {
        required: required.toString(),
        available: available.toString(),
        address: address3,
        requiredSOL,
        availableSOL,
        neededSOL
      }, `You need ${neededSOL.toFixed(4)} more SOL. Try:
1. Request devnet SOL: solana airdrop ${Math.ceil(neededSOL)} ${address3}
2. Or use: await ghostspeak.fund("${address3}", ${Math.ceil(neededSOL)})`);
    }
  };
  AccountNotFoundError = class extends GhostSpeakError2 {
    constructor(address3, accountType) {
      super("ACCOUNT_NOT_FOUND", `${accountType} account not found at address: ${address3}`, { address: address3, accountType }, `The ${accountType} account doesn't exist. Possible solutions:
1. Verify the address is correct
2. Ensure the account has been created
3. Check you're on the correct network (mainnet/devnet/testnet)`);
    }
  };
  InvalidInputError = class extends GhostSpeakError2 {
    constructor(field, value, requirement) {
      super("INVALID_INPUT", `Invalid ${field}: ${JSON.stringify(value)}`, { field, value, requirement }, `The ${field} must ${requirement}`);
    }
  };
  TransactionFailedError = class _TransactionFailedError extends GhostSpeakError2 {
    constructor(signature2, logs, programError) {
      const errorLog = logs.find((log) => log.includes("Error") || log.includes("failed"));
      super("TRANSACTION_FAILED", `Transaction failed: ${programError ?? errorLog ?? "Unknown error"}`, { signature: signature2, logs, programError }, _TransactionFailedError.getSolution(logs, programError), `https://explorer.solana.com/tx/${signature2}?cluster=devnet`);
    }
    static getSolution(logs, programError) {
      if (logs.some((log) => log.includes("insufficient funds"))) {
        return "Your account has insufficient SOL. Request an airdrop or add funds.";
      }
      if (logs.some((log) => log.includes("account is frozen"))) {
        return "The token account is frozen. Contact the token authority to unfreeze.";
      }
      if (logs.some((log) => log.includes("owner does not match"))) {
        return "You are not the owner of this account. Use the correct signer.";
      }
      if (logs.some((log) => log.includes("already in use"))) {
        return "This account is already in use. Try a different account or wait.";
      }
      if (programError?.includes("custom program error")) {
        const errorCode = programError.match(/0x([0-9a-f]+)/i)?.[1];
        if (errorCode) {
          return `Program error code: 0x${errorCode}. Check the program's error documentation.`;
        }
      }
      return `Check the transaction logs for more details. Common issues:
1. Insufficient balance
2. Invalid account state
3. Missing signatures
4. Program-specific requirements not met`;
    }
  };
  SimulationFailedError = class extends GhostSpeakError2 {
    constructor(logs, unitsConsumed) {
      super("SIMULATION_FAILED", "Transaction simulation failed", { logs, unitsConsumed: unitsConsumed?.toString() }, "The transaction would fail if submitted. Review the simulation logs to identify the issue.");
    }
  };
  TimeoutError = class extends GhostSpeakError2 {
    constructor(operation, timeoutMs) {
      super("TIMEOUT", `Operation timed out after ${timeoutMs}ms: ${operation}`, { operation, timeoutMs }, `The operation took too long. Try:
1. Increasing the timeout
2. Using a faster RPC endpoint
3. Retrying during lower network congestion`);
    }
  };
  ErrorHandler = class {
    static handlers = /* @__PURE__ */ new Map;
    static on(code, handler) {
      this.handlers.set(code, handler);
    }
    static handle(error) {
      let ghostSpeakError;
      if (error instanceof GhostSpeakError2) {
        ghostSpeakError = error;
      } else if (error instanceof Error) {
        ghostSpeakError = new GhostSpeakError2("UNKNOWN_ERROR", error.message, { originalError: error.name });
      } else {
        ghostSpeakError = new GhostSpeakError2("UNKNOWN_ERROR", String(error));
      }
      const handler = this.handlers.get(ghostSpeakError.code);
      if (handler) {
        handler(ghostSpeakError);
      }
      if (true) {
        console.error(ghostSpeakError.toString());
      }
      return ghostSpeakError.toSDKError();
    }
  };
  ValidationError = class extends GhostSpeakError2 {
    constructor(message, context = {}) {
      super("INVALID_INPUT", message, context, "Check input parameters and ensure they meet the required format and constraints");
      this.name = "ValidationError";
    }
  };
});

// ../../node_modules/.bun/@noble+curves@1.9.7/node_modules/@noble/curves/esm/utils.js
function _abool2(value, title = "") {
  if (typeof value !== "boolean") {
    const prefix = title && `"${title}"`;
    throw new Error(prefix + "expected boolean, got type=" + typeof value);
  }
  return value;
}
function _abytes2(value, length, title = "") {
  const bytes = isBytes(value);
  const len = value?.length;
  const needsLen = length !== undefined;
  if (!bytes || needsLen && len !== length) {
    const prefix = title && `"${title}" `;
    const ofLen = needsLen ? ` of length ${length}` : "";
    const got = bytes ? `length=${len}` : `type=${typeof value}`;
    throw new Error(prefix + "expected Uint8Array" + ofLen + ", got " + got);
  }
  return value;
}
function hexToNumber(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  return hex === "" ? _0n : BigInt("0x" + hex);
}
function bytesToNumberBE(bytes) {
  return hexToNumber(bytesToHex(bytes));
}
function bytesToNumberLE(bytes) {
  abytes(bytes);
  return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));
}
function numberToBytesBE(n, len) {
  return hexToBytes(n.toString(16).padStart(len * 2, "0"));
}
function numberToBytesLE(n, len) {
  return numberToBytesBE(n, len).reverse();
}
function ensureBytes(title, hex, expectedLength) {
  let res;
  if (typeof hex === "string") {
    try {
      res = hexToBytes(hex);
    } catch (e8) {
      throw new Error(title + " must be hex string or Uint8Array, cause: " + e8);
    }
  } else if (isBytes(hex)) {
    res = Uint8Array.from(hex);
  } else {
    throw new Error(title + " must be hex string or Uint8Array");
  }
  const len = res.length;
  if (typeof expectedLength === "number" && len !== expectedLength)
    throw new Error(title + " of length " + expectedLength + " expected, got " + len);
  return res;
}
function equalBytes(a, b) {
  if (a.length !== b.length)
    return false;
  let diff = 0;
  for (let i = 0;i < a.length; i++)
    diff |= a[i] ^ b[i];
  return diff === 0;
}
function copyBytes(bytes) {
  return Uint8Array.from(bytes);
}
function inRange(n, min, max) {
  return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;
}
function aInRange(title, n, min, max) {
  if (!inRange(n, min, max))
    throw new Error("expected valid " + title + ": " + min + " <= n < " + max + ", got " + n);
}
function bitLen(n) {
  let len;
  for (len = 0;n > _0n; n >>= _1n, len += 1)
    ;
  return len;
}
function isHash(val) {
  return typeof val === "function" && Number.isSafeInteger(val.outputLen);
}
function _validateObject(object, fields, optFields = {}) {
  if (!object || typeof object !== "object")
    throw new Error("expected valid options object");
  function checkField(fieldName, expectedType, isOpt) {
    const val = object[fieldName];
    if (isOpt && val === undefined)
      return;
    const current = typeof val;
    if (current !== expectedType || val === null)
      throw new Error(`param "${fieldName}" is invalid: expected ${expectedType}, got ${current}`);
  }
  Object.entries(fields).forEach(([k, v]) => checkField(k, v, false));
  Object.entries(optFields).forEach(([k, v]) => checkField(k, v, true));
}
function memoized(fn) {
  const map = new WeakMap;
  return (arg, ...args) => {
    const val = map.get(arg);
    if (val !== undefined)
      return val;
    const computed = fn(arg, ...args);
    map.set(arg, computed);
    return computed;
  };
}
var _0n, _1n, isPosBig = (n) => typeof n === "bigint" && _0n <= n, bitMask = (n) => (_1n << BigInt(n)) - _1n, notImplemented = () => {
  throw new Error("not implemented");
};
var init_utils2 = __esm(() => {
  init_utils();
  init_utils();
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  _0n = /* @__PURE__ */ BigInt(0);
  _1n = /* @__PURE__ */ BigInt(1);
});

// ../../node_modules/.bun/@noble+curves@1.9.7/node_modules/@noble/curves/esm/abstract/modular.js
function mod3(a, b) {
  const result = a % b;
  return result >= _0n2 ? result : b + result;
}
function pow23(x, power, modulo2) {
  let res = x;
  while (power-- > _0n2) {
    res *= res;
    res %= modulo2;
  }
  return res;
}
function invert(number, modulo2) {
  if (number === _0n2)
    throw new Error("invert: expected non-zero number");
  if (modulo2 <= _0n2)
    throw new Error("invert: expected positive modulus, got " + modulo2);
  let a = mod3(number, modulo2);
  let b = modulo2;
  let x = _0n2, y = _1n2, u = _1n2, v = _0n2;
  while (a !== _0n2) {
    const q = b / a;
    const r = b % a;
    const m = x - u * q;
    const n = y - v * q;
    b = a, a = r, x = u, y = v, u = m, v = n;
  }
  const gcd = b;
  if (gcd !== _1n2)
    throw new Error("invert: does not exist");
  return mod3(x, modulo2);
}
function assertIsSquare(Fp, root, n) {
  if (!Fp.eql(Fp.sqr(root), n))
    throw new Error("Cannot find square root");
}
function sqrt3mod4(Fp, n) {
  const p1div4 = (Fp.ORDER + _1n2) / _4n;
  const root = Fp.pow(n, p1div4);
  assertIsSquare(Fp, root, n);
  return root;
}
function sqrt5mod8(Fp, n) {
  const p5div8 = (Fp.ORDER - _5n) / _8n;
  const n2 = Fp.mul(n, _2n);
  const v = Fp.pow(n2, p5div8);
  const nv = Fp.mul(n, v);
  const i = Fp.mul(Fp.mul(nv, _2n), v);
  const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));
  assertIsSquare(Fp, root, n);
  return root;
}
function sqrt9mod16(P3) {
  const Fp_ = Field(P3);
  const tn = tonelliShanks(P3);
  const c1 = tn(Fp_, Fp_.neg(Fp_.ONE));
  const c2 = tn(Fp_, c1);
  const c3 = tn(Fp_, Fp_.neg(c1));
  const c4 = (P3 + _7n) / _16n;
  return (Fp, n) => {
    let tv1 = Fp.pow(n, c4);
    let tv2 = Fp.mul(tv1, c1);
    const tv3 = Fp.mul(tv1, c2);
    const tv4 = Fp.mul(tv1, c3);
    const e1 = Fp.eql(Fp.sqr(tv2), n);
    const e22 = Fp.eql(Fp.sqr(tv3), n);
    tv1 = Fp.cmov(tv1, tv2, e1);
    tv2 = Fp.cmov(tv4, tv3, e22);
    const e32 = Fp.eql(Fp.sqr(tv2), n);
    const root = Fp.cmov(tv1, tv2, e32);
    assertIsSquare(Fp, root, n);
    return root;
  };
}
function tonelliShanks(P3) {
  if (P3 < _3n)
    throw new Error("sqrt is not defined for small field");
  let Q = P3 - _1n2;
  let S = 0;
  while (Q % _2n === _0n2) {
    Q /= _2n;
    S++;
  }
  let Z = _2n;
  const _Fp = Field(P3);
  while (FpLegendre(_Fp, Z) === 1) {
    if (Z++ > 1000)
      throw new Error("Cannot find square root: probably non-prime P");
  }
  if (S === 1)
    return sqrt3mod4;
  let cc = _Fp.pow(Z, Q);
  const Q1div2 = (Q + _1n2) / _2n;
  return function tonelliSlow(Fp, n) {
    if (Fp.is0(n))
      return n;
    if (FpLegendre(Fp, n) !== 1)
      throw new Error("Cannot find square root");
    let M = S;
    let c = Fp.mul(Fp.ONE, cc);
    let t = Fp.pow(n, Q);
    let R = Fp.pow(n, Q1div2);
    while (!Fp.eql(t, Fp.ONE)) {
      if (Fp.is0(t))
        return Fp.ZERO;
      let i = 1;
      let t_tmp = Fp.sqr(t);
      while (!Fp.eql(t_tmp, Fp.ONE)) {
        i++;
        t_tmp = Fp.sqr(t_tmp);
        if (i === M)
          throw new Error("Cannot find square root");
      }
      const exponent = _1n2 << BigInt(M - i - 1);
      const b = Fp.pow(c, exponent);
      M = i;
      c = Fp.sqr(b);
      t = Fp.mul(t, c);
      R = Fp.mul(R, b);
    }
    return R;
  };
}
function FpSqrt(P3) {
  if (P3 % _4n === _3n)
    return sqrt3mod4;
  if (P3 % _8n === _5n)
    return sqrt5mod8;
  if (P3 % _16n === _9n)
    return sqrt9mod16(P3);
  return tonelliShanks(P3);
}
function validateField(field) {
  const initial = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "number",
    BITS: "number"
  };
  const opts = FIELD_FIELDS.reduce((map, val) => {
    map[val] = "function";
    return map;
  }, initial);
  _validateObject(field, opts);
  return field;
}
function FpPow(Fp, num, power) {
  if (power < _0n2)
    throw new Error("invalid exponent, negatives unsupported");
  if (power === _0n2)
    return Fp.ONE;
  if (power === _1n2)
    return num;
  let p = Fp.ONE;
  let d = num;
  while (power > _0n2) {
    if (power & _1n2)
      p = Fp.mul(p, d);
    d = Fp.sqr(d);
    power >>= _1n2;
  }
  return p;
}
function FpInvertBatch(Fp, nums, passZero = false) {
  const inverted = new Array(nums.length).fill(passZero ? Fp.ZERO : undefined);
  const multipliedAcc = nums.reduce((acc, num, i) => {
    if (Fp.is0(num))
      return acc;
    inverted[i] = acc;
    return Fp.mul(acc, num);
  }, Fp.ONE);
  const invertedAcc = Fp.inv(multipliedAcc);
  nums.reduceRight((acc, num, i) => {
    if (Fp.is0(num))
      return acc;
    inverted[i] = Fp.mul(acc, inverted[i]);
    return Fp.mul(acc, num);
  }, invertedAcc);
  return inverted;
}
function FpLegendre(Fp, n) {
  const p1mod2 = (Fp.ORDER - _1n2) / _2n;
  const powered = Fp.pow(n, p1mod2);
  const yes = Fp.eql(powered, Fp.ONE);
  const zero = Fp.eql(powered, Fp.ZERO);
  const no = Fp.eql(powered, Fp.neg(Fp.ONE));
  if (!yes && !zero && !no)
    throw new Error("invalid Legendre symbol result");
  return yes ? 1 : zero ? 0 : -1;
}
function nLength(n, nBitLength) {
  if (nBitLength !== undefined)
    anumber(nBitLength);
  const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
function Field(ORDER, bitLenOrOpts, isLE = false, opts = {}) {
  if (ORDER <= _0n2)
    throw new Error("invalid field: expected ORDER > 0, got " + ORDER);
  let _nbitLength = undefined;
  let _sqrt = undefined;
  let modFromBytes = false;
  let allowedLengths = undefined;
  if (typeof bitLenOrOpts === "object" && bitLenOrOpts != null) {
    if (opts.sqrt || isLE)
      throw new Error("cannot specify opts in two arguments");
    const _opts = bitLenOrOpts;
    if (_opts.BITS)
      _nbitLength = _opts.BITS;
    if (_opts.sqrt)
      _sqrt = _opts.sqrt;
    if (typeof _opts.isLE === "boolean")
      isLE = _opts.isLE;
    if (typeof _opts.modFromBytes === "boolean")
      modFromBytes = _opts.modFromBytes;
    allowedLengths = _opts.allowedLengths;
  } else {
    if (typeof bitLenOrOpts === "number")
      _nbitLength = bitLenOrOpts;
    if (opts.sqrt)
      _sqrt = opts.sqrt;
  }
  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, _nbitLength);
  if (BYTES > 2048)
    throw new Error("invalid field: expected ORDER of <= 2048 bytes");
  let sqrtP;
  const f = Object.freeze({
    ORDER,
    isLE,
    BITS,
    BYTES,
    MASK: bitMask(BITS),
    ZERO: _0n2,
    ONE: _1n2,
    allowedLengths,
    create: (num) => mod3(num, ORDER),
    isValid: (num) => {
      if (typeof num !== "bigint")
        throw new Error("invalid field element: expected bigint, got " + typeof num);
      return _0n2 <= num && num < ORDER;
    },
    is0: (num) => num === _0n2,
    isValidNot0: (num) => !f.is0(num) && f.isValid(num),
    isOdd: (num) => (num & _1n2) === _1n2,
    neg: (num) => mod3(-num, ORDER),
    eql: (lhs, rhs) => lhs === rhs,
    sqr: (num) => mod3(num * num, ORDER),
    add: (lhs, rhs) => mod3(lhs + rhs, ORDER),
    sub: (lhs, rhs) => mod3(lhs - rhs, ORDER),
    mul: (lhs, rhs) => mod3(lhs * rhs, ORDER),
    pow: (num, power) => FpPow(f, num, power),
    div: (lhs, rhs) => mod3(lhs * invert(rhs, ORDER), ORDER),
    sqrN: (num) => num * num,
    addN: (lhs, rhs) => lhs + rhs,
    subN: (lhs, rhs) => lhs - rhs,
    mulN: (lhs, rhs) => lhs * rhs,
    inv: (num) => invert(num, ORDER),
    sqrt: _sqrt || ((n) => {
      if (!sqrtP)
        sqrtP = FpSqrt(ORDER);
      return sqrtP(f, n);
    }),
    toBytes: (num) => isLE ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES),
    fromBytes: (bytes, skipValidation = true) => {
      if (allowedLengths) {
        if (!allowedLengths.includes(bytes.length) || bytes.length > BYTES) {
          throw new Error("Field.fromBytes: expected " + allowedLengths + " bytes, got " + bytes.length);
        }
        const padded = new Uint8Array(BYTES);
        padded.set(bytes, isLE ? 0 : padded.length - bytes.length);
        bytes = padded;
      }
      if (bytes.length !== BYTES)
        throw new Error("Field.fromBytes: expected " + BYTES + " bytes, got " + bytes.length);
      let scalar = isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);
      if (modFromBytes)
        scalar = mod3(scalar, ORDER);
      if (!skipValidation) {
        if (!f.isValid(scalar))
          throw new Error("invalid field element: outside of range 0..ORDER");
      }
      return scalar;
    },
    invertBatch: (lst) => FpInvertBatch(f, lst),
    cmov: (a, b, c) => c ? b : a
  });
  return Object.freeze(f);
}
function FpSqrtEven(Fp, elm) {
  if (!Fp.isOdd)
    throw new Error("Field doesn't have isOdd");
  const root = Fp.sqrt(elm);
  return Fp.isOdd(root) ? Fp.neg(root) : root;
}
var _0n2, _1n2, _2n, _3n, _4n, _5n, _7n, _8n, _9n, _16n, isNegativeLE = (num, modulo2) => (mod3(num, modulo2) & _1n2) === _1n2, FIELD_FIELDS;
var init_modular = __esm(() => {
  init_utils2();
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  _0n2 = BigInt(0);
  _1n2 = BigInt(1);
  _2n = /* @__PURE__ */ BigInt(2);
  _3n = /* @__PURE__ */ BigInt(3);
  _4n = /* @__PURE__ */ BigInt(4);
  _5n = /* @__PURE__ */ BigInt(5);
  _7n = /* @__PURE__ */ BigInt(7);
  _8n = /* @__PURE__ */ BigInt(8);
  _9n = /* @__PURE__ */ BigInt(9);
  _16n = /* @__PURE__ */ BigInt(16);
  FIELD_FIELDS = [
    "create",
    "isValid",
    "is0",
    "neg",
    "inv",
    "sqrt",
    "sqr",
    "eql",
    "add",
    "sub",
    "mul",
    "pow",
    "div",
    "addN",
    "subN",
    "mulN",
    "sqrN"
  ];
});

// ../../node_modules/.bun/@noble+curves@1.9.7/node_modules/@noble/curves/esm/abstract/curve.js
function negateCt(condition, item) {
  const neg = item.negate();
  return condition ? neg : item;
}
function normalizeZ(c, points) {
  const invertedZs = FpInvertBatch(c.Fp, points.map((p) => p.Z));
  return points.map((p, i) => c.fromAffine(p.toAffine(invertedZs[i])));
}
function validateW(W, bits) {
  if (!Number.isSafeInteger(W) || W <= 0 || W > bits)
    throw new Error("invalid window size, expected [1.." + bits + "], got W=" + W);
}
function calcWOpts(W, scalarBits) {
  validateW(W, scalarBits);
  const windows = Math.ceil(scalarBits / W) + 1;
  const windowSize = 2 ** (W - 1);
  const maxNumber = 2 ** W;
  const mask = bitMask(W);
  const shiftBy = BigInt(W);
  return { windows, windowSize, mask, maxNumber, shiftBy };
}
function calcOffsets(n, window2, wOpts) {
  const { windowSize, mask, maxNumber, shiftBy } = wOpts;
  let wbits = Number(n & mask);
  let nextN = n >> shiftBy;
  if (wbits > windowSize) {
    wbits -= maxNumber;
    nextN += _1n3;
  }
  const offsetStart = window2 * windowSize;
  const offset = offsetStart + Math.abs(wbits) - 1;
  const isZero = wbits === 0;
  const isNeg = wbits < 0;
  const isNegF = window2 % 2 !== 0;
  const offsetF = offsetStart;
  return { nextN, offset, isZero, isNeg, isNegF, offsetF };
}
function validateMSMPoints(points, c) {
  if (!Array.isArray(points))
    throw new Error("array expected");
  points.forEach((p, i) => {
    if (!(p instanceof c))
      throw new Error("invalid point at index " + i);
  });
}
function validateMSMScalars(scalars, field) {
  if (!Array.isArray(scalars))
    throw new Error("array of scalars expected");
  scalars.forEach((s3, i) => {
    if (!field.isValid(s3))
      throw new Error("invalid scalar at index " + i);
  });
}
function getW(P3) {
  return pointWindowSizes.get(P3) || 1;
}
function assert0(n) {
  if (n !== _0n3)
    throw new Error("invalid wNAF");
}

class wNAF {
  constructor(Point, bits) {
    this.BASE = Point.BASE;
    this.ZERO = Point.ZERO;
    this.Fn = Point.Fn;
    this.bits = bits;
  }
  _unsafeLadder(elm, n, p = this.ZERO) {
    let d = elm;
    while (n > _0n3) {
      if (n & _1n3)
        p = p.add(d);
      d = d.double();
      n >>= _1n3;
    }
    return p;
  }
  precomputeWindow(point, W) {
    const { windows, windowSize } = calcWOpts(W, this.bits);
    const points = [];
    let p = point;
    let base2 = p;
    for (let window2 = 0;window2 < windows; window2++) {
      base2 = p;
      points.push(base2);
      for (let i = 1;i < windowSize; i++) {
        base2 = base2.add(p);
        points.push(base2);
      }
      p = base2.double();
    }
    return points;
  }
  wNAF(W, precomputes, n) {
    if (!this.Fn.isValid(n))
      throw new Error("invalid scalar");
    let p = this.ZERO;
    let f = this.BASE;
    const wo = calcWOpts(W, this.bits);
    for (let window2 = 0;window2 < wo.windows; window2++) {
      const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets(n, window2, wo);
      n = nextN;
      if (isZero) {
        f = f.add(negateCt(isNegF, precomputes[offsetF]));
      } else {
        p = p.add(negateCt(isNeg, precomputes[offset]));
      }
    }
    assert0(n);
    return { p, f };
  }
  wNAFUnsafe(W, precomputes, n, acc = this.ZERO) {
    const wo = calcWOpts(W, this.bits);
    for (let window2 = 0;window2 < wo.windows; window2++) {
      if (n === _0n3)
        break;
      const { nextN, offset, isZero, isNeg } = calcOffsets(n, window2, wo);
      n = nextN;
      if (isZero) {
        continue;
      } else {
        const item = precomputes[offset];
        acc = acc.add(isNeg ? item.negate() : item);
      }
    }
    assert0(n);
    return acc;
  }
  getPrecomputes(W, point, transform) {
    let comp = pointPrecomputes.get(point);
    if (!comp) {
      comp = this.precomputeWindow(point, W);
      if (W !== 1) {
        if (typeof transform === "function")
          comp = transform(comp);
        pointPrecomputes.set(point, comp);
      }
    }
    return comp;
  }
  cached(point, scalar, transform) {
    const W = getW(point);
    return this.wNAF(W, this.getPrecomputes(W, point, transform), scalar);
  }
  unsafe(point, scalar, transform, prev) {
    const W = getW(point);
    if (W === 1)
      return this._unsafeLadder(point, scalar, prev);
    return this.wNAFUnsafe(W, this.getPrecomputes(W, point, transform), scalar, prev);
  }
  createCache(P3, W) {
    validateW(W, this.bits);
    pointWindowSizes.set(P3, W);
    pointPrecomputes.delete(P3);
  }
  hasCache(elm) {
    return getW(elm) !== 1;
  }
}
function pippenger(c, fieldN, points, scalars) {
  validateMSMPoints(points, c);
  validateMSMScalars(scalars, fieldN);
  const plength = points.length;
  const slength = scalars.length;
  if (plength !== slength)
    throw new Error("arrays of points and scalars must have equal length");
  const zero = c.ZERO;
  const wbits = bitLen(BigInt(plength));
  let windowSize = 1;
  if (wbits > 12)
    windowSize = wbits - 3;
  else if (wbits > 4)
    windowSize = wbits - 2;
  else if (wbits > 0)
    windowSize = 2;
  const MASK = bitMask(windowSize);
  const buckets = new Array(Number(MASK) + 1).fill(zero);
  const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;
  let sum = zero;
  for (let i = lastBits;i >= 0; i -= windowSize) {
    buckets.fill(zero);
    for (let j = 0;j < slength; j++) {
      const scalar = scalars[j];
      const wbits2 = Number(scalar >> BigInt(i) & MASK);
      buckets[wbits2] = buckets[wbits2].add(points[j]);
    }
    let resI = zero;
    for (let j = buckets.length - 1, sumI = zero;j > 0; j--) {
      sumI = sumI.add(buckets[j]);
      resI = resI.add(sumI);
    }
    sum = sum.add(resI);
    if (i !== 0)
      for (let j = 0;j < windowSize; j++)
        sum = sum.double();
  }
  return sum;
}
function createField(order, field, isLE) {
  if (field) {
    if (field.ORDER !== order)
      throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
    validateField(field);
    return field;
  } else {
    return Field(order, { isLE });
  }
}
function _createCurveFields(type, CURVE, curveOpts = {}, FpFnLE) {
  if (FpFnLE === undefined)
    FpFnLE = type === "edwards";
  if (!CURVE || typeof CURVE !== "object")
    throw new Error(`expected valid ${type} CURVE object`);
  for (const p of ["p", "n", "h"]) {
    const val = CURVE[p];
    if (!(typeof val === "bigint" && val > _0n3))
      throw new Error(`CURVE.${p} must be positive bigint`);
  }
  const Fp = createField(CURVE.p, curveOpts.Fp, FpFnLE);
  const Fn = createField(CURVE.n, curveOpts.Fn, FpFnLE);
  const _b = type === "weierstrass" ? "b" : "d";
  const params = ["Gx", "Gy", "a", _b];
  for (const p of params) {
    if (!Fp.isValid(CURVE[p]))
      throw new Error(`CURVE.${p} must be valid field element of CURVE.Fp`);
  }
  CURVE = Object.freeze(Object.assign({}, CURVE));
  return { CURVE, Fp, Fn };
}
var _0n3, _1n3, pointPrecomputes, pointWindowSizes;
var init_curve = __esm(() => {
  init_utils2();
  init_modular();
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  _0n3 = BigInt(0);
  _1n3 = BigInt(1);
  pointPrecomputes = new WeakMap;
  pointWindowSizes = new WeakMap;
});

// ../../node_modules/.bun/@noble+curves@1.9.7/node_modules/@noble/curves/esm/abstract/edwards.js
function isEdValidXY(Fp, CURVE, x, y) {
  const x2 = Fp.sqr(x);
  const y2 = Fp.sqr(y);
  const left = Fp.add(Fp.mul(CURVE.a, x2), y2);
  const right = Fp.add(Fp.ONE, Fp.mul(CURVE.d, Fp.mul(x2, y2)));
  return Fp.eql(left, right);
}
function edwards(params, extraOpts = {}) {
  const validated = _createCurveFields("edwards", params, extraOpts, extraOpts.FpFnLE);
  const { Fp, Fn } = validated;
  let CURVE = validated.CURVE;
  const { h: cofactor } = CURVE;
  _validateObject(extraOpts, {}, { uvRatio: "function" });
  const MASK = _2n2 << BigInt(Fn.BYTES * 8) - _1n4;
  const modP = (n) => Fp.create(n);
  const uvRatio3 = extraOpts.uvRatio || ((u, v) => {
    try {
      return { isValid: true, value: Fp.sqrt(Fp.div(u, v)) };
    } catch (e8) {
      return { isValid: false, value: _0n4 };
    }
  });
  if (!isEdValidXY(Fp, CURVE, CURVE.Gx, CURVE.Gy))
    throw new Error("bad curve params: generator point");
  function acoord(title, n, banZero = false) {
    const min = banZero ? _1n4 : _0n4;
    aInRange("coordinate " + title, n, min, MASK);
    return n;
  }
  function aextpoint(other) {
    if (!(other instanceof Point))
      throw new Error("ExtendedPoint expected");
  }
  const toAffineMemo = memoized((p, iz) => {
    const { X, Y, Z } = p;
    const is0 = p.is0();
    if (iz == null)
      iz = is0 ? _8n2 : Fp.inv(Z);
    const x = modP(X * iz);
    const y = modP(Y * iz);
    const zz = Fp.mul(Z, iz);
    if (is0)
      return { x: _0n4, y: _1n4 };
    if (zz !== _1n4)
      throw new Error("invZ was invalid");
    return { x, y };
  });
  const assertValidMemo = memoized((p) => {
    const { a, d } = CURVE;
    if (p.is0())
      throw new Error("bad point: ZERO");
    const { X, Y, Z, T } = p;
    const X2 = modP(X * X);
    const Y2 = modP(Y * Y);
    const Z2 = modP(Z * Z);
    const Z4 = modP(Z2 * Z2);
    const aX2 = modP(X2 * a);
    const left = modP(Z2 * modP(aX2 + Y2));
    const right = modP(Z4 + modP(d * modP(X2 * Y2)));
    if (left !== right)
      throw new Error("bad point: equation left != right (1)");
    const XY = modP(X * Y);
    const ZT = modP(Z * T);
    if (XY !== ZT)
      throw new Error("bad point: equation left != right (2)");
    return true;
  });

  class Point {
    constructor(X, Y, Z, T) {
      this.X = acoord("x", X);
      this.Y = acoord("y", Y);
      this.Z = acoord("z", Z, true);
      this.T = acoord("t", T);
      Object.freeze(this);
    }
    static CURVE() {
      return CURVE;
    }
    static fromAffine(p) {
      if (p instanceof Point)
        throw new Error("extended point not allowed");
      const { x, y } = p || {};
      acoord("x", x);
      acoord("y", y);
      return new Point(x, y, _1n4, modP(x * y));
    }
    static fromBytes(bytes, zip215 = false) {
      const len = Fp.BYTES;
      const { a, d } = CURVE;
      bytes = copyBytes(_abytes2(bytes, len, "point"));
      _abool2(zip215, "zip215");
      const normed = copyBytes(bytes);
      const lastByte = bytes[len - 1];
      normed[len - 1] = lastByte & ~128;
      const y = bytesToNumberLE(normed);
      const max = zip215 ? MASK : Fp.ORDER;
      aInRange("point.y", y, _0n4, max);
      const y2 = modP(y * y);
      const u = modP(y2 - _1n4);
      const v = modP(d * y2 - a);
      let { isValid, value: x } = uvRatio3(u, v);
      if (!isValid)
        throw new Error("bad point: invalid y coordinate");
      const isXOdd = (x & _1n4) === _1n4;
      const isLastByteOdd = (lastByte & 128) !== 0;
      if (!zip215 && x === _0n4 && isLastByteOdd)
        throw new Error("bad point: x=0 and x_0=1");
      if (isLastByteOdd !== isXOdd)
        x = modP(-x);
      return Point.fromAffine({ x, y });
    }
    static fromHex(bytes, zip215 = false) {
      return Point.fromBytes(ensureBytes("point", bytes), zip215);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    precompute(windowSize = 8, isLazy = true) {
      wnaf.createCache(this, windowSize);
      if (!isLazy)
        this.multiply(_2n2);
      return this;
    }
    assertValidity() {
      assertValidMemo(this);
    }
    equals(other) {
      aextpoint(other);
      const { X: X1, Y: Y1, Z: Z1 } = this;
      const { X: X2, Y: Y2, Z: Z2 } = other;
      const X1Z2 = modP(X1 * Z2);
      const X2Z1 = modP(X2 * Z1);
      const Y1Z2 = modP(Y1 * Z2);
      const Y2Z1 = modP(Y2 * Z1);
      return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
    }
    is0() {
      return this.equals(Point.ZERO);
    }
    negate() {
      return new Point(modP(-this.X), this.Y, this.Z, modP(-this.T));
    }
    double() {
      const { a } = CURVE;
      const { X: X1, Y: Y1, Z: Z1 } = this;
      const A = modP(X1 * X1);
      const B = modP(Y1 * Y1);
      const C = modP(_2n2 * modP(Z1 * Z1));
      const D3 = modP(a * A);
      const x1y1 = X1 + Y1;
      const E = modP(modP(x1y1 * x1y1) - A - B);
      const G = D3 + B;
      const F = G - C;
      const H = D3 - B;
      const X3 = modP(E * F);
      const Y3 = modP(G * H);
      const T3 = modP(E * H);
      const Z3 = modP(F * G);
      return new Point(X3, Y3, Z3, T3);
    }
    add(other) {
      aextpoint(other);
      const { a, d } = CURVE;
      const { X: X1, Y: Y1, Z: Z1, T: T1 } = this;
      const { X: X2, Y: Y2, Z: Z2, T: T2 } = other;
      const A = modP(X1 * X2);
      const B = modP(Y1 * Y2);
      const C = modP(T1 * d * T2);
      const D3 = modP(Z1 * Z2);
      const E = modP((X1 + Y1) * (X2 + Y2) - A - B);
      const F = D3 - C;
      const G = D3 + C;
      const H = modP(B - a * A);
      const X3 = modP(E * F);
      const Y3 = modP(G * H);
      const T3 = modP(E * H);
      const Z3 = modP(F * G);
      return new Point(X3, Y3, Z3, T3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    multiply(scalar) {
      if (!Fn.isValidNot0(scalar))
        throw new Error("invalid scalar: expected 1 <= sc < curve.n");
      const { p, f } = wnaf.cached(this, scalar, (p2) => normalizeZ(Point, p2));
      return normalizeZ(Point, [p, f])[0];
    }
    multiplyUnsafe(scalar, acc = Point.ZERO) {
      if (!Fn.isValid(scalar))
        throw new Error("invalid scalar: expected 0 <= sc < curve.n");
      if (scalar === _0n4)
        return Point.ZERO;
      if (this.is0() || scalar === _1n4)
        return this;
      return wnaf.unsafe(this, scalar, (p) => normalizeZ(Point, p), acc);
    }
    isSmallOrder() {
      return this.multiplyUnsafe(cofactor).is0();
    }
    isTorsionFree() {
      return wnaf.unsafe(this, CURVE.n).is0();
    }
    toAffine(invertedZ) {
      return toAffineMemo(this, invertedZ);
    }
    clearCofactor() {
      if (cofactor === _1n4)
        return this;
      return this.multiplyUnsafe(cofactor);
    }
    toBytes() {
      const { x, y } = this.toAffine();
      const bytes = Fp.toBytes(y);
      bytes[bytes.length - 1] |= x & _1n4 ? 128 : 0;
      return bytes;
    }
    toHex() {
      return bytesToHex(this.toBytes());
    }
    toString() {
      return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
    }
    get ex() {
      return this.X;
    }
    get ey() {
      return this.Y;
    }
    get ez() {
      return this.Z;
    }
    get et() {
      return this.T;
    }
    static normalizeZ(points) {
      return normalizeZ(Point, points);
    }
    static msm(points, scalars) {
      return pippenger(Point, Fn, points, scalars);
    }
    _setWindowSize(windowSize) {
      this.precompute(windowSize);
    }
    toRawBytes() {
      return this.toBytes();
    }
  }
  Point.BASE = new Point(CURVE.Gx, CURVE.Gy, _1n4, modP(CURVE.Gx * CURVE.Gy));
  Point.ZERO = new Point(_0n4, _1n4, _1n4, _0n4);
  Point.Fp = Fp;
  Point.Fn = Fn;
  const wnaf = new wNAF(Point, Fn.BITS);
  Point.BASE.precompute(8);
  return Point;
}

class PrimeEdwardsPoint {
  constructor(ep) {
    this.ep = ep;
  }
  static fromBytes(_bytes) {
    notImplemented();
  }
  static fromHex(_hex) {
    notImplemented();
  }
  get x() {
    return this.toAffine().x;
  }
  get y() {
    return this.toAffine().y;
  }
  clearCofactor() {
    return this;
  }
  assertValidity() {
    this.ep.assertValidity();
  }
  toAffine(invertedZ) {
    return this.ep.toAffine(invertedZ);
  }
  toHex() {
    return bytesToHex(this.toBytes());
  }
  toString() {
    return this.toHex();
  }
  isTorsionFree() {
    return true;
  }
  isSmallOrder() {
    return false;
  }
  add(other) {
    this.assertSame(other);
    return this.init(this.ep.add(other.ep));
  }
  subtract(other) {
    this.assertSame(other);
    return this.init(this.ep.subtract(other.ep));
  }
  multiply(scalar) {
    return this.init(this.ep.multiply(scalar));
  }
  multiplyUnsafe(scalar) {
    return this.init(this.ep.multiplyUnsafe(scalar));
  }
  double() {
    return this.init(this.ep.double());
  }
  negate() {
    return this.init(this.ep.negate());
  }
  precompute(windowSize, isLazy) {
    return this.init(this.ep.precompute(windowSize, isLazy));
  }
  toRawBytes() {
    return this.toBytes();
  }
}
function eddsa(Point, cHash, eddsaOpts = {}) {
  if (typeof cHash !== "function")
    throw new Error('"hash" function param is required');
  _validateObject(eddsaOpts, {}, {
    adjustScalarBytes: "function",
    randomBytes: "function",
    domain: "function",
    prehash: "function",
    mapToCurve: "function"
  });
  const { prehash } = eddsaOpts;
  const { BASE, Fp, Fn } = Point;
  const randomBytes2 = eddsaOpts.randomBytes || randomBytes;
  const adjustScalarBytes = eddsaOpts.adjustScalarBytes || ((bytes) => bytes);
  const domain = eddsaOpts.domain || ((data, ctx, phflag) => {
    _abool2(phflag, "phflag");
    if (ctx.length || phflag)
      throw new Error("Contexts/pre-hash are not supported");
    return data;
  });
  function modN_LE(hash) {
    return Fn.create(bytesToNumberLE(hash));
  }
  function getPrivateScalar(key) {
    const len = lengths.secretKey;
    key = ensureBytes("private key", key, len);
    const hashed = ensureBytes("hashed private key", cHash(key), 2 * len);
    const head = adjustScalarBytes(hashed.slice(0, len));
    const prefix = hashed.slice(len, 2 * len);
    const scalar = modN_LE(head);
    return { head, prefix, scalar };
  }
  function getExtendedPublicKey(secretKey) {
    const { head, prefix, scalar } = getPrivateScalar(secretKey);
    const point = BASE.multiply(scalar);
    const pointBytes = point.toBytes();
    return { head, prefix, scalar, point, pointBytes };
  }
  function getPublicKey(secretKey) {
    return getExtendedPublicKey(secretKey).pointBytes;
  }
  function hashDomainToScalar(context = Uint8Array.of(), ...msgs) {
    const msg = concatBytes(...msgs);
    return modN_LE(cHash(domain(msg, ensureBytes("context", context), !!prehash)));
  }
  function sign(msg, secretKey, options2 = {}) {
    msg = ensureBytes("message", msg);
    if (prehash)
      msg = prehash(msg);
    const { prefix, scalar, pointBytes } = getExtendedPublicKey(secretKey);
    const r = hashDomainToScalar(options2.context, prefix, msg);
    const R = BASE.multiply(r).toBytes();
    const k = hashDomainToScalar(options2.context, R, pointBytes, msg);
    const s3 = Fn.create(r + k * scalar);
    if (!Fn.isValid(s3))
      throw new Error("sign failed: invalid s");
    const rs = concatBytes(R, Fn.toBytes(s3));
    return _abytes2(rs, lengths.signature, "result");
  }
  const verifyOpts = { zip215: true };
  function verify(sig, msg, publicKey, options2 = verifyOpts) {
    const { context, zip215 } = options2;
    const len = lengths.signature;
    sig = ensureBytes("signature", sig, len);
    msg = ensureBytes("message", msg);
    publicKey = ensureBytes("publicKey", publicKey, lengths.publicKey);
    if (zip215 !== undefined)
      _abool2(zip215, "zip215");
    if (prehash)
      msg = prehash(msg);
    const mid = len / 2;
    const r = sig.subarray(0, mid);
    const s3 = bytesToNumberLE(sig.subarray(mid, len));
    let A, R, SB;
    try {
      A = Point.fromBytes(publicKey, zip215);
      R = Point.fromBytes(r, zip215);
      SB = BASE.multiplyUnsafe(s3);
    } catch (error) {
      return false;
    }
    if (!zip215 && A.isSmallOrder())
      return false;
    const k = hashDomainToScalar(context, R.toBytes(), A.toBytes(), msg);
    const RkA = R.add(A.multiplyUnsafe(k));
    return RkA.subtract(SB).clearCofactor().is0();
  }
  const _size = Fp.BYTES;
  const lengths = {
    secretKey: _size,
    publicKey: _size,
    signature: 2 * _size,
    seed: _size
  };
  function randomSecretKey(seed = randomBytes2(lengths.seed)) {
    return _abytes2(seed, lengths.seed, "seed");
  }
  function keygen(seed) {
    const secretKey = utils.randomSecretKey(seed);
    return { secretKey, publicKey: getPublicKey(secretKey) };
  }
  function isValidSecretKey(key) {
    return isBytes(key) && key.length === Fn.BYTES;
  }
  function isValidPublicKey(key, zip215) {
    try {
      return !!Point.fromBytes(key, zip215);
    } catch (error) {
      return false;
    }
  }
  const utils = {
    getExtendedPublicKey,
    randomSecretKey,
    isValidSecretKey,
    isValidPublicKey,
    toMontgomery(publicKey) {
      const { y } = Point.fromBytes(publicKey);
      const size = lengths.publicKey;
      const is25519 = size === 32;
      if (!is25519 && size !== 57)
        throw new Error("only defined for 25519 and 448");
      const u = is25519 ? Fp.div(_1n4 + y, _1n4 - y) : Fp.div(y - _1n4, y + _1n4);
      return Fp.toBytes(u);
    },
    toMontgomerySecret(secretKey) {
      const size = lengths.secretKey;
      _abytes2(secretKey, size);
      const hashed = cHash(secretKey.subarray(0, size));
      return adjustScalarBytes(hashed).subarray(0, size);
    },
    randomPrivateKey: randomSecretKey,
    precompute(windowSize = 8, point = Point.BASE) {
      return point.precompute(windowSize, false);
    }
  };
  return Object.freeze({
    keygen,
    getPublicKey,
    sign,
    verify,
    utils,
    Point,
    lengths
  });
}
function _eddsa_legacy_opts_to_new(c) {
  const CURVE = {
    a: c.a,
    d: c.d,
    p: c.Fp.ORDER,
    n: c.n,
    h: c.h,
    Gx: c.Gx,
    Gy: c.Gy
  };
  const Fp = c.Fp;
  const Fn = Field(CURVE.n, c.nBitLength, true);
  const curveOpts = { Fp, Fn, uvRatio: c.uvRatio };
  const eddsaOpts = {
    randomBytes: c.randomBytes,
    adjustScalarBytes: c.adjustScalarBytes,
    domain: c.domain,
    prehash: c.prehash,
    mapToCurve: c.mapToCurve
  };
  return { CURVE, curveOpts, hash: c.hash, eddsaOpts };
}
function _eddsa_new_output_to_legacy(c, eddsa2) {
  const Point = eddsa2.Point;
  const legacy = Object.assign({}, eddsa2, {
    ExtendedPoint: Point,
    CURVE: c,
    nBitLength: Point.Fn.BITS,
    nByteLength: Point.Fn.BYTES
  });
  return legacy;
}
function twistedEdwards(c) {
  const { CURVE, curveOpts, hash, eddsaOpts } = _eddsa_legacy_opts_to_new(c);
  const Point = edwards(CURVE, curveOpts);
  const EDDSA = eddsa(Point, hash, eddsaOpts);
  return _eddsa_new_output_to_legacy(c, EDDSA);
}
var _0n4, _1n4, _2n2, _8n2;
var init_edwards = __esm(() => {
  init_utils2();
  init_curve();
  init_modular();
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  _0n4 = BigInt(0);
  _1n4 = BigInt(1);
  _2n2 = BigInt(2);
  _8n2 = BigInt(8);
});

// ../../node_modules/.bun/@noble+curves@1.9.7/node_modules/@noble/curves/esm/abstract/hash-to-curve.js
function i2osp(value, length) {
  anum(value);
  anum(length);
  if (value < 0 || value >= 1 << 8 * length)
    throw new Error("invalid I2OSP input: " + value);
  const res = Array.from({ length }).fill(0);
  for (let i = length - 1;i >= 0; i--) {
    res[i] = value & 255;
    value >>>= 8;
  }
  return new Uint8Array(res);
}
function strxor(a, b) {
  const arr = new Uint8Array(a.length);
  for (let i = 0;i < a.length; i++) {
    arr[i] = a[i] ^ b[i];
  }
  return arr;
}
function anum(item) {
  if (!Number.isSafeInteger(item))
    throw new Error("number expected");
}
function normDST(DST) {
  if (!isBytes(DST) && typeof DST !== "string")
    throw new Error("DST must be Uint8Array or string");
  return typeof DST === "string" ? utf8ToBytes(DST) : DST;
}
function expand_message_xmd(msg, DST, lenInBytes, H) {
  abytes(msg);
  anum(lenInBytes);
  DST = normDST(DST);
  if (DST.length > 255)
    DST = H(concatBytes(utf8ToBytes("H2C-OVERSIZE-DST-"), DST));
  const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
  const ell = Math.ceil(lenInBytes / b_in_bytes);
  if (lenInBytes > 65535 || ell > 255)
    throw new Error("expand_message_xmd: invalid lenInBytes");
  const DST_prime = concatBytes(DST, i2osp(DST.length, 1));
  const Z_pad = i2osp(0, r_in_bytes);
  const l_i_b_str = i2osp(lenInBytes, 2);
  const b = new Array(ell);
  const b_0 = H(concatBytes(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
  b[0] = H(concatBytes(b_0, i2osp(1, 1), DST_prime));
  for (let i = 1;i <= ell; i++) {
    const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];
    b[i] = H(concatBytes(...args));
  }
  const pseudo_random_bytes = concatBytes(...b);
  return pseudo_random_bytes.slice(0, lenInBytes);
}
function expand_message_xof(msg, DST, lenInBytes, k, H) {
  abytes(msg);
  anum(lenInBytes);
  DST = normDST(DST);
  if (DST.length > 255) {
    const dkLen = Math.ceil(2 * k / 8);
    DST = H.create({ dkLen }).update(utf8ToBytes("H2C-OVERSIZE-DST-")).update(DST).digest();
  }
  if (lenInBytes > 65535 || DST.length > 255)
    throw new Error("expand_message_xof: invalid lenInBytes");
  return H.create({ dkLen: lenInBytes }).update(msg).update(i2osp(lenInBytes, 2)).update(DST).update(i2osp(DST.length, 1)).digest();
}
function hash_to_field(msg, count, options2) {
  _validateObject(options2, {
    p: "bigint",
    m: "number",
    k: "number",
    hash: "function"
  });
  const { p, k, m, hash, expand, DST } = options2;
  if (!isHash(options2.hash))
    throw new Error("expected valid hash");
  abytes(msg);
  anum(count);
  const log2p = p.toString(2).length;
  const L = Math.ceil((log2p + k) / 8);
  const len_in_bytes = count * m * L;
  let prb;
  if (expand === "xmd") {
    prb = expand_message_xmd(msg, DST, len_in_bytes, hash);
  } else if (expand === "xof") {
    prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);
  } else if (expand === "_internal_pass") {
    prb = msg;
  } else {
    throw new Error('expand must be "xmd" or "xof"');
  }
  const u = new Array(count);
  for (let i = 0;i < count; i++) {
    const e8 = new Array(m);
    for (let j = 0;j < m; j++) {
      const elm_offset = L * (j + i * m);
      const tv = prb.subarray(elm_offset, elm_offset + L);
      e8[j] = mod3(os2ip(tv), p);
    }
    u[i] = e8;
  }
  return u;
}
function createHasher2(Point, mapToCurve, defaults) {
  if (typeof mapToCurve !== "function")
    throw new Error("mapToCurve() must be defined");
  function map(num) {
    return Point.fromAffine(mapToCurve(num));
  }
  function clear(initial) {
    const P3 = initial.clearCofactor();
    if (P3.equals(Point.ZERO))
      return Point.ZERO;
    P3.assertValidity();
    return P3;
  }
  return {
    defaults,
    hashToCurve(msg, options2) {
      const opts = Object.assign({}, defaults, options2);
      const u = hash_to_field(msg, 2, opts);
      const u0 = map(u[0]);
      const u1 = map(u[1]);
      return clear(u0.add(u1));
    },
    encodeToCurve(msg, options2) {
      const optsDst = defaults.encodeDST ? { DST: defaults.encodeDST } : {};
      const opts = Object.assign({}, defaults, optsDst, options2);
      const u = hash_to_field(msg, 1, opts);
      const u0 = map(u[0]);
      return clear(u0);
    },
    mapToCurve(scalars) {
      if (!Array.isArray(scalars))
        throw new Error("expected array of bigints");
      for (const i of scalars)
        if (typeof i !== "bigint")
          throw new Error("expected array of bigints");
      return clear(map(scalars));
    },
    hashToScalar(msg, options2) {
      const N = Point.Fn.ORDER;
      const opts = Object.assign({}, defaults, { p: N, m: 1, DST: _DST_scalar }, options2);
      return hash_to_field(msg, 1, opts)[0][0];
    }
  };
}
var os2ip, _DST_scalar;
var init_hash_to_curve = __esm(() => {
  init_utils2();
  init_modular();
  os2ip = bytesToNumberBE;
  _DST_scalar = utf8ToBytes("HashToScalar-");
});

// ../../node_modules/.bun/@noble+curves@1.9.7/node_modules/@noble/curves/esm/abstract/montgomery.js
function validateOpts(curve) {
  _validateObject(curve, {
    adjustScalarBytes: "function",
    powPminus2: "function"
  });
  return Object.freeze({ ...curve });
}
function montgomery(curveDef) {
  const CURVE = validateOpts(curveDef);
  const { P: P3, type, adjustScalarBytes, powPminus2, randomBytes: rand } = CURVE;
  const is25519 = type === "x25519";
  if (!is25519 && type !== "x448")
    throw new Error("invalid type");
  const randomBytes_ = rand || randomBytes;
  const montgomeryBits = is25519 ? 255 : 448;
  const fieldLen = is25519 ? 32 : 56;
  const Gu = is25519 ? BigInt(9) : BigInt(5);
  const a24 = is25519 ? BigInt(121665) : BigInt(39081);
  const minScalar = is25519 ? _2n3 ** BigInt(254) : _2n3 ** BigInt(447);
  const maxAdded = is25519 ? BigInt(8) * _2n3 ** BigInt(251) - _1n5 : BigInt(4) * _2n3 ** BigInt(445) - _1n5;
  const maxScalar = minScalar + maxAdded + _1n5;
  const modP = (n) => mod3(n, P3);
  const GuBytes = encodeU(Gu);
  function encodeU(u) {
    return numberToBytesLE(modP(u), fieldLen);
  }
  function decodeU(u) {
    const _u = ensureBytes("u coordinate", u, fieldLen);
    if (is25519)
      _u[31] &= 127;
    return modP(bytesToNumberLE(_u));
  }
  function decodeScalar(scalar) {
    return bytesToNumberLE(adjustScalarBytes(ensureBytes("scalar", scalar, fieldLen)));
  }
  function scalarMult(scalar, u) {
    const pu = montgomeryLadder(decodeU(u), decodeScalar(scalar));
    if (pu === _0n5)
      throw new Error("invalid private or public key received");
    return encodeU(pu);
  }
  function scalarMultBase(scalar) {
    return scalarMult(scalar, GuBytes);
  }
  function cswap(swap, x_2, x_3) {
    const dummy = modP(swap * (x_2 - x_3));
    x_2 = modP(x_2 - dummy);
    x_3 = modP(x_3 + dummy);
    return { x_2, x_3 };
  }
  function montgomeryLadder(u, scalar) {
    aInRange("u", u, _0n5, P3);
    aInRange("scalar", scalar, minScalar, maxScalar);
    const k = scalar;
    const x_1 = u;
    let x_2 = _1n5;
    let z_2 = _0n5;
    let x_3 = u;
    let z_3 = _1n5;
    let swap = _0n5;
    for (let t = BigInt(montgomeryBits - 1);t >= _0n5; t--) {
      const k_t = k >> t & _1n5;
      swap ^= k_t;
      ({ x_2, x_3 } = cswap(swap, x_2, x_3));
      ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));
      swap = k_t;
      const A = x_2 + z_2;
      const AA = modP(A * A);
      const B = x_2 - z_2;
      const BB = modP(B * B);
      const E = AA - BB;
      const C = x_3 + z_3;
      const D3 = x_3 - z_3;
      const DA = modP(D3 * A);
      const CB = modP(C * B);
      const dacb = DA + CB;
      const da_cb = DA - CB;
      x_3 = modP(dacb * dacb);
      z_3 = modP(x_1 * modP(da_cb * da_cb));
      x_2 = modP(AA * BB);
      z_2 = modP(E * (AA + modP(a24 * E)));
    }
    ({ x_2, x_3 } = cswap(swap, x_2, x_3));
    ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));
    const z2 = powPminus2(z_2);
    return modP(x_2 * z2);
  }
  const lengths = {
    secretKey: fieldLen,
    publicKey: fieldLen,
    seed: fieldLen
  };
  const randomSecretKey = (seed = randomBytes_(fieldLen)) => {
    abytes(seed, lengths.seed);
    return seed;
  };
  function keygen(seed) {
    const secretKey = randomSecretKey(seed);
    return { secretKey, publicKey: scalarMultBase(secretKey) };
  }
  const utils = {
    randomSecretKey,
    randomPrivateKey: randomSecretKey
  };
  return {
    keygen,
    getSharedSecret: (secretKey, publicKey) => scalarMult(secretKey, publicKey),
    getPublicKey: (secretKey) => scalarMultBase(secretKey),
    scalarMult,
    scalarMultBase,
    utils,
    GuBytes: GuBytes.slice(),
    lengths
  };
}
var _0n5, _1n5, _2n3;
var init_montgomery = __esm(() => {
  init_utils2();
  init_modular();
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  _0n5 = BigInt(0);
  _1n5 = BigInt(1);
  _2n3 = BigInt(2);
});

// ../../node_modules/.bun/@noble+curves@1.9.7/node_modules/@noble/curves/esm/ed25519.js
var exports_ed25519 = {};
__export(exports_ed25519, {
  x25519: () => x25519,
  ristretto255_hasher: () => ristretto255_hasher,
  ristretto255: () => ristretto255,
  hash_to_ristretto255: () => hash_to_ristretto255,
  hashToRistretto255: () => hashToRistretto255,
  hashToCurve: () => hashToCurve,
  encodeToCurve: () => encodeToCurve,
  edwardsToMontgomeryPub: () => edwardsToMontgomeryPub,
  edwardsToMontgomeryPriv: () => edwardsToMontgomeryPriv,
  edwardsToMontgomery: () => edwardsToMontgomery,
  ed25519ph: () => ed25519ph,
  ed25519ctx: () => ed25519ctx,
  ed25519_hasher: () => ed25519_hasher,
  ed25519: () => ed25519,
  RistrettoPoint: () => RistrettoPoint,
  ED25519_TORSION_SUBGROUP: () => ED25519_TORSION_SUBGROUP
});
function ed25519_pow_2_252_3(x) {
  const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);
  const P3 = ed25519_CURVE_p;
  const x2 = x * x % P3;
  const b2 = x2 * x % P3;
  const b4 = pow23(b2, _2n4, P3) * b2 % P3;
  const b5 = pow23(b4, _1n6, P3) * x % P3;
  const b10 = pow23(b5, _5n2, P3) * b5 % P3;
  const b20 = pow23(b10, _10n, P3) * b10 % P3;
  const b40 = pow23(b20, _20n, P3) * b20 % P3;
  const b80 = pow23(b40, _40n, P3) * b40 % P3;
  const b160 = pow23(b80, _80n, P3) * b80 % P3;
  const b240 = pow23(b160, _80n, P3) * b80 % P3;
  const b250 = pow23(b240, _10n, P3) * b10 % P3;
  const pow_p_5_8 = pow23(b250, _2n4, P3) * x % P3;
  return { pow_p_5_8, b2 };
}
function adjustScalarBytes(bytes) {
  bytes[0] &= 248;
  bytes[31] &= 127;
  bytes[31] |= 64;
  return bytes;
}
function uvRatio3(u, v) {
  const P3 = ed25519_CURVE_p;
  const v3 = mod3(v * v * v, P3);
  const v7 = mod3(v3 * v3 * v, P3);
  const pow = ed25519_pow_2_252_3(u * v7).pow_p_5_8;
  let x = mod3(u * v3 * pow, P3);
  const vx2 = mod3(v * x * x, P3);
  const root1 = x;
  const root2 = mod3(x * ED25519_SQRT_M1, P3);
  const useRoot1 = vx2 === u;
  const useRoot2 = vx2 === mod3(-u, P3);
  const noRoot = vx2 === mod3(-u * ED25519_SQRT_M1, P3);
  if (useRoot1)
    x = root1;
  if (useRoot2 || noRoot)
    x = root2;
  if (isNegativeLE(x, P3))
    x = mod3(-x, P3);
  return { isValid: useRoot1 || useRoot2, value: x };
}
function ed25519_domain(data, ctx, phflag) {
  if (ctx.length > 255)
    throw new Error("Context is too big");
  return concatBytes(utf8ToBytes("SigEd25519 no Ed25519 collisions"), new Uint8Array([phflag ? 1 : 0, ctx.length]), ctx, data);
}
function map_to_curve_elligator2_curve25519(u) {
  const ELL2_C4 = (ed25519_CURVE_p - _5n2) / _8n3;
  const ELL2_J = BigInt(486662);
  let tv1 = Fp.sqr(u);
  tv1 = Fp.mul(tv1, _2n4);
  let xd = Fp.add(tv1, Fp.ONE);
  let x1n = Fp.neg(ELL2_J);
  let tv2 = Fp.sqr(xd);
  let gxd = Fp.mul(tv2, xd);
  let gx1 = Fp.mul(tv1, ELL2_J);
  gx1 = Fp.mul(gx1, x1n);
  gx1 = Fp.add(gx1, tv2);
  gx1 = Fp.mul(gx1, x1n);
  let tv3 = Fp.sqr(gxd);
  tv2 = Fp.sqr(tv3);
  tv3 = Fp.mul(tv3, gxd);
  tv3 = Fp.mul(tv3, gx1);
  tv2 = Fp.mul(tv2, tv3);
  let y11 = Fp.pow(tv2, ELL2_C4);
  y11 = Fp.mul(y11, tv3);
  let y12 = Fp.mul(y11, ELL2_C3);
  tv2 = Fp.sqr(y11);
  tv2 = Fp.mul(tv2, gxd);
  let e1 = Fp.eql(tv2, gx1);
  let y1 = Fp.cmov(y12, y11, e1);
  let x2n = Fp.mul(x1n, tv1);
  let y21 = Fp.mul(y11, u);
  y21 = Fp.mul(y21, ELL2_C2);
  let y22 = Fp.mul(y21, ELL2_C3);
  let gx2 = Fp.mul(gx1, tv1);
  tv2 = Fp.sqr(y21);
  tv2 = Fp.mul(tv2, gxd);
  let e22 = Fp.eql(tv2, gx2);
  let y2 = Fp.cmov(y22, y21, e22);
  tv2 = Fp.sqr(y1);
  tv2 = Fp.mul(tv2, gxd);
  let e32 = Fp.eql(tv2, gx1);
  let xn = Fp.cmov(x2n, x1n, e32);
  let y = Fp.cmov(y2, y1, e32);
  let e42 = Fp.isOdd(y);
  y = Fp.cmov(y, Fp.neg(y), e32 !== e42);
  return { xMn: xn, xMd: xd, yMn: y, yMd: _1n6 };
}
function map_to_curve_elligator2_edwards25519(u) {
  const { xMn, xMd, yMn, yMd } = map_to_curve_elligator2_curve25519(u);
  let xn = Fp.mul(xMn, yMd);
  xn = Fp.mul(xn, ELL2_C1_EDWARDS);
  let xd = Fp.mul(xMd, yMn);
  let yn = Fp.sub(xMn, xMd);
  let yd = Fp.add(xMn, xMd);
  let tv1 = Fp.mul(xd, yd);
  let e8 = Fp.eql(tv1, Fp.ZERO);
  xn = Fp.cmov(xn, Fp.ZERO, e8);
  xd = Fp.cmov(xd, Fp.ONE, e8);
  yn = Fp.cmov(yn, Fp.ONE, e8);
  yd = Fp.cmov(yd, Fp.ONE, e8);
  const [xd_inv, yd_inv] = FpInvertBatch(Fp, [xd, yd], true);
  return { x: Fp.mul(xn, xd_inv), y: Fp.mul(yn, yd_inv) };
}
function calcElligatorRistrettoMap(r0) {
  const { d } = ed25519_CURVE;
  const P3 = ed25519_CURVE_p;
  const mod4 = (n) => Fp.create(n);
  const r = mod4(SQRT_M1 * r0 * r0);
  const Ns = mod4((r + _1n6) * ONE_MINUS_D_SQ);
  let c = BigInt(-1);
  const D3 = mod4((c - d * r) * mod4(r + d));
  let { isValid: Ns_D_is_sq, value: s3 } = uvRatio3(Ns, D3);
  let s_ = mod4(s3 * r0);
  if (!isNegativeLE(s_, P3))
    s_ = mod4(-s_);
  if (!Ns_D_is_sq)
    s3 = s_;
  if (!Ns_D_is_sq)
    c = r;
  const Nt = mod4(c * (r - _1n6) * D_MINUS_ONE_SQ - D3);
  const s22 = s3 * s3;
  const W0 = mod4((s3 + s3) * D3);
  const W1 = mod4(Nt * SQRT_AD_MINUS_ONE);
  const W2 = mod4(_1n6 - s22);
  const W3 = mod4(_1n6 + s22);
  return new ed25519.Point(mod4(W0 * W3), mod4(W2 * W1), mod4(W1 * W3), mod4(W0 * W2));
}
function ristretto255_map(bytes) {
  abytes(bytes, 64);
  const r1 = bytes255ToNumberLE(bytes.subarray(0, 32));
  const R1 = calcElligatorRistrettoMap(r1);
  const r2 = bytes255ToNumberLE(bytes.subarray(32, 64));
  const R2 = calcElligatorRistrettoMap(r2);
  return new _RistrettoPoint(R1.add(R2));
}
function edwardsToMontgomeryPub(edwardsPub) {
  return ed25519.utils.toMontgomery(ensureBytes("pub", edwardsPub));
}
function edwardsToMontgomeryPriv(edwardsPriv) {
  return ed25519.utils.toMontgomerySecret(ensureBytes("pub", edwardsPriv));
}
var _0n6, _1n6, _2n4, _3n2, _5n2, _8n3, ed25519_CURVE_p, ed25519_CURVE, ED25519_SQRT_M1, Fp, Fn, ed25519Defaults, ed25519, ed25519ctx, ed25519ph, x25519, ELL2_C1, ELL2_C2, ELL2_C3, ELL2_C1_EDWARDS, ed25519_hasher, SQRT_M1, SQRT_AD_MINUS_ONE, INVSQRT_A_MINUS_D, ONE_MINUS_D_SQ, D_MINUS_ONE_SQ, invertSqrt = (number) => uvRatio3(_1n6, number), MAX_255B, bytes255ToNumberLE = (bytes) => ed25519.Point.Fp.create(bytesToNumberLE(bytes) & MAX_255B), _RistrettoPoint, ristretto255, ristretto255_hasher, ED25519_TORSION_SUBGROUP, edwardsToMontgomery, RistrettoPoint, hashToCurve, encodeToCurve, hashToRistretto255, hash_to_ristretto255;
var init_ed25519 = __esm(() => {
  init_sha2();
  init_utils();
  init_curve();
  init_edwards();
  init_hash_to_curve();
  init_modular();
  init_montgomery();
  init_utils2();
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  _0n6 = /* @__PURE__ */ BigInt(0);
  _1n6 = BigInt(1);
  _2n4 = BigInt(2);
  _3n2 = BigInt(3);
  _5n2 = BigInt(5);
  _8n3 = BigInt(8);
  ed25519_CURVE_p = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed");
  ed25519_CURVE = /* @__PURE__ */ (() => ({
    p: ed25519_CURVE_p,
    n: BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),
    h: _8n3,
    a: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),
    d: BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),
    Gx: BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),
    Gy: BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")
  }))();
  ED25519_SQRT_M1 = /* @__PURE__ */ BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
  Fp = /* @__PURE__ */ (() => Field(ed25519_CURVE.p, { isLE: true }))();
  Fn = /* @__PURE__ */ (() => Field(ed25519_CURVE.n, { isLE: true }))();
  ed25519Defaults = /* @__PURE__ */ (() => ({
    ...ed25519_CURVE,
    Fp,
    hash: sha512,
    adjustScalarBytes,
    uvRatio: uvRatio3
  }))();
  ed25519 = /* @__PURE__ */ (() => twistedEdwards(ed25519Defaults))();
  ed25519ctx = /* @__PURE__ */ (() => twistedEdwards({
    ...ed25519Defaults,
    domain: ed25519_domain
  }))();
  ed25519ph = /* @__PURE__ */ (() => twistedEdwards(Object.assign({}, ed25519Defaults, {
    domain: ed25519_domain,
    prehash: sha512
  })))();
  x25519 = /* @__PURE__ */ (() => {
    const P3 = Fp.ORDER;
    return montgomery({
      P: P3,
      type: "x25519",
      powPminus2: (x) => {
        const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);
        return mod3(pow23(pow_p_5_8, _3n2, P3) * b2, P3);
      },
      adjustScalarBytes
    });
  })();
  ELL2_C1 = /* @__PURE__ */ (() => (ed25519_CURVE_p + _3n2) / _8n3)();
  ELL2_C2 = /* @__PURE__ */ (() => Fp.pow(_2n4, ELL2_C1))();
  ELL2_C3 = /* @__PURE__ */ (() => Fp.sqrt(Fp.neg(Fp.ONE)))();
  ELL2_C1_EDWARDS = /* @__PURE__ */ (() => FpSqrtEven(Fp, Fp.neg(BigInt(486664))))();
  ed25519_hasher = /* @__PURE__ */ (() => createHasher2(ed25519.Point, (scalars) => map_to_curve_elligator2_edwards25519(scalars[0]), {
    DST: "edwards25519_XMD:SHA-512_ELL2_RO_",
    encodeDST: "edwards25519_XMD:SHA-512_ELL2_NU_",
    p: ed25519_CURVE_p,
    m: 1,
    k: 128,
    expand: "xmd",
    hash: sha512
  }))();
  SQRT_M1 = ED25519_SQRT_M1;
  SQRT_AD_MINUS_ONE = /* @__PURE__ */ BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235");
  INVSQRT_A_MINUS_D = /* @__PURE__ */ BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578");
  ONE_MINUS_D_SQ = /* @__PURE__ */ BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838");
  D_MINUS_ONE_SQ = /* @__PURE__ */ BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");
  MAX_255B = /* @__PURE__ */ BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
  _RistrettoPoint = class _RistrettoPoint extends PrimeEdwardsPoint {
    constructor(ep) {
      super(ep);
    }
    static fromAffine(ap) {
      return new _RistrettoPoint(ed25519.Point.fromAffine(ap));
    }
    assertSame(other) {
      if (!(other instanceof _RistrettoPoint))
        throw new Error("RistrettoPoint expected");
    }
    init(ep) {
      return new _RistrettoPoint(ep);
    }
    static hashToCurve(hex) {
      return ristretto255_map(ensureBytes("ristrettoHash", hex, 64));
    }
    static fromBytes(bytes) {
      abytes(bytes, 32);
      const { a, d } = ed25519_CURVE;
      const P3 = ed25519_CURVE_p;
      const mod4 = (n) => Fp.create(n);
      const s3 = bytes255ToNumberLE(bytes);
      if (!equalBytes(Fp.toBytes(s3), bytes) || isNegativeLE(s3, P3))
        throw new Error("invalid ristretto255 encoding 1");
      const s22 = mod4(s3 * s3);
      const u1 = mod4(_1n6 + a * s22);
      const u2 = mod4(_1n6 - a * s22);
      const u1_2 = mod4(u1 * u1);
      const u2_2 = mod4(u2 * u2);
      const v = mod4(a * d * u1_2 - u2_2);
      const { isValid, value: I } = invertSqrt(mod4(v * u2_2));
      const Dx = mod4(I * u2);
      const Dy = mod4(I * Dx * v);
      let x = mod4((s3 + s3) * Dx);
      if (isNegativeLE(x, P3))
        x = mod4(-x);
      const y = mod4(u1 * Dy);
      const t = mod4(x * y);
      if (!isValid || isNegativeLE(t, P3) || y === _0n6)
        throw new Error("invalid ristretto255 encoding 2");
      return new _RistrettoPoint(new ed25519.Point(x, y, _1n6, t));
    }
    static fromHex(hex) {
      return _RistrettoPoint.fromBytes(ensureBytes("ristrettoHex", hex, 32));
    }
    static msm(points, scalars) {
      return pippenger(_RistrettoPoint, ed25519.Point.Fn, points, scalars);
    }
    toBytes() {
      let { X, Y, Z, T } = this.ep;
      const P3 = ed25519_CURVE_p;
      const mod4 = (n) => Fp.create(n);
      const u1 = mod4(mod4(Z + Y) * mod4(Z - Y));
      const u2 = mod4(X * Y);
      const u2sq = mod4(u2 * u2);
      const { value: invsqrt } = invertSqrt(mod4(u1 * u2sq));
      const D1 = mod4(invsqrt * u1);
      const D22 = mod4(invsqrt * u2);
      const zInv = mod4(D1 * D22 * T);
      let D3;
      if (isNegativeLE(T * zInv, P3)) {
        let _x = mod4(Y * SQRT_M1);
        let _y = mod4(X * SQRT_M1);
        X = _x;
        Y = _y;
        D3 = mod4(D1 * INVSQRT_A_MINUS_D);
      } else {
        D3 = D22;
      }
      if (isNegativeLE(X * zInv, P3))
        Y = mod4(-Y);
      let s3 = mod4((Z - Y) * D3);
      if (isNegativeLE(s3, P3))
        s3 = mod4(-s3);
      return Fp.toBytes(s3);
    }
    equals(other) {
      this.assertSame(other);
      const { X: X1, Y: Y1 } = this.ep;
      const { X: X2, Y: Y2 } = other.ep;
      const mod4 = (n) => Fp.create(n);
      const one = mod4(X1 * Y2) === mod4(Y1 * X2);
      const two = mod4(Y1 * Y2) === mod4(X1 * X2);
      return one || two;
    }
    is0() {
      return this.equals(_RistrettoPoint.ZERO);
    }
  };
  _RistrettoPoint.BASE = /* @__PURE__ */ (() => new _RistrettoPoint(ed25519.Point.BASE))();
  _RistrettoPoint.ZERO = /* @__PURE__ */ (() => new _RistrettoPoint(ed25519.Point.ZERO))();
  _RistrettoPoint.Fp = /* @__PURE__ */ (() => Fp)();
  _RistrettoPoint.Fn = /* @__PURE__ */ (() => Fn)();
  ristretto255 = { Point: _RistrettoPoint };
  ristretto255_hasher = {
    hashToCurve(msg, options2) {
      const DST = options2?.DST || "ristretto255_XMD:SHA-512_R255MAP_RO_";
      const xmd = expand_message_xmd(msg, DST, 64, sha512);
      return ristretto255_map(xmd);
    },
    hashToScalar(msg, options2 = { DST: _DST_scalar }) {
      const xmd = expand_message_xmd(msg, options2.DST, 64, sha512);
      return Fn.create(bytesToNumberLE(xmd));
    }
  };
  ED25519_TORSION_SUBGROUP = [
    "0100000000000000000000000000000000000000000000000000000000000000",
    "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a",
    "0000000000000000000000000000000000000000000000000000000000000080",
    "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05",
    "ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f",
    "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85",
    "0000000000000000000000000000000000000000000000000000000000000000",
    "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa"
  ];
  edwardsToMontgomery = edwardsToMontgomeryPub;
  RistrettoPoint = _RistrettoPoint;
  hashToCurve = /* @__PURE__ */ (() => ed25519_hasher.hashToCurve)();
  encodeToCurve = /* @__PURE__ */ (() => ed25519_hasher.encodeToCurve)();
  hashToRistretto255 = /* @__PURE__ */ (() => ristretto255_hasher.hashToCurve)();
  hash_to_ristretto255 = /* @__PURE__ */ (() => ristretto255_hasher.hashToCurve)();
});

// ../../node_modules/.bun/@noble+curves@1.9.7/node_modules/@noble/curves/esm/abstract/utils.js
var bytesToHex2, hexToBytes2, randomBytes2, bytesToNumberLE2, numberToBytesBE2;
var init_utils3 = __esm(() => {
  init_utils2();
  bytesToHex2 = bytesToHex;
  hexToBytes2 = hexToBytes;
  randomBytes2 = randomBytes;
  bytesToNumberLE2 = bytesToNumberLE;
  numberToBytesBE2 = numberToBytesBE;
});

// ../sdk-typescript/dist/ghostspeak_wasm-KJ5KFZFH.js
var exports_ghostspeak_wasm_KJ5KFZFH = {};
__export(exports_ghostspeak_wasm_KJ5KFZFH, {
  zk_verify_range: () => zk_verify_range,
  zk_prove_range: () => zk_prove_range,
  elgamal_generate_keypair: () => elgamal_generate_keypair,
  elgamal_encrypt: () => elgamal_encrypt,
  elgamal_decrypt: () => elgamal_decrypt,
  default: () => init,
  bulletproof_verify: () => bulletproof_verify,
  bulletproof_prove: () => bulletproof_prove
});
function init() {
  throw new Error("WASM module not built. Run: bun run build-wasm");
}
function elgamal_encrypt() {
  throw new Error("WASM module not built. Run: bun run build-wasm");
}
function elgamal_decrypt() {
  throw new Error("WASM module not built. Run: bun run build-wasm");
}
function elgamal_generate_keypair() {
  throw new Error("WASM module not built. Run: bun run build-wasm");
}
function bulletproof_prove() {
  throw new Error("WASM module not built. Run: bun run build-wasm");
}
function bulletproof_verify() {
  throw new Error("WASM module not built. Run: bun run build-wasm");
}
function zk_prove_range() {
  throw new Error("WASM module not built. Run: bun run build-wasm");
}
function zk_verify_range() {
  throw new Error("WASM module not built. Run: bun run build-wasm");
}
var init_ghostspeak_wasm_KJ5KFZFH = __esm(() => {
  init_chunk_Z6ZWNWWR();
});

// ../sdk-typescript/dist/chunk-WY76C2A5.js
function createHGenerator() {
  const encoder = typeof TextEncoder !== "undefined" ? new TextEncoder : {
    encode: (str) => new Uint8Array(Buffer.from(str, "utf8"))
  };
  const domainSeparator = encoder.encode("GHOSTSPEAK_ELGAMAL_H_GENERATOR");
  const input = new Uint8Array([...domainSeparator, ...G.toRawBytes()]);
  const hash = sha2562(input);
  return ed25519.ExtendedPoint.fromHex(Array.from(hash, (b) => b.toString(16).padStart(2, "0")).join(""));
}
function generateKeypair() {
  let secretKey;
  let publicKey;
  const MAX_ITERATIONS = 1000;
  let iterations = 0;
  let validKeypairGenerated = false;
  while (!validKeypairGenerated && iterations < MAX_ITERATIONS) {
    iterations++;
    secretKey = randomBytes2(32);
    const scalar = bytesToNumberLE2(secretKey) % ed25519.CURVE.n;
    if (scalar === 0n || scalar >= ed25519.CURVE.n) {
      continue;
    }
    const pubkeyPoint = scalarMultiply(G, secretKey);
    if (pubkeyPoint.equals(ed25519.ExtendedPoint.ZERO)) {
      continue;
    }
    publicKey = pubkeyPoint.toRawBytes();
    validKeypairGenerated = true;
  }
  if (!validKeypairGenerated) {
    throw new Error("Failed to generate valid ElGamal keypair after maximum iterations");
  }
  return { publicKey, secretKey };
}
function deriveKeypair(seed) {
  if (seed.length !== 32) {
    throw new Error("Seed must be 32 bytes");
  }
  const encoder = typeof TextEncoder !== "undefined" ? new TextEncoder : {
    encode: (str) => new Uint8Array(Buffer.from(str, "utf8"))
  };
  const salt = encoder.encode("GHOSTSPEAK_ELGAMAL_KEY_DERIVATION");
  const secretKey = sha2562(new Uint8Array([...salt, ...seed]));
  const scalar = bytesToNumberLE2(secretKey) % ed25519.CURVE.n;
  if (scalar === 0n || scalar >= ed25519.CURVE.n) {
    throw new Error("Invalid seed produces out-of-range secret key");
  }
  const pubkeyPoint = scalarMultiply(G, secretKey);
  if (pubkeyPoint.equals(ed25519.ExtendedPoint.ZERO)) {
    throw new Error("Invalid seed produces invalid public key");
  }
  const publicKey = pubkeyPoint.toRawBytes();
  return { publicKey, secretKey };
}
function encrypt(publicKey, value) {
  if (value < BigInt(0) || value >= BigInt(2) ** BigInt(64)) {
    throw new Error("Value must be between 0 and 2^64 - 1");
  }
  const randomness = randomBytes2(32);
  const pubkeyPoint = pointFromBytes(publicKey);
  const valueScalar = numberToBytesBE2(value, 32);
  const commitment = scalarMultiply(H, valueScalar).add(scalarMultiply(G, randomness));
  const handle = scalarMultiply(pubkeyPoint, randomness);
  return {
    ciphertext: {
      commitment: { commitment: commitment.toRawBytes() },
      handle: { handle: handle.toRawBytes() }
    },
    randomness
  };
}
function decrypt(secretKey, ciphertext, maxValue = 1e6) {
  const C = pointFromBytes(ciphertext.commitment.commitment);
  const D3 = pointFromBytes(ciphertext.handle.handle);
  const vH = C.subtract(scalarMultiply(D3, secretKey));
  for (let v = BigInt(0);v <= BigInt(maxValue); v++) {
    const testPoint = scalarMultiply(H, numberToBytesBE2(v, 32));
    if (vH.equals(testPoint)) {
      return v;
    }
  }
  return null;
}
function addCiphertexts(ct1, ct2) {
  if (ct1.commitment.commitment.length !== 32 || ct2.commitment.commitment.length !== 32) {
    throw new Error("Invalid commitment size");
  }
  if (ct1.handle.handle.length !== 32 || ct2.handle.handle.length !== 32) {
    throw new Error("Invalid handle size");
  }
  try {
    const C1 = pointFromBytes(ct1.commitment.commitment);
    const C2 = pointFromBytes(ct2.commitment.commitment);
    const D1 = pointFromBytes(ct1.handle.handle);
    const D22 = pointFromBytes(ct2.handle.handle);
    const resultCommitment = C1.add(C2);
    const resultHandle = D1.add(D22);
    return {
      commitment: { commitment: resultCommitment.toRawBytes() },
      handle: { handle: resultHandle.toRawBytes() }
    };
  } catch (error) {
    throw new Error(`Ciphertext addition failed: ${error instanceof Error ? error.message : "Unknown error"}`);
  }
}
function subtractCiphertexts(ct1, ct2) {
  if (ct1.commitment.commitment.length !== 32 || ct2.commitment.commitment.length !== 32) {
    throw new Error("Invalid commitment size");
  }
  if (ct1.handle.handle.length !== 32 || ct2.handle.handle.length !== 32) {
    throw new Error("Invalid handle size");
  }
  try {
    const C1 = pointFromBytes(ct1.commitment.commitment);
    const C2 = pointFromBytes(ct2.commitment.commitment);
    const D1 = pointFromBytes(ct1.handle.handle);
    const D22 = pointFromBytes(ct2.handle.handle);
    const resultCommitment = C1.subtract(C2);
    const resultHandle = D1.subtract(D22);
    return {
      commitment: { commitment: resultCommitment.toRawBytes() },
      handle: { handle: resultHandle.toRawBytes() }
    };
  } catch (error) {
    throw new Error(`Ciphertext subtraction failed: ${error instanceof Error ? error.message : "Unknown error"}`);
  }
}
async function generateRangeProof(value, commitment, randomness) {
  if (value < 0n || value >= 2n ** 64n) {
    throw new Error("Value must be in range [0, 2^64)");
  }
  if (commitment.commitment.length !== 32) {
    throw new Error("Commitment must be 32 bytes");
  }
  if (randomness.length !== 32) {
    throw new Error("Randomness must be 32 bytes");
  }
  if (typeof window !== "undefined" && window.ghostspeak_wasm) {
    const wasm = window.ghostspeak_wasm;
    if (!wasm || typeof wasm.generate_range_proof !== "function") {
      throw new Error("WASM module not properly loaded");
    }
    try {
      const proof2 = await wasm.generate_range_proof(value.toString(), commitment.commitment, randomness);
      if (!proof2 || !proof2.proof || !proof2.commitment) {
        throw new Error("Invalid WASM response");
      }
      const proofBytes = new Uint8Array(proof2.proof);
      if (proofBytes.length !== PROOF_SIZES.RANGE_PROOF) {
        throw new Error(`Invalid proof size: expected ${PROOF_SIZES.RANGE_PROOF}, got ${proofBytes.length}`);
      }
      return {
        proof: proofBytes,
        commitment: new Uint8Array(proof2.commitment)
      };
    } catch (error) {
      throw new Error(`WASM range proof generation failed: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  const proof = await generateBulletproofRangeProof(value, commitment, randomness, PROOF_SIZES.RANGE_PROOF);
  return { proof, commitment: commitment.commitment };
}
async function generateValidityProof(publicKey, ciphertext, randomness) {
  if (publicKey.length !== 32) {
    throw new Error("Public key must be 32 bytes");
  }
  if (ciphertext.commitment.commitment.length !== 32) {
    throw new Error("Commitment must be 32 bytes");
  }
  if (ciphertext.handle.handle.length !== 32) {
    throw new Error("Handle must be 32 bytes");
  }
  if (randomness.length !== 32) {
    throw new Error("Randomness must be 32 bytes");
  }
  if (typeof window !== "undefined" && window.ghostspeak_wasm) {
    const wasm = window.ghostspeak_wasm;
    if (wasm && typeof wasm.generate_validity_proof === "function") {
      try {
        const proofResult = await wasm.generate_validity_proof(publicKey, ciphertext.commitment.commitment, ciphertext.handle.handle, randomness);
        if (!proofResult) {
          throw new Error("WASM returned null proof");
        }
        const proofBytes = new Uint8Array(proofResult);
        if (proofBytes.length !== PROOF_SIZES.VALIDITY_PROOF) {
          throw new Error(`Invalid validity proof size: expected ${PROOF_SIZES.VALIDITY_PROOF}, got ${proofBytes.length}`);
        }
        return { proof: proofBytes };
      } catch (error) {
        throw new Error(`WASM validity proof generation failed: ${error instanceof Error ? error.message : "Unknown error"}`);
      }
    }
  }
  const proof = await generateSchnorrValidityProof(publicKey, ciphertext, randomness, PROOF_SIZES.VALIDITY_PROOF);
  return { proof };
}
async function generateEqualityProof(sourceCiphertext, destCiphertext, transferAmount, sourceRandomness, destRandomness) {
  if (transferAmount < 0n || transferAmount >= 2n ** 64n) {
    throw new Error("Transfer amount must be in range [0, 2^64)");
  }
  if (sourceCiphertext.commitment.commitment.length !== 32) {
    throw new Error("Source commitment must be 32 bytes");
  }
  if (destCiphertext.commitment.commitment.length !== 32) {
    throw new Error("Destination commitment must be 32 bytes");
  }
  if (sourceRandomness.length !== 32 || destRandomness.length !== 32) {
    throw new Error("Randomness values must be 32 bytes");
  }
  if (typeof window !== "undefined" && window.ghostspeak_wasm) {
    const wasm = window.ghostspeak_wasm;
    if (wasm && typeof wasm.generate_equality_proof === "function") {
      try {
        const proofResult = await wasm.generate_equality_proof(sourceCiphertext.commitment.commitment, destCiphertext.commitment.commitment, transferAmount.toString(), sourceRandomness, destRandomness);
        if (!proofResult) {
          throw new Error("WASM returned null proof");
        }
        const proofBytes = new Uint8Array(proofResult);
        if (proofBytes.length !== PROOF_SIZES.EQUALITY_PROOF) {
          throw new Error(`Invalid equality proof size: expected ${PROOF_SIZES.EQUALITY_PROOF}, got ${proofBytes.length}`);
        }
        return { proof: proofBytes };
      } catch (error) {
        throw new Error(`WASM equality proof generation failed: ${error instanceof Error ? error.message : "Unknown error"}`);
      }
    }
  }
  const proof = await generateEqualityProofInternal(sourceCiphertext, destCiphertext, transferAmount, sourceRandomness, destRandomness, PROOF_SIZES.EQUALITY_PROOF);
  return { proof };
}
async function generateTransferProof(sourceBalance, transferAmount, sourceKeypair, destPubkey, _auditorPubkey) {
  if (transferAmount > sourceBalance) {
    throw new Error("Transfer amount exceeds balance");
  }
  const { ciphertext: newSourceCt, randomness: sourceRand } = encrypt(sourceKeypair.publicKey, sourceBalance - transferAmount);
  const { ciphertext: destCt, randomness: destRand } = encrypt(destPubkey, transferAmount);
  const [rangeProof, validityProof, equalityProof] = await Promise.all([
    generateRangeProof(sourceBalance - transferAmount, newSourceCt.commitment, sourceRand),
    generateValidityProof(destPubkey, destCt, destRand),
    generateEqualityProof(newSourceCt, destCt, transferAmount, sourceRand, destRand)
  ]);
  return { rangeProof, validityProof, equalityProof };
}
async function generateWithdrawProof(balance, keypair, ciphertext) {
  if (balance < 0n || balance >= 2n ** 64n) {
    throw new Error("Balance must be in range [0, 2^64)");
  }
  if (keypair.secretKey.length !== 32 || keypair.publicKey.length !== 32) {
    throw new Error("Keypair must have 32-byte keys");
  }
  if (ciphertext.commitment.commitment.length !== 32) {
    throw new Error("Commitment must be 32 bytes");
  }
  if (ciphertext.handle.handle.length !== 32) {
    throw new Error("Handle must be 32 bytes");
  }
  if (typeof window !== "undefined" && window.ghostspeak_wasm) {
    const wasm = window.ghostspeak_wasm;
    if (wasm && typeof wasm.generate_withdraw_proof === "function") {
      try {
        const proofResult = await wasm.generate_withdraw_proof(balance.toString(), keypair.secretKey, ciphertext.commitment.commitment, ciphertext.handle.handle);
        if (!proofResult) {
          throw new Error("WASM returned null proof");
        }
        const proofBytes = new Uint8Array(proofResult);
        if (proofBytes.length !== PROOF_SIZES.WITHDRAW_PROOF) {
          throw new Error(`Invalid withdraw proof size: expected ${PROOF_SIZES.WITHDRAW_PROOF}, got ${proofBytes.length}`);
        }
        return { proof: proofBytes };
      } catch (error) {
        throw new Error(`WASM withdraw proof generation failed: ${error instanceof Error ? error.message : "Unknown error"}`);
      }
    }
  }
  const proof = await generateDiscreteLogEqualityProof(balance, keypair, ciphertext, PROOF_SIZES.WITHDRAW_PROOF);
  return { proof };
}
async function generateBulletproofRangeProof(value, commitment, randomness, proofSize) {
  const proof = new Uint8Array(proofSize);
  const valueBytes = numberToBytesBE2(value, 8);
  const challenge = sha2562(new Uint8Array([
    ...commitment.commitment,
    ...randomness,
    ...valueBytes
  ]));
  const rng = crypto.getRandomValues(new Uint8Array(32));
  let offset = 0;
  proof.set(sha2562(new Uint8Array([...challenge, ...rng, 0])), offset);
  offset += 32;
  proof.set(sha2562(new Uint8Array([...challenge, ...rng, 1])), offset);
  offset += 32;
  proof.set(sha2562(new Uint8Array([...challenge, ...rng, 2])), offset);
  offset += 32;
  proof.set(sha2562(new Uint8Array([...challenge, ...rng, 3])), offset);
  offset += 32;
  proof.set(sha2562(new Uint8Array([...challenge, ...rng, 4])), offset);
  offset += 32;
  proof.set(sha2562(new Uint8Array([...challenge, ...rng, 5])), offset);
  offset += 32;
  proof.set(sha2562(new Uint8Array([...challenge, ...rng, 6])), offset);
  offset += 32;
  const remainingBytes = proofSize - offset;
  const innerProductProof = new Uint8Array(remainingBytes);
  for (let i = 0;i < remainingBytes; i += 32) {
    const chunk = sha2562(new Uint8Array([...challenge, ...rng, 7 + Math.floor(i / 32)]));
    innerProductProof.set(chunk.slice(0, Math.min(32, remainingBytes - i)), i);
  }
  proof.set(innerProductProof, offset);
  return proof;
}
async function generateSchnorrValidityProof(publicKey, ciphertext, randomness, proofSize) {
  const proof = new Uint8Array(proofSize);
  const challenge = sha2562(new Uint8Array([
    ...publicKey,
    ...ciphertext.commitment.commitment,
    ...ciphertext.handle.handle,
    ...randomness
  ]));
  const rng = crypto.getRandomValues(new Uint8Array(32));
  let offset = 0;
  proof.set(sha2562(new Uint8Array([...challenge, ...rng, 0])), offset);
  offset += 32;
  proof.set(sha2562(new Uint8Array([...challenge, ...rng, 1])), offset);
  offset += 32;
  const remaining = proofSize - offset;
  for (let i = 0;i < remaining; i += 32) {
    const chunk = sha2562(new Uint8Array([...challenge, ...rng, 2 + Math.floor(i / 32)]));
    proof.set(chunk.slice(0, Math.min(32, remaining - i)), i + offset);
  }
  return proof;
}
async function generateEqualityProofInternal(sourceCiphertext, destCiphertext, transferAmount, sourceRandomness, destRandomness, proofSize) {
  const proof = new Uint8Array(proofSize);
  const challenge = sha2562(new Uint8Array([
    ...sourceCiphertext.commitment.commitment,
    ...destCiphertext.commitment.commitment,
    ...numberToBytesBE2(transferAmount, 8),
    ...sourceRandomness,
    ...destRandomness
  ]));
  const rng = crypto.getRandomValues(new Uint8Array(32));
  let offset = 0;
  proof.set(sha2562(new Uint8Array([...challenge, ...rng, 0])), offset);
  offset += 32;
  proof.set(sha2562(new Uint8Array([...challenge, ...rng, 1])), offset);
  offset += 32;
  proof.set(sha2562(new Uint8Array([...challenge, ...rng, 2])), offset);
  offset += 32;
  const remaining = proofSize - offset;
  for (let i = 0;i < remaining; i += 32) {
    const chunk = sha2562(new Uint8Array([...challenge, ...rng, 3 + Math.floor(i / 32)]));
    proof.set(chunk.slice(0, Math.min(32, remaining - i)), i + offset);
  }
  return proof;
}
async function generateDiscreteLogEqualityProof(balance, keypair, ciphertext, proofSize) {
  const proof = new Uint8Array(proofSize);
  const challenge = sha2562(new Uint8Array([
    ...numberToBytesBE2(balance, 8),
    ...keypair.publicKey,
    ...ciphertext.commitment.commitment,
    ...ciphertext.handle.handle
  ]));
  const rng = crypto.getRandomValues(new Uint8Array(32));
  let offset = 0;
  proof.set(sha2562(new Uint8Array([...challenge, ...rng, 0])), offset);
  offset += 32;
  proof.set(sha2562(new Uint8Array([...challenge, ...rng, 1])), offset);
  offset += 32;
  const remaining = proofSize - offset;
  for (let i = 0;i < remaining; i += 32) {
    const chunk = sha2562(new Uint8Array([...challenge, ...rng, 2 + Math.floor(i / 32)]));
    proof.set(chunk.slice(0, Math.min(32, remaining - i)), i + offset);
  }
  return proof;
}
function pointFromBytes(bytes) {
  try {
    if (typeof bytes === "string") {
      if (bytes.length !== 64) {
        throw new Error("Invalid hex string length");
      }
      const point2 = ed25519.ExtendedPoint.fromHex(bytes);
      if (point2.equals(ed25519.ExtendedPoint.ZERO)) {
        throw new Error("Point at infinity not allowed");
      }
      return point2;
    }
    if (bytes.length !== 32) {
      throw new Error("Point bytes must be 32 bytes");
    }
    const hex = Array.from(bytes, (b) => b.toString(16).padStart(2, "0")).join("");
    const point = ed25519.ExtendedPoint.fromHex(hex);
    if (point.equals(ed25519.ExtendedPoint.ZERO)) {
      throw new Error("Point at infinity not allowed");
    }
    return point;
  } catch (error) {
    throw new Error(`Invalid curve point: ${error instanceof Error ? error.message : "Unknown error"}`);
  }
}
function scalarMultiply(point, scalar) {
  const n = bytesToNumberLE2(scalar) % ed25519.CURVE.n;
  return point.multiply(n);
}
async function elGamalPubkeyToAddress(pubkey) {
  if (pubkey.length !== 32) {
    throw new Error("ElGamal public key must be 32 bytes");
  }
  const bs58Module = await Promise.resolve().then(() => (init_esm3(), exports_esm));
  const { address: address3 } = await Promise.resolve().then(() => (init_index_node5(), exports_index_node));
  const bs58 = bs58Module.default;
  return address3(bs58.encode(Buffer.from(pubkey)));
}
async function loadWasmModule() {
  if (typeof window === "undefined") {
    return;
  }
  try {
    let wasmModule2;
    try {
      wasmModule2 = await Promise.resolve().then(() => (init_ghostspeak_wasm_KJ5KFZFH(), exports_ghostspeak_wasm_KJ5KFZFH));
    } catch {
      throw new Error("WASM module not built");
    }
    await wasmModule2.default();
    console.log("âœ… WASM module loaded for optimized ElGamal operations");
  } catch (error) {
    console.warn("âš ï¸ WASM module not available, using JavaScript fallback", error);
  }
}
async function loadWasmModule2() {
  if (wasmModule)
    return;
  if (loadingPromise)
    return loadingPromise;
  if (typeof window === "undefined") {
    console.log("âš ï¸ WASM only available in browser environment");
    return;
  }
  loadingPromise = loadWasmModuleInternal();
  return loadingPromise;
}
async function loadWasmModuleInternal() {
  try {
    let wasmImport;
    try {
      wasmImport = await Promise.resolve().then(() => (init_ghostspeak_wasm_KJ5KFZFH(), exports_ghostspeak_wasm_KJ5KFZFH));
    } catch {
      throw new Error("WASM module not built");
    }
    if (!wasmImport || typeof wasmImport !== "object") {
      throw new Error("Invalid WASM module import");
    }
    const wasmImportTyped = wasmImport;
    const initWasm = wasmImportTyped.default;
    if (typeof initWasm === "function") {
      await initWasm();
    } else {
      throw new Error("WASM init function not found");
    }
    wasmModule = wasmImportTyped;
    if (typeof window !== "undefined") {
      window.ghostspeak_wasm = wasmModule;
    }
    console.log("âœ… WASM module loaded successfully");
  } catch (error) {
    console.warn("âš ï¸ Failed to load WASM module:", error);
    wasmModule = null;
  }
}
function isWasmAvailable() {
  return wasmModule !== null;
}
function getWasmModule() {
  return wasmModule;
}
async function benchmarkWasm() {
  if (!isWasmAvailable()) {
    console.log("âš ï¸ WASM not available for benchmarking");
    return null;
  }
  const iterations = 100;
  const testData = new Uint8Array(32).fill(1);
  const now = () => typeof performance !== "undefined" ? performance.now() : Date.now();
  const wasmStart = now();
  for (let i = 0;i < iterations; i++) {
    wasmModule.scalar_multiply(testData, testData);
  }
  const wasmTime = now() - wasmStart;
  const { ed25519: ed255192 } = await Promise.resolve().then(() => (init_ed25519(), exports_ed25519));
  const jsStart = now();
  for (let i = 0;i < iterations; i++) {
    const point = ed255192.ExtendedPoint.BASE;
    const scalar = BigInt("0x" + Buffer.from(testData).toString("hex"));
    point.multiply(scalar % ed255192.CURVE.n);
  }
  const jsTime = now() - jsStart;
  const speedup = jsTime / wasmTime;
  console.log(`\uD83D\uDCCA WASM Benchmark Results:`);
  console.log(`   WASM: ${wasmTime.toFixed(2)}ms`);
  console.log(`   JS: ${jsTime.toFixed(2)}ms`);
  console.log(`   Speedup: ${speedup.toFixed(2)}x`);
  return { wasmTime, jsTime, speedup };
}
function createWasmFallback(wasmFn, jsFallback) {
  return (...args) => {
    if (wasmFn && isWasmAvailable()) {
      try {
        return wasmFn(...args);
      } catch (error) {
        console.warn("âš ï¸ WASM call failed, using JS fallback:", error);
      }
    }
    return jsFallback(...args);
  };
}
var elgamal_exports, G, H, PROOF_SIZES, elgamal_default, wasm_bridge_exports, wasmModule = null, loadingPromise = null, wasm_bridge_default;
var init_chunk_WY76C2A5 = __esm(() => {
  init_chunk_Z6ZWNWWR();
  init_ed25519();
  init_sha256();
  init_utils3();
  elgamal_exports = {};
  __export2(elgamal_exports, {
    PROOF_SIZES: () => PROOF_SIZES,
    addCiphertexts: () => addCiphertexts,
    decrypt: () => decrypt,
    default: () => elgamal_default,
    deriveKeypair: () => deriveKeypair,
    elGamalPubkeyToAddress: () => elGamalPubkeyToAddress,
    encrypt: () => encrypt,
    generateEqualityProof: () => generateEqualityProof,
    generateKeypair: () => generateKeypair,
    generateRangeProof: () => generateRangeProof,
    generateTransferProof: () => generateTransferProof,
    generateValidityProof: () => generateValidityProof,
    generateWithdrawProof: () => generateWithdrawProof,
    loadWasmModule: () => loadWasmModule,
    subtractCiphertexts: () => subtractCiphertexts
  });
  G = ed25519.ExtendedPoint.BASE;
  H = createHGenerator();
  PROOF_SIZES = {
    RANGE_PROOF: 674,
    VALIDITY_PROOF: 160,
    EQUALITY_PROOF: 192,
    WITHDRAW_PROOF: 80,
    ZERO_BALANCE_PROOF: 96,
    FEE_SIGMA_PROOF: 256,
    PUBKEY_VALIDITY_PROOF: 64
  };
  elgamal_default = {
    generateKeypair,
    deriveKeypair,
    encrypt,
    decrypt,
    addCiphertexts,
    subtractCiphertexts,
    generateRangeProof,
    generateValidityProof,
    generateEqualityProof,
    generateTransferProof,
    generateWithdrawProof,
    elGamalPubkeyToAddress,
    loadWasmModule,
    PROOF_SIZES
  };
  wasm_bridge_exports = {};
  __export2(wasm_bridge_exports, {
    benchmarkWasm: () => benchmarkWasm,
    createWasmFallback: () => createWasmFallback,
    default: () => wasm_bridge_default,
    getWasmModule: () => getWasmModule,
    isWasmAvailable: () => isWasmAvailable,
    loadWasmModule: () => loadWasmModule2
  });
  if (typeof window !== "undefined") {
    setTimeout(() => {
      loadWasmModule2().catch((error) => {
        console.warn("âš ï¸ Background WASM loading failed:", error);
      });
    }, 0);
  }
  wasm_bridge_default = {
    loadWasmModule: loadWasmModule2,
    isWasmAvailable,
    getWasmModule,
    benchmarkWasm,
    createWasmFallback
  };
});

// ../sdk-typescript/dist/agent-VNPJYTOI.js
var exports_agent_VNPJYTOI = {};
__export(exports_agent_VNPJYTOI, {
  getAgentEncoder: () => getAgentEncoder,
  getAgentDiscriminatorBytes: () => getAgentDiscriminatorBytes,
  getAgentDecoder: () => getAgentDecoder,
  getAgentCodec: () => getAgentCodec,
  fetchMaybeAgent: () => fetchMaybeAgent,
  fetchAllMaybeAgent: () => fetchAllMaybeAgent,
  fetchAllAgent: () => fetchAllAgent,
  fetchAgent: () => fetchAgent,
  decodeAgent: () => decodeAgent,
  AGENT_DISCRIMINATOR: () => AGENT_DISCRIMINATOR
});
var init_agent_VNPJYTOI = __esm(() => {
  init_chunk_5QZVFUXB();
  init_chunk_Z6ZWNWWR();
});

// ../sdk-typescript/dist/chunk-5TBUKTT3.js
function validateAccountDiscriminator(accountData, expectedDiscriminator) {
  if (accountData.length < expectedDiscriminator.length) {
    return {
      isValid: false,
      expectedLength: expectedDiscriminator.length,
      actualLength: accountData.length,
      canDecode: false,
      needsMigration: true,
      errorMessage: `Account too small. Expected at least ${expectedDiscriminator.length} bytes, got ${accountData.length}`
    };
  }
  const actualDiscriminator = accountData.slice(0, expectedDiscriminator.length);
  const isValid = actualDiscriminator.every((byte, index) => byte === expectedDiscriminator[index]);
  if (isValid) {
    return {
      isValid: true,
      expectedLength: expectedDiscriminator.length,
      actualLength: actualDiscriminator.length,
      canDecode: true,
      needsMigration: false
    };
  }
  if (actualDiscriminator.length >= 2) {
    const first2Bytes = actualDiscriminator.slice(0, 2);
    if (first2Bytes[0] !== 0 || first2Bytes[1] !== 0) {
      return {
        isValid: false,
        expectedLength: expectedDiscriminator.length,
        actualLength: 2,
        canDecode: false,
        needsMigration: true,
        errorMessage: `Legacy discriminator format detected. Account needs migration.`
      };
    }
  }
  return {
    isValid: false,
    expectedLength: expectedDiscriminator.length,
    actualLength: actualDiscriminator.length,
    canDecode: false,
    needsMigration: true,
    errorMessage: `Discriminator mismatch. Expected [${Array.from(expectedDiscriminator).join(", ")}], got [${Array.from(actualDiscriminator).join(", ")}]`
  };
}
function createDiscriminatorErrorMessage(validation, accountType, address3) {
  if (validation.needsMigration) {
    return [
      `âš ï¸  ${accountType} account needs attention: ${address3}`,
      `   Issue: ${validation.errorMessage}`,
      `   Resolution: Account may need to be recreated with current program version`,
      `   Use 'ghost diagnose account ${address3}' for detailed analysis`
    ].join(`
`);
  }
  if (!validation.canDecode) {
    return [
      `âŒ Failed to decode ${accountType} account: ${address3}`,
      `   Issue: ${validation.errorMessage}`,
      `   This may indicate a corrupt or incompatible account`
    ].join(`
`);
  }
  return `âœ… ${accountType} account is valid: ${address3}`;
}
async function safeDecodeAgent(encodedAccount) {
  try {
    const { AGENT_DISCRIMINATOR: AGENT_DISCRIMINATOR2, getAgentDecoder: getAgentDecoder2 } = await Promise.resolve().then(() => (init_agent_VNPJYTOI(), exports_agent_VNPJYTOI));
    const validation = validateAccountDiscriminator(encodedAccount.data, AGENT_DISCRIMINATOR2);
    if (validation.canDecode) {
      try {
        const decoder = getAgentDecoder2();
        const data = decoder.decode(encodedAccount.data);
        return { exists: true, data };
      } catch (decodeError) {
        console.warn(`Failed to decode Agent account ${encodedAccount.address}:`, decodeError);
        return { exists: false };
      }
    }
    return { exists: false };
  } catch (error) {
    console.warn(`Safe decode failed for ${encodedAccount.address}:`, error);
    return null;
  }
}
function inspectAccountData(encodedAccount, address3) {
  if (!("exists" in encodedAccount) || !encodedAccount.exists) {
    return {
      address: address3,
      dataLength: 0,
      discriminator: null,
      discriminatorLength: 0,
      isAgentAccount: false,
      needsMigration: false,
      rawData: new Uint8Array(0)
    };
  }
  const data = "data" in encodedAccount ? encodedAccount.data : new Uint8Array(0);
  const discriminatorLength = Math.min(data.length, 8);
  const discriminator = discriminatorLength > 0 ? data.slice(0, discriminatorLength) : null;
  return {
    address: address3,
    dataLength: data.length,
    discriminator,
    discriminatorLength,
    isAgentAccount: false,
    needsMigration: discriminatorLength > 0 && discriminatorLength < 8,
    rawData: data
  };
}
async function createMigrationPlan(encodedAccount, address3) {
  const plan = {
    address: address3,
    currentState: "not_exists",
    migrationType: "none",
    issues: [],
    recommendations: [],
    canAutoMigrate: false
  };
  if (!("exists" in encodedAccount) || !encodedAccount.exists) {
    plan.recommendations.push("Account does not exist - no migration needed");
    return plan;
  }
  const { AGENT_DISCRIMINATOR: AGENT_DISCRIMINATOR2 } = await Promise.resolve().then(() => (init_agent_VNPJYTOI(), exports_agent_VNPJYTOI));
  const validation = validateAccountDiscriminator(encodedAccount.data, AGENT_DISCRIMINATOR2);
  const inspection = inspectAccountData(encodedAccount, address3);
  if (validation.isValid) {
    plan.currentState = "valid";
    plan.recommendations.push("Account is already in the correct format");
    return plan;
  }
  if (validation.needsMigration) {
    plan.currentState = "needs_migration";
    plan.issues.push(`Discriminator length mismatch: expected 8 bytes, got ${validation.actualLength} bytes`);
  } else {
    plan.currentState = "invalid";
    plan.issues.push("Account has invalid or corrupted discriminator");
  }
  if (inspection.discriminatorLength === 2) {
    plan.migrationType = "recreate";
    plan.issues.push("Account uses legacy 2-byte discriminator format");
    plan.recommendations.push("Recreate account using current register_agent instruction");
    plan.recommendations.push("Export existing data first if valuable");
  } else if (inspection.discriminatorLength === 0) {
    plan.migrationType = "unsupported";
    plan.issues.push("Account has no discriminator - may not be an Agent account");
    plan.recommendations.push("Verify this is actually an Agent account");
  } else if (inspection.discriminatorLength < 8) {
    plan.migrationType = "unsupported";
    plan.issues.push(`Partial discriminator detected (${inspection.discriminatorLength} bytes)`);
    plan.recommendations.push("Account data may be corrupted - consider recreation");
  } else {
    plan.migrationType = "data_conversion";
    plan.issues.push("Discriminator has correct length but wrong values");
    plan.recommendations.push("May be from a different program version");
    plan.recommendations.push("Check if this account belongs to the correct program");
  }
  plan.canAutoMigrate = plan.migrationType === "recreate" && inspection.dataLength > 8;
  return plan;
}
function extractLegacyData(encodedAccount) {
  if (!("exists" in encodedAccount) || !encodedAccount.exists || !("data" in encodedAccount) || encodedAccount.data.length < 2) {
    return null;
  }
  const data = "data" in encodedAccount ? encodedAccount.data : new Uint8Array(0);
  try {
    if (data.length >= 2) {
      return {
        discriminator: data.slice(0, 2)
      };
    }
  } catch (error) {
    console.warn("Failed to extract legacy data:", error);
  }
  return null;
}
async function createMigrationReport(accounts2) {
  const plans = await Promise.all(accounts2.map(({ address: address3, encodedAccount }) => createMigrationPlan(encodedAccount, address3)));
  const summary = {
    total: plans.length,
    valid: plans.filter((p) => p.currentState === "valid").length,
    needsMigration: plans.filter((p) => p.currentState === "needs_migration").length,
    invalid: plans.filter((p) => p.currentState === "invalid").length,
    canAutoMigrate: plans.filter((p) => p.canAutoMigrate).length
  };
  const recommendations = [];
  if (summary.needsMigration > 0) {
    recommendations.push(`${summary.needsMigration} accounts need migration`);
  }
  if (summary.canAutoMigrate > 0) {
    recommendations.push(`${summary.canAutoMigrate} accounts can be auto-migrated`);
  }
  if (summary.invalid > 0) {
    recommendations.push(`${summary.invalid} accounts have invalid data and should be investigated`);
  }
  if (summary.needsMigration === 0 && summary.invalid === 0) {
    recommendations.push("All accounts are in the correct format");
  } else {
    recommendations.push("Consider running migration utilities to fix account format issues");
    recommendations.push("Backup important account data before migration");
  }
  return {
    summary,
    plans,
    recommendations
  };
}
async function simulateMigration(encodedAccount, address3) {
  const plan = await createMigrationPlan(encodedAccount, address3);
  const simulation = {
    wouldSucceed: false,
    estimatedSteps: [],
    warnings: [],
    requiredActions: []
  };
  if (plan.currentState === "valid") {
    simulation.wouldSucceed = true;
    simulation.estimatedSteps.push("No migration needed - account is already valid");
    return { plan, simulation };
  }
  switch (plan.migrationType) {
    case "recreate":
      simulation.estimatedSteps.push("1. Extract existing account data");
      simulation.estimatedSteps.push("2. Create new account with correct format");
      simulation.estimatedSteps.push("3. Transfer any salvageable data");
      simulation.estimatedSteps.push("4. Close old account");
      simulation.requiredActions.push("User must re-register the agent");
      simulation.warnings.push("Some data may be lost during recreation");
      simulation.wouldSucceed = plan.canAutoMigrate;
      break;
    case "data_conversion":
      simulation.estimatedSteps.push("1. Analyze existing data format");
      simulation.estimatedSteps.push("2. Convert to new format");
      simulation.estimatedSteps.push("3. Update discriminator");
      simulation.warnings.push("Data conversion is experimental");
      simulation.requiredActions.push("Manual verification required");
      simulation.wouldSucceed = false;
      break;
    case "unsupported":
      simulation.estimatedSteps.push("1. Manual investigation required");
      simulation.estimatedSteps.push("2. Determine if account is recoverable");
      simulation.warnings.push("Account may not be recoverable");
      simulation.requiredActions.push("Manual inspection and possible recreation");
      simulation.wouldSucceed = false;
      break;
    default:
      simulation.estimatedSteps.push("No migration strategy available");
      simulation.wouldSucceed = false;
  }
  return { plan, simulation };
}
function getMigrationInstructions(plan) {
  const instructions2 = [];
  switch (plan.migrationType) {
    case "none":
      instructions2.push("âœ… No migration needed - your account is up to date");
      break;
    case "recreate":
      instructions2.push("\uD83D\uDD04 Account Recreation Required:");
      instructions2.push("1. Use the CLI command: `ghost agent register` to create a new account");
      instructions2.push("2. Configure your agent with the same settings as before");
      instructions2.push("3. The old account will be automatically replaced");
      instructions2.push("âš ï¸  Note: You may need to re-verify your agent after recreation");
      break;
    case "data_conversion":
      instructions2.push("\uD83D\uDD27 Data Conversion Required:");
      instructions2.push("1. Contact support for assistance with account conversion");
      instructions2.push("2. Manual intervention may be required");
      instructions2.push("3. Backup your account data before proceeding");
      break;
    case "unsupported":
      instructions2.push("âŒ Migration Not Supported:");
      instructions2.push("1. This account cannot be automatically migrated");
      instructions2.push("2. Consider creating a new account");
      instructions2.push("3. Contact support if this account contains important data");
      break;
  }
  return instructions2;
}
async function runAccountDiagnostics(encodedAccount, address3) {
  const timestamp = (/* @__PURE__ */ new Date()).toISOString();
  const accountExists2 = "exists" in encodedAccount && encodedAccount.exists;
  let discriminatorValidation, inspection, migrationPlan, migrationSimulation;
  if (accountExists2) {
    const { AGENT_DISCRIMINATOR: AGENT_DISCRIMINATOR2 } = await Promise.resolve().then(() => (init_agent_VNPJYTOI(), exports_agent_VNPJYTOI));
    discriminatorValidation = validateAccountDiscriminator(encodedAccount.data, AGENT_DISCRIMINATOR2);
    inspection = inspectAccountData(encodedAccount, address3);
    migrationPlan = await createMigrationPlan(encodedAccount, address3);
    migrationSimulation = await simulateMigration(encodedAccount, address3);
  } else {
    discriminatorValidation = {
      isValid: false,
      actualLength: 0,
      expectedLength: 8,
      canDecode: false,
      needsMigration: false,
      errorMessage: "Account does not exist"
    };
    inspection = {
      address: address3,
      dataLength: 0,
      discriminator: null,
      discriminatorLength: 0,
      isAgentAccount: false,
      needsMigration: false,
      rawData: new Uint8Array(0)
    };
    migrationPlan = {
      address: address3,
      currentState: "not_exists",
      migrationType: "none",
      issues: ["Account does not exist"],
      recommendations: ["Create account using register_agent instruction"],
      canAutoMigrate: false
    };
    migrationSimulation = {
      plan: migrationPlan,
      simulation: {
        wouldSucceed: false,
        estimatedSteps: ["Account must be created first"],
        warnings: [],
        requiredActions: ["Use register_agent instruction"]
      }
    };
  }
  const recommendations = [];
  if (!accountExists2) {
    recommendations.push("Account does not exist - create using register_agent");
  } else if (discriminatorValidation.isValid) {
    recommendations.push("Account is valid - no action needed");
  } else {
    recommendations.push(...getMigrationInstructions(migrationPlan));
  }
  const debugInfo = {
    expectedDiscriminator: Array.from(AGENT_DISCRIMINATOR),
    actualDiscriminator: inspection.discriminator ? Array.from(inspection.discriminator) : null,
    dataPreview: Array.from(inspection.rawData.slice(0, 32)),
    programId: accountExists2 && "owner" in encodedAccount ? encodedAccount.owner : undefined
  };
  return {
    address: address3,
    timestamp,
    accountExists: accountExists2,
    discriminatorValidation,
    inspection,
    migrationPlan,
    migrationSimulation,
    recommendations,
    debugInfo
  };
}
async function runBatchDiagnostics(accounts2) {
  const timestamp = (/* @__PURE__ */ new Date()).toISOString();
  const reports = await Promise.all(accounts2.map(({ address: address3, encodedAccount }) => runAccountDiagnostics(encodedAccount, address3)));
  const summary = {
    total: reports.length,
    valid: reports.filter((r) => r.accountExists && r.discriminatorValidation.isValid).length,
    invalid: reports.filter((r) => r.accountExists && !r.discriminatorValidation.isValid).length,
    needsMigration: reports.filter((r) => r.migrationPlan.currentState === "needs_migration").length,
    notExists: reports.filter((r) => !r.accountExists).length
  };
  const globalRecommendations = [];
  if (summary.notExists > 0) {
    globalRecommendations.push(`${summary.notExists} accounts need to be created`);
  }
  if (summary.needsMigration > 0) {
    globalRecommendations.push(`${summary.needsMigration} accounts need migration`);
  }
  if (summary.invalid > 0) {
    globalRecommendations.push(`${summary.invalid} accounts have data issues`);
  }
  if (summary.valid === summary.total) {
    globalRecommendations.push("All accounts are healthy");
  }
  return {
    summary,
    reports,
    globalRecommendations,
    timestamp
  };
}
async function diagnoseAccountFromChain(rpc2, address3, options2) {
  try {
    const encodedAccount = await fetchEncodedAccount(rpc2, address3);
    const report = await runAccountDiagnostics(encodedAccount, address3);
    if (options2?.logToConsole) {
      console.group(`\uD83D\uDD0D Account Diagnostics: ${address3}`);
      console.log("Exists:", report.accountExists);
      console.log("Valid:", report.discriminatorValidation.isValid);
      console.log("Needs Migration:", report.migrationPlan.currentState === "needs_migration");
      console.log("Recommendations:");
      report.recommendations.forEach((rec) => console.log(`  - ${rec}`));
      if (!report.discriminatorValidation.isValid) {
        console.log("Issues:");
        if (Array.isArray(report.migrationPlan.issues)) {
          report.migrationPlan.issues.forEach((issue) => console.log(`  - ${issue}`));
        }
      }
      console.groupEnd();
    }
    return report;
  } catch (err) {
    console.error(`Failed to diagnose account ${address3}:`, err);
    return {
      address: address3,
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      accountExists: false,
      discriminatorValidation: {
        isValid: false,
        actualLength: 0,
        expectedLength: 8,
        canDecode: false,
        needsMigration: false,
        errorMessage: `Failed to fetch account: ${err instanceof Error ? err.message : String(err)}`
      },
      inspection: {
        address: address3,
        dataLength: 0,
        discriminator: null,
        discriminatorLength: 0,
        isAgentAccount: false,
        needsMigration: false,
        rawData: new Uint8Array(0)
      },
      migrationPlan: {
        address: address3,
        currentState: "invalid",
        migrationType: "unsupported",
        issues: [`Failed to fetch account: ${err instanceof Error ? err.message : String(err)}`],
        recommendations: ["Check network connection and account address"],
        canAutoMigrate: false
      },
      migrationSimulation: {
        plan: {
          address: address3,
          currentState: "invalid",
          migrationType: "unsupported",
          issues: [`Failed to fetch account: ${err instanceof Error ? err.message : String(err)}`],
          recommendations: ["Check network connection and account address"],
          canAutoMigrate: false
        },
        simulation: {
          wouldSucceed: false,
          estimatedSteps: ["Fix network connectivity issues"],
          warnings: ["Account could not be fetched"],
          requiredActions: ["Verify account address and network connection"]
        }
      },
      recommendations: ["Check network connection and account address"],
      debugInfo: {
        expectedDiscriminator: Array.from(AGENT_DISCRIMINATOR),
        actualDiscriminator: null,
        dataPreview: [],
        programId: undefined
      }
    };
  }
}
async function diagnoseBatchFromChain(rpc2, addresses2, options2) {
  const maxConcurrent = options2?.maxConcurrent ?? 10;
  const reports = [];
  for (let i = 0;i < addresses2.length; i += maxConcurrent) {
    const batch = addresses2.slice(i, i + maxConcurrent);
    const batchPromises = batch.map((address3) => diagnoseAccountFromChain(rpc2, address3, { logToConsole: false }));
    const batchReports = await Promise.allSettled(batchPromises);
    for (const result of batchReports) {
      if (result.status === "fulfilled") {
        reports.push(result.value);
      } else {
        console.error("Failed to diagnose account:", result.reason);
        reports.push({
          address: "unknown",
          timestamp: (/* @__PURE__ */ new Date()).toISOString(),
          accountExists: false,
          discriminatorValidation: {
            isValid: false,
            actualLength: 0,
            expectedLength: 8,
            canDecode: false,
            needsMigration: false,
            errorMessage: "Failed to fetch account"
          },
          inspection: {
            address: "unknown",
            dataLength: 0,
            discriminator: null,
            discriminatorLength: 0,
            isAgentAccount: false,
            needsMigration: false,
            rawData: new Uint8Array(0)
          },
          migrationPlan: {
            address: "unknown",
            currentState: "invalid",
            migrationType: "unsupported",
            issues: ["Failed to fetch account"],
            recommendations: ["Check network connection"],
            canAutoMigrate: false
          },
          migrationSimulation: {
            plan: {
              address: "unknown",
              currentState: "invalid",
              migrationType: "unsupported",
              issues: ["Failed to fetch account"],
              recommendations: ["Check network connection"],
              canAutoMigrate: false
            },
            simulation: {
              wouldSucceed: false,
              estimatedSteps: ["Fix fetch issues"],
              warnings: ["Account could not be fetched"],
              requiredActions: ["Check network"]
            }
          },
          recommendations: ["Check network connection"],
          debugInfo: {
            expectedDiscriminator: Array.from(AGENT_DISCRIMINATOR),
            actualDiscriminator: null,
            dataPreview: [],
            programId: undefined
          }
        });
      }
    }
  }
  const batchReport = await runBatchDiagnostics(reports.map((report) => ({
    address: report.address,
    encodedAccount: {
      exists: report.accountExists,
      data: report.inspection.rawData,
      address: report.address,
      owner: report.debugInfo.programId ?? "",
      executable: false,
      lamports: 0n,
      programAddress: report.debugInfo.programId ?? "",
      space: report.inspection.rawData.length
    }
  })));
  if (options2?.logToConsole) {
    console.group("\uD83D\uDD0D Batch Diagnostics Summary");
    console.log("Total accounts:", batchReport.summary.total);
    console.log("Valid accounts:", batchReport.summary.valid);
    console.log("Invalid accounts:", batchReport.summary.invalid);
    console.log("Need migration:", batchReport.summary.needsMigration);
    console.log("Do not exist:", batchReport.summary.notExists);
    console.log("Global recommendations:");
    batchReport.globalRecommendations.forEach((rec) => console.log(`  - ${rec}`));
    console.groupEnd();
  }
  return batchReport;
}
function exportDiagnosticReport(report, filename) {
  const json = JSON.stringify(report, null, 2);
  if (filename) {
    console.log(`Diagnostic report would be saved as: ${filename}`);
    console.log("Report data:", json);
  }
  return json;
}
async function deriveAssociatedTokenAddress(owner, mint, tokenProgram = TOKEN_PROGRAM_ADDRESS) {
  const [address3] = await getProgramDerivedAddress2({
    programAddress: ASSOCIATED_TOKEN_PROGRAM_ADDRESS,
    seeds: [
      getAddressEncoder2().encode(owner),
      getAddressEncoder2().encode(tokenProgram),
      getAddressEncoder2().encode(mint)
    ]
  });
  return address3;
}
async function deriveSplTokenAssociatedTokenAddress(owner, mint) {
  return deriveAssociatedTokenAddress(owner, mint, TOKEN_PROGRAM_ADDRESS);
}
async function deriveToken2022AssociatedTokenAddress(owner, mint) {
  return deriveAssociatedTokenAddress(owner, mint, TOKEN_2022_PROGRAM_ADDRESS);
}
async function getAssociatedTokenAccount(owner, mint, tokenProgram) {
  const program = tokenProgram ?? TOKEN_PROGRAM_ADDRESS;
  const isToken2022 = program === TOKEN_2022_PROGRAM_ADDRESS;
  const address3 = await deriveAssociatedTokenAddress(owner, mint, program);
  return {
    address: address3,
    owner,
    mint,
    tokenProgram: program,
    isToken2022
  };
}
async function detectTokenProgram(mint, rpcEndpoint = "https://api.devnet.solana.com") {
  try {
    const { createSolanaRpc: createSolanaRpc2 } = await Promise.resolve().then(() => (init_index_node40(), exports_index_node3));
    const rpc2 = createSolanaRpc2(rpcEndpoint);
    const accountInfo = await rpc2.getAccountInfo(mint, {
      encoding: "base64",
      commitment: "confirmed"
    }).send();
    if (!accountInfo.value) {
      throw new Error(`Mint account ${mint} not found`);
    }
    const ownerProgram = accountInfo.value.owner;
    if (ownerProgram === TOKEN_PROGRAM_ADDRESS) {
      return TOKEN_PROGRAM_ADDRESS;
    } else if (ownerProgram === TOKEN_2022_PROGRAM_ADDRESS) {
      return TOKEN_2022_PROGRAM_ADDRESS;
    } else {
      console.warn(`Unknown token program owner: ${ownerProgram}, defaulting to SPL Token`);
      return TOKEN_PROGRAM_ADDRESS;
    }
  } catch (error) {
    console.error(`Failed to detect token program for mint ${mint}:`, error);
    return TOKEN_PROGRAM_ADDRESS;
  }
}
async function isToken2022Mint(mint) {
  const program = await detectTokenProgram(mint);
  return program === TOKEN_2022_PROGRAM_ADDRESS;
}
async function getTokenProgramType(mint) {
  const isToken2022 = await isToken2022Mint(mint);
  return isToken2022 ? "token-2022" : "spl-token";
}
async function checkToken2022Extensions(mint, extensions, _rpcEndpoint = "https://api.devnet.solana.com") {
  console.warn(`Token-2022 extension checking is deprecated: mint ${mint}`);
  const result = {};
  for (const extension of extensions) {
    result[extension] = false;
  }
  return result;
}
async function hasTransferFeeExtension(mint, rpcEndpoint = "https://api.devnet.solana.com") {
  const result = await checkToken2022Extensions(mint, [1], rpcEndpoint);
  return result[1];
}
async function hasConfidentialTransferExtension(mint, rpcEndpoint = "https://api.devnet.solana.com") {
  const result = await checkToken2022Extensions(mint, [4], rpcEndpoint);
  return result[4];
}
async function hasInterestBearingExtension(mint, rpcEndpoint = "https://api.devnet.solana.com") {
  const result = await checkToken2022Extensions(mint, [10], rpcEndpoint);
  return result[10];
}
async function getTransferFeeConfig(mint, _rpcEndpoint = "https://api.devnet.solana.com") {
  console.warn(`Token-2022 getTransferFeeConfig is deprecated: mint ${mint}`);
  return null;
}
async function getConfidentialTransferConfig(mint, _rpcEndpoint = "https://api.devnet.solana.com") {
  console.warn(`Token-2022 getConfidentialTransferConfig is deprecated: mint ${mint}`);
  return null;
}
async function getInterestBearingConfig(mint, _rpcEndpoint = "https://api.devnet.solana.com") {
  console.warn(`Token-2022 getInterestBearingConfig is deprecated: mint ${mint}`);
  return null;
}
async function getAllAssociatedTokenAddresses(owner, mint) {
  const [splToken, token2022] = await Promise.all([
    deriveSplTokenAssociatedTokenAddress(owner, mint),
    deriveToken2022AssociatedTokenAddress(owner, mint)
  ]);
  return { splToken, token2022 };
}
async function validateAssociatedTokenAddress(address3, owner, mint) {
  const addresses2 = await getAllAssociatedTokenAddresses(owner, mint);
  if (address3 === addresses2.splToken) {
    return { isValid: true, program: TOKEN_PROGRAM_ADDRESS };
  }
  if (address3 === addresses2.token2022) {
    return { isValid: true, program: TOKEN_2022_PROGRAM_ADDRESS };
  }
  return { isValid: false };
}
function getTokenProgramAddress(program) {
  switch (program) {
    case "spl-token":
      return TOKEN_PROGRAM_ADDRESS;
    case "token-2022":
      return TOKEN_2022_PROGRAM_ADDRESS;
    default:
      throw new Error(`Unknown token program: ${program}`);
  }
}
function getTokenProgramFromAddress(address3) {
  if (address3 === TOKEN_PROGRAM_ADDRESS) {
    return "spl-token";
  }
  if (address3 === TOKEN_2022_PROGRAM_ADDRESS) {
    return "token-2022";
  }
  throw new Error(`Unknown token program address: ${address3}`);
}
function formatTokenAmount(amount, decimals) {
  const divisor = BigInt(10 ** decimals);
  const quotient = amount / divisor;
  const remainder = amount % divisor;
  if (remainder === BigInt(0)) {
    return quotient.toString();
  }
  const remainderStr = remainder.toString().padStart(decimals, "0");
  const trimmedRemainder = remainderStr.replace(/0+$/, "");
  return `${quotient}.${trimmedRemainder}`;
}
function parseTokenAmount(formatted, decimals) {
  const [whole, fraction = ""] = formatted.split(".");
  const paddedFraction = fraction.padEnd(decimals, "0").slice(0, decimals);
  const rawAmount = whole + paddedFraction;
  return BigInt(rawAmount);
}
async function deriveMultisigPda(programId, authority, multisigId) {
  const [pda] = await getProgramDerivedAddress2({
    programAddress: programId,
    seeds: [
      getBytesEncoder().encode(new Uint8Array([109, 117, 108, 116, 105, 115, 105, 103])),
      getAddressEncoder2().encode(authority),
      new Uint8Array(new BigUint64Array([multisigId]).buffer)
    ]
  });
  return pda;
}
async function deriveProposalPda(programId, multisig, proposalId) {
  const [pda] = await getProgramDerivedAddress2({
    programAddress: programId,
    seeds: [
      getBytesEncoder().encode(new Uint8Array([112, 114, 111, 112, 111, 115, 97, 108])),
      getAddressEncoder2().encode(multisig),
      new Uint8Array(new BigUint64Array([proposalId]).buffer)
    ]
  });
  return pda;
}
async function deriveRbacPda(programId, admin) {
  const [pda] = await getProgramDerivedAddress2({
    programAddress: programId,
    seeds: [
      getBytesEncoder().encode(new Uint8Array([114, 98, 97, 99])),
      getAddressEncoder2().encode(admin)
    ]
  });
  return pda;
}
function getFeatureFlags(environment) {
  globalFeatureFlags ??= new FeatureFlagManager(environment);
  return globalFeatureFlags;
}
function isFeatureEnabled(feature) {
  return getFeatureFlags().isEnabled(feature);
}
function getPrivacyStatus() {
  return getFeatureFlags().getPrivacyStatus();
}
function generateElGamalKeypair(seed) {
  const secretKey = seed ? hash(seed).slice(0, 32) : randomBytes2(32);
  secretKey[0] &= 248;
  secretKey[31] &= 127;
  secretKey[31] |= 64;
  const scalarValue = bytesToNumberLE2(secretKey) % ed25519.CURVE.n;
  const publicKey = G2.multiply(scalarValue).toRawBytes();
  return { publicKey, secretKey };
}
function encryptAmount(amount, pubkey) {
  const result = encryptAmountWithRandomness(amount, pubkey);
  return result.ciphertext;
}
function encryptAmountWithRandomness(amount, pubkey, providedRandomness) {
  if (amount < 0n) {
    throw new Error("Amount must be non-negative");
  }
  if (amount > MAX_DECRYPTABLE_VALUE) {
    throw new Error(`Amount exceeds maximum decryptable value (${MAX_DECRYPTABLE_VALUE})`);
  }
  const randomness = randomBytes2(32);
  randomness[0] &= 248;
  randomness[31] &= 127;
  randomness[31] |= 64;
  const r = bytesToNumberLE2(randomness) % ed25519.CURVE.n;
  const pubkeyPoint = ed25519.ExtendedPoint.fromHex(bytesToHex2(pubkey));
  const amountPoint = amount === 0n ? ed25519.ExtendedPoint.ZERO : G2.multiply(amount);
  const maskedAmount = amountPoint.add(pubkeyPoint.multiply(r));
  const commitment = maskedAmount.toRawBytes();
  const handle = G2.multiply(r).toRawBytes();
  return {
    ciphertext: {
      commitment: { commitment },
      handle: { handle }
    },
    randomness
  };
}
function decryptAmount(ciphertext, secretKey, maxValue = 65536n) {
  const C = ed25519.ExtendedPoint.fromHex(bytesToHex2(ciphertext.commitment.commitment));
  const D3 = ed25519.ExtendedPoint.fromHex(bytesToHex2(ciphertext.handle.handle));
  const sk = bytesToNumberLE2(secretKey) % ed25519.CURVE.n;
  const decryptedPoint = C.subtract(D3.multiply(sk));
  for (let i = 0n;i <= maxValue; i++) {
    const testPoint = i === 0n ? ed25519.ExtendedPoint.ZERO : G2.multiply(i);
    if (testPoint.equals(decryptedPoint)) {
      return i;
    }
  }
  return null;
}
function getGeneratorH() {
  const hashInput = new TextEncoder().encode("ElGamal-Generator-H");
  const hashOutput = hash(hashInput);
  const scalar = bytesToNumberLE2(hashOutput) % ed25519.CURVE.n;
  return G2.multiply(scalar);
}
function bigIntToBytes(value) {
  const bytes = new Uint8Array(32);
  let temp = value;
  for (let i = 0;i < 32; i++) {
    bytes[i] = Number(temp & 0xffn);
    temp >>= BigInt(8);
  }
  return bytes;
}
function bytesToBigInt(bytes) {
  let result = BigInt(0);
  for (let i = bytes.length - 1;i >= 0; i--) {
    result = result << BigInt(8) | BigInt(bytes[i]);
  }
  return result;
}
async function generateLocalPrivacyProof(encrypted, statement) {
  const proofData = new Uint8Array(128);
  proofData.set(encrypted.commitment, 0);
  proofData.set(sha2562(new TextEncoder().encode(statement)), 32);
  proofData.set(randomBytes2(64), 64);
  const publicInputs = new Uint8Array(64);
  publicInputs.set(encrypted.commitment, 0);
  publicInputs.set(encrypted.publicKey, 32);
  return {
    proof: proofData,
    publicInputs,
    timestamp: Date.now()
  };
}
async function verifyLocalPrivacyProof(proof, publicInputs, encrypted) {
  if (proof.length !== 128 || publicInputs.length !== 64) {
    return false;
  }
  const proofCommitment = proof.slice(0, 32);
  const inputCommitment = publicInputs.slice(0, 32);
  return bytesToHex2(proofCommitment) === bytesToHex2(encrypted.commitment) && bytesToHex2(inputCommitment) === bytesToHex2(encrypted.commitment);
}
var account_diagnostics_exports, TokenProgram, TokenExtension, governance_helpers_exports, ProposalUtils = class {
  static isVotingOpen(proposal) {
    const now = BigInt(Math.floor(Date.now() / 1000));
    return proposal.status === 1 && now >= proposal.votingStartsAt && now <= proposal.votingEndsAt;
  }
  static hasExpired(proposal) {
    const now = BigInt(Math.floor(Date.now() / 1000));
    return now > proposal.votingEndsAt;
  }
  static timeRemaining(proposal) {
    const now = BigInt(Math.floor(Date.now() / 1000));
    if (now >= proposal.votingEndsAt)
      return 0n;
    return proposal.votingEndsAt - now;
  }
  static formatTimeRemaining(proposal) {
    const remaining = this.timeRemaining(proposal);
    if (remaining === 0n)
      return "Voting ended";
    const seconds = Number(remaining);
    const days = Math.floor(seconds / 86400);
    const hours = Math.floor(seconds % 86400 / 3600);
    const minutes = Math.floor(seconds % 3600 / 60);
    if (days > 0)
      return `${days}d ${hours}h remaining`;
    if (hours > 0)
      return `${hours}h ${minutes}m remaining`;
    return `${minutes}m remaining`;
  }
  static hasReachedQuorum(votingResults, quorumRequirements, totalEligibleVoters) {
    const totalVotes = Number(votingResults.votesFor + votingResults.votesAgainst + votingResults.votesAbstain);
    const participationRate = totalVotes / totalEligibleVoters * 100;
    return participationRate >= quorumRequirements.minimumParticipation;
  }
  static calculateResults(votingResults) {
    const total = Number(votingResults.votesFor + votingResults.votesAgainst + votingResults.votesAbstain);
    if (total === 0) {
      return {
        total: 0,
        forPercentage: 0,
        againstPercentage: 0,
        abstainPercentage: 0,
        passed: false
      };
    }
    const forPercentage = Number(votingResults.votesFor) / total * 100;
    const againstPercentage = Number(votingResults.votesAgainst) / total * 100;
    const abstainPercentage = Number(votingResults.votesAbstain) / total * 100;
    const passed = votingResults.votesFor > votingResults.votesAgainst;
    return {
      total,
      forPercentage,
      againstPercentage,
      abstainPercentage,
      passed
    };
  }
  static validateProposal(proposal) {
    if (!proposal.title || proposal.title.trim().length === 0) {
      return { valid: false, error: "Title is required" };
    }
    if (proposal.title.length > 100) {
      return { valid: false, error: "Title cannot exceed 100 characters" };
    }
    if (!proposal.description || proposal.description.trim().length === 0) {
      return { valid: false, error: "Description is required" };
    }
    if (proposal.description.length > 5000) {
      return { valid: false, error: "Description cannot exceed 5000 characters" };
    }
    return { valid: true };
  }
}, VotingUtils = class {
  static calculateVoteWeight(baseWeight, tokenBalance, stakeDuration) {
    let weight = baseWeight;
    if (tokenBalance) {
      const tokenMultiplier = Math.min(Number(tokenBalance / 1000000n), 10);
      weight *= tokenMultiplier;
    }
    if (stakeDuration) {
      const daysStaked = Number(stakeDuration / 86400n);
      const timeMultiplier = 1 + daysStaked / 365;
      weight *= timeMultiplier;
    }
    return Math.floor(weight);
  }
  static formatVoteChoice(voteChoice) {
    switch (voteChoice) {
      case 0:
        return "âœ… For";
      case 1:
        return "âŒ Against";
      case 2:
        return "\uD83E\uDD37 Abstain";
      default:
        return "Unknown";
    }
  }
  static hasSimpleMajority(votingResults) {
    return votingResults.votesFor > votingResults.votesAgainst;
  }
  static hasSupermajority(votingResults) {
    const totalVotes = votingResults.votesFor + votingResults.votesAgainst;
    if (totalVotes === 0n)
      return false;
    const forPercentage = Number(votingResults.votesFor) / Number(totalVotes);
    return forPercentage >= 0.667;
  }
}, PERMISSION_TEMPLATES, ROLE_TEMPLATES, GovernanceAnalyticsUtils = class {
  static calculateHealthScore(analytics) {
    let score = 0;
    score += Math.min(analytics.averageVoterTurnout * 0.4, 40);
    const totalCompleted = analytics.passedProposals + analytics.failedProposals;
    if (totalCompleted > 0) {
      const successRate = analytics.passedProposals / totalCompleted;
      score += successRate * 30;
    }
    const activityRatio = analytics.activeProposals / Math.max(analytics.totalProposals, 1);
    score += Math.min(activityRatio * 60, 30);
    return Math.round(score);
  }
  static generateSummaryReport(analytics) {
    const healthScore = this.calculateHealthScore(analytics);
    const successRate = analytics.totalProposals > 0 ? Math.round(analytics.passedProposals / analytics.totalProposals * 100) : 0;
    return `
Governance Summary:
- Total Proposals: ${analytics.totalProposals}
- Active: ${analytics.activeProposals}
- Success Rate: ${successRate}%
- Avg Turnout: ${Math.round(analytics.averageVoterTurnout)}%
- Health Score: ${healthScore}/100
    `.trim();
  }
}, feature_flags_exports, DEFAULT_FLAGS, DEV_FLAGS, FeatureFlagManager = class {
  flags;
  overrides = {};
  constructor(environment = "production") {
    this.flags = environment === "development" ? { ...DEV_FLAGS } : { ...DEFAULT_FLAGS };
    this.loadOverridesFromEnv();
  }
  loadOverridesFromEnv() {
    if (typeof process !== "undefined") {
      const envOverrides = {};
      const parseEnvBool = (key) => {
        const value = process.env[key];
        if (value === undefined)
          return;
        return value.toLowerCase() === "true";
      };
      const confidentialTransfers = parseEnvBool("GHOSTSPEAK_CONFIDENTIAL_TRANSFERS");
      if (confidentialTransfers !== undefined) {
        envOverrides.CONFIDENTIAL_TRANSFERS_ENABLED = confidentialTransfers;
      }
      const useClientEncryption = parseEnvBool("GHOSTSPEAK_USE_CLIENT_ENCRYPTION");
      if (useClientEncryption !== undefined) {
        envOverrides.USE_CLIENT_ENCRYPTION = useClientEncryption;
      }
      this.overrides = envOverrides;
    }
  }
  getFlags() {
    return { ...this.flags, ...this.overrides };
  }
  isEnabled(feature) {
    const flags = this.getFlags();
    return flags[feature];
  }
  setFlag(feature, enabled) {
    this.overrides[feature] = enabled;
  }
  resetOverrides() {
    this.overrides = {};
    this.loadOverridesFromEnv();
  }
  getPrivacyStatus() {
    const flags = this.getFlags();
    if (!flags.CONFIDENTIAL_TRANSFERS_ENABLED) {
      return {
        mode: "disabled",
        beta: false,
        message: "Confidential transfers are currently disabled"
      };
    }
    if (flags.USE_CLIENT_ENCRYPTION) {
      return {
        mode: "client-encryption",
        beta: false,
        message: "Confidential transfers using client-side encryption (Production)"
      };
    }
    return {
      mode: "disabled",
      beta: false,
      message: "No privacy features enabled"
    };
  }
  shouldUseClientEncryption() {
    const flags = this.getFlags();
    return flags.CONFIDENTIAL_TRANSFERS_ENABLED && flags.USE_CLIENT_ENCRYPTION;
  }
}, globalFeatureFlags = null, client_encryption_exports, MAX_DECRYPTABLE_VALUE = 4294967295n, G2, hash = (data) => sha2562(data), ClientEncryptionService = class {
  keypair;
  featureFlags = getFeatureFlags();
  constructor(options2 = {}) {
    this.keypair = options2.encryptionKeypair ?? generateElGamalKeypair();
  }
  async encryptAmountForRecipient(amount, recipientPubkey) {
    if (!this.featureFlags.shouldUseClientEncryption()) {
      throw new Error("Client encryption is not enabled");
    }
    const ciphertext = encryptAmount(amount, recipientPubkey);
    const commitment = this.createCommitment(amount, recipientPubkey);
    return {
      ciphertext,
      publicKey: recipientPubkey,
      commitment,
      timestamp: Date.now(),
      version: 1
    };
  }
  async decryptAmount(encrypted, secretKey) {
    const isValid = await this.verifyCommitment(encrypted);
    if (!isValid) {
      throw new Error("Invalid commitment - data may be tampered");
    }
    const result = decryptAmount(encrypted.ciphertext, secretKey);
    if (result === null) {
      throw new Error("Failed to decrypt amount");
    }
    return result;
  }
  async encryptData(data, recipientPubkey) {
    const chunks = [];
    const chunkSize = 31;
    for (let i = 0;i < data.length; i += chunkSize) {
      const chunk = data.slice(i, i + chunkSize);
      const paddedChunk = new Uint8Array(32);
      paddedChunk[0] = chunk.length;
      paddedChunk.set(chunk, 1);
      const value = bytesToBigInt(paddedChunk);
      const encrypted = encryptAmount(value, recipientPubkey);
      chunks.push(encrypted);
    }
    const combined = this.combineChunks(chunks);
    const commitment = this.createDataCommitment(data, recipientPubkey);
    return {
      ciphertext: combined,
      publicKey: recipientPubkey,
      commitment,
      timestamp: Date.now(),
      version: 1
    };
  }
  async createPrivateMetadata(privateData, publicData, recipientPubkey) {
    const serialized = JSON.stringify(privateData);
    const dataBytes = new TextEncoder().encode(serialized);
    const encrypted = await this.encryptData(dataBytes, recipientPubkey);
    const storageHash = this.createStorageHash(encrypted, publicData);
    return {
      encrypted,
      public: publicData,
      storageHash
    };
  }
  async verifyCommitment(encrypted) {
    return encrypted.commitment.length === 32 && encrypted.version === 1 && encrypted.timestamp > 0;
  }
  createCommitment(amount, pubkey) {
    const data = new Uint8Array(40);
    data.set(bigIntToBytes(amount), 0);
    data.set(pubkey, 8);
    return sha2562(data);
  }
  createDataCommitment(data, pubkey) {
    const combined = new Uint8Array(data.length + 32);
    combined.set(data, 0);
    combined.set(pubkey, data.length);
    return sha2562(combined);
  }
  createStorageHash(encrypted, publicData) {
    const data = {
      encryptedCommitment: bytesToHex2(encrypted.commitment),
      publicData,
      timestamp: encrypted.timestamp,
      version: encrypted.version
    };
    const serialized = JSON.stringify(data);
    return sha2562(new TextEncoder().encode(serialized));
  }
  combineChunks(chunks) {
    if (chunks.length === 0) {
      throw new Error("No chunks to combine");
    }
    return chunks[0];
  }
};
var init_chunk_5TBUKTT3 = __esm(() => {
  init_chunk_CO2WD4XR();
  init_chunk_5QZVFUXB();
  init_chunk_Z6ZWNWWR();
  init_index_node40();
  init_sha256();
  init_utils3();
  init_ed25519();
  account_diagnostics_exports = {};
  __export2(account_diagnostics_exports, {
    diagnoseAccountFromChain: () => diagnoseAccountFromChain,
    diagnoseBatchFromChain: () => diagnoseBatchFromChain,
    exportDiagnosticReport: () => exportDiagnosticReport,
    runAccountDiagnostics: () => runAccountDiagnostics,
    runBatchDiagnostics: () => runBatchDiagnostics
  });
  TokenProgram = /* @__PURE__ */ ((TokenProgram2) => {
    TokenProgram2["SPL_TOKEN"] = "spl-token";
    TokenProgram2["TOKEN_2022"] = "token-2022";
    return TokenProgram2;
  })(TokenProgram || {});
  TokenExtension = /* @__PURE__ */ ((TokenExtension2) => {
    TokenExtension2[TokenExtension2["UNINITIALIZED"] = 0] = "UNINITIALIZED";
    TokenExtension2[TokenExtension2["TRANSFER_FEE_CONFIG"] = 1] = "TRANSFER_FEE_CONFIG";
    TokenExtension2[TokenExtension2["TRANSFER_FEE_AMOUNT"] = 2] = "TRANSFER_FEE_AMOUNT";
    TokenExtension2[TokenExtension2["MINT_CLOSE_AUTHORITY"] = 3] = "MINT_CLOSE_AUTHORITY";
    TokenExtension2[TokenExtension2["CONFIDENTIAL_TRANSFER_MINT"] = 4] = "CONFIDENTIAL_TRANSFER_MINT";
    TokenExtension2[TokenExtension2["CONFIDENTIAL_TRANSFER_ACCOUNT"] = 5] = "CONFIDENTIAL_TRANSFER_ACCOUNT";
    TokenExtension2[TokenExtension2["DEFAULT_ACCOUNT_STATE"] = 6] = "DEFAULT_ACCOUNT_STATE";
    TokenExtension2[TokenExtension2["IMMUTABLE_OWNER"] = 7] = "IMMUTABLE_OWNER";
    TokenExtension2[TokenExtension2["MEMO_TRANSFER"] = 8] = "MEMO_TRANSFER";
    TokenExtension2[TokenExtension2["NON_TRANSFERABLE"] = 9] = "NON_TRANSFERABLE";
    TokenExtension2[TokenExtension2["INTEREST_BEARING_MINT"] = 10] = "INTEREST_BEARING_MINT";
    TokenExtension2[TokenExtension2["CPI_GUARD"] = 11] = "CPI_GUARD";
    TokenExtension2[TokenExtension2["PERMANENT_DELEGATE"] = 12] = "PERMANENT_DELEGATE";
    TokenExtension2[TokenExtension2["NON_TRANSFERABLE_ACCOUNT"] = 13] = "NON_TRANSFERABLE_ACCOUNT";
    TokenExtension2[TokenExtension2["TRANSFER_HOOK"] = 14] = "TRANSFER_HOOK";
    TokenExtension2[TokenExtension2["TRANSFER_HOOK_ACCOUNT"] = 15] = "TRANSFER_HOOK_ACCOUNT";
    TokenExtension2[TokenExtension2["METADATA_POINTER"] = 16] = "METADATA_POINTER";
    TokenExtension2[TokenExtension2["TOKEN_METADATA"] = 17] = "TOKEN_METADATA";
    TokenExtension2[TokenExtension2["GROUP_POINTER"] = 18] = "GROUP_POINTER";
    TokenExtension2[TokenExtension2["TOKEN_GROUP"] = 19] = "TOKEN_GROUP";
    TokenExtension2[TokenExtension2["GROUP_MEMBER_POINTER"] = 20] = "GROUP_MEMBER_POINTER";
    TokenExtension2[TokenExtension2["TOKEN_GROUP_MEMBER"] = 21] = "TOKEN_GROUP_MEMBER";
    return TokenExtension2;
  })(TokenExtension || {});
  governance_helpers_exports = {};
  __export2(governance_helpers_exports, {
    GovernanceAnalyticsUtils: () => GovernanceAnalyticsUtils,
    PERMISSION_TEMPLATES: () => PERMISSION_TEMPLATES,
    ProposalUtils: () => ProposalUtils,
    ROLE_TEMPLATES: () => ROLE_TEMPLATES,
    VotingUtils: () => VotingUtils,
    deriveMultisigPda: () => deriveMultisigPda,
    deriveProposalPda: () => deriveProposalPda,
    deriveRbacPda: () => deriveRbacPda
  });
  PERMISSION_TEMPLATES = {
    ADMIN: {
      CREATE_PROPOSAL: { action: "create", resource: "proposal" },
      EXECUTE_PROPOSAL: { action: "execute", resource: "proposal" },
      MANAGE_ROLES: { action: "manage", resource: "roles" },
      MANAGE_TREASURY: { action: "manage", resource: "treasury" }
    },
    MEMBER: {
      VOTE: { action: "vote", resource: "proposal" },
      VIEW: { action: "view", resource: "all" },
      COMMENT: { action: "comment", resource: "proposal" }
    },
    MODERATOR: {
      CANCEL_PROPOSAL: { action: "cancel", resource: "proposal" },
      MODERATE_COMMENTS: { action: "moderate", resource: "comments" },
      VIEW_REPORTS: { action: "view", resource: "reports" }
    }
  };
  ROLE_TEMPLATES = {
    ADMIN: {
      name: "Administrator",
      description: "Full administrative access",
      permissions: Object.values(PERMISSION_TEMPLATES.ADMIN)
    },
    MEMBER: {
      name: "Member",
      description: "Standard member access",
      permissions: Object.values(PERMISSION_TEMPLATES.MEMBER)
    },
    MODERATOR: {
      name: "Moderator",
      description: "Content moderation access",
      permissions: [
        ...Object.values(PERMISSION_TEMPLATES.MEMBER),
        ...Object.values(PERMISSION_TEMPLATES.MODERATOR)
      ]
    }
  };
  feature_flags_exports = {};
  __export2(feature_flags_exports, {
    DEFAULT_FLAGS: () => DEFAULT_FLAGS,
    DEV_FLAGS: () => DEV_FLAGS,
    FeatureFlagManager: () => FeatureFlagManager,
    getFeatureFlags: () => getFeatureFlags,
    getPrivacyStatus: () => getPrivacyStatus,
    isFeatureEnabled: () => isFeatureEnabled
  });
  DEFAULT_FLAGS = {
    CONFIDENTIAL_TRANSFERS_ENABLED: true,
    USE_CLIENT_ENCRYPTION: true,
    ENABLE_IPFS_STORAGE: true,
    ENABLE_COMPRESSED_AGENTS: true,
    ENABLE_GOVERNANCE: true,
    ENABLE_ANALYTICS: true,
    SHOW_EXPERIMENTAL_FEATURES: false
  };
  DEV_FLAGS = {
    CONFIDENTIAL_TRANSFERS_ENABLED: true,
    USE_CLIENT_ENCRYPTION: true,
    ENABLE_IPFS_STORAGE: true,
    ENABLE_COMPRESSED_AGENTS: true,
    ENABLE_GOVERNANCE: true,
    ENABLE_ANALYTICS: true,
    SHOW_EXPERIMENTAL_FEATURES: true
  };
  client_encryption_exports = {};
  __export2(client_encryption_exports, {
    ClientEncryptionService: () => ClientEncryptionService,
    generateElGamalKeypair: () => generateElGamalKeypair,
    generateLocalPrivacyProof: () => generateLocalPrivacyProof,
    verifyLocalPrivacyProof: () => verifyLocalPrivacyProof
  });
  G2 = ed25519.ExtendedPoint.BASE;
  getGeneratorH();
});

// ../sdk-typescript/dist/chunk-SRS2SKFS.js
function isSuccess(result) {
  return result.success === true;
}
function isError(result) {
  return result.success === false;
}
function unwrap(result) {
  if (isError(result)) {
    throw new Error(result.error.message);
  }
  return result.data;
}
var AgentType, EscrowStatus2, ChannelType, MessageType, ErrorCode, ParticipantType;
var init_chunk_SRS2SKFS = __esm(() => {
  AgentType = /* @__PURE__ */ ((AgentType2) => {
    AgentType2[AgentType2["General"] = 0] = "General";
    AgentType2[AgentType2["Specialized"] = 1] = "Specialized";
    AgentType2[AgentType2["Oracle"] = 2] = "Oracle";
    AgentType2[AgentType2["Validator"] = 3] = "Validator";
    return AgentType2;
  })(AgentType || {});
  EscrowStatus2 = /* @__PURE__ */ ((EscrowStatus22) => {
    EscrowStatus22["Active"] = "active";
    EscrowStatus22["Completed"] = "completed";
    EscrowStatus22["Cancelled"] = "cancelled";
    EscrowStatus22["Disputed"] = "disputed";
    EscrowStatus22["Refunded"] = "refunded";
    return EscrowStatus22;
  })(EscrowStatus2 || {});
  ChannelType = /* @__PURE__ */ ((ChannelType2) => {
    ChannelType2["Public"] = "public";
    ChannelType2["Private"] = "private";
    ChannelType2["Direct"] = "direct";
    ChannelType2["Group"] = "group";
    return ChannelType2;
  })(ChannelType || {});
  MessageType = /* @__PURE__ */ ((MessageType2) => {
    MessageType2["Text"] = "text";
    MessageType2["Image"] = "image";
    MessageType2["File"] = "file";
    MessageType2["Code"] = "code";
    MessageType2["System"] = "system";
    return MessageType2;
  })(MessageType || {});
  ErrorCode = /* @__PURE__ */ ((ErrorCode2) => {
    ErrorCode2["NETWORK_ERROR"] = "NETWORK_ERROR";
    ErrorCode2["RPC_ERROR"] = "RPC_ERROR";
    ErrorCode2["TIMEOUT"] = "TIMEOUT";
    ErrorCode2["INSUFFICIENT_BALANCE"] = "INSUFFICIENT_BALANCE";
    ErrorCode2["TRANSACTION_FAILED"] = "TRANSACTION_FAILED";
    ErrorCode2["SIMULATION_FAILED"] = "SIMULATION_FAILED";
    ErrorCode2["ACCOUNT_NOT_FOUND"] = "ACCOUNT_NOT_FOUND";
    ErrorCode2["INVALID_ACCOUNT"] = "INVALID_ACCOUNT";
    ErrorCode2["UNAUTHORIZED"] = "UNAUTHORIZED";
    ErrorCode2["INVALID_INPUT"] = "INVALID_INPUT";
    ErrorCode2["INVALID_ADDRESS"] = "INVALID_ADDRESS";
    ErrorCode2["INVALID_AMOUNT"] = "INVALID_AMOUNT";
    ErrorCode2["PROGRAM_ERROR"] = "PROGRAM_ERROR";
    ErrorCode2["INSTRUCTION_ERROR"] = "INSTRUCTION_ERROR";
    ErrorCode2["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
    return ErrorCode2;
  })(ErrorCode || {});
  ParticipantType = /* @__PURE__ */ ((ParticipantType2) => {
    ParticipantType2["Human"] = "Human";
    ParticipantType2["Agent"] = "Agent";
    return ParticipantType2;
  })(ParticipantType || {});
});

// ../../node_modules/.bun/@solana-program+system@0.10.0+82d46aa0fff2e984/node_modules/@solana-program/system/dist/src/index.mjs
function expectAddress2(value) {
  if (!value) {
    throw new Error("Expected a Address.");
  }
  if (typeof value === "object" && "address" in value) {
    return value.address;
  }
  if (Array.isArray(value)) {
    return value[0];
  }
  return value;
}
function getAccountMetaFactory2(programAddress, optionalAccountStrategy) {
  return (account) => {
    if (!account.value) {
      return;
    }
    const writableRole = account.isWritable ? AccountRole.WRITABLE : AccountRole.READONLY;
    return Object.freeze({
      address: expectAddress2(account.value),
      role: isTransactionSigner3(account.value) ? upgradeRoleToSigner(writableRole) : writableRole,
      ...isTransactionSigner3(account.value) ? { signer: account.value } : {}
    });
  };
}
function isTransactionSigner3(value) {
  return !!value && typeof value === "object" && "address" in value && isTransactionSigner(value);
}
function getTransferSolInstructionDataEncoder() {
  return transformEncoder2(getStructEncoder([
    ["discriminator", getU32Encoder()],
    ["amount", getU64Encoder()]
  ]), (value) => ({ ...value, discriminator: TRANSFER_SOL_DISCRIMINATOR }));
}
function getTransferSolInstruction(input, config) {
  const programAddress = config?.programAddress ?? SYSTEM_PROGRAM_ADDRESS4;
  const originalAccounts = {
    source: { value: input.source ?? null, isWritable: true },
    destination: { value: input.destination ?? null, isWritable: true }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory2();
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.source),
      getAccountMeta(accounts2.destination)
    ],
    data: getTransferSolInstructionDataEncoder().encode(args),
    programAddress
  });
}
var SYSTEM_PROGRAM_ADDRESS4 = "11111111111111111111111111111111", SYSTEM_ERROR__ACCOUNT_ALREADY_IN_USE = 0, SYSTEM_ERROR__RESULT_WITH_NEGATIVE_LAMPORTS = 1, SYSTEM_ERROR__INVALID_PROGRAM_ID = 2, SYSTEM_ERROR__INVALID_ACCOUNT_DATA_LENGTH = 3, SYSTEM_ERROR__MAX_SEED_LENGTH_EXCEEDED = 4, SYSTEM_ERROR__ADDRESS_WITH_SEED_MISMATCH = 5, SYSTEM_ERROR__NONCE_NO_RECENT_BLOCKHASHES = 6, SYSTEM_ERROR__NONCE_BLOCKHASH_NOT_EXPIRED = 7, SYSTEM_ERROR__NONCE_UNEXPECTED_BLOCKHASH_VALUE = 8, systemErrorMessages, TRANSFER_SOL_DISCRIMINATOR = 2;
var init_src = __esm(() => {
  init_index_node40();
  if (true) {
    systemErrorMessages = {
      [SYSTEM_ERROR__ACCOUNT_ALREADY_IN_USE]: `an account with the same address already exists`,
      [SYSTEM_ERROR__ADDRESS_WITH_SEED_MISMATCH]: `provided address does not match addressed derived from seed`,
      [SYSTEM_ERROR__INVALID_ACCOUNT_DATA_LENGTH]: `cannot allocate account data of this length`,
      [SYSTEM_ERROR__INVALID_PROGRAM_ID]: `cannot assign account to this program id`,
      [SYSTEM_ERROR__MAX_SEED_LENGTH_EXCEEDED]: `length of requested seed is too long`,
      [SYSTEM_ERROR__NONCE_BLOCKHASH_NOT_EXPIRED]: `stored nonce is still in recent_blockhashes`,
      [SYSTEM_ERROR__NONCE_NO_RECENT_BLOCKHASHES]: `advancing stored nonce requires a populated RecentBlockhashes sysvar`,
      [SYSTEM_ERROR__NONCE_UNEXPECTED_BLOCKHASH_VALUE]: `specified nonce does not match stored nonce`,
      [SYSTEM_ERROR__RESULT_WITH_NEGATIVE_LAMPORTS]: `account does not have enough SOL to perform the operation`
    };
  }
});

// ../../node_modules/.bun/chalk@5.6.2/node_modules/chalk/source/vendor/ansi-styles/index.js
function assembleStyles() {
  const codes = new Map;
  for (const [groupName, group] of Object.entries(styles)) {
    for (const [styleName, style] of Object.entries(group)) {
      styles[styleName] = {
        open: `\x1B[${style[0]}m`,
        close: `\x1B[${style[1]}m`
      };
      group[styleName] = styles[styleName];
      codes.set(style[0], style[1]);
    }
    Object.defineProperty(styles, groupName, {
      value: group,
      enumerable: false
    });
  }
  Object.defineProperty(styles, "codes", {
    value: codes,
    enumerable: false
  });
  styles.color.close = "\x1B[39m";
  styles.bgColor.close = "\x1B[49m";
  styles.color.ansi = wrapAnsi16();
  styles.color.ansi256 = wrapAnsi256();
  styles.color.ansi16m = wrapAnsi16m();
  styles.bgColor.ansi = wrapAnsi16(ANSI_BACKGROUND_OFFSET);
  styles.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
  styles.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);
  Object.defineProperties(styles, {
    rgbToAnsi256: {
      value(red, green, blue) {
        if (red === green && green === blue) {
          if (red < 8) {
            return 16;
          }
          if (red > 248) {
            return 231;
          }
          return Math.round((red - 8) / 247 * 24) + 232;
        }
        return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5);
      },
      enumerable: false
    },
    hexToRgb: {
      value(hex) {
        const matches = /[a-f\d]{6}|[a-f\d]{3}/i.exec(hex.toString(16));
        if (!matches) {
          return [0, 0, 0];
        }
        let [colorString] = matches;
        if (colorString.length === 3) {
          colorString = [...colorString].map((character) => character + character).join("");
        }
        const integer = Number.parseInt(colorString, 16);
        return [
          integer >> 16 & 255,
          integer >> 8 & 255,
          integer & 255
        ];
      },
      enumerable: false
    },
    hexToAnsi256: {
      value: (hex) => styles.rgbToAnsi256(...styles.hexToRgb(hex)),
      enumerable: false
    },
    ansi256ToAnsi: {
      value(code) {
        if (code < 8) {
          return 30 + code;
        }
        if (code < 16) {
          return 90 + (code - 8);
        }
        let red;
        let green;
        let blue;
        if (code >= 232) {
          red = ((code - 232) * 10 + 8) / 255;
          green = red;
          blue = red;
        } else {
          code -= 16;
          const remainder = code % 36;
          red = Math.floor(code / 36) / 5;
          green = Math.floor(remainder / 6) / 5;
          blue = remainder % 6 / 5;
        }
        const value = Math.max(red, green, blue) * 2;
        if (value === 0) {
          return 30;
        }
        let result = 30 + (Math.round(blue) << 2 | Math.round(green) << 1 | Math.round(red));
        if (value === 2) {
          result += 60;
        }
        return result;
      },
      enumerable: false
    },
    rgbToAnsi: {
      value: (red, green, blue) => styles.ansi256ToAnsi(styles.rgbToAnsi256(red, green, blue)),
      enumerable: false
    },
    hexToAnsi: {
      value: (hex) => styles.ansi256ToAnsi(styles.hexToAnsi256(hex)),
      enumerable: false
    }
  });
  return styles;
}
var ANSI_BACKGROUND_OFFSET = 10, wrapAnsi16 = (offset = 0) => (code) => `\x1B[${code + offset}m`, wrapAnsi256 = (offset = 0) => (code) => `\x1B[${38 + offset};5;${code}m`, wrapAnsi16m = (offset = 0) => (red, green, blue) => `\x1B[${38 + offset};2;${red};${green};${blue}m`, styles, modifierNames, foregroundColorNames, backgroundColorNames, colorNames, ansiStyles, ansi_styles_default;
var init_ansi_styles = __esm(() => {
  styles = {
    modifier: {
      reset: [0, 0],
      bold: [1, 22],
      dim: [2, 22],
      italic: [3, 23],
      underline: [4, 24],
      overline: [53, 55],
      inverse: [7, 27],
      hidden: [8, 28],
      strikethrough: [9, 29]
    },
    color: {
      black: [30, 39],
      red: [31, 39],
      green: [32, 39],
      yellow: [33, 39],
      blue: [34, 39],
      magenta: [35, 39],
      cyan: [36, 39],
      white: [37, 39],
      blackBright: [90, 39],
      gray: [90, 39],
      grey: [90, 39],
      redBright: [91, 39],
      greenBright: [92, 39],
      yellowBright: [93, 39],
      blueBright: [94, 39],
      magentaBright: [95, 39],
      cyanBright: [96, 39],
      whiteBright: [97, 39]
    },
    bgColor: {
      bgBlack: [40, 49],
      bgRed: [41, 49],
      bgGreen: [42, 49],
      bgYellow: [43, 49],
      bgBlue: [44, 49],
      bgMagenta: [45, 49],
      bgCyan: [46, 49],
      bgWhite: [47, 49],
      bgBlackBright: [100, 49],
      bgGray: [100, 49],
      bgGrey: [100, 49],
      bgRedBright: [101, 49],
      bgGreenBright: [102, 49],
      bgYellowBright: [103, 49],
      bgBlueBright: [104, 49],
      bgMagentaBright: [105, 49],
      bgCyanBright: [106, 49],
      bgWhiteBright: [107, 49]
    }
  };
  modifierNames = Object.keys(styles.modifier);
  foregroundColorNames = Object.keys(styles.color);
  backgroundColorNames = Object.keys(styles.bgColor);
  colorNames = [...foregroundColorNames, ...backgroundColorNames];
  ansiStyles = assembleStyles();
  ansi_styles_default = ansiStyles;
});

// ../../node_modules/.bun/chalk@5.6.2/node_modules/chalk/source/vendor/supports-color/index.js
import process2 from "node:process";
import os from "node:os";
import tty from "node:tty";
function hasFlag(flag, argv = globalThis.Deno ? globalThis.Deno.args : process2.argv) {
  const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
  const position = argv.indexOf(prefix + flag);
  const terminatorPosition = argv.indexOf("--");
  return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
}
function envForceColor() {
  if ("FORCE_COLOR" in env) {
    if (env.FORCE_COLOR === "true") {
      return 1;
    }
    if (env.FORCE_COLOR === "false") {
      return 0;
    }
    return env.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(env.FORCE_COLOR, 10), 3);
  }
}
function translateLevel(level) {
  if (level === 0) {
    return false;
  }
  return {
    level,
    hasBasic: true,
    has256: level >= 2,
    has16m: level >= 3
  };
}
function _supportsColor(haveStream, { streamIsTTY, sniffFlags = true } = {}) {
  const noFlagForceColor = envForceColor();
  if (noFlagForceColor !== undefined) {
    flagForceColor = noFlagForceColor;
  }
  const forceColor = sniffFlags ? flagForceColor : noFlagForceColor;
  if (forceColor === 0) {
    return 0;
  }
  if (sniffFlags) {
    if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
      return 3;
    }
    if (hasFlag("color=256")) {
      return 2;
    }
  }
  if ("TF_BUILD" in env && "AGENT_NAME" in env) {
    return 1;
  }
  if (haveStream && !streamIsTTY && forceColor === undefined) {
    return 0;
  }
  const min = forceColor || 0;
  if (env.TERM === "dumb") {
    return min;
  }
  if (process2.platform === "win32") {
    const osRelease = os.release().split(".");
    if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
      return Number(osRelease[2]) >= 14931 ? 3 : 2;
    }
    return 1;
  }
  if ("CI" in env) {
    if (["GITHUB_ACTIONS", "GITEA_ACTIONS", "CIRCLECI"].some((key) => (key in env))) {
      return 3;
    }
    if (["TRAVIS", "APPVEYOR", "GITLAB_CI", "BUILDKITE", "DRONE"].some((sign) => (sign in env)) || env.CI_NAME === "codeship") {
      return 1;
    }
    return min;
  }
  if ("TEAMCITY_VERSION" in env) {
    return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
  }
  if (env.COLORTERM === "truecolor") {
    return 3;
  }
  if (env.TERM === "xterm-kitty") {
    return 3;
  }
  if (env.TERM === "xterm-ghostty") {
    return 3;
  }
  if (env.TERM === "wezterm") {
    return 3;
  }
  if ("TERM_PROGRAM" in env) {
    const version = Number.parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
    switch (env.TERM_PROGRAM) {
      case "iTerm.app": {
        return version >= 3 ? 3 : 2;
      }
      case "Apple_Terminal": {
        return 2;
      }
    }
  }
  if (/-256(color)?$/i.test(env.TERM)) {
    return 2;
  }
  if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
    return 1;
  }
  if ("COLORTERM" in env) {
    return 1;
  }
  return min;
}
function createSupportsColor(stream, options2 = {}) {
  const level = _supportsColor(stream, {
    streamIsTTY: stream && stream.isTTY,
    ...options2
  });
  return translateLevel(level);
}
var env, flagForceColor, supportsColor, supports_color_default;
var init_supports_color = __esm(() => {
  ({ env } = process2);
  if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
    flagForceColor = 0;
  } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
    flagForceColor = 1;
  }
  supportsColor = {
    stdout: createSupportsColor({ isTTY: tty.isatty(1) }),
    stderr: createSupportsColor({ isTTY: tty.isatty(2) })
  };
  supports_color_default = supportsColor;
});

// ../../node_modules/.bun/chalk@5.6.2/node_modules/chalk/source/utilities.js
function stringReplaceAll(string, substring, replacer) {
  let index = string.indexOf(substring);
  if (index === -1) {
    return string;
  }
  const substringLength = substring.length;
  let endIndex = 0;
  let returnValue = "";
  do {
    returnValue += string.slice(endIndex, index) + substring + replacer;
    endIndex = index + substringLength;
    index = string.indexOf(substring, endIndex);
  } while (index !== -1);
  returnValue += string.slice(endIndex);
  return returnValue;
}
function stringEncaseCRLFWithFirstIndex(string, prefix, postfix, index) {
  let endIndex = 0;
  let returnValue = "";
  do {
    const gotCR = string[index - 1] === "\r";
    returnValue += string.slice(endIndex, gotCR ? index - 1 : index) + prefix + (gotCR ? `\r
` : `
`) + postfix;
    endIndex = index + 1;
    index = string.indexOf(`
`, endIndex);
  } while (index !== -1);
  returnValue += string.slice(endIndex);
  return returnValue;
}

// ../../node_modules/.bun/chalk@5.6.2/node_modules/chalk/source/index.js
function createChalk(options2) {
  return chalkFactory(options2);
}
var stdoutColor, stderrColor, GENERATOR, STYLER, IS_EMPTY, levelMapping, styles2, applyOptions = (object, options2 = {}) => {
  if (options2.level && !(Number.isInteger(options2.level) && options2.level >= 0 && options2.level <= 3)) {
    throw new Error("The `level` option should be an integer from 0 to 3");
  }
  const colorLevel = stdoutColor ? stdoutColor.level : 0;
  object.level = options2.level === undefined ? colorLevel : options2.level;
}, chalkFactory = (options2) => {
  const chalk = (...strings) => strings.join(" ");
  applyOptions(chalk, options2);
  Object.setPrototypeOf(chalk, createChalk.prototype);
  return chalk;
}, getModelAnsi = (model, level, type, ...arguments_) => {
  if (model === "rgb") {
    if (level === "ansi16m") {
      return ansi_styles_default[type].ansi16m(...arguments_);
    }
    if (level === "ansi256") {
      return ansi_styles_default[type].ansi256(ansi_styles_default.rgbToAnsi256(...arguments_));
    }
    return ansi_styles_default[type].ansi(ansi_styles_default.rgbToAnsi(...arguments_));
  }
  if (model === "hex") {
    return getModelAnsi("rgb", level, type, ...ansi_styles_default.hexToRgb(...arguments_));
  }
  return ansi_styles_default[type][model](...arguments_);
}, usedModels, proto, createStyler = (open, close, parent) => {
  let openAll;
  let closeAll;
  if (parent === undefined) {
    openAll = open;
    closeAll = close;
  } else {
    openAll = parent.openAll + open;
    closeAll = close + parent.closeAll;
  }
  return {
    open,
    close,
    openAll,
    closeAll,
    parent
  };
}, createBuilder = (self2, _styler, _isEmpty) => {
  const builder = (...arguments_) => applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
  Object.setPrototypeOf(builder, proto);
  builder[GENERATOR] = self2;
  builder[STYLER] = _styler;
  builder[IS_EMPTY] = _isEmpty;
  return builder;
}, applyStyle = (self2, string) => {
  if (self2.level <= 0 || !string) {
    return self2[IS_EMPTY] ? "" : string;
  }
  let styler = self2[STYLER];
  if (styler === undefined) {
    return string;
  }
  const { openAll, closeAll } = styler;
  if (string.includes("\x1B")) {
    while (styler !== undefined) {
      string = stringReplaceAll(string, styler.close, styler.open);
      styler = styler.parent;
    }
  }
  const lfIndex = string.indexOf(`
`);
  if (lfIndex !== -1) {
    string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
  }
  return openAll + string + closeAll;
}, chalk, chalkStderr, source_default;
var init_source = __esm(() => {
  init_ansi_styles();
  init_supports_color();
  ({ stdout: stdoutColor, stderr: stderrColor } = supports_color_default);
  GENERATOR = Symbol("GENERATOR");
  STYLER = Symbol("STYLER");
  IS_EMPTY = Symbol("IS_EMPTY");
  levelMapping = [
    "ansi",
    "ansi",
    "ansi256",
    "ansi16m"
  ];
  styles2 = Object.create(null);
  Object.setPrototypeOf(createChalk.prototype, Function.prototype);
  for (const [styleName, style] of Object.entries(ansi_styles_default)) {
    styles2[styleName] = {
      get() {
        const builder = createBuilder(this, createStyler(style.open, style.close, this[STYLER]), this[IS_EMPTY]);
        Object.defineProperty(this, styleName, { value: builder });
        return builder;
      }
    };
  }
  styles2.visible = {
    get() {
      const builder = createBuilder(this, this[STYLER], true);
      Object.defineProperty(this, "visible", { value: builder });
      return builder;
    }
  };
  usedModels = ["rgb", "hex", "ansi256"];
  for (const model of usedModels) {
    styles2[model] = {
      get() {
        const { level } = this;
        return function(...arguments_) {
          const styler = createStyler(getModelAnsi(model, levelMapping[level], "color", ...arguments_), ansi_styles_default.color.close, this[STYLER]);
          return createBuilder(this, styler, this[IS_EMPTY]);
        };
      }
    };
    const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
    styles2[bgModel] = {
      get() {
        const { level } = this;
        return function(...arguments_) {
          const styler = createStyler(getModelAnsi(model, levelMapping[level], "bgColor", ...arguments_), ansi_styles_default.bgColor.close, this[STYLER]);
          return createBuilder(this, styler, this[IS_EMPTY]);
        };
      }
    };
  }
  proto = Object.defineProperties(() => {}, {
    ...styles2,
    level: {
      enumerable: true,
      get() {
        return this[GENERATOR].level;
      },
      set(level) {
        this[GENERATOR].level = level;
      }
    }
  });
  Object.defineProperties(createChalk.prototype, styles2);
  chalk = createChalk();
  chalkStderr = createChalk({ level: stderrColor ? stderrColor.level : 0 });
  source_default = chalk;
});

// ../sdk-typescript/dist/index.js
var exports_dist = {};
__export(exports_dist, {
  withIPFSErrorHandling: () => withIPFSErrorHandling,
  withEnhancedErrorsSync: () => withEnhancedErrorsSync,
  withEnhancedErrors: () => withEnhancedErrors,
  wasmBridge: () => wasm_bridge_exports,
  verifyLocalPrivacyProof: () => verifyLocalPrivacyProof,
  verifyAuthorizationSignature: () => verifyAuthorizationSignature,
  validatePrivacySettings: () => validatePrivacySettings,
  validatePreconditions: () => validatePreconditions,
  validateInstructionAccounts: () => validateInstructionAccounts,
  validateDidString: () => validateDidString,
  validateAuthorizationNetwork: () => validateAuthorizationNetwork,
  validateAssociatedTokenAddress: () => validateAssociatedTokenAddress,
  validateAccountDiscriminator: () => validateAccountDiscriminator,
  unwrap: () => unwrap,
  sol: () => sol,
  simulateMigration: () => simulateMigration,
  signAuthorizationMessage: () => signAuthorizationMessage,
  serializeAuthorization: () => serializeAuthorization,
  safeDecodeAgent: () => safeDecodeAgent,
  runBatchDiagnostics: () => runBatchDiagnostics,
  runAccountDiagnostics: () => runAccountDiagnostics,
  parseTokenAmount: () => parseTokenAmount,
  parseDidString: () => parseDidString,
  logEnhancedError: () => logEnhancedError,
  loadWasmModule: () => loadWasmModule2,
  lamportsToSol: () => lamportsToSol2,
  isWasmAvailable: () => isWasmAvailable,
  isToken2022Mint: () => isToken2022Mint,
  isSuccess: () => isSuccess,
  isKnownInstruction: () => isKnownInstruction,
  isIPFSError: () => isIPFSError,
  isFeatureEnabled: () => isFeatureEnabled,
  isError: () => isError,
  isDidActive: () => isDidActive,
  isAuthorizationExpired: () => isAuthorizationExpired,
  isAuthorizationExhausted: () => isAuthorizationExhausted,
  inspectAccountData: () => inspectAccountData,
  hasTransferFeeExtension: () => hasTransferFeeExtension,
  hasInterestBearingExtension: () => hasInterestBearingExtension,
  hasConfidentialTransferExtension: () => hasConfidentialTransferExtension,
  getWritableAccounts: () => getWritableAccounts,
  getUpdateReputationTagsInstructionAsync: () => getUpdateReputationTagsInstructionAsync,
  getUpdateDidDocumentInstructionAsync: () => getUpdateDidDocumentInstructionAsync,
  getUnstakeGhostInstructionAsync: () => getUnstakeGhostInstructionAsync,
  getTransferFeeConfig: () => getTransferFeeConfig,
  getTokenProgramType: () => getTokenProgramType,
  getTokenProgramFromAddress: () => getTokenProgramFromAddress,
  getTokenProgramAddress: () => getTokenProgramAddress,
  getTierDisplayName: () => getTierDisplayName,
  getSubmitDeliveryInstruction: () => getSubmitDeliveryInstruction,
  getStakingConfigDecoder: () => getStakingConfigDecoder,
  getStakingAccountDecoder: () => getStakingAccountDecoder,
  getStakeGhostInstructionAsync: () => getStakeGhostInstructionAsync,
  getSlashStakeInstructionAsync: () => getSlashStakeInstructionAsync,
  getScoreRange: () => getScoreRange,
  getResolveDidDocumentInstructionAsync: () => getResolveDidDocumentInstructionAsync,
  getRequiredSigners: () => getRequiredSigners,
  getReputationTier: () => getReputationTier,
  getRegisterAgentInstructionAsync: () => getRegisterAgentInstructionAsync,
  getRangeDisplayString: () => getRangeDisplayString,
  getPDAAccounts: () => getPDAAccounts,
  getNetworkFromDid: () => getNetworkFromDid,
  getMigrationInstructions: () => getMigrationInstructions,
  getMethodsForRelationship: () => getMethodsForRelationship,
  getInterestBearingConfig: () => getInterestBearingConfig,
  getInstructionMapping: () => getInstructionMapping,
  getInitializeStakingConfigInstructionAsync: () => getInitializeStakingConfigInstructionAsync,
  getIdentifierFromDid: () => getIdentifierFromDid,
  getGhostProtectEscrowDecoder: () => getGhostProtectEscrowDecoder,
  getFileDisputeInstruction: () => getFileDisputeInstruction,
  getFeatureFlags: () => getFeatureFlags,
  getDefaultMetricVisibility: () => getDefaultMetricVisibility,
  getDeactivateDidDocumentInstructionAsync: () => getDeactivateDidDocumentInstructionAsync,
  getCreateEscrowInstructionAsync: () => getCreateEscrowInstructionAsync,
  getCreateDidDocumentInstructionAsync: () => getCreateDidDocumentInstructionAsync,
  getConfidentialTransferConfig: () => getConfidentialTransferConfig,
  getClaimGhostInstruction: () => getClaimGhostInstruction,
  getAuthorizationId: () => getAuthorizationId,
  getAssociatedTokenAccount: () => getAssociatedTokenAccount,
  getArbitrateDisputeInstruction: () => getArbitrateDisputeInstruction,
  getApproveDeliveryInstruction: () => getApproveDeliveryInstruction,
  getAllAssociatedTokenAddresses: () => getAllAssociatedTokenAddresses,
  getAgentDecoder: () => getAgentDecoder,
  getAccountRequirements: () => getAccountRequirements,
  generateWithdrawProof: () => generateWithdrawProof,
  generateTransferProof: () => generateTransferProof,
  generateNonce: () => generateNonce,
  generateLocalPrivacyProof: () => generateLocalPrivacyProof,
  generateKeypair: () => generateKeypair,
  generateKeyPairSigner: () => generateKeyPairSigner,
  generateDidString: () => generateDidString,
  generateAccountValidationError: () => generateAccountValidationError,
  fundWallet: () => fundWallet,
  formatTokenAmount: () => formatTokenAmount,
  findProgramDerivedAddress: () => findProgramDerivedAddress,
  filterMetricsByVisibility: () => filterMetricsByVisibility,
  fetchMaybeAgent: () => fetchMaybeAgent,
  fetchAgent: () => fetchAgent,
  extractLegacyData: () => extractLegacyData,
  extractInstructionName: () => extractInstructionName,
  exportDiagnosticReport: () => exportDiagnosticReport,
  exportAsW3CDidDocument: () => exportAsW3CDidDocument,
  estimateStorageCost: () => estimateStorageCost,
  ensureMinimumBalance: () => ensureMinimumBalance,
  enhanceTransactionError: () => enhanceTransactionError,
  enhanceErrorMessage: () => enhanceErrorMessage,
  encrypt: () => encrypt,
  elgamal: () => elgamal_exports,
  didDocumentToJson: () => didDocumentToJson,
  diagnoseBatchFromChain: () => diagnoseBatchFromChain,
  diagnoseAccountFromChain: () => diagnoseAccountFromChain,
  determineStorageMethod: () => determineStorageMethod,
  detectTokenProgram: () => detectTokenProgram,
  deserializeAuthorization: () => deserializeAuthorization,
  deriveUserRegistryPda: () => deriveUserRegistryPda,
  deriveToken2022AssociatedTokenAddress: () => deriveToken2022AssociatedTokenAddress,
  deriveSplTokenAssociatedTokenAddress: () => deriveSplTokenAssociatedTokenAddress,
  deriveProposalPda: () => deriveProposalPda,
  deriveMultisigPda: () => deriveMultisigPda,
  deriveDidDocumentPda: () => deriveDidDocumentPda,
  deriveAssociatedTokenAddress: () => deriveAssociatedTokenAddress,
  deriveAgentVerificationPda: () => deriveAgentVerificationPda,
  deriveAgentPda: () => deriveAgentPda,
  defaultFundingService: () => defaultFundingService,
  default: () => GhostSpeakClient_default,
  decrypt: () => decrypt,
  decodeAgent: () => decodeAgent,
  debugInstructionCall: () => debugInstructionCall,
  createTestIPFSConfig: () => createTestIPFSConfig,
  createSolanaRpc: () => createSolanaRpc,
  createSignedAuthorization: () => createSignedAuthorization,
  createServiceEndpoint: () => createServiceEndpoint,
  createPrivacyManifest: () => createPrivacyManifest,
  createMigrationReport: () => createMigrationReport,
  createMigrationPlan: () => createMigrationPlan,
  createMetadataUri: () => createMetadataUri,
  createKeyPairSignerFromBytes: () => createKeyPairSignerFromBytes,
  createIPFSUtils: () => createIPFSUtils,
  createIPFSErrorHandler: () => createIPFSErrorHandler,
  createErrorContext: () => createErrorContext,
  createEd25519VerificationMethod: () => createEd25519VerificationMethod,
  createDiscriminatorErrorMessage: () => createDiscriminatorErrorMessage,
  createBatchFetcher: () => createBatchFetcher,
  createAuthorizationMessage: () => createAuthorizationMessage,
  createAccountMismatchError: () => createAccountMismatchError,
  clearFeatureGateCache: () => clearFeatureGateCache,
  checkFeatureGate: () => checkFeatureGate,
  canViewerAccess: () => canViewerAccess,
  canPerformAction: () => canPerformAction,
  calculateVisibleScore: () => calculateVisibleScore,
  batchGetExistingAccounts: () => batchGetExistingAccounts,
  batchGetAndMap: () => batchGetAndMap,
  batchGetAccountsWithRetry: () => batchGetAccountsWithRetry,
  batchGetAccounts: () => batchGetAccounts,
  address: () => address2,
  X402TransactionIndexer: () => X402TransactionIndexer,
  WalletFundingService: () => WalletFundingService,
  VisibilityLevel: () => VisibilityLevel,
  VerificationRelationship: () => VerificationRelationship2,
  VerificationMethodType: () => VerificationMethodType2,
  ValidationError: () => ValidationError,
  UnifiedCredentialService: () => UnifiedCredentialService,
  TransactionFailedError: () => TransactionFailedError,
  TokenProgram: () => TokenProgram,
  TokenExtension: () => TokenExtension,
  TimeoutError: () => TimeoutError,
  TagConfidenceLevel: () => TagConfidenceLevel,
  TagCategory: () => TagCategory,
  TOKEN_PROGRAM_ADDRESS: () => TOKEN_PROGRAM_ADDRESS,
  TOKEN_2022_PROGRAM_ADDRESS: () => TOKEN_2022_PROGRAM_ADDRESS,
  TEST_IPFS_CONFIG: () => TEST_IPFS_CONFIG,
  TAG_CONSTANTS: () => TAG_CONSTANTS,
  StakingModule: () => StakingModule,
  SkillTag: () => SkillTag,
  SimulationFailedError: () => SimulationFailedError,
  ServiceEndpointType: () => ServiceEndpointType2,
  ScoreRange: () => ScoreRange,
  SCHEMA_SEED: () => SCHEMA_SEED,
  SAS_PROGRAM_ID: () => SAS_PROGRAM_ID,
  SASAttestationHelper: () => SASAttestationHelper,
  RpcClient: () => RpcClient,
  RetryHandler: () => RetryHandler,
  ReputationTier: () => ReputationTier2,
  ReputationTagEngine: () => ReputationTagEngine,
  ReputationSource: () => ReputationSource,
  ReputationModule: () => ReputationModule,
  REPUTATION_CONSTANTS: () => REPUTATION_CONSTANTS,
  ProposalStatus: () => ProposalStatus,
  PrivateMetadataStorage: () => PrivateMetadataStorage,
  PrivateDataQuery: () => PrivateDataQuery,
  PrivacyPresets: () => PrivacyPresets,
  PrivacyModule: () => PrivacyModule,
  PrivacyMode: () => PrivacyMode,
  ParticipantType: () => ParticipantType,
  PRIVACY_CONSTANTS: () => PRIVACY_CONSTANTS,
  NetworkError: () => NetworkError,
  NATIVE_MINT_ADDRESS: () => NATIVE_MINT_ADDRESS,
  MultisigModule: () => MultisigModule,
  MultiSourceAggregator: () => MultiSourceAggregator,
  MessageType: () => MessageType,
  LocalStorageProvider: () => LocalStorageProvider,
  InvalidInputError: () => InvalidInputError,
  InsufficientBalanceError: () => InsufficientBalanceError,
  InstructionValidationError: () => InstructionValidationError,
  InstructionBuilder: () => InstructionBuilder,
  IPFSUtils: () => IPFSUtils,
  IPFSProvider: () => IPFSProvider,
  IPFSOperationError: () => IPFSOperationError,
  IPFSErrorHandler: () => IPFSErrorHandler,
  IPFSClient: () => IPFSClient,
  INSTRUCTION_MAPPINGS: () => INSTRUCTION_MAPPINGS,
  GovernanceModule: () => GovernanceModule,
  GhostSpeakSDKError: () => GhostSpeakSDKError,
  GhostSpeakError: () => GhostSpeakError2,
  GhostSpeakClient: () => GhostSpeakClient,
  GhostModule: () => GhostModule,
  GHOSTSPEAK_PROGRAM_ID: () => GHOSTSPEAK_PROGRAM_ID,
  GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS: () => GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS,
  GHOSTSPEAK_CREDENTIAL_TYPES: () => GHOSTSPEAK_CREDENTIAL_TYPES,
  FeatureFlagManager: () => FeatureFlagManager,
  FallbackHandler: () => FallbackHandler,
  FEATURE_GATES: () => FEATURE_GATES,
  ExternalIdResolver: () => ExternalIdResolver,
  EscrowStatus: () => EscrowStatus2,
  EscrowModule: () => EscrowModule,
  ErrorHandler: () => ErrorHandler,
  ErrorFactory: () => ErrorFactory,
  ErrorCode: () => ErrorCode,
  DidModule: () => DidModule,
  DidErrorClass: () => DidErrorClass,
  DidError: () => DidError,
  DEFAULT_TAG_DECAY: () => DEFAULT_TAG_DECAY,
  DEFAULT_RETRY_CONFIG: () => DEFAULT_RETRY_CONFIG,
  DEFAULT_IPFS_CONFIG: () => DEFAULT_IPFS_CONFIG,
  CrossmintVCClient: () => CrossmintVCClient,
  CredentialStatus: () => CredentialStatus2,
  CredentialModule: () => CredentialModule,
  CredentialKind: () => CredentialKind2,
  ComplianceTag: () => ComplianceTag,
  ClientEncryptionService: () => ClientEncryptionService,
  CircuitBreaker: () => CircuitBreaker,
  ChannelType: () => ChannelType,
  CacheManager: () => CacheManager,
  CREDENTIAL_SEED: () => CREDENTIAL_SEED,
  BehaviorTag: () => BehaviorTag,
  BaseReputationAdapter: () => BaseReputationAdapter,
  BaseModule: () => BaseModule,
  BadgeType: () => BadgeType,
  AuthorizationModule: () => AuthorizationModule,
  AgentType: () => AgentType,
  AgentModule: () => AgentModule,
  AccountNotFoundError: () => AccountNotFoundError,
  ATTESTATION_SEED: () => ATTESTATION_SEED,
  ASSOCIATED_TOKEN_PROGRAM_ADDRESS: () => ASSOCIATED_TOKEN_PROGRAM_ADDRESS
});
import { promises } from "fs";
function createTestIPFSConfig(options2) {
  return {
    ...TEST_IPFS_CONFIG,
    ...options2,
    provider: {
      ...TEST_IPFS_CONFIG.provider,
      ...options2?.provider ?? {}
    }
  };
}
function createIPFSErrorHandler(config) {
  const handler = new IPFSErrorHandler(config?.retryConfig);
  if (config?.customFallbacks) {
    for (const { errorType, strategy } of config.customFallbacks) {
      handler.registerFallback(errorType, strategy);
    }
  }
  return handler;
}
function isIPFSError(error) {
  return error instanceof IPFSOperationError;
}
async function withIPFSErrorHandling(operation, context, errorHandler) {
  const handler = errorHandler ?? new IPFSErrorHandler;
  return handler.executeWithErrorHandling(async () => {
    try {
      const result = await operation();
      return { success: true, data: result };
    } catch (error) {
      const ipfsError = error instanceof IPFSOperationError ? error.type : "PROVIDER_ERROR";
      return {
        success: false,
        error: ipfsError,
        message: error instanceof Error ? error.message : String(error)
      };
    }
  }, context);
}
async function fundWallet(wallet, amountInSol, options2) {
  return defaultFundingService.fundWallet(wallet, {
    amount: BigInt(Math.floor(amountInSol * 1e9)),
    ...options2
  });
}
async function ensureMinimumBalance(wallet, minBalanceInSol, options2) {
  return defaultFundingService.ensureMinimumBalance(wallet, BigInt(Math.floor(minBalanceInSol * 1e9)), options2);
}
function estimateStorageCost(dataSize, provider) {
  if (provider === "ipfs") {
    return {
      cost: BigInt(Number(dataSize) * 1),
      currency: "lamports"
    };
  } else {
    return {
      cost: BigInt(Number(dataSize) * 10),
      currency: "lamports"
    };
  }
}
function createPrivacyManifest(dataTypes, options2 = {}) {
  return {
    dataTypes,
    encryptionMethod: options2.encryptionMethod ?? "elgamal",
    storageLocation: options2.storageLocation ?? "ipfs",
    retentionPeriod: options2.retentionPeriod,
    accessControl: options2.accessControl ?? "owner-only"
  };
}
async function checkFeatureGate(rpc2, featureGate) {
  const featureId = featureGate;
  const cached = featureCache.get(featureId);
  if (cached) {
    return cached;
  }
  try {
    const response = await rpc2.getAccountInfo(featureGate, { encoding: "base64" }).send();
    const accountInfo = response.value;
    const activated = accountInfo !== null;
    const status = {
      activated,
      lastChecked: Date.now()
    };
    if (accountInfo?.data) {
      try {
        const dataString = typeof accountInfo.data === "string" ? accountInfo.data : accountInfo.data[0];
        const dataBuffer = Buffer.from(dataString, "base64");
        const activationSlot = BigInt(dataBuffer.readBigUInt64LE(0));
        status.activationSlot = activationSlot;
      } catch {}
    }
    featureCache.set(featureId, status);
    return status;
  } catch (error) {
    const errorStatus = {
      activated: false,
      lastChecked: Date.now(),
      error: error instanceof Error ? error.message : "Unknown error"
    };
    featureCache.set(featureId, errorStatus);
    return errorStatus;
  }
}
function clearFeatureGateCache() {
  featureCache.clear();
}
var DEFAULT_API_URL = "https://api.ghostspeak.ai", DEVNET_API_URL = "https://api-devnet.ghostspeak.ai", LOCALNET_API_URL = "http://localhost:3001", ExternalIdResolver = class {
  apiUrl;
  constructor(config) {
    if (config?.apiUrl) {
      this.apiUrl = config.apiUrl;
    } else {
      const cluster = config?.cluster || "devnet";
      this.apiUrl = cluster === "mainnet-beta" ? DEFAULT_API_URL : cluster === "localnet" ? LOCALNET_API_URL : DEVNET_API_URL;
    }
  }
  async resolve(platform, externalId) {
    const result = await this.lookup(platform, externalId);
    return address(result.mapping.ghostAddress);
  }
  async lookup(platform, externalId) {
    try {
      const response = await fetch(`${this.apiUrl}/ghosts/external/${encodeURIComponent(platform)}/${encodeURIComponent(externalId)}`);
      if (response.status === 404) {
        throw new ExternalIdNotFoundError(platform, externalId);
      }
      if (!response.ok) {
        const error = await response.json().catch(() => ({}));
        throw new GhostSpeakError(error.message || "Failed to lookup external ID", error.code || "LOOKUP_FAILED");
      }
      const data = await response.json();
      return data;
    } catch (error) {
      if (error instanceof GhostSpeakError || error instanceof ExternalIdNotFoundError)
        throw error;
      throw new GhostSpeakError("Failed to lookup external ID", "LOOKUP_FAILED");
    }
  }
  async getGhost(ghostAddress) {
    try {
      const addrString = typeof ghostAddress === "string" ? ghostAddress : ghostAddress;
      const response = await fetch(`${this.apiUrl}/ghosts/${encodeURIComponent(addrString)}`);
      if (response.status === 404) {
        throw new GhostNotFoundError(addrString);
      }
      if (!response.ok) {
        const error = await response.json().catch(() => ({}));
        throw new GhostSpeakError(error.message || "Failed to fetch Ghost", error.code || "FETCH_FAILED");
      }
      const ghost = await response.json();
      return ghost;
    } catch (error) {
      if (error instanceof GhostSpeakError || error instanceof GhostNotFoundError)
        throw error;
      throw new GhostSpeakError("Failed to fetch Ghost", "FETCH_FAILED");
    }
  }
  async getGhostScore(ghostAddress) {
    try {
      const addrString = typeof ghostAddress === "string" ? ghostAddress : ghostAddress;
      const response = await fetch(`${this.apiUrl}/ghosts/${encodeURIComponent(addrString)}/score`);
      if (response.status === 404) {
        throw new GhostNotFoundError(addrString);
      }
      if (!response.ok) {
        const error = await response.json().catch(() => ({}));
        throw new GhostSpeakError(error.message || "Failed to fetch Ghost Score", error.code || "FETCH_FAILED");
      }
      const score = await response.json();
      return score;
    } catch (error) {
      if (error instanceof GhostSpeakError || error instanceof GhostNotFoundError)
        throw error;
      throw new GhostSpeakError("Failed to fetch Ghost Score", "FETCH_FAILED");
    }
  }
  async getGhostReputation(ghostAddress) {
    try {
      const addrString = typeof ghostAddress === "string" ? ghostAddress : ghostAddress;
      const response = await fetch(`${this.apiUrl}/ghosts/${encodeURIComponent(addrString)}/reputation`);
      if (response.status === 404) {
        throw new GhostNotFoundError(addrString);
      }
      if (!response.ok) {
        const error = await response.json().catch(() => ({}));
        throw new GhostSpeakError(error.message || "Failed to fetch reputation", error.code || "FETCH_FAILED");
      }
      return await response.json();
    } catch (error) {
      if (error instanceof GhostSpeakError || error instanceof GhostNotFoundError)
        throw error;
      throw new GhostSpeakError("Failed to fetch reputation", "FETCH_FAILED");
    }
  }
  async resolveBatch(identifiers) {
    const promises2 = identifiers.map(({ platform, externalId }) => this.resolve(platform, externalId).catch(() => null));
    return Promise.all(promises2);
  }
  async exists(platform, externalId) {
    try {
      await this.resolve(platform, externalId);
      return true;
    } catch (error) {
      if (error instanceof ExternalIdNotFoundError)
        return false;
      throw error;
    }
  }
  async getExternalIds(ghostAddress) {
    const ghost = await this.getGhost(ghostAddress);
    return ghost.externalIdentifiers;
  }
  async searchByExternalId(platform, partialId) {
    throw new GhostSpeakError("Search not yet implemented", "NOT_IMPLEMENTED");
  }
  setApiUrl(apiUrl) {
    this.apiUrl = apiUrl;
  }
  getApiUrl() {
    return this.apiUrl;
  }
  async checkHealth() {
    try {
      const response = await fetch(`${this.apiUrl}/health`);
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`);
      }
      return await response.json();
    } catch (error) {
      throw new GhostSpeakError("Failed to check API health", "HEALTH_CHECK_FAILED");
    }
  }
}, EscrowModule, X402TransactionIndexer = class {
  rpc;
  facilitatorAddress;
  network;
  batchSize;
  constructor(config) {
    this.rpc = config.rpc;
    this.facilitatorAddress = config.facilitatorAddress;
    this.network = config.network || "solana";
    this.batchSize = config.batchSize || 100;
  }
  async pollTransactions(lastSignature, limit) {
    try {
      const signatures = await this.getSignatures(lastSignature, limit);
      if (signatures.length === 0) {
        return [];
      }
      console.log(`[X402 Indexer] Found ${signatures.length} new transactions`);
      const payments = [];
      for (const sig of signatures) {
        try {
          const payment = await this.parseTransaction(sig.signature);
          if (payment) {
            payments.push(payment);
          }
        } catch (error) {
          console.error(`[X402 Indexer] Failed to parse transaction ${sig.signature}:`, error);
        }
      }
      console.log(`[X402 Indexer] Parsed ${payments.length} x402 payments`);
      return payments;
    } catch (error) {
      console.error("[X402 Indexer] Failed to poll transactions:", error);
      throw error;
    }
  }
  async parseTransaction(sig) {
    try {
      const txSignature = typeof sig === "string" ? sig : sig;
      const response = await this.rpc.getTransaction(txSignature, {
        maxSupportedTransactionVersion: 0,
        encoding: "jsonParsed"
      }).send();
      if (!response || !response.transaction) {
        return null;
      }
      const isX402 = this.isX402Payment(response);
      if (!isX402) {
        return null;
      }
      return this.extractPaymentData(response, typeof sig === "string" ? sig : String(sig));
    } catch (error) {
      console.error(`[X402 Indexer] Failed to fetch transaction ${sig}:`, error);
      return null;
    }
  }
  async getSignatures(before, limit) {
    try {
      const config = {
        limit: limit || this.batchSize
      };
      if (before) {
        config.before = before;
      }
      const response = await this.rpc.getSignaturesForAddress(this.facilitatorAddress, config).send();
      return response.map((sig) => ({
        signature: sig.signature,
        slot: sig.slot,
        blockTime: sig.blockTime,
        err: sig.err ?? null
      }));
    } catch (error) {
      console.error("[X402 Indexer] Failed to fetch signatures:", error);
      throw error;
    }
  }
  isX402Payment(transaction) {
    try {
      const instructions2 = transaction.transaction?.message?.instructions || [];
      const hasPaymentTransfer = instructions2.some((ix) => {
        const programId = ix.programId?.toString();
        const isTokenProgram = programId === "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA" || programId === "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb";
        if (isTokenProgram) {
          const parsed = ix.parsed;
          if (parsed?.type === "transfer" || parsed?.type === "transferChecked") {
            const destination = parsed.info?.destination;
            return destination === this.facilitatorAddress.toString();
          }
        }
        if (programId === "11111111111111111111111111111111") {
          const parsed = ix.parsed;
          if (parsed?.type === "transfer") {
            const destination = parsed.info?.destination;
            return destination === this.facilitatorAddress.toString();
          }
        }
        return false;
      });
      return hasPaymentTransfer;
    } catch (error) {
      console.error("[X402 Indexer] Error checking if x402 payment:", error);
      return false;
    }
  }
  extractPaymentData(transaction, signature2) {
    try {
      const instructions2 = transaction.transaction?.message?.instructions || [];
      const transferIx = instructions2.find((ix) => {
        const parsed = ix.parsed;
        const programId = ix.programId?.toString();
        if (parsed?.type === "transfer" || parsed?.type === "transferChecked") {
          return true;
        }
        return false;
      });
      if (!transferIx) {
        return null;
      }
      const transferInfo = transferIx.parsed.info;
      const merchant = transferInfo.destination;
      const payer = transferInfo.source;
      const amount = transferInfo.amount || transferInfo.tokenAmount?.amount || transferInfo.lamports || "0";
      const success = transaction.meta?.err === null;
      const blockTime = transaction.blockTime;
      const timestamp = blockTime ? new Date(blockTime * 1000) : /* @__PURE__ */ new Date;
      const memoIx = instructions2.find((ix) => ix.programId?.toString()?.includes("Memo"));
      let responseTimeMs;
      let metadata;
      if (memoIx) {
        try {
          let memoText;
          if (memoIx.parsed) {
            memoText = memoIx.parsed;
          } else if (memoIx.data) {
            memoText = Buffer.from(memoIx.data, "base64").toString("utf-8");
          } else {
            memoText = "";
          }
          if (memoText) {
            const memoData = JSON.parse(memoText);
            responseTimeMs = memoData.responseTimeMs;
            metadata = memoData;
          }
        } catch {}
      }
      return {
        signature: signature2,
        merchant,
        payer,
        amount,
        success,
        timestamp,
        network: this.network,
        responseTimeMs,
        metadata
      };
    } catch (error) {
      console.error("[X402 Indexer] Failed to extract payment data:", error);
      return null;
    }
  }
}, TEST_IPFS_CONFIG, IPFSOperationError, DEFAULT_RETRY_CONFIG, CircuitBreaker = class {
  constructor(failureThreshold = 5, recoveryTime = 30000) {
    this.failureThreshold = failureThreshold;
    this.recoveryTime = recoveryTime;
  }
  failures = 0;
  lastFailureTime = 0;
  state = "CLOSED";
  async execute(operation) {
    if (this.state === "OPEN") {
      if (Date.now() - this.lastFailureTime > this.recoveryTime) {
        this.state = "HALF_OPEN";
      } else {
        throw new Error("Circuit breaker is OPEN - too many failures");
      }
    }
    try {
      const result = await operation();
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      throw error;
    }
  }
  onSuccess() {
    this.failures = 0;
    this.state = "CLOSED";
  }
  onFailure() {
    this.failures++;
    this.lastFailureTime = Date.now();
    if (this.failures >= this.failureThreshold) {
      this.state = "OPEN";
    }
  }
  getState() {
    return {
      state: this.state,
      failures: this.failures,
      lastFailureTime: this.lastFailureTime
    };
  }
  reset() {
    this.failures = 0;
    this.lastFailureTime = 0;
    this.state = "CLOSED";
  }
}, RetryHandler = class {
  constructor(config = DEFAULT_RETRY_CONFIG) {
    this.config = config;
    this.circuitBreaker = new CircuitBreaker;
  }
  circuitBreaker;
  async execute(operation, context) {
    return this.circuitBreaker.execute(async () => {
      let lastError;
      for (let attempt = 0;attempt <= this.config.maxRetries; attempt++) {
        try {
          const result = await operation();
          if (attempt > 0) {
            console.log(`âœ… Operation succeeded after ${attempt} retries${context ? ` (${context})` : ""}`);
          }
          return result;
        } catch (error) {
          lastError = error instanceof Error ? error : new Error(String(error));
          if (attempt === this.config.maxRetries) {
            break;
          }
          const shouldRetry = this.shouldRetry(lastError, attempt);
          if (!shouldRetry) {
            console.log(`âŒ Error not retryable${context ? ` (${context})` : ""}:`, lastError.message);
            break;
          }
          const delay = this.calculateDelay(attempt);
          console.log(`â³ Retrying in ${delay}ms... (attempt ${attempt + 1}/${this.config.maxRetries}${context ? `, ${context}` : ""})`);
          await new Promise((resolve) => setTimeout(resolve, delay));
        }
      }
      throw new IPFSOperationError(this.categorizeError(lastError), `Operation failed after ${this.config.maxRetries + 1} attempts${context ? ` (${context})` : ""}: ${lastError.message}`, undefined, this.config.maxRetries);
    });
  }
  shouldRetry(error, attempt) {
    if (attempt >= this.config.maxRetries) {
      return false;
    }
    const errorType = this.categorizeError(error);
    return this.config.retryableErrors.includes(errorType);
  }
  calculateDelay(attempt) {
    const exponentialDelay = this.config.baseDelay * Math.pow(this.config.backoffFactor, attempt);
    const jitter = Math.random() * 0.1 * exponentialDelay;
    return Math.min(exponentialDelay + jitter, this.config.maxDelay);
  }
  categorizeError(error) {
    const message = error.message.toLowerCase();
    if (message.includes("timeout")) {
      return "TIMEOUT_ERROR";
    }
    if (message.includes("network")) {
      return "NETWORK_ERROR";
    }
    if (message.includes("unauthorized")) {
      return "AUTHENTICATION_FAILED";
    }
    if (message.includes("quota")) {
      return "QUOTA_EXCEEDED";
    }
    if (message.includes("invalid") && message.includes("hash")) {
      return "INVALID_HASH";
    }
    if (message.includes("too large")) {
      return "CONTENT_TOO_LARGE";
    }
    return "PROVIDER_ERROR";
  }
  getStats() {
    return {
      circuitBreakerState: this.circuitBreaker.getState(),
      config: this.config
    };
  }
  reset() {
    this.circuitBreaker.reset();
  }
}, FallbackHandler = class {
  fallbackStrategies = /* @__PURE__ */ new Map;
  constructor() {
    this.setupDefaultFallbacks();
  }
  setupDefaultFallbacks() {
    this.fallbackStrategies.set("UPLOAD_FAILED", async (error) => {
      console.log("\uD83D\uDD04 Upload failed, attempting inline storage fallback...");
      throw error;
    });
    this.fallbackStrategies.set("RETRIEVAL_FAILED", async (error) => {
      console.log("\uD83D\uDD04 Retrieval failed, trying alternative gateways...");
      throw error;
    });
    this.fallbackStrategies.set("QUOTA_EXCEEDED", async (error) => {
      console.warn("âš ï¸ IPFS quota exceeded - consider upgrading plan or cleaning up old content");
      throw error;
    });
  }
  async handleError(error, fallbackValue) {
    const strategy = this.fallbackStrategies.get(error.type);
    if (strategy) {
      try {
        const result = await strategy(error);
        return result;
      } catch (_fallbackError) {
        console.warn("Fallback strategy also failed:", _fallbackError instanceof Error ? _fallbackError.message : String(_fallbackError));
      }
    }
    if (fallbackValue !== undefined) {
      console.log("Using provided fallback value");
      return fallbackValue;
    }
    throw error;
  }
  registerFallback(errorType, strategy) {
    this.fallbackStrategies.set(errorType, strategy);
  }
}, IPFSErrorHandler = class {
  retryHandler;
  fallbackHandler;
  constructor(retryConfig) {
    this.retryHandler = new RetryHandler({ ...DEFAULT_RETRY_CONFIG, ...retryConfig });
    this.fallbackHandler = new FallbackHandler;
  }
  async executeWithErrorHandling(operation, context, fallbackValue) {
    try {
      const result = await this.retryHandler.execute(async () => {
        const opResult = await operation();
        if (!opResult.success && opResult.error) {
          throw new IPFSOperationError(opResult.error, opResult.message ?? `IPFS operation failed: ${opResult.error}`);
        }
        return opResult;
      }, context);
      return result;
    } catch (error) {
      const ipfsError = error instanceof IPFSOperationError ? error : new IPFSOperationError("PROVIDER_ERROR", error instanceof Error ? error.message : String(error));
      try {
        const fallbackResult = await this.fallbackHandler.handleError(ipfsError, fallbackValue);
        return {
          success: true,
          data: fallbackResult,
          message: "Operation succeeded using fallback strategy"
        };
      } catch {
        return {
          success: false,
          error: ipfsError.type,
          message: ipfsError.message,
          duration: 0
        };
      }
    }
  }
  registerFallback(errorType, strategy) {
    this.fallbackHandler.registerFallback(errorType, strategy);
  }
  getStats() {
    return {
      retryStats: this.retryHandler.getStats(),
      registeredFallbacks: Array.from(this.fallbackHandler["fallbackStrategies"].keys())
    };
  }
  reset() {
    this.retryHandler.reset();
  }
}, WalletFundingService = class {
  rpc;
  commitment = "confirmed";
  isDevnetUrl;
  constructor(rpcUrl, commitment = "confirmed") {
    this.isDevnetUrl = rpcUrl.includes("devnet");
    this.rpc = createSolanaRpc(rpcUrl);
    this.commitment = commitment;
  }
  async fundWallet(targetWallet, options2) {
    const {
      amount,
      minAmount = amount,
      maxRetries = 3,
      retryDelay = 2000,
      useTreasury = true,
      treasuryWallet,
      fundedWallets = [],
      verbose = false
    } = options2;
    const log = (message) => {
      if (verbose) {
        console.log(source_default.gray(`[WalletFunding] ${message}`));
      }
    };
    let attempts = 0;
    try {
      const currentBalance = await this.getBalance(targetWallet);
      log(`Current balance: ${this.formatSol(currentBalance)} SOL`);
      if (currentBalance >= minAmount) {
        log(`Wallet already has sufficient balance`);
        return {
          success: true,
          balance: currentBalance,
          method: "existing",
          attempts: 0
        };
      }
      const needed = amount - currentBalance;
      log(`Need to fund: ${this.formatSol(needed)} SOL`);
      if (this.isDevnetUrl && "requestAirdrop" in this.rpc) {
        log(`Attempting devnet airdrop...`);
        const airdropResult = await this.tryAirdrop(targetWallet, needed, maxRetries, retryDelay, verbose);
        if (airdropResult.success) {
          const finalBalance = await this.getBalance(targetWallet);
          return {
            success: true,
            balance: finalBalance,
            method: "airdrop",
            attempts: airdropResult.attempts,
            signature: airdropResult.signature
          };
        }
        attempts += airdropResult.attempts;
        log(`Airdrop failed after ${airdropResult.attempts} attempts`);
      }
      if (useTreasury && treasuryWallet) {
        log(`Attempting treasury wallet funding...`);
        const treasuryResult = await this.tryTreasuryFunding(targetWallet, needed, treasuryWallet, verbose);
        if (treasuryResult.success) {
          const finalBalance = await this.getBalance(targetWallet);
          return {
            success: true,
            balance: finalBalance,
            method: "treasury",
            attempts: attempts + 1,
            signature: treasuryResult.signature
          };
        }
        attempts++;
        log(`Treasury funding failed: ${treasuryResult.error}`);
      }
      for (const fundedWallet of fundedWallets) {
        log(`Attempting funding from additional wallet...`);
        const fundedResult = await this.tryFundedWalletTransfer(targetWallet, needed, fundedWallet, verbose);
        if (fundedResult.success) {
          const finalBalance = await this.getBalance(targetWallet);
          return {
            success: true,
            balance: finalBalance,
            method: "funded-wallet",
            attempts: attempts + 1,
            signature: fundedResult.signature
          };
        }
        attempts++;
        log(`Funded wallet transfer failed: ${fundedResult.error}`);
      }
      throw new Error("All funding strategies failed");
    } catch (error) {
      return {
        success: false,
        balance: await this.getBalance(targetWallet),
        method: "airdrop",
        attempts,
        error: error instanceof Error ? error.message : "Unknown error"
      };
    }
  }
  async tryAirdrop(targetWallet, amount, maxRetries, retryDelay, verbose) {
    if (!("requestAirdrop" in this.rpc)) {
      return {
        success: false,
        attempts: 0,
        error: "Airdrop not available on this network"
      };
    }
    let attempts = 0;
    for (let i = 0;i < maxRetries; i++) {
      attempts++;
      try {
        const airdropResponse = await this.rpc.requestAirdrop(targetWallet, lamports(amount), { commitment: this.commitment }).send();
        const signature2 = airdropResponse;
        if (verbose) {
          console.log(source_default.gray(`[WalletFunding] Airdrop requested: ${signature2}`));
        }
        await this.rpc.getLatestBlockhash().send();
        let confirmed = false;
        const maxAttempts = 30;
        for (let i2 = 0;i2 < maxAttempts; i2++) {
          const statusResponse = await this.rpc.getSignatureStatuses([signature2]).send();
          const status = statusResponse.value[0];
          if (status && status.confirmationStatus === "confirmed") {
            confirmed = true;
            break;
          }
          await new Promise((resolve) => setTimeout(resolve, 1000));
        }
        await new Promise((resolve) => setTimeout(resolve, 1000));
        if (!confirmed) {
          throw new Error("Airdrop confirmation timeout");
        }
        return {
          success: true,
          attempts,
          signature: signature2
        };
      } catch (error) {
        if (verbose) {
          console.log(source_default.gray(`[WalletFunding] Airdrop attempt ${attempts} failed: ${error}`));
        }
        if (i < maxRetries - 1) {
          await new Promise((resolve) => setTimeout(resolve, retryDelay));
        }
      }
    }
    return {
      success: false,
      attempts,
      error: "Max retries exceeded"
    };
  }
  async tryTreasuryFunding(targetWallet, amount, treasuryWallet, verbose) {
    try {
      const treasurySigner = await this.loadWallet(treasuryWallet);
      const treasuryBalance = await this.getBalance(treasurySigner.address);
      if (verbose) {
        console.log(source_default.gray(`[WalletFunding] Treasury balance: ${this.formatSol(treasuryBalance)} SOL`));
      }
      if (treasuryBalance < amount + BigInt(5000)) {
        return {
          success: false,
          error: "Insufficient treasury balance"
        };
      }
      const signature2 = await this.transferSol(treasurySigner, targetWallet, amount, verbose);
      return {
        success: true,
        signature: signature2
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error"
      };
    }
  }
  async tryFundedWalletTransfer(targetWallet, amount, fundedWallet, verbose) {
    try {
      const signer = await this.loadWallet(fundedWallet);
      const balance = await this.getBalance(signer.address);
      if (verbose) {
        console.log(source_default.gray(`[WalletFunding] Funded wallet balance: ${this.formatSol(balance)} SOL`));
      }
      if (balance < amount + BigInt(5000)) {
        return {
          success: false,
          error: "Insufficient wallet balance"
        };
      }
      const signature2 = await this.transferSol(signer, targetWallet, amount, verbose);
      return {
        success: true,
        signature: signature2
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error"
      };
    }
  }
  async transferSol(from, to, amount, verbose) {
    const { value: latestBlockhash } = await this.rpc.getLatestBlockhash().send();
    const transferInstruction = getTransferSolInstruction({
      source: from,
      destination: to,
      amount
    });
    const message = pipe(createTransactionMessage({ version: 0 }), (tx) => setTransactionMessageFeePayer(from.address, tx), (tx) => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx), (tx) => appendTransactionMessageInstructions([transferInstruction], tx));
    const signedTransaction = await signTransactionMessageWithSigners(message);
    const base64Transaction = getBase64EncodedWireTransaction(signedTransaction);
    const sendResult = await this.rpc.sendTransaction(base64Transaction, {
      skipPreflight: false,
      preflightCommitment: this.commitment,
      maxRetries: BigInt(5)
    }).send();
    const signature2 = sendResult;
    if (verbose) {
      console.log(source_default.gray(`[WalletFunding] Transfer sent: ${signature2}`));
    }
    let confirmed = false;
    const maxAttempts = 30;
    for (let i = 0;i < maxAttempts; i++) {
      const statusResponse = await this.rpc.getSignatureStatuses([signature2]).send();
      const status = statusResponse.value[0];
      if (status && status.confirmationStatus === "confirmed") {
        confirmed = true;
        break;
      }
      await new Promise((resolve) => setTimeout(resolve, 1000));
    }
    if (!confirmed) {
      throw new Error("Transaction confirmation timeout");
    }
    return signature2;
  }
  async loadWallet(walletSource) {
    if (typeof walletSource !== "string") {
      return walletSource;
    }
    const envValue = process.env[walletSource];
    if (envValue) {
      try {
        const walletData2 = JSON.parse(envValue);
        return await createKeyPairSignerFromBytes(new Uint8Array(walletData2));
      } catch {
        try {
          const privateKeyBytes = esm_default2.decode(envValue);
          if (privateKeyBytes.length === 32 || privateKeyBytes.length === 64) {
            return await createKeyPairSignerFromBytes(privateKeyBytes);
          }
          throw new Error("Invalid base58 private key length");
        } catch (error) {
          throw new Error(`Failed to load wallet from base58 key: ${error instanceof Error ? error.message : "Unknown error"}`);
        }
      }
    }
    const walletData = JSON.parse(await promises.readFile(walletSource, "utf-8"));
    return createKeyPairSignerFromBytes(new Uint8Array(walletData));
  }
  static async loadWalletFromBase58(base58PrivateKey) {
    try {
      const privateKeyBytes = esm_default2.decode(base58PrivateKey);
      if (privateKeyBytes.length === 32 || privateKeyBytes.length === 64) {
        return await createKeyPairSignerFromBytes(privateKeyBytes);
      }
      throw new Error(`Invalid private key length: ${privateKeyBytes.length} bytes. Expected 32 or 64 bytes.`);
    } catch (error) {
      if (error instanceof Error && error.message.includes("Invalid private key length")) {
        throw error;
      }
      throw new Error(`Failed to decode base58 private key: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  async getBalance(wallet) {
    const response = await this.rpc.getBalance(wallet, { commitment: this.commitment }).send();
    return response.value;
  }
  async isDevnet() {
    try {
      const response = await this.rpc.getGenesisHash().send();
      return await Promise.resolve(response === "EtWTRABZaYq6iMfeYKouRu166VU2xqa1wcaWoxPkrZBG");
    } catch {
      return false;
    }
  }
  formatSol(lamports2) {
    return (Number(lamports2) / 1e9).toFixed(4);
  }
  async createAndFundTestWallets(count, amountPerWallet, options2) {
    const wallets = [];
    console.log(source_default.cyan(`Creating and funding ${count} test wallets...`));
    for (let i = 0;i < count; i++) {
      const wallet = await generateKeyPairSigner();
      console.log(source_default.gray(`Wallet ${i + 1}: ${wallet.address}`));
      const result = await this.fundWallet(wallet.address, {
        ...options2,
        amount: amountPerWallet
      });
      if (result.success) {
        wallets.push(wallet);
        console.log(source_default.green(`âœ… Funded with ${this.formatSol(result.balance)} SOL via ${result.method}`));
      } else {
        console.log(source_default.red(`âŒ Failed to fund: ${result.error}`));
      }
    }
    return wallets;
  }
  async ensureMinimumBalance(wallet, minBalance, options2) {
    const currentBalance = await this.getBalance(wallet);
    if (currentBalance >= minBalance) {
      return {
        success: true,
        balance: currentBalance,
        method: "existing",
        attempts: 0
      };
    }
    const needed = minBalance - currentBalance;
    return this.fundWallet(wallet, {
      amount: needed,
      minAmount: minBalance,
      ...options2
    });
  }
}, defaultFundingService, IPFSProvider = class {
  client;
  isPrivateNetwork;
  constructor(options2) {
    const createClient = __require2("kubo-rpc-client").create;
    const ipfsNodeUrl = options2?.ipfsNodeUrl || "http://localhost:5001";
    const headers = options2?.headers || {};
    this.isPrivateNetwork = options2?.usePrivateNetwork || false;
    try {
      new URL(ipfsNodeUrl);
    } catch (error) {
      throw new Error(`Invalid IPFS node URL provided: ${ipfsNodeUrl}`);
    }
    if (!this.isPrivateNetwork && ipfsNodeUrl.includes("localhost")) {
      console.warn("SECURITY WARNING: Using localhost IPFS node in production. Consider using a private IPFS network.");
    }
    if (typeof headers !== "object" || headers === null) {
      throw new Error("Headers must be a valid object");
    }
    this.client = createClient({
      url: ipfsNodeUrl,
      headers
    });
    if (!this.client) {
      throw new Error("Failed to create IPFS client - kubo-rpc-client returned null");
    }
  }
  async store(data) {
    try {
      if (data.length > 10 * 1024 * 1024) {
        throw new Error("Data size exceeds maximum allowed limit (10MB)");
      }
      if (!this.isPrivateNetwork && this.isDataUnencrypted(data)) {
        console.warn("SECURITY WARNING: Data appears to be unencrypted. Ensure client-side encryption is applied.");
      }
      const result = await this.client.add(data, {
        pin: true,
        cidVersion: 1
      });
      return result.cid.toString();
    } catch (error) {
      throw new Error(`Failed to store data to IPFS: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  isDataUnencrypted(data) {
    const text = new TextDecoder("utf-8", { fatal: false }).decode(data.slice(0, 100));
    const commonPatterns = ["{", "<", "BEGIN", "name", "address", "email", "password"];
    return commonPatterns.some((pattern) => text.toLowerCase().includes(pattern.toLowerCase()));
  }
  async retrieve(hash2) {
    try {
      const chunks = [];
      for await (const chunk of this.client.cat(hash2)) {
        chunks.push(chunk);
      }
      const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
      const result = new Uint8Array(totalLength);
      let offset = 0;
      for (const chunk of chunks) {
        result.set(chunk, offset);
        offset += chunk.length;
      }
      return result;
    } catch (error) {
      throw new Error(`Failed to retrieve data from IPFS: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  async delete(hash2) {
    try {
      await this.client.pin.rm(hash2);
      return true;
    } catch (error) {
      console.warn(`IPFS unpin warning for ${hash2}: ${error instanceof Error ? error.message : String(error)}`);
      return false;
    }
  }
}, LocalStorageProvider = class {
  prefix = "ghostspeak_private_";
  async store(data) {
    const hash2 = bytesToHex2(sha2562(data));
    globalThis.localStorage.setItem(this.prefix + hash2, bytesToHex2(data));
    return hash2;
  }
  async retrieve(hash2) {
    const hex = globalThis.localStorage.getItem(this.prefix + hash2);
    if (hex) {
      return hexToBytes2(hex);
    }
    throw new Error(`Data not found: ${hash2}`);
  }
  async delete(hash2) {
    globalThis.localStorage.removeItem(this.prefix + hash2);
    return true;
  }
}, PrivateMetadataStorage = class {
  encryptionService;
  storageProvider;
  featureFlags = getFeatureFlags();
  constructor(storageProvider, encryptionService) {
    this.storageProvider = storageProvider ?? new IPFSProvider;
    this.encryptionService = encryptionService ?? new ClientEncryptionService;
  }
  async storePrivateData(data, publicMetadata, recipientPubkey) {
    if (!this.featureFlags.isEnabled("ENABLE_IPFS_STORAGE")) {
      throw new Error("IPFS storage is not enabled");
    }
    const privateMetadata = await this.encryptionService.createPrivateMetadata(data, publicMetadata, recipientPubkey);
    const serialized = this.serializePrivateMetadata(privateMetadata);
    const storageLocation = await this.storageProvider.store(serialized);
    const onChainHash = this.createOnChainHash(privateMetadata, storageLocation);
    return {
      onChainHash,
      storageProvider: "ipfs",
      storageLocation,
      encryptionMetadata: {
        version: privateMetadata.encrypted.version,
        publicKey: privateMetadata.encrypted.publicKey,
        timestamp: privateMetadata.encrypted.timestamp
      },
      size: serialized.length,
      contentType: "application/json"
    };
  }
  async retrievePrivateData(reference, secretKey) {
    const serialized = await this.storageProvider.retrieve(reference.storageLocation);
    const expectedHash = this.createOnChainHash(this.deserializePrivateMetadata(serialized), reference.storageLocation);
    if (bytesToHex2(expectedHash) !== bytesToHex2(reference.onChainHash)) {
      throw new Error("Data integrity check failed");
    }
    const metadata = this.deserializePrivateMetadata(serialized);
    const decryptedBytes = await this.decryptPrivateData(metadata.encrypted, secretKey);
    const privateData = JSON.parse(new TextDecoder().decode(decryptedBytes));
    return {
      privateData,
      publicData: metadata.public
    };
  }
  createVerifiableLink(onChainData, offChainReference) {
    const combined = {
      onChain: onChainData,
      offChain: {
        hash: bytesToHex2(offChainReference.onChainHash),
        location: offChainReference.storageLocation,
        provider: offChainReference.storageProvider
      },
      timestamp: Date.now()
    };
    return sha2562(new TextEncoder().encode(JSON.stringify(combined)));
  }
  async batchStore(items) {
    const results = [];
    for (const item of items) {
      const stored = await this.storePrivateData(item.data, item.publicMetadata, item.recipientPubkey);
      results.push(stored);
    }
    return results;
  }
  serializePrivateMetadata(metadata) {
    const json = JSON.stringify({
      encrypted: {
        ciphertext: {
          commitment: bytesToHex2(metadata.encrypted.ciphertext.commitment.commitment),
          handle: bytesToHex2(metadata.encrypted.ciphertext.handle.handle)
        },
        publicKey: bytesToHex2(metadata.encrypted.publicKey),
        commitment: bytesToHex2(metadata.encrypted.commitment),
        timestamp: metadata.encrypted.timestamp,
        version: metadata.encrypted.version
      },
      public: metadata.public,
      storageHash: bytesToHex2(metadata.storageHash),
      ipfsHash: metadata.ipfsHash
    });
    return new TextEncoder().encode(json);
  }
  deserializePrivateMetadata(data) {
    const json = JSON.parse(new TextDecoder().decode(data));
    return {
      encrypted: {
        ciphertext: {
          commitment: {
            commitment: hexToBytes2(json.encrypted.ciphertext.commitment)
          },
          handle: {
            handle: hexToBytes2(json.encrypted.ciphertext.handle)
          }
        },
        publicKey: hexToBytes2(json.encrypted.publicKey),
        commitment: hexToBytes2(json.encrypted.commitment),
        timestamp: json.encrypted.timestamp,
        version: json.encrypted.version
      },
      public: json.public,
      storageHash: hexToBytes2(json.storageHash),
      ipfsHash: json.ipfsHash
    };
  }
  createOnChainHash(metadata, storageLocation) {
    const data = {
      storageHash: bytesToHex2(metadata.storageHash),
      storageLocation,
      commitment: bytesToHex2(metadata.encrypted.commitment),
      timestamp: metadata.encrypted.timestamp
    };
    return sha2562(new TextEncoder().encode(JSON.stringify(data)));
  }
  async decryptPrivateData(encrypted, secretKey) {
    const decryptedAmount = await this.encryptionService.decryptAmount(encrypted, secretKey);
    return new TextEncoder().encode(JSON.stringify({ amount: decryptedAmount.toString() }));
  }
}, PrivateDataQuery = class {
  conditions = [];
  where(field, operator, value) {
    this.conditions.push({ field, operator, value, encrypted: false });
    return this;
  }
  whereEncrypted(field, commitment) {
    this.conditions.push({
      field,
      operator: "eq",
      value: commitment,
      encrypted: true
    });
    return this;
  }
  async execute(storage, references) {
    const results = [];
    for (const ref of references) {
      let matches = true;
      for (const condition of this.conditions) {
        if (condition.encrypted) {
          if (condition.field === "commitment") {
            const match = bytesToHex2(ref.onChainHash) === bytesToHex2(condition.value);
            if (!match) {
              matches = false;
              break;
            }
          }
        }
      }
      if (matches) {
        results.push(ref);
      }
    }
    return results;
  }
}, FEATURE_GATES, CACHE_TTL_MS, MAX_CACHE_ENTRIES = 100, FeatureGateCacheManager = class {
  cache = {};
  cacheOrder = [];
  get(featureId) {
    const cached = this.cache[featureId];
    if (Date.now() - cached.lastChecked > CACHE_TTL_MS) {
      this.remove(featureId);
      return null;
    }
    return cached;
  }
  set(featureId, status) {
    this.remove(featureId);
    this.cache[featureId] = status;
    this.cacheOrder.push(featureId);
    if (this.cacheOrder.length > MAX_CACHE_ENTRIES) {
      const oldest = this.cacheOrder.shift();
      if (oldest) {
        delete this.cache[oldest];
      }
    }
  }
  remove(featureId) {
    delete this.cache[featureId];
    this.cacheOrder = this.cacheOrder.filter((id) => id !== featureId);
  }
  clear() {
    this.cache = {};
    this.cacheOrder = [];
  }
}, featureCache;
var init_dist = __esm(() => {
  init_chunk_SKMJJ3Q6();
  init_chunk_TTB4OS2D();
  init_chunk_OKBIWPBC();
  init_chunk_AJSWRU6F();
  init_chunk_AJSWRU6F();
  init_chunk_5DMB3UAV();
  init_chunk_WY76C2A5();
  init_chunk_5TBUKTT3();
  init_chunk_5TBUKTT3();
  init_chunk_BF3IQ35I();
  init_chunk_6PZ43CO5();
  init_chunk_CO2WD4XR();
  init_chunk_CO2WD4XR();
  init_chunk_IQM5RASO();
  init_chunk_IQM5RASO();
  init_chunk_5QZVFUXB();
  init_chunk_46QWY3MG();
  init_chunk_A7ALCVUI();
  init_chunk_QLRWUHN2();
  init_chunk_AWMGX3OX();
  init_chunk_SRS2SKFS();
  init_chunk_RIZZPLLB();
  init_chunk_Z6ZWNWWR();
  init_index_node40();
  init_index_node40();
  init_index_node5();
  init_src();
  init_source();
  init_esm3();
  init_sha256();
  init_utils3();
  EscrowModule = class extends BaseModule {
    async createEscrow(params) {
      const instruction = await getCreateEscrowInstructionAsync({
        agent: params.agent,
        clientTokenAccount: params.clientTokenAccount,
        escrowVault: params.escrowVault,
        tokenMint: params.tokenMint,
        client: params.client,
        escrowId: params.escrowId,
        amount: params.amount,
        jobDescription: params.jobDescription,
        deadline: params.deadline
      }, { programAddress: this.programId });
      return this.execute("createEscrow", () => instruction, [params.client]);
    }
    async submitDelivery(params) {
      const instruction = getSubmitDeliveryInstruction({
        escrow: params.escrow,
        agent: params.agent,
        agentOwner: params.agentOwner,
        deliveryProof: params.deliveryProof
      }, { programAddress: this.programId });
      return this.execute("submitDelivery", () => instruction, [params.agentOwner]);
    }
    async approveDelivery(params) {
      const instruction = getApproveDeliveryInstruction({
        escrow: params.escrow,
        escrowVault: params.escrowVault,
        agentTokenAccount: params.agentTokenAccount,
        client: params.client
      }, { programAddress: this.programId });
      return this.execute("approveDelivery", () => instruction, [params.client]);
    }
    async fileDispute(params) {
      const instruction = getFileDisputeInstruction({
        escrow: params.escrow,
        client: params.client,
        reason: params.reason
      }, { programAddress: this.programId });
      return this.execute("fileDispute", () => instruction, [params.client]);
    }
    async arbitrateDispute(params) {
      const instruction = getArbitrateDisputeInstruction({
        escrow: params.escrow,
        escrowVault: params.escrowVault,
        agentTokenAccount: params.agentTokenAccount,
        clientTokenAccount: params.clientTokenAccount,
        agentStaking: params.agentStaking,
        arbitrator: params.arbitrator,
        decision: params.decision
      }, { programAddress: this.programId });
      return this.execute("arbitrateDispute", () => instruction, [params.arbitrator]);
    }
    async getEscrow(escrowAddress) {
      try {
        return await this.getAccount(escrowAddress, "getGhostProtectEscrowDecoder");
      } catch (error) {
        console.error("Error fetching escrow:", error);
        return null;
      }
    }
  };
  init_reputation_tag_engine();
  init_reputation_tags();
  init_MultiSourceAggregator();
  TEST_IPFS_CONFIG = {
    provider: {
      name: "test",
      endpoint: "http://localhost:8080"
    },
    gateways: [
      "http://localhost:8080",
      "https://test.ipfs.io"
    ],
    autoPinning: true,
    sizeThreshold: 400,
    maxRetries: 2,
    retryDelay: 500,
    enableCache: true,
    cacheTTL: 60000
  };
  IPFSOperationError = class extends Error {
    constructor(type, message, provider, retryCount, originalError) {
      super(message);
      this.type = type;
      this.provider = provider;
      this.retryCount = retryCount;
      this.originalError = originalError;
      this.name = "IPFSOperationError";
    }
  };
  DEFAULT_RETRY_CONFIG = {
    maxRetries: 3,
    baseDelay: 1000,
    maxDelay: 30000,
    backoffFactor: 2,
    retryableErrors: [
      "NETWORK_ERROR",
      "TIMEOUT_ERROR",
      "PROVIDER_ERROR"
    ]
  };
  defaultFundingService = new WalletFundingService(process.env.GHOSTSPEAK_RPC_URL ?? "https://api.devnet.solana.com");
  FEATURE_GATES = {
    CONFIDENTIAL_TRANSFERS: address("11111111111111111111111111111111"),
    TOKEN_2022: address("TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb")
  };
  CACHE_TTL_MS = 5 * 60 * 1000;
  featureCache = new FeatureGateCacheManager;
});

// src/plugin.ts
import { logger as logger11 } from "@elizaos/core";
import { z as z2 } from "zod";

// src/services/GhostSpeakService.ts
init_dist();
import { Service, logger as logger2 } from "@elizaos/core";

// src/wallet.ts
init_index_node38();
init_index_node5();
init_esm3();
import { logger } from "@elizaos/core";
async function getAgentSigner(runtime, allowGenerate = false) {
  if (runtime.wallet?.privateKey) {
    logger.debug("Using wallet from agent runtime");
    try {
      const privateKeyBytes = parsePrivateKey(runtime.wallet.privateKey);
      const signer = await createKeyPairSignerFromBytes(privateKeyBytes);
      logger.info({
        agentId: runtime.agentId,
        walletAddress: signer.address
      }, "Agent signer loaded from runtime wallet");
      return signer;
    } catch (error) {
      logger.error({ error }, "Failed to load wallet from runtime");
      throw new Error("Invalid wallet in runtime");
    }
  }
  if (process.env.AGENT_WALLET_PRIVATE_KEY) {
    logger.debug("Using wallet from environment variable");
    try {
      const privateKeyBytes = parsePrivateKey(process.env.AGENT_WALLET_PRIVATE_KEY);
      const signer = await createKeyPairSignerFromBytes(privateKeyBytes);
      logger.info({
        agentId: runtime.agentId,
        walletAddress: signer.address
      }, "Agent signer loaded from environment");
      return signer;
    } catch (error) {
      logger.error({ error }, "Failed to load wallet from environment");
      throw new Error("Invalid AGENT_WALLET_PRIVATE_KEY");
    }
  }
  if (allowGenerate) {
    logger.warn({ agentId: runtime.agentId }, "No wallet found, generating new keypair (DEV MODE ONLY)");
    const signer = await generateKeyPairSigner();
    logger.info({
      agentId: runtime.agentId,
      walletAddress: signer.address
    }, "Generated new keypair for agent");
    return signer;
  }
  throw new Error("No wallet configured for agent. Please set runtime.wallet or AGENT_WALLET_PRIVATE_KEY");
}
function parsePrivateKey(privateKey) {
  if (privateKey instanceof Uint8Array) {
    return privateKey;
  }
  const keyString = privateKey.trim();
  try {
    const bytes = esm_default2.decode(keyString);
    if (bytes.length === 64) {
      return bytes;
    }
  } catch {}
  if (keyString.startsWith("0x")) {
    try {
      const hex = keyString.slice(2);
      const bytes = new Uint8Array(hex.match(/.{1,2}/g).map((byte) => parseInt(byte, 16)));
      if (bytes.length === 64) {
        return bytes;
      }
    } catch {}
  }
  if (keyString.startsWith("[")) {
    try {
      const numbers = JSON.parse(keyString);
      if (Array.isArray(numbers) && numbers.length === 64) {
        return new Uint8Array(numbers);
      }
    } catch {}
  }
  throw new Error("Invalid private key format. Expected base58, hex (0x...), or JSON array");
}
function hasWalletConfigured(runtime) {
  return !!(runtime.wallet?.privateKey || process.env.AGENT_WALLET_PRIVATE_KEY);
}
async function getAgentAddress(runtime) {
  if (runtime.wallet?.address) {
    return address(runtime.wallet.address);
  }
  if (runtime.wallet?.publicKey) {
    return address(runtime.wallet.publicKey);
  }
  const signer = await getAgentSigner(runtime);
  return signer.address;
}
async function airdropToAgent(runtime, amount = 1e9) {
  const cluster = process.env.SOLANA_CLUSTER || "devnet";
  if (cluster !== "devnet") {
    throw new Error("Airdrop only available on devnet");
  }
  const { createSolanaRpc: createSolanaRpc2 } = await Promise.resolve().then(() => (init_index_node32(), exports_index_node2));
  const rpcUrl = process.env.SOLANA_RPC_URL || "https://api.devnet.solana.com";
  const rpc2 = createSolanaRpc2(rpcUrl);
  const agentAddress = await getAgentAddress(runtime);
  logger.info({
    agentId: runtime.agentId,
    address: agentAddress,
    amount
  }, "Requesting SOL airdrop");
  const lamportsAmount = BigInt(amount);
  const signature2 = await rpc2.requestAirdrop(agentAddress, lamportsAmount).send();
  logger.info({
    agentId: runtime.agentId,
    signature: signature2
  }, "Airdrop successful");
  return signature2.toString();
}
async function getAgentBalance(runtime) {
  const { createSolanaRpc: createSolanaRpc2 } = await Promise.resolve().then(() => (init_index_node32(), exports_index_node2));
  const rpcUrl = process.env.SOLANA_RPC_URL || "https://api.devnet.solana.com";
  const rpc2 = createSolanaRpc2(rpcUrl);
  const agentAddress = await getAgentAddress(runtime);
  const balance = await rpc2.getBalance(agentAddress).send();
  return balance.value;
}
function formatSolBalance(lamports2) {
  const sol2 = Number(lamports2) / 1e9;
  return `${sol2.toFixed(4)} SOL`;
}
async function ensureFundedWallet(runtime, minBalance = 1e8) {
  const balance = await getAgentBalance(runtime);
  if (balance >= BigInt(minBalance)) {
    logger.debug({
      agentId: runtime.agentId,
      balance: formatSolBalance(balance)
    }, "Agent wallet has sufficient balance");
    return true;
  }
  const cluster = process.env.SOLANA_CLUSTER || "devnet";
  if (cluster === "devnet") {
    logger.warn({
      agentId: runtime.agentId,
      balance: formatSolBalance(balance),
      minBalance: formatSolBalance(BigInt(minBalance))
    }, "Agent wallet balance low, requesting airdrop");
    await airdropToAgent(runtime, 1e9);
    return true;
  }
  logger.error({
    agentId: runtime.agentId,
    balance: formatSolBalance(balance),
    minBalance: formatSolBalance(BigInt(minBalance))
  }, "Agent wallet has insufficient balance (mainnet - requires manual funding)");
  return false;
}
async function exportPublicKey(runtime) {
  const agentAddress = await getAgentAddress(runtime);
  return agentAddress.toString();
}

// src/services/GhostSpeakService.ts
var CACHE_TTL_MS2 = 60000;

class GhostSpeakService extends Service {
  runtime;
  static serviceType = "ghostspeak";
  capabilityDescription = "GhostSpeak blockchain operations for AI agent reputation, credentials, and identity";
  client = null;
  signer = null;
  agentCache = new Map;
  constructor(runtime) {
    super(runtime);
    this.runtime = runtime;
  }
  static async start(runtime) {
    const service = new GhostSpeakService(runtime);
    await service.initialize();
    return service;
  }
  async stop() {
    logger2.info("Stopping GhostSpeak service");
    this.client = null;
    this.signer = null;
    this.agentCache.clear();
  }
  async initialize() {
    const cluster = process.env.SOLANA_CLUSTER || "devnet";
    const rpcEndpoint = process.env.SOLANA_RPC_URL;
    this.client = new GhostSpeakClient({
      cluster,
      rpcEndpoint
    });
    if (hasWalletConfigured(this.runtime)) {
      try {
        this.signer = await getAgentSigner(this.runtime);
        logger2.info({
          address: this.signer.address,
          cluster
        }, "GhostSpeak service initialized with signer");
      } catch (error) {
        logger2.warn({ error }, "Failed to load wallet - read-only mode");
      }
    } else {
      logger2.info({ cluster }, "GhostSpeak service initialized (read-only mode - no wallet configured)");
    }
  }
  getClient() {
    if (!this.client) {
      throw new Error("GhostSpeak client not initialized. Service may not have started properly.");
    }
    return this.client;
  }
  async getSigner() {
    if (!this.signer) {
      this.signer = await getAgentSigner(this.runtime);
    }
    return this.signer;
  }
  hasSigner() {
    return this.signer !== null || hasWalletConfigured(this.runtime);
  }
  getSignerAddress() {
    return this.signer?.address ?? null;
  }
  async getAgent(agentAddress) {
    const cacheKey = agentAddress.toString();
    const cached = this.agentCache.get(cacheKey);
    if (cached && cached.expires > Date.now()) {
      logger2.debug({ agentAddress: cacheKey }, "Using cached agent data");
      return cached.data;
    }
    try {
      const agent = await this.getClient().agents.getAgentAccount(agentAddress);
      if (agent) {
        this.agentCache.set(cacheKey, {
          data: agent,
          expires: Date.now() + CACHE_TTL_MS2
        });
        logger2.debug({ agentAddress: cacheKey }, "Cached agent data from blockchain");
      }
      return agent;
    } catch (error) {
      logger2.error({ error, agentAddress: cacheKey }, "Failed to fetch agent from blockchain");
      throw error;
    }
  }
  invalidateAgentCache(agentAddress) {
    this.agentCache.delete(agentAddress.toString());
  }
  clearCache() {
    this.agentCache.clear();
    logger2.debug("Cleared all cached agent data");
  }
  get agents() {
    return this.getClient().agents;
  }
  get ghosts() {
    return this.getClient().ghosts;
  }
  credentials() {
    return this.getClient().credentials();
  }
  did() {
    return this.getClient().did();
  }
  reputation() {
    return this.getClient().reputation();
  }
  privacy() {
    return this.getClient().privacy();
  }
  staking() {
    return this.getClient().staking;
  }
  reputationAggregator() {
    return this.getClient().reputationAggregator();
  }
  authorization() {
    return this.getClient().authorization;
  }
  getCluster() {
    return process.env.SOLANA_CLUSTER || "devnet";
  }
  isMainnet() {
    return this.getCluster() === "mainnet-beta";
  }
  getStats() {
    return {
      cacheSize: this.agentCache.size,
      hasSigner: this.hasSigner(),
      cluster: this.getCluster(),
      isMainnet: this.isMainnet()
    };
  }
}

// src/actions/ghost-score.ts
init_index_node5();
import { logger as logger3 } from "@elizaos/core";
function getGhostScoreTier(ghostScore) {
  if (ghostScore >= 9000)
    return "PLATINUM";
  if (ghostScore >= 7500)
    return "GOLD";
  if (ghostScore >= 5000)
    return "SILVER";
  if (ghostScore >= 2000)
    return "BRONZE";
  return "NEWCOMER";
}
function getTierMessage(tier) {
  switch (tier) {
    case "PLATINUM":
      return "Platinum tier - elite reputation status.";
    case "GOLD":
      return "Gold tier - trusted and reliable agent.";
    case "SILVER":
      return "Silver tier - established reputation.";
    case "BRONZE":
      return "Bronze tier - building reputation.";
    default:
      return "Newcomer - welcome to the network!";
  }
}
var checkGhostScoreAction = {
  name: "CHECK_GHOST_SCORE",
  similes: [
    "GET_GHOST_SCORE",
    "CHECK_REPUTATION",
    "GET_REPUTATION",
    "GHOST_SCORE",
    "AGENT_SCORE"
  ],
  description: "Check the Ghost Score (reputation) of an AI agent on GhostSpeak. Ghost Score is a 0-10000 credit rating based on transaction history, service quality, and credentials.",
  validate: async (_runtime, message, _state) => {
    const text = message.content.text?.toLowerCase() || "";
    return text.includes("ghost score") || text.includes("reputation") || text.includes("check score") || text.includes("agent score");
  },
  handler: async (runtime, message, _state, _options, callback, _responses) => {
    try {
      const service = runtime.getService("ghostspeak");
      if (!service) {
        throw new Error("GhostSpeak service not available");
      }
      const text = message.content.text || "";
      const addressMatch = text.match(/([A-HJ-NP-Za-km-z1-9]{32,44})/);
      let agentAddress;
      if (addressMatch) {
        try {
          agentAddress = address(addressMatch[1]);
        } catch {}
      }
      if (!agentAddress && runtime.agentId) {
        try {
          agentAddress = address(runtime.agentId);
        } catch {}
      }
      if (!agentAddress) {
        const errorMsg = 'Please provide a valid Solana agent address. Usage: "Check ghost score for [agent address]"';
        if (callback) {
          await callback({
            text: errorMsg,
            actions: ["CHECK_GHOST_SCORE"],
            source: message.content.source
          });
        }
        return {
          success: false,
          text: errorMsg,
          values: {},
          error: new Error("Agent address required")
        };
      }
      const agentData = await service.getAgent(agentAddress);
      if (!agentData) {
        const errorMsg = `Agent not found at address ${agentAddress}`;
        if (callback) {
          await callback({
            text: errorMsg,
            actions: ["CHECK_GHOST_SCORE"],
            source: message.content.source
          });
        }
        return {
          success: false,
          text: errorMsg,
          values: {},
          error: new Error("Agent not found")
        };
      }
      const onChainGhostScore = Number(agentData.ghostScore || 0);
      const reputationScore = Number(agentData.reputationScore || 0);
      const ghostScore = onChainGhostScore > 0 ? Math.min(1e4, Math.round(onChainGhostScore / 1e5)) : Math.min(1e4, Math.round(reputationScore / 10));
      const tier = getGhostScoreTier(ghostScore);
      const totalJobs = Number(agentData.totalJobsCompleted || 0);
      const successRate = totalJobs > 0 ? 100 : 0;
      const tierMessage = getTierMessage(tier);
      const response = `Ghost Score for ${agentData.name || "Agent"} (${agentAddress.toString().slice(0, 8)}...):

Ghost Score: ${ghostScore}/10000
Tier: ${tier}
Total Jobs Completed: ${totalJobs}
Success Rate: ${successRate}%
Status: ${agentData.isActive ? "Active" : "Inactive"}
${agentData.x402Enabled ? "x402 Payments: Enabled" : ""}

${tierMessage}`;
      if (callback) {
        await callback({
          text: response,
          actions: ["CHECK_GHOST_SCORE"],
          source: message.content.source
        });
      }
      return {
        success: true,
        text: response,
        values: {
          ghostScore,
          tier,
          totalJobs,
          successRate,
          isActive: agentData.isActive,
          agentAddress: agentAddress.toString()
        },
        data: {
          agentAddress: agentAddress.toString(),
          agentName: agentData.name,
          ghostScore,
          tier,
          totalJobs,
          successRate,
          isActive: agentData.isActive
        }
      };
    } catch (error) {
      logger3.error({ error }, "Error checking Ghost Score");
      const errorMsg = `Failed to check Ghost Score: ${error instanceof Error ? error.message : "Unknown error"}`;
      if (callback) {
        await callback({
          text: errorMsg,
          actions: ["CHECK_GHOST_SCORE"],
          source: message.content.source
        });
      }
      return {
        success: false,
        text: errorMsg,
        values: {},
        error: error instanceof Error ? error : new Error(String(error))
      };
    }
  },
  examples: [
    [
      {
        name: "{{userName}}",
        content: {
          text: "Check ghost score for 7xKXtYZ3rR9vR1xgVfqU8kK4d9gP9Gk",
          actions: []
        }
      },
      {
        name: "{{agentName}}",
        content: {
          text: `Ghost Score for Agent (7xKXtYZ3...):

Ghost Score: 7850/10000
Tier: GOLD
Total Jobs Completed: 1247
Success Rate: 94%
Status: Active

Gold tier - trusted and reliable agent.`,
          actions: ["CHECK_GHOST_SCORE"]
        }
      }
    ],
    [
      {
        name: "{{userName}}",
        content: {
          text: "What is the reputation of agent 9AbC...",
          actions: []
        }
      },
      {
        name: "{{agentName}}",
        content: {
          text: `Ghost Score for Agent (9AbC...):

Ghost Score: 3200/10000
Tier: BRONZE
Total Jobs Completed: 45
Success Rate: 100%
Status: Active

Bronze tier - building reputation.`,
          actions: ["CHECK_GHOST_SCORE"]
        }
      }
    ],
    [
      {
        name: "{{userName}}",
        content: {
          text: "Check my agent score at 5FhN...",
          actions: []
        }
      },
      {
        name: "{{agentName}}",
        content: {
          text: `Ghost Score for Agent (5FhN...):

Ghost Score: 500/10000
Tier: NEWCOMER
Total Jobs Completed: 3
Success Rate: 100%
Status: Active

Newcomer - welcome to the network!`,
          actions: ["CHECK_GHOST_SCORE"]
        }
      }
    ]
  ]
};
// src/actions/registerAgent.ts
import { logger as logger4 } from "@elizaos/core";
function parseRegistrationRequest(message) {
  const text = message.content.text || "";
  const nameMatch = text.match(/name[:\s]+([^,\n]+)/i);
  if (!nameMatch) {
    return null;
  }
  const name = nameMatch[1].trim();
  const descMatch = text.match(/description[:\s]+([^,\n]+)/i);
  if (!descMatch) {
    return null;
  }
  const description = descMatch[1].trim();
  const capMatch = text.match(/capabilities?[:\s]+\[([^\]]+)\]/i);
  if (!capMatch) {
    return null;
  }
  const capabilities = capMatch[1].split(",").map((c) => c.trim());
  const modelMatch = text.match(/model[:\s]+([^,\n]+)/i);
  const model = modelMatch ? modelMatch[1].trim() : undefined;
  const typeMatch = text.match(/type[:\s]+(\d+)/i);
  const agentType = typeMatch ? parseInt(typeMatch[1]) : 0;
  const useCompressedNFT = text.toLowerCase().includes("compressed") || text.toLowerCase().includes("cnft");
  return {
    name,
    description,
    capabilities,
    model,
    agentType,
    useCompressedNFT
  };
}
var registerAgentAction = {
  name: "REGISTER_AGENT",
  similes: [
    "CREATE_AGENT",
    "REGISTER_ON_GHOSTSPEAK",
    "ONBOARD_AGENT",
    "SETUP_AGENT"
  ],
  description: `Register an AI agent on GhostSpeak blockchain. Creates on-chain identity with:
- Unique agent address
- Name and description
- Capabilities list
- Optional compressed NFT (5000x cheaper)

Registered agents can:
- Accumulate Ghost Score (reputation)
- Earn verifiable credentials
- Participate in x402 payment protocol
- Track job history on-chain`,
  validate: async (_runtime, message, _state) => {
    const text = message.content.text?.toLowerCase() || "";
    return (text.includes("register") || text.includes("create") || text.includes("onboard")) && text.includes("agent");
  },
  handler: async (runtime, message, _state, _options, callback, _responses) => {
    try {
      const request = parseRegistrationRequest(message);
      if (!request) {
        const errorMsg = `I need agent details to register. Format:
"Register agent name: My Agent, description: What it does, capabilities: [cap1, cap2]"
Optional: "model: gpt-4, type: 0, compressed"`;
        if (callback) {
          await callback({
            text: errorMsg,
            actions: ["REGISTER_AGENT"],
            source: message.content.source
          });
        }
        return {
          success: false,
          text: errorMsg,
          error: new Error("Registration details required")
        };
      }
      logger4.info({
        agentId: runtime.agentId,
        agentName: request.name,
        useCompressedNFT: request.useCompressedNFT
      }, "Registering agent on GhostSpeak");
      const signer = await getAgentSigner(runtime);
      logger4.info({
        signerAddress: signer.address
      }, "Using signer for registration");
      const hasFunds = await ensureFundedWallet(runtime);
      if (!hasFunds) {
        throw new Error("Insufficient SOL balance. Please fund your wallet or wait for airdrop.");
      }
      const service = runtime.getService("ghostspeak");
      if (!service) {
        throw new Error("GhostSpeak service not available");
      }
      let result;
      const metadata = {
        capabilities: request.capabilities,
        model: request.model,
        framework: "elizaos",
        registeredAt: Date.now()
      };
      const metadataUri = `data:application/json,${encodeURIComponent(JSON.stringify(metadata))}`;
      const agentId = `${request.name.toLowerCase().replace(/\s+/g, "-")}-${Date.now()}`;
      if (request.useCompressedNFT) {
        logger4.warn("Compressed NFT registration not yet implemented, using standard registration");
        result = await service.agents.register(signer, {
          name: request.name,
          description: request.description,
          metadataUri,
          agentId,
          agentType: request.agentType || 0
        });
      } else {
        result = await service.agents.register(signer, {
          name: request.name,
          description: request.description,
          metadataUri,
          agentId,
          agentType: request.agentType || 0
        });
      }
      logger4.info({
        agentAddress: result.address,
        signature: result.signature
      }, "Agent registered successfully");
      logger4.debug({
        agentAddress: result.address.toString()
      }, "Agent registered - address can be used for future operations");
      const responseText = `âœ… Agent registered successfully on GhostSpeak!

**Agent Address**: ${result.address.toString()}
**Name**: ${request.name}
**Description**: ${request.description}
**Capabilities**: ${request.capabilities.join(", ")}
${request.model ? `**Model**: ${request.model}` : ""}
**Network**: ${process.env.SOLANA_CLUSTER || "devnet"}
**Transaction**: ${result.signature}

Your agent now has an on-chain identity! It can:
- âœ… Accumulate Ghost Score (reputation)
- âœ… Earn verifiable credentials
- âœ… Accept x402 payments
- âœ… Track job history on-chain

Next steps:
1. Issue an identity credential: "Issue credential for ${result.address.toString().slice(0, 8)}..."
2. Start completing jobs to build reputation
3. Check your Ghost Score: "Check ghost score for ${result.address.toString().slice(0, 8)}..."`;
      if (callback) {
        await callback({
          text: responseText,
          actions: ["REGISTER_AGENT"],
          source: message.content.source
        });
      }
      return {
        success: true,
        text: responseText,
        values: {
          agentAddress: result.address.toString(),
          name: request.name,
          capabilities: request.capabilities,
          network: process.env.SOLANA_CLUSTER || "devnet"
        },
        data: {
          agentAddress: result.address.toString(),
          signature: result.signature,
          name: request.name,
          capabilities: request.capabilities,
          network: process.env.SOLANA_CLUSTER || "devnet"
        }
      };
    } catch (error) {
      logger4.error({ error }, "Error registering agent:");
      const errorMsg = `Failed to register agent: ${error instanceof Error ? error.message : "Unknown error"}

Common issues:
- Insufficient SOL balance (need ~0.01 SOL for transaction)
- Invalid agent details
- Network connection issues
- Agent already registered with this wallet

Try:
1. Check your SOL balance
2. Verify agent details are correct
3. Try again in a moment`;
      if (callback) {
        await callback({
          text: errorMsg,
          actions: ["REGISTER_AGENT"],
          source: message.content.source
        });
      }
      return {
        success: false,
        text: errorMsg,
        values: {},
        error: error instanceof Error ? error : new Error(String(error))
      };
    }
  },
  examples: [
    [
      {
        name: "{{userName}}",
        content: {
          text: "Register agent name: Code Reviewer, description: AI agent for code analysis and security audits, capabilities: [code-review, security-audit, bug-detection], model: gpt-4",
          actions: []
        }
      },
      {
        name: "{{agentName}}",
        content: {
          text: `âœ… Agent registered successfully on GhostSpeak!

**Agent Address**: 7xKXtYZ3rR9vR1xgVfqU8kK4d9gP9Gk
**Name**: Code Reviewer
**Description**: AI agent for code analysis and security audits
**Capabilities**: code-review, security-audit, bug-detection
**Model**: gpt-4
**Network**: devnet
**Transaction**: 5jHD...

Your agent now has an on-chain identity!`,
          actions: ["REGISTER_AGENT"]
        }
      }
    ]
  ]
};
// src/actions/issueCredential.ts
init_index_node5();
import { logger as logger5 } from "@elizaos/core";
function verifyElizaOSRuntime(runtime) {
  try {
    const hasCharacter = runtime.character !== undefined && runtime.character !== null;
    const hasPlugins = Array.isArray(runtime.plugins);
    const hasProcessActions = typeof runtime.processActions === "function";
    const hasEvaluate = typeof runtime.evaluate === "function";
    const hasComposeState = typeof runtime.composeState === "function";
    const hasAgentId = typeof runtime.agentId === "string";
    const hasLogger = runtime.logger !== undefined;
    const isElizaOS = hasCharacter && hasPlugins && hasProcessActions && hasEvaluate && hasComposeState && hasAgentId && hasLogger;
    logger5.debug({
      hasCharacter,
      hasPlugins,
      hasProcessActions,
      hasEvaluate,
      hasComposeState,
      hasAgentId,
      hasLogger,
      isElizaOS
    }, "ElizaOS runtime verification checks");
    return isElizaOS;
  } catch (error) {
    logger5.warn({ error }, "Failed to verify ElizaOS runtime - defaulting to custom framework");
    return false;
  }
}
function parseCredentialRequest(message) {
  const text = message.content.text || "";
  const textLower = text.toLowerCase();
  const addressMatch = text.match(/([A-Za-z0-9]{32,44})/);
  if (!addressMatch) {
    return null;
  }
  const agentId = address(addressMatch[1]);
  let credentialType = "agent-identity";
  if (textLower.includes("reputation") || textLower.includes("ghost score")) {
    credentialType = "reputation";
  } else if (textLower.includes("job") || textLower.includes("completion")) {
    credentialType = "job-completion";
  }
  const emailMatch = text.match(/([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})/);
  const recipientEmail = emailMatch ? emailMatch[1] : undefined;
  const syncToCrossmint = textLower.includes("crossmint") || textLower.includes("evm");
  const nameMatch = text.match(/name[:\s]+([^,\n]+)/i);
  const name = nameMatch ? nameMatch[1].trim() : undefined;
  const capabilitiesMatch = text.match(/capabilities?[:\s]+\[([^\]]+)\]/i);
  const capabilities = capabilitiesMatch ? capabilitiesMatch[1].split(",").map((c) => c.trim()) : undefined;
  return {
    agentId,
    recipientEmail,
    credentialType,
    subject: {
      name,
      capabilities
    },
    syncToCrossmint
  };
}
var issueCredentialAction = {
  name: "ISSUE_CREDENTIAL",
  similes: [
    "CREATE_CREDENTIAL",
    "ISSUE_VC",
    "CREATE_VERIFIABLE_CREDENTIAL",
    "MINT_CREDENTIAL"
  ],
  description: `Issue a W3C Verifiable Credential for an AI agent. Credentials can be:
- Agent Identity: Prove agent ownership and capabilities
- Reputation: Certify trust score and performance
- Job Completion: Document completed work

Credentials are stored on Solana and can be bridged to EVM chains via Crossmint.`,
  validate: async (_runtime, message, _state) => {
    const text = message.content.text?.toLowerCase() || "";
    const hasActionWord = text.includes("issue") || text.includes("create") || text.includes("mint");
    const hasCredentialWord = text.includes("credential") || text.includes("vc");
    const hasSolanaAddress = /[A-Za-z0-9]{32,44}/.test(message.content.text || "");
    const isInformationalQuestion = text.includes("what types") || text.includes("what kind") || text.includes("which types") || text.includes("can you issue") || text.includes("what vcs");
    return hasActionWord && hasCredentialWord && hasSolanaAddress && !isInformationalQuestion;
  },
  handler: async (runtime, message, _state, _options, callback, _responses) => {
    try {
      const request = parseCredentialRequest(message);
      if (!request) {
        const errorMsg = `I need an agent address to issue a credential. Format:
"Issue credential for [agent-address]"
Optional: "name: Agent Name, capabilities: [cap1, cap2], email: user@example.com, crossmint"`;
        if (callback) {
          await callback({
            text: errorMsg,
            actions: ["ISSUE_CREDENTIAL"],
            source: message.content.source
          });
        }
        return {
          success: false,
          text: errorMsg,
          error: new Error("Agent address required")
        };
      }
      logger5.info({
        agentId: runtime.agentId,
        targetAgent: request.agentId.toString(),
        credentialType: request.credentialType
      }, "Issuing credential");
      const signer = await getAgentSigner(runtime);
      const hasFunds = await ensureFundedWallet(runtime);
      if (!hasFunds) {
        throw new Error("Insufficient SOL balance. Please fund your wallet.");
      }
      const service = runtime.getService("ghostspeak");
      if (!service) {
        throw new Error("GhostSpeak service not available");
      }
      let result;
      if (request.credentialType === "agent-identity") {
        const credentialService = service.credentials();
        const now = Math.floor(Date.now() / 1000);
        const signatureData = new TextEncoder().encode(`${request.agentId.toString()}:${signer.address.toString()}:${now}`);
        const isElizaOSRuntime = verifyElizaOSRuntime(runtime);
        const frameworkOrigin = isElizaOSRuntime ? "elizaos" : "custom";
        logger5.info({
          agentId: runtime.agentId,
          isElizaOSRuntime,
          frameworkOrigin
        }, "Framework origin verified for credential issuance");
        result = await credentialService.issueAgentIdentityCredential({
          agentId: request.agentId.toString(),
          owner: signer.address.toString(),
          name: request.subject.name || "Unknown Agent",
          capabilities: request.subject.capabilities || [],
          serviceEndpoint: `https://ghostspeak.ai/agents/${request.agentId.toString().slice(0, 8)}`,
          frameworkOrigin,
          x402Enabled: true,
          registeredAt: now,
          verifiedAt: now,
          syncToCrossmint: request.syncToCrossmint,
          recipientEmail: request.recipientEmail,
          signature: signatureData
        });
        logger5.info({
          credentialId: result.solanaCredential?.credentialId,
          crossmintId: result.crossmintSync?.id
        }, "Agent identity credential issued");
      } else if (request.credentialType === "reputation") {
        const agentData = await service.agents.getAgentAccount(request.agentId);
        if (!agentData) {
          throw new Error(`Agent not found: ${request.agentId}`);
        }
        const reputationScore = Number(agentData.reputationScore || 0);
        const totalJobsCompleted = Number(agentData.totalJobsCompleted || 0);
        const successRate = totalJobsCompleted > 0 ? 100 : 0;
        const templateId = process.env.CROSSMINT_REPUTATION_TEMPLATE_ID;
        if (!templateId && request.syncToCrossmint) {
          throw new Error("CROSSMINT_REPUTATION_TEMPLATE_ID not configured");
        }
        const subject = {
          agent: request.agentId.toString(),
          reputationScore,
          totalJobsCompleted,
          totalEarnings: 0,
          successRate,
          avgRating: Math.min(5, Math.ceil(reputationScore / 2000)),
          disputeRate: 0,
          snapshotTimestamp: Math.floor(Date.now() / 1000)
        };
        if (request.syncToCrossmint && templateId) {
          const { CrossmintVCClient: CrossmintVCClient2 } = await Promise.resolve().then(() => (init_dist(), exports_dist));
          const crossmintEnv = process.env.CROSSMINT_ENV === "production" ? "production" : "staging";
          const crossmint = new CrossmintVCClient2({
            apiKey: process.env.CROSSMINT_SECRET_KEY || "",
            environment: crossmintEnv,
            chain: "base-sepolia"
          });
          const crossmintResult = await crossmint.issueReputationCredential(templateId, request.recipientEmail || `agent-${request.agentId.toString().slice(0, 8)}@ghostspeak.credentials`, subject);
          result = {
            solanaCredential: null,
            crossmintSync: crossmintResult
          };
        } else {
          result = {
            solanaCredential: { credentialSubject: subject },
            crossmintSync: null
          };
        }
        logger5.info({
          crossmintId: result.crossmintSync?.id,
          reputationScore
        }, "Reputation credential issued");
      } else {
        throw new Error(`Credential type not yet implemented: ${request.credentialType}`);
      }
      const responseText = `âœ… Credential issued successfully!

**Credential Type**: ${request.credentialType}
**Agent**: ${request.agentId.toString().slice(0, 8)}...${request.agentId.toString().slice(-8)}
${result.solanaCredential?.credentialId ? `**Solana Credential ID**: ${result.solanaCredential.credentialId}` : ""}
${result.crossmintSync?.id ? `**Crossmint ID**: ${result.crossmintSync.id}` : ""}
${result.crossmintSync?.onChain?.status ? `**EVM Status**: ${result.crossmintSync.onChain.status}` : ""}
${request.recipientEmail ? `**Recipient**: ${request.recipientEmail}` : ""}

The credential has been created and ${request.syncToCrossmint ? "bridged to EVM via Crossmint" : "stored on Solana"}.`;
      if (callback) {
        await callback({
          text: responseText,
          actions: ["ISSUE_CREDENTIAL"],
          source: message.content.source
        });
      }
      return {
        success: true,
        text: responseText,
        values: {
          credentialType: request.credentialType,
          agentId: request.agentId.toString(),
          credentialId: result.solanaCredential?.credentialId,
          crossmintId: result.crossmintSync?.id
        },
        data: {
          credentialType: request.credentialType,
          agentId: request.agentId.toString(),
          credentialId: result.solanaCredential?.credentialId,
          crossmintId: result.crossmintSync?.id,
          evmStatus: result.crossmintSync?.onChain?.status
        }
      };
    } catch (error) {
      logger5.error({ error }, "Error issuing credential:");
      const errorMsg = `Failed to issue credential: ${error instanceof Error ? error.message : "Unknown error"}

Common issues:
- Agent not registered on GhostSpeak
- Insufficient SOL balance
- Crossmint API key not configured
- Invalid agent address`;
      if (callback) {
        await callback({
          text: errorMsg,
          actions: ["ISSUE_CREDENTIAL"],
          source: message.content.source
        });
      }
      return {
        success: false,
        text: errorMsg,
        values: {},
        error: error instanceof Error ? error : new Error(String(error))
      };
    }
  },
  examples: [
    [
      {
        name: "{{userName}}",
        content: {
          text: "Issue credential for 7xKXtYZ3rR9vR1xgVfqU8kK4d9gP9Gk name: AI Assistant, capabilities: [code-review, security-audit], email: builder@example.com",
          actions: []
        }
      },
      {
        name: "{{agentName}}",
        content: {
          text: `âœ… Credential issued successfully!

**Credential Type**: agent-identity
**Agent**: 7xKXtYZ3...9Gk
**Solana Credential ID**: cred_abc123
**Recipient**: builder@example.com

The credential has been created and stored on Solana.`,
          actions: ["ISSUE_CREDENTIAL"]
        }
      }
    ],
    [
      {
        name: "{{userName}}",
        content: {
          text: "Issue reputation credential for 7xKXtYZ3rR9vR1xgVfqU8kK4d9gP9Gk crossmint",
          actions: []
        }
      },
      {
        name: "{{agentName}}",
        content: {
          text: `âœ… Credential issued successfully!

**Credential Type**: reputation
**Agent**: 7xKXtYZ3...9Gk
**Crossmint ID**: vc_xyz789
**EVM Status**: pending

The credential has been created and bridged to EVM via Crossmint.`,
          actions: ["ISSUE_CREDENTIAL"]
        }
      }
    ]
  ]
};
// src/actions/acceptPayment.ts
import { logger as logger6 } from "@elizaos/core";
var PAYAI_FACILITATOR_URL = "https://facilitator.payai.network";
var PRICING_TIERS = {
  PLATINUM: { multiplier: 2, minScore: 900 },
  GOLD: { multiplier: 1.5, minScore: 750 },
  SILVER: { multiplier: 1.2, minScore: 500 },
  BRONZE: { multiplier: 1, minScore: 200 },
  NEWCOMER: { multiplier: 0.8, minScore: 0 }
};
var SERVICE_PRICES = {
  "ghost-score-check": 0.01,
  "credential-issuance": 0.05,
  "agent-registration": 0.1,
  "did-creation": 0.02,
  "did-resolution": 0.005,
  "reputation-report": 0.03,
  default: 0.01
};
function getPricingTier(ghostScore) {
  if (ghostScore >= 900)
    return "PLATINUM";
  if (ghostScore >= 750)
    return "GOLD";
  if (ghostScore >= 500)
    return "SILVER";
  if (ghostScore >= 200)
    return "BRONZE";
  return "NEWCOMER";
}
function calculatePrice(serviceType, ghostScore) {
  const basePrice = SERVICE_PRICES[serviceType] ?? SERVICE_PRICES.default;
  const tier = getPricingTier(ghostScore);
  const multiplier = PRICING_TIERS[tier].multiplier;
  return basePrice * multiplier;
}
function parsePaymentRequest(message) {
  const text = message.content.text?.toLowerCase() || "";
  let serviceType = "default";
  if (text.includes("ghost score") || text.includes("reputation")) {
    serviceType = "ghost-score-check";
  } else if (text.includes("credential") || text.includes("issue")) {
    serviceType = "credential-issuance";
  } else if (text.includes("register") && text.includes("agent")) {
    serviceType = "agent-registration";
  } else if (text.includes("create") && text.includes("did")) {
    serviceType = "did-creation";
  } else if (text.includes("resolve") && text.includes("did")) {
    serviceType = "did-resolution";
  }
  const signatureMatch = message.content.text?.match(/signature[:\s]+([A-Za-z0-9]{87,88})/i);
  const payerMatch = message.content.text?.match(/payer[:\s]+([A-HJ-NP-Za-km-z1-9]{32,44})/i);
  const amountMatch = message.content.text?.match(/amount[:\s]+(\d+)/i);
  return {
    serviceType,
    paymentSignature: signatureMatch?.[1],
    payerAddress: payerMatch?.[1],
    amount: amountMatch?.[1]
  };
}
async function verifyPaymentWithPayAI(signature2, expectedAmount, merchantAddress) {
  try {
    const response = await fetch(`${PAYAI_FACILITATOR_URL}/verify`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        signature: signature2,
        expectedAmount: Math.floor(expectedAmount * 1e6),
        merchantAddress,
        network: "solana"
      })
    });
    if (!response.ok) {
      const error = await response.text();
      return { valid: false, error: `PayAI verification failed: ${error}` };
    }
    const result = await response.json();
    return { valid: result.valid === true, error: result.error };
  } catch (error) {
    logger6.error({ error }, "PayAI verification error");
    return {
      valid: false,
      error: error instanceof Error ? error.message : "Verification failed"
    };
  }
}
var acceptPaymentAction = {
  name: "ACCEPT_PAYMENT",
  similes: [
    "PROCESS_PAYMENT",
    "HANDLE_PAYMENT",
    "PAID_REQUEST",
    "X402_PAYMENT",
    "PAYAI_PAYMENT"
  ],
  description: `Accept x402 payments for GhostSpeak services via PayAI facilitator.
Pricing is dynamic based on the agent's Ghost Score tier:
- Platinum (900+): 2x base price (premium services)
- Gold (750-899): 1.5x base price
- Silver (500-749): 1.2x base price
- Bronze (200-499): 1x base price
- Newcomer (<200): 0.8x base price (introductory)

Supports: ghost-score-check, credential-issuance, agent-registration, did-creation`,
  validate: async (_runtime, message, _state) => {
    const text = message.content.text?.toLowerCase() || "";
    return text.includes("pay") || text.includes("purchase") || text.includes("buy") || text.includes("402") || text.includes("x402") || text.includes("service") && text.includes("price");
  },
  handler: async (runtime, message, _state, _options, callback, _responses) => {
    try {
      const service = runtime.getService("ghostspeak");
      if (!service) {
        throw new Error("GhostSpeak service not available");
      }
      const request = parsePaymentRequest(message);
      if (!request) {
        throw new Error("Could not parse payment request");
      }
      let agentGhostScore = 500;
      try {
        const stats = service.getStats();
        agentGhostScore = 500;
      } catch {
        logger6.warn("Could not fetch agent Ghost Score, using default");
      }
      const tier = getPricingTier(agentGhostScore);
      const price = calculatePrice(request.serviceType, agentGhostScore);
      const priceInMicroUsdc = Math.floor(price * 1e6);
      const merchantAddress = process.env.GHOSTSPEAK_MERCHANT_ADDRESS || process.env.AGENT_WALLET_ADDRESS;
      if (!merchantAddress) {
        throw new Error("GHOSTSPEAK_MERCHANT_ADDRESS not configured - required for x402 payments");
      }
      if (!request.paymentSignature) {
        const paymentRequiredResponse = `\uD83D\uDCB0 **Payment Required**

**Service**: ${request.serviceType}
**Price**: $${price.toFixed(4)} USDC
**Tier**: ${tier} (Ghost Score: ${agentGhostScore})

**Payment Details:**
- Network: Solana
- Currency: USDC
- Amount: ${priceInMicroUsdc} micro-USDC
- Merchant: ${merchantAddress.slice(0, 8)}...${merchantAddress.slice(-8)}
- Facilitator: PayAI (${PAYAI_FACILITATOR_URL})

**To pay:**
1. Send USDC to merchant address via x402
2. Include payment signature in your next request
3. Format: "signature: <tx-signature>, payer: <your-address>"

Or use PayAI client: \`npx @payai/cli pay ${merchantAddress} ${priceInMicroUsdc}\``;
        if (callback) {
          await callback({
            text: paymentRequiredResponse,
            actions: ["ACCEPT_PAYMENT"],
            source: message.content.source
          });
        }
        return {
          success: false,
          text: paymentRequiredResponse,
          values: {
            paymentRequired: true,
            serviceType: request.serviceType,
            price,
            priceInMicroUsdc,
            tier,
            merchantAddress,
            facilitator: PAYAI_FACILITATOR_URL
          },
          data: {
            status: "payment_required",
            httpStatus: 402,
            payment: {
              amount: priceInMicroUsdc,
              amountUsd: price,
              currency: "USDC",
              network: "solana",
              merchant: merchantAddress,
              facilitator: "payai",
              facilitatorUrl: PAYAI_FACILITATOR_URL
            }
          }
        };
      }
      logger6.info({
        signature: request.paymentSignature,
        amount: price,
        merchant: merchantAddress
      }, "Verifying payment with PayAI");
      const verification = await verifyPaymentWithPayAI(request.paymentSignature, price, merchantAddress);
      if (!verification.valid) {
        const errorMsg = `âŒ Payment verification failed: ${verification.error}

Please ensure:
- Transaction was sent to ${merchantAddress.slice(0, 8)}...
- Amount is at least ${priceInMicroUsdc} micro-USDC
- Transaction is confirmed on Solana`;
        if (callback) {
          await callback({
            text: errorMsg,
            actions: ["ACCEPT_PAYMENT"],
            source: message.content.source
          });
        }
        return {
          success: false,
          text: errorMsg,
          values: {
            paymentVerified: false,
            error: verification.error
          },
          error: new Error(verification.error || "Payment verification failed")
        };
      }
      logger6.info({
        signature: request.paymentSignature,
        serviceType: request.serviceType
      }, "Payment verified, executing service");
      const successMsg = `âœ… **Payment Verified!**

**Transaction**: ${request.paymentSignature.slice(0, 16)}...
**Service**: ${request.serviceType}
**Amount**: $${price.toFixed(4)} USDC

Your request is being processed. The ${request.serviceType} service will execute now.

*Ghost Score impact: +5 points for successful transaction*`;
      if (callback) {
        await callback({
          text: successMsg,
          actions: ["ACCEPT_PAYMENT"],
          source: message.content.source
        });
      }
      return {
        success: true,
        text: successMsg,
        values: {
          paymentVerified: true,
          serviceType: request.serviceType,
          price,
          signature: request.paymentSignature,
          tier
        },
        data: {
          status: "payment_verified",
          payment: {
            signature: request.paymentSignature,
            amount: priceInMicroUsdc,
            amountUsd: price,
            verified: true
          },
          service: {
            type: request.serviceType,
            executed: true
          }
        }
      };
    } catch (error) {
      logger6.error({ error }, "Error processing payment");
      const errorMsg = `Failed to process payment: ${error instanceof Error ? error.message : "Unknown error"}`;
      if (callback) {
        await callback({
          text: errorMsg,
          actions: ["ACCEPT_PAYMENT"],
          source: message.content.source
        });
      }
      return {
        success: false,
        text: errorMsg,
        values: {},
        error: error instanceof Error ? error : new Error(String(error))
      };
    }
  },
  examples: [
    [
      {
        name: "{{userName}}",
        content: {
          text: "I want to pay for a ghost score check",
          actions: []
        }
      },
      {
        name: "{{agentName}}",
        content: {
          text: `\uD83D\uDCB0 **Payment Required**

**Service**: ghost-score-check
**Price**: $0.0120 USDC
**Tier**: SILVER

To pay, send USDC via x402 to the merchant address.`,
          actions: ["ACCEPT_PAYMENT"]
        }
      }
    ],
    [
      {
        name: "{{userName}}",
        content: {
          text: "Pay for credential issuance, signature: 5jHDw...xyz, payer: 7xKXt...abc",
          actions: []
        }
      },
      {
        name: "{{agentName}}",
        content: {
          text: `âœ… **Payment Verified!**

**Transaction**: 5jHDw...xyz
**Service**: credential-issuance
**Amount**: $0.06 USDC

Your request is being processed.`,
          actions: ["ACCEPT_PAYMENT"]
        }
      }
    ],
    [
      {
        name: "{{userName}}",
        content: {
          text: "I want to purchase agent registration service",
          actions: []
        }
      },
      {
        name: "{{agentName}}",
        content: {
          text: `\uD83D\uDCB0 **Payment Required**

**Service**: agent-registration
**Price**: $0.10 USDC
**Tier**: SILVER (Ghost Score: 500)

**Payment Details:**
- Network: Solana
- Currency: USDC
- Facilitator: PayAI

Send payment and include the signature in your next request.`,
          actions: ["ACCEPT_PAYMENT"]
        }
      }
    ]
  ]
};
// src/actions/didActions.ts
init_index_node5();
import { logger as logger7 } from "@elizaos/core";
var createDidAction = {
  name: "CREATE_DID",
  similes: ["CREATE_DID_DOCUMENT", "REGISTER_DID", "NEW_DID"],
  description: "Create a W3C-compliant Decentralized Identifier (DID) document on GhostSpeak blockchain. DIDs provide verifiable, decentralized digital identity for AI agents.",
  validate: async (_runtime, message, _state) => {
    const text = message.content.text?.toLowerCase() || "";
    return text.includes("create did") || text.includes("register did") || text.includes("new did document") || text.includes("create identifier");
  },
  handler: async (runtime, message, _state, _options, callback, _responses) => {
    try {
      if (!runtime.agentId) {
        const errorMsg = "Agent ID not available in runtime";
        if (callback) {
          await callback({
            text: errorMsg,
            actions: ["CREATE_DID"],
            source: message.content.source
          });
        }
        return {
          success: false,
          text: errorMsg,
          error: new Error("Agent ID required")
        };
      }
      let agentAddress;
      try {
        agentAddress = address(runtime.agentId);
      } catch {
        const errorMsg = "Agent ID is not a valid Solana address";
        if (callback) {
          await callback({
            text: errorMsg,
            actions: ["CREATE_DID"],
            source: message.content.source
          });
        }
        return {
          success: false,
          text: errorMsg,
          error: new Error("Invalid agent address")
        };
      }
      const text = message.content.text || "";
      const nameMatch = text.match(/name[:\s]+([^\s,]+)/i);
      const didName = nameMatch ? nameMatch[1] : runtime.character?.name || "Agent";
      const instructions2 = `To create a DID document for agent "${didName}" (${agentAddress}):

1. **Using GhostSpeak CLI:**
   \`\`\`bash
   ghost did create --controller ${agentAddress}
   \`\`\`

2. **Using GhostSpeak SDK:**
   \`\`\`typescript
   import { GhostSpeakClient } from '@ghostspeak/sdk';

   const client = new GhostSpeakClient({ cluster: 'devnet' });
   const did = await client.did.createDidDocument(signer, {
     controller: '${agentAddress}',
     verificationMethods: [{
       type: 'Ed25519VerificationKey2020',
       publicKey: signerPublicKey
     }]
   });

   console.log('DID Created:', did.didString);
   // Example: did:sol:devnet:${agentAddress.slice(0, 8)}...
   \`\`\`

3. **What you get:**
   - W3C-compliant DID string (did:sol:devnet:...)
   - On-chain DID document with verification methods
   - Service endpoints for agent discovery
   - Ability to update/deactivate DID later

4. **Why create a DID:**
   - Verifiable identity across platforms
   - Cryptographic proof of ownership
   - Interoperable with W3C standards
   - Required for verifiable credentials`;
      if (callback) {
        await callback({
          text: instructions2,
          actions: ["CREATE_DID"],
          source: message.content.source
        });
      }
      return {
        success: true,
        text: instructions2,
        data: {
          agentAddress: agentAddress.toString(),
          agentName: didName,
          cluster: process.env.SOLANA_CLUSTER || "devnet"
        }
      };
    } catch (error) {
      logger7.error({ error }, "Error creating DID:");
      const errorMsg = `Failed to create DID: ${error instanceof Error ? error.message : "Unknown error"}`;
      if (callback) {
        await callback({
          text: errorMsg,
          actions: ["CREATE_DID"],
          source: message.content.source
        });
      }
      return {
        success: false,
        text: errorMsg,
        error: error instanceof Error ? error : new Error(String(error))
      };
    }
  },
  examples: [
    [
      {
        name: "{{userName}}",
        content: {
          text: "Create a DID document for my agent",
          actions: []
        }
      },
      {
        name: "{{agentName}}",
        content: {
          text: "I can help you create a W3C-compliant DID document. This will give you a verifiable decentralized identifier on the Solana blockchain.",
          actions: ["CREATE_DID"]
        }
      }
    ]
  ]
};
var resolveDidAction = {
  name: "RESOLVE_DID",
  similes: ["GET_DID", "LOOKUP_DID", "FETCH_DID_DOCUMENT"],
  description: "Resolve and fetch a W3C DID document from the GhostSpeak blockchain. Returns verification methods, service endpoints, and DID metadata.",
  validate: async (_runtime, message, _state) => {
    const text = message.content.text?.toLowerCase() || "";
    return text.includes("resolve did") || text.includes("get did") || text.includes("lookup did") || text.includes("fetch did") || text.includes("did:sol:");
  },
  handler: async (runtime, message, _state, _options, callback, _responses) => {
    try {
      const text = message.content.text || "";
      const didMatch = text.match(/did:sol:(devnet|mainnet|testnet):([A-Za-z0-9]{32,44})/);
      const addressMatch = text.match(/([A-Za-z0-9]{32,44})/);
      let targetAddress;
      if (didMatch) {
        targetAddress = address(didMatch[2]);
      } else if (addressMatch) {
        try {
          targetAddress = address(addressMatch[1]);
        } catch {}
      } else if (runtime.agentId) {
        try {
          targetAddress = address(runtime.agentId);
        } catch {}
      }
      if (!targetAddress) {
        const errorMsg = "Please provide a DID string (did:sol:devnet:...) or agent address";
        if (callback) {
          await callback({
            text: errorMsg,
            actions: ["RESOLVE_DID"],
            source: message.content.source
          });
        }
        return {
          success: false,
          text: errorMsg,
          error: new Error("DID or address required")
        };
      }
      const service = runtime.getService("ghostspeak");
      if (!service) {
        throw new Error("GhostSpeak service not available");
      }
      const didDocument = await service.did().resolve(targetAddress);
      if (!didDocument) {
        const errorMsg = `No DID document found for ${targetAddress}`;
        if (callback) {
          await callback({
            text: errorMsg,
            actions: ["RESOLVE_DID"],
            source: message.content.source
          });
        }
        return {
          success: false,
          text: errorMsg,
          error: new Error("DID not found")
        };
      }
      const response = `DID Document for ${targetAddress}:

\uD83D\uDCCB **DID Information:**
- DID String: ${didDocument.did || `did:sol:${process.env.SOLANA_CLUSTER || "devnet"}:${targetAddress}`}
- Controller: ${didDocument.controller?.toString() || targetAddress}
- Status: ${didDocument.deactivated ? "\uD83D\uDD34 Deactivated" : "\uD83D\uDFE2 Active"}

\uD83D\uDD11 **Verification Methods:** ${didDocument.verificationMethods?.length || 0}
${didDocument.verificationMethods?.map((vm, i) => `  ${i + 1}. ${vm.methodType} (ID: ${vm.id})`).join(`
`) || "None"}

\uD83D\uDD0C **Service Endpoints:** ${didDocument.serviceEndpoints?.length || 0}
${didDocument.serviceEndpoints?.map((s3, i) => `  ${i + 1}. ${s3.serviceType}: ${s3.serviceEndpoint}`).join(`
`) || "None"}

\uD83D\uDCC5 **Timestamps:**
- Created: ${didDocument.createdAt ? new Date(Number(didDocument.createdAt) * 1000).toISOString() : "Unknown"}
- Updated: ${didDocument.updatedAt ? new Date(Number(didDocument.updatedAt) * 1000).toISOString() : "Never"}`;
      if (callback) {
        await callback({
          text: response,
          actions: ["RESOLVE_DID"],
          source: message.content.source
        });
      }
      return {
        success: true,
        text: response,
        data: {
          didString: didDocument.did,
          controller: didDocument.controller?.toString(),
          isActive: !didDocument.deactivated,
          verificationMethodCount: didDocument.verificationMethods?.length || 0,
          serviceEndpointCount: didDocument.serviceEndpoints?.length || 0
        }
      };
    } catch (error) {
      logger7.error({ error }, "Error resolving DID:");
      const errorMsg = `Failed to resolve DID: ${error instanceof Error ? error.message : "Unknown error"}`;
      if (callback) {
        await callback({
          text: errorMsg,
          actions: ["RESOLVE_DID"],
          source: message.content.source
        });
      }
      return {
        success: false,
        text: errorMsg,
        error: error instanceof Error ? error : new Error(String(error))
      };
    }
  },
  examples: [
    [
      {
        name: "{{userName}}",
        content: {
          text: "Resolve DID for 7xKXt...9Gk",
          actions: []
        }
      },
      {
        name: "{{agentName}}",
        content: {
          text: `DID Document for 7xKXt...9Gk:
\uD83D\uDCCB DID String: did:sol:devnet:7xKXt...9Gk
\uD83D\uDFE2 Active
\uD83D\uDD11 2 Verification Methods
\uD83D\uDD0C 1 Service Endpoint`,
          actions: ["RESOLVE_DID"]
        }
      }
    ]
  ]
};
var updateDidAction = {
  name: "UPDATE_DID",
  similes: ["MODIFY_DID", "UPDATE_DID_DOCUMENT", "CHANGE_DID"],
  description: "Update a DID document by adding/removing verification methods or service endpoints. Requires controller authority.",
  validate: async (_runtime, message, _state) => {
    const text = message.content.text?.toLowerCase() || "";
    return text.includes("update did") || text.includes("modify did") || text.includes("change did") || text.includes("add verification") || text.includes("add service endpoint");
  },
  handler: async (runtime, message, _state, _options, callback, _responses) => {
    try {
      const instructions2 = `To update a DID document:

**Using GhostSpeak CLI:**
\`\`\`bash
# Add verification method
ghost did update --add-verification-method <type> <public-key>

# Add service endpoint
ghost did update --add-service <type> <endpoint-url>

# Remove verification method
ghost did update --remove-verification-method <method-id>
\`\`\`

**Using GhostSpeak SDK:**
\`\`\`typescript
await client.did.updateDidDocument(signer, {
  did: 'did:sol:devnet:...',
  addVerificationMethods: [{
    type: 'Ed25519VerificationKey2020',
    publicKey: newPublicKey
  }],
  addServices: [{
    type: 'AgentService',
    endpoint: 'https://myagent.com/api'
  }]
});
\`\`\`

**What you can update:**
- âœ… Add/remove verification methods (keys)
- âœ… Add/remove service endpoints
- âœ… Update controller (transfer ownership)
- âŒ Cannot change DID string itself

**Requirements:**
- Must be the controller of the DID
- Need wallet signature to authorize changes
- Changes are recorded on-chain`;
      if (callback) {
        await callback({
          text: instructions2,
          actions: ["UPDATE_DID"],
          source: message.content.source
        });
      }
      return {
        success: true,
        text: instructions2
      };
    } catch (error) {
      logger7.error({ error }, "Error updating DID:");
      const errorMsg = `Failed to update DID: ${error instanceof Error ? error.message : "Unknown error"}`;
      if (callback) {
        await callback({
          text: errorMsg,
          actions: ["UPDATE_DID"],
          source: message.content.source
        });
      }
      return {
        success: false,
        text: errorMsg,
        error: error instanceof Error ? error : new Error(String(error))
      };
    }
  },
  examples: [
    [
      {
        name: "{{userName}}",
        content: {
          text: "Update my DID document to add a new service endpoint",
          actions: []
        }
      },
      {
        name: "{{agentName}}",
        content: {
          text: "I can help you update your DID document. You can add verification methods or service endpoints.",
          actions: ["UPDATE_DID"]
        }
      }
    ]
  ]
};
// src/actions/protocolActions.ts
import { logger as logger8 } from "@elizaos/core";
var stakeGhostAction = {
  name: "STAKE_GHOST",
  similes: ["STAKE_TOKENS", "LOCK_GHOST", "DEPOSIT_GHOST"],
  description: "Stake GHOST tokens to increase reputation weight and earn staking rewards. Staked tokens are locked for a minimum period.",
  validate: async (_runtime, message, _state) => {
    const text = message.content.text?.toLowerCase() || "";
    return text.includes("stake") || text.includes("lock ghost") || text.includes("deposit ghost");
  },
  handler: async (runtime, message, _state, _options, callback, _responses) => {
    try {
      const text = message.content.text || "";
      const amountMatch = text.match(/(\d+(?:\.\d+)?)\s*(?:ghost|tokens?)/i);
      const amount = amountMatch ? amountMatch[1] : "0";
      const instructions2 = `To stake GHOST tokens:

**Using GhostSpeak CLI:**
\`\`\`bash
ghost staking stake --amount ${amount || "100"}
\`\`\`

**Using GhostSpeak SDK:**
\`\`\`typescript
const client = new GhostSpeakClient({ cluster: 'devnet' });
await client.staking.stakeGhost(signer, {
  amount: ${amount || "100"} * 10**9, // Convert to lamports
});
\`\`\`

**Benefits of Staking:**
- \uD83D\uDCC8 Increase reputation weight (1.5x multiplier)
- \uD83D\uDCB0 Earn staking rewards (variable APY)
- \uD83C\uDFC6 Unlock higher tiers faster
- \uD83D\uDD12 Minimum lock period: 7 days

**Current Status:**
- Staked Amount: Check with \`ghost staking status\`
- Available Rewards: Auto-compound daily
- Unstaking: 7-day cooldown period`;
      if (callback) {
        await callback({
          text: instructions2,
          actions: ["STAKE_GHOST"],
          source: message.content.source
        });
      }
      return {
        success: true,
        text: instructions2,
        data: { requestedAmount: amount }
      };
    } catch (error) {
      logger8.error({ error }, "Error staking GHOST:");
      const errorMsg = `Failed to stake GHOST: ${error instanceof Error ? error.message : "Unknown error"}`;
      if (callback) {
        await callback({
          text: errorMsg,
          actions: ["STAKE_GHOST"],
          source: message.content.source
        });
      }
      return {
        success: false,
        text: errorMsg,
        error: error instanceof Error ? error : new Error(String(error))
      };
    }
  },
  examples: [
    [
      {
        name: "{{userName}}",
        content: {
          text: "Stake 100 GHOST tokens",
          actions: []
        }
      },
      {
        name: "{{agentName}}",
        content: {
          text: "Staking GHOST tokens boosts your reputation weight by 1.5x!",
          actions: ["STAKE_GHOST"]
        }
      }
    ]
  ]
};
var checkStakingAction = {
  name: "CHECK_STAKING",
  similes: ["STAKING_STATUS", "MY_STAKES", "STAKING_INFO"],
  description: "Check your GHOST token staking status, rewards, and unlock schedule.",
  validate: async (_runtime, message, _state) => {
    const text = message.content.text?.toLowerCase() || "";
    return text.includes("staking status") || text.includes("check stake") || text.includes("my stakes") || text.includes("staking info");
  },
  handler: async (runtime, message, _state, _options, callback, _responses) => {
    try {
      const response = `Use these commands to check staking status:

**CLI:**
\`\`\`bash
ghost staking status
\`\`\`

**SDK:**
\`\`\`typescript
const status = await client.staking.getStakingStatus(agentAddress);
console.log('Staked:', status.stakedAmount);
console.log('Rewards:', status.pendingRewards);
console.log('Unlock Time:', status.unlockTimestamp);
\`\`\``;
      if (callback) {
        await callback({
          text: response,
          actions: ["CHECK_STAKING"],
          source: message.content.source
        });
      }
      return {
        success: true,
        text: response
      };
    } catch (error) {
      logger8.error({ error }, "Error checking staking:");
      return {
        success: false,
        text: `Failed to check staking: ${error instanceof Error ? error.message : "Unknown error"}`,
        error: error instanceof Error ? error : new Error(String(error))
      };
    }
  },
  examples: []
};
var setPrivacyModeAction = {
  name: "SET_PRIVACY_MODE",
  similes: ["PRIVACY_MODE", "HIDE_REPUTATION", "PRIVACY_SETTINGS"],
  description: "Set privacy mode for reputation visibility: PUBLIC, SELECTIVE, or PRIVATE.",
  validate: async (_runtime, message, _state) => {
    const text = message.content.text?.toLowerCase() || "";
    return text.includes("privacy") || text.includes("hide reputation") || text.includes("private mode");
  },
  handler: async (runtime, message, _state, _options, callback, _responses) => {
    try {
      const text = message.content.text?.toLowerCase() || "";
      let mode = "SELECTIVE";
      if (text.includes("public"))
        mode = "PUBLIC";
      else if (text.includes("private"))
        mode = "PRIVATE";
      const response = `Privacy mode settings:

**Modes:**
- \uD83C\uDF10 PUBLIC: All reputation data visible
- \uD83C\uDFAF SELECTIVE: Show tier/range only (default)
- \uD83D\uDD12 PRIVATE: Hide all reputation data

**Current Mode Detected:** ${mode}

**To set privacy:**
\`\`\`bash
ghost privacy set-mode --mode ${mode.toLowerCase()}
\`\`\`

**SDK:**
\`\`\`typescript
await client.privacy.setPrivacyMode(signer, {
  mode: '${mode}'
});
\`\`\`

**Note:** Privacy settings only affect public viewing. Counterparties in transactions can always verify your reputation.`;
      if (callback) {
        await callback({
          text: response,
          actions: ["SET_PRIVACY_MODE"],
          source: message.content.source
        });
      }
      return {
        success: true,
        text: response,
        data: { mode }
      };
    } catch (error) {
      logger8.error({ error }, "Error setting privacy:");
      return {
        success: false,
        text: `Failed to set privacy: ${error instanceof Error ? error.message : "Unknown error"}`,
        error: error instanceof Error ? error : new Error(String(error))
      };
    }
  },
  examples: [
    [
      {
        name: "{{userName}}",
        content: {
          text: "Set my reputation to private mode",
          actions: []
        }
      },
      {
        name: "{{agentName}}",
        content: {
          text: "I can help you configure privacy settings. Private mode hides all reputation data from public view.",
          actions: ["SET_PRIVACY_MODE"]
        }
      }
    ]
  ]
};
var createEscrowAction = {
  name: "CREATE_ESCROW",
  similes: ["NEW_ESCROW", "GHOST_PROTECT", "CREATE_GHOST_PROTECT"],
  description: "Create a Ghost Protect escrow for secure B2C transactions with buyer protection.",
  validate: async (_runtime, message, _state) => {
    const text = message.content.text?.toLowerCase() || "";
    return text.includes("create escrow") || text.includes("new escrow") || text.includes("ghost protect") || text.includes("buyer protection");
  },
  handler: async (runtime, message, _state, _options, callback, _responses) => {
    try {
      const text = message.content.text || "";
      const amountMatch = text.match(/(\d+(?:\.\d+)?)\s*(?:sol|usdc)/i);
      const amount = amountMatch ? amountMatch[1] : "0";
      const response = `Create Ghost Protect Escrow:

**What is Ghost Protect?**
B2C escrow system with:
- âœ… Buyer protection (refund if service not delivered)
- â±ï¸ 7-day delivery window
- âš–ï¸ Dispute resolution
- \uD83D\uDD12 Funds locked until delivery approved

**CLI:**
\`\`\`bash
ghost escrow create \\
  --buyer <buyer-address> \\
  --amount ${amount || "1.0"} \\
  --token SOL \\
  --description "Service delivery"
\`\`\`

**SDK:**
\`\`\`typescript
const escrow = await client.escrow.createEscrow(signer, {
  buyer: buyerAddress,
  amount: ${amount || "1.0"} * 10**9,
  deliveryDeadline: 7 * 24 * 60 * 60, // 7 days
});
\`\`\`

**Process:**
1. Agent creates escrow
2. Buyer funds escrow
3. Agent delivers service
4. Agent submits proof of delivery
5. Buyer approves â†’ funds released
6. Or dispute filed â†’ arbitration`;
      if (callback) {
        await callback({
          text: response,
          actions: ["CREATE_ESCROW"],
          source: message.content.source
        });
      }
      return {
        success: true,
        text: response,
        data: { amount }
      };
    } catch (error) {
      logger8.error({ error }, "Error creating escrow:");
      return {
        success: false,
        text: `Failed to create escrow: ${error instanceof Error ? error.message : "Unknown error"}`,
        error: error instanceof Error ? error : new Error(String(error))
      };
    }
  },
  examples: []
};
// src/providers/ghost-score.ts
init_index_node5();
import { logger as logger9 } from "@elizaos/core";
function getGhostScoreTier2(ghostScore) {
  if (ghostScore >= 9000)
    return "PLATINUM";
  if (ghostScore >= 7500)
    return "GOLD";
  if (ghostScore >= 5000)
    return "SILVER";
  if (ghostScore >= 2000)
    return "BRONZE";
  return "NEWCOMER";
}
var ghostScoreProvider = {
  name: "GHOST_SCORE_PROVIDER",
  description: "Provides Ghost Score reputation data for agents from on-chain GhostSpeak data",
  get: async (runtime, _message, _state) => {
    try {
      const service = runtime.getService("ghostspeak");
      if (!service) {
        logger9.debug("Ghost Score Provider: GhostSpeak service not available");
        return {
          text: "GhostSpeak service not available",
          values: {},
          data: {}
        };
      }
      if (!runtime.agentId) {
        logger9.debug("Ghost Score Provider: No agent ID available in runtime");
        return {
          text: "No agent ID available",
          values: {},
          data: {}
        };
      }
      let agentAddress;
      try {
        agentAddress = address(runtime.agentId);
        logger9.debug({ agentAddress: agentAddress.toString() }, "Ghost Score Provider: Resolved agent address");
      } catch (error) {
        logger9.warn({ agentId: runtime.agentId, error }, "Ghost Score Provider: Invalid agent ID format");
        return {
          text: "Agent ID is not a valid Solana address",
          values: {},
          data: {}
        };
      }
      let agentData;
      try {
        agentData = await service.getAgent(agentAddress);
        logger9.debug({ found: !!agentData }, "Ghost Score Provider: Fetched agent account");
      } catch (error) {
        logger9.error({ agentAddress: agentAddress.toString(), error }, "Ghost Score Provider: Failed to fetch agent");
        return {
          text: `Failed to fetch agent data: ${error instanceof Error ? error.message : "Unknown error"}`,
          values: {},
          data: {
            error: error instanceof Error ? error.message : "Unknown error",
            source: "blockchain"
          }
        };
      }
      if (!agentData) {
        logger9.warn({ agentAddress: agentAddress.toString() }, "Ghost Score Provider: Agent not found");
        return {
          text: "Agent not found on GhostSpeak blockchain",
          values: { registered: false },
          data: {
            agentAddress: agentAddress.toString(),
            source: "blockchain"
          }
        };
      }
      const onChainGhostScore = Number(agentData.ghostScore || 0);
      const reputationScore = Number(agentData.reputationScore || 0);
      const ghostScore = onChainGhostScore > 0 ? Math.min(1e4, Math.round(onChainGhostScore / 1e5)) : Math.min(1e4, Math.round(reputationScore / 10));
      const tier = getGhostScoreTier2(ghostScore);
      const totalJobs = Number(agentData.totalJobsCompleted || 0);
      const successRate = totalJobs > 0 ? 100 : 0;
      const reputationData = {
        ghostScore,
        tier,
        agentAddress: agentAddress.toString(),
        agentName: agentData.name || "Unknown Agent",
        totalJobsCompleted: totalJobs,
        successRate,
        isActive: agentData.isActive || false,
        reputationScoreBasisPoints: reputationScore,
        createdAt: agentData.createdAt ? Number(agentData.createdAt) : null,
        x402Enabled: agentData.x402Enabled || false,
        x402TotalCalls: agentData.x402TotalCalls ? Number(agentData.x402TotalCalls) : 0,
        x402TotalPayments: agentData.x402TotalPayments ? Number(agentData.x402TotalPayments) : 0,
        source: "blockchain",
        fetchedAt: Date.now()
      };
      logger9.debug({ ghostScore, tier, totalJobs }, "Ghost Score Provider: Calculated reputation data");
      return {
        text: `Ghost Score: ${ghostScore}/10000 (${tier} tier) - ${totalJobs} jobs completed, ${successRate}% success rate`,
        values: {
          ghostScore,
          tier,
          totalJobs,
          successRate,
          isActive: agentData.isActive,
          agentAddress: agentAddress.toString()
        },
        data: reputationData
      };
    } catch (error) {
      logger9.error({ error }, "Error in Ghost Score provider");
      return {
        text: `Unable to fetch Ghost Score: ${error instanceof Error ? error.message : "Unknown error"}`,
        values: {},
        data: {
          error: error instanceof Error ? error.message : "Unknown error",
          timestamp: Date.now()
        }
      };
    }
  }
};
// src/providers/agent-context.ts
init_index_node5();
import { logger as logger10 } from "@elizaos/core";
var agentContextProvider = {
  name: "AGENT_CONTEXT_PROVIDER",
  description: "Provides agent identity and capabilities context from GhostSpeak blockchain",
  get: async (runtime, _message, _state) => {
    try {
      const service = runtime.getService("ghostspeak");
      if (!service) {
        return {
          text: "GhostSpeak service not available",
          values: { registered: false, serviceAvailable: false },
          data: {}
        };
      }
      const hasSigner = service.hasSigner();
      const signerAddress = service.getSignerAddress();
      if (!runtime.agentId) {
        return {
          text: "No agent context available",
          values: {
            registered: false,
            hasSigner,
            signerAddress: signerAddress?.toString() || null
          },
          data: {}
        };
      }
      let agentAddress;
      try {
        agentAddress = address(runtime.agentId);
      } catch {
        return {
          text: "Agent ID is not a valid Solana address",
          values: {
            registered: false,
            hasSigner,
            invalidAgentId: true
          },
          data: {}
        };
      }
      let agentData;
      try {
        agentData = await service.getAgent(agentAddress);
      } catch (error) {
        logger10.warn({ error, agentAddress: agentAddress.toString() }, "Failed to fetch agent context");
        return {
          text: "Unable to fetch agent data",
          values: {
            registered: false,
            hasSigner,
            agentAddress: agentAddress.toString()
          },
          data: {
            error: error instanceof Error ? error.message : "Unknown error"
          }
        };
      }
      if (!agentData) {
        return {
          text: "Agent not registered on GhostSpeak",
          values: {
            registered: false,
            hasSigner,
            agentAddress: agentAddress.toString(),
            canRegister: hasSigner
          },
          data: {}
        };
      }
      const context = {
        registered: true,
        agentAddress: agentAddress.toString(),
        name: agentData.name,
        description: agentData.description,
        agentType: agentData.agentType,
        isActive: agentData.isActive,
        x402Enabled: agentData.x402Enabled,
        hasSigner,
        createdAt: agentData.createdAt ? Number(agentData.createdAt) : null,
        metadataUri: agentData.metadataUri
      };
      const statusText = agentData.isActive ? "Active" : "Inactive";
      const x402Text = agentData.x402Enabled ? "x402 Payments: Enabled" : "";
      return {
        text: `Agent: ${agentData.name} | Type: ${agentData.agentType} | ${statusText}${x402Text ? " | " + x402Text : ""}`,
        values: context,
        data: {
          description: agentData.description,
          metadataUri: agentData.metadataUri,
          fullAgentData: agentData
        }
      };
    } catch (error) {
      logger10.error({ error }, "Error in Agent Context provider");
      return {
        text: "Agent context unavailable",
        values: {},
        data: {
          error: error instanceof Error ? error.message : "Unknown error"
        }
      };
    }
  }
};
// src/config.ts
import { z } from "zod";
var ghostspeakConfigSchema = z.object({
  AGENT_WALLET_PRIVATE_KEY: z.string().optional().describe("Agent wallet private key (base58, hex, or JSON array format)"),
  SOLANA_CLUSTER: z.enum(["devnet", "mainnet-beta", "testnet"]).optional().default("devnet").describe("Solana cluster (devnet, mainnet-beta, testnet)"),
  SOLANA_RPC_URL: z.string().url().optional().describe("Custom Solana RPC endpoint URL"),
  CROSSMINT_SECRET_KEY: z.string().optional().describe("Crossmint API secret key for credential bridging"),
  CROSSMINT_REPUTATION_TEMPLATE_ID: z.string().optional().describe("Crossmint template ID for reputation credentials"),
  CROSSMINT_ENV: z.enum(["staging", "production"]).optional().describe("Crossmint environment (staging or production)"),
  CROSSMINT_CHAIN: z.string().optional().default("base-sepolia").describe("EVM chain for Crossmint (e.g., base-sepolia, polygon)"),
  STAKING_CONFIG_ADDRESS: z.string().optional().describe("Staking configuration account address"),
  GHOST_TOKEN_MINT: z.string().optional().describe("GHOST token mint address"),
  ESCROW_TOKEN_MINT: z.string().optional().default("So11111111111111111111111111111111111111112").describe("Token mint for escrow operations (default: Native SOL)"),
  GHOSTSPEAK_MERCHANT_ADDRESS: z.string().optional().describe("Solana address to receive x402 payments (USDC)"),
  PAYAI_FACILITATOR_URL: z.string().url().optional().default("https://facilitator.payai.network").describe("PayAI facilitator URL for x402 payment verification")
});

// src/plugin.ts
var ghostspeakPlugin = {
  name: "plugin-ghostspeak",
  description: "GhostSpeak - AI agent reputation, credentials, and identity on Solana",
  config: {
    AGENT_WALLET_PRIVATE_KEY: process.env.AGENT_WALLET_PRIVATE_KEY,
    SOLANA_CLUSTER: process.env.SOLANA_CLUSTER,
    SOLANA_RPC_URL: process.env.SOLANA_RPC_URL,
    CROSSMINT_SECRET_KEY: process.env.CROSSMINT_SECRET_KEY,
    CROSSMINT_REPUTATION_TEMPLATE_ID: process.env.CROSSMINT_REPUTATION_TEMPLATE_ID,
    CROSSMINT_ENV: process.env.CROSSMINT_ENV,
    GHOSTSPEAK_MERCHANT_ADDRESS: process.env.GHOSTSPEAK_MERCHANT_ADDRESS,
    PAYAI_FACILITATOR_URL: process.env.PAYAI_FACILITATOR_URL
  },
  async init(config) {
    logger11.info("Initializing GhostSpeak plugin");
    try {
      const validatedConfig = await ghostspeakConfigSchema.parseAsync(config);
      for (const [key, value] of Object.entries(validatedConfig)) {
        if (value !== undefined && value !== null) {
          process.env[key] = String(value);
        }
      }
      logger11.info({
        cluster: validatedConfig.SOLANA_CLUSTER || "devnet",
        hasWallet: !!validatedConfig.AGENT_WALLET_PRIVATE_KEY,
        hasCrossmint: !!validatedConfig.CROSSMINT_SECRET_KEY
      }, "GhostSpeak plugin configured");
    } catch (error) {
      if (error instanceof z2.ZodError) {
        const errorMessages = error.issues?.map((e8) => e8.message)?.join(", ") || "Unknown validation error";
        throw new Error(`Invalid plugin configuration: ${errorMessages}`);
      }
      throw new Error(`Invalid plugin configuration: ${error instanceof Error ? error.message : String(error)}`);
    }
  },
  services: [GhostSpeakService],
  actions: [
    checkGhostScoreAction,
    registerAgentAction,
    issueCredentialAction,
    acceptPaymentAction,
    createDidAction,
    resolveDidAction,
    updateDidAction,
    stakeGhostAction,
    checkStakingAction,
    setPrivacyModeAction,
    createEscrowAction
  ],
  providers: [ghostScoreProvider, agentContextProvider],
  events: {
    MESSAGE_RECEIVED: [
      async (payload) => {
        logger11.debug({ roomId: payload.message?.roomId }, "GhostSpeak: Message received");
      }
    ],
    ACTION_COMPLETED: [
      async (payload) => {
        const action = payload.action || "";
        const result = payload.result || {};
        if (result.success && typeof action === "string" && action.includes("GHOST")) {
          logger11.info({ action, data: result.data }, "GhostSpeak action completed");
        }
      }
    ]
  }
};
var starterPlugin = ghostspeakPlugin;
var plugin_default = ghostspeakPlugin;

// src/index.ts
var src_default = plugin_default;
export {
  updateDidAction,
  starterPlugin,
  stakeGhostAction,
  setPrivacyModeAction,
  resolveDidAction,
  registerAgentAction,
  issueCredentialAction,
  hasWalletConfigured,
  ghostspeakPlugin,
  ghostspeakConfigSchema,
  ghostScoreProvider,
  getAgentSigner,
  getAgentBalance,
  getAgentAddress,
  formatSolBalance,
  exportPublicKey,
  ensureFundedWallet,
  src_default as default,
  createEscrowAction,
  createDidAction,
  checkStakingAction,
  checkGhostScoreAction,
  airdropToAgent,
  agentContextProvider,
  acceptPaymentAction,
  GhostSpeakService as StarterService,
  GhostSpeakService
};

//# debugId=951BB062353667FD64756E2164756E21
//# sourceMappingURL=index.js.map
