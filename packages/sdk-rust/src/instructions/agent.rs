use std::sync::Arc;

use async_trait::async_trait;
use borsh::{BorshSerialize, BorshDeserialize};
use solana_sdk::{
    instruction::{AccountMeta, Instruction},
    pubkey::Pubkey,
    signature::Keypair,
    signer::Signer,
    system_program,
};
use tracing::{debug, instrument};

use crate::{
    client::PodAIClient,
    client::transaction_factory::{TransactionFactory, TransactionResult},
    errors::{PodAIError, PodAIResult},
    instructions::{ComputeUnitEstimator, InstructionBuilder},
    types::agent::{AgentAccount, AgentCapabilities},
    utils::find_agent_pda,
    impl_instruction_builder_basics,
};

// Instruction discriminators generated by Anchor (8-byte sighash)
// These are the first 8 bytes of the SHA256 hash of "global:<instruction_name>"
const REGISTER_AGENT_DISCRIMINATOR: [u8; 8] = [135, 157, 66, 195, 2, 113, 175, 30];
const UPDATE_AGENT_DISCRIMINATOR: [u8; 8] = [219, 200, 88, 176, 158, 63, 253, 127];

// Instruction data structures that match the Anchor program
#[derive(BorshSerialize, BorshDeserialize, Debug, Clone)]
pub struct RegisterAgentInstructionData {
    pub agent_type: u8,
    pub metadata_uri: String,
}

#[derive(BorshSerialize, BorshDeserialize, Debug, Clone)]
pub struct UpdateAgentInstructionData {
    pub agent_type: u8,
    pub metadata_uri: String,
}

/// Result of agent registration
#[derive(Debug, Clone)]
pub struct AgentRegistrationResult {
    pub signature: solana_sdk::signature::Signature,
    pub agent_pda: Pubkey,
    pub capabilities: u64,
    pub metadata_uri: String,
    pub transaction_result: TransactionResult,
}

/// Builder for agent registration instruction
pub struct AgentRegistrationBuilder {
    client: Arc<PodAIClient>,
    signer: Option<Keypair>,
    capabilities: Option<u64>,
    metadata_uri: Option<String>,
    transaction_factory: Option<TransactionFactory>,
}

impl AgentRegistrationBuilder {
    pub fn new(client: Arc<PodAIClient>) -> Self {
        Self {
            client,
            signer: None,
            capabilities: None,
            metadata_uri: None,
            transaction_factory: None,
        }
    }

    /// Set the signer (agent keypair)
    pub fn signer(mut self, signer: Keypair) -> Self {
        self.signer = Some(signer);
        self
    }

    /// Set agent capabilities
    pub fn capabilities(mut self, capabilities: AgentCapabilities) -> Self {
        self.capabilities = Some(capabilities.bits());
        self
    }

    /// Set agent capabilities from raw bits
    pub fn capabilities_raw(mut self, capabilities: u64) -> Self {
        self.capabilities = Some(capabilities);
        self
    }

    /// Set metadata URI
    pub fn metadata_uri(mut self, uri: impl Into<String>) -> Self {
        self.metadata_uri = Some(uri.into());
        self
    }

    /// Set custom transaction factory
    pub fn transaction_factory(mut self, factory: TransactionFactory) -> Self {
        self.transaction_factory = Some(factory);
        self
    }

    /// Validate all parameters before building
    fn validate_params(&self) -> PodAIResult<()> {
        if self.signer.is_none() {
            return Err(PodAIError::InvalidInput {
                field: "signer".to_string(),
                reason: "Signer is required for agent registration".to_string(),
            });
        }

        if self.capabilities.is_none() {
            return Err(PodAIError::InvalidInput {
                field: "capabilities".to_string(),
                reason: "Capabilities are required for agent registration".to_string(),
            });
        }

        if let Some(uri) = &self.metadata_uri {
            if uri.len() > 200 {
                return Err(PodAIError::InvalidInput {
                    field: "metadata_uri".to_string(),
                    reason: "Metadata URI too long (max 200 chars)".to_string(),
                });
            }

            if !uri.starts_with("https://") {
                return Err(PodAIError::InvalidInput {
                    field: "metadata_uri".to_string(),
                    reason: "Metadata URI must use HTTPS".to_string(),
                });
            }
        }

        Ok(())
    }

    /// Execute the agent registration
    #[instrument(skip(self), fields(capabilities = ?self.capabilities))]
    pub async fn execute(self) -> PodAIResult<AgentRegistrationResult> {
        debug!("Executing agent registration");
        
        self.validate_params()?;

        let signer = self.signer.unwrap();
        let capabilities = self.capabilities.unwrap();
        let metadata_uri = self.metadata_uri.unwrap_or_default();

        let factory = self.transaction_factory.unwrap_or_else(|| {
            TransactionFactory::new(self.client.clone())
        });

        let instruction_builder = AgentRegistrationInstructionBuilder {
            client: self.client.clone(),
            signer: signer.clone(),
            capabilities,
            metadata_uri: metadata_uri.clone(),
        };

        let instructions = instruction_builder.build().await?;
        let signers = vec![&signer];

        let transaction_result = factory
            .execute_transaction(instructions, &signers, Some(&signer.pubkey()))
            .await?;

        let agent_pda = find_agent_pda(&signer.pubkey());

        Ok(AgentRegistrationResult {
            signature: transaction_result.signature,
            agent_pda,
            capabilities,
            metadata_uri,
            transaction_result,
        })
    }
}

/// Internal instruction builder for agent registration
struct AgentRegistrationInstructionBuilder {
    client: Arc<PodAIClient>,
    signer: Keypair,
    capabilities: u64,
    metadata_uri: String,
}

#[async_trait]
impl InstructionBuilder for AgentRegistrationInstructionBuilder {
    async fn build(&self) -> PodAIResult<Vec<Instruction>> {
        let agent_pda = find_agent_pda(&self.signer.pubkey());
        
        // Check if agent already exists
        if let Ok(_existing_agent) = self.client.get_account(&agent_pda).await {
            return Err(PodAIError::InvalidInput {
                field: "agent".to_string(),
                reason: "Agent already registered".to_string(),
            });
        }

        // Build the register agent instruction
        let instruction = build_register_agent_instruction(
            &self.signer.pubkey(),
            &agent_pda,
            self.capabilities,
            &self.metadata_uri,
        )?;

        Ok(vec![instruction])
    }

    fn payer(&self) -> Pubkey {
        self.signer.pubkey()
    }

    fn signers(&self) -> Vec<&Keypair> {
        vec![&self.signer]
    }

    fn instruction_type(&self) -> &'static str {
        "register_agent"
    }

    fn validate(&self) -> PodAIResult<()> {
        if self.metadata_uri.len() > 200 {
            return Err(PodAIError::ValidationFailed {
                field: "metadata_uri".to_string(),
                reason: "URI too long".to_string(),
            });
        }
        Ok(())
    }
}

impl ComputeUnitEstimator for AgentRegistrationInstructionBuilder {
    fn estimate_compute_units(&self) -> u32 {
        // Agent registration is relatively simple
        50_000
    }
}

/// Builder for agent update instruction
pub struct AgentUpdateBuilder {
    client: Arc<PodAIClient>,
    signer: Option<Keypair>,
    capabilities: Option<u64>,
    metadata_uri: Option<String>,
    transaction_factory: Option<TransactionFactory>,
}

impl AgentUpdateBuilder {
    pub fn new(client: Arc<PodAIClient>) -> Self {
        Self {
            client,
            signer: None,
            capabilities: None,
            metadata_uri: None,
            transaction_factory: None,
        }
    }

    /// Set the signer (agent keypair)
    pub fn signer(mut self, signer: Keypair) -> Self {
        self.signer = Some(signer);
        self
    }

    /// Set new capabilities (optional)
    pub fn capabilities(mut self, capabilities: AgentCapabilities) -> Self {
        self.capabilities = Some(capabilities.bits());
        self
    }

    /// Set new metadata URI (optional)
    pub fn metadata_uri(mut self, uri: impl Into<String>) -> Self {
        self.metadata_uri = Some(uri.into());
        self
    }

    /// Set custom transaction factory
    pub fn transaction_factory(mut self, factory: TransactionFactory) -> Self {
        self.transaction_factory = Some(factory);
        self
    }

    /// Execute the agent update
    #[instrument(skip(self))]
    pub async fn execute(self) -> PodAIResult<TransactionResult> {
        debug!("Executing agent update");

        let signer = self.signer.ok_or_else(|| PodAIError::InvalidInput {
            field: "signer".to_string(),
            reason: "Signer is required for agent update".to_string(),
        })?;

        // Verify agent exists
        let agent_pda = find_agent_pda(&signer.pubkey());
        let _agent_account = self.client
            .get_account(&agent_pda)
            .await
            .map_err(|_| PodAIError::AccountNotFound {
                account_type: "Agent".to_string(),
                address: agent_pda.to_string(),
            })?;

        let factory = self.transaction_factory.unwrap_or_else(|| {
            TransactionFactory::new(self.client.clone())
        });

        let instruction_builder = AgentUpdateInstructionBuilder {
            client: self.client.clone(),
            signer: signer.clone(),
            capabilities: self.capabilities,
            metadata_uri: self.metadata_uri,
        };

        let instructions = instruction_builder.build().await?;
        let signers = vec![&signer];

        factory
            .execute_transaction(instructions, &signers, Some(&signer.pubkey()))
            .await
    }
}

/// Internal instruction builder for agent updates
struct AgentUpdateInstructionBuilder {
    client: Arc<PodAIClient>,
    signer: Keypair,
    capabilities: Option<u64>,
    metadata_uri: Option<String>,
}

#[async_trait]
impl InstructionBuilder for AgentUpdateInstructionBuilder {
    async fn build(&self) -> PodAIResult<Vec<Instruction>> {
        let agent_pda = find_agent_pda(&self.signer.pubkey());

        let instruction = build_update_agent_instruction(
            &self.signer.pubkey(),
            &agent_pda,
            self.capabilities,
            self.metadata_uri.as_deref(),
        )?;

        Ok(vec![instruction])
    }

    fn payer(&self) -> Pubkey {
        self.signer.pubkey()
    }

    fn signers(&self) -> Vec<&Keypair> {
        vec![&self.signer]
    }

    fn instruction_type(&self) -> &'static str {
        "update_agent"
    }

    fn validate(&self) -> PodAIResult<()> {
        if let Some(uri) = &self.metadata_uri {
            if uri.len() > 200 {
                return Err(PodAIError::ValidationFailed {
                    field: "metadata_uri".to_string(),
                    reason: "URI too long".to_string(),
                });
            }
        }
        Ok(())
    }
}

impl ComputeUnitEstimator for AgentUpdateInstructionBuilder {
    fn estimate_compute_units(&self) -> u32 {
        // Agent update is simpler than registration
        30_000
    }
}

// Helper functions to build actual Solana instructions with proper Anchor serialization

fn build_register_agent_instruction(
    signer: &Pubkey,
    agent_pda: &Pubkey,
    capabilities: u64,
    metadata_uri: &str,
) -> PodAIResult<Instruction> {
    // Find the user registry PDA
    let (user_registry_pda, _) = Pubkey::find_program_address(
        &[b"user_registry", signer.as_ref()],
        &crate::PROGRAM_ID,
    );
    
    // Build accounts in the order expected by the Anchor program
    let accounts = vec![
        AccountMeta::new(*agent_pda, false),           // agent_account (writable)
        AccountMeta::new(user_registry_pda, false),    // user_registry (writable)
        AccountMeta::new(*signer, true),                // signer (writable, signer)
        AccountMeta::new_readonly(system_program::id(), false), // system_program
    ];

    // Create instruction data with Anchor discriminator
    let mut instruction_data = Vec::new();
    instruction_data.extend_from_slice(&REGISTER_AGENT_DISCRIMINATOR);
    
    // Convert capabilities to agent_type (u8)
    // For now, we'll use the lower 8 bits of capabilities as agent_type
    let agent_type = (capabilities & 0xFF) as u8;
    
    // Serialize the instruction arguments
    let args = RegisterAgentInstructionData {
        agent_type,
        metadata_uri: metadata_uri.to_string(),
    };
    
    args.serialize(&mut instruction_data)
        .map_err(|e| PodAIError::SerializationError {
            message: format!("Failed to serialize register_agent instruction: {}", e),
        })?;
    
    Ok(Instruction {
        program_id: crate::PROGRAM_ID,
        accounts,
        data: instruction_data,
    })
}

fn build_update_agent_instruction(
    signer: &Pubkey,
    agent_pda: &Pubkey,
    capabilities: Option<u64>,
    metadata_uri: Option<&str>,
) -> PodAIResult<Instruction> {
    // Build accounts in the order expected by the Anchor program
    let accounts = vec![
        AccountMeta::new(*agent_pda, false),     // agent_account (writable)
        AccountMeta::new_readonly(*signer, true), // signer (signer)
    ];

    // Create instruction data with Anchor discriminator
    let mut instruction_data = Vec::new();
    instruction_data.extend_from_slice(&UPDATE_AGENT_DISCRIMINATOR);
    
    // For update, we need to provide both fields even if not changing
    // This matches the Anchor program's expectation
    let agent_type = if let Some(caps) = capabilities {
        (caps & 0xFF) as u8
    } else {
        // Default to 0 if not updating capabilities
        0u8
    };
    
    let metadata_uri_str = metadata_uri.unwrap_or("").to_string();
    
    // Serialize the instruction arguments
    let args = UpdateAgentInstructionData {
        agent_type,
        metadata_uri: metadata_uri_str,
    };
    
    args.serialize(&mut instruction_data)
        .map_err(|e| PodAIError::SerializationError {
            message: format!("Failed to serialize update_agent instruction: {}", e),
        })?;
    
    Ok(Instruction {
        program_id: crate::PROGRAM_ID,
        accounts,
        data: instruction_data,
    })
}

#[cfg(test)]
mod tests {
    use super::*;
    use solana_sdk::signature::Keypair;

    #[tokio::test]
    async fn test_agent_registration_builder() {
        let client = Arc::new(PodAIClient::devnet().await.unwrap());
        let signer = Keypair::new();
        
        let builder = AgentRegistrationBuilder::new(client)
            .signer(signer)
            .capabilities(AgentCapabilities::Communication)
            .metadata_uri("https://example.com/metadata.json");
        
        // Test validation
        assert!(builder.validate_params().is_ok());
    }

    #[test]
    fn test_agent_registration_validation() {
        let client = Arc::new(PodAIClient::devnet().await.unwrap());
        
        // Test missing signer
        let builder = AgentRegistrationBuilder::new(client.clone())
            .capabilities(AgentCapabilities::Communication)
            .metadata_uri("https://example.com/metadata.json");
        
        assert!(builder.validate_params().is_err());
        
        // Test invalid URI
        let signer = Keypair::new();
        let builder = AgentRegistrationBuilder::new(client)
            .signer(signer)
            .capabilities(AgentCapabilities::Communication)
            .metadata_uri("http://insecure.com/metadata.json");
        
        assert!(builder.validate_params().is_err());
    }
} 