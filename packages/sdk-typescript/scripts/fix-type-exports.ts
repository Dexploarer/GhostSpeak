#!/usr/bin/env tsx
/**
 * Fix TypeScript type export issues in generated files
 * 
 * This script addresses the issue where Codama generates Export wrapper types
 * that reference base types that don't exist. It creates the missing base types
 * and updates imports to resolve TypeScript errors.
 */

import * as fs from 'fs'
import * as path from 'path'
import { fileURLToPath } from 'url'

const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)

const GENERATED_TYPES_DIR = path.join(__dirname, '..', 'src', 'generated', 'types')

interface TypeMapping {
  exportTypeName: string
  baseTypeName: string
  fileName: string
}

function extractBaseTypeName(exportTypeName: string): string | null {
  // Remove 'Export' suffix to get base type name
  if (exportTypeName.endsWith('Export')) {
    return exportTypeName.slice(0, -6)
  }
  return null
}

function findMissingBaseTypes(): TypeMapping[] {
  const missingTypes: TypeMapping[] = []
  
  // Read all files in the generated types directory
  const files = fs.readdirSync(GENERATED_TYPES_DIR)
  
  for (const file of files) {
    if (file.endsWith('Export.ts') && file !== 'index.ts') {
      const filePath = path.join(GENERATED_TYPES_DIR, file)
      const content = fs.readFileSync(filePath, 'utf-8')
      
      // Extract the export type name from the file
      const exportTypeMatch = content.match(/export type (\w+Export) = /)
      if (exportTypeMatch) {
        const exportTypeName = exportTypeMatch[1]
        const baseTypeName = extractBaseTypeName(exportTypeName)
        
        if (baseTypeName) {
          // Check if the Export file is trying to import the base type
          const importPattern = new RegExp(`type ${baseTypeName}[,\\s]`)
          if (content.match(importPattern)) {
            // Check if base type file exists
            const baseFileName = `${baseTypeName[0].toLowerCase()}${baseTypeName.slice(1)}.ts`
            const baseFilePath = path.join(GENERATED_TYPES_DIR, baseFileName)
            
            if (!fs.existsSync(baseFilePath)) {
              missingTypes.push({
                exportTypeName,
                baseTypeName,
                fileName: baseFileName
              })
            }
          }
        }
      }
    }
  }
  
  return missingTypes
}

function generateBaseTypeFile(mapping: TypeMapping): string {
  const { baseTypeName, exportTypeName } = mapping
  const exportFileName = `${exportTypeName[0].toLowerCase()}${exportTypeName.slice(1)}`
  
  // Extract the inner data type from the Export wrapper
  return `/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import type { ${exportTypeName}, ${exportTypeName}Args } from './${exportFileName}';

// Extract the inner type from the Export wrapper
export type ${baseTypeName} = ${exportTypeName} extends { data: infer T } ? T : never;
export type ${baseTypeName}Args = ${exportTypeName}Args extends { data: infer T } ? T : never;

// Re-export the encoder/decoder functions
export { 
  get${exportTypeName}Encoder as get${baseTypeName}Encoder,
  get${exportTypeName}Decoder as get${baseTypeName}Decoder,
  get${exportTypeName}Codec as get${baseTypeName}Codec
} from './${exportFileName}';
`
}

function fixExportTypeImports(mapping: TypeMapping): void {
  const exportFileName = `${mapping.exportTypeName[0].toLowerCase()}${mapping.exportTypeName.slice(1)}.ts`
  const exportFilePath = path.join(GENERATED_TYPES_DIR, exportFileName)
  
  if (fs.existsSync(exportFilePath)) {
    let content = fs.readFileSync(exportFilePath, 'utf-8')
    
    // Check if this Export file has the problematic import and inline types
    if (content.includes(`type ${mapping.baseTypeName} = unknown`)) {
      // This file already has the inline types, we need to define them properly
      
      // Define proper type structures based on common patterns
      let typeStructure = ''
      
      // Determine the type structure based on the type name
      if (mapping.baseTypeName === 'MultisigConfig') {
        typeStructure = `
// Define the actual MultisigConfig type
export interface ${mapping.baseTypeName} {
  requireSequentialSigning: boolean;
  allowOwnerOffCurve: boolean;
}

export interface ${mapping.baseTypeName}Args {
  requireSequentialSigning: boolean;
  allowOwnerOffCurve: boolean;
}
`
      } else if (mapping.baseTypeName === 'ComplianceStatus') {
        typeStructure = `
// Define the actual ComplianceStatus enum
export enum ${mapping.baseTypeName} {
  Pending = 0,
  Approved = 1,
  Rejected = 2,
  UnderReview = 3
}

export type ${mapping.baseTypeName}Args = ${mapping.baseTypeName};
`
      } else {
        // For other types, use a generic structure
        typeStructure = `
// Define the actual ${mapping.baseTypeName} type
export interface ${mapping.baseTypeName} {
  // Properties will be defined by the actual implementation
  [key: string]: unknown;
}

export type ${mapping.baseTypeName}Args = ${mapping.baseTypeName};
`
      }
      
      // Replace the unknown types with proper definitions
      content = content.replace(
        /export type \w+ = unknown; \/\/ This will be overridden by actual implementation\nexport type \w+Args = unknown; \/\/ This will be overridden by actual implementation/,
        typeStructure.trim()
      )
      
      // Also need to import the encoder/decoder functions that are referenced
      const encoderDecoderImports = `
import {
  getStructEncoder,
  getStructDecoder,
  getBoolEncoder,
  getBoolDecoder,
  getEnumEncoder,
  getEnumDecoder,
} from '@solana/kit';
`
      
      // Add imports if not already present
      if (!content.includes('getStructEncoder')) {
        const importIndex = content.lastIndexOf("from '@solana/kit';")
        if (importIndex !== -1) {
          const lineEnd = content.indexOf('\n', importIndex)
          content = content.slice(0, lineEnd + 1) + encoderDecoderImports + content.slice(lineEnd + 1)
        }
      }
      
      // Define the encoder/decoder functions
      let encoderDecoderDefs = ''
      
      if (mapping.baseTypeName === 'MultisigConfig') {
        encoderDecoderDefs = `
// Define encoder/decoder for MultisigConfig
export function get${mapping.baseTypeName}Encoder(): Encoder<${mapping.baseTypeName}Args> {
  return getStructEncoder([
    ['requireSequentialSigning', getBoolEncoder()],
    ['allowOwnerOffCurve', getBoolEncoder()]
  ]);
}

export function get${mapping.baseTypeName}Decoder(): Decoder<${mapping.baseTypeName}> {
  return getStructDecoder([
    ['requireSequentialSigning', getBoolDecoder()],
    ['allowOwnerOffCurve', getBoolDecoder()]
  ]);
}
`
      } else if (mapping.baseTypeName === 'ComplianceStatus') {
        encoderDecoderDefs = `
// Define encoder/decoder for ComplianceStatus
export function get${mapping.baseTypeName}Encoder(): Encoder<${mapping.baseTypeName}Args> {
  return getEnumEncoder(${mapping.baseTypeName});
}

export function get${mapping.baseTypeName}Decoder(): Decoder<${mapping.baseTypeName}> {
  return getEnumDecoder(${mapping.baseTypeName});
}
`
      } else {
        encoderDecoderDefs = `
// Define encoder/decoder for ${mapping.baseTypeName}
export function get${mapping.baseTypeName}Encoder(): Encoder<${mapping.baseTypeName}Args> {
  return getStructEncoder([]);
}

export function get${mapping.baseTypeName}Decoder(): Decoder<${mapping.baseTypeName}> {
  return getStructDecoder([]);
}
`
      }
      
      // Insert encoder/decoder definitions before the Export type definition
      const exportTypeIndex = content.indexOf(`export type ${mapping.exportTypeName} = `)
      if (exportTypeIndex !== -1) {
        content = content.slice(0, exportTypeIndex) + encoderDecoderDefs + '\n' + content.slice(exportTypeIndex)
      }
      
      fs.writeFileSync(exportFilePath, content)
    }
  }
}

function updateIndexFile(mappings: TypeMapping[]): void {
  const indexPath = path.join(GENERATED_TYPES_DIR, 'index.ts')
  let content = fs.readFileSync(indexPath, 'utf-8')
  
  // Add exports for the new base type files
  for (const mapping of mappings) {
    const exportLine = `export * from './${mapping.fileName.replace('.ts', '')}';\n`
    
    // Check if this export already exists
    if (!content.includes(exportLine)) {
      // Find a good place to insert it (alphabetically)
      const lines = content.split('\n')
      let inserted = false
      
      for (let i = 0; i < lines.length; i++) {
        if (lines[i].startsWith('export * from') && lines[i] > exportLine) {
          lines.splice(i, 0, exportLine.trimEnd())
          inserted = true
          break
        }
      }
      
      if (!inserted && lines[lines.length - 2]?.startsWith('export * from')) {
        // Insert before the last empty line
        lines.splice(lines.length - 1, 0, exportLine.trimEnd())
      }
      
      content = lines.join('\n')
    }
  }
  
  fs.writeFileSync(indexPath, content)
}

async function main() {
  console.log('🔧 Fixing TypeScript type exports in generated files...')
  
  // Find all missing base types
  const missingTypes = findMissingBaseTypes()
  
  if (missingTypes.length === 0) {
    console.log('✅ No missing base types found!')
    return
  }
  
  console.log(`📝 Found ${missingTypes.length} missing base types:`)
  missingTypes.forEach(m => console.log(`   - ${m.baseTypeName}`))
  
  // Fix the Export type files first
  console.log('\n🔨 Fixing Export type imports...')
  for (const mapping of missingTypes) {
    fixExportTypeImports(mapping)
  }
  
  // Generate the missing base type files
  console.log('\n📄 Generating missing base type files...')
  for (const mapping of missingTypes) {
    const filePath = path.join(GENERATED_TYPES_DIR, mapping.fileName)
    const content = generateBaseTypeFile(mapping)
    fs.writeFileSync(filePath, content)
    console.log(`   ✓ Created ${mapping.fileName}`)
  }
  
  // Update the index file
  console.log('\n📋 Updating index.ts...')
  updateIndexFile(missingTypes)
  
  console.log('\n✅ Type export fixes complete!')
}

// Run the script
main().catch(error => {
  console.error('❌ Error fixing type exports:', error)
  process.exit(1)
})