#!/usr/bin/env tsx

/**
 * Patch script to add missing nested type definitions that Codama doesn't generate
 * This is a workaround for Anchor IDL limitations with nested struct types
 */

import { writeFileSync, appendFileSync } from 'fs';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const GENERATED_TYPES_DIR = join(__dirname, '..', 'src', 'generated', 'types');

// Missing type definitions based on the Rust structs
const missingTypes = {
  // AuditContext from audit.rs
  auditContext: `/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  combineCodec,
  getOptionDecoder,
  getOptionEncoder,
  getStringDecoder,
  getStringEncoder,
  getStructDecoder,
  getStructEncoder,
  getU64Decoder,
  getU64Encoder,
  getU8Decoder,
  getU8Encoder,
  type Codec,
  type Decoder,
  type Encoder,
  type Option,
  type OptionOrNullable,
} from '@solana/kit';

export type AuditContext = {
  /** Transaction signature */
  transactionSignature: Option<string>;
  /** Block number */
  blockNumber: Option<bigint>;
  /** IP address (if available) */
  ipAddress: Option<string>;
  /** User agent string */
  userAgent: Option<string>;
  /** Geographic location */
  geoLocation: Option<string>;
  /** Session ID */
  sessionId: Option<string>;
  /** Risk score at time of action */
  riskScore: number;
  /** Additional metadata as JSON string */
  metadata: Option<string>;
};

export type AuditContextArgs = {
  /** Transaction signature */
  transactionSignature: OptionOrNullable<string>;
  /** Block number */
  blockNumber: OptionOrNullable<bigint>;
  /** IP address (if available) */
  ipAddress: OptionOrNullable<string>;
  /** User agent string */
  userAgent: OptionOrNullable<string>;
  /** Geographic location */
  geoLocation: OptionOrNullable<string>;
  /** Session ID */
  sessionId: OptionOrNullable<string>;
  /** Risk score at time of action */
  riskScore: number;
  /** Additional metadata as JSON string */
  metadata: OptionOrNullable<string>;
};

export function getAuditContextEncoder(): Encoder<AuditContextArgs> {
  return getStructEncoder([
    ['transactionSignature', getOptionEncoder(getStringEncoder())],
    ['blockNumber', getOptionEncoder(getU64Encoder())],
    ['ipAddress', getOptionEncoder(getStringEncoder())],
    ['userAgent', getOptionEncoder(getStringEncoder())],
    ['geoLocation', getOptionEncoder(getStringEncoder())],
    ['sessionId', getOptionEncoder(getStringEncoder())],
    ['riskScore', getU8Encoder()],
    ['metadata', getOptionEncoder(getStringEncoder())],
  ]);
}

export function getAuditContextDecoder(): Decoder<AuditContext> {
  return getStructDecoder([
    ['transactionSignature', getOptionDecoder(getStringDecoder())],
    ['blockNumber', getOptionDecoder(getU64Decoder())],
    ['ipAddress', getOptionDecoder(getStringDecoder())],
    ['userAgent', getOptionDecoder(getStringDecoder())],
    ['geoLocation', getOptionDecoder(getStringDecoder())],
    ['sessionId', getOptionDecoder(getStringDecoder())],
    ['riskScore', getU8Decoder()],
    ['metadata', getOptionDecoder(getStringDecoder())],
  ]);
}

export function getAuditContextCodec(): Codec<AuditContextArgs, AuditContext> {
  return combineCodec(getAuditContextEncoder(), getAuditContextDecoder());
}`,

  // BiometricQuality from security_governance.rs
  biometricQuality: `/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  combineCodec,
  getStructDecoder,
  getStructEncoder,
  getU8Decoder,
  getU8Encoder,
  type Codec,
  type Decoder,
  type Encoder,
} from '@solana/kit';

export type BiometricQuality = {
  /** Minimum quality score */
  minimumQuality: number;
  /** Liveness detection required */
  livenessRequired: boolean;
  /** Anti-spoofing required */
  antiSpoofingRequired: boolean;
  /** Maximum false acceptance rate */
  maxFalseAcceptanceRate: number;
  /** Maximum false rejection rate */
  maxFalseRejectionRate: number;
};

export type BiometricQualityArgs = BiometricQuality;

export function getBiometricQualityEncoder(): Encoder<BiometricQualityArgs> {
  return getStructEncoder([
    ['minimumQuality', getU8Encoder()],
    ['livenessRequired', getU8Encoder()],
    ['antiSpoofingRequired', getU8Encoder()],
    ['maxFalseAcceptanceRate', getU8Encoder()],
    ['maxFalseRejectionRate', getU8Encoder()],
  ]);
}

export function getBiometricQualityDecoder(): Decoder<BiometricQuality> {
  return getStructDecoder([
    ['minimumQuality', getU8Decoder()],
    ['livenessRequired', getU8Decoder()],
    ['antiSpoofingRequired', getU8Decoder()],
    ['maxFalseAcceptanceRate', getU8Decoder()],
    ['maxFalseRejectionRate', getU8Decoder()],
  ]);
}

export function getBiometricQualityCodec(): Codec<BiometricQualityArgs, BiometricQuality> {
  return combineCodec(getBiometricQualityEncoder(), getBiometricQualityDecoder());
}`,

  // ComplianceStatus from audit.rs
  complianceStatus: `/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  combineCodec,
  getAddressDecoder,
  getAddressEncoder,
  getI64Decoder,
  getI64Encoder,
  getStructDecoder,
  getStructEncoder,
  getU8Decoder,
  getU8Encoder,
  getVecDecoder,
  getVecEncoder,
  type Address,
  type Codec,
  type Decoder,
  type Encoder,
} from '@solana/kit';
import {
  getRiskAssessmentDecoder,
  getRiskAssessmentEncoder,
  getViolationSeverityDecoder,
  getViolationSeverityEncoder,
  type RiskAssessment,
  type RiskAssessmentArgs,
  type ViolationSeverity,
  type ViolationSeverityArgs,
} from '.';

export type ComplianceStatus = {
  /** Overall compliance score (0-100) */
  complianceScore: number;
  /** Last compliance review timestamp */
  lastReview: bigint;
  /** Next scheduled review */
  nextReview: bigint;
  /** Active compliance violations */
  activeViolations: Array<ViolationSeverity>;
  /** Regulatory status flags */
  regulatoryStatus: Array<string>;
  /** Risk assessment */
  riskAssessment: RiskAssessment;
  /** Compliance officers */
  complianceOfficers: Array<Address>;
};

export type ComplianceStatusArgs = {
  /** Overall compliance score (0-100) */
  complianceScore: number;
  /** Last compliance review timestamp */
  lastReview: number | bigint;
  /** Next scheduled review */
  nextReview: number | bigint;
  /** Active compliance violations */
  activeViolations: Array<ViolationSeverityArgs>;
  /** Regulatory status flags */
  regulatoryStatus: Array<string>;
  /** Risk assessment */
  riskAssessment: RiskAssessmentArgs;
  /** Compliance officers */
  complianceOfficers: Array<Address>;
};

export function getComplianceStatusEncoder(): Encoder<ComplianceStatusArgs> {
  return getStructEncoder([
    ['complianceScore', getU8Encoder()],
    ['lastReview', getI64Encoder()],
    ['nextReview', getI64Encoder()],
    ['activeViolations', getVecEncoder(getViolationSeverityEncoder())],
    ['regulatoryStatus', getVecEncoder(getStringEncoder())],
    ['riskAssessment', getRiskAssessmentEncoder()],
    ['complianceOfficers', getVecEncoder(getAddressEncoder())],
  ]);
}

export function getComplianceStatusDecoder(): Decoder<ComplianceStatus> {
  return getStructDecoder([
    ['complianceScore', getU8Decoder()],
    ['lastReview', getI64Decoder()],
    ['nextReview', getI64Decoder()],
    ['activeViolations', getVecDecoder(getViolationSeverityDecoder())],
    ['regulatoryStatus', getVecDecoder(getStringDecoder())],
    ['riskAssessment', getRiskAssessmentDecoder()],
    ['complianceOfficers', getVecDecoder(getAddressDecoder())],
  ]);
}

export function getComplianceStatusCodec(): Codec<ComplianceStatusArgs, ComplianceStatus> {
  return combineCodec(getComplianceStatusEncoder(), getComplianceStatusDecoder());
}`,

  // DynamicPricingConfig from pricing.rs
  dynamicPricingConfig: `/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  combineCodec,
  getStructDecoder,
  getStructEncoder,
  getU64Decoder,
  getU64Encoder,
  type Codec,
  type Decoder,
  type Encoder,
} from '@solana/kit';
import {
  getPricingAlgorithmDecoder,
  getPricingAlgorithmEncoder,
  type PricingAlgorithm,
  type PricingAlgorithmArgs,
} from '.';

export type DynamicPricingConfig = {
  algorithm: PricingAlgorithm;
  basePrice: bigint;
  minPrice: bigint;
  maxPrice: bigint;
  priceAdjustmentFactor: bigint;
  demandMultiplier: bigint;
  supplyMultiplier: bigint;
  timeDecayFactor: bigint;
  updateFrequency: bigint;
};

export type DynamicPricingConfigArgs = {
  algorithm: PricingAlgorithmArgs;
  basePrice: number | bigint;
  minPrice: number | bigint;
  maxPrice: number | bigint;
  priceAdjustmentFactor: number | bigint;
  demandMultiplier: number | bigint;
  supplyMultiplier: number | bigint;
  timeDecayFactor: number | bigint;
  updateFrequency: number | bigint;
};

export function getDynamicPricingConfigEncoder(): Encoder<DynamicPricingConfigArgs> {
  return getStructEncoder([
    ['algorithm', getPricingAlgorithmEncoder()],
    ['basePrice', getU64Encoder()],
    ['minPrice', getU64Encoder()],
    ['maxPrice', getU64Encoder()],
    ['priceAdjustmentFactor', getU64Encoder()],
    ['demandMultiplier', getU64Encoder()],
    ['supplyMultiplier', getU64Encoder()],
    ['timeDecayFactor', getU64Encoder()],
    ['updateFrequency', getU64Encoder()],
  ]);
}

export function getDynamicPricingConfigDecoder(): Decoder<DynamicPricingConfig> {
  return getStructDecoder([
    ['algorithm', getPricingAlgorithmDecoder()],
    ['basePrice', getU64Decoder()],
    ['minPrice', getU64Decoder()],
    ['maxPrice', getU64Decoder()],
    ['priceAdjustmentFactor', getU64Decoder()],
    ['demandMultiplier', getU64Decoder()],
    ['supplyMultiplier', getU64Decoder()],
    ['timeDecayFactor', getU64Decoder()],
    ['updateFrequency', getU64Decoder()],
  ]);
}

export function getDynamicPricingConfigCodec(): Codec<DynamicPricingConfigArgs, DynamicPricingConfig> {
  return combineCodec(getDynamicPricingConfigEncoder(), getDynamicPricingConfigDecoder());
}`,

  // MultisigConfig from governance.rs
  multisigConfig: `/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  combineCodec,
  getI64Decoder,
  getI64Encoder,
  getStructDecoder,
  getStructEncoder,
  getU8Decoder,
  getU8Encoder,
  getVecDecoder,
  getVecEncoder,
  type Codec,
  type Decoder,
  type Encoder,
} from '@solana/kit';
import {
  getTransactionTypeDecoder,
  getTransactionTypeEncoder,
  type TransactionType,
  type TransactionTypeArgs,
} from '.';

export type MultisigConfig = {
  /** Maximum number of signers */
  maxSigners: number;
  /** Default transaction timeout (seconds) */
  defaultTimeout: bigint;
  /** Allow threshold changes */
  allowThresholdChanges: boolean;
  /** Allow signer updates */
  allowSignerUpdates: boolean;
  /** Require sequential signing */
  requireSequentialSigning: boolean;
  /** Allow partial execution */
  allowPartialExecution: boolean;
  /** Transaction types allowed */
  allowedTransactionTypes: Array<TransactionType>;
  /** Cooldown period between transactions (seconds) */
  cooldownPeriod: bigint;
  /** Maximum pending transactions */
  maxPendingTransactions: number;
};

export type MultisigConfigArgs = {
  /** Maximum number of signers */
  maxSigners: number;
  /** Default transaction timeout (seconds) */
  defaultTimeout: number | bigint;
  /** Allow threshold changes */
  allowThresholdChanges: boolean;
  /** Allow signer updates */
  allowSignerUpdates: boolean;
  /** Require sequential signing */
  requireSequentialSigning: boolean;
  /** Allow partial execution */
  allowPartialExecution: boolean;
  /** Transaction types allowed */
  allowedTransactionTypes: Array<TransactionTypeArgs>;
  /** Cooldown period between transactions (seconds) */
  cooldownPeriod: number | bigint;
  /** Maximum pending transactions */
  maxPendingTransactions: number;
};

export function getMultisigConfigEncoder(): Encoder<MultisigConfigArgs> {
  return getStructEncoder([
    ['maxSigners', getU8Encoder()],
    ['defaultTimeout', getI64Encoder()],
    ['allowThresholdChanges', getU8Encoder()],
    ['allowSignerUpdates', getU8Encoder()],
    ['requireSequentialSigning', getU8Encoder()],
    ['allowPartialExecution', getU8Encoder()],
    ['allowedTransactionTypes', getVecEncoder(getTransactionTypeEncoder())],
    ['cooldownPeriod', getI64Encoder()],
    ['maxPendingTransactions', getU8Encoder()],
  ]);
}

export function getMultisigConfigDecoder(): Decoder<MultisigConfig> {
  return getStructDecoder([
    ['maxSigners', getU8Decoder()],
    ['defaultTimeout', getI64Decoder()],
    ['allowThresholdChanges', getU8Decoder()],
    ['allowSignerUpdates', getU8Decoder()],
    ['requireSequentialSigning', getU8Decoder()],
    ['allowPartialExecution', getU8Decoder()],
    ['allowedTransactionTypes', getVecDecoder(getTransactionTypeDecoder())],
    ['cooldownPeriod', getI64Decoder()],
    ['maxPendingTransactions', getU8Decoder()],
  ]);
}

export function getMultisigConfigCodec(): Codec<MultisigConfigArgs, MultisigConfig> {
  return combineCodec(getMultisigConfigEncoder(), getMultisigConfigDecoder());
}`,

  // Action from security_governance.rs
  action: `/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  combineCodec,
  getStringDecoder,
  getStringEncoder,
  getStructDecoder,
  getStructEncoder,
  getVecDecoder,
  getVecEncoder,
  type Codec,
  type Decoder,
  type Encoder,
} from '@solana/kit';

export type Action = {
  /** Action identifier */
  actionId: string;
  /** Action resource */
  resource: string;
  /** Action operation */
  operation: string;
  /** Action constraints */
  constraints: Array<string>;
};

export type ActionArgs = Action;

export function getActionEncoder(): Encoder<ActionArgs> {
  return getStructEncoder([
    ['actionId', getStringEncoder()],
    ['resource', getStringEncoder()],
    ['operation', getStringEncoder()],
    ['constraints', getVecEncoder(getStringEncoder())],
  ]);
}

export function getActionDecoder(): Decoder<Action> {
  return getStructDecoder([
    ['actionId', getStringDecoder()],
    ['resource', getStringDecoder()],
    ['operation', getStringDecoder()],
    ['constraints', getVecDecoder(getStringDecoder())],
  ]);
}

export function getActionCodec(): Codec<ActionArgs, Action> {
  return combineCodec(getActionEncoder(), getActionDecoder());
}`,

  // RuleCondition from security_governance.rs
  ruleCondition: `/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  combineCodec,
  getStringDecoder,
  getStringEncoder,
  getStructDecoder,
  getStructEncoder,
  type Codec,
  type Decoder,
  type Encoder,
} from '@solana/kit';
import {
  getConditionTypeDecoder,
  getConditionTypeEncoder,
  getValueTypeDecoder,
  getValueTypeEncoder,
  type ConditionType,
  type ConditionTypeArgs,
  type ValueType,
  type ValueTypeArgs,
} from '.';

export type RuleCondition = {
  /** Condition type */
  conditionType: ConditionType;
  /** Field to evaluate */
  field: string;
  /** Operator (e.g., "equals", "greater_than") */
  operator: string;
  /** Expected value */
  value: string;
  /** Value type for parsing */
  valueType: ValueType;
};

export type RuleConditionArgs = {
  /** Condition type */
  conditionType: ConditionTypeArgs;
  /** Field to evaluate */
  field: string;
  /** Operator (e.g., "equals", "greater_than") */
  operator: string;
  /** Expected value */
  value: string;
  /** Value type for parsing */
  valueType: ValueTypeArgs;
};

export function getRuleConditionEncoder(): Encoder<RuleConditionArgs> {
  return getStructEncoder([
    ['conditionType', getConditionTypeEncoder()],
    ['field', getStringEncoder()],
    ['operator', getStringEncoder()],
    ['value', getStringEncoder()],
    ['valueType', getValueTypeEncoder()],
  ]);
}

export function getRuleConditionDecoder(): Decoder<RuleCondition> {
  return getStructDecoder([
    ['conditionType', getConditionTypeDecoder()],
    ['field', getStringDecoder()],
    ['operator', getStringDecoder()],
    ['value', getStringDecoder()],
    ['valueType', getValueTypeDecoder()],
  ]);
}

export function getRuleConditionCodec(): Codec<RuleConditionArgs, RuleCondition> {
  return combineCodec(getRuleConditionEncoder(), getRuleConditionDecoder());
}`,

  // ReportEntry from audit.rs
  reportEntry: `/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  combineCodec,
  getI64Decoder,
  getI64Encoder,
  getStringDecoder,
  getStringEncoder,
  getStructDecoder,
  getStructEncoder,
  getU64Decoder,
  getU64Encoder,
  getU8Decoder,
  getU8Encoder,
  getVecDecoder,
  getVecEncoder,
  type Codec,
  type Decoder,
  type Encoder,
} from '@solana/kit';
import {
  getComplianceFlagsDecoder,
  getComplianceFlagsEncoder,
  getRiskIndicatorDecoder,
  getRiskIndicatorEncoder,
  type ComplianceFlags,
  type ComplianceFlagsArgs,
  type RiskIndicator,
  type RiskIndicatorArgs,
} from '.';

export type ReportEntry = {
  /** Entry timestamp */
  timestamp: bigint;
  /** Transaction ID */
  transactionId: bigint;
  /** Transaction amount */
  amount: bigint;
  /** Risk score */
  riskScore: number;
  /** Compliance flags */
  complianceFlags: ComplianceFlags;
  /** Risk indicators */
  riskIndicators: Array<RiskIndicator>;
  /** Anomalies detected */
  anomalies: Array<string>;
  /** Actions taken */
  actionsTaken: Array<string>;
};

export type ReportEntryArgs = {
  /** Entry timestamp */
  timestamp: number | bigint;
  /** Transaction ID */
  transactionId: number | bigint;
  /** Transaction amount */
  amount: number | bigint;
  /** Risk score */
  riskScore: number;
  /** Compliance flags */
  complianceFlags: ComplianceFlagsArgs;
  /** Risk indicators */
  riskIndicators: Array<RiskIndicatorArgs>;
  /** Anomalies detected */
  anomalies: Array<string>;
  /** Actions taken */
  actionsTaken: Array<string>;
};

export function getReportEntryEncoder(): Encoder<ReportEntryArgs> {
  return getStructEncoder([
    ['timestamp', getI64Encoder()],
    ['transactionId', getU64Encoder()],
    ['amount', getU64Encoder()],
    ['riskScore', getU8Encoder()],
    ['complianceFlags', getComplianceFlagsEncoder()],
    ['riskIndicators', getVecEncoder(getRiskIndicatorEncoder())],
    ['anomalies', getVecEncoder(getStringEncoder())],
    ['actionsTaken', getVecEncoder(getStringEncoder())],
  ]);
}

export function getReportEntryDecoder(): Decoder<ReportEntry> {
  return getStructDecoder([
    ['timestamp', getI64Decoder()],
    ['transactionId', getU64Decoder()],
    ['amount', getU64Decoder()],
    ['riskScore', getU8Decoder()],
    ['complianceFlags', getComplianceFlagsDecoder()],
    ['riskIndicators', getVecDecoder(getRiskIndicatorDecoder())],
    ['anomalies', getVecDecoder(getStringDecoder())],
    ['actionsTaken', getVecDecoder(getStringDecoder())],
  ]);
}

export function getReportEntryCodec(): Codec<ReportEntryArgs, ReportEntry> {
  return combineCodec(getReportEntryEncoder(), getReportEntryDecoder());
}`,

  // ResourceConstraints from security_governance.rs
  resourceConstraints: `/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  combineCodec,
  getOptionDecoder,
  getOptionEncoder,
  getStringDecoder,
  getStringEncoder,
  getStructDecoder,
  getStructEncoder,
  getU32Decoder,
  getU32Encoder,
  getU64Decoder,
  getU64Encoder,
  getVecDecoder,
  getVecEncoder,
  type Codec,
  type Decoder,
  type Encoder,
  type Option,
  type OptionOrNullable,
} from '@solana/kit';

export type ResourceConstraints = {
  /** Maximum operations per hour */
  maxOperationsPerHour: Option<number>;
  /** Maximum data size (bytes) */
  maxDataSize: Option<bigint>;
  /** Maximum transaction value */
  maxTransactionValue: Option<bigint>;
  /** Allowed resource types */
  allowedResourceTypes: Array<string>;
  /** Blocked resource patterns */
  blockedResourcePatterns: Array<string>;
  /** Quota reset period (seconds) */
  quotaResetPeriod: Option<bigint>;
};

export type ResourceConstraintsArgs = {
  /** Maximum operations per hour */
  maxOperationsPerHour: OptionOrNullable<number>;
  /** Maximum data size (bytes) */
  maxDataSize: OptionOrNullable<number | bigint>;
  /** Maximum transaction value */
  maxTransactionValue: OptionOrNullable<number | bigint>;
  /** Allowed resource types */
  allowedResourceTypes: Array<string>;
  /** Blocked resource patterns */
  blockedResourcePatterns: Array<string>;
  /** Quota reset period (seconds) */
  quotaResetPeriod: OptionOrNullable<number | bigint>;
};

export function getResourceConstraintsEncoder(): Encoder<ResourceConstraintsArgs> {
  return getStructEncoder([
    ['maxOperationsPerHour', getOptionEncoder(getU32Encoder())],
    ['maxDataSize', getOptionEncoder(getU64Encoder())],
    ['maxTransactionValue', getOptionEncoder(getU64Encoder())],
    ['allowedResourceTypes', getVecEncoder(getStringEncoder())],
    ['blockedResourcePatterns', getVecEncoder(getStringEncoder())],
    ['quotaResetPeriod', getOptionEncoder(getU64Encoder())],
  ]);
}

export function getResourceConstraintsDecoder(): Decoder<ResourceConstraints> {
  return getStructDecoder([
    ['maxOperationsPerHour', getOptionDecoder(getU32Decoder())],
    ['maxDataSize', getOptionDecoder(getU64Decoder())],
    ['maxTransactionValue', getOptionDecoder(getU64Decoder())],
    ['allowedResourceTypes', getVecDecoder(getStringDecoder())],
    ['blockedResourcePatterns', getVecDecoder(getStringDecoder())],
    ['quotaResetPeriod', getOptionDecoder(getU64Decoder())],
  ]);
}

export function getResourceConstraintsCodec(): Codec<ResourceConstraintsArgs, ResourceConstraints> {
  return combineCodec(getResourceConstraintsEncoder(), getResourceConstraintsDecoder());
}`,
};

// Write the missing type files
for (const [filename, content] of Object.entries(missingTypes)) {
  const filepath = join(GENERATED_TYPES_DIR, `${filename}.ts`);
  writeFileSync(filepath, content);
  console.log(`✅ Created missing type: ${filename}.ts`);
}

// Update the index.ts to export these types
const indexPath = join(GENERATED_TYPES_DIR, 'index.ts');
const indexContent = `
// Add exports for manually patched types
export * from './action';
export * from './auditContext';
export * from './biometricQuality';
export * from './complianceStatus';
export * from './dynamicPricingConfig';
export * from './multisigConfig';
export * from './reportEntry';
export * from './resourceConstraints';
export * from './ruleCondition';
`;

// Append to index.ts
appendFileSync(indexPath, indexContent);
console.log('✅ Updated index.ts with missing type exports');

console.log('\n🔧 Patch complete! Missing types have been added.');