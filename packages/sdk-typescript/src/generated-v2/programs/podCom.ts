/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import { type Address } from '@solana/addresses';
import {
  containsBytes,
  fixEncoderSize,
  getBytesEncoder,
  type ReadonlyUint8Array,
} from '@solana/codecs';
import {
  type ParsedAddParticipantInstruction,
  type ParsedBroadcastMessageInstruction,
  type ParsedCreateChannelInstruction,
  type ParsedRegisterAgentInstruction,
  type ParsedSendMessageInstruction,
} from '../instructions';

export const POD_COM_PROGRAM_ADDRESS =
  '367WUUpQTxXYUZqFyo9rDpgfJtH7mfGxX9twahdUmaEK' as Address<'367WUUpQTxXYUZqFyo9rDpgfJtH7mfGxX9twahdUmaEK'>;

export enum PodComAccount {
  AgentAccount,
  ChannelAccount,
  MessageAccount,
}

export function identifyPodComAccount(
  account: { data: ReadonlyUint8Array } | ReadonlyUint8Array
): PodComAccount {
  const data = 'data' in account ? account.data : account;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([241, 119, 69, 140, 233, 9, 112, 50])
      ),
      0
    )
  ) {
    return PodComAccount.AgentAccount;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([89, 117, 191, 67, 201, 23, 89, 155])
      ),
      0
    )
  ) {
    return PodComAccount.ChannelAccount;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([15, 40, 235, 178, 191, 96, 190, 12])
      ),
      0
    )
  ) {
    return PodComAccount.MessageAccount;
  }
  throw new Error(
    'The provided account could not be identified as a podCom account.'
  );
}

export enum PodComInstruction {
  RegisterAgent,
  CreateChannel,
  SendMessage,
  BroadcastMessage,
  AddParticipant,
}

export function identifyPodComInstruction(
  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array
): PodComInstruction {
  const data = 'data' in instruction ? instruction.data : instruction;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([135, 157, 66, 195, 2, 113, 175, 30])
      ),
      0
    )
  ) {
    return PodComInstruction.RegisterAgent;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([142, 179, 25, 199, 84, 243, 69, 80])
      ),
      0
    )
  ) {
    return PodComInstruction.CreateChannel;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([15, 40, 235, 178, 191, 96, 190, 12])
      ),
      0
    )
  ) {
    return PodComInstruction.SendMessage;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([82, 156, 47, 199, 117, 203, 24, 91])
      ),
      0
    )
  ) {
    return PodComInstruction.BroadcastMessage;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([201, 23, 89, 155, 12, 47, 199, 233])
      ),
      0
    )
  ) {
    return PodComInstruction.AddParticipant;
  }
  throw new Error(
    'The provided instruction could not be identified as a podCom instruction.'
  );
}

export type ParsedPodComInstruction<
  TProgram extends string = '367WUUpQTxXYUZqFyo9rDpgfJtH7mfGxX9twahdUmaEK',
> =
  | ({
      instructionType: PodComInstruction.RegisterAgent;
    } & ParsedRegisterAgentInstruction<TProgram>)
  | ({
      instructionType: PodComInstruction.CreateChannel;
    } & ParsedCreateChannelInstruction<TProgram>)
  | ({
      instructionType: PodComInstruction.SendMessage;
    } & ParsedSendMessageInstruction<TProgram>)
  | ({
      instructionType: PodComInstruction.BroadcastMessage;
    } & ParsedBroadcastMessageInstruction<TProgram>)
  | ({
      instructionType: PodComInstruction.AddParticipant;
    } & ParsedAddParticipantInstruction<TProgram>);
