/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  addDecoderSizePrefix,
  addEncoderSizePrefix,
  assertAccountExists,
  assertAccountsExist,
  combineCodec,
  decodeAccount,
  fetchEncodedAccount,
  fetchEncodedAccounts,
  fixDecoderSize,
  fixEncoderSize,
  getAddressDecoder,
  getAddressEncoder,
  getArrayDecoder,
  getArrayEncoder,
  getBytesDecoder,
  getBytesEncoder,
  getI64Decoder,
  getI64Encoder,
  getStructDecoder,
  getStructEncoder,
  getU32Decoder,
  getU32Encoder,
  getU64Decoder,
  getU64Encoder,
  getU8Decoder,
  getU8Encoder,
  getUtf8Decoder,
  getUtf8Encoder,
  transformEncoder,
  type Account,
  type Address,
  type Codec,
  type Decoder,
  type EncodedAccount,
  type Encoder,
  type FetchAccountConfig,
  type FetchAccountsConfig,
  type MaybeAccount,
  type MaybeEncodedAccount,
  type ReadonlyUint8Array,
} from "@solana/kit";
import {
  getSourceScoreDecoder,
  getSourceScoreEncoder,
  getTagScoreDecoder,
  getTagScoreEncoder,
  type SourceScore,
  type SourceScoreArgs,
  type TagScore,
  type TagScoreArgs,
} from "../types";

export const REPUTATION_METRICS_DISCRIMINATOR = new Uint8Array([
  8, 160, 71, 30, 66, 150, 108, 33,
]);

export function getReputationMetricsDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(
    REPUTATION_METRICS_DISCRIMINATOR,
  );
}

export type ReputationMetrics = {
  discriminator: ReadonlyUint8Array;
  /** Agent public key */
  agent: Address;
  /** Total successful x402 payments received */
  successfulPayments: bigint;
  /** Total failed x402 payment attempts */
  failedPayments: bigint;
  /** Cumulative response time in milliseconds */
  totalResponseTime: bigint;
  /** Number of response time measurements */
  responseTimeCount: bigint;
  /** Total disputes filed against agent for x402 services */
  totalDisputes: number;
  /** Disputes resolved favorably */
  disputesResolved: number;
  /** Sum of all client ratings (0-5 scale) */
  totalRating: number;
  /** Number of ratings submitted */
  totalRatingsCount: number;
  /** Rolling 7-day payment volume (daily buckets) */
  paymentHistory7d: Array<bigint>;
  /** Creation timestamp */
  createdAt: bigint;
  /** Last update timestamp */
  updatedAt: bigint;
  /** Skill-based reputation tags (e.g., "code-generation", "defi-expert") */
  skillTags: Array<string>;
  /** Behavior-based tags (e.g., "fast-responder", "dispute-free") */
  behaviorTags: Array<string>;
  /** Compliance-based tags (e.g., "kyc-verified", "audited-code") */
  complianceTags: Array<string>;
  /** Tag confidence scores with evidence */
  tagScores: Array<TagScore>;
  /** Last time tags were updated */
  tagUpdatedAt: bigint;
  /** Multi-source reputation scores (max 10 sources) */
  sourceScores: Array<SourceScore>;
  /** Primary reputation source (default: "payai") */
  primarySource: string;
  /** Last time multi-source aggregation was performed */
  lastAggregation: bigint;
  /** Conflict flags describing score discrepancies */
  conflictFlags: Array<string>;
  /** PDA bump */
  bump: number;
};

export type ReputationMetricsArgs = {
  /** Agent public key */
  agent: Address;
  /** Total successful x402 payments received */
  successfulPayments: number | bigint;
  /** Total failed x402 payment attempts */
  failedPayments: number | bigint;
  /** Cumulative response time in milliseconds */
  totalResponseTime: number | bigint;
  /** Number of response time measurements */
  responseTimeCount: number | bigint;
  /** Total disputes filed against agent for x402 services */
  totalDisputes: number;
  /** Disputes resolved favorably */
  disputesResolved: number;
  /** Sum of all client ratings (0-5 scale) */
  totalRating: number;
  /** Number of ratings submitted */
  totalRatingsCount: number;
  /** Rolling 7-day payment volume (daily buckets) */
  paymentHistory7d: Array<number | bigint>;
  /** Creation timestamp */
  createdAt: number | bigint;
  /** Last update timestamp */
  updatedAt: number | bigint;
  /** Skill-based reputation tags (e.g., "code-generation", "defi-expert") */
  skillTags: Array<string>;
  /** Behavior-based tags (e.g., "fast-responder", "dispute-free") */
  behaviorTags: Array<string>;
  /** Compliance-based tags (e.g., "kyc-verified", "audited-code") */
  complianceTags: Array<string>;
  /** Tag confidence scores with evidence */
  tagScores: Array<TagScoreArgs>;
  /** Last time tags were updated */
  tagUpdatedAt: number | bigint;
  /** Multi-source reputation scores (max 10 sources) */
  sourceScores: Array<SourceScoreArgs>;
  /** Primary reputation source (default: "payai") */
  primarySource: string;
  /** Last time multi-source aggregation was performed */
  lastAggregation: number | bigint;
  /** Conflict flags describing score discrepancies */
  conflictFlags: Array<string>;
  /** PDA bump */
  bump: number;
};

/** Gets the encoder for {@link ReputationMetricsArgs} account data. */
export function getReputationMetricsEncoder(): Encoder<ReputationMetricsArgs> {
  return transformEncoder(
    getStructEncoder([
      ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
      ["agent", getAddressEncoder()],
      ["successfulPayments", getU64Encoder()],
      ["failedPayments", getU64Encoder()],
      ["totalResponseTime", getU64Encoder()],
      ["responseTimeCount", getU64Encoder()],
      ["totalDisputes", getU32Encoder()],
      ["disputesResolved", getU32Encoder()],
      ["totalRating", getU32Encoder()],
      ["totalRatingsCount", getU32Encoder()],
      ["paymentHistory7d", getArrayEncoder(getU64Encoder(), { size: 7 })],
      ["createdAt", getI64Encoder()],
      ["updatedAt", getI64Encoder()],
      [
        "skillTags",
        getArrayEncoder(
          addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()),
        ),
      ],
      [
        "behaviorTags",
        getArrayEncoder(
          addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()),
        ),
      ],
      [
        "complianceTags",
        getArrayEncoder(
          addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()),
        ),
      ],
      ["tagScores", getArrayEncoder(getTagScoreEncoder())],
      ["tagUpdatedAt", getI64Encoder()],
      ["sourceScores", getArrayEncoder(getSourceScoreEncoder())],
      [
        "primarySource",
        addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()),
      ],
      ["lastAggregation", getI64Encoder()],
      [
        "conflictFlags",
        getArrayEncoder(
          addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()),
        ),
      ],
      ["bump", getU8Encoder()],
    ]),
    (value) => ({ ...value, discriminator: REPUTATION_METRICS_DISCRIMINATOR }),
  );
}

/** Gets the decoder for {@link ReputationMetrics} account data. */
export function getReputationMetricsDecoder(): Decoder<ReputationMetrics> {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    ["agent", getAddressDecoder()],
    ["successfulPayments", getU64Decoder()],
    ["failedPayments", getU64Decoder()],
    ["totalResponseTime", getU64Decoder()],
    ["responseTimeCount", getU64Decoder()],
    ["totalDisputes", getU32Decoder()],
    ["disputesResolved", getU32Decoder()],
    ["totalRating", getU32Decoder()],
    ["totalRatingsCount", getU32Decoder()],
    ["paymentHistory7d", getArrayDecoder(getU64Decoder(), { size: 7 })],
    ["createdAt", getI64Decoder()],
    ["updatedAt", getI64Decoder()],
    [
      "skillTags",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())),
    ],
    [
      "behaviorTags",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())),
    ],
    [
      "complianceTags",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())),
    ],
    ["tagScores", getArrayDecoder(getTagScoreDecoder())],
    ["tagUpdatedAt", getI64Decoder()],
    ["sourceScores", getArrayDecoder(getSourceScoreDecoder())],
    ["primarySource", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["lastAggregation", getI64Decoder()],
    [
      "conflictFlags",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())),
    ],
    ["bump", getU8Decoder()],
  ]);
}

/** Gets the codec for {@link ReputationMetrics} account data. */
export function getReputationMetricsCodec(): Codec<
  ReputationMetricsArgs,
  ReputationMetrics
> {
  return combineCodec(
    getReputationMetricsEncoder(),
    getReputationMetricsDecoder(),
  );
}

export function decodeReputationMetrics<TAddress extends string = string>(
  encodedAccount: EncodedAccount<TAddress>,
): Account<ReputationMetrics, TAddress>;
export function decodeReputationMetrics<TAddress extends string = string>(
  encodedAccount: MaybeEncodedAccount<TAddress>,
): MaybeAccount<ReputationMetrics, TAddress>;
export function decodeReputationMetrics<TAddress extends string = string>(
  encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>,
):
  | Account<ReputationMetrics, TAddress>
  | MaybeAccount<ReputationMetrics, TAddress> {
  return decodeAccount(
    encodedAccount as MaybeEncodedAccount<TAddress>,
    getReputationMetricsDecoder(),
  );
}

export async function fetchReputationMetrics<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig,
): Promise<Account<ReputationMetrics, TAddress>> {
  const maybeAccount = await fetchMaybeReputationMetrics(rpc, address, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}

export async function fetchMaybeReputationMetrics<
  TAddress extends string = string,
>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig,
): Promise<MaybeAccount<ReputationMetrics, TAddress>> {
  const maybeAccount = await fetchEncodedAccount(rpc, address, config);
  return decodeReputationMetrics(maybeAccount);
}

export async function fetchAllReputationMetrics(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Array<Address>,
  config?: FetchAccountsConfig,
): Promise<Account<ReputationMetrics>[]> {
  const maybeAccounts = await fetchAllMaybeReputationMetrics(
    rpc,
    addresses,
    config,
  );
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}

export async function fetchAllMaybeReputationMetrics(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Array<Address>,
  config?: FetchAccountsConfig,
): Promise<MaybeAccount<ReputationMetrics>[]> {
  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
  return maybeAccounts.map((maybeAccount) =>
    decodeReputationMetrics(maybeAccount),
  );
}
