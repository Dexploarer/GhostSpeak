/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  addDecoderSizePrefix,
  addEncoderSizePrefix,
  combineCodec,
  fixDecoderSize,
  fixEncoderSize,
  getBytesDecoder,
  getBytesEncoder,
  getOptionDecoder,
  getOptionEncoder,
  getProgramDerivedAddress,
  getStructDecoder,
  getStructEncoder,
  getU32Decoder,
  getU32Encoder,
  getUtf8Decoder,
  getUtf8Encoder,
  transformEncoder,
  type AccountMeta,
  type AccountSignerMeta,
  type Address,
  type Codec,
  type Decoder,
  type Encoder,
  type Instruction,
  type InstructionWithAccounts,
  type InstructionWithData,
  type Option,
  type OptionOrNullable,
  type ReadonlyAccount,
  type ReadonlySignerAccount,
  type ReadonlyUint8Array,
  type TransactionSigner,
  type WritableAccount,
} from '@solana/kit';
import { GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS } from '../programs';
import { getAccountMetaFactory, type ResolvedAccount } from '../shared';

export const COMPLETE_ESCROW_DISCRIMINATOR = new Uint8Array([
  158, 211, 102, 36, 244, 24, 103, 163,
]);

export function getCompleteEscrowDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(
    COMPLETE_ESCROW_DISCRIMINATOR
  );
}

export type CompleteEscrowInstruction<
  TProgram extends string = typeof GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS,
  TAccountEscrow extends string | AccountMeta<string> = string,
  TAccountReentrancyGuard extends string | AccountMeta<string> = string,
  TAccountAgent extends string | AccountMeta<string> = string,
  TAccountEscrowTokenAccount extends string | AccountMeta<string> = string,
  TAccountAgentTokenAccount extends string | AccountMeta<string> = string,
  TAccountAuthority extends string | AccountMeta<string> = string,
  TAccountTokenProgram extends
    | string
    | AccountMeta<string> = 'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb',
  TRemainingAccounts extends readonly AccountMeta<string>[] = [],
> = Instruction<TProgram> &
  InstructionWithData<ReadonlyUint8Array> &
  InstructionWithAccounts<
    [
      TAccountEscrow extends string
        ? WritableAccount<TAccountEscrow>
        : TAccountEscrow,
      TAccountReentrancyGuard extends string
        ? WritableAccount<TAccountReentrancyGuard>
        : TAccountReentrancyGuard,
      TAccountAgent extends string
        ? WritableAccount<TAccountAgent>
        : TAccountAgent,
      TAccountEscrowTokenAccount extends string
        ? WritableAccount<TAccountEscrowTokenAccount>
        : TAccountEscrowTokenAccount,
      TAccountAgentTokenAccount extends string
        ? WritableAccount<TAccountAgentTokenAccount>
        : TAccountAgentTokenAccount,
      TAccountAuthority extends string
        ? ReadonlySignerAccount<TAccountAuthority> &
            AccountSignerMeta<TAccountAuthority>
        : TAccountAuthority,
      TAccountTokenProgram extends string
        ? ReadonlyAccount<TAccountTokenProgram>
        : TAccountTokenProgram,
      ...TRemainingAccounts,
    ]
  >;

export type CompleteEscrowInstructionData = {
  discriminator: ReadonlyUint8Array;
  resolutionNotes: Option<string>;
};

export type CompleteEscrowInstructionDataArgs = {
  resolutionNotes: OptionOrNullable<string>;
};

export function getCompleteEscrowInstructionDataEncoder(): Encoder<CompleteEscrowInstructionDataArgs> {
  return transformEncoder(
    getStructEncoder([
      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
      [
        'resolutionNotes',
        getOptionEncoder(
          addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())
        ),
      ],
    ]),
    (value) => ({ ...value, discriminator: COMPLETE_ESCROW_DISCRIMINATOR })
  );
}

export function getCompleteEscrowInstructionDataDecoder(): Decoder<CompleteEscrowInstructionData> {
  return getStructDecoder([
    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
    [
      'resolutionNotes',
      getOptionDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())),
    ],
  ]);
}

export function getCompleteEscrowInstructionDataCodec(): Codec<
  CompleteEscrowInstructionDataArgs,
  CompleteEscrowInstructionData
> {
  return combineCodec(
    getCompleteEscrowInstructionDataEncoder(),
    getCompleteEscrowInstructionDataDecoder()
  );
}

export type CompleteEscrowAsyncInput<
  TAccountEscrow extends string = string,
  TAccountReentrancyGuard extends string = string,
  TAccountAgent extends string = string,
  TAccountEscrowTokenAccount extends string = string,
  TAccountAgentTokenAccount extends string = string,
  TAccountAuthority extends string = string,
  TAccountTokenProgram extends string = string,
> = {
  escrow: Address<TAccountEscrow>;
  reentrancyGuard?: Address<TAccountReentrancyGuard>;
  agent: Address<TAccountAgent>;
  escrowTokenAccount: Address<TAccountEscrowTokenAccount>;
  agentTokenAccount: Address<TAccountAgentTokenAccount>;
  authority: TransactionSigner<TAccountAuthority>;
  tokenProgram?: Address<TAccountTokenProgram>;
  resolutionNotes: CompleteEscrowInstructionDataArgs['resolutionNotes'];
};

export async function getCompleteEscrowInstructionAsync<
  TAccountEscrow extends string,
  TAccountReentrancyGuard extends string,
  TAccountAgent extends string,
  TAccountEscrowTokenAccount extends string,
  TAccountAgentTokenAccount extends string,
  TAccountAuthority extends string,
  TAccountTokenProgram extends string,
  TProgramAddress extends
    Address = typeof GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS,
>(
  input: CompleteEscrowAsyncInput<
    TAccountEscrow,
    TAccountReentrancyGuard,
    TAccountAgent,
    TAccountEscrowTokenAccount,
    TAccountAgentTokenAccount,
    TAccountAuthority,
    TAccountTokenProgram
  >,
  config?: { programAddress?: TProgramAddress }
): Promise<
  CompleteEscrowInstruction<
    TProgramAddress,
    TAccountEscrow,
    TAccountReentrancyGuard,
    TAccountAgent,
    TAccountEscrowTokenAccount,
    TAccountAgentTokenAccount,
    TAccountAuthority,
    TAccountTokenProgram
  >
> {
  // Program address.
  const programAddress =
    config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    escrow: { value: input.escrow ?? null, isWritable: true },
    reentrancyGuard: { value: input.reentrancyGuard ?? null, isWritable: true },
    agent: { value: input.agent ?? null, isWritable: true },
    escrowTokenAccount: {
      value: input.escrowTokenAccount ?? null,
      isWritable: true,
    },
    agentTokenAccount: {
      value: input.agentTokenAccount ?? null,
      isWritable: true,
    },
    authority: { value: input.authority ?? null, isWritable: false },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Original args.
  const args = { ...input };

  // Resolve default values.
  if (!accounts.reentrancyGuard.value) {
    accounts.reentrancyGuard.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(
          new Uint8Array([
            114, 101, 101, 110, 116, 114, 97, 110, 99, 121, 95, 103, 117, 97,
            114, 100,
          ])
        ),
      ],
    });
  }
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value =
      'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb' as Address<'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb'>;
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
  const instruction = {
    accounts: [
      getAccountMeta(accounts.escrow),
      getAccountMeta(accounts.reentrancyGuard),
      getAccountMeta(accounts.agent),
      getAccountMeta(accounts.escrowTokenAccount),
      getAccountMeta(accounts.agentTokenAccount),
      getAccountMeta(accounts.authority),
      getAccountMeta(accounts.tokenProgram),
    ],
    programAddress,
    data: getCompleteEscrowInstructionDataEncoder().encode(
      args as CompleteEscrowInstructionDataArgs
    ),
  } as CompleteEscrowInstruction<
    TProgramAddress,
    TAccountEscrow,
    TAccountReentrancyGuard,
    TAccountAgent,
    TAccountEscrowTokenAccount,
    TAccountAgentTokenAccount,
    TAccountAuthority,
    TAccountTokenProgram
  >;

  return instruction;
}

export type CompleteEscrowInput<
  TAccountEscrow extends string = string,
  TAccountReentrancyGuard extends string = string,
  TAccountAgent extends string = string,
  TAccountEscrowTokenAccount extends string = string,
  TAccountAgentTokenAccount extends string = string,
  TAccountAuthority extends string = string,
  TAccountTokenProgram extends string = string,
> = {
  escrow: Address<TAccountEscrow>;
  reentrancyGuard: Address<TAccountReentrancyGuard>;
  agent: Address<TAccountAgent>;
  escrowTokenAccount: Address<TAccountEscrowTokenAccount>;
  agentTokenAccount: Address<TAccountAgentTokenAccount>;
  authority: TransactionSigner<TAccountAuthority>;
  tokenProgram?: Address<TAccountTokenProgram>;
  resolutionNotes: CompleteEscrowInstructionDataArgs['resolutionNotes'];
};

export function getCompleteEscrowInstruction<
  TAccountEscrow extends string,
  TAccountReentrancyGuard extends string,
  TAccountAgent extends string,
  TAccountEscrowTokenAccount extends string,
  TAccountAgentTokenAccount extends string,
  TAccountAuthority extends string,
  TAccountTokenProgram extends string,
  TProgramAddress extends
    Address = typeof GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS,
>(
  input: CompleteEscrowInput<
    TAccountEscrow,
    TAccountReentrancyGuard,
    TAccountAgent,
    TAccountEscrowTokenAccount,
    TAccountAgentTokenAccount,
    TAccountAuthority,
    TAccountTokenProgram
  >,
  config?: { programAddress?: TProgramAddress }
): CompleteEscrowInstruction<
  TProgramAddress,
  TAccountEscrow,
  TAccountReentrancyGuard,
  TAccountAgent,
  TAccountEscrowTokenAccount,
  TAccountAgentTokenAccount,
  TAccountAuthority,
  TAccountTokenProgram
> {
  // Program address.
  const programAddress =
    config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    escrow: { value: input.escrow ?? null, isWritable: true },
    reentrancyGuard: { value: input.reentrancyGuard ?? null, isWritable: true },
    agent: { value: input.agent ?? null, isWritable: true },
    escrowTokenAccount: {
      value: input.escrowTokenAccount ?? null,
      isWritable: true,
    },
    agentTokenAccount: {
      value: input.agentTokenAccount ?? null,
      isWritable: true,
    },
    authority: { value: input.authority ?? null, isWritable: false },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Original args.
  const args = { ...input };

  // Resolve default values.
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value =
      'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb' as Address<'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb'>;
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
  const instruction = {
    accounts: [
      getAccountMeta(accounts.escrow),
      getAccountMeta(accounts.reentrancyGuard),
      getAccountMeta(accounts.agent),
      getAccountMeta(accounts.escrowTokenAccount),
      getAccountMeta(accounts.agentTokenAccount),
      getAccountMeta(accounts.authority),
      getAccountMeta(accounts.tokenProgram),
    ],
    programAddress,
    data: getCompleteEscrowInstructionDataEncoder().encode(
      args as CompleteEscrowInstructionDataArgs
    ),
  } as CompleteEscrowInstruction<
    TProgramAddress,
    TAccountEscrow,
    TAccountReentrancyGuard,
    TAccountAgent,
    TAccountEscrowTokenAccount,
    TAccountAgentTokenAccount,
    TAccountAuthority,
    TAccountTokenProgram
  >;

  return instruction;
}

export type ParsedCompleteEscrowInstruction<
  TProgram extends string = typeof GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS,
  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],
> = {
  programAddress: Address<TProgram>;
  accounts: {
    escrow: TAccountMetas[0];
    reentrancyGuard: TAccountMetas[1];
    agent: TAccountMetas[2];
    escrowTokenAccount: TAccountMetas[3];
    agentTokenAccount: TAccountMetas[4];
    authority: TAccountMetas[5];
    tokenProgram: TAccountMetas[6];
  };
  data: CompleteEscrowInstructionData;
};

export function parseCompleteEscrowInstruction<
  TProgram extends string,
  TAccountMetas extends readonly AccountMeta[],
>(
  instruction: Instruction<TProgram> &
    InstructionWithAccounts<TAccountMetas> &
    InstructionWithData<ReadonlyUint8Array>
): ParsedCompleteEscrowInstruction<TProgram, TAccountMetas> {
  if (instruction.accounts.length < 7) {
    // TODO: Coded error.
    throw new Error('Not enough accounts');
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts![accountIndex]!;
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      escrow: getNextAccount(),
      reentrancyGuard: getNextAccount(),
      agent: getNextAccount(),
      escrowTokenAccount: getNextAccount(),
      agentTokenAccount: getNextAccount(),
      authority: getNextAccount(),
      tokenProgram: getNextAccount(),
    },
    data: getCompleteEscrowInstructionDataDecoder().decode(instruction.data),
  };
}
