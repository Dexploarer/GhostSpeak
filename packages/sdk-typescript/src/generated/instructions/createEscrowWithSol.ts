/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead regenerate from IDL.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  type Address,
  type ReadonlyUint8Array,
} from '@solana/kit'
import type { TransactionSigner } from '@solana/kit'
import {
  getProgramDerivedAddress,
  getAddressEncoder,
  getU8Encoder,
  getU32Encoder,
  getU64Encoder,
  getI64Encoder,
  getBooleanEncoder,
  getUtf8Encoder,
  combineCodec,
  getStructEncoder,
  getStructDecoder,
  getU8Decoder,
  getU32Decoder,
  getU64Decoder,
  getI64Decoder,
  getBooleanDecoder,
  getUtf8Decoder,
  getOptionEncoder,
  getOptionDecoder,
  fixEncoderSize,
  fixDecoderSize,
  transformEncoder,
} from '@solana/kit'
import { GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS } from '../programs/ghostspeakMarketplace.js'

// Instruction discriminator
export const CREATE_ESCROW_WITH_SOL_DISCRIMINATOR = new Uint8Array([135, 194, 171, 90, 18, 253, 103, 115])

// Constants
const NATIVE_MINT = 'So11111111111111111111111111111111111111112' as Address
const TOKEN_PROGRAM = 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' as Address
const ASSOCIATED_TOKEN_PROGRAM = 'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL' as Address
const SYSTEM_PROGRAM = '11111111111111111111111111111111' as Address

export type CreateEscrowWithSolInput = {
  /** The escrow account to create */
  escrow?: Address
  /** Reentrancy guard account */
  reentrancyGuard?: Address
  /** The client creating the escrow (payer) */
  client: TransactionSigner
  /** The agent who will receive payment */
  agent: Address
  /** Client's wSOL token account */
  clientWsolAccount?: Address
  /** Escrow's wSOL token account */
  escrowWsolAccount?: Address
  /** Native SOL mint */
  nativeMint?: Address
  /** Token program */
  tokenProgram?: Address
  /** Associated token program */
  associatedTokenProgram?: Address
  /** System program */
  systemProgram?: Address
  /** Unique task identifier */
  taskId: string
  /** Amount in lamports */
  amount: bigint
  /** Expiration timestamp */
  expiresAt: bigint
  /** Optional transfer hook */
  transferHook: Address | null
  /** Whether escrow is confidential */
  isConfidential: boolean
}

export type CreateEscrowWithSolInputWithSigners = CreateEscrowWithSolInput

/**
 * Helper to derive ATA for regular Token program
 */
async function deriveTokenATA(wallet: Address, mint: Address): Promise<Address> {
  const [ata] = await getProgramDerivedAddress({
    programAddress: ASSOCIATED_TOKEN_PROGRAM,
    seeds: [
      getAddressEncoder().encode(wallet),
      getAddressEncoder().encode(TOKEN_PROGRAM),
      getAddressEncoder().encode(mint)
    ]
  })
  return ata
}

/**
 * Helper to derive escrow PDA
 */
async function deriveEscrowPda(programId: Address, taskId: string): Promise<Address> {
  const encoder = new TextEncoder()
  const [pda] = await getProgramDerivedAddress({
    programAddress: programId,
    seeds: [
      new Uint8Array([101, 115, 99, 114, 111, 119]), // "escrow"
      encoder.encode(taskId)
    ]
  })
  return pda
}

/**
 * Helper to derive reentrancy guard PDA
 */
async function deriveReentrancyGuardPda(programId: Address): Promise<Address> {
  const [pda] = await getProgramDerivedAddress({
    programAddress: programId,
    seeds: [
      new Uint8Array([114, 101, 101, 110, 116, 114, 97, 110, 99, 121, 95, 103, 117, 97, 114, 100]) // "reentrancy_guard"
    ]
  })
  return pda
}

/**
 * Creates an escrow by depositing native SOL (auto-wraps to wSOL)
 */
export async function getCreateEscrowWithSolInstructionAsync(
  input: CreateEscrowWithSolInput,
  config: { programAddress?: Address } = {}
) {
  const programAddress = config.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS

  // Derive PDAs if not provided
  const escrow = input.escrow ?? await deriveEscrowPda(programAddress, input.taskId)
  const reentrancyGuard = input.reentrancyGuard ?? await deriveReentrancyGuardPda(programAddress)
  const clientWsolAccount = input.clientWsolAccount ?? await deriveTokenATA(input.client.address, NATIVE_MINT)
  const escrowWsolAccount = input.escrowWsolAccount ?? await deriveTokenATA(escrow, NATIVE_MINT)

  // Encode instruction data
  const encoder = new TextEncoder()
  const taskIdBytes = encoder.encode(input.taskId)
  
  // Build data buffer
  // discriminator (8) + taskId length (4) + taskId + amount (8) + expiresAt (8) + transferHook (1 + 32?) + isConfidential (1)
  const dataSize = 8 + 4 + taskIdBytes.length + 8 + 8 + (input.transferHook ? 33 : 1) + 1
  const data = new Uint8Array(dataSize)
  const view = new DataView(data.buffer)
  
  let offset = 0
  
  // Discriminator
  data.set(CREATE_ESCROW_WITH_SOL_DISCRIMINATOR, offset)
  offset += 8
  
  // taskId (string: 4-byte length prefix + bytes)
  view.setUint32(offset, taskIdBytes.length, true)
  offset += 4
  data.set(taskIdBytes, offset)
  offset += taskIdBytes.length
  
  // amount (u64)
  view.setBigUint64(offset, input.amount, true)
  offset += 8
  
  // expiresAt (i64)
  view.setBigInt64(offset, input.expiresAt, true)
  offset += 8
  
  // transferHook (Option<Pubkey>)
  if (input.transferHook) {
    data[offset] = 1 // Some
    offset += 1
    data.set(getAddressEncoder().encode(input.transferHook), offset)
    offset += 32
  } else {
    data[offset] = 0 // None
    offset += 1
  }
  
  // isConfidential (bool)
  data[offset] = input.isConfidential ? 1 : 0

  return {
    programAddress,
    accounts: [
      { address: escrow, role: 1 }, // WRITABLE
      { address: reentrancyGuard, role: 1 }, // WRITABLE
      { address: input.client.address, role: 3 }, // WRITABLE_SIGNER
      { address: input.agent, role: 0 }, // READONLY
      { address: clientWsolAccount, role: 1 }, // WRITABLE
      { address: escrowWsolAccount, role: 1 }, // WRITABLE
      { address: input.nativeMint ?? NATIVE_MINT, role: 0 }, // READONLY
      { address: input.tokenProgram ?? TOKEN_PROGRAM, role: 0 }, // READONLY
      { address: input.associatedTokenProgram ?? ASSOCIATED_TOKEN_PROGRAM, role: 0 }, // READONLY
      { address: input.systemProgram ?? SYSTEM_PROGRAM, role: 0 }, // READONLY
    ],
    data
  }
}
