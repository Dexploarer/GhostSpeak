/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  addDecoderSizePrefix,
  addEncoderSizePrefix,
  combineCodec,
  fixDecoderSize,
  fixEncoderSize,
  getBytesDecoder,
  getBytesEncoder,
  getOptionDecoder,
  getOptionEncoder,
  getStructDecoder,
  getStructEncoder,
  getU32Decoder,
  getU32Encoder,
  getU8Decoder,
  getU8Encoder,
  getUtf8Decoder,
  getUtf8Encoder,
  transformEncoder,
  type AccountMeta,
  type AccountSignerMeta,
  type Address,
  type Codec,
  type Decoder,
  type Encoder,
  type Instruction,
  type InstructionWithAccounts,
  type InstructionWithData,
  type Option,
  type OptionOrNullable,
  type ReadonlyAccount,
  type ReadonlySignerAccount,
  type ReadonlyUint8Array,
  type TransactionSigner,
  type WritableAccount,
} from "@solana/kit";
import { GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS } from "../programs";
import { getAccountMetaFactory, type ResolvedAccount } from "../shared";

export const SUBMIT_X402_RATING_DISCRIMINATOR = new Uint8Array([
  207, 232, 84, 144, 125, 143, 137, 30,
]);

export function getSubmitX402RatingDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(
    SUBMIT_X402_RATING_DISCRIMINATOR,
  );
}

export type SubmitX402RatingInstruction<
  TProgram extends string = typeof GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS,
  TAccountAgent extends string | AccountMeta<string> = string,
  TAccountRater extends string | AccountMeta<string> = string,
  TAccountClock extends string | AccountMeta<string> =
    "SysvarC1ock11111111111111111111111111111111",
  TRemainingAccounts extends readonly AccountMeta<string>[] = [],
> = Instruction<TProgram> &
  InstructionWithData<ReadonlyUint8Array> &
  InstructionWithAccounts<
    [
      TAccountAgent extends string
        ? WritableAccount<TAccountAgent>
        : TAccountAgent,
      TAccountRater extends string
        ? ReadonlySignerAccount<TAccountRater> &
            AccountSignerMeta<TAccountRater>
        : TAccountRater,
      TAccountClock extends string
        ? ReadonlyAccount<TAccountClock>
        : TAccountClock,
      ...TRemainingAccounts,
    ]
  >;

export type SubmitX402RatingInstructionData = {
  discriminator: ReadonlyUint8Array;
  agentId: string;
  rating: number;
  transactionSignature: string;
  feedback: Option<string>;
};

export type SubmitX402RatingInstructionDataArgs = {
  agentId: string;
  rating: number;
  transactionSignature: string;
  feedback: OptionOrNullable<string>;
};

export function getSubmitX402RatingInstructionDataEncoder(): Encoder<SubmitX402RatingInstructionDataArgs> {
  return transformEncoder(
    getStructEncoder([
      ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
      ["agentId", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
      ["rating", getU8Encoder()],
      [
        "transactionSignature",
        addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()),
      ],
      [
        "feedback",
        getOptionEncoder(
          addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()),
        ),
      ],
    ]),
    (value) => ({ ...value, discriminator: SUBMIT_X402_RATING_DISCRIMINATOR }),
  );
}

export function getSubmitX402RatingInstructionDataDecoder(): Decoder<SubmitX402RatingInstructionData> {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    ["agentId", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["rating", getU8Decoder()],
    [
      "transactionSignature",
      addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()),
    ],
    [
      "feedback",
      getOptionDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())),
    ],
  ]);
}

export function getSubmitX402RatingInstructionDataCodec(): Codec<
  SubmitX402RatingInstructionDataArgs,
  SubmitX402RatingInstructionData
> {
  return combineCodec(
    getSubmitX402RatingInstructionDataEncoder(),
    getSubmitX402RatingInstructionDataDecoder(),
  );
}

export type SubmitX402RatingInput<
  TAccountAgent extends string = string,
  TAccountRater extends string = string,
  TAccountClock extends string = string,
> = {
  /** Agent account receiving the rating */
  agent: Address<TAccountAgent>;
  /** User submitting the rating (must have paid via x402) */
  rater: TransactionSigner<TAccountRater>;
  /** Clock sysvar for timestamp validation */
  clock?: Address<TAccountClock>;
  agentId: SubmitX402RatingInstructionDataArgs["agentId"];
  rating: SubmitX402RatingInstructionDataArgs["rating"];
  transactionSignature: SubmitX402RatingInstructionDataArgs["transactionSignature"];
  feedback: SubmitX402RatingInstructionDataArgs["feedback"];
};

export function getSubmitX402RatingInstruction<
  TAccountAgent extends string,
  TAccountRater extends string,
  TAccountClock extends string,
  TProgramAddress extends Address =
    typeof GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS,
>(
  input: SubmitX402RatingInput<TAccountAgent, TAccountRater, TAccountClock>,
  config?: { programAddress?: TProgramAddress },
): SubmitX402RatingInstruction<
  TProgramAddress,
  TAccountAgent,
  TAccountRater,
  TAccountClock
> {
  // Program address.
  const programAddress =
    config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    agent: { value: input.agent ?? null, isWritable: true },
    rater: { value: input.rater ?? null, isWritable: false },
    clock: { value: input.clock ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Original args.
  const args = { ...input };

  // Resolve default values.
  if (!accounts.clock.value) {
    accounts.clock.value =
      "SysvarC1ock11111111111111111111111111111111" as Address<"SysvarC1ock11111111111111111111111111111111">;
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.agent),
      getAccountMeta(accounts.rater),
      getAccountMeta(accounts.clock),
    ],
    data: getSubmitX402RatingInstructionDataEncoder().encode(
      args as SubmitX402RatingInstructionDataArgs,
    ),
    programAddress,
  } as SubmitX402RatingInstruction<
    TProgramAddress,
    TAccountAgent,
    TAccountRater,
    TAccountClock
  >);
}

export type ParsedSubmitX402RatingInstruction<
  TProgram extends string = typeof GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS,
  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],
> = {
  programAddress: Address<TProgram>;
  accounts: {
    /** Agent account receiving the rating */
    agent: TAccountMetas[0];
    /** User submitting the rating (must have paid via x402) */
    rater: TAccountMetas[1];
    /** Clock sysvar for timestamp validation */
    clock: TAccountMetas[2];
  };
  data: SubmitX402RatingInstructionData;
};

export function parseSubmitX402RatingInstruction<
  TProgram extends string,
  TAccountMetas extends readonly AccountMeta[],
>(
  instruction: Instruction<TProgram> &
    InstructionWithAccounts<TAccountMetas> &
    InstructionWithData<ReadonlyUint8Array>,
): ParsedSubmitX402RatingInstruction<TProgram, TAccountMetas> {
  if (instruction.accounts.length < 3) {
    // TODO: Coded error.
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      agent: getNextAccount(),
      rater: getNextAccount(),
      clock: getNextAccount(),
    },
    data: getSubmitX402RatingInstructionDataDecoder().decode(instruction.data),
  };
}
