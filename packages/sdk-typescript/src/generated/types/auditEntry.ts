/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  combineCodec,
  fixDecoderSize,
  fixEncoderSize,
  getAddressDecoder,
  getAddressEncoder,
  getBytesDecoder,
  getBytesEncoder,
  getI64Decoder,
  getI64Encoder,
  getOptionDecoder,
  getOptionEncoder,
  getStructDecoder,
  getStructEncoder,
  getU64Decoder,
  getU64Encoder,
  type Address,
  type Codec,
  type Decoder,
  type Encoder,
  type Option,
  type OptionOrNullable,
  type ReadonlyUint8Array,
} from '@solana/kit';
import {
  getAuditActionDecoder,
  getAuditActionEncoder,
  getAuditContextDecoder,
  getAuditContextEncoder,
  getComplianceFlagsDecoder,
  getComplianceFlagsEncoder,
  type AuditAction,
  type AuditActionArgs,
  type AuditContext,
  type AuditContextArgs,
  type ComplianceFlags,
  type ComplianceFlagsArgs,
} from '.';

/** Individual audit entry (immutable) */
export type AuditEntry = {
  /** Unique entry ID */
  entryId: bigint;
  /** Timestamp of the action */
  timestamp: bigint;
  /** Action that was performed */
  action: AuditAction;
  /** User/agent who performed the action */
  actor: Address;
  /** Target of the action (if applicable) */
  target: Option<Address>;
  /** Additional context data */
  context: AuditContext;
  /** Compliance flags */
  complianceFlags: ComplianceFlags;
  /** Hash of previous entry for chain integrity */
  previousHash: ReadonlyUint8Array;
  /** Hash of this entry */
  entryHash: ReadonlyUint8Array;
  /** Digital signature for non-repudiation */
  signature: Option<ReadonlyUint8Array>;
};

export type AuditEntryArgs = {
  /** Unique entry ID */
  entryId: number | bigint;
  /** Timestamp of the action */
  timestamp: number | bigint;
  /** Action that was performed */
  action: AuditActionArgs;
  /** User/agent who performed the action */
  actor: Address;
  /** Target of the action (if applicable) */
  target: OptionOrNullable<Address>;
  /** Additional context data */
  context: AuditContextArgs;
  /** Compliance flags */
  complianceFlags: ComplianceFlagsArgs;
  /** Hash of previous entry for chain integrity */
  previousHash: ReadonlyUint8Array;
  /** Hash of this entry */
  entryHash: ReadonlyUint8Array;
  /** Digital signature for non-repudiation */
  signature: OptionOrNullable<ReadonlyUint8Array>;
};

export function getAuditEntryEncoder(): Encoder<AuditEntryArgs> {
  return getStructEncoder([
    ['entryId', getU64Encoder()],
    ['timestamp', getI64Encoder()],
    ['action', getAuditActionEncoder()],
    ['actor', getAddressEncoder()],
    ['target', getOptionEncoder(getAddressEncoder())],
    ['context', getAuditContextEncoder()],
    ['complianceFlags', getComplianceFlagsEncoder()],
    ['previousHash', fixEncoderSize(getBytesEncoder(), 32)],
    ['entryHash', fixEncoderSize(getBytesEncoder(), 32)],
    ['signature', getOptionEncoder(fixEncoderSize(getBytesEncoder(), 64))],
  ]);
}

export function getAuditEntryDecoder(): Decoder<AuditEntry> {
  return getStructDecoder([
    ['entryId', getU64Decoder()],
    ['timestamp', getI64Decoder()],
    ['action', getAuditActionDecoder()],
    ['actor', getAddressDecoder()],
    ['target', getOptionDecoder(getAddressDecoder())],
    ['context', getAuditContextDecoder()],
    ['complianceFlags', getComplianceFlagsDecoder()],
    ['previousHash', fixDecoderSize(getBytesDecoder(), 32)],
    ['entryHash', fixDecoderSize(getBytesDecoder(), 32)],
    ['signature', getOptionDecoder(fixDecoderSize(getBytesDecoder(), 64))],
  ]);
}

export function getAuditEntryCodec(): Codec<AuditEntryArgs, AuditEntry> {
  return combineCodec(getAuditEntryEncoder(), getAuditEntryDecoder());
}
