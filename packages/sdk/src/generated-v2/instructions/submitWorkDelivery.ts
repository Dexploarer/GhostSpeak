/**
 * This code was GENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

/* eslint-disable @typescript-eslint/no-unused-vars */
// @ts-nocheck

import { Address } from '@solana/addresses';
import type {
  IAccountMeta,
  IInstruction,
  IInstructionWithAccounts,
  IInstructionWithData,
} from '../../utils/instruction-compat';
import { AccountRole } from '../../utils/instruction-compat';

import {
  combineCodec,
  getStructDecoder,
  getStructEncoder,
  transformEncoder,
  type Codec,
  type Decoder,
  type Encoder,
  getArrayDecoder,
  getArrayEncoder,
  getUtf8Decoder,
  getUtf8Encoder,
  getBytesEncoder,
  getBytesDecoder,
  transformDecoder,
} from '@solana/codecs';

export const SUBMIT_WORK_DELIVERY_DISCRIMINATOR = new Uint8Array([
  201, 45, 78, 92, 156, 89, 23, 177,
]);

export function getSubmitWorkDeliveryDiscriminatorBytes() {
  return SUBMIT_WORK_DELIVERY_DISCRIMINATOR.slice();
}

export type SubmitWorkDeliveryInstruction = IInstruction<string> &
  IInstructionWithData<Uint8Array> &
  IInstructionWithAccounts<IAccountMeta<string>[]>;

export type SubmitWorkDeliveryInstructionData = {
  discriminator: Uint8Array;
  deliveryData: WorkDeliveryData;
};

export type WorkDeliveryData = {
  deliverables: Deliverable[];
  ipfsHash: string;
  metadataUri: string;
};

export type Deliverable = {
  __kind: 'Code' | 'Document' | 'Design' | 'Analysis' | 'Other';
};

export type SubmitWorkDeliveryInstructionDataArgs = {
  deliveryData: WorkDeliveryDataArgs;
};

export type WorkDeliveryDataArgs = {
  deliverables: DeliverableArgs[];
  ipfsHash: string;
  metadataUri: string;
};

export type DeliverableArgs = {
  __kind: 'Code' | 'Document' | 'Design' | 'Analysis' | 'Other';
};

export function getSubmitWorkDeliveryInstructionDataEncoder(): Encoder<SubmitWorkDeliveryInstructionDataArgs> {
  return transformEncoder(
    getStructEncoder([
      ['discriminator', getBytesEncoder()],
      ['deliveryData', getWorkDeliveryDataEncoder()],
    ]),
    value => ({
      ...value,
      discriminator: getSubmitWorkDeliveryDiscriminatorBytes(),
    })
  );
}

export function getSubmitWorkDeliveryInstructionDataDecoder(): Decoder<SubmitWorkDeliveryInstructionData> {
  return transformDecoder(
    getStructDecoder([
      ['discriminator', getBytesDecoder()],
      ['deliveryData', getWorkDeliveryDataDecoder()],
    ]),
    value => ({
      ...value,
      discriminator: new Uint8Array(value.discriminator),
    })
  );
}

export function getSubmitWorkDeliveryInstructionDataCodec(): Codec<
  SubmitWorkDeliveryInstructionDataArgs,
  SubmitWorkDeliveryInstructionData
> {
  return combineCodec(
    getSubmitWorkDeliveryInstructionDataEncoder(),
    getSubmitWorkDeliveryInstructionDataDecoder()
  );
}

export function getWorkDeliveryDataEncoder(): Encoder<WorkDeliveryDataArgs> {
  return getStructEncoder([
    ['deliverables', getArrayEncoder(getDeliverableEncoder())],
    ['ipfsHash', getUtf8Encoder()],
    ['metadataUri', getUtf8Encoder()],
  ]);
}

export function getWorkDeliveryDataDecoder(): Decoder<WorkDeliveryData> {
  return getStructDecoder([
    ['deliverables', getArrayDecoder(getDeliverableDecoder())],
    ['ipfsHash', getUtf8Decoder()],
    ['metadataUri', getUtf8Decoder()],
  ]);
}

export function getWorkDeliveryDataCodec(): Codec<
  WorkDeliveryDataArgs,
  WorkDeliveryData
> {
  return combineCodec(
    getWorkDeliveryDataEncoder(),
    getWorkDeliveryDataDecoder()
  );
}

export function getDeliverableEncoder(): Encoder<DeliverableArgs> {
  return getStructEncoder([['__kind', getUtf8Encoder()]]);
}

export function getDeliverableDecoder(): Decoder<Deliverable> {
  return transformDecoder(
    getStructDecoder([['__kind', getUtf8Decoder()]]),
    value => ({ __kind: value.__kind as Deliverable['__kind'] })
  );
}

export function getDeliverableCodec(): Codec<DeliverableArgs, Deliverable> {
  return combineCodec(getDeliverableEncoder(), getDeliverableDecoder());
}

export type SubmitWorkDeliveryInput<
  TAccountWorkDelivery extends string = string,
  TAccountWorkOrder extends string = string,
  TAccountProvider extends string = string,
  TAccountSystemProgram extends string = string,
> = {
  workDelivery: Address<TAccountWorkDelivery>;
  workOrder: Address<TAccountWorkOrder>;
  provider: Address<TAccountProvider>;
  systemProgram?: Address<TAccountSystemProgram>;
  deliveryData: WorkDeliveryDataArgs;
};

export function getSubmitWorkDeliveryInstruction(
  input: SubmitWorkDeliveryInput
): SubmitWorkDeliveryInstruction {
  const programAddress =
    'PodAI111111111111111111111111111111111111111' as Address<string>;
  const accounts: IAccountMeta<string>[] = [
    { address: input.workDelivery, role: AccountRole.WRITABLE },
    { address: input.workOrder, role: AccountRole.WRITABLE },
    { address: input.provider, role: AccountRole.WRITABLE_SIGNER },
    {
      address:
        input.systemProgram ??
        ('11111111111111111111111111111111' as Address<string>),
      role: AccountRole.READONLY,
    },
  ];

  // Instruction data
  const args = { deliveryData: input.deliveryData };
  let data = getSubmitWorkDeliveryInstructionDataEncoder().encode(args);
  if (!(data instanceof Uint8Array)) {
    data = new Uint8Array(data);
  }

  return {
    programAddress,
    accounts,
    data: data as Uint8Array & ArrayBufferLike,
  };
}

export type ParsedSubmitWorkDeliveryInstruction<
  TProgram extends string = 'PodAI111111111111111111111111111111111111111',
  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],
> = {
  programAddress: Address<TProgram>;
  accounts: {
    workDelivery: TAccountMetas[0];
    workOrder: TAccountMetas[1];
    provider: TAccountMetas[2];
    systemProgram: TAccountMetas[3];
  };
  data: SubmitWorkDeliveryInstructionData;
};

export function parseSubmitWorkDeliveryInstruction<
  TProgram extends string,
  TAccountMetas extends readonly IAccountMeta[],
>(
  instruction: IInstruction<TProgram> &
    IInstructionWithAccounts<TAccountMetas> &
    IInstructionWithData<Uint8Array>
): ParsedSubmitWorkDeliveryInstruction<TProgram, TAccountMetas> {
  if (instruction.accounts.length < 4) {
    throw new Error('Not enough accounts');
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts![accountIndex]!;
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      workDelivery: getNextAccount(),
      workOrder: getNextAccount(),
      provider: getNextAccount(),
      systemProgram: getNextAccount(),
    },
    data: getSubmitWorkDeliveryInstructionDataDecoder().decode(
      instruction.data
    ),
  };
}

// Async version for modern Web3.js v2 usage
export async function getSubmitWorkDeliveryInstructionAsync<
  TAccountWorkDelivery extends string,
  TAccountWorkOrder extends string,
  TAccountProvider extends string,
  TAccountSystemProgram extends string,
>(
  input: SubmitWorkDeliveryInput<
    TAccountWorkDelivery,
    TAccountWorkOrder,
    TAccountProvider,
    TAccountSystemProgram
  >
): Promise<SubmitWorkDeliveryInstruction> {
  return getSubmitWorkDeliveryInstruction(input);
}
