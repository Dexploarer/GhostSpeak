import { createRequire } from "node:module";
var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __esm = (fn, res) => () => (fn && (res = fn(fn = 0)), res);
var __require = /* @__PURE__ */ createRequire(import.meta.url);

// ../packages/sdk-typescript/dist/chunk-SKMJJ3Q6.js
function chunkArray(array, size) {
  const chunks = [];
  for (let i = 0;i < array.length; i += size) {
    chunks.push(array.slice(i, i + size));
  }
  return chunks;
}
async function batchGetAccounts(rpc, addresses, config = {}) {
  const batchSize = Math.min(config.batchSize ?? MAX_ACCOUNTS_PER_BATCH, MAX_ACCOUNTS_PER_BATCH);
  if (addresses.length === 0)
    return [];
  if (addresses.length <= batchSize) {
    const result = await rpc.getMultipleAccounts(addresses).send();
    return result.value;
  }
  const batches = chunkArray(addresses, batchSize);
  const results = [];
  let completed = 0;
  const batchPromises = batches.map(async (batch) => {
    const result = await rpc.getMultipleAccounts(batch).send();
    completed += batch.length;
    config.onProgress?.(completed, addresses.length);
    return result.value;
  });
  results.push(...await Promise.all(batchPromises));
  return results.flat();
}
async function batchGetExistingAccounts(rpc, addresses, config = {}) {
  const accounts = await batchGetAccounts(rpc, addresses, config);
  const existing = [];
  for (let i = 0;i < accounts.length; i++) {
    const account = accounts[i];
    if (account !== null) {
      existing.push({
        address: addresses[i],
        account
      });
    }
  }
  return existing;
}
async function batchGetAndMap(rpc, addresses, mapper, config = {}) {
  const accounts = await batchGetAccounts(rpc, addresses, config);
  return accounts.map((account, index) => mapper(account, addresses[index], index));
}
async function batchGetAccountsWithRetry(rpc, addresses, config = {}, maxRetries = 3) {
  const batchSize = Math.min(config.batchSize ?? MAX_ACCOUNTS_PER_BATCH, MAX_ACCOUNTS_PER_BATCH);
  if (addresses.length === 0)
    return [];
  const batches = chunkArray(addresses, batchSize);
  const results = new Array(addresses.length);
  let completed = 0;
  await Promise.all(batches.map(async (batch, batchIndex) => {
    let retries = 0;
    let success = false;
    while (!success && retries <= maxRetries) {
      try {
        const result = await rpc.getMultipleAccounts(batch).send();
        const batchResults = result.value;
        batchResults.forEach((account, i) => {
          results[batchIndex * batchSize + i] = account;
        });
        completed += batch.length;
        config.onProgress?.(completed, addresses.length);
        success = true;
      } catch (error) {
        retries++;
        if (retries > maxRetries) {
          throw new Error(`Batch ${batchIndex} failed after ${maxRetries} retries: ${error}`);
        }
        await new Promise((resolve) => setTimeout(resolve, 100 * Math.pow(2, retries - 1)));
      }
    }
  }));
  return results;
}
function createBatchFetcher(rpc, defaultConfig = {}) {
  return {
    getAccounts: (addresses, config) => batchGetAccounts(rpc, addresses, { ...defaultConfig, ...config }),
    getExisting: (addresses, config) => batchGetExistingAccounts(rpc, addresses, {
      ...defaultConfig,
      ...config
    }),
    getAndMap: (addresses, mapper, config) => batchGetAndMap(rpc, addresses, mapper, {
      ...defaultConfig,
      ...config
    }),
    getWithRetry: (addresses, config, maxRetries) => batchGetAccountsWithRetry(rpc, addresses, { ...defaultConfig, ...config }, maxRetries)
  };
}
var MAX_ACCOUNTS_PER_BATCH = 100;
var init_chunk_SKMJJ3Q6 = () => {};

// ../node_modules/.bun/@solana+errors@5.1.0+1fb4c65d43e298b9/node_modules/@solana/errors/dist/index.node.mjs
function getHumanReadableErrorMessage(code, context = {}) {
  const messageFormatString = SolanaErrorMessages[code];
  if (messageFormatString.length === 0) {
    return "";
  }
  let state;
  function commitStateUpTo(endIndex) {
    if (state[TYPE] === 2) {
      const variableName = messageFormatString.slice(state[START_INDEX] + 1, endIndex);
      fragments.push(variableName in context ? `${context[variableName]}` : `$${variableName}`);
    } else if (state[TYPE] === 1) {
      fragments.push(messageFormatString.slice(state[START_INDEX], endIndex));
    }
  }
  const fragments = [];
  messageFormatString.split("").forEach((char, ii) => {
    if (ii === 0) {
      state = {
        [START_INDEX]: 0,
        [TYPE]: messageFormatString[0] === "\\" ? 0 : messageFormatString[0] === "$" ? 2 : 1
      };
      return;
    }
    let nextState;
    switch (state[TYPE]) {
      case 0:
        nextState = { [START_INDEX]: ii, [TYPE]: 1 };
        break;
      case 1:
        if (char === "\\") {
          nextState = { [START_INDEX]: ii, [TYPE]: 0 };
        } else if (char === "$") {
          nextState = { [START_INDEX]: ii, [TYPE]: 2 };
        }
        break;
      case 2:
        if (char === "\\") {
          nextState = { [START_INDEX]: ii, [TYPE]: 0 };
        } else if (char === "$") {
          nextState = { [START_INDEX]: ii, [TYPE]: 2 };
        } else if (!char.match(/\w/)) {
          nextState = { [START_INDEX]: ii, [TYPE]: 1 };
        }
        break;
    }
    if (nextState) {
      if (state !== nextState) {
        commitStateUpTo(ii);
      }
      state = nextState;
    }
  });
  commitStateUpTo();
  return fragments.join("");
}
function getErrorMessage(code, context = {}) {
  if (true) {
    return getHumanReadableErrorMessage(code, context);
  } else {}
}
function isSolanaError(e, code) {
  const isSolanaError2 = e instanceof Error && e.name === "SolanaError";
  if (isSolanaError2) {
    if (code !== undefined) {
      return e.context.__code === code;
    }
    return true;
  }
  return false;
}
function safeCaptureStackTrace(...args) {
  if ("captureStackTrace" in Error && typeof Error.captureStackTrace === "function") {
    Error.captureStackTrace(...args);
  }
}
function getSolanaErrorFromRpcError({ errorCodeBaseOffset, getErrorContext, orderedErrorNames, rpcEnumError }, constructorOpt) {
  let rpcErrorName;
  let rpcErrorContext;
  if (typeof rpcEnumError === "string") {
    rpcErrorName = rpcEnumError;
  } else {
    rpcErrorName = Object.keys(rpcEnumError)[0];
    rpcErrorContext = rpcEnumError[rpcErrorName];
  }
  const codeOffset = orderedErrorNames.indexOf(rpcErrorName);
  const errorCode = errorCodeBaseOffset + codeOffset;
  const errorContext = getErrorContext(errorCode, rpcErrorName, rpcErrorContext);
  const err = new SolanaError(errorCode, errorContext);
  safeCaptureStackTrace(err, constructorOpt);
  return err;
}
function getSolanaErrorFromInstructionError(index, instructionError) {
  const numberIndex = Number(index);
  return getSolanaErrorFromRpcError({
    errorCodeBaseOffset: 4615001,
    getErrorContext(errorCode, rpcErrorName, rpcErrorContext) {
      if (errorCode === SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN) {
        return {
          errorName: rpcErrorName,
          index: numberIndex,
          ...rpcErrorContext !== undefined ? { instructionErrorContext: rpcErrorContext } : null
        };
      } else if (errorCode === SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM) {
        return {
          code: Number(rpcErrorContext),
          index: numberIndex
        };
      }
      return { index: numberIndex };
    },
    orderedErrorNames: ORDERED_ERROR_NAMES,
    rpcEnumError: instructionError
  }, getSolanaErrorFromInstructionError);
}
function getSolanaErrorFromTransactionError(transactionError) {
  if (typeof transactionError === "object" && "InstructionError" in transactionError) {
    return getSolanaErrorFromInstructionError(...transactionError.InstructionError);
  }
  return getSolanaErrorFromRpcError({
    errorCodeBaseOffset: 7050001,
    getErrorContext(errorCode, rpcErrorName, rpcErrorContext) {
      if (errorCode === SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN) {
        return {
          errorName: rpcErrorName,
          ...rpcErrorContext !== undefined ? { transactionErrorContext: rpcErrorContext } : null
        };
      } else if (errorCode === SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION) {
        return {
          index: Number(rpcErrorContext)
        };
      } else if (errorCode === SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT || errorCode === SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED) {
        return {
          accountIndex: Number(rpcErrorContext.account_index)
        };
      }
    },
    orderedErrorNames: ORDERED_ERROR_NAMES2,
    rpcEnumError: transactionError
  }, getSolanaErrorFromTransactionError);
}
function getSolanaErrorFromJsonRpcError(putativeErrorResponse) {
  let out;
  if (isRpcErrorResponse(putativeErrorResponse)) {
    const { code: rawCode, data: data2, message } = putativeErrorResponse;
    const code = Number(rawCode);
    if (code === SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE) {
      const { err, ...preflightErrorContext } = data2;
      const causeObject = err ? { cause: getSolanaErrorFromTransactionError(err) } : null;
      out = new SolanaError(SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE, {
        ...preflightErrorContext,
        ...causeObject
      });
    } else {
      let errorContext;
      switch (code) {
        case SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR:
        case SOLANA_ERROR__JSON_RPC__INVALID_PARAMS:
        case SOLANA_ERROR__JSON_RPC__INVALID_REQUEST:
        case SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND:
        case SOLANA_ERROR__JSON_RPC__PARSE_ERROR:
        case SOLANA_ERROR__JSON_RPC__SCAN_ERROR:
        case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP:
        case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE:
        case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET:
        case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX:
        case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED:
        case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED:
        case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE:
        case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION:
          errorContext = { __serverMessage: message };
          break;
        default:
          if (typeof data2 === "object" && !Array.isArray(data2)) {
            errorContext = data2;
          }
      }
      out = new SolanaError(code, errorContext);
    }
  } else {
    const message = typeof putativeErrorResponse === "object" && putativeErrorResponse !== null && "message" in putativeErrorResponse && typeof putativeErrorResponse.message === "string" ? putativeErrorResponse.message : "Malformed JSON-RPC error with no message attribute";
    out = new SolanaError(SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR, { error: putativeErrorResponse, message });
  }
  safeCaptureStackTrace(out, getSolanaErrorFromJsonRpcError);
  return out;
}
function isRpcErrorResponse(value) {
  return typeof value === "object" && value !== null && "code" in value && "message" in value && (typeof value.code === "number" || typeof value.code === "bigint") && typeof value.message === "string";
}
var SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED = 1, SOLANA_ERROR__INVALID_NONCE = 2, SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND = 3, SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE = 4, SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH = 5, SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE = 6, SOLANA_ERROR__MALFORMED_BIGINT_STRING = 7, SOLANA_ERROR__MALFORMED_NUMBER_STRING = 8, SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE = 9, SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR = 10, SOLANA_ERROR__JSON_RPC__PARSE_ERROR = -32700, SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR = -32603, SOLANA_ERROR__JSON_RPC__INVALID_PARAMS = -32602, SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND = -32601, SOLANA_ERROR__JSON_RPC__INVALID_REQUEST = -32600, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_UNREACHABLE = -32019, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_NOT_EPOCH_BOUNDARY = -32018, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_EPOCH_REWARDS_PERIOD_ACTIVE = -32017, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED = -32016, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION = -32015, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET = -32014, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH = -32013, SOLANA_ERROR__JSON_RPC__SCAN_ERROR = -32012, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE = -32011, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX = -32010, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED = -32009, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT = -32008, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED = -32007, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE = -32006, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY = -32005, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE = -32004, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE = -32003, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE = -32002, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP = -32001, SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH = 2800000, SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE = 2800001, SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS = 2800002, SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY = 2800003, SOLANA_ERROR__ADDRESSES__MALFORMED_PDA = 2800004, SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE = 2800005, SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED = 2800006, SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED = 2800007, SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE = 2800008, SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED = 2800009, SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER = 2800010, SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS = 2800011, SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND = 3230000, SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND = 32300001, SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT = 3230002, SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT = 3230003, SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED = 3230004, SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT = 3610000, SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED = 3610001, SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED = 3610002, SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED = 3610003, SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED = 3610004, SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED = 3610005, SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED = 3610006, SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY = 3610007, SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED = 3611000, SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH = 3704000, SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH = 3704001, SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH = 3704002, SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE = 3704003, SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY = 3704004, SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS = 4128000, SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA = 4128001, SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH = 4128002, SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN = 4615000, SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR = 4615001, SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT = 4615002, SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA = 4615003, SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA = 4615004, SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL = 4615005, SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS = 4615006, SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID = 4615007, SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE = 4615008, SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED = 4615009, SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT = 4615010, SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION = 4615011, SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID = 4615012, SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND = 4615013, SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED = 4615014, SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE = 4615015, SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED = 4615016, SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX = 4615017, SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED = 4615018, SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED = 4615019, SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS = 4615020, SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED = 4615021, SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE = 4615022, SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED = 4615023, SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING = 4615024, SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC = 4615025, SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM = 4615026, SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR = 4615027, SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED = 4615028, SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE = 4615029, SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT = 4615030, SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID = 4615031, SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH = 4615032, SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT = 4615033, SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED = 4615034, SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED = 4615035, SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS = 4615036, SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC = 4615037, SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED = 4615038, SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION = 4615039, SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE = 4615040, SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE = 4615041, SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE = 4615042, SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE = 4615043, SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY = 4615044, SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR = 4615045, SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT = 4615046, SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER = 4615047, SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW = 4615048, SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR = 4615049, SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER = 4615050, SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED = 4615051, SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED = 4615052, SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED = 4615053, SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS = 4615054, SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS = 5508000, SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER = 5508001, SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER = 5508002, SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER = 5508003, SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER = 5508004, SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER = 5508005, SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER = 5508006, SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER = 5508007, SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER = 5508008, SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS = 5508009, SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING = 5508010, SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED = 5508011, SOLANA_ERROR__OFFCHAIN_MESSAGE__MAXIMUM_LENGTH_EXCEEDED = 5607000, SOLANA_ERROR__OFFCHAIN_MESSAGE__RESTRICTED_ASCII_BODY_CHARACTER_OUT_OF_RANGE = 5607001, SOLANA_ERROR__OFFCHAIN_MESSAGE__APPLICATION_DOMAIN_STRING_LENGTH_OUT_OF_RANGE = 5607002, SOLANA_ERROR__OFFCHAIN_MESSAGE__INVALID_APPLICATION_DOMAIN_BYTE_LENGTH = 5607003, SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_SIGNATURES_MISMATCH = 5607004, SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO = 5607005, SOLANA_ERROR__OFFCHAIN_MESSAGE__VERSION_NUMBER_NOT_SUPPORTED = 5607006, SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_FORMAT_MISMATCH = 5607007, SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_LENGTH_MISMATCH = 5607008, SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_MUST_BE_NON_EMPTY = 5607009, SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_ENVELOPE_SIGNATURES_CANNOT_BE_ZERO = 5607010, SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURES_MISSING = 5607011, SOLANA_ERROR__OFFCHAIN_MESSAGE__ENVELOPE_SIGNERS_MISMATCH = 5607012, SOLANA_ERROR__OFFCHAIN_MESSAGE__ADDRESSES_CANNOT_SIGN_OFFCHAIN_MESSAGE = 5607013, SOLANA_ERROR__OFFCHAIN_MESSAGE__UNEXPECTED_VERSION = 5607014, SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATORIES_MUST_BE_SORTED = 5607015, SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATORIES_MUST_BE_UNIQUE = 5607016, SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURE_VERIFICATION_FAILURE = 5607017, SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES = 5663000, SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE = 5663001, SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME = 5663002, SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME = 5663003, SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE = 5663004, SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING = 5663005, SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE = 5663006, SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND = 5663007, SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING = 5663008, SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING = 5663009, SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING = 5663010, SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING = 5663011, SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING = 5663012, SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING = 5663013, SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE = 5663014, SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION = 5663015, SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES = 5663016, SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH = 5663017, SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT = 5663018, SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT = 5663019, SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT = 5663020, SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_NOT_SUPPORTED = 5663021, SOLANA_ERROR__TRANSACTION__NONCE_ACCOUNT_CANNOT_BE_IN_LOOKUP_TABLE = 5663022, SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN = 7050000, SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE = 7050001, SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE = 7050002, SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND = 7050003, SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND = 7050004, SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE = 7050005, SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE = 7050006, SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED = 7050007, SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND = 7050008, SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP = 7050009, SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE = 7050010, SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX = 7050011, SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE = 7050012, SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION = 7050013, SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE = 7050014, SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE = 7050015, SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING = 7050016, SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT = 7050017, SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION = 7050018, SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT = 7050019, SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT = 7050020, SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT = 7050021, SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS = 7050022, SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND = 7050023, SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER = 7050024, SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA = 7050025, SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX = 7050026, SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT = 7050027, SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT = 7050028, SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT = 7050029, SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION = 7050030, SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT = 7050031, SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED = 7050032, SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT = 7050033, SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED = 7050034, SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED = 7050035, SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION = 7050036, SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN = 7618000, SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_PACKER_ALREADY_COMPLETE = 7618001, SOLANA_ERROR__INSTRUCTION_PLANS__EMPTY_INSTRUCTION_PLAN = 7618002, SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_TO_EXECUTE_TRANSACTION_PLAN = 7618003, SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY = 8078000, SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH = 8078001, SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH = 8078002, SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH = 8078003, SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH = 8078004, SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH = 8078005, SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH = 8078006, SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS = 8078007, SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE = 8078008, SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT = 8078009, SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT = 8078010, SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE = 8078011, SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE = 8078012, SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH = 8078013, SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE = 8078014, SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT = 8078015, SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE = 8078016, SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE = 8078017, SOLANA_ERROR__CODECS__INVALID_CONSTANT = 8078018, SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE = 8078019, SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL = 8078020, SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES = 8078021, SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS = 8078022, SOLANA_ERROR__CODECS__EXPECTED_DECODER_TO_CONSUME_ENTIRE_BYTE_ARRAY = 8078023, SOLANA_ERROR__RPC__INTEGER_OVERFLOW = 8100000, SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN = 8100001, SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR = 8100002, SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD = 8100003, SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN = 8190000, SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID = 8190001, SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED = 8190002, SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED = 8190003, SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT = 8190004, SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING = 9900000, SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE = 9900001, SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING = 9900002, SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE = 9900003, SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED = 9900004, SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_INSTRUCTION_PLAN_KIND = 9900005, SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_TRANSACTION_PLAN_KIND = 9900006, SolanaErrorMessages, START_INDEX = "i", TYPE = "t", SolanaError, ORDERED_ERROR_NAMES, ORDERED_ERROR_NAMES2;
var init_index_node = __esm(() => {
  SolanaErrorMessages = {
    [SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND]: "Account not found at address: $address",
    [SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED]: "Not all accounts were decoded. Encoded accounts found at addresses: $addresses.",
    [SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT]: "Expected decoded account at address: $address",
    [SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT]: "Failed to decode account data at address: $address",
    [SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND]: "Accounts not found at addresses: $addresses",
    [SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED]: "Unable to find a viable program address bump seed.",
    [SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS]: "$putativeAddress is not a base58-encoded address.",
    [SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH]: "Expected base58 encoded address to decode to a byte array of length 32. Actual length: $actualLength.",
    [SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY]: "The `CryptoKey` must be an `Ed25519` public key.",
    [SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS]: "$putativeOffCurveAddress is not a base58-encoded off-curve address.",
    [SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE]: "Invalid seeds; point must fall off the Ed25519 curve.",
    [SOLANA_ERROR__ADDRESSES__MALFORMED_PDA]: "Expected given program derived address to have the following format: [Address, ProgramDerivedAddressBump].",
    [SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED]: "A maximum of $maxSeeds seeds, including the bump seed, may be supplied when creating an address. Received: $actual.",
    [SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED]: "The seed at index $index with length $actual exceeds the maximum length of $maxSeedLength bytes.",
    [SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE]: "Expected program derived address bump to be in the range [0, 255], got: $bump.",
    [SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER]: "Program address cannot end with PDA marker.",
    [SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE]: "Expected base58-encoded address string of length in the range [32, 44]. Actual length: $actualLength.",
    [SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE]: "Expected base58-encoded blockash string of length in the range [32, 44]. Actual length: $actualLength.",
    [SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED]: "The network has progressed past the last block for which this transaction could have been committed.",
    [SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY]: "Codec [$codecDescription] cannot decode empty byte arrays.",
    [SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS]: "Enum codec cannot use lexical values [$stringValues] as discriminators. Either remove all lexical values or set `useValuesAsDiscriminators` to `false`.",
    [SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL]: "Sentinel [$hexSentinel] must not be present in encoded bytes [$hexEncodedBytes].",
    [SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH]: "Encoder and decoder must have the same fixed size, got [$encoderFixedSize] and [$decoderFixedSize].",
    [SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH]: "Encoder and decoder must have the same max size, got [$encoderMaxSize] and [$decoderMaxSize].",
    [SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH]: "Encoder and decoder must either both be fixed-size or variable-size.",
    [SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE]: "Enum discriminator out of range. Expected a number in [$formattedValidDiscriminators], got $discriminator.",
    [SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH]: "Expected a fixed-size codec, got a variable-size one.",
    [SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH]: "Codec [$codecDescription] expected a positive byte length, got $bytesLength.",
    [SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH]: "Expected a variable-size codec, got a fixed-size one.",
    [SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE]: "Codec [$codecDescription] expected zero-value [$hexZeroValue] to have the same size as the provided fixed-size item [$expectedSize bytes].",
    [SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH]: "Codec [$codecDescription] expected $expected bytes, got $bytesLength.",
    [SOLANA_ERROR__CODECS__INVALID_CONSTANT]: "Expected byte array constant [$hexConstant] to be present in data [$hexData] at offset [$offset].",
    [SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT]: "Invalid discriminated union variant. Expected one of [$variants], got $value.",
    [SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT]: "Invalid enum variant. Expected one of [$stringValues] or a number in [$formattedNumericalValues], got $variant.",
    [SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT]: "Invalid literal union variant. Expected one of [$variants], got $value.",
    [SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS]: "Expected [$codecDescription] to have $expected items, got $actual.",
    [SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE]: "Invalid value $value for base $base with alphabet $alphabet.",
    [SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE]: "Literal union discriminator out of range. Expected a number between $minRange and $maxRange, got $discriminator.",
    [SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE]: "Codec [$codecDescription] expected number to be in the range [$min, $max], got $value.",
    [SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE]: "Codec [$codecDescription] expected offset to be in the range [0, $bytesLength], got $offset.",
    [SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES]: "Expected sentinel [$hexSentinel] to be present in decoded bytes [$hexDecodedBytes].",
    [SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE]: "Union variant out of range. Expected an index between $minRange and $maxRange, got $variant.",
    [SOLANA_ERROR__CODECS__EXPECTED_DECODER_TO_CONSUME_ENTIRE_BYTE_ARRAY]: "This decoder expected a byte array of exactly $expectedLength bytes, but $numExcessBytes unexpected excess bytes remained after decoding. Are you sure that you have chosen the correct decoder for this data?",
    [SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED]: "No random values implementation could be found.",
    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED]: "instruction requires an uninitialized account",
    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED]: "instruction tries to borrow reference for an account which is already borrowed",
    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING]: "instruction left account with an outstanding borrowed reference",
    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED]: "program other than the account's owner changed the size of the account data",
    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL]: "account data too small for instruction",
    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE]: "instruction expected an executable account",
    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT]: "An account does not have enough lamports to be rent-exempt",
    [SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW]: "Program arithmetic overflowed",
    [SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR]: "Failed to serialize or deserialize account data: $encodedData",
    [SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS]: "Builtin programs must consume compute units",
    [SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH]: "Cross-program invocation call depth too deep",
    [SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED]: "Computational budget exceeded",
    [SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM]: "custom program error: #$code",
    [SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX]: "instruction contains duplicate accounts",
    [SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC]: "instruction modifications of multiply-passed account differ",
    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT]: "executable accounts must be rent exempt",
    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED]: "instruction changed executable accounts data",
    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE]: "instruction changed the balance of an executable account",
    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED]: "instruction changed executable bit of an account",
    [SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED]: "instruction modified data of an account it does not own",
    [SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND]: "instruction spent from the balance of an account it does not own",
    [SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR]: "generic instruction error",
    [SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER]: "Provided owner is not allowed",
    [SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE]: "Account is immutable",
    [SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY]: "Incorrect authority provided",
    [SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID]: "incorrect program id for instruction",
    [SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS]: "insufficient funds for instruction",
    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA]: "invalid account data for instruction",
    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER]: "Invalid account owner",
    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT]: "invalid program argument",
    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR]: "program returned invalid error code",
    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA]: "invalid instruction data",
    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC]: "Failed to reallocate account data",
    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS]: "Provided seeds do not result in a valid address",
    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED]: "Accounts data allocations exceeded the maximum allowed per transaction",
    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED]: "Max accounts exceeded",
    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED]: "Max instruction trace length exceeded",
    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED]: "Length of the seed is too long for address generation",
    [SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT]: "An account required by the instruction is missing",
    [SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE]: "missing required signature for instruction",
    [SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID]: "instruction illegally modified the program id of an account",
    [SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS]: "insufficient account keys for instruction",
    [SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION]: "Cross-program invocation with unauthorized signer or writable account",
    [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE]: "Failed to create program execution environment",
    [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE]: "Program failed to compile",
    [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE]: "Program failed to complete",
    [SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED]: "instruction modified data of a read-only account",
    [SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE]: "instruction changed the balance of a read-only account",
    [SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED]: "Cross-program invocation reentrancy not allowed for this instruction",
    [SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED]: "instruction modified rent epoch of an account",
    [SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION]: "sum of account balances before and after instruction do not match",
    [SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT]: "instruction requires an initialized account",
    [SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN]: "",
    [SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID]: "Unsupported program id",
    [SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR]: "Unsupported sysvar",
    [SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_INSTRUCTION_PLAN_KIND]: "Invalid instruction plan kind: $kind.",
    [SOLANA_ERROR__INSTRUCTION_PLANS__EMPTY_INSTRUCTION_PLAN]: "The provided instruction plan is empty.",
    [SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_TO_EXECUTE_TRANSACTION_PLAN]: "The provided transaction plan failed to execute. See the `transactionPlanResult` attribute and the `cause` error for more details.",
    [SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN]: "The provided message has insufficient capacity to accommodate the next instruction(s) in this plan. Expected at least $numBytesRequired free byte(s), got $numFreeBytes byte(s).",
    [SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_TRANSACTION_PLAN_KIND]: "Invalid transaction plan kind: $kind.",
    [SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_PACKER_ALREADY_COMPLETE]: "No more instructions to pack; the message packer has completed the instruction plan.",
    [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS]: "The instruction does not have any accounts.",
    [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA]: "The instruction does not have any data.",
    [SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH]: "Expected instruction to have progress address $expectedProgramAddress, got $actualProgramAddress.",
    [SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH]: "Expected base58 encoded blockhash to decode to a byte array of length 32. Actual length: $actualLength.",
    [SOLANA_ERROR__INVALID_NONCE]: "The nonce `$expectedNonceValue` is no longer valid. It has advanced to `$actualNonceValue`",
    [SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING]: "Invariant violation: Found no abortable iterable cache entry for key `$cacheKey`. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
    [SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED]: "Invariant violation: This data publisher does not publish to the channel named `$channelName`. Supported channels include $supportedChannelNames.",
    [SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE]: "Invariant violation: WebSocket message iterator state is corrupt; iterated without first resolving existing message promise. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
    [SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING]: "Invariant violation: WebSocket message iterator is missing state storage. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
    [SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE]: "Invariant violation: Switch statement non-exhaustive. Received unexpected value `$unexpectedValue`. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
    [SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR]: "JSON-RPC error: Internal JSON-RPC error ($__serverMessage)",
    [SOLANA_ERROR__JSON_RPC__INVALID_PARAMS]: "JSON-RPC error: Invalid method parameter(s) ($__serverMessage)",
    [SOLANA_ERROR__JSON_RPC__INVALID_REQUEST]: "JSON-RPC error: The JSON sent is not a valid `Request` object ($__serverMessage)",
    [SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND]: "JSON-RPC error: The method does not exist / is not available ($__serverMessage)",
    [SOLANA_ERROR__JSON_RPC__PARSE_ERROR]: "JSON-RPC error: An error occurred on the server while parsing the JSON text ($__serverMessage)",
    [SOLANA_ERROR__JSON_RPC__SCAN_ERROR]: "$__serverMessage",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP]: "$__serverMessage",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE]: "$__serverMessage",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET]: "$__serverMessage",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_EPOCH_REWARDS_PERIOD_ACTIVE]: "Epoch rewards period still active at slot $slot",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX]: "$__serverMessage",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED]: "$__serverMessage",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_UNREACHABLE]: "Failed to query long-term storage; please try again",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED]: "Minimum context slot has not been reached",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY]: "Node is unhealthy; behind by $numSlotsBehind slots",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT]: "No snapshot",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE]: "Transaction simulation failed",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_NOT_EPOCH_BOUNDARY]: "Rewards cannot be found because slot $slot is not the epoch boundary. This may be due to gap in the queried node's local ledger or long-term storage",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED]: "$__serverMessage",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE]: "Transaction history is not available from this node",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE]: "$__serverMessage",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH]: "Transaction signature length mismatch",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE]: "Transaction signature verification failure",
    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION]: "$__serverMessage",
    [SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH]: "Key pair bytes must be of length 64, got $byteLength.",
    [SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH]: "Expected private key bytes with length 32. Actual length: $actualLength.",
    [SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH]: "Expected base58-encoded signature to decode to a byte array of length 64. Actual length: $actualLength.",
    [SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY]: "The provided private key does not match the provided public key.",
    [SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE]: "Expected base58-encoded signature string of length in the range [64, 88]. Actual length: $actualLength.",
    [SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE]: "Lamports value must be in the range [0, 2e64-1]",
    [SOLANA_ERROR__MALFORMED_BIGINT_STRING]: "`$value` cannot be parsed as a `BigInt`",
    [SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR]: "$message",
    [SOLANA_ERROR__MALFORMED_NUMBER_STRING]: "`$value` cannot be parsed as a `Number`",
    [SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND]: "No nonce account could be found at address `$nonceAccountAddress`",
    [SOLANA_ERROR__OFFCHAIN_MESSAGE__INVALID_APPLICATION_DOMAIN_BYTE_LENGTH]: "Expected base58 encoded application domain to decode to a byte array of length 32. Actual length: $actualLength.",
    [SOLANA_ERROR__OFFCHAIN_MESSAGE__ADDRESSES_CANNOT_SIGN_OFFCHAIN_MESSAGE]: "Attempted to sign an offchain message with an address that is not a signer for it",
    [SOLANA_ERROR__OFFCHAIN_MESSAGE__APPLICATION_DOMAIN_STRING_LENGTH_OUT_OF_RANGE]: "Expected base58-encoded application domain string of length in the range [32, 44]. Actual length: $actualLength.",
    [SOLANA_ERROR__OFFCHAIN_MESSAGE__ENVELOPE_SIGNERS_MISMATCH]: "The signer addresses in this offchain message envelope do not match the list of required signers in the message preamble. These unexpected signers were present in the envelope: `[$unexpectedSigners]`. These required signers were missing from the envelope `[$missingSigners]`.",
    [SOLANA_ERROR__OFFCHAIN_MESSAGE__MAXIMUM_LENGTH_EXCEEDED]: "The message body provided has a byte-length of $actualBytes. The maximum allowable byte-length is $maxBytes",
    [SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_FORMAT_MISMATCH]: "Expected message format $expectedMessageFormat, got $actualMessageFormat",
    [SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_LENGTH_MISMATCH]: "The message length specified in the message preamble is $specifiedLength bytes. The actual length of the message is $actualLength bytes.",
    [SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_MUST_BE_NON_EMPTY]: "Offchain message content must be non-empty",
    [SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO]: "Offchain message must specify the address of at least one required signer",
    [SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_ENVELOPE_SIGNATURES_CANNOT_BE_ZERO]: "Offchain message envelope must reserve space for at least one signature",
    [SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_SIGNATURES_MISMATCH]: "The offchain message preamble specifies $numRequiredSignatures required signature(s), got $signaturesLength.",
    [SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATORIES_MUST_BE_SORTED]: "The signatories of this offchain message must be listed in lexicographical order",
    [SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATORIES_MUST_BE_UNIQUE]: "An address must be listed no more than once among the signatories of an offchain message",
    [SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURES_MISSING]: "Offchain message is missing signatures for addresses: $addresses.",
    [SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURE_VERIFICATION_FAILURE]: "Offchain message signature verification failed. Signature mismatch for required signatories [$signatoriesWithInvalidSignatures]. Missing signatures for signatories [$signatoriesWithMissingSignatures]",
    [SOLANA_ERROR__OFFCHAIN_MESSAGE__RESTRICTED_ASCII_BODY_CHARACTER_OUT_OF_RANGE]: "The message body provided contains characters whose codes fall outside the allowed range. In order to ensure clear-signing compatiblity with hardware wallets, the message may only contain line feeds and characters in the range [\\x20-\\x7e].",
    [SOLANA_ERROR__OFFCHAIN_MESSAGE__UNEXPECTED_VERSION]: "Expected offchain message version $expectedVersion. Got $actualVersion.",
    [SOLANA_ERROR__OFFCHAIN_MESSAGE__VERSION_NUMBER_NOT_SUPPORTED]: "This version of Kit does not support decoding offchain messages with version $unsupportedVersion. The current max supported version is 0.",
    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN]: "The notification name must end in 'Notifications' and the API must supply a subscription plan creator function for the notification '$notificationName'.",
    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED]: "WebSocket was closed before payload could be added to the send buffer",
    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED]: "WebSocket connection closed",
    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT]: "WebSocket failed to connect",
    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID]: "Failed to obtain a subscription id from the server",
    [SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD]: "Could not find an API plan for RPC method: `$method`",
    [SOLANA_ERROR__RPC__INTEGER_OVERFLOW]: "The $argumentLabel argument to the `$methodName` RPC method$optionalPathLabel was `$value`. This number is unsafe for use with the Solana JSON-RPC because it exceeds `Number.MAX_SAFE_INTEGER`.",
    [SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR]: "HTTP error ($statusCode): $message",
    [SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN]: "HTTP header(s) forbidden: $headers. Learn more at https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name.",
    [SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS]: "Multiple distinct signers were identified for address `$address`. Please ensure that you are using the same signer instance for each address.",
    [SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER]: "The provided value does not implement the `KeyPairSigner` interface",
    [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER]: "The provided value does not implement the `MessageModifyingSigner` interface",
    [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER]: "The provided value does not implement the `MessagePartialSigner` interface",
    [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER]: "The provided value does not implement any of the `MessageSigner` interfaces",
    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER]: "The provided value does not implement the `TransactionModifyingSigner` interface",
    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER]: "The provided value does not implement the `TransactionPartialSigner` interface",
    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER]: "The provided value does not implement the `TransactionSendingSigner` interface",
    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER]: "The provided value does not implement any of the `TransactionSigner` interfaces",
    [SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS]: "More than one `TransactionSendingSigner` was identified.",
    [SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING]: "No `TransactionSendingSigner` was identified. Please provide a valid `TransactionWithSingleSendingSigner` transaction.",
    [SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED]: "Wallet account signers do not support signing multiple messages/transactions in a single operation",
    [SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY]: "Cannot export a non-extractable key.",
    [SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED]: "No digest implementation could be found.",
    [SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT]: "Cryptographic operations are only allowed in secure browser contexts. Read more here: https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts.",
    [SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED]: `This runtime does not support the generation of Ed25519 key pairs.

Install @solana/webcrypto-ed25519-polyfill and call its \`install\` function before generating keys in environments that do not support Ed25519.

For a list of runtimes that currently support Ed25519 operations, visit https://github.com/WICG/webcrypto-secure-curves/issues/20.`,
    [SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED]: "No signature verification implementation could be found.",
    [SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED]: "No key generation implementation could be found.",
    [SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED]: "No signing implementation could be found.",
    [SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED]: "No key export implementation could be found.",
    [SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE]: "Timestamp value must be in the range [-(2n ** 63n), (2n ** 63n) - 1]. `$value` given",
    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING]: "Transaction processing left an account with an outstanding borrowed reference",
    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE]: "Account in use",
    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE]: "Account loaded twice",
    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND]: "Attempt to debit an account but found no record of a prior credit.",
    [SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND]: "Transaction loads an address table account that doesn't exist",
    [SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED]: "This transaction has already been processed",
    [SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND]: "Blockhash not found",
    [SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP]: "Loader call chain is too deep",
    [SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE]: "Transactions are currently disabled due to cluster maintenance",
    [SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION]: "Transaction contains a duplicate instruction ($index) that is not allowed",
    [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE]: "Insufficient funds for fee",
    [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT]: "Transaction results in an account ($accountIndex) with insufficient funds for rent",
    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE]: "This account may not be used to pay transaction fees",
    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX]: "Transaction contains an invalid account reference",
    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA]: "Transaction loads an address table account with invalid data",
    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX]: "Transaction address table lookup uses an invalid index",
    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER]: "Transaction loads an address table account with an invalid owner",
    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT]: "LoadedAccountsDataSizeLimit set for transaction must be greater than 0.",
    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION]: "This program may not be used for executing instructions",
    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT]: "Transaction leaves an account with a lower balance than rent-exempt minimum",
    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT]: "Transaction loads a writable account that cannot be written",
    [SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED]: "Transaction exceeded max loaded accounts data size cap",
    [SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE]: "Transaction requires a fee but has no signature present",
    [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND]: "Attempt to load a program that does not exist",
    [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED]: "Execution of the program referenced by account at index $accountIndex is temporarily restricted.",
    [SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED]: "ResanitizationNeeded",
    [SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE]: "Transaction failed to sanitize accounts offsets correctly",
    [SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE]: "Transaction did not pass signature verification",
    [SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS]: "Transaction locked too many accounts",
    [SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION]: "Sum of account balances before and after transaction do not match",
    [SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN]: "The transaction failed with the error `$errorName`",
    [SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION]: "Transaction version is unsupported",
    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT]: "Transaction would exceed account data limit within the block",
    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT]: "Transaction would exceed total account data limit",
    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT]: "Transaction would exceed max account limit within the block",
    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT]: "Transaction would exceed max Block Cost Limit",
    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT]: "Transaction would exceed max Vote Cost Limit",
    [SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION]: "Attempted to sign a transaction with an address that is not a signer for it",
    [SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING]: "Transaction is missing an address at index: $index.",
    [SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES]: "Transaction has no expected signers therefore it cannot be encoded",
    [SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT]: "Transaction size $transactionSize exceeds limit of $transactionSizeLimit bytes",
    [SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME]: "Transaction does not have a blockhash lifetime",
    [SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME]: "Transaction is not a durable nonce transaction",
    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING]: "Contents of these address lookup tables unknown: $lookupTableAddresses",
    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE]: "Lookup of address at index $highestRequestedIndex failed for lookup table `$lookupTableAddress`. Highest known index is $highestKnownIndex. The lookup table may have been extended since its contents were retrieved",
    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING]: "No fee payer set in CompiledTransaction",
    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND]: "Could not find program address at index $index",
    [SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT]: "Failed to estimate the compute unit consumption for this transaction message. This is likely because simulating the transaction failed. Inspect the `cause` property of this error to learn more",
    [SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT]: "Transaction failed when it was simulated in order to estimate the compute unit consumption. The compute unit estimate provided is for a transaction that failed when simulated and may not be representative of the compute units this transaction would consume if successful. Inspect the `cause` property of this error to learn more",
    [SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING]: "Transaction is missing a fee payer.",
    [SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING]: "Could not determine this transaction's signature. Make sure that the transaction has been signed by its fee payer.",
    [SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE]: "Transaction first instruction is not advance nonce account instruction.",
    [SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING]: "Transaction with no instructions cannot be durable nonce transaction.",
    [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES]: "This transaction includes an address (`$programAddress`) which is both invoked and set as the fee payer. Program addresses may not pay fees",
    [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE]: "This transaction includes an address (`$programAddress`) which is both invoked and marked writable. Program addresses may not be writable",
    [SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH]: "The transaction message expected the transaction to have $numRequiredSignatures signatures, got $signaturesLength.",
    [SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING]: "Transaction is missing signatures for addresses: $addresses.",
    [SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE]: "Transaction version must be in the range [0, 127]. `$actualVersion` given",
    [SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_NOT_SUPPORTED]: "This version of Kit does not support decoding transactions with version $unsupportedVersion. The current max supported version is 0.",
    [SOLANA_ERROR__TRANSACTION__NONCE_ACCOUNT_CANNOT_BE_IN_LOOKUP_TABLE]: "The transaction has a durable nonce lifetime (with nonce `$nonce`), but the nonce account address is in a lookup table. The lifetime constraint cannot be constructed without fetching the lookup tables for the transaction."
  };
  SolanaError = class extends Error {
    cause = this.cause;
    context;
    constructor(...[code, contextAndErrorOptions]) {
      let context;
      let errorOptions;
      if (contextAndErrorOptions) {
        Object.entries(Object.getOwnPropertyDescriptors(contextAndErrorOptions)).forEach(([name, descriptor]) => {
          if (name === "cause") {
            errorOptions = { cause: descriptor.value };
          } else {
            if (context === undefined) {
              context = {
                __code: code
              };
            }
            Object.defineProperty(context, name, descriptor);
          }
        });
      }
      const message = getErrorMessage(code, context);
      super(message, errorOptions);
      this.context = Object.freeze(context === undefined ? {
        __code: code
      } : context);
      this.name = "SolanaError";
    }
  };
  ORDERED_ERROR_NAMES = [
    "GenericError",
    "InvalidArgument",
    "InvalidInstructionData",
    "InvalidAccountData",
    "AccountDataTooSmall",
    "InsufficientFunds",
    "IncorrectProgramId",
    "MissingRequiredSignature",
    "AccountAlreadyInitialized",
    "UninitializedAccount",
    "UnbalancedInstruction",
    "ModifiedProgramId",
    "ExternalAccountLamportSpend",
    "ExternalAccountDataModified",
    "ReadonlyLamportChange",
    "ReadonlyDataModified",
    "DuplicateAccountIndex",
    "ExecutableModified",
    "RentEpochModified",
    "NotEnoughAccountKeys",
    "AccountDataSizeChanged",
    "AccountNotExecutable",
    "AccountBorrowFailed",
    "AccountBorrowOutstanding",
    "DuplicateAccountOutOfSync",
    "Custom",
    "InvalidError",
    "ExecutableDataModified",
    "ExecutableLamportChange",
    "ExecutableAccountNotRentExempt",
    "UnsupportedProgramId",
    "CallDepth",
    "MissingAccount",
    "ReentrancyNotAllowed",
    "MaxSeedLengthExceeded",
    "InvalidSeeds",
    "InvalidRealloc",
    "ComputationalBudgetExceeded",
    "PrivilegeEscalation",
    "ProgramEnvironmentSetupFailure",
    "ProgramFailedToComplete",
    "ProgramFailedToCompile",
    "Immutable",
    "IncorrectAuthority",
    "BorshIoError",
    "AccountNotRentExempt",
    "InvalidAccountOwner",
    "ArithmeticOverflow",
    "UnsupportedSysvar",
    "IllegalOwner",
    "MaxAccountsDataAllocationsExceeded",
    "MaxAccountsExceeded",
    "MaxInstructionTraceLengthExceeded",
    "BuiltinProgramsMustConsumeComputeUnits"
  ];
  ORDERED_ERROR_NAMES2 = [
    "AccountInUse",
    "AccountLoadedTwice",
    "AccountNotFound",
    "ProgramAccountNotFound",
    "InsufficientFundsForFee",
    "InvalidAccountForFee",
    "AlreadyProcessed",
    "BlockhashNotFound",
    "CallChainTooDeep",
    "MissingSignatureForFee",
    "InvalidAccountIndex",
    "SignatureFailure",
    "InvalidProgramForExecution",
    "SanitizeFailure",
    "ClusterMaintenance",
    "AccountBorrowOutstanding",
    "WouldExceedMaxBlockCostLimit",
    "UnsupportedVersion",
    "InvalidWritableAccount",
    "WouldExceedMaxAccountCostLimit",
    "WouldExceedAccountDataBlockLimit",
    "TooManyAccountLocks",
    "AddressLookupTableNotFound",
    "InvalidAddressLookupTableOwner",
    "InvalidAddressLookupTableData",
    "InvalidAddressLookupTableIndex",
    "InvalidRentPayingAccount",
    "WouldExceedMaxVoteCostLimit",
    "WouldExceedAccountDataTotalLimit",
    "DuplicateInstruction",
    "InsufficientFundsForRent",
    "MaxLoadedAccountsDataSizeExceeded",
    "InvalidLoadedAccountsDataSizeLimit",
    "ResanitizationNeeded",
    "ProgramExecutionTemporarilyRestricted",
    "UnbalancedTransaction"
  ];
});

// ../node_modules/.bun/@solana+codecs-core@5.1.0+1fb4c65d43e298b9/node_modules/@solana/codecs-core/dist/index.node.mjs
function padBytes(bytes, length) {
  if (bytes.length >= length)
    return bytes;
  const paddedBytes = new Uint8Array(length).fill(0);
  paddedBytes.set(bytes);
  return paddedBytes;
}
function containsBytes(data2, bytes, offset) {
  const slice = offset === 0 && data2.length === bytes.length ? data2 : data2.slice(offset, offset + bytes.length);
  return bytesEqual(slice, bytes);
}
function bytesEqual(bytes1, bytes2) {
  return bytes1.length === bytes2.length && bytes1.every((value, index) => value === bytes2[index]);
}
function getEncodedSize(value, encoder2) {
  return "fixedSize" in encoder2 ? encoder2.fixedSize : encoder2.getSizeFromValue(value);
}
function createEncoder(encoder2) {
  return Object.freeze({
    ...encoder2,
    encode: (value) => {
      const bytes = new Uint8Array(getEncodedSize(value, encoder2));
      encoder2.write(value, bytes, 0);
      return bytes;
    }
  });
}
function createDecoder(decoder) {
  return Object.freeze({
    ...decoder,
    decode: (bytes, offset = 0) => decoder.read(bytes, offset)[0]
  });
}
function createCodec(codec) {
  return Object.freeze({
    ...codec,
    decode: (bytes, offset = 0) => codec.read(bytes, offset)[0],
    encode: (value) => {
      const bytes = new Uint8Array(getEncodedSize(value, codec));
      codec.write(value, bytes, 0);
      return bytes;
    }
  });
}
function isFixedSize(codec) {
  return "fixedSize" in codec && typeof codec.fixedSize === "number";
}
function assertIsFixedSize(codec) {
  if (!isFixedSize(codec)) {
    throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH);
  }
}
function isVariableSize(codec) {
  return !isFixedSize(codec);
}
function assertIsVariableSize(codec) {
  if (!isVariableSize(codec)) {
    throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH);
  }
}
function combineCodec(encoder2, decoder) {
  if (isFixedSize(encoder2) !== isFixedSize(decoder)) {
    throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH);
  }
  if (isFixedSize(encoder2) && isFixedSize(decoder) && encoder2.fixedSize !== decoder.fixedSize) {
    throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH, {
      decoderFixedSize: decoder.fixedSize,
      encoderFixedSize: encoder2.fixedSize
    });
  }
  if (!isFixedSize(encoder2) && !isFixedSize(decoder) && encoder2.maxSize !== decoder.maxSize) {
    throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH, {
      decoderMaxSize: decoder.maxSize,
      encoderMaxSize: encoder2.maxSize
    });
  }
  return {
    ...decoder,
    ...encoder2,
    decode: decoder.decode,
    encode: encoder2.encode,
    read: decoder.read,
    write: encoder2.write
  };
}
function addEncoderSentinel(encoder2, sentinel) {
  const write = (value, bytes, offset) => {
    const encoderBytes = encoder2.encode(value);
    if (findSentinelIndex(encoderBytes, sentinel) >= 0) {
      throw new SolanaError(SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL, {
        encodedBytes: encoderBytes,
        hexEncodedBytes: hexBytes(encoderBytes),
        hexSentinel: hexBytes(sentinel),
        sentinel
      });
    }
    bytes.set(encoderBytes, offset);
    offset += encoderBytes.length;
    bytes.set(sentinel, offset);
    offset += sentinel.length;
    return offset;
  };
  if (isFixedSize(encoder2)) {
    return createEncoder({ ...encoder2, fixedSize: encoder2.fixedSize + sentinel.length, write });
  }
  return createEncoder({
    ...encoder2,
    ...encoder2.maxSize != null ? { maxSize: encoder2.maxSize + sentinel.length } : {},
    getSizeFromValue: (value) => encoder2.getSizeFromValue(value) + sentinel.length,
    write
  });
}
function addDecoderSentinel(decoder, sentinel) {
  const read = (bytes, offset) => {
    const candidateBytes = offset === 0 ? bytes : bytes.slice(offset);
    const sentinelIndex = findSentinelIndex(candidateBytes, sentinel);
    if (sentinelIndex === -1) {
      throw new SolanaError(SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES, {
        decodedBytes: candidateBytes,
        hexDecodedBytes: hexBytes(candidateBytes),
        hexSentinel: hexBytes(sentinel),
        sentinel
      });
    }
    const preSentinelBytes = candidateBytes.slice(0, sentinelIndex);
    return [decoder.decode(preSentinelBytes), offset + preSentinelBytes.length + sentinel.length];
  };
  if (isFixedSize(decoder)) {
    return createDecoder({ ...decoder, fixedSize: decoder.fixedSize + sentinel.length, read });
  }
  return createDecoder({
    ...decoder,
    ...decoder.maxSize != null ? { maxSize: decoder.maxSize + sentinel.length } : {},
    read
  });
}
function addCodecSentinel(codec, sentinel) {
  return combineCodec(addEncoderSentinel(codec, sentinel), addDecoderSentinel(codec, sentinel));
}
function findSentinelIndex(bytes, sentinel) {
  return bytes.findIndex((byte, index, arr) => {
    if (sentinel.length === 1)
      return byte === sentinel[0];
    return containsBytes(arr, sentinel, index);
  });
}
function hexBytes(bytes) {
  return bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, "0"), "");
}
function assertByteArrayIsNotEmptyForCodec(codecDescription, bytes, offset = 0) {
  if (bytes.length - offset <= 0) {
    throw new SolanaError(SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY, {
      codecDescription
    });
  }
}
function assertByteArrayHasEnoughBytesForCodec(codecDescription, expected, bytes, offset = 0) {
  const bytesLength = bytes.length - offset;
  if (bytesLength < expected) {
    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH, {
      bytesLength,
      codecDescription,
      expected
    });
  }
}
function assertByteArrayOffsetIsNotOutOfRange(codecDescription, offset, bytesLength) {
  if (offset < 0 || offset > bytesLength) {
    throw new SolanaError(SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE, {
      bytesLength,
      codecDescription,
      offset
    });
  }
}
function addEncoderSizePrefix(encoder2, prefix) {
  const write = (value, bytes, offset) => {
    const encoderBytes = encoder2.encode(value);
    offset = prefix.write(encoderBytes.length, bytes, offset);
    bytes.set(encoderBytes, offset);
    return offset + encoderBytes.length;
  };
  if (isFixedSize(prefix) && isFixedSize(encoder2)) {
    return createEncoder({ ...encoder2, fixedSize: prefix.fixedSize + encoder2.fixedSize, write });
  }
  const prefixMaxSize = isFixedSize(prefix) ? prefix.fixedSize : prefix.maxSize ?? null;
  const encoderMaxSize = isFixedSize(encoder2) ? encoder2.fixedSize : encoder2.maxSize ?? null;
  const maxSize = prefixMaxSize !== null && encoderMaxSize !== null ? prefixMaxSize + encoderMaxSize : null;
  return createEncoder({
    ...encoder2,
    ...maxSize !== null ? { maxSize } : {},
    getSizeFromValue: (value) => {
      const encoderSize = getEncodedSize(value, encoder2);
      return getEncodedSize(encoderSize, prefix) + encoderSize;
    },
    write
  });
}
function addDecoderSizePrefix(decoder, prefix) {
  const read = (bytes, offset) => {
    const [bigintSize, decoderOffset] = prefix.read(bytes, offset);
    const size = Number(bigintSize);
    offset = decoderOffset;
    if (offset > 0 || bytes.length > size) {
      bytes = bytes.slice(offset, offset + size);
    }
    assertByteArrayHasEnoughBytesForCodec("addDecoderSizePrefix", size, bytes);
    return [decoder.decode(bytes), offset + size];
  };
  if (isFixedSize(prefix) && isFixedSize(decoder)) {
    return createDecoder({ ...decoder, fixedSize: prefix.fixedSize + decoder.fixedSize, read });
  }
  const prefixMaxSize = isFixedSize(prefix) ? prefix.fixedSize : prefix.maxSize ?? null;
  const decoderMaxSize = isFixedSize(decoder) ? decoder.fixedSize : decoder.maxSize ?? null;
  const maxSize = prefixMaxSize !== null && decoderMaxSize !== null ? prefixMaxSize + decoderMaxSize : null;
  return createDecoder({ ...decoder, ...maxSize !== null ? { maxSize } : {}, read });
}
function addCodecSizePrefix(codec, prefix) {
  return combineCodec(addEncoderSizePrefix(codec, prefix), addDecoderSizePrefix(codec, prefix));
}
function createDecoderThatConsumesEntireByteArray(decoder) {
  return createDecoder({
    ...decoder,
    read(bytes, offset) {
      const [value, newOffset] = decoder.read(bytes, offset);
      if (bytes.length > newOffset) {
        throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_DECODER_TO_CONSUME_ENTIRE_BYTE_ARRAY, {
          expectedLength: newOffset,
          numExcessBytes: bytes.length - newOffset
        });
      }
      return [value, newOffset];
    }
  });
}
function fixEncoderSize(encoder2, fixedBytes) {
  return createEncoder({
    fixedSize: fixedBytes,
    write: (value, bytes, offset) => {
      const variableByteArray = encoder2.encode(value);
      const fixedByteArray = variableByteArray.length > fixedBytes ? variableByteArray.slice(0, fixedBytes) : variableByteArray;
      bytes.set(fixedByteArray, offset);
      return offset + fixedBytes;
    }
  });
}
function fixDecoderSize(decoder, fixedBytes) {
  return createDecoder({
    fixedSize: fixedBytes,
    read: (bytes, offset) => {
      assertByteArrayHasEnoughBytesForCodec("fixCodecSize", fixedBytes, bytes, offset);
      if (offset > 0 || bytes.length > fixedBytes) {
        bytes = bytes.slice(offset, offset + fixedBytes);
      }
      if (isFixedSize(decoder)) {
        bytes = fixBytes(bytes, decoder.fixedSize);
      }
      const [value] = decoder.read(bytes, 0);
      return [value, offset + fixedBytes];
    }
  });
}
function fixCodecSize(codec, fixedBytes) {
  return combineCodec(fixEncoderSize(codec, fixedBytes), fixDecoderSize(codec, fixedBytes));
}
function offsetEncoder(encoder2, config) {
  return createEncoder({
    ...encoder2,
    write: (value, bytes, preOffset) => {
      const wrapBytes = (offset) => modulo(offset, bytes.length);
      const newPreOffset = config.preOffset ? config.preOffset({ bytes, preOffset, wrapBytes }) : preOffset;
      assertByteArrayOffsetIsNotOutOfRange("offsetEncoder", newPreOffset, bytes.length);
      const postOffset = encoder2.write(value, bytes, newPreOffset);
      const newPostOffset = config.postOffset ? config.postOffset({ bytes, newPreOffset, postOffset, preOffset, wrapBytes }) : postOffset;
      assertByteArrayOffsetIsNotOutOfRange("offsetEncoder", newPostOffset, bytes.length);
      return newPostOffset;
    }
  });
}
function offsetDecoder(decoder, config) {
  return createDecoder({
    ...decoder,
    read: (bytes, preOffset) => {
      const wrapBytes = (offset) => modulo(offset, bytes.length);
      const newPreOffset = config.preOffset ? config.preOffset({ bytes, preOffset, wrapBytes }) : preOffset;
      assertByteArrayOffsetIsNotOutOfRange("offsetDecoder", newPreOffset, bytes.length);
      const [value, postOffset] = decoder.read(bytes, newPreOffset);
      const newPostOffset = config.postOffset ? config.postOffset({ bytes, newPreOffset, postOffset, preOffset, wrapBytes }) : postOffset;
      assertByteArrayOffsetIsNotOutOfRange("offsetDecoder", newPostOffset, bytes.length);
      return [value, newPostOffset];
    }
  });
}
function offsetCodec(codec, config) {
  return combineCodec(offsetEncoder(codec, config), offsetDecoder(codec, config));
}
function modulo(dividend, divisor) {
  if (divisor === 0)
    return 0;
  return (dividend % divisor + divisor) % divisor;
}
function resizeEncoder(encoder2, resize) {
  if (isFixedSize(encoder2)) {
    const fixedSize = resize(encoder2.fixedSize);
    if (fixedSize < 0) {
      throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {
        bytesLength: fixedSize,
        codecDescription: "resizeEncoder"
      });
    }
    return createEncoder({ ...encoder2, fixedSize });
  }
  return createEncoder({
    ...encoder2,
    getSizeFromValue: (value) => {
      const newSize = resize(encoder2.getSizeFromValue(value));
      if (newSize < 0) {
        throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {
          bytesLength: newSize,
          codecDescription: "resizeEncoder"
        });
      }
      return newSize;
    }
  });
}
function resizeDecoder(decoder, resize) {
  if (isFixedSize(decoder)) {
    const fixedSize = resize(decoder.fixedSize);
    if (fixedSize < 0) {
      throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {
        bytesLength: fixedSize,
        codecDescription: "resizeDecoder"
      });
    }
    return createDecoder({ ...decoder, fixedSize });
  }
  return decoder;
}
function resizeCodec(codec, resize) {
  return combineCodec(resizeEncoder(codec, resize), resizeDecoder(codec, resize));
}
function padLeftEncoder(encoder2, offset) {
  return offsetEncoder(resizeEncoder(encoder2, (size) => size + offset), { preOffset: ({ preOffset }) => preOffset + offset });
}
function padRightEncoder(encoder2, offset) {
  return offsetEncoder(resizeEncoder(encoder2, (size) => size + offset), { postOffset: ({ postOffset }) => postOffset + offset });
}
function padLeftDecoder(decoder, offset) {
  return offsetDecoder(resizeDecoder(decoder, (size) => size + offset), { preOffset: ({ preOffset }) => preOffset + offset });
}
function padRightDecoder(decoder, offset) {
  return offsetDecoder(resizeDecoder(decoder, (size) => size + offset), { postOffset: ({ postOffset }) => postOffset + offset });
}
function padLeftCodec(codec, offset) {
  return combineCodec(padLeftEncoder(codec, offset), padLeftDecoder(codec, offset));
}
function padRightCodec(codec, offset) {
  return combineCodec(padRightEncoder(codec, offset), padRightDecoder(codec, offset));
}
function copySourceToTargetInReverse(source, target_WILL_MUTATE, sourceOffset, sourceLength, targetOffset = 0) {
  while (sourceOffset < --sourceLength) {
    const leftValue = source[sourceOffset];
    target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceLength];
    target_WILL_MUTATE[sourceLength + targetOffset] = leftValue;
    sourceOffset++;
  }
  if (sourceOffset === sourceLength) {
    target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceOffset];
  }
}
function reverseEncoder(encoder2) {
  assertIsFixedSize(encoder2);
  return createEncoder({
    ...encoder2,
    write: (value, bytes, offset) => {
      const newOffset = encoder2.write(value, bytes, offset);
      copySourceToTargetInReverse(bytes, bytes, offset, offset + encoder2.fixedSize);
      return newOffset;
    }
  });
}
function reverseDecoder(decoder) {
  assertIsFixedSize(decoder);
  return createDecoder({
    ...decoder,
    read: (bytes, offset) => {
      const reversedBytes = bytes.slice();
      copySourceToTargetInReverse(bytes, reversedBytes, offset, offset + decoder.fixedSize);
      return decoder.read(reversedBytes, offset);
    }
  });
}
function reverseCodec(codec) {
  return combineCodec(reverseEncoder(codec), reverseDecoder(codec));
}
function transformEncoder(encoder2, unmap) {
  return createEncoder({
    ...isVariableSize(encoder2) ? { ...encoder2, getSizeFromValue: (value) => encoder2.getSizeFromValue(unmap(value)) } : encoder2,
    write: (value, bytes, offset) => encoder2.write(unmap(value), bytes, offset)
  });
}
function transformDecoder(decoder, map) {
  return createDecoder({
    ...decoder,
    read: (bytes, offset) => {
      const [value, newOffset] = decoder.read(bytes, offset);
      return [map(value, bytes, offset), newOffset];
    }
  });
}
function transformCodec(codec, unmap, map) {
  return createCodec({
    ...transformEncoder(codec, unmap),
    read: map ? transformDecoder(codec, map).read : codec.read
  });
}
var mergeBytes = (byteArrays) => {
  const nonEmptyByteArrays = byteArrays.filter((arr) => arr.length);
  if (nonEmptyByteArrays.length === 0) {
    return byteArrays.length ? byteArrays[0] : new Uint8Array;
  }
  if (nonEmptyByteArrays.length === 1) {
    return nonEmptyByteArrays[0];
  }
  const totalLength = nonEmptyByteArrays.reduce((total, arr) => total + arr.length, 0);
  const result = new Uint8Array(totalLength);
  let offset = 0;
  nonEmptyByteArrays.forEach((arr) => {
    result.set(arr, offset);
    offset += arr.length;
  });
  return result;
}, fixBytes = (bytes, length) => padBytes(bytes.length <= length ? bytes : bytes.slice(0, length), length);
var init_index_node2 = __esm(() => {
  init_index_node();
});

// ../node_modules/.bun/@solana+codecs-strings@5.1.0+7f9e3d21594a24ff/node_modules/@solana/codecs-strings/dist/index.node.mjs
function assertValidBaseString(alphabet4, testValue, givenValue = testValue) {
  if (!testValue.match(new RegExp(`^[${alphabet4}]*$`))) {
    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {
      alphabet: alphabet4,
      base: alphabet4.length,
      value: givenValue
    });
  }
}
function partitionLeadingZeroes(value, zeroCharacter) {
  const [leadingZeros, tailChars] = value.split(new RegExp(`((?!${zeroCharacter}).*)`));
  return [leadingZeros, tailChars];
}
function getBigIntFromBaseX(value, alphabet4) {
  const base = BigInt(alphabet4.length);
  let sum = 0n;
  for (const char of value) {
    sum *= base;
    sum += BigInt(alphabet4.indexOf(char));
  }
  return sum;
}
function getBaseXFromBigInt(value, alphabet4) {
  const base = BigInt(alphabet4.length);
  const tailChars = [];
  while (value > 0n) {
    tailChars.unshift(alphabet4[Number(value % base)]);
    value /= base;
  }
  return tailChars.join("");
}
function charCodeToBase16(char) {
  if (char >= 48 && char <= 57)
    return char - 48;
  if (char >= 65 && char <= 70)
    return char - (65 - 10);
  if (char >= 97 && char <= 102)
    return char - (97 - 10);
}
function reslice(input, inputBits, outputBits, useRemainder) {
  const output = [];
  let accumulator = 0;
  let bitsInAccumulator = 0;
  const mask = (1 << outputBits) - 1;
  for (const value of input) {
    accumulator = accumulator << inputBits | value;
    bitsInAccumulator += inputBits;
    while (bitsInAccumulator >= outputBits) {
      bitsInAccumulator -= outputBits;
      output.push(accumulator >> bitsInAccumulator & mask);
    }
  }
  if (useRemainder && bitsInAccumulator > 0) {
    output.push(accumulator << outputBits - bitsInAccumulator & mask);
  }
  return output;
}
var getBaseXEncoder = (alphabet4) => {
  return createEncoder({
    getSizeFromValue: (value) => {
      const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet4[0]);
      if (!tailChars)
        return value.length;
      const base10Number = getBigIntFromBaseX(tailChars, alphabet4);
      return leadingZeroes.length + Math.ceil(base10Number.toString(16).length / 2);
    },
    write(value, bytes, offset) {
      assertValidBaseString(alphabet4, value);
      if (value === "")
        return offset;
      const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet4[0]);
      if (!tailChars) {
        bytes.set(new Uint8Array(leadingZeroes.length).fill(0), offset);
        return offset + leadingZeroes.length;
      }
      let base10Number = getBigIntFromBaseX(tailChars, alphabet4);
      const tailBytes = [];
      while (base10Number > 0n) {
        tailBytes.unshift(Number(base10Number % 256n));
        base10Number /= 256n;
      }
      const bytesToAdd = [...Array(leadingZeroes.length).fill(0), ...tailBytes];
      bytes.set(bytesToAdd, offset);
      return offset + bytesToAdd.length;
    }
  });
}, getBaseXDecoder = (alphabet4) => {
  return createDecoder({
    read(rawBytes, offset) {
      const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);
      if (bytes.length === 0)
        return ["", 0];
      let trailIndex = bytes.findIndex((n) => n !== 0);
      trailIndex = trailIndex === -1 ? bytes.length : trailIndex;
      const leadingZeroes = alphabet4[0].repeat(trailIndex);
      if (trailIndex === bytes.length)
        return [leadingZeroes, rawBytes.length];
      const base10Number = bytes.slice(trailIndex).reduce((sum, byte) => sum * 256n + BigInt(byte), 0n);
      const tailChars = getBaseXFromBigInt(base10Number, alphabet4);
      return [leadingZeroes + tailChars, rawBytes.length];
    }
  });
}, getBaseXCodec = (alphabet4) => combineCodec(getBaseXEncoder(alphabet4), getBaseXDecoder(alphabet4)), alphabet = "0123456789", getBase10Encoder = () => getBaseXEncoder(alphabet), getBase10Decoder = () => getBaseXDecoder(alphabet), getBase10Codec = () => getBaseXCodec(alphabet), INVALID_STRING_ERROR_BASE_CONFIG, getBase16Encoder = () => createEncoder({
  getSizeFromValue: (value) => Math.ceil(value.length / 2),
  write(value, bytes, offset) {
    const len = value.length;
    const al = len / 2;
    if (len === 1) {
      const c = value.charCodeAt(0);
      const n = charCodeToBase16(c);
      if (n === undefined) {
        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {
          ...INVALID_STRING_ERROR_BASE_CONFIG,
          value
        });
      }
      bytes.set([n], offset);
      return 1 + offset;
    }
    const hexBytes2 = new Uint8Array(al);
    for (let i = 0, j = 0;i < al; i++) {
      const c1 = value.charCodeAt(j++);
      const c2 = value.charCodeAt(j++);
      const n1 = charCodeToBase16(c1);
      const n2 = charCodeToBase16(c2);
      if (n1 === undefined || n2 === undefined && !Number.isNaN(c2)) {
        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {
          ...INVALID_STRING_ERROR_BASE_CONFIG,
          value
        });
      }
      hexBytes2[i] = !Number.isNaN(c2) ? n1 << 4 | (n2 ?? 0) : n1;
    }
    bytes.set(hexBytes2, offset);
    return hexBytes2.length + offset;
  }
}), getBase16Decoder = () => createDecoder({
  read(bytes, offset) {
    const value = bytes.slice(offset).reduce((str, byte) => str + byte.toString(16).padStart(2, "0"), "");
    return [value, bytes.length];
  }
}), getBase16Codec = () => combineCodec(getBase16Encoder(), getBase16Decoder()), alphabet2 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz", getBase58Encoder = () => getBaseXEncoder(alphabet2), getBase58Decoder = () => getBaseXDecoder(alphabet2), getBase58Codec = () => getBaseXCodec(alphabet2), getBaseXResliceEncoder = (alphabet4, bits) => createEncoder({
  getSizeFromValue: (value) => Math.floor(value.length * bits / 8),
  write(value, bytes, offset) {
    assertValidBaseString(alphabet4, value);
    if (value === "")
      return offset;
    const charIndices = [...value].map((c) => alphabet4.indexOf(c));
    const reslicedBytes = reslice(charIndices, bits, 8, false);
    bytes.set(reslicedBytes, offset);
    return reslicedBytes.length + offset;
  }
}), getBaseXResliceDecoder = (alphabet4, bits) => createDecoder({
  read(rawBytes, offset = 0) {
    const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);
    if (bytes.length === 0)
      return ["", rawBytes.length];
    const charIndices = reslice([...bytes], 8, bits, true);
    return [charIndices.map((i) => alphabet4[i]).join(""), rawBytes.length];
  }
}), getBaseXResliceCodec = (alphabet4, bits) => combineCodec(getBaseXResliceEncoder(alphabet4, bits), getBaseXResliceDecoder(alphabet4, bits)), alphabet3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", getBase64Encoder = () => {
  {
    return createEncoder({
      getSizeFromValue: (value) => Buffer.from(value, "base64").length,
      write(value, bytes, offset) {
        assertValidBaseString(alphabet3, value.replace(/=/g, ""));
        const buffer2 = Buffer.from(value, "base64");
        bytes.set(buffer2, offset);
        return buffer2.length + offset;
      }
    });
  }
}, getBase64Decoder = () => {
  {
    return createDecoder({
      read: (bytes, offset = 0) => [Buffer.from(bytes, offset).toString("base64"), bytes.length]
    });
  }
}, getBase64Codec = () => combineCodec(getBase64Encoder(), getBase64Decoder()), removeNullCharacters = (value) => value.replace(/\u0000/g, ""), padNullCharacters = (value, chars) => value.padEnd(chars, "\x00"), e, o, getUtf8Encoder = () => {
  let textEncoder;
  return createEncoder({
    getSizeFromValue: (value) => (textEncoder ||= new o).encode(value).length,
    write: (value, bytes, offset) => {
      const bytesToAdd = (textEncoder ||= new o).encode(value);
      bytes.set(bytesToAdd, offset);
      return offset + bytesToAdd.length;
    }
  });
}, getUtf8Decoder = () => {
  let textDecoder;
  return createDecoder({
    read(bytes, offset) {
      const value = (textDecoder ||= new e).decode(bytes.slice(offset));
      return [removeNullCharacters(value), bytes.length];
    }
  });
}, getUtf8Codec = () => combineCodec(getUtf8Encoder(), getUtf8Decoder());
var init_index_node3 = __esm(() => {
  init_index_node();
  init_index_node2();
  INVALID_STRING_ERROR_BASE_CONFIG = {
    alphabet: "0123456789abcdef",
    base: 16
  };
  e = globalThis.TextDecoder;
  o = globalThis.TextEncoder;
});

// ../node_modules/.bun/@solana+assertions@5.1.0+1fb4c65d43e298b9/node_modules/@solana/assertions/dist/index.node.mjs
function assertPRNGIsAvailable() {
  if (typeof globalThis.crypto === "undefined" || typeof globalThis.crypto.getRandomValues !== "function") {
    throw new SolanaError(SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED);
  }
}
async function isEd25519CurveSupported(subtle) {
  if (cachedEd25519Decision === undefined) {
    cachedEd25519Decision = new Promise((resolve) => {
      subtle.generateKey("Ed25519", false, ["sign", "verify"]).then(() => {
        resolve(cachedEd25519Decision = true);
      }).catch(() => {
        resolve(cachedEd25519Decision = false);
      });
    });
  }
  if (typeof cachedEd25519Decision === "boolean") {
    return cachedEd25519Decision;
  } else {
    return await cachedEd25519Decision;
  }
}
function assertDigestCapabilityIsAvailable() {
  if (typeof globalThis.crypto === "undefined" || typeof globalThis.crypto.subtle?.digest !== "function") {
    throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED);
  }
}
async function assertKeyGenerationIsAvailable() {
  if (typeof globalThis.crypto === "undefined" || typeof globalThis.crypto.subtle?.generateKey !== "function") {
    throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED);
  }
  if (!await isEd25519CurveSupported(globalThis.crypto.subtle)) {
    throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED);
  }
}
function assertKeyExporterIsAvailable() {
  if (typeof globalThis.crypto === "undefined" || typeof globalThis.crypto.subtle?.exportKey !== "function") {
    throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED);
  }
}
function assertSigningCapabilityIsAvailable() {
  if (typeof globalThis.crypto === "undefined" || typeof globalThis.crypto.subtle?.sign !== "function") {
    throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED);
  }
}
function assertVerificationCapabilityIsAvailable() {
  if (typeof globalThis.crypto === "undefined" || typeof globalThis.crypto.subtle?.verify !== "function") {
    throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED);
  }
}
var cachedEd25519Decision;
var init_index_node4 = __esm(() => {
  init_index_node();
});

// ../node_modules/.bun/@solana+addresses@5.1.0+7f9e3d21594a24ff/node_modules/@solana/addresses/dist/index.node.mjs
var exports_index_node = {};
__export(exports_index_node, {
  offCurveAddress: () => offCurveAddress,
  isProgramDerivedAddress: () => isProgramDerivedAddress,
  isOffCurveAddress: () => isOffCurveAddress,
  isAddress: () => isAddress,
  getPublicKeyFromAddress: () => getPublicKeyFromAddress,
  getProgramDerivedAddress: () => getProgramDerivedAddress,
  getAddressFromPublicKey: () => getAddressFromPublicKey,
  getAddressEncoder: () => getAddressEncoder,
  getAddressDecoder: () => getAddressDecoder,
  getAddressComparator: () => getAddressComparator,
  getAddressCodec: () => getAddressCodec,
  createAddressWithSeed: () => createAddressWithSeed,
  assertIsProgramDerivedAddress: () => assertIsProgramDerivedAddress,
  assertIsOffCurveAddress: () => assertIsOffCurveAddress,
  assertIsAddress: () => assertIsAddress,
  address: () => address
});
function getMemoizedBase58Encoder() {
  if (!memoizedBase58Encoder)
    memoizedBase58Encoder = getBase58Encoder();
  return memoizedBase58Encoder;
}
function getMemoizedBase58Decoder() {
  if (!memoizedBase58Decoder)
    memoizedBase58Decoder = getBase58Decoder();
  return memoizedBase58Decoder;
}
function isAddress(putativeAddress) {
  if (putativeAddress.length < 32 || putativeAddress.length > 44) {
    return false;
  }
  const base58Encoder = getMemoizedBase58Encoder();
  try {
    return base58Encoder.encode(putativeAddress).byteLength === 32;
  } catch {
    return false;
  }
}
function assertIsAddress(putativeAddress) {
  if (putativeAddress.length < 32 || putativeAddress.length > 44) {
    throw new SolanaError(SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE, {
      actualLength: putativeAddress.length
    });
  }
  const base58Encoder = getMemoizedBase58Encoder();
  const bytes = base58Encoder.encode(putativeAddress);
  const numBytes = bytes.byteLength;
  if (numBytes !== 32) {
    throw new SolanaError(SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH, {
      actualLength: numBytes
    });
  }
}
function address(putativeAddress) {
  assertIsAddress(putativeAddress);
  return putativeAddress;
}
function getAddressEncoder() {
  return transformEncoder(fixEncoderSize(getMemoizedBase58Encoder(), 32), (putativeAddress) => address(putativeAddress));
}
function getAddressDecoder() {
  return fixDecoderSize(getMemoizedBase58Decoder(), 32);
}
function getAddressCodec() {
  return combineCodec(getAddressEncoder(), getAddressDecoder());
}
function getAddressComparator() {
  return new Intl.Collator("en", {
    caseFirst: "lower",
    ignorePunctuation: false,
    localeMatcher: "best fit",
    numeric: false,
    sensitivity: "variant",
    usage: "sort"
  }).compare;
}
function mod(a) {
  const r = a % P;
  return r >= 0n ? r : P + r;
}
function pow2(x, power) {
  let r = x;
  while (power-- > 0n) {
    r *= r;
    r %= P;
  }
  return r;
}
function pow_2_252_3(x) {
  const x2 = x * x % P;
  const b2 = x2 * x % P;
  const b4 = pow2(b2, 2n) * b2 % P;
  const b5 = pow2(b4, 1n) * x % P;
  const b10 = pow2(b5, 5n) * b5 % P;
  const b20 = pow2(b10, 10n) * b10 % P;
  const b40 = pow2(b20, 20n) * b20 % P;
  const b80 = pow2(b40, 40n) * b40 % P;
  const b160 = pow2(b80, 80n) * b80 % P;
  const b240 = pow2(b160, 80n) * b80 % P;
  const b250 = pow2(b240, 10n) * b10 % P;
  const pow_p_5_8 = pow2(b250, 2n) * x % P;
  return pow_p_5_8;
}
function uvRatio(u, v) {
  const v3 = mod(v * v * v);
  const v7 = mod(v3 * v3 * v);
  const pow = pow_2_252_3(u * v7);
  let x = mod(u * v3 * pow);
  const vx2 = mod(v * x * x);
  const root1 = x;
  const root2 = mod(x * RM1);
  const useRoot1 = vx2 === u;
  const useRoot2 = vx2 === mod(-u);
  const noRoot = vx2 === mod(-u * RM1);
  if (useRoot1)
    x = root1;
  if (useRoot2 || noRoot)
    x = root2;
  if ((mod(x) & 1n) === 1n)
    x = mod(-x);
  if (!useRoot1 && !useRoot2) {
    return null;
  }
  return x;
}
function pointIsOnCurve(y, lastByte) {
  const y2 = mod(y * y);
  const u = mod(y2 - 1n);
  const v = mod(D * y2 + 1n);
  const x = uvRatio(u, v);
  if (x === null) {
    return false;
  }
  const isLastByteOdd = (lastByte & 128) !== 0;
  if (x === 0n && isLastByteOdd) {
    return false;
  }
  return true;
}
function byteToHex(byte) {
  const hexString = byte.toString(16);
  if (hexString.length === 1) {
    return `0${hexString}`;
  } else {
    return hexString;
  }
}
function decompressPointBytes(bytes) {
  const hexString = bytes.reduce((acc, byte, ii) => `${byteToHex(ii === 31 ? byte & -129 : byte)}${acc}`, "");
  const integerLiteralString = `0x${hexString}`;
  return BigInt(integerLiteralString);
}
function compressedPointBytesAreOnCurve(bytes) {
  if (bytes.byteLength !== 32) {
    return false;
  }
  const y = decompressPointBytes(bytes);
  return pointIsOnCurve(y, bytes[31]);
}
function isOffCurveAddress(putativeOffCurveAddress) {
  const addressBytes = getAddressCodec().encode(putativeOffCurveAddress);
  return compressedPointBytesAreOnCurve(addressBytes) === false;
}
function assertIsOffCurveAddress(putativeOffCurveAddress) {
  if (!isOffCurveAddress(putativeOffCurveAddress)) {
    throw new SolanaError(SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS);
  }
}
function offCurveAddress(putativeOffCurveAddress) {
  assertIsOffCurveAddress(putativeOffCurveAddress);
  return putativeOffCurveAddress;
}
function isProgramDerivedAddress(value) {
  return Array.isArray(value) && value.length === 2 && typeof value[0] === "string" && typeof value[1] === "number" && value[1] >= 0 && value[1] <= 255 && isAddress(value[0]);
}
function assertIsProgramDerivedAddress(value) {
  const validFormat = Array.isArray(value) && value.length === 2 && typeof value[0] === "string" && typeof value[1] === "number";
  if (!validFormat) {
    throw new SolanaError(SOLANA_ERROR__ADDRESSES__MALFORMED_PDA);
  }
  if (value[1] < 0 || value[1] > 255) {
    throw new SolanaError(SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE, {
      bump: value[1]
    });
  }
  assertIsAddress(value[0]);
}
async function createProgramDerivedAddress({ programAddress, seeds }) {
  assertDigestCapabilityIsAvailable();
  if (seeds.length > MAX_SEEDS) {
    throw new SolanaError(SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED, {
      actual: seeds.length,
      maxSeeds: MAX_SEEDS
    });
  }
  let textEncoder;
  const seedBytes = seeds.reduce((acc, seed, ii) => {
    const bytes = typeof seed === "string" ? (textEncoder ||= new TextEncoder).encode(seed) : seed;
    if (bytes.byteLength > MAX_SEED_LENGTH) {
      throw new SolanaError(SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED, {
        actual: bytes.byteLength,
        index: ii,
        maxSeedLength: MAX_SEED_LENGTH
      });
    }
    acc.push(...bytes);
    return acc;
  }, []);
  const base58EncodedAddressCodec = getAddressCodec();
  const programAddressBytes = base58EncodedAddressCodec.encode(programAddress);
  const addressBytesBuffer = await crypto.subtle.digest("SHA-256", new Uint8Array([...seedBytes, ...programAddressBytes, ...PDA_MARKER_BYTES]));
  const addressBytes = new Uint8Array(addressBytesBuffer);
  if (compressedPointBytesAreOnCurve(addressBytes)) {
    throw new SolanaError(SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE);
  }
  return base58EncodedAddressCodec.decode(addressBytes);
}
async function getProgramDerivedAddress({
  programAddress,
  seeds
}) {
  let bumpSeed = 255;
  while (bumpSeed > 0) {
    try {
      const address2 = await createProgramDerivedAddress({
        programAddress,
        seeds: [...seeds, new Uint8Array([bumpSeed])]
      });
      return [address2, bumpSeed];
    } catch (e2) {
      if (isSolanaError(e2, SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE)) {
        bumpSeed--;
      } else {
        throw e2;
      }
    }
  }
  throw new SolanaError(SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED);
}
async function createAddressWithSeed({ baseAddress, programAddress, seed }) {
  const { encode, decode } = getAddressCodec();
  const seedBytes = typeof seed === "string" ? new TextEncoder().encode(seed) : seed;
  if (seedBytes.byteLength > MAX_SEED_LENGTH) {
    throw new SolanaError(SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED, {
      actual: seedBytes.byteLength,
      index: 0,
      maxSeedLength: MAX_SEED_LENGTH
    });
  }
  const programAddressBytes = encode(programAddress);
  if (programAddressBytes.length >= PDA_MARKER_BYTES.length && bytesEqual(programAddressBytes.slice(-PDA_MARKER_BYTES.length), new Uint8Array(PDA_MARKER_BYTES))) {
    throw new SolanaError(SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER);
  }
  const addressBytesBuffer = await crypto.subtle.digest("SHA-256", new Uint8Array([...encode(baseAddress), ...seedBytes, ...programAddressBytes]));
  const addressBytes = new Uint8Array(addressBytesBuffer);
  return decode(addressBytes);
}
async function getAddressFromPublicKey(publicKey) {
  assertKeyExporterIsAvailable();
  if (publicKey.type !== "public" || publicKey.algorithm.name !== "Ed25519") {
    throw new SolanaError(SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY);
  }
  const publicKeyBytes = await crypto.subtle.exportKey("raw", publicKey);
  return getAddressDecoder().decode(new Uint8Array(publicKeyBytes));
}
async function getPublicKeyFromAddress(address2) {
  const addressBytes = getAddressEncoder().encode(address2);
  return await crypto.subtle.importKey("raw", addressBytes, { name: "Ed25519" }, true, ["verify"]);
}
var memoizedBase58Encoder, memoizedBase58Decoder, D = 37095705934669439343138083508754565189542113879843219016388785533085940283555n, P = 57896044618658097711785492504343953926634992332820282019728792003956564819949n, RM1 = 19681161376707505956807079304988542015446066515923890162744021073123829784752n, MAX_SEED_LENGTH = 32, MAX_SEEDS = 16, PDA_MARKER_BYTES;
var init_index_node5 = __esm(() => {
  init_index_node2();
  init_index_node3();
  init_index_node();
  init_index_node4();
  PDA_MARKER_BYTES = [
    80,
    114,
    111,
    103,
    114,
    97,
    109,
    68,
    101,
    114,
    105,
    118,
    101,
    100,
    65,
    100,
    100,
    114,
    101,
    115,
    115
  ];
});

// ../packages/sdk-typescript/dist/chunk-TTB4OS2D.js
var ReputationSource, BaseReputationAdapter = class {
  config;
  constructor(config) {
    this.config = config;
  }
  calculateReliability(_data) {
    return this.config.reliability / 1e4;
  }
  isEnabled() {
    return this.config.enabled;
  }
  getWeight() {
    return this.config.weight;
  }
  validateScoreRange(score) {
    return score >= 0 && score <= 1000;
  }
  clampScore(score) {
    return Math.max(0, Math.min(1000, score));
  }
}, GHOSTSPEAK_PROGRAM_ID;
var init_chunk_TTB4OS2D = __esm(() => {
  init_index_node5();
  ReputationSource = /* @__PURE__ */ ((ReputationSource2) => {
    ReputationSource2["PayAI"] = "payai";
    ReputationSource2["DirectSolana"] = "direct-solana";
    ReputationSource2["GitHub"] = "github";
    ReputationSource2["Twitter"] = "twitter";
    ReputationSource2["CustomWebhook"] = "custom-webhook";
    ReputationSource2["OnChainHistory"] = "onchain-history";
    return ReputationSource2;
  })(ReputationSource || {});
  GHOSTSPEAK_PROGRAM_ID = address("4wHjA2a5YC4twZb4NQpwZpixo5FgxxzuJUrCG7UnF9pB");
  address("DFQ9ejBt1T192Xnru1J21bFq9FSU7gjRRRYJkehvpump");
});

// ../packages/sdk-typescript/dist/chunk-UP2VWCW5.js
var __defProp2, __getOwnPropDesc, __getOwnPropNames2, __hasOwnProp2, __require2, __esm2 = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames2(fn)[0]])(fn = 0)), res;
}, __commonJS2 = (cb, mod2) => function __require2() {
  return mod2 || (0, cb[__getOwnPropNames2(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
}, __export2 = (target, all) => {
  for (var name in all)
    __defProp2(target, name, { get: all[name], enumerable: true });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames2(from))
      if (!__hasOwnProp2.call(to, key) && key !== except)
        __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
}, __toCommonJS = (mod2) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod2);
var init_chunk_UP2VWCW5 = __esm(() => {
  __defProp2 = Object.defineProperty;
  __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  __getOwnPropNames2 = Object.getOwnPropertyNames;
  __hasOwnProp2 = Object.prototype.hasOwnProperty;
  __require2 = /* @__PURE__ */ ((x) => __require)(function(x) {
    if (true)
      return __require.apply(this, arguments);
    throw Error('Dynamic require of "' + x + '" is not supported');
  });
});

// ../node_modules/.bun/@solana+accounts@5.1.0+7f9e3d21594a24ff/node_modules/@solana/accounts/dist/index.node.mjs
function decodeAccount(encodedAccount, decoder) {
  try {
    if ("exists" in encodedAccount && !encodedAccount.exists) {
      return encodedAccount;
    }
    return Object.freeze({ ...encodedAccount, data: decoder.decode(encodedAccount.data) });
  } catch {
    throw new SolanaError(SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT, {
      address: encodedAccount.address
    });
  }
}
function accountExists(account) {
  return !("exists" in account) || "exists" in account && account.exists;
}
function assertAccountDecoded(account) {
  if (accountExists(account) && account.data instanceof Uint8Array) {
    throw new SolanaError(SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT, {
      address: account.address
    });
  }
}
function assertAccountsDecoded(accounts) {
  const encoded = accounts.filter((a) => accountExists(a) && a.data instanceof Uint8Array);
  if (encoded.length > 0) {
    const encodedAddresses = encoded.map((a) => a.address);
    throw new SolanaError(SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED, {
      addresses: encodedAddresses
    });
  }
}
function parseBase64RpcAccount(address2, rpcAccount) {
  if (!rpcAccount)
    return Object.freeze({ address: address2, exists: false });
  const data2 = getBase64Encoder().encode(rpcAccount.data[0]);
  return Object.freeze({ ...parseBaseAccount(rpcAccount), address: address2, data: data2, exists: true });
}
function parseBase58RpcAccount(address2, rpcAccount) {
  if (!rpcAccount)
    return Object.freeze({ address: address2, exists: false });
  const data2 = getBase58Encoder().encode(typeof rpcAccount.data === "string" ? rpcAccount.data : rpcAccount.data[0]);
  return Object.freeze({ ...parseBaseAccount(rpcAccount), address: address2, data: data2, exists: true });
}
function parseJsonRpcAccount(address2, rpcAccount) {
  if (!rpcAccount)
    return Object.freeze({ address: address2, exists: false });
  const data2 = rpcAccount.data.parsed.info;
  return Object.freeze({ ...parseBaseAccount(rpcAccount), address: address2, data: data2, exists: true });
}
function parseBaseAccount(rpcAccount) {
  return Object.freeze({
    executable: rpcAccount.executable,
    lamports: rpcAccount.lamports,
    programAddress: rpcAccount.owner,
    space: rpcAccount.space
  });
}
async function fetchEncodedAccount(rpc, address2, config = {}) {
  const { abortSignal, ...rpcConfig } = config;
  const response = await rpc.getAccountInfo(address2, { ...rpcConfig, encoding: "base64" }).send({ abortSignal });
  return parseBase64RpcAccount(address2, response.value);
}
async function fetchJsonParsedAccount(rpc, address2, config = {}) {
  const { abortSignal, ...rpcConfig } = config;
  const { value: account } = await rpc.getAccountInfo(address2, { ...rpcConfig, encoding: "jsonParsed" }).send({ abortSignal });
  return !!account && typeof account === "object" && "parsed" in account.data ? parseJsonRpcAccount(address2, account) : parseBase64RpcAccount(address2, account);
}
async function fetchEncodedAccounts(rpc, addresses, config = {}) {
  const { abortSignal, ...rpcConfig } = config;
  const response = await rpc.getMultipleAccounts(addresses, { ...rpcConfig, encoding: "base64" }).send({ abortSignal });
  return response.value.map((account, index) => parseBase64RpcAccount(addresses[index], account));
}
async function fetchJsonParsedAccounts(rpc, addresses, config = {}) {
  const { abortSignal, ...rpcConfig } = config;
  const response = await rpc.getMultipleAccounts(addresses, { ...rpcConfig, encoding: "jsonParsed" }).send({ abortSignal });
  return response.value.map((account, index) => {
    return !!account && typeof account === "object" && "parsed" in account.data ? parseJsonRpcAccount(addresses[index], account) : parseBase64RpcAccount(addresses[index], account);
  });
}
function assertAccountExists(account) {
  if (!account.exists) {
    throw new SolanaError(SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND, { address: account.address });
  }
}
function assertAccountsExist(accounts) {
  const missingAccounts = accounts.filter((a) => !a.exists);
  if (missingAccounts.length > 0) {
    const missingAddresses = missingAccounts.map((a) => a.address);
    throw new SolanaError(SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND, { addresses: missingAddresses });
  }
}
var BASE_ACCOUNT_SIZE = 128;
var init_index_node6 = __esm(() => {
  init_index_node();
  init_index_node3();
});

// ../node_modules/.bun/@solana+codecs-numbers@5.1.0+1fb4c65d43e298b9/node_modules/@solana/codecs-numbers/dist/index.node.mjs
function assertNumberIsBetweenForCodec(codecDescription, min, max, value) {
  if (value < min || value > max) {
    throw new SolanaError(SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE, {
      codecDescription,
      max,
      min,
      value
    });
  }
}
function isLittleEndian(config) {
  return config?.endian === 1 ? false : true;
}
function numberEncoderFactory(input) {
  return createEncoder({
    fixedSize: input.size,
    write(value, bytes, offset) {
      if (input.range) {
        assertNumberIsBetweenForCodec(input.name, input.range[0], input.range[1], value);
      }
      const arrayBuffer = new ArrayBuffer(input.size);
      input.set(new DataView(arrayBuffer), value, isLittleEndian(input.config));
      bytes.set(new Uint8Array(arrayBuffer), offset);
      return offset + input.size;
    }
  });
}
function numberDecoderFactory(input) {
  return createDecoder({
    fixedSize: input.size,
    read(bytes, offset = 0) {
      assertByteArrayIsNotEmptyForCodec(input.name, bytes, offset);
      assertByteArrayHasEnoughBytesForCodec(input.name, input.size, bytes, offset);
      const view = new DataView(toArrayBuffer(bytes, offset, input.size));
      return [input.get(view, isLittleEndian(input.config)), offset + input.size];
    }
  });
}
function toArrayBuffer(bytes, offset, length) {
  const bytesOffset = bytes.byteOffset + (offset ?? 0);
  const bytesLength = length ?? bytes.byteLength;
  return bytes.buffer.slice(bytesOffset, bytesOffset + bytesLength);
}
var Endian, getF32Encoder = (config = {}) => numberEncoderFactory({
  config,
  name: "f32",
  set: (view, value, le) => view.setFloat32(0, Number(value), le),
  size: 4
}), getF32Decoder = (config = {}) => numberDecoderFactory({
  config,
  get: (view, le) => view.getFloat32(0, le),
  name: "f32",
  size: 4
}), getF32Codec = (config = {}) => combineCodec(getF32Encoder(config), getF32Decoder(config)), getF64Encoder = (config = {}) => numberEncoderFactory({
  config,
  name: "f64",
  set: (view, value, le) => view.setFloat64(0, Number(value), le),
  size: 8
}), getF64Decoder = (config = {}) => numberDecoderFactory({
  config,
  get: (view, le) => view.getFloat64(0, le),
  name: "f64",
  size: 8
}), getF64Codec = (config = {}) => combineCodec(getF64Encoder(config), getF64Decoder(config)), getI128Encoder = (config = {}) => numberEncoderFactory({
  config,
  name: "i128",
  range: [-BigInt("0x7fffffffffffffffffffffffffffffff") - 1n, BigInt("0x7fffffffffffffffffffffffffffffff")],
  set: (view, value, le) => {
    const leftOffset = le ? 8 : 0;
    const rightOffset = le ? 0 : 8;
    const rightMask = 0xffffffffffffffffn;
    view.setBigInt64(leftOffset, BigInt(value) >> 64n, le);
    view.setBigUint64(rightOffset, BigInt(value) & rightMask, le);
  },
  size: 16
}), getI128Decoder = (config = {}) => numberDecoderFactory({
  config,
  get: (view, le) => {
    const leftOffset = le ? 8 : 0;
    const rightOffset = le ? 0 : 8;
    const left = view.getBigInt64(leftOffset, le);
    const right = view.getBigUint64(rightOffset, le);
    return (left << 64n) + right;
  },
  name: "i128",
  size: 16
}), getI128Codec = (config = {}) => combineCodec(getI128Encoder(config), getI128Decoder(config)), getI16Encoder = (config = {}) => numberEncoderFactory({
  config,
  name: "i16",
  range: [-Number("0x7fff") - 1, Number("0x7fff")],
  set: (view, value, le) => view.setInt16(0, Number(value), le),
  size: 2
}), getI16Decoder = (config = {}) => numberDecoderFactory({
  config,
  get: (view, le) => view.getInt16(0, le),
  name: "i16",
  size: 2
}), getI16Codec = (config = {}) => combineCodec(getI16Encoder(config), getI16Decoder(config)), getI32Encoder = (config = {}) => numberEncoderFactory({
  config,
  name: "i32",
  range: [-Number("0x7fffffff") - 1, Number("0x7fffffff")],
  set: (view, value, le) => view.setInt32(0, Number(value), le),
  size: 4
}), getI32Decoder = (config = {}) => numberDecoderFactory({
  config,
  get: (view, le) => view.getInt32(0, le),
  name: "i32",
  size: 4
}), getI32Codec = (config = {}) => combineCodec(getI32Encoder(config), getI32Decoder(config)), getI64Encoder = (config = {}) => numberEncoderFactory({
  config,
  name: "i64",
  range: [-BigInt("0x7fffffffffffffff") - 1n, BigInt("0x7fffffffffffffff")],
  set: (view, value, le) => view.setBigInt64(0, BigInt(value), le),
  size: 8
}), getI64Decoder = (config = {}) => numberDecoderFactory({
  config,
  get: (view, le) => view.getBigInt64(0, le),
  name: "i64",
  size: 8
}), getI64Codec = (config = {}) => combineCodec(getI64Encoder(config), getI64Decoder(config)), getI8Encoder = () => numberEncoderFactory({
  name: "i8",
  range: [-Number("0x7f") - 1, Number("0x7f")],
  set: (view, value) => view.setInt8(0, Number(value)),
  size: 1
}), getI8Decoder = () => numberDecoderFactory({
  get: (view) => view.getInt8(0),
  name: "i8",
  size: 1
}), getI8Codec = () => combineCodec(getI8Encoder(), getI8Decoder()), getShortU16Encoder = () => createEncoder({
  getSizeFromValue: (value) => {
    if (value <= 127)
      return 1;
    if (value <= 16383)
      return 2;
    return 3;
  },
  maxSize: 3,
  write: (value, bytes, offset) => {
    assertNumberIsBetweenForCodec("shortU16", 0, 65535, value);
    const shortU16Bytes = [0];
    for (let ii = 0;; ii += 1) {
      const alignedValue = Number(value) >> ii * 7;
      if (alignedValue === 0) {
        break;
      }
      const nextSevenBits = 127 & alignedValue;
      shortU16Bytes[ii] = nextSevenBits;
      if (ii > 0) {
        shortU16Bytes[ii - 1] |= 128;
      }
    }
    bytes.set(shortU16Bytes, offset);
    return offset + shortU16Bytes.length;
  }
}), getShortU16Decoder = () => createDecoder({
  maxSize: 3,
  read: (bytes, offset) => {
    let value = 0;
    let byteCount = 0;
    while (++byteCount) {
      const byteIndex = byteCount - 1;
      const currentByte = bytes[offset + byteIndex];
      const nextSevenBits = 127 & currentByte;
      value |= nextSevenBits << byteIndex * 7;
      if ((currentByte & 128) === 0) {
        break;
      }
    }
    return [value, offset + byteCount];
  }
}), getShortU16Codec = () => combineCodec(getShortU16Encoder(), getShortU16Decoder()), getU128Encoder = (config = {}) => numberEncoderFactory({
  config,
  name: "u128",
  range: [0n, BigInt("0xffffffffffffffffffffffffffffffff")],
  set: (view, value, le) => {
    const leftOffset = le ? 8 : 0;
    const rightOffset = le ? 0 : 8;
    const rightMask = 0xffffffffffffffffn;
    view.setBigUint64(leftOffset, BigInt(value) >> 64n, le);
    view.setBigUint64(rightOffset, BigInt(value) & rightMask, le);
  },
  size: 16
}), getU128Decoder = (config = {}) => numberDecoderFactory({
  config,
  get: (view, le) => {
    const leftOffset = le ? 8 : 0;
    const rightOffset = le ? 0 : 8;
    const left = view.getBigUint64(leftOffset, le);
    const right = view.getBigUint64(rightOffset, le);
    return (left << 64n) + right;
  },
  name: "u128",
  size: 16
}), getU128Codec = (config = {}) => combineCodec(getU128Encoder(config), getU128Decoder(config)), getU16Encoder = (config = {}) => numberEncoderFactory({
  config,
  name: "u16",
  range: [0, Number("0xffff")],
  set: (view, value, le) => view.setUint16(0, Number(value), le),
  size: 2
}), getU16Decoder = (config = {}) => numberDecoderFactory({
  config,
  get: (view, le) => view.getUint16(0, le),
  name: "u16",
  size: 2
}), getU16Codec = (config = {}) => combineCodec(getU16Encoder(config), getU16Decoder(config)), getU32Encoder = (config = {}) => numberEncoderFactory({
  config,
  name: "u32",
  range: [0, Number("0xffffffff")],
  set: (view, value, le) => view.setUint32(0, Number(value), le),
  size: 4
}), getU32Decoder = (config = {}) => numberDecoderFactory({
  config,
  get: (view, le) => view.getUint32(0, le),
  name: "u32",
  size: 4
}), getU32Codec = (config = {}) => combineCodec(getU32Encoder(config), getU32Decoder(config)), getU64Encoder = (config = {}) => numberEncoderFactory({
  config,
  name: "u64",
  range: [0n, BigInt("0xffffffffffffffff")],
  set: (view, value, le) => view.setBigUint64(0, BigInt(value), le),
  size: 8
}), getU64Decoder = (config = {}) => numberDecoderFactory({
  config,
  get: (view, le) => view.getBigUint64(0, le),
  name: "u64",
  size: 8
}), getU64Codec = (config = {}) => combineCodec(getU64Encoder(config), getU64Decoder(config)), getU8Encoder = () => numberEncoderFactory({
  name: "u8",
  range: [0, Number("0xff")],
  set: (view, value) => view.setUint8(0, Number(value)),
  size: 1
}), getU8Decoder = () => numberDecoderFactory({
  get: (view) => view.getUint8(0),
  name: "u8",
  size: 1
}), getU8Codec = () => combineCodec(getU8Encoder(), getU8Decoder());
var init_index_node7 = __esm(() => {
  init_index_node();
  init_index_node2();
  Endian = /* @__PURE__ */ ((Endian2) => {
    Endian2[Endian2["Little"] = 0] = "Little";
    Endian2[Endian2["Big"] = 1] = "Big";
    return Endian2;
  })(Endian || {});
});

// ../node_modules/.bun/@solana+codecs-data-structures@5.1.0+1fb4c65d43e298b9/node_modules/@solana/codecs-data-structures/dist/index.node.mjs
function assertValidNumberOfItemsForCodec(codecDescription, expected, actual) {
  if (expected !== actual) {
    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS, {
      actual,
      codecDescription,
      expected
    });
  }
}
function maxCodecSizes(sizes) {
  return sizes.reduce((all, size) => all === null || size === null ? null : Math.max(all, size), 0);
}
function sumCodecSizes(sizes) {
  return sizes.reduce((all, size) => all === null || size === null ? null : all + size, 0);
}
function getFixedSize(codec) {
  return isFixedSize(codec) ? codec.fixedSize : null;
}
function getMaxSize(codec) {
  return isFixedSize(codec) ? codec.fixedSize : codec.maxSize ?? null;
}
function getArrayEncoder(item, config = {}) {
  const size = config.size ?? getU32Encoder();
  const fixedSize = computeArrayLikeCodecSize(size, getFixedSize(item));
  const maxSize = computeArrayLikeCodecSize(size, getMaxSize(item)) ?? undefined;
  return createEncoder({
    ...fixedSize !== null ? { fixedSize } : {
      getSizeFromValue: (array) => {
        const prefixSize = typeof size === "object" ? getEncodedSize(array.length, size) : 0;
        return prefixSize + [...array].reduce((all, value) => all + getEncodedSize(value, item), 0);
      },
      maxSize
    },
    write: (array, bytes, offset) => {
      if (typeof size === "number") {
        assertValidNumberOfItemsForCodec("array", size, array.length);
      }
      if (typeof size === "object") {
        offset = size.write(array.length, bytes, offset);
      }
      array.forEach((value) => {
        offset = item.write(value, bytes, offset);
      });
      return offset;
    }
  });
}
function getArrayDecoder(item, config = {}) {
  const size = config.size ?? getU32Decoder();
  const itemSize = getFixedSize(item);
  const fixedSize = computeArrayLikeCodecSize(size, itemSize);
  const maxSize = computeArrayLikeCodecSize(size, getMaxSize(item)) ?? undefined;
  return createDecoder({
    ...fixedSize !== null ? { fixedSize } : { maxSize },
    read: (bytes, offset) => {
      const array = [];
      if (typeof size === "object" && bytes.slice(offset).length === 0) {
        return [array, offset];
      }
      if (size === "remainder") {
        while (offset < bytes.length) {
          const [value, newOffset2] = item.read(bytes, offset);
          offset = newOffset2;
          array.push(value);
        }
        return [array, offset];
      }
      const [resolvedSize, newOffset] = typeof size === "number" ? [size, offset] : size.read(bytes, offset);
      offset = newOffset;
      for (let i = 0;i < resolvedSize; i += 1) {
        const [value, newOffset2] = item.read(bytes, offset);
        offset = newOffset2;
        array.push(value);
      }
      return [array, offset];
    }
  });
}
function getArrayCodec(item, config = {}) {
  return combineCodec(getArrayEncoder(item, config), getArrayDecoder(item, config));
}
function computeArrayLikeCodecSize(size, itemSize) {
  if (typeof size !== "number")
    return null;
  if (size === 0)
    return 0;
  return itemSize === null ? null : itemSize * size;
}
function getBitArrayEncoder(size, config = {}) {
  const parsedConfig = typeof config === "boolean" ? { backward: config } : config;
  const backward = parsedConfig.backward ?? false;
  return createEncoder({
    fixedSize: size,
    write(value, bytes, offset) {
      const bytesToAdd = [];
      for (let i = 0;i < size; i += 1) {
        let byte = 0;
        for (let j = 0;j < 8; j += 1) {
          const feature = Number(value[i * 8 + j] ?? 0);
          byte |= feature << (backward ? j : 7 - j);
        }
        if (backward) {
          bytesToAdd.unshift(byte);
        } else {
          bytesToAdd.push(byte);
        }
      }
      bytes.set(bytesToAdd, offset);
      return size;
    }
  });
}
function getBitArrayDecoder(size, config = {}) {
  const parsedConfig = typeof config === "boolean" ? { backward: config } : config;
  const backward = parsedConfig.backward ?? false;
  return createDecoder({
    fixedSize: size,
    read(bytes, offset) {
      assertByteArrayHasEnoughBytesForCodec("bitArray", size, bytes, offset);
      const booleans = [];
      let slice = bytes.slice(offset, offset + size);
      slice = backward ? slice.reverse() : slice;
      slice.forEach((byte) => {
        for (let i = 0;i < 8; i += 1) {
          if (backward) {
            booleans.push(Boolean(byte & 1));
            byte >>= 1;
          } else {
            booleans.push(Boolean(byte & 128));
            byte <<= 1;
          }
        }
      });
      return [booleans, offset + size];
    }
  });
}
function getBitArrayCodec(size, config = {}) {
  return combineCodec(getBitArrayEncoder(size, config), getBitArrayDecoder(size, config));
}
function getBooleanEncoder(config = {}) {
  return transformEncoder(config.size ?? getU8Encoder(), (value) => value ? 1 : 0);
}
function getBooleanDecoder(config = {}) {
  return transformDecoder(config.size ?? getU8Decoder(), (value) => Number(value) === 1);
}
function getBooleanCodec(config = {}) {
  return combineCodec(getBooleanEncoder(config), getBooleanDecoder(config));
}
function getBytesEncoder() {
  return createEncoder({
    getSizeFromValue: (value) => value.length,
    write: (value, bytes, offset) => {
      bytes.set(value, offset);
      return offset + value.length;
    }
  });
}
function getBytesDecoder() {
  return createDecoder({
    read: (bytes, offset) => {
      const slice = bytes.slice(offset);
      return [slice, offset + slice.length];
    }
  });
}
function getBytesCodec() {
  return combineCodec(getBytesEncoder(), getBytesDecoder());
}
function getConstantEncoder(constant) {
  return createEncoder({
    fixedSize: constant.length,
    write: (_, bytes, offset) => {
      bytes.set(constant, offset);
      return offset + constant.length;
    }
  });
}
function getConstantDecoder(constant) {
  return createDecoder({
    fixedSize: constant.length,
    read: (bytes, offset) => {
      const base16 = getBase16Decoder2();
      if (!containsBytes(bytes, constant, offset)) {
        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_CONSTANT, {
          constant,
          data: bytes,
          hexConstant: base16.decode(constant),
          hexData: base16.decode(bytes),
          offset
        });
      }
      return [undefined, offset + constant.length];
    }
  });
}
function getConstantCodec(constant) {
  return combineCodec(getConstantEncoder(constant), getConstantDecoder(constant));
}
function getTupleEncoder(items) {
  const fixedSize = sumCodecSizes(items.map(getFixedSize));
  const maxSize = sumCodecSizes(items.map(getMaxSize)) ?? undefined;
  return createEncoder({
    ...fixedSize === null ? {
      getSizeFromValue: (value) => items.map((item, index) => getEncodedSize(value[index], item)).reduce((all, one) => all + one, 0),
      maxSize
    } : { fixedSize },
    write: (value, bytes, offset) => {
      assertValidNumberOfItemsForCodec("tuple", items.length, value.length);
      items.forEach((item, index) => {
        offset = item.write(value[index], bytes, offset);
      });
      return offset;
    }
  });
}
function getTupleDecoder(items) {
  const fixedSize = sumCodecSizes(items.map(getFixedSize));
  const maxSize = sumCodecSizes(items.map(getMaxSize)) ?? undefined;
  return createDecoder({
    ...fixedSize === null ? { maxSize } : { fixedSize },
    read: (bytes, offset) => {
      const values = [];
      items.forEach((item) => {
        const [newValue, newOffset] = item.read(bytes, offset);
        values.push(newValue);
        offset = newOffset;
      });
      return [values, offset];
    }
  });
}
function getTupleCodec(items) {
  return combineCodec(getTupleEncoder(items), getTupleDecoder(items));
}
function getUnionEncoder(variants, getIndexFromValue) {
  const fixedSize = getUnionFixedSize(variants);
  const write = (variant, bytes, offset) => {
    const index = getIndexFromValue(variant);
    assertValidVariantIndex(variants, index);
    return variants[index].write(variant, bytes, offset);
  };
  if (fixedSize !== null) {
    return createEncoder({ fixedSize, write });
  }
  const maxSize = getUnionMaxSize(variants);
  return createEncoder({
    ...maxSize !== null ? { maxSize } : {},
    getSizeFromValue: (variant) => {
      const index = getIndexFromValue(variant);
      assertValidVariantIndex(variants, index);
      return getEncodedSize(variant, variants[index]);
    },
    write
  });
}
function getUnionDecoder(variants, getIndexFromBytes) {
  const fixedSize = getUnionFixedSize(variants);
  const read = (bytes, offset) => {
    const index = getIndexFromBytes(bytes, offset);
    assertValidVariantIndex(variants, index);
    return variants[index].read(bytes, offset);
  };
  if (fixedSize !== null) {
    return createDecoder({ fixedSize, read });
  }
  const maxSize = getUnionMaxSize(variants);
  return createDecoder({ ...maxSize !== null ? { maxSize } : {}, read });
}
function getUnionCodec(variants, getIndexFromValue, getIndexFromBytes) {
  return combineCodec(getUnionEncoder(variants, getIndexFromValue), getUnionDecoder(variants, getIndexFromBytes));
}
function assertValidVariantIndex(variants, index) {
  if (typeof variants[index] === "undefined") {
    throw new SolanaError(SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE, {
      maxRange: variants.length - 1,
      minRange: 0,
      variant: index
    });
  }
}
function getUnionFixedSize(variants) {
  if (variants.length === 0)
    return 0;
  if (!isFixedSize(variants[0]))
    return null;
  const variantSize = variants[0].fixedSize;
  const sameSizedVariants = variants.every((variant) => isFixedSize(variant) && variant.fixedSize === variantSize);
  return sameSizedVariants ? variantSize : null;
}
function getUnionMaxSize(variants) {
  return maxCodecSizes(variants.map((variant) => getMaxSize(variant)));
}
function getDiscriminatedUnionEncoder(variants, config = {}) {
  const discriminatorProperty = config.discriminator ?? "__kind";
  const prefix = config.size ?? getU8Encoder();
  return getUnionEncoder(variants.map(([, variant], index) => transformEncoder(getTupleEncoder([prefix, variant]), (value) => [index, value])), (value) => getVariantDiscriminator(variants, value[discriminatorProperty]));
}
function getDiscriminatedUnionDecoder(variants, config = {}) {
  const discriminatorProperty = config.discriminator ?? "__kind";
  const prefix = config.size ?? getU8Decoder();
  return getUnionDecoder(variants.map(([discriminator, variant]) => transformDecoder(getTupleDecoder([prefix, variant]), ([, value]) => ({
    [discriminatorProperty]: discriminator,
    ...value
  }))), (bytes, offset) => Number(prefix.read(bytes, offset)[0]));
}
function getDiscriminatedUnionCodec(variants, config = {}) {
  return combineCodec(getDiscriminatedUnionEncoder(variants, config), getDiscriminatedUnionDecoder(variants, config));
}
function getVariantDiscriminator(variants, discriminatorValue) {
  const discriminator = variants.findIndex(([key]) => discriminatorValue === key);
  if (discriminator < 0) {
    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT, {
      value: discriminatorValue,
      variants: variants.map(([key]) => key)
    });
  }
  return discriminator;
}
function getEnumStats(constructor) {
  const numericalValues = [...new Set(Object.values(constructor).filter((v) => typeof v === "number"))].sort();
  const enumRecord = Object.fromEntries(Object.entries(constructor).slice(numericalValues.length));
  const enumKeys = Object.keys(enumRecord);
  const enumValues = Object.values(enumRecord);
  const stringValues = [
    .../* @__PURE__ */ new Set([...enumKeys, ...enumValues.filter((v) => typeof v === "string")])
  ];
  return { enumKeys, enumRecord, enumValues, numericalValues, stringValues };
}
function getEnumIndexFromVariant({
  enumKeys,
  enumValues,
  variant
}) {
  const valueIndex = findLastIndex(enumValues, (value) => value === variant);
  if (valueIndex >= 0)
    return valueIndex;
  return enumKeys.findIndex((key) => key === variant);
}
function getEnumIndexFromDiscriminator({
  discriminator,
  enumKeys,
  enumValues,
  useValuesAsDiscriminators
}) {
  if (!useValuesAsDiscriminators) {
    return discriminator >= 0 && discriminator < enumKeys.length ? discriminator : -1;
  }
  return findLastIndex(enumValues, (value) => value === discriminator);
}
function findLastIndex(array, predicate) {
  let l = array.length;
  while (l--) {
    if (predicate(array[l], l, array))
      return l;
  }
  return -1;
}
function formatNumericalValues(values) {
  if (values.length === 0)
    return "";
  let range = [values[0], values[0]];
  const ranges = [];
  for (let index = 1;index < values.length; index++) {
    const value = values[index];
    if (range[1] + 1 === value) {
      range[1] = value;
    } else {
      ranges.push(range[0] === range[1] ? `${range[0]}` : `${range[0]}-${range[1]}`);
      range = [value, value];
    }
  }
  ranges.push(range[0] === range[1] ? `${range[0]}` : `${range[0]}-${range[1]}`);
  return ranges.join(", ");
}
function getEnumEncoder(constructor, config = {}) {
  const prefix = config.size ?? getU8Encoder();
  const useValuesAsDiscriminators = config.useValuesAsDiscriminators ?? false;
  const { enumKeys, enumValues, numericalValues, stringValues } = getEnumStats(constructor);
  if (useValuesAsDiscriminators && enumValues.some((value) => typeof value === "string")) {
    throw new SolanaError(SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS, {
      stringValues: enumValues.filter((v) => typeof v === "string")
    });
  }
  return transformEncoder(prefix, (variant) => {
    const index = getEnumIndexFromVariant({ enumKeys, enumValues, variant });
    if (index < 0) {
      throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT, {
        formattedNumericalValues: formatNumericalValues(numericalValues),
        numericalValues,
        stringValues,
        variant
      });
    }
    return useValuesAsDiscriminators ? enumValues[index] : index;
  });
}
function getEnumDecoder(constructor, config = {}) {
  const prefix = config.size ?? getU8Decoder();
  const useValuesAsDiscriminators = config.useValuesAsDiscriminators ?? false;
  const { enumKeys, enumValues, numericalValues } = getEnumStats(constructor);
  if (useValuesAsDiscriminators && enumValues.some((value) => typeof value === "string")) {
    throw new SolanaError(SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS, {
      stringValues: enumValues.filter((v) => typeof v === "string")
    });
  }
  return transformDecoder(prefix, (value) => {
    const discriminator = Number(value);
    const index = getEnumIndexFromDiscriminator({
      discriminator,
      enumKeys,
      enumValues,
      useValuesAsDiscriminators
    });
    if (index < 0) {
      const validDiscriminators = useValuesAsDiscriminators ? numericalValues : [...Array(enumKeys.length).keys()];
      throw new SolanaError(SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE, {
        discriminator,
        formattedValidDiscriminators: formatNumericalValues(validDiscriminators),
        validDiscriminators
      });
    }
    return enumValues[index];
  });
}
function getEnumCodec(constructor, config = {}) {
  return combineCodec(getEnumEncoder(constructor, config), getEnumDecoder(constructor, config));
}
function getHiddenPrefixEncoder(encoder2, prefixedEncoders) {
  return transformEncoder(getTupleEncoder([...prefixedEncoders, encoder2]), (value) => [...prefixedEncoders.map(() => {
    return;
  }), value]);
}
function getHiddenPrefixDecoder(decoder, prefixedDecoders) {
  return transformDecoder(getTupleDecoder([...prefixedDecoders, decoder]), (tuple) => tuple[tuple.length - 1]);
}
function getHiddenPrefixCodec(codec, prefixedCodecs) {
  return combineCodec(getHiddenPrefixEncoder(codec, prefixedCodecs), getHiddenPrefixDecoder(codec, prefixedCodecs));
}
function getHiddenSuffixEncoder(encoder2, suffixedEncoders) {
  return transformEncoder(getTupleEncoder([encoder2, ...suffixedEncoders]), (value) => [value, ...suffixedEncoders.map(() => {
    return;
  })]);
}
function getHiddenSuffixDecoder(decoder, suffixedDecoders) {
  return transformDecoder(getTupleDecoder([decoder, ...suffixedDecoders]), (tuple) => tuple[0]);
}
function getHiddenSuffixCodec(codec, suffixedCodecs) {
  return combineCodec(getHiddenSuffixEncoder(codec, suffixedCodecs), getHiddenSuffixDecoder(codec, suffixedCodecs));
}
function getLiteralUnionEncoder(variants, config = {}) {
  const discriminator = config.size ?? getU8Encoder();
  return transformEncoder(discriminator, (variant) => {
    const index = variants.indexOf(variant);
    if (index < 0) {
      throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT, {
        value: variant,
        variants
      });
    }
    return index;
  });
}
function getLiteralUnionDecoder(variants, config = {}) {
  const discriminator = config.size ?? getU8Decoder();
  return transformDecoder(discriminator, (index) => {
    if (index < 0 || index >= variants.length) {
      throw new SolanaError(SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE, {
        discriminator: index,
        maxRange: variants.length - 1,
        minRange: 0
      });
    }
    return variants[Number(index)];
  });
}
function getLiteralUnionCodec(variants, config = {}) {
  return combineCodec(getLiteralUnionEncoder(variants, config), getLiteralUnionDecoder(variants, config));
}
function getMapEncoder(key, value, config = {}) {
  return transformEncoder(getArrayEncoder(getTupleEncoder([key, value]), config), (map) => [...map.entries()]);
}
function getMapDecoder(key, value, config = {}) {
  return transformDecoder(getArrayDecoder(getTupleDecoder([key, value]), config), (entries) => new Map(entries));
}
function getMapCodec(key, value, config = {}) {
  return combineCodec(getMapEncoder(key, value, config), getMapDecoder(key, value, config));
}
function getUnitEncoder() {
  return createEncoder({
    fixedSize: 0,
    write: (_value, _bytes, offset) => offset
  });
}
function getUnitDecoder() {
  return createDecoder({
    fixedSize: 0,
    read: (_bytes, offset) => [undefined, offset]
  });
}
function getUnitCodec() {
  return combineCodec(getUnitEncoder(), getUnitDecoder());
}
function getNullableEncoder(item, config = {}) {
  const prefix = (() => {
    if (config.prefix === null) {
      return transformEncoder(getUnitEncoder(), (_boolean) => {
        return;
      });
    }
    return getBooleanEncoder({ size: config.prefix ?? getU8Encoder() });
  })();
  const noneValue = (() => {
    if (config.noneValue === "zeroes") {
      assertIsFixedSize(item);
      return fixEncoderSize(getUnitEncoder(), item.fixedSize);
    }
    if (!config.noneValue) {
      return getUnitEncoder();
    }
    return getConstantEncoder(config.noneValue);
  })();
  return getUnionEncoder([
    transformEncoder(getTupleEncoder([prefix, noneValue]), (_value) => [
      false,
      undefined
    ]),
    transformEncoder(getTupleEncoder([prefix, item]), (value) => [true, value])
  ], (variant) => Number(variant !== null));
}
function getNullableDecoder(item, config = {}) {
  const prefix = (() => {
    if (config.prefix === null) {
      return transformDecoder(getUnitDecoder(), () => false);
    }
    return getBooleanDecoder({ size: config.prefix ?? getU8Decoder() });
  })();
  const noneValue = (() => {
    if (config.noneValue === "zeroes") {
      assertIsFixedSize(item);
      return fixDecoderSize(getUnitDecoder(), item.fixedSize);
    }
    if (!config.noneValue) {
      return getUnitDecoder();
    }
    return getConstantDecoder(config.noneValue);
  })();
  return getUnionDecoder([
    transformDecoder(getTupleDecoder([prefix, noneValue]), () => null),
    transformDecoder(getTupleDecoder([prefix, item]), ([, value]) => value)
  ], (bytes, offset) => {
    if (config.prefix === null && !config.noneValue) {
      return Number(offset < bytes.length);
    }
    if (config.prefix === null && config.noneValue != null) {
      const zeroValue = config.noneValue === "zeroes" ? new Uint8Array(noneValue.fixedSize).fill(0) : config.noneValue;
      return containsBytes(bytes, zeroValue, offset) ? 0 : 1;
    }
    return Number(prefix.read(bytes, offset)[0]);
  });
}
function getNullableCodec(item, config = {}) {
  return combineCodec(getNullableEncoder(item, config), getNullableDecoder(item, config));
}
function getSetEncoder(item, config = {}) {
  return transformEncoder(getArrayEncoder(item, config), (set) => [...set]);
}
function getSetDecoder(item, config = {}) {
  return transformDecoder(getArrayDecoder(item, config), (entries) => new Set(entries));
}
function getSetCodec(item, config = {}) {
  return combineCodec(getSetEncoder(item, config), getSetDecoder(item, config));
}
function getStructEncoder(fields) {
  const fieldCodecs = fields.map(([, codec]) => codec);
  const fixedSize = sumCodecSizes(fieldCodecs.map(getFixedSize));
  const maxSize = sumCodecSizes(fieldCodecs.map(getMaxSize)) ?? undefined;
  return createEncoder({
    ...fixedSize === null ? {
      getSizeFromValue: (value) => fields.map(([key, codec]) => getEncodedSize(value[key], codec)).reduce((all, one) => all + one, 0),
      maxSize
    } : { fixedSize },
    write: (struct, bytes, offset) => {
      fields.forEach(([key, codec]) => {
        offset = codec.write(struct[key], bytes, offset);
      });
      return offset;
    }
  });
}
function getStructDecoder(fields) {
  const fieldCodecs = fields.map(([, codec]) => codec);
  const fixedSize = sumCodecSizes(fieldCodecs.map(getFixedSize));
  const maxSize = sumCodecSizes(fieldCodecs.map(getMaxSize)) ?? undefined;
  return createDecoder({
    ...fixedSize === null ? { maxSize } : { fixedSize },
    read: (bytes, offset) => {
      const struct = {};
      fields.forEach(([key, codec]) => {
        const [value, newOffset] = codec.read(bytes, offset);
        offset = newOffset;
        struct[key] = value;
      });
      return [struct, offset];
    }
  });
}
function getStructCodec(fields) {
  return combineCodec(getStructEncoder(fields), getStructDecoder(fields));
}
var getBase16Decoder2 = () => createDecoder({
  read(bytes, offset) {
    const value = bytes.slice(offset).reduce((str, byte) => str + byte.toString(16).padStart(2, "0"), "");
    return [value, bytes.length];
  }
});
var init_index_node8 = __esm(() => {
  init_index_node2();
  init_index_node7();
  init_index_node();
});

// ../node_modules/.bun/@solana+options@5.1.0+7f9e3d21594a24ff/node_modules/@solana/options/dist/index.node.mjs
function unwrapOption(option, fallback) {
  if (isSome(option))
    return option.value;
  return fallback ? fallback() : null;
}
function getOptionEncoder(item, config = {}) {
  const prefix = (() => {
    if (config.prefix === null) {
      return transformEncoder(getUnitEncoder(), (_boolean) => {
        return;
      });
    }
    return getBooleanEncoder({ size: config.prefix ?? getU8Encoder() });
  })();
  const noneValue = (() => {
    if (config.noneValue === "zeroes") {
      assertIsFixedSize(item);
      return fixEncoderSize(getUnitEncoder(), item.fixedSize);
    }
    if (!config.noneValue) {
      return getUnitEncoder();
    }
    return getConstantEncoder(config.noneValue);
  })();
  return getUnionEncoder([
    transformEncoder(getTupleEncoder([prefix, noneValue]), (_value) => [
      false,
      undefined
    ]),
    transformEncoder(getTupleEncoder([prefix, item]), (value) => [
      true,
      isOption(value) && isSome(value) ? value.value : value
    ])
  ], (variant) => {
    const option = isOption(variant) ? variant : wrapNullable(variant);
    return Number(isSome(option));
  });
}
function getOptionDecoder(item, config = {}) {
  const prefix = (() => {
    if (config.prefix === null) {
      return transformDecoder(getUnitDecoder(), () => false);
    }
    return getBooleanDecoder({ size: config.prefix ?? getU8Decoder() });
  })();
  const noneValue = (() => {
    if (config.noneValue === "zeroes") {
      assertIsFixedSize(item);
      return fixDecoderSize(getUnitDecoder(), item.fixedSize);
    }
    if (!config.noneValue) {
      return getUnitDecoder();
    }
    return getConstantDecoder(config.noneValue);
  })();
  return getUnionDecoder([
    transformDecoder(getTupleDecoder([prefix, noneValue]), () => none()),
    transformDecoder(getTupleDecoder([prefix, item]), ([, value]) => some(value))
  ], (bytes, offset) => {
    if (config.prefix === null && !config.noneValue) {
      return Number(offset < bytes.length);
    }
    if (config.prefix === null && config.noneValue != null) {
      const zeroValue = config.noneValue === "zeroes" ? new Uint8Array(noneValue.fixedSize).fill(0) : config.noneValue;
      return containsBytes(bytes, zeroValue, offset) ? 0 : 1;
    }
    return Number(prefix.read(bytes, offset)[0]);
  });
}
function getOptionCodec(item, config = {}) {
  return combineCodec(getOptionEncoder(item, config), getOptionDecoder(item, config));
}
function unwrapOptionRecursively(input, fallback) {
  if (!input || ArrayBuffer.isView(input)) {
    return input;
  }
  const next = (x) => fallback ? unwrapOptionRecursively(x, fallback) : unwrapOptionRecursively(x);
  if (isOption(input)) {
    if (isSome(input))
      return next(input.value);
    return fallback ? fallback() : null;
  }
  if (Array.isArray(input)) {
    return input.map(next);
  }
  if (typeof input === "object") {
    return Object.fromEntries(Object.entries(input).map(([k, v]) => [k, next(v)]));
  }
  return input;
}
var some = (value) => ({ __option: "Some", value }), none = () => ({ __option: "None" }), isOption = (input) => !!(input && typeof input === "object" && ("__option" in input) && (input.__option === "Some" && ("value" in input) || input.__option === "None")), isSome = (option) => option.__option === "Some", isNone = (option) => option.__option === "None", wrapNullable = (nullable) => nullable !== null ? some(nullable) : none();
var init_index_node9 = __esm(() => {
  init_index_node2();
  init_index_node8();
  init_index_node7();
});

// ../node_modules/.bun/@solana+codecs@5.1.0+7f9e3d21594a24ff/node_modules/@solana/codecs/dist/index.node.mjs
var init_index_node10 = __esm(() => {
  init_index_node2();
  init_index_node8();
  init_index_node7();
  init_index_node3();
  init_index_node9();
});

// ../node_modules/.bun/@solana+rpc-types@5.1.0+7f9e3d21594a24ff/node_modules/@solana/rpc-types/dist/index.node.mjs
function isBlockhash(putativeBlockhash) {
  return isAddress(putativeBlockhash);
}
function assertIsBlockhash(putativeBlockhash) {
  try {
    assertIsAddress(putativeBlockhash);
  } catch (error) {
    if (isSolanaError(error, SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE)) {
      throw new SolanaError(SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE, error.context);
    }
    if (isSolanaError(error, SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH)) {
      throw new SolanaError(SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH, error.context);
    }
    throw error;
  }
}
function blockhash(putativeBlockhash) {
  assertIsBlockhash(putativeBlockhash);
  return putativeBlockhash;
}
function getBlockhashEncoder() {
  const addressEncoder = getAddressEncoder();
  return createEncoder({
    fixedSize: 32,
    write: (value, bytes, offset) => {
      assertIsBlockhash(value);
      return addressEncoder.write(value, bytes, offset);
    }
  });
}
function getBlockhashDecoder() {
  return getAddressDecoder();
}
function getBlockhashCodec() {
  return combineCodec(getBlockhashEncoder(), getBlockhashDecoder());
}
function getBlockhashComparator() {
  return new Intl.Collator("en", {
    caseFirst: "lower",
    ignorePunctuation: false,
    localeMatcher: "best fit",
    numeric: false,
    sensitivity: "variant",
    usage: "sort"
  }).compare;
}
function mainnet(putativeString) {
  return putativeString;
}
function devnet(putativeString) {
  return putativeString;
}
function testnet(putativeString) {
  return putativeString;
}
function getCommitmentScore(commitment) {
  switch (commitment) {
    case "finalized":
      return 2;
    case "confirmed":
      return 1;
    case "processed":
      return 0;
    default:
      throw new SolanaError(SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE, {
        unexpectedValue: commitment
      });
  }
}
function commitmentComparator(a, b) {
  if (a === b) {
    return 0;
  }
  return getCommitmentScore(a) < getCommitmentScore(b) ? -1 : 1;
}
function getMemoizedU64Encoder() {
  if (!memoizedU64Encoder)
    memoizedU64Encoder = getU64Encoder();
  return memoizedU64Encoder;
}
function getMemoizedU64Decoder() {
  if (!memoizedU64Decoder)
    memoizedU64Decoder = getU64Decoder();
  return memoizedU64Decoder;
}
function isLamports(putativeLamports) {
  return putativeLamports >= 0 && putativeLamports <= maxU64Value;
}
function assertIsLamports(putativeLamports) {
  if (putativeLamports < 0 || putativeLamports > maxU64Value) {
    throw new SolanaError(SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE);
  }
}
function lamports(putativeLamports) {
  assertIsLamports(putativeLamports);
  return putativeLamports;
}
function getDefaultLamportsEncoder() {
  return getLamportsEncoder(getMemoizedU64Encoder());
}
function getLamportsEncoder(innerEncoder) {
  return innerEncoder;
}
function getDefaultLamportsDecoder() {
  return getLamportsDecoder(getMemoizedU64Decoder());
}
function getLamportsDecoder(innerDecoder) {
  return transformDecoder(innerDecoder, (value) => lamports(typeof value === "bigint" ? value : BigInt(value)));
}
function getDefaultLamportsCodec() {
  return combineCodec(getDefaultLamportsEncoder(), getDefaultLamportsDecoder());
}
function getLamportsCodec(innerCodec) {
  return combineCodec(getLamportsEncoder(innerCodec), getLamportsDecoder(innerCodec));
}
function isStringifiedBigInt(putativeBigInt) {
  try {
    BigInt(putativeBigInt);
    return true;
  } catch {
    return false;
  }
}
function assertIsStringifiedBigInt(putativeBigInt) {
  try {
    BigInt(putativeBigInt);
  } catch {
    throw new SolanaError(SOLANA_ERROR__MALFORMED_BIGINT_STRING, {
      value: putativeBigInt
    });
  }
}
function stringifiedBigInt(putativeBigInt) {
  assertIsStringifiedBigInt(putativeBigInt);
  return putativeBigInt;
}
function isStringifiedNumber(putativeNumber) {
  return !Number.isNaN(Number(putativeNumber));
}
function assertIsStringifiedNumber(putativeNumber) {
  if (Number.isNaN(Number(putativeNumber))) {
    throw new SolanaError(SOLANA_ERROR__MALFORMED_NUMBER_STRING, {
      value: putativeNumber
    });
  }
}
function stringifiedNumber(putativeNumber) {
  assertIsStringifiedNumber(putativeNumber);
  return putativeNumber;
}
function isUnixTimestamp(putativeTimestamp) {
  return putativeTimestamp >= minI64Value && putativeTimestamp <= maxI64Value;
}
function assertIsUnixTimestamp(putativeTimestamp) {
  if (putativeTimestamp < minI64Value || putativeTimestamp > maxI64Value) {
    throw new SolanaError(SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE, {
      value: putativeTimestamp
    });
  }
}
function unixTimestamp(putativeTimestamp) {
  assertIsUnixTimestamp(putativeTimestamp);
  return putativeTimestamp;
}
var maxU64Value = 18446744073709551615n, memoizedU64Encoder, memoizedU64Decoder, maxI64Value = 9223372036854775807n, minI64Value;
var init_index_node11 = __esm(() => {
  init_index_node5();
  init_index_node2();
  init_index_node();
  init_index_node7();
  minI64Value = -9223372036854775808n;
});

// ../packages/sdk-typescript/dist/chunk-C5CDA3WX.js
function isIPFSUploadResponse(data2) {
  if (typeof data2 !== "object" || data2 === null)
    return false;
  const obj = data2;
  return typeof obj.IpfsHash === "string";
}
function isKnownInstruction(instructionName) {
  return instructionName in instructionAccountMappings;
}
function validateInstructionAccounts(instructionName, providedAccounts, accountNames) {
  const mapping = getInstructionMapping(instructionName);
  if (!mapping) {
    throw new InstructionValidationError(instructionName, 0, providedAccounts.length, `Unknown instruction: ${instructionName}. This instruction may not exist in the current IDL or may be misspelled.`);
  }
  if (providedAccounts.length !== mapping.expectedAccounts.length) {
    const errorMessage = generateAccountValidationError(instructionName, providedAccounts.length, accountNames);
    throw new InstructionValidationError(instructionName, mapping.expectedAccounts.length, providedAccounts.length, errorMessage, mapping.expectedAccounts);
  }
}
function createAccountMismatchError(instructionName, providedCount, providedAccountNames) {
  const mapping = getInstructionMapping(instructionName);
  if (!mapping) {
    return `Unknown instruction: ${instructionName}`;
  }
  if (providedCount === mapping.expectedAccounts.length) {
    return `Accounts are correctly provided for ${instructionName}`;
  }
  let error = ` Account validation failed for "${instructionName}"

`;
  error += `\uD83D\uDCCA Expected: ${mapping.expectedAccounts.length} accounts
`;
  error += `\uD83D\uDCCA Provided: ${providedCount} accounts

`;
  error += `\uD83D\uDCCB Required accounts:
`;
  mapping.expectedAccounts.forEach((account, index) => {
    const attributes = [];
    if (account.pda)
      attributes.push("PDA");
    const attrStr = attributes.length > 0 ? ` (${attributes.join(", ")})` : "";
    error += `  ${index + 1}. ${account.name}${attrStr}
`;
  });
  if (providedAccountNames && providedAccountNames.length > 0) {
    error += `
\uD83D\uDCCB Provided accounts:
`;
    providedAccountNames.forEach((name, index) => {
      error += `  ${index + 1}. ${name}
`;
    });
  }
  if (mapping.docs) {
    error += `
\uD83D\uDCD6 Description: ${mapping.docs}
`;
  }
  error += `
\uD83D\uDCA1 Tip: Make sure all required accounts are provided in the correct order.`;
  return error;
}
function getAccountRequirements(instructionName) {
  const mapping = getInstructionMapping(instructionName);
  if (!mapping) {
    return `Unknown instruction: ${instructionName}`;
  }
  let requirements = `${instructionName} requires ${mapping.expectedAccounts.length} accounts:

`;
  mapping.expectedAccounts.forEach((account, index) => {
    const attributes = [];
    if (account.pda)
      attributes.push("PDA-derived");
    const attrStr = attributes.length > 0 ? ` [${attributes.join(", ")}]` : "";
    requirements += `  ${index + 1}. ${account.name}${attrStr}
`;
  });
  if (mapping.docs) {
    requirements += `
Description: ${mapping.docs}
`;
  }
  return requirements;
}
function getInstructionMapping(instructionName) {
  return instructionAccountMappings[instructionName] ?? null;
}
function generateAccountValidationError(instructionName, providedCount, accountNames) {
  const mapping = getInstructionMapping(instructionName);
  if (!mapping) {
    return `Unknown instruction: ${instructionName}`;
  }
  let error = `Account mismatch for ${instructionName}: expected ${mapping.expectedAccounts.length} accounts, got ${providedCount}`;
  if (accountNames) {
    error += `. Provided: ${accountNames.join(", ")}`;
  }
  return error;
}
function enhanceErrorMessage(error, context) {
  return `${error.message}

Context: ${context}`;
}
function debugInstructionCall(instructionName, accounts) {
  return `Instruction: ${instructionName}
Accounts: ${accounts.length}
Mapping: ${JSON.stringify(getInstructionMapping(instructionName), null, 2)}`;
}
function getRequiredSigners(instructionName) {
  const mapping = getInstructionMapping(instructionName);
  if (!mapping)
    return [];
  return mapping.expectedAccounts.filter((account) => account.name.includes("authority") || account.name.includes("signer")).map((account) => account.name);
}
function getWritableAccounts(instructionName) {
  const mapping = getInstructionMapping(instructionName);
  if (!mapping)
    return [];
  return mapping.expectedAccounts.filter((account) => account.pda || account.name.includes("data") || account.name.includes("account")).map((account) => account.name);
}
function getPDAAccounts(instructionName) {
  const mapping = getInstructionMapping(instructionName);
  if (!mapping)
    return [];
  return mapping.expectedAccounts.filter((account) => account.pda).map((account) => account.name);
}
async function withEnhancedErrors(operation, instructionName, fn, debugAccounts) {
  try {
    if (debugAccounts && instructionName) {
      debugInstructionCall(instructionName, debugAccounts);
    }
    return await fn();
  } catch (error) {
    if (error instanceof Error) {
      throw new GhostSpeakSDKError(operation, error, instructionName);
    }
    throw error;
  }
}
function withEnhancedErrorsSync(operation, instructionName, fn, debugAccounts) {
  try {
    if (debugAccounts && instructionName) {
      debugInstructionCall(instructionName, debugAccounts);
    }
    return fn();
  } catch (error) {
    if (error instanceof Error) {
      throw new GhostSpeakSDKError(operation, error, instructionName);
    }
    throw error;
  }
}
function enhanceTransactionError(error, instructionName, accounts) {
  const message = error.message;
  if (message.includes("custom program error")) {
    const enhancedMessage = `${message}

Instruction: ${instructionName ?? "unknown"}`;
    if (accounts && instructionName) {
      const debugInfo = `
Accounts provided: ${accounts.length}`;
      return new Error(enhancedMessage + debugInfo);
    }
    return new Error(enhancedMessage);
  }
  if (message.includes("insufficient") || message.includes("account") || message.includes("signer") || message.includes("writable")) {
    return new Error(enhanceErrorMessage(error, instructionName ?? "unknown"));
  }
  return error;
}
function logEnhancedError(error, context) {
  console.error("\uD83D\uDEA8 GhostSpeak SDK Error:", error.message);
  if (context) {
    if (context.operation) {
      console.error("\uD83D\uDD27 Operation:", context.operation);
    }
    if (context.instructionName) {
      console.error("\uD83D\uDCCB Instruction:", context.instructionName);
    }
    if (context.accounts) {
      console.error("\uD83C\uDFE6 Accounts provided:", context.accounts.length);
      context.accounts.forEach((account, index) => {
        if (typeof account === "string") {
          console.error(`  ${index + 1}. ${account}`);
        } else if (typeof account === "object") {
          const addr = "address" in account ? account.address : account;
          const name = "name" in account ? account.name : undefined;
          console.error(`  ${index + 1}. ${addr}${name ? ` (${name})` : ""}`);
        } else {
          console.error(`  ${index + 1}. ${String(account)}`);
        }
      });
    }
    if (context.params) {
      console.error(" Parameters:", context.params);
    }
  }
  console.error(`
\uD83D\uDCA1 Troubleshooting tips:`);
  console.error("  1. Check that all required accounts are provided");
  console.error("  2. Verify account addresses are correct");
  console.error("  3. Ensure signers have sufficient SOL for transaction fees");
  console.error("  4. Confirm the program is deployed on the target network");
}
function createErrorContext(operation, instructionName, accounts, params) {
  return {
    operation,
    instructionName,
    accounts,
    params
  };
}
function validatePreconditions(checks) {
  for (const check of checks) {
    if (!check.condition) {
      const error = new Error(check.message);
      const enhanced = enhanceErrorMessage(error, check.instructionName ?? "unknown");
      throw new Error(enhanced);
    }
  }
}
function extractInstructionName(operation) {
  const operationToInstruction = {
    register_agent: "register_agent",
    registerAgent: "register_agent",
    activate_agent: "activate_agent",
    activateAgent: "activate_agent",
    update_agent: "update_agent",
    updateAgent: "update_agent",
    create_service_listing: "create_service_listing",
    createServiceListing: "create_service_listing",
    create_escrow: "create_escrow",
    createEscrow: "create_escrow",
    complete_escrow: "complete_escrow",
    completeEscrow: "complete_escrow",
    create_job_posting: "create_job_posting",
    createJobPosting: "create_job_posting",
    apply_to_job: "apply_to_job",
    applyToJob: "apply_to_job",
    submit_work_delivery: "submit_work_delivery",
    submitWorkDelivery: "submit_work_delivery",
    verify_work_delivery: "verify_work_delivery",
    verifyWorkDelivery: "verify_work_delivery",
    reject_work_delivery: "reject_work_delivery",
    rejectWorkDelivery: "reject_work_delivery",
    create_work_order: "create_work_order",
    createWorkOrder: "create_work_order",
    create_channel: "create_channel",
    createChannel: "create_channel",
    send_message: "send_message",
    sendMessage: "send_message",
    file_dispute: "file_dispute",
    fileDispute: "file_dispute",
    resolve_dispute: "resolve_dispute",
    resolveDispute: "resolve_dispute"
  };
  return operationToInstruction[operation];
}
var TagCategory, SkillTag, BehaviorTag, ComplianceTag, TAG_CONSTANTS, DEFAULT_TAG_DECAY, TagConfidenceLevel, init_reputation_tags, reputation_tag_engine_exports, ReputationTagEngine, init_reputation_tag_engine, PrivacyMode, VisibilityLevel, ScoreRange, PrivacyPresets, PRIVACY_CONSTANTS, instructionAccountMappings, InstructionValidationError, INSTRUCTION_MAPPINGS, GhostSpeakSDKError, ipfs_client_exports, sharedTestStorage, sharedUploadCount = 0, TestIPFSProvider = class {
  constructor(config) {
    this.config = config;
    console.log("\uD83E\uDDEA Initialized TestIPFSProvider for local testing (shared storage)");
  }
  storage = sharedTestStorage;
  uploadCount = 0;
  async upload(content, options2) {
    sharedUploadCount++;
    const contentStr = typeof content === "string" ? content : new TextDecoder().decode(content);
    const hash = `Qm${this.generateHash(contentStr)}_test_${sharedUploadCount}`;
    this.storage.set(hash, {
      content,
      pinned: options2?.pin !== false
    });
    const size = typeof content === "string" ? new TextEncoder().encode(content).length : content.length;
    console.log(`\uD83D\uDCE6 Test IPFS upload: ${hash} (${size} bytes)`);
    return {
      hash,
      uri: `ipfs://${hash}`,
      size,
      timestamp: Date.now(),
      pinned: options2?.pin !== false,
      gateways: [
        `http://localhost:8080/ipfs/${hash}`,
        `https://test.ipfs.io/ipfs/${hash}`
      ]
    };
  }
  async retrieve(hash) {
    const stored = this.storage.get(hash);
    if (!stored) {
      throw new Error(`Test IPFS: Content not found for hash ${hash}`);
    }
    console.log(`\uD83D\uDCE5 Test IPFS retrieve: ${hash}`);
    await new Promise((resolve) => setTimeout(resolve, 100));
    return stored.content;
  }
  async pin(hash) {
    const stored = this.storage.get(hash);
    if (!stored) {
      return {
        hash,
        success: false,
        status: "failed",
        error: `Content not found: ${hash}`
      };
    }
    stored.pinned = true;
    console.log(`\uD83D\uDCCC Test IPFS pin: ${hash}`);
    return {
      hash,
      success: true,
      status: "pinned"
    };
  }
  async unpin(hash) {
    const stored = this.storage.get(hash);
    if (!stored) {
      return {
        hash,
        success: false,
        status: "failed",
        error: `Content not found: ${hash}`
      };
    }
    stored.pinned = false;
    console.log(`\uD83D\uDCCC Test IPFS unpin: ${hash}`);
    return {
      hash,
      success: true,
      status: "pinned"
    };
  }
  generateHash(content) {
    let hash = 0;
    for (let i = 0;i < content.length; i++) {
      const char = content.charCodeAt(i);
      hash = (hash << 5) - hash + char;
      hash = hash & hash;
    }
    const chars = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    let result = "";
    let value = Math.abs(hash);
    while (value > 0 && result.length < 40) {
      result = chars[value % chars.length] + result;
      value = Math.floor(value / chars.length);
    }
    while (result.length < 40) {
      result = chars[Math.floor(Math.random() * chars.length)] + result;
    }
    return result;
  }
  getStats() {
    let totalSize = 0;
    let pinned = 0;
    for (const data2 of this.storage.values()) {
      const size = typeof data2.content === "string" ? new TextEncoder().encode(data2.content).length : data2.content.length;
      totalSize += size;
      if (data2.pinned)
        pinned++;
    }
    return {
      count: this.storage.size,
      totalSize,
      pinned
    };
  }
  clear() {
    this.storage.clear();
    sharedUploadCount = 0;
    console.log("\uD83E\uDDF9 Test IPFS storage cleared");
  }
  static getSharedStorage() {
    return sharedTestStorage;
  }
}, PinataProvider = class {
  constructor(config) {
    this.config = config;
  }
  async upload(content, options2) {
    const endpoint = this.config.endpoint ?? "https://api.pinata.cloud";
    const formData = new FormData;
    const blob = new Blob([content], {
      type: options2?.contentType ?? "application/octet-stream"
    });
    formData.append("file", blob, options2?.filename ?? "content");
    if (options2?.metadata) {
      formData.append("pinataMetadata", JSON.stringify({
        name: options2.filename ?? "ghostspeak-content",
        keyvalues: options2.metadata
      }));
    }
    const response = await fetch(`${endpoint}/pinning/pinFileToIPFS`, {
      method: "POST",
      headers: {
        Authorization: `Bearer ${this.config.jwt ?? this.config.apiKey}`,
        ...this.config.headers
      },
      body: formData
    });
    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Pinata upload failed: ${response.status} ${errorText}`);
    }
    const result = await response.json();
    const size = typeof content === "string" ? new TextEncoder().encode(content).length : content.length;
    if (!isIPFSUploadResponse(result)) {
      throw new Error("Invalid IPFS upload response format");
    }
    return {
      hash: result.IpfsHash,
      uri: `ipfs://${result.IpfsHash}`,
      size,
      timestamp: Date.now(),
      pinned: true,
      gateways: [
        `https://gateway.pinata.cloud/ipfs/${result.IpfsHash}`,
        `https://ipfs.io/ipfs/${result.IpfsHash}`
      ]
    };
  }
  async retrieve(hash, options2) {
    const gateway = options2?.gateway ?? "https://gateway.pinata.cloud";
    const url = `${gateway}/ipfs/${hash}`;
    const response = await fetch(url, {
      signal: options2?.timeout ? AbortSignal.timeout(options2.timeout) : undefined
    });
    if (!response.ok) {
      throw new Error(`Failed to retrieve from IPFS: ${response.status} ${response.statusText}`);
    }
    const contentType = response.headers.get("content-type");
    if (contentType?.startsWith("text/") || contentType?.includes("json")) {
      return response.text();
    } else {
      return new Uint8Array(await response.arrayBuffer());
    }
  }
  async pin(hash) {
    const endpoint = this.config.endpoint ?? "https://api.pinata.cloud";
    const response = await fetch(`${endpoint}/pinning/pinByHash`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${this.config.jwt ?? this.config.apiKey}`,
        ...this.config.headers
      },
      body: JSON.stringify({ hashToPin: hash })
    });
    const success = response.ok;
    return {
      hash,
      success,
      status: success ? "pinned" : "failed",
      error: success ? undefined : `Pin failed: ${response.status}`
    };
  }
  async unpin(hash) {
    const endpoint = this.config.endpoint ?? "https://api.pinata.cloud";
    const response = await fetch(`${endpoint}/pinning/unpin/${hash}`, {
      method: "DELETE",
      headers: {
        Authorization: `Bearer ${this.config.jwt ?? this.config.apiKey}`,
        ...this.config.headers
      }
    });
    const success = response.ok;
    return {
      hash,
      success,
      status: success ? "pinned" : "failed",
      error: success ? undefined : `Unpin failed: ${response.status}`
    };
  }
}, HttpClientProvider = class {
  constructor(config) {
    this.config = config;
  }
  async upload(content, options2) {
    const endpoint = this.config.endpoint ?? "http://localhost:5001";
    const formData = new FormData;
    const blob = new Blob([content], {
      type: options2?.contentType ?? "application/octet-stream"
    });
    formData.append("file", blob, options2?.filename ?? "content");
    const response = await fetch(`${endpoint}/api/v0/add`, {
      method: "POST",
      body: formData
    });
    if (!response.ok) {
      throw new Error(`IPFS HTTP upload failed: ${response.status}`);
    }
    const result = await response.json();
    const size = typeof content === "string" ? new TextEncoder().encode(content).length : content.length;
    if (typeof result !== "object" || result === null) {
      throw new Error("Invalid IPFS HTTP API response");
    }
    const ipfsResult = result;
    if (typeof ipfsResult.Hash !== "string") {
      throw new Error("IPFS HTTP API response missing Hash field");
    }
    const hash = ipfsResult.Hash;
    return {
      hash,
      uri: `ipfs://${hash}`,
      size,
      timestamp: Date.now(),
      pinned: options2?.pin !== false,
      gateways: [
        `${endpoint}/ipfs/${hash}`,
        `https://ipfs.io/ipfs/${hash}`
      ]
    };
  }
  async retrieve(hash, options2) {
    const gateway = options2?.gateway ?? this.config.endpoint?.replace("/api/v0", "") ?? "https://ipfs.io";
    const url = `${gateway}/ipfs/${hash}`;
    const response = await fetch(url, {
      signal: options2?.timeout ? AbortSignal.timeout(options2.timeout) : undefined
    });
    if (!response.ok) {
      throw new Error(`Failed to retrieve from IPFS: ${response.status}`);
    }
    const contentType = response.headers.get("content-type");
    if (contentType?.startsWith("text/") || contentType?.includes("json")) {
      return response.text();
    } else {
      return new Uint8Array(await response.arrayBuffer());
    }
  }
  async pin(hash) {
    const endpoint = this.config.endpoint ?? "http://localhost:5001";
    const response = await fetch(`${endpoint}/api/v0/pin/add?arg=${hash}`, {
      method: "POST"
    });
    const success = response.ok;
    return {
      hash,
      success,
      status: success ? "pinned" : "failed",
      error: success ? undefined : `Pin failed: ${response.status}`
    };
  }
  async unpin(hash) {
    const endpoint = this.config.endpoint ?? "http://localhost:5001";
    const response = await fetch(`${endpoint}/api/v0/pin/rm?arg=${hash}`, {
      method: "POST"
    });
    const success = response.ok;
    return {
      hash,
      success,
      status: success ? "pinned" : "failed",
      error: success ? undefined : `Unpin failed: ${response.status}`
    };
  }
}, IPFSClient = class {
  constructor(config) {
    this.config = config;
    this.initializeProviders();
  }
  providers = [];
  cache = /* @__PURE__ */ new Map;
  initializeProviders() {
    this.providers.push(this.createProvider(this.config.provider));
    if (this.config.fallbackProviders) {
      for (const providerConfig of this.config.fallbackProviders) {
        this.providers.push(this.createProvider(providerConfig));
      }
    }
  }
  createProvider(config) {
    switch (config.name) {
      case "pinata":
        return new PinataProvider(config);
      case "ipfs-http-client":
      case "custom":
        return new HttpClientProvider(config);
      case "test":
        return new TestIPFSProvider(config);
      default:
        throw new Error(`Unsupported IPFS provider: ${config.name}`);
    }
  }
  async upload(content, options2) {
    const startTime = Date.now();
    let lastError;
    for (let i = 0;i < this.providers.length; i++) {
      const provider = this.providers[i];
      try {
        console.log(`\uD83D\uDCE4 Attempting IPFS upload with provider ${i + 1}/${this.providers.length}`);
        const result = await this.withRetry(() => provider.upload(content, options2), this.config.maxRetries ?? 3, this.config.retryDelay ?? 1000);
        console.log(` IPFS upload successful: ${result.hash}`);
        return {
          success: true,
          data: result,
          duration: Date.now() - startTime,
          provider: this.config.provider.name
        };
      } catch (error) {
        console.warn(` Provider ${i + 1} upload failed:`, error instanceof Error ? error.message : String(error));
        lastError = error instanceof Error ? error : new Error(String(error));
      }
    }
    return {
      success: false,
      error: "UPLOAD_FAILED",
      message: `All providers failed. Last error: ${lastError?.message}`,
      duration: Date.now() - startTime
    };
  }
  async retrieve(hash, options2) {
    const startTime = Date.now();
    if (this.config.enableCache && options2?.cache !== false) {
      const cached = this.cache.get(hash);
      if (cached && Date.now() - cached.timestamp < (this.config.cacheTTL ?? 300000)) {
        return {
          success: true,
          data: {
            content: cached.content,
            size: typeof cached.content === "string" ? cached.content.length : cached.content.length,
            hash,
            gateway: "cache",
            fromCache: true
          },
          duration: Date.now() - startTime
        };
      }
    }
    let lastError;
    const gateways = options2?.gateway ? [options2.gateway] : this.config.gateways ?? ["https://ipfs.io"];
    for (const gateway of gateways) {
      for (const provider of this.providers) {
        try {
          const content = await this.withRetry(() => provider.retrieve(hash, { ...options2, gateway }), this.config.maxRetries ?? 3, this.config.retryDelay ?? 1000);
          if (this.config.enableCache) {
            this.cache.set(hash, { content, timestamp: Date.now() });
          }
          return {
            success: true,
            data: {
              content,
              size: typeof content === "string" ? content.length : content.length,
              hash,
              gateway,
              fromCache: false
            },
            duration: Date.now() - startTime
          };
        } catch (error) {
          lastError = error instanceof Error ? error : new Error(String(error));
        }
      }
    }
    return {
      success: false,
      error: "RETRIEVAL_FAILED",
      message: `Failed to retrieve from all gateways. Last error: ${lastError?.message}`,
      duration: Date.now() - startTime
    };
  }
  async pin(hash) {
    const startTime = Date.now();
    for (const provider of this.providers) {
      try {
        const result = await provider.pin(hash);
        return {
          success: result.success,
          data: result,
          duration: Date.now() - startTime
        };
      } catch (error) {
        console.warn("Pin attempt failed:", error);
      }
    }
    return {
      success: false,
      error: "PIN_FAILED",
      message: "All pin attempts failed",
      duration: Date.now() - startTime
    };
  }
  async storeContent(content, type, options2) {
    const contentSize = new TextEncoder().encode(content).length;
    const sizeThreshold = this.config.sizeThreshold ?? 800;
    const shouldUseIpfs = options2?.forceIpfs ?? contentSize > sizeThreshold;
    if (!shouldUseIpfs) {
      const dataUri = `data:application/json;base64,${btoa(content)}`;
      return {
        uri: dataUri,
        useIpfs: false,
        size: contentSize
      };
    }
    const uploadResult = await this.upload(content, options2);
    if (!uploadResult.success || !uploadResult.data) {
      throw new Error(`IPFS upload failed: ${uploadResult.message}`);
    }
    const ipfsMetadata = {
      type,
      originalSize: contentSize,
      ipfsHash: uploadResult.data.hash,
      encoding: "utf8",
      compression: "none",
      mimeType: "application/json",
      uploadedAt: uploadResult.data.timestamp,
      pinned: uploadResult.data.pinned,
      checksum: await this.calculateChecksum(content)
    };
    return {
      uri: uploadResult.data.uri,
      useIpfs: true,
      ipfsMetadata,
      size: contentSize
    };
  }
  async retrieveContent(uri) {
    if (uri.startsWith("data:")) {
      const base64Data = uri.split(",")[1];
      if (!base64Data) {
        throw new Error("Invalid data URI format");
      }
      return atob(base64Data);
    }
    if (uri.startsWith("ipfs://")) {
      const hash = uri.replace("ipfs://", "");
      const result = await this.retrieve(hash);
      if (!result.success || !result.data) {
        throw new Error(`Failed to retrieve IPFS content: ${result.message}`);
      }
      return typeof result.data.content === "string" ? result.data.content : new TextDecoder().decode(result.data.content);
    }
    throw new Error(`Unsupported URI format: ${uri}`);
  }
  async withRetry(operation, maxRetries, delay) {
    let lastError;
    for (let attempt = 0;attempt <= maxRetries; attempt++) {
      try {
        return await operation();
      } catch (error) {
        lastError = error instanceof Error ? error : new Error(String(error));
        if (attempt < maxRetries) {
          console.log(` Retrying in ${delay}ms... (attempt ${attempt + 1}/${maxRetries})`);
          await new Promise((resolve) => setTimeout(resolve, delay));
        }
      }
    }
    throw lastError;
  }
  async calculateChecksum(content) {
    const encoder2 = new TextEncoder;
    const data2 = encoder2.encode(content);
    const hashBuffer2 = await crypto.subtle.digest("SHA-256", data2);
    const hashArray2 = Array.from(new Uint8Array(hashBuffer2));
    return hashArray2.map((b) => b.toString(16).padStart(2, "0")).join("");
  }
  clearCache() {
    this.cache.clear();
  }
  getCacheStats() {
    return {
      size: this.cache.size,
      keys: Array.from(this.cache.keys())
    };
  }
}, SYSTEM_PROGRAM_ADDRESS, TOKEN_PROGRAM_ADDRESS, TOKEN_2022_PROGRAM_ADDRESS, ASSOCIATED_TOKEN_PROGRAM_ADDRESS, NATIVE_MINT_ADDRESS, ReputationTier2, BadgeType, REPUTATION_CONSTANTS, ReputationCalculator = class {
  fraudPatterns = [];
  constructor() {
    this.initializeFraudPatterns();
  }
  initializeFraudPatterns() {
    this.fraudPatterns = [
      {
        patternId: "sudden_spike",
        description: "Sudden spike in reputation without corresponding activity",
        riskScore: 80,
        detect: (data2) => {
          if (data2.performanceHistory.length < 2)
            return false;
          const recent = data2.performanceHistory[data2.performanceHistory.length - 1];
          const previous = data2.performanceHistory[data2.performanceHistory.length - 2];
          const spike = recent.score - previous.score;
          return spike > 2000 && recent.jobsCompleted === previous.jobsCompleted;
        }
      },
      {
        patternId: "perfect_scores_only",
        description: "All jobs have perfect scores (potential manipulation)",
        riskScore: 60,
        detect: (data2) => {
          const recentJobs = data2.performanceHistory.slice(-10);
          return recentJobs.length >= 5 && recentJobs.every((job) => job.avgQuality === 100);
        }
      },
      {
        patternId: "rapid_category_switching",
        description: "Rapid switching between unrelated categories",
        riskScore: 40,
        detect: (data2) => {
          if (data2.categoryReputations.length < 5)
            return false;
          const recentCategories = data2.categoryReputations.sort((a, b) => b.lastActivity - a.lastActivity).slice(0, 5);
          const daysSinceOldest = (Date.now() - recentCategories[4].lastActivity) / (1000 * 60 * 60 * 24);
          return daysSinceOldest < 7;
        }
      },
      {
        patternId: "dispute_pattern",
        description: "High dispute rate with suspicious resolution pattern",
        riskScore: 70,
        detect: (data2) => {
          if (data2.totalJobsCompleted < 10)
            return false;
          const disputeRate = data2.disputesAgainst / data2.totalJobsCompleted;
          const resolutionRate = data2.disputesResolved / Math.max(1, data2.disputesAgainst);
          return disputeRate > 0.3 && resolutionRate > 0.9;
        }
      },
      {
        patternId: "time_manipulation",
        description: "Completion times significantly below expected",
        riskScore: 50,
        detect: (data2, job) => {
          return job.actualDuration < job.expectedDuration * 0.1;
        }
      }
    ];
  }
  calculateReputation(currentData, jobPerformance) {
    const decayedData = this.applyTimeDecay(currentData);
    const jobScore = this.calculateWeightedScore(decayedData.factors, jobPerformance);
    const categoryUpdate = this.updateCategoryReputation(decayedData.categoryReputations, jobPerformance, jobScore);
    const overallScore = this.calculateOverallScore(categoryUpdate.categories);
    const tier = this.getTierFromScore(overallScore);
    const newBadges = this.checkBadgeAchievements(decayedData, jobPerformance, overallScore);
    const fraudAnalysis = this.detectFraud(decayedData, jobPerformance);
    return {
      overallScore,
      jobScore,
      categoryScore: categoryUpdate.categoryScore,
      tier,
      newBadges,
      fraudDetected: fraudAnalysis.detected,
      fraudRiskScore: fraudAnalysis.riskScore
    };
  }
  applyTimeDecay(data2) {
    const currentTime = Date.now() / 1000;
    const daysSinceUpdate = (currentTime - data2.lastUpdated) / 86400;
    if (daysSinceUpdate <= 0)
      return data2;
    const decayFactor = REPUTATION_CONSTANTS.REPUTATION_DECAY_RATE_BPS * daysSinceUpdate;
    const decayMultiplier = Math.max(0, 1e4 - decayFactor) / 1e4;
    const decayedOverallScore = Math.floor(data2.overallScore * decayMultiplier);
    const decayedCategories = data2.categoryReputations.map((category) => {
      const categoryDaysInactive = (currentTime - category.lastActivity) / 86400;
      const categoryDecay = REPUTATION_CONSTANTS.REPUTATION_DECAY_RATE_BPS * categoryDaysInactive;
      const categoryMultiplier = Math.max(0, 1e4 - categoryDecay) / 1e4;
      return {
        ...category,
        score: Math.floor(category.score * categoryMultiplier)
      };
    });
    return {
      ...data2,
      overallScore: decayedOverallScore,
      categoryReputations: decayedCategories
    };
  }
  calculateWeightedScore(factors, jobPerformance) {
    const totalWeight = factors.completionWeight + factors.qualityWeight + factors.timelinessWeight + factors.satisfactionWeight + factors.disputeWeight;
    if (totalWeight !== 100) {
      throw new Error("Reputation factors must sum to 100");
    }
    const completionScore = jobPerformance.completed ? REPUTATION_CONSTANTS.MAX_REPUTATION_SCORE : 0;
    const qualityScore = jobPerformance.qualityRating * REPUTATION_CONSTANTS.MAX_REPUTATION_SCORE / 100;
    const timelinessScore = this.calculateTimelinessScore(jobPerformance.expectedDuration, jobPerformance.actualDuration);
    const satisfactionScore = jobPerformance.clientSatisfaction * REPUTATION_CONSTANTS.MAX_REPUTATION_SCORE / 100;
    const disputeScore = this.calculateDisputeScore(jobPerformance);
    const weightedScore = (completionScore * factors.completionWeight + qualityScore * factors.qualityWeight + timelinessScore * factors.timelinessWeight + satisfactionScore * factors.satisfactionWeight + disputeScore * factors.disputeWeight) / 100;
    return Math.min(weightedScore, REPUTATION_CONSTANTS.MAX_REPUTATION_SCORE);
  }
  calculateTimelinessScore(expectedDuration, actualDuration) {
    if (actualDuration <= expectedDuration) {
      return REPUTATION_CONSTANTS.MAX_REPUTATION_SCORE;
    }
    const delayRatio = (actualDuration - expectedDuration) * 1e4 / expectedDuration;
    if (delayRatio > 5000) {
      return 0;
    }
    return REPUTATION_CONSTANTS.MAX_REPUTATION_SCORE - REPUTATION_CONSTANTS.MAX_REPUTATION_SCORE * delayRatio / 1e4;
  }
  calculateDisputeScore(jobPerformance) {
    if (!jobPerformance.hadDispute) {
      return REPUTATION_CONSTANTS.MAX_REPUTATION_SCORE;
    }
    if (jobPerformance.disputeResolvedFavorably) {
      return REPUTATION_CONSTANTS.MAX_REPUTATION_SCORE / 2;
    }
    return 0;
  }
  updateCategoryReputation(categories, jobPerformance, jobScore) {
    const existingCategoryIndex = categories.findIndex((c) => c.category === jobPerformance.category);
    if (existingCategoryIndex !== -1) {
      const category = categories[existingCategoryIndex];
      const updatedCategory = {
        ...category,
        completedJobs: category.completedJobs + 1,
        qualitySum: category.qualitySum + jobPerformance.qualityRating,
        qualityCount: category.qualityCount + 1,
        totalEarnings: category.totalEarnings + jobPerformance.paymentAmount,
        lastActivity: Date.now() / 1000,
        score: Math.floor((category.score * 7 + jobScore * 3) / 10),
        avgCompletionTime: Math.floor((category.avgCompletionTime * category.completedJobs + jobPerformance.actualDuration) / (category.completedJobs + 1))
      };
      const newCategories = [...categories];
      newCategories[existingCategoryIndex] = updatedCategory;
      return { categories: newCategories, categoryScore: updatedCategory.score };
    } else {
      if (categories.length >= REPUTATION_CONSTANTS.MAX_REPUTATION_CATEGORIES) {
        throw new Error("Maximum reputation categories reached");
      }
      const newCategory = {
        category: jobPerformance.category,
        score: jobScore,
        completedJobs: 1,
        avgCompletionTime: jobPerformance.actualDuration,
        qualitySum: jobPerformance.qualityRating,
        qualityCount: 1,
        lastActivity: Date.now() / 1000,
        totalEarnings: jobPerformance.paymentAmount
      };
      return {
        categories: [...categories, newCategory],
        categoryScore: jobScore
      };
    }
  }
  calculateOverallScore(categories) {
    if (categories.length === 0)
      return 5000;
    let weightedSum = 0;
    let totalWeight = 0;
    for (const category of categories) {
      const weight = category.completedJobs;
      weightedSum += category.score * weight;
      totalWeight += weight;
    }
    return totalWeight > 0 ? Math.floor(weightedSum / totalWeight) : 5000;
  }
  getTierFromScore(score) {
    if (score >= REPUTATION_CONSTANTS.PLATINUM_TIER_THRESHOLD) {
      return "Platinum";
    } else if (score >= REPUTATION_CONSTANTS.GOLD_TIER_THRESHOLD) {
      return "Gold";
    } else if (score >= REPUTATION_CONSTANTS.SILVER_TIER_THRESHOLD) {
      return "Silver";
    } else if (score >= REPUTATION_CONSTANTS.BRONZE_TIER_THRESHOLD) {
      return "Bronze";
    } else {
      return "None";
    }
  }
  checkBadgeAchievements(data2, jobPerformance, newScore) {
    const newBadges = [];
    const existingBadges = new Set(data2.badges.map((b) => b.badgeType));
    const newTotalJobs = data2.totalJobsCompleted + (jobPerformance.completed ? 1 : 0);
    if (!existingBadges.has("FirstJob") && newTotalJobs >= 1) {
      newBadges.push("FirstJob");
    }
    if (!existingBadges.has("TenJobs") && newTotalJobs >= 10) {
      newBadges.push("TenJobs");
    }
    if (!existingBadges.has("HundredJobs") && newTotalJobs >= 100) {
      newBadges.push("HundredJobs");
    }
    if (!existingBadges.has("ThousandJobs") && newTotalJobs >= 1000) {
      newBadges.push("ThousandJobs");
    }
    if (!existingBadges.has("PerfectRating") && newScore >= 9500) {
      newBadges.push("PerfectRating");
    }
    if (!existingBadges.has("QuickResponder") && data2.avgResponseTime > 0 && data2.avgResponseTime < 3600) {
      newBadges.push("QuickResponder");
    }
    if (!existingBadges.has("DisputeResolver") && data2.disputesResolved >= 5) {
      newBadges.push("DisputeResolver");
    }
    if (!existingBadges.has("CategoryExpert")) {
      const hasExpertCategory = data2.categoryReputations.some((c) => c.score >= 9000);
      if (hasExpertCategory) {
        newBadges.push("CategoryExpert");
      }
    }
    if (!existingBadges.has("CrossCategoryMaster") && data2.categoryReputations.length >= 5) {
      newBadges.push("CrossCategoryMaster");
    }
    return newBadges;
  }
  detectFraud(data2, jobPerformance) {
    let totalRiskScore = 0;
    const detectedPatterns = [];
    for (const pattern of this.fraudPatterns) {
      if (pattern.detect(data2, jobPerformance)) {
        totalRiskScore += pattern.riskScore;
        detectedPatterns.push(pattern.patternId);
      }
    }
    const normalizedRiskScore = Math.min(100, totalRiskScore);
    return {
      detected: normalizedRiskScore >= 50,
      riskScore: normalizedRiskScore,
      patterns: detectedPatterns
    };
  }
  createPerformanceSnapshot(data2, newScore) {
    const avgQuality = data2.categoryReputations.length > 0 ? data2.categoryReputations.reduce((sum, cat) => {
      return sum + (cat.qualityCount > 0 ? cat.qualitySum / cat.qualityCount : 0);
    }, 0) / data2.categoryReputations.length : 0;
    return {
      timestamp: Date.now() / 1000,
      score: newScore,
      jobsCompleted: data2.totalJobsCompleted,
      avgQuality: Math.floor(avgQuality)
    };
  }
  calculateSlashAmount(currentScore, slashPercentage) {
    if (slashPercentage > 5000) {
      throw new Error("Slash percentage cannot exceed 50%");
    }
    if (currentScore < REPUTATION_CONSTANTS.MIN_REPUTATION_FOR_SLASH) {
      throw new Error("Reputation too low to slash");
    }
    const slashAmount = Math.floor(currentScore * slashPercentage / 1e4);
    const newScore = Math.max(0, currentScore - slashAmount);
    return { newScore, slashAmount };
  }
  calculateStakingBonus(stakeAmount) {
    return Math.min(500, Math.floor(stakeAmount / 1000));
  }
};
var init_chunk_C5CDA3WX = __esm(() => {
  init_chunk_UP2VWCW5();
  init_index_node5();
  init_reputation_tags = __esm2({
    "src/types/reputation-tags.ts"() {
      TagCategory = /* @__PURE__ */ ((TagCategory2) => {
        TagCategory2["Skill"] = "skill";
        TagCategory2["Behavior"] = "behavior";
        TagCategory2["Compliance"] = "compliance";
        return TagCategory2;
      })(TagCategory || {});
      SkillTag = /* @__PURE__ */ ((SkillTag2) => {
        SkillTag2["CodeGeneration"] = "code-generation";
        SkillTag2["DataAnalysis"] = "data-analysis";
        SkillTag2["ContentCreation"] = "content-creation";
        SkillTag2["ImageGeneration"] = "image-generation";
        SkillTag2["AudioProcessing"] = "audio-processing";
        SkillTag2["VideoProcessing"] = "video-processing";
        SkillTag2["NaturalLanguageProcessing"] = "nlp-specialist";
        SkillTag2["ComputerVision"] = "computer-vision";
        SkillTag2["ReinforcementLearning"] = "reinforcement-learning";
        SkillTag2["DeFiExpert"] = "defi-expert";
        SkillTag2["NFTSpecialist"] = "nft-specialist";
        SkillTag2["SmartContractAudit"] = "smart-contract-audit";
        SkillTag2["BlockchainDevelopment"] = "blockchain-dev";
        SkillTag2["DAOGovernance"] = "dao-governance";
        SkillTag2["GameDevelopment"] = "game-dev";
        SkillTag2["WebDevelopment"] = "web-dev";
        SkillTag2["MobileDevelopment"] = "mobile-dev";
        SkillTag2["APIIntegration"] = "api-integration";
        SkillTag2["DatabaseManagement"] = "database-management";
        SkillTag2["DevOpsAutomation"] = "devops-automation";
        SkillTag2["FinancialAnalysis"] = "financial-analysis";
        SkillTag2["MarketResearch"] = "market-research";
        SkillTag2["LegalCompliance"] = "legal-compliance";
        SkillTag2["CustomerSupport"] = "customer-support";
        SkillTag2["TranslationServices"] = "translation-services";
        SkillTag2["SecurityAudit"] = "security-audit";
        SkillTag2["PenetrationTesting"] = "penetration-testing";
        SkillTag2["ThreatDetection"] = "threat-detection";
        SkillTag2["IncidentResponse"] = "incident-response";
        SkillTag2["DataEngineering"] = "data-engineering";
        SkillTag2["DataVisualization"] = "data-visualization";
        SkillTag2["PredictiveModeling"] = "predictive-modeling";
        SkillTag2["StatisticalAnalysis"] = "statistical-analysis";
        return SkillTag2;
      })(SkillTag || {});
      BehaviorTag = /* @__PURE__ */ ((BehaviorTag2) => {
        BehaviorTag2["FastResponder"] = "fast-responder";
        BehaviorTag2["QuickResponder"] = "quick-responder";
        BehaviorTag2["SameDay"] = "same-day";
        BehaviorTag2["ConsistentQuality"] = "consistent-quality";
        BehaviorTag2["HighQuality"] = "high-quality";
        BehaviorTag2["TopRated"] = "top-rated";
        BehaviorTag2["PerfectRecord"] = "perfect-record";
        BehaviorTag2["HighVolume"] = "high-volume";
        BehaviorTag2["VeryHighVolume"] = "very-high-volume";
        BehaviorTag2["MegaVolume"] = "mega-volume";
        BehaviorTag2["LongTermActive"] = "long-term-active";
        BehaviorTag2["MultiYear"] = "multi-year";
        BehaviorTag2["CategorySpecialist"] = "category-specialist";
        BehaviorTag2["MultiDomain"] = "multi-domain";
        BehaviorTag2["Generalist"] = "generalist";
        BehaviorTag2["DisputeFree"] = "dispute-free";
        BehaviorTag2["LowDispute"] = "low-dispute";
        BehaviorTag2["HighResolution"] = "high-resolution";
        BehaviorTag2["PlatinumTier"] = "platinum-tier";
        BehaviorTag2["GoldTier"] = "gold-tier";
        BehaviorTag2["SilverTier"] = "silver-tier";
        BehaviorTag2["BronzeTier"] = "bronze-tier";
        BehaviorTag2["Responsive"] = "responsive";
        BehaviorTag2["Communicative"] = "communicative";
        BehaviorTag2["Proactive"] = "proactive";
        BehaviorTag2["DetailOriented"] = "detail-oriented";
        BehaviorTag2["VerifiedIdentity"] = "verified-identity";
        BehaviorTag2["LongStanding"] = "long-standing";
        BehaviorTag2["CommunityTrusted"] = "community-trusted";
        BehaviorTag2["ClientFavorite"] = "client-favorite";
        return BehaviorTag2;
      })(BehaviorTag || {});
      ComplianceTag = /* @__PURE__ */ ((ComplianceTag2) => {
        ComplianceTag2["KYCVerified"] = "kyc-verified";
        ComplianceTag2["KYBVerified"] = "kyb-verified";
        ComplianceTag2["AccreditedInvestor"] = "accredited-investor";
        ComplianceTag2["SOC2Compliant"] = "soc2-compliant";
        ComplianceTag2["ISO27001"] = "iso-27001";
        ComplianceTag2["GDPR"] = "gdpr-compliant";
        ComplianceTag2["HIPAA"] = "hipaa-compliant";
        ComplianceTag2["PCI_DSS"] = "pci-dss";
        ComplianceTag2["AuditedCode"] = "audited-code";
        ComplianceTag2["BugBounty"] = "bug-bounty";
        ComplianceTag2["OpenSource"] = "open-source";
        ComplianceTag2["InsuredService"] = "insured-service";
        ComplianceTag2["BondedAgent"] = "bonded-agent";
        ComplianceTag2["LicensedProfessional"] = "licensed-professional";
        ComplianceTag2["RegulatedEntity"] = "regulated-entity";
        ComplianceTag2["PublicAuditTrail"] = "public-audit-trail";
        ComplianceTag2["TransparentPricing"] = "transparent-pricing";
        ComplianceTag2["VerifiedMetrics"] = "verified-metrics";
        return ComplianceTag2;
      })(ComplianceTag || {});
      TAG_CONSTANTS = {
        MAX_SKILL_TAGS: 20,
        MAX_BEHAVIOR_TAGS: 20,
        MAX_COMPLIANCE_TAGS: 10,
        MAX_TAG_SCORES: 50,
        MAX_TAG_NAME_LENGTH: 32,
        STALE_TAG_THRESHOLD: 90 * 24 * 60 * 60,
        MIN_TAG_CONFIDENCE: 5000,
        MAX_TAG_CONFIDENCE: 1e4,
        BASIS_POINTS_MAX: 1e4
      };
      DEFAULT_TAG_DECAY = {
        decayRatePerDay: 10,
        minConfidence: 2000,
        maxAgeSeconds: 90 * 24 * 60 * 60
      };
      TagConfidenceLevel = /* @__PURE__ */ ((TagConfidenceLevel2) => {
        TagConfidenceLevel2[TagConfidenceLevel2["VeryLow"] = 2000] = "VeryLow";
        TagConfidenceLevel2[TagConfidenceLevel2["Low"] = 4000] = "Low";
        TagConfidenceLevel2[TagConfidenceLevel2["Medium"] = 6000] = "Medium";
        TagConfidenceLevel2[TagConfidenceLevel2["High"] = 8000] = "High";
        TagConfidenceLevel2[TagConfidenceLevel2["VeryHigh"] = 9500] = "VeryHigh";
        TagConfidenceLevel2[TagConfidenceLevel2["Absolute"] = 1e4] = "Absolute";
        return TagConfidenceLevel2;
      })(TagConfidenceLevel || {});
    }
  });
  reputation_tag_engine_exports = {};
  __export2(reputation_tag_engine_exports, {
    ReputationTagEngine: () => ReputationTagEngine
  });
  init_reputation_tag_engine = __esm2({
    "src/utils/reputation-tag-engine.ts"() {
      init_reputation_tags();
      ReputationTagEngine = class {
        tagCriteria = [];
        decayConfig;
        constructor(decayConfig = DEFAULT_TAG_DECAY) {
          this.decayConfig = decayConfig;
          this.initializeTagCriteria();
        }
        initializeTagCriteria() {
          this.tagCriteria = [
            {
              tag: "fast-responder",
              category: "behavior",
              minConfidence: TAG_CONSTANTS.MIN_TAG_CONFIDENCE,
              evaluate: (metrics) => {
                if (metrics.responseTimeCount === 0n) {
                  return { shouldAssign: false, confidence: 0, evidenceCount: 0 };
                }
                const avgResponseTime = metrics.avgResponseTime;
                const evidenceCount = Number(metrics.responseTimeCount);
                if (avgResponseTime < 60000) {
                  const confidence = Math.min(1e4, 1e4 - Math.floor(avgResponseTime / 60000 * 2000));
                  return {
                    shouldAssign: true,
                    confidence,
                    evidenceCount,
                    reason: `Average response time ${avgResponseTime}ms`
                  };
                }
                return { shouldAssign: false, confidence: 0, evidenceCount };
              }
            },
            {
              tag: "quick-responder",
              category: "behavior",
              minConfidence: TAG_CONSTANTS.MIN_TAG_CONFIDENCE,
              evaluate: (metrics) => {
                if (metrics.responseTimeCount === 0n) {
                  return { shouldAssign: false, confidence: 0, evidenceCount: 0 };
                }
                const avgResponseTime = metrics.avgResponseTime;
                const evidenceCount = Number(metrics.responseTimeCount);
                if (avgResponseTime < 300000) {
                  const confidence = Math.min(1e4, 1e4 - Math.floor(avgResponseTime / 300000 * 3000));
                  return {
                    shouldAssign: true,
                    confidence,
                    evidenceCount,
                    reason: `Average response time ${avgResponseTime}ms`
                  };
                }
                return { shouldAssign: false, confidence: 0, evidenceCount };
              }
            },
            {
              tag: "dispute-free",
              category: "behavior",
              minConfidence: TAG_CONSTANTS.MIN_TAG_CONFIDENCE,
              evaluate: (metrics) => {
                const totalPayments = Number(metrics.successfulPayments + metrics.failedPayments);
                if (totalPayments < 10) {
                  return { shouldAssign: false, confidence: 0, evidenceCount: 0 };
                }
                if (metrics.totalDisputes === 0) {
                  const confidence = Math.min(1e4, 7000 + totalPayments * 10);
                  return {
                    shouldAssign: true,
                    confidence,
                    evidenceCount: totalPayments,
                    reason: `0 disputes over ${totalPayments} transactions`
                  };
                }
                return { shouldAssign: false, confidence: 0, evidenceCount: totalPayments };
              }
            },
            {
              tag: "low-dispute",
              category: "behavior",
              minConfidence: TAG_CONSTANTS.MIN_TAG_CONFIDENCE,
              evaluate: (metrics) => {
                const totalPayments = Number(metrics.successfulPayments + metrics.failedPayments);
                if (totalPayments < 100) {
                  return { shouldAssign: false, confidence: 0, evidenceCount: 0 };
                }
                const disputeRate = metrics.totalDisputes / totalPayments * 100;
                if (disputeRate < 1) {
                  const confidence = Math.min(1e4, 1e4 - Math.floor(disputeRate * 1000));
                  return {
                    shouldAssign: true,
                    confidence,
                    evidenceCount: totalPayments,
                    reason: `${disputeRate.toFixed(2)}% dispute rate`
                  };
                }
                return { shouldAssign: false, confidence: 0, evidenceCount: totalPayments };
              }
            },
            {
              tag: "high-volume",
              category: "behavior",
              minConfidence: TAG_CONSTANTS.MIN_TAG_CONFIDENCE,
              evaluate: (metrics) => {
                const totalPayments = Number(metrics.successfulPayments);
                if (totalPayments >= 1000) {
                  const confidence = Math.min(1e4, 6000 + Math.floor(totalPayments / 100));
                  return {
                    shouldAssign: true,
                    confidence,
                    evidenceCount: totalPayments,
                    reason: `${totalPayments} successful transactions`
                  };
                }
                return { shouldAssign: false, confidence: 0, evidenceCount: totalPayments };
              }
            },
            {
              tag: "very-high-volume",
              category: "behavior",
              minConfidence: TAG_CONSTANTS.MIN_TAG_CONFIDENCE,
              evaluate: (metrics) => {
                const totalPayments = Number(metrics.successfulPayments);
                if (totalPayments >= 1e4) {
                  const confidence = Math.min(1e4, 8000 + Math.floor(totalPayments / 1000));
                  return {
                    shouldAssign: true,
                    confidence,
                    evidenceCount: totalPayments,
                    reason: `${totalPayments} successful transactions`
                  };
                }
                return { shouldAssign: false, confidence: 0, evidenceCount: totalPayments };
              }
            },
            {
              tag: "top-rated",
              category: "behavior",
              minConfidence: TAG_CONSTANTS.MIN_TAG_CONFIDENCE,
              evaluate: (metrics) => {
                if (metrics.totalRatingsCount < 10) {
                  return { shouldAssign: false, confidence: 0, evidenceCount: 0 };
                }
                const avgRating = metrics.avgRating / 20;
                const evidenceCount = metrics.totalRatingsCount;
                if (avgRating > 4.8) {
                  const confidence = Math.min(1e4, Math.floor((avgRating - 4.8) * 50000) + 8000);
                  return {
                    shouldAssign: true,
                    confidence,
                    evidenceCount,
                    reason: `Average rating ${avgRating.toFixed(2)}/5.0`
                  };
                }
                return { shouldAssign: false, confidence: 0, evidenceCount };
              }
            },
            {
              tag: "high-quality",
              category: "behavior",
              minConfidence: TAG_CONSTANTS.MIN_TAG_CONFIDENCE,
              evaluate: (metrics) => {
                if (metrics.totalRatingsCount < 5) {
                  return { shouldAssign: false, confidence: 0, evidenceCount: 0 };
                }
                const avgRating = metrics.avgRating / 20;
                const evidenceCount = metrics.totalRatingsCount;
                if (avgRating > 4.5) {
                  const confidence = Math.min(1e4, Math.floor((avgRating - 4.5) * 20000) + 7000);
                  return {
                    shouldAssign: true,
                    confidence,
                    evidenceCount,
                    reason: `Average rating ${avgRating.toFixed(2)}/5.0`
                  };
                }
                return { shouldAssign: false, confidence: 0, evidenceCount };
              }
            },
            {
              tag: "consistent-quality",
              category: "behavior",
              minConfidence: TAG_CONSTANTS.MIN_TAG_CONFIDENCE,
              evaluate: (metrics) => {
                if (metrics.totalRatingsCount < 20) {
                  return { shouldAssign: false, confidence: 0, evidenceCount: 0 };
                }
                const avgRating = metrics.avgRating / 20;
                const evidenceCount = metrics.totalRatingsCount;
                if (avgRating > 4.3) {
                  const confidence = Math.min(1e4, Math.floor((avgRating - 4) * 1e4) + 5000);
                  return {
                    shouldAssign: true,
                    confidence,
                    evidenceCount,
                    reason: `Consistent high ratings (${avgRating.toFixed(2)}/5.0)`
                  };
                }
                return { shouldAssign: false, confidence: 0, evidenceCount };
              }
            },
            {
              tag: "perfect-record",
              category: "behavior",
              minConfidence: TAG_CONSTANTS.MIN_TAG_CONFIDENCE,
              evaluate: (metrics) => {
                const totalPayments = Number(metrics.successfulPayments + metrics.failedPayments);
                if (totalPayments < 50) {
                  return { shouldAssign: false, confidence: 0, evidenceCount: 0 };
                }
                const successRate = metrics.successRate / 100;
                if (successRate === 100 && metrics.failedPayments === 0n) {
                  const confidence = Math.min(1e4, 8000 + Math.floor(totalPayments / 10));
                  return {
                    shouldAssign: true,
                    confidence,
                    evidenceCount: totalPayments,
                    reason: `100% success rate over ${totalPayments} transactions`
                  };
                }
                return { shouldAssign: false, confidence: 0, evidenceCount: totalPayments };
              }
            },
            {
              tag: "high-resolution",
              category: "behavior",
              minConfidence: TAG_CONSTANTS.MIN_TAG_CONFIDENCE,
              evaluate: (metrics) => {
                if (metrics.totalDisputes < 5) {
                  return { shouldAssign: false, confidence: 0, evidenceCount: 0 };
                }
                const resolutionRate = metrics.disputesResolved / metrics.totalDisputes * 100;
                const evidenceCount = metrics.totalDisputes;
                if (resolutionRate > 90) {
                  const confidence = Math.min(1e4, Math.floor((resolutionRate - 90) * 1000) + 8000);
                  return {
                    shouldAssign: true,
                    confidence,
                    evidenceCount,
                    reason: `${resolutionRate.toFixed(1)}% disputes resolved favorably`
                  };
                }
                return { shouldAssign: false, confidence: 0, evidenceCount };
              }
            },
            {
              tag: "long-term-active",
              category: "behavior",
              minConfidence: TAG_CONSTANTS.MIN_TAG_CONFIDENCE,
              evaluate: (metrics) => {
                const currentTime = Math.floor(Date.now() / 1000);
                const ageSeconds = currentTime - metrics.createdAt;
                const ageYears = ageSeconds / (365 * 24 * 60 * 60);
                if (ageYears >= 1) {
                  const confidence = Math.min(1e4, Math.floor(ageYears * 2000) + 6000);
                  return {
                    shouldAssign: true,
                    confidence,
                    evidenceCount: Math.floor(ageYears),
                    reason: `Active for ${ageYears.toFixed(1)} years`
                  };
                }
                return { shouldAssign: false, confidence: 0, evidenceCount: 0 };
              }
            },
            {
              tag: "multi-year",
              category: "behavior",
              minConfidence: TAG_CONSTANTS.MIN_TAG_CONFIDENCE,
              evaluate: (metrics) => {
                const currentTime = Math.floor(Date.now() / 1000);
                const ageSeconds = currentTime - metrics.createdAt;
                const ageYears = ageSeconds / (365 * 24 * 60 * 60);
                if (ageYears >= 3) {
                  const confidence = Math.min(1e4, Math.floor(ageYears * 1000) + 7000);
                  return {
                    shouldAssign: true,
                    confidence,
                    evidenceCount: Math.floor(ageYears),
                    reason: `Active for ${ageYears.toFixed(1)} years`
                  };
                }
                return { shouldAssign: false, confidence: 0, evidenceCount: 0 };
              }
            }
          ];
        }
        async calculateTags(metrics) {
          const tagScores = [];
          const currentTime = Math.floor(Date.now() / 1000);
          for (const criteria of this.tagCriteria) {
            const evaluation = criteria.evaluate(metrics);
            if (evaluation.shouldAssign && evaluation.confidence >= criteria.minConfidence) {
              tagScores.push({
                tagName: criteria.tag,
                confidence: evaluation.confidence,
                evidenceCount: evaluation.evidenceCount,
                lastUpdated: currentTime
              });
            }
          }
          return tagScores;
        }
        applyTagDecay(tagScores, currentTimestamp) {
          const now = currentTimestamp || Math.floor(Date.now() / 1000);
          const decayedTags = [];
          for (const tag of tagScores) {
            const ageSeconds = now - tag.lastUpdated;
            const ageDays = ageSeconds / (24 * 60 * 60);
            const totalDecay = Math.floor(ageDays * this.decayConfig.decayRatePerDay);
            const newConfidence = Math.max(0, tag.confidence - totalDecay);
            if (newConfidence >= this.decayConfig.minConfidence && ageSeconds <= this.decayConfig.maxAgeSeconds) {
              decayedTags.push({
                ...tag,
                confidence: newConfidence
              });
            }
          }
          return decayedTags;
        }
        mergeTags(existingTags, newTags) {
          const tagMap = /* @__PURE__ */ new Map;
          for (const tag of existingTags) {
            tagMap.set(tag.tagName, tag);
          }
          for (const tag of newTags) {
            const existing = tagMap.get(tag.tagName);
            if (existing) {
              if (tag.confidence > existing.confidence || tag.evidenceCount > existing.evidenceCount) {
                tagMap.set(tag.tagName, tag);
              }
            } else {
              tagMap.set(tag.tagName, tag);
            }
          }
          return Array.from(tagMap.values());
        }
        filterTags(tags, filters) {
          let filtered = [...tags];
          const currentTime = Math.floor(Date.now() / 1000);
          if (filters.category) {
            filtered = filtered.filter((tag) => this.getTagCategory(tag.tagName) === filters.category);
          }
          if (filters.minConfidence !== undefined) {
            filtered = filtered.filter((tag) => tag.confidence >= filters.minConfidence);
          }
          if (filters.maxAge !== undefined) {
            filtered = filtered.filter((tag) => {
              const age = currentTime - tag.lastUpdated;
              return age <= filters.maxAge;
            });
          }
          if (filters.activeOnly) {
            filtered = filtered.filter((tag) => {
              const age = currentTime - tag.lastUpdated;
              return age <= TAG_CONSTANTS.STALE_TAG_THRESHOLD && tag.confidence >= this.decayConfig.minConfidence;
            });
          }
          return filtered;
        }
        getTagCategory(tagName) {
          if (Object.values(SkillTag).includes(tagName)) {
            return "skill";
          } else if (Object.values(BehaviorTag).includes(tagName)) {
            return "behavior";
          } else if (Object.values(ComplianceTag).includes(tagName)) {
            return "compliance";
          }
          return "behavior";
        }
        validateTagName(tagName) {
          return tagName.length > 0 && tagName.length <= TAG_CONSTANTS.MAX_TAG_NAME_LENGTH;
        }
        validateConfidence(confidence) {
          return confidence >= 0 && confidence <= TAG_CONSTANTS.MAX_TAG_CONFIDENCE;
        }
        getConfidenceLevel(confidence) {
          if (confidence >= 1e4)
            return "Absolute";
          if (confidence >= 9500)
            return "Very High";
          if (confidence >= 8000)
            return "High";
          if (confidence >= 6000)
            return "Medium";
          if (confidence >= 4000)
            return "Low";
          return "Very Low";
        }
        sortByConfidence(tags) {
          return [...tags].sort((a, b) => b.confidence - a.confidence);
        }
        sortByEvidence(tags) {
          return [...tags].sort((a, b) => b.evidenceCount - a.evidenceCount);
        }
        sortByRecent(tags) {
          return [...tags].sort((a, b) => b.lastUpdated - a.lastUpdated);
        }
        getTopTags(tags, count) {
          return this.sortByConfidence(tags).slice(0, count);
        }
        categorizeTags(tags) {
          const skillTags = [];
          const behaviorTags = [];
          const complianceTags = [];
          const allTags = [];
          for (const tag of tags) {
            allTags.push(tag.tagName);
            const category = this.getTagCategory(tag.tagName);
            switch (category) {
              case "skill":
                skillTags.push(tag.tagName);
                break;
              case "behavior":
                behaviorTags.push(tag.tagName);
                break;
              case "compliance":
                complianceTags.push(tag.tagName);
                break;
            }
          }
          return {
            allTags,
            skillTags,
            behaviorTags,
            complianceTags,
            tagScores: tags,
            lastUpdated: tags.length > 0 ? Math.max(...tags.map((t) => t.lastUpdated)) : 0
          };
        }
      };
    }
  });
  PrivacyMode = /* @__PURE__ */ ((PrivacyMode2) => {
    PrivacyMode2["Public"] = "Public";
    PrivacyMode2["TierOnly"] = "TierOnly";
    PrivacyMode2["RangeOnly"] = "RangeOnly";
    PrivacyMode2["Custom"] = "Custom";
    PrivacyMode2["Confidential"] = "Confidential";
    return PrivacyMode2;
  })(PrivacyMode || {});
  VisibilityLevel = /* @__PURE__ */ ((VisibilityLevel2) => {
    VisibilityLevel2["Public"] = "Public";
    VisibilityLevel2["Private"] = "Private";
    VisibilityLevel2["ZKProof"] = "ZKProof";
    return VisibilityLevel2;
  })(VisibilityLevel || {});
  ScoreRange = /* @__PURE__ */ ((ScoreRange2) => {
    ScoreRange2["VeryLow"] = "VeryLow";
    ScoreRange2["Low"] = "Low";
    ScoreRange2["Medium"] = "Medium";
    ScoreRange2["High"] = "High";
    ScoreRange2["VeryHigh"] = "VeryHigh";
    return ScoreRange2;
  })(ScoreRange || {});
  PrivacyPresets = {
    CONSERVATIVE: {
      name: "Conservative",
      mode: "TierOnly",
      metricVisibility: {
        showScore: "Private",
        showJobsCompleted: "Private",
        showSuccessRate: "Private",
        showResponseTime: "Private",
        showDisputes: "Private",
        showEarnings: "Private",
        showRatings: "Private",
        showBadges: "Public"
      },
      autoGrantClients: false
    },
    BALANCED: {
      name: "Balanced",
      mode: "Custom",
      metricVisibility: {
        showScore: "Private",
        showJobsCompleted: "Public",
        showSuccessRate: "Public",
        showResponseTime: "Public",
        showDisputes: "Private",
        showEarnings: "Private",
        showRatings: "Public",
        showBadges: "Public"
      },
      autoGrantClients: true
    },
    OPEN: {
      name: "Open",
      mode: "Public",
      metricVisibility: {
        showScore: "Public",
        showJobsCompleted: "Public",
        showSuccessRate: "Public",
        showResponseTime: "Public",
        showDisputes: "Public",
        showEarnings: "Public",
        showRatings: "Public",
        showBadges: "Public"
      },
      autoGrantClients: true
    }
  };
  PRIVACY_CONSTANTS = {
    SCORE_RANGES: {
      VERY_LOW: { min: 0, max: 2000 },
      LOW: { min: 2000, max: 5000 },
      MEDIUM: { min: 5000, max: 7500 },
      HIGH: { min: 7500, max: 9000 },
      VERY_HIGH: { min: 9000, max: 1e4 }
    },
    TIER_THRESHOLDS: {
      BRONZE: 2000,
      SILVER: 5000,
      GOLD: 7500,
      PLATINUM: 9000
    },
    MAX_AUTHORIZED_VIEWERS: 100
  };
  init_reputation_tags();
  instructionAccountMappings = {
    activate_agent: {
      name: "activate_agent",
      expectedAccounts: [
        {
          name: "agent_account",
          pda: true
        },
        {
          name: "signer",
          pda: false
        },
        {
          name: "clock",
          pda: false
        }
      ],
      accounts: [
        {
          name: "agent_account",
          writable: true,
          signer: false,
          optional: false,
          docs: [
            "Agent account with canonical PDA validation"
          ],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  97,
                  103,
                  101,
                  110,
                  116
                ]
              },
              {
                kind: "account",
                path: "signer"
              },
              {
                kind: "arg",
                path: "agent_id"
              }
            ]
          }
        },
        {
          name: "signer",
          writable: true,
          signer: true,
          optional: false,
          docs: [
            "Enhanced authority verification"
          ]
        },
        {
          name: "clock",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "Clock sysvar for rate limiting"
          ],
          address: "SysvarC1ock11111111111111111111111111111111"
        }
      ],
      docs: "",
      discriminator: [
        252,
        139,
        87,
        21,
        195,
        152,
        29,
        217
      ],
      args: [
        {
          name: "agent_id",
          type: "string"
        }
      ]
    },
    approve_delivery: {
      name: "approve_delivery",
      expectedAccounts: [
        {
          name: "escrow",
          pda: true
        },
        {
          name: "escrow_vault",
          pda: false
        },
        {
          name: "agent_token_account",
          pda: false
        },
        {
          name: "client",
          pda: false
        },
        {
          name: "token_program",
          pda: false
        }
      ],
      accounts: [
        {
          name: "escrow",
          writable: true,
          signer: false,
          optional: false,
          docs: [],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  103,
                  104,
                  111,
                  115,
                  116,
                  95,
                  112,
                  114,
                  111,
                  116,
                  101,
                  99,
                  116
                ]
              },
              {
                kind: "account",
                path: "escrow.client",
                account: "GhostProtectEscrow"
              },
              {
                kind: "account",
                path: "escrow.escrow_id",
                account: "GhostProtectEscrow"
              }
            ]
          }
        },
        {
          name: "escrow_vault",
          writable: true,
          signer: false,
          optional: false,
          docs: []
        },
        {
          name: "agent_token_account",
          writable: true,
          signer: false,
          optional: false,
          docs: []
        },
        {
          name: "client",
          writable: false,
          signer: true,
          optional: false,
          docs: []
        },
        {
          name: "token_program",
          writable: false,
          signer: false,
          optional: false,
          docs: [],
          address: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
        }
      ],
      docs: "Client approves delivery and releases payment",
      discriminator: [
        28,
        233,
        51,
        115,
        33,
        220,
        41,
        28
      ],
      args: []
    },
    arbitrate_dispute: {
      name: "arbitrate_dispute",
      expectedAccounts: [
        {
          name: "escrow",
          pda: true
        },
        {
          name: "escrow_vault",
          pda: false
        },
        {
          name: "agent_token_account",
          pda: false
        },
        {
          name: "client_token_account",
          pda: false
        },
        {
          name: "agent_staking",
          pda: true
        },
        {
          name: "arbitrator",
          pda: false
        },
        {
          name: "token_program",
          pda: false
        }
      ],
      accounts: [
        {
          name: "escrow",
          writable: true,
          signer: false,
          optional: false,
          docs: [],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  103,
                  104,
                  111,
                  115,
                  116,
                  95,
                  112,
                  114,
                  111,
                  116,
                  101,
                  99,
                  116
                ]
              },
              {
                kind: "account",
                path: "escrow.client",
                account: "GhostProtectEscrow"
              },
              {
                kind: "account",
                path: "escrow.escrow_id",
                account: "GhostProtectEscrow"
              }
            ]
          }
        },
        {
          name: "escrow_vault",
          writable: true,
          signer: false,
          optional: false,
          docs: []
        },
        {
          name: "agent_token_account",
          writable: true,
          signer: false,
          optional: false,
          docs: []
        },
        {
          name: "client_token_account",
          writable: true,
          signer: false,
          optional: false,
          docs: []
        },
        {
          name: "agent_staking",
          writable: true,
          signer: false,
          optional: false,
          docs: [
            "Agent's staking account (for potential slashing)"
          ],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  115,
                  116,
                  97,
                  107,
                  105,
                  110,
                  103
                ]
              },
              {
                kind: "account",
                path: "escrow.agent",
                account: "GhostProtectEscrow"
              }
            ]
          }
        },
        {
          name: "arbitrator",
          writable: false,
          signer: true,
          optional: false,
          docs: []
        },
        {
          name: "token_program",
          writable: false,
          signer: false,
          optional: false,
          docs: [],
          address: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
        }
      ],
      docs: "Arbitrator resolves dispute (admin only)",
      discriminator: [
        225,
        89,
        166,
        101,
        215,
        40,
        191,
        4
      ],
      args: [
        {
          name: "decision",
          type: {
            defined: {
              name: "ArbitratorDecision"
            }
          }
        }
      ]
    },
    create_agent_authorization: {
      name: "create_agent_authorization",
      expectedAccounts: [
        {
          name: "agent",
          pda: false
        },
        {
          name: "authorization",
          pda: true
        },
        {
          name: "authority",
          pda: false
        },
        {
          name: "system_program",
          pda: false
        }
      ],
      accounts: [
        {
          name: "agent",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "Agent granting authorization"
          ]
        },
        {
          name: "authorization",
          writable: true,
          signer: false,
          optional: false,
          docs: [
            "Authorization account (PDA)"
          ],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  97,
                  103,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104
                ]
              },
              {
                kind: "account",
                path: "agent"
              },
              {
                kind: "arg",
                path: "authorized_source"
              },
              {
                kind: "arg",
                path: "nonce"
              }
            ]
          }
        },
        {
          name: "authority",
          writable: true,
          signer: true,
          optional: false,
          docs: [
            "Authority (agent owner)"
          ]
        },
        {
          name: "system_program",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "System program"
          ],
          address: "11111111111111111111111111111111"
        }
      ],
      docs: "Create agent authorization for reputation updates  Allows an agent to pre-authorize a facilitator (e.g., PayAI) to update their reputation a limited number of times before expiration.  Parameters: - authorized_source: Pubkey of the facilitator being authorized - index_limit: Maximum number of updates allowed - expires_at: Unix timestamp when authorization expires - network: Network ID for cross-chain compatibility - signature: Ed25519 signature proving agent's consent - nonce: Optional nonce for multiple authorizations to same facilitator",
      discriminator: [
        48,
        219,
        232,
        202,
        151,
        97,
        230,
        20
      ],
      args: [
        {
          name: "authorized_source",
          type: "pubkey"
        },
        {
          name: "index_limit",
          type: "u64"
        },
        {
          name: "expires_at",
          type: "i64"
        },
        {
          name: "network",
          type: "u8"
        },
        {
          name: "signature",
          type: {
            array: [
              "u8",
              64
            ]
          }
        },
        {
          name: "nonce",
          type: {
            option: "string"
          }
        }
      ]
    },
    create_credential_template: {
      name: "create_credential_template",
      expectedAccounts: [
        {
          name: "credential_template",
          pda: true
        },
        {
          name: "credential_type",
          pda: false
        },
        {
          name: "issuer",
          pda: false
        },
        {
          name: "system_program",
          pda: false
        }
      ],
      accounts: [
        {
          name: "credential_template",
          writable: true,
          signer: false,
          optional: false,
          docs: [],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  99,
                  114,
                  101,
                  100,
                  101,
                  110,
                  116,
                  105,
                  97,
                  108,
                  95,
                  116,
                  101,
                  109,
                  112,
                  108,
                  97,
                  116,
                  101
                ]
              },
              {
                kind: "account",
                path: "credential_type"
              },
              {
                kind: "arg",
                path: "name"
              }
            ]
          }
        },
        {
          name: "credential_type",
          writable: false,
          signer: false,
          optional: false,
          docs: []
        },
        {
          name: "issuer",
          writable: true,
          signer: true,
          optional: false,
          docs: []
        },
        {
          name: "system_program",
          writable: false,
          signer: false,
          optional: false,
          docs: [],
          address: "11111111111111111111111111111111"
        }
      ],
      docs: "Create a credential template from a credential type for issuing credentials",
      discriminator: [
        183,
        109,
        12,
        128,
        134,
        8,
        139,
        144
      ],
      args: [
        {
          name: "name",
          type: "string"
        },
        {
          name: "image_uri",
          type: "string"
        },
        {
          name: "crossmint_template_id",
          type: {
            option: "string"
          }
        }
      ]
    },
    create_credential_type: {
      name: "create_credential_type",
      expectedAccounts: [
        {
          name: "credential_type",
          pda: true
        },
        {
          name: "authority",
          pda: false
        },
        {
          name: "system_program",
          pda: false
        }
      ],
      accounts: [
        {
          name: "credential_type",
          writable: true,
          signer: false,
          optional: false,
          docs: [],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  99,
                  114,
                  101,
                  100,
                  101,
                  110,
                  116,
                  105,
                  97,
                  108,
                  95,
                  116,
                  121,
                  112,
                  101
                ]
              },
              {
                kind: "arg",
                path: "name"
              }
            ]
          }
        },
        {
          name: "authority",
          writable: true,
          signer: true,
          optional: false,
          docs: []
        },
        {
          name: "system_program",
          writable: false,
          signer: false,
          optional: false,
          docs: [],
          address: "11111111111111111111111111111111"
        }
      ],
      docs: "Create a new credential type (e.g., AgentIdentity, Reputation, JobCompletion) This is an admin-only operation typically done by governance/multisig.",
      discriminator: [
        211,
        208,
        67,
        175,
        20,
        248,
        8,
        227
      ],
      args: [
        {
          name: "name",
          type: "string"
        },
        {
          name: "kind",
          type: {
            defined: {
              name: "CredentialKind"
            }
          }
        },
        {
          name: "schema_uri",
          type: "string"
        },
        {
          name: "description",
          type: "string"
        }
      ]
    },
    create_did_document: {
      name: "create_did_document",
      expectedAccounts: [
        {
          name: "did_document",
          pda: true
        },
        {
          name: "controller",
          pda: false
        },
        {
          name: "system_program",
          pda: false
        },
        {
          name: "clock",
          pda: false
        }
      ],
      accounts: [
        {
          name: "did_document",
          writable: true,
          signer: false,
          optional: false,
          docs: [
            "DID document account with canonical PDA"
          ],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  100,
                  105,
                  100,
                  95,
                  100,
                  111,
                  99,
                  117,
                  109,
                  101,
                  110,
                  116
                ]
              },
              {
                kind: "account",
                path: "controller"
              }
            ]
          }
        },
        {
          name: "controller",
          writable: true,
          signer: true,
          optional: false,
          docs: [
            "Controller of the DID (owner)"
          ]
        },
        {
          name: "system_program",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "System program for account creation"
          ],
          address: "11111111111111111111111111111111"
        },
        {
          name: "clock",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "Clock sysvar for timestamp validation"
          ],
          address: "SysvarC1ock11111111111111111111111111111111"
        }
      ],
      docs: 'Create a new DID document for an agent or user  Initializes a W3C-compliant DID document following the did:sol method. The DID document can contain verification methods and service endpoints.  Parameters: - did_string: The DID string (e.g., "did:sol:devnet:HN7c...") - verification_methods: Initial verification methods (max 10) - service_endpoints: Initial service endpoints (max 5)',
      discriminator: [
        253,
        40,
        200,
        239,
        69,
        147,
        82,
        182
      ],
      args: [
        {
          name: "did_string",
          type: "string"
        },
        {
          name: "verification_methods",
          type: {
            vec: {
              defined: {
                name: "VerificationMethod"
              }
            }
          }
        },
        {
          name: "service_endpoints",
          type: {
            vec: {
              defined: {
                name: "ServiceEndpoint"
              }
            }
          }
        }
      ]
    },
    create_escrow: {
      name: "create_escrow",
      expectedAccounts: [
        {
          name: "escrow",
          pda: true
        },
        {
          name: "agent",
          pda: false
        },
        {
          name: "client_token_account",
          pda: false
        },
        {
          name: "escrow_vault",
          pda: false
        },
        {
          name: "token_mint",
          pda: false
        },
        {
          name: "client",
          pda: false
        },
        {
          name: "token_program",
          pda: false
        },
        {
          name: "system_program",
          pda: false
        }
      ],
      accounts: [
        {
          name: "escrow",
          writable: true,
          signer: false,
          optional: false,
          docs: [],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  103,
                  104,
                  111,
                  115,
                  116,
                  95,
                  112,
                  114,
                  111,
                  116,
                  101,
                  99,
                  116
                ]
              },
              {
                kind: "account",
                path: "client"
              },
              {
                kind: "arg",
                path: "escrow_id"
              }
            ]
          }
        },
        {
          name: "agent",
          writable: false,
          signer: false,
          optional: false,
          docs: []
        },
        {
          name: "client_token_account",
          writable: true,
          signer: false,
          optional: false,
          docs: []
        },
        {
          name: "escrow_vault",
          writable: true,
          signer: false,
          optional: false,
          docs: []
        },
        {
          name: "token_mint",
          writable: false,
          signer: false,
          optional: false,
          docs: []
        },
        {
          name: "client",
          writable: true,
          signer: true,
          optional: false,
          docs: []
        },
        {
          name: "token_program",
          writable: false,
          signer: false,
          optional: false,
          docs: [],
          address: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
        },
        {
          name: "system_program",
          writable: false,
          signer: false,
          optional: false,
          docs: [],
          address: "11111111111111111111111111111111"
        }
      ],
      docs: "Create a new escrow for agent service payment",
      discriminator: [
        253,
        215,
        165,
        116,
        36,
        108,
        68,
        80
      ],
      args: [
        {
          name: "escrow_id",
          type: "u64"
        },
        {
          name: "amount",
          type: "u64"
        },
        {
          name: "job_description",
          type: "string"
        },
        {
          name: "deadline",
          type: "i64"
        }
      ]
    },
    create_multisig: {
      name: "create_multisig",
      expectedAccounts: [
        {
          name: "multisig",
          pda: true
        },
        {
          name: "owner",
          pda: false
        },
        {
          name: "system_program",
          pda: false
        }
      ],
      accounts: [
        {
          name: "multisig",
          writable: true,
          signer: false,
          optional: false,
          docs: [],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  109,
                  117,
                  108,
                  116,
                  105,
                  115,
                  105,
                  103
                ]
              },
              {
                kind: "account",
                path: "owner"
              },
              {
                kind: "arg",
                path: "multisig_id"
              }
            ]
          }
        },
        {
          name: "owner",
          writable: true,
          signer: true,
          optional: false,
          docs: []
        },
        {
          name: "system_program",
          writable: false,
          signer: false,
          optional: false,
          docs: [],
          address: "11111111111111111111111111111111"
        }
      ],
      docs: "",
      discriminator: [
        148,
        146,
        240,
        10,
        226,
        215,
        167,
        174
      ],
      args: [
        {
          name: "multisig_id",
          type: "u64"
        },
        {
          name: "threshold",
          type: "u8"
        },
        {
          name: "signers",
          type: {
            vec: "pubkey"
          }
        },
        {
          name: "config",
          type: {
            defined: {
              name: "MultisigConfig"
            }
          }
        }
      ]
    },
    deactivate_agent: {
      name: "deactivate_agent",
      expectedAccounts: [
        {
          name: "agent_account",
          pda: true
        },
        {
          name: "signer",
          pda: false
        },
        {
          name: "clock",
          pda: false
        }
      ],
      accounts: [
        {
          name: "agent_account",
          writable: true,
          signer: false,
          optional: false,
          docs: [
            "Agent account with canonical PDA validation"
          ],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  97,
                  103,
                  101,
                  110,
                  116
                ]
              },
              {
                kind: "account",
                path: "signer"
              },
              {
                kind: "arg",
                path: "agent_id"
              }
            ]
          }
        },
        {
          name: "signer",
          writable: true,
          signer: true,
          optional: false,
          docs: [
            "Enhanced authority verification"
          ]
        },
        {
          name: "clock",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "Clock sysvar for rate limiting"
          ],
          address: "SysvarC1ock11111111111111111111111111111111"
        }
      ],
      docs: "",
      discriminator: [
        205,
        171,
        239,
        225,
        82,
        126,
        96,
        166
      ],
      args: [
        {
          name: "agent_id",
          type: "string"
        }
      ]
    },
    deactivate_credential_template: {
      name: "deactivate_credential_template",
      expectedAccounts: [
        {
          name: "credential_template",
          pda: false
        },
        {
          name: "issuer",
          pda: false
        }
      ],
      accounts: [
        {
          name: "credential_template",
          writable: true,
          signer: false,
          optional: false,
          docs: []
        },
        {
          name: "issuer",
          writable: true,
          signer: true,
          optional: false,
          docs: []
        }
      ],
      docs: "Deactivate a credential template (no new credentials can be issued from it)",
      discriminator: [
        177,
        8,
        195,
        104,
        56,
        34,
        84,
        162
      ],
      args: []
    },
    deactivate_credential_type: {
      name: "deactivate_credential_type",
      expectedAccounts: [
        {
          name: "credential_type",
          pda: false
        },
        {
          name: "authority",
          pda: false
        }
      ],
      accounts: [
        {
          name: "credential_type",
          writable: true,
          signer: false,
          optional: false,
          docs: []
        },
        {
          name: "authority",
          writable: true,
          signer: true,
          optional: false,
          docs: []
        }
      ],
      docs: "Deactivate a credential type (no new credentials can be issued)",
      discriminator: [
        110,
        174,
        221,
        244,
        36,
        206,
        60,
        237
      ],
      args: []
    },
    deactivate_did_document: {
      name: "deactivate_did_document",
      expectedAccounts: [
        {
          name: "did_document",
          pda: true
        },
        {
          name: "controller",
          pda: false
        },
        {
          name: "clock",
          pda: false
        }
      ],
      accounts: [
        {
          name: "did_document",
          writable: true,
          signer: false,
          optional: false,
          docs: [
            "DID document account with canonical PDA validation"
          ],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  100,
                  105,
                  100,
                  95,
                  100,
                  111,
                  99,
                  117,
                  109,
                  101,
                  110,
                  116
                ]
              },
              {
                kind: "account",
                path: "controller"
              }
            ]
          }
        },
        {
          name: "controller",
          writable: true,
          signer: true,
          optional: false,
          docs: [
            "Controller of the DID (must match document controller)"
          ]
        },
        {
          name: "clock",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "Clock sysvar for timestamp validation"
          ],
          address: "SysvarC1ock11111111111111111111111111111111"
        }
      ],
      docs: "Deactivate a DID document  Permanently deactivates the DID document. This operation is irreversible. Only the controller can deactivate their DID.",
      discriminator: [
        77,
        13,
        56,
        161,
        67,
        155,
        206,
        119
      ],
      args: []
    },
    enable_protocol_fees: {
      name: "enable_protocol_fees",
      expectedAccounts: [
        {
          name: "config",
          pda: true
        },
        {
          name: "authority",
          pda: false
        }
      ],
      accounts: [
        {
          name: "config",
          writable: true,
          signer: false,
          optional: false,
          docs: [],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  112,
                  114,
                  111,
                  116,
                  111,
                  99,
                  111,
                  108,
                  95,
                  99,
                  111,
                  110,
                  102,
                  105,
                  103
                ]
              }
            ]
          }
        },
        {
          name: "authority",
          writable: false,
          signer: true,
          optional: false,
          docs: []
        }
      ],
      docs: "Enable production fees (authority only)  Activates the full fee structure for mainnet: - Escrow: 0.5% (80% Treasury, 20% Buyback) - Agent Registration: 0.01 SOL - Marketplace Listing: 0.001 SOL - Dispute Resolution: 1%",
      discriminator: [
        9,
        115,
        79,
        19,
        158,
        209,
        221,
        38
      ],
      args: []
    },
    file_dispute: {
      name: "file_dispute",
      expectedAccounts: [
        {
          name: "escrow",
          pda: true
        },
        {
          name: "client",
          pda: false
        }
      ],
      accounts: [
        {
          name: "escrow",
          writable: true,
          signer: false,
          optional: false,
          docs: [],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  103,
                  104,
                  111,
                  115,
                  116,
                  95,
                  112,
                  114,
                  111,
                  116,
                  101,
                  99,
                  116
                ]
              },
              {
                kind: "account",
                path: "escrow.client",
                account: "GhostProtectEscrow"
              },
              {
                kind: "account",
                path: "escrow.escrow_id",
                account: "GhostProtectEscrow"
              }
            ]
          }
        },
        {
          name: "client",
          writable: false,
          signer: true,
          optional: false,
          docs: []
        }
      ],
      docs: "Client files a dispute on escrow",
      discriminator: [
        210,
        63,
        221,
        114,
        212,
        97,
        195,
        156
      ],
      args: [
        {
          name: "reason",
          type: "string"
        }
      ]
    },
    generate_compliance_report: {
      name: "generate_compliance_report",
      expectedAccounts: [
        {
          name: "report",
          pda: true
        },
        {
          name: "audit_trail",
          pda: false
        },
        {
          name: "authority",
          pda: false
        },
        {
          name: "system_program",
          pda: false
        }
      ],
      accounts: [
        {
          name: "report",
          writable: true,
          signer: false,
          optional: false,
          docs: [],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  99,
                  111,
                  109,
                  112,
                  108,
                  105,
                  97,
                  110,
                  99,
                  101,
                  95,
                  114,
                  101,
                  112,
                  111,
                  114,
                  116
                ]
              },
              {
                kind: "arg",
                path: "report_id"
              }
            ]
          }
        },
        {
          name: "audit_trail",
          writable: true,
          signer: false,
          optional: false,
          docs: [
            "Audit trail for the entity"
          ]
        },
        {
          name: "authority",
          writable: true,
          signer: true,
          optional: false,
          docs: []
        },
        {
          name: "system_program",
          writable: false,
          signer: false,
          optional: false,
          docs: [],
          address: "11111111111111111111111111111111"
        }
      ],
      docs: "",
      discriminator: [
        213,
        97,
        79,
        234,
        22,
        228,
        14,
        32
      ],
      args: [
        {
          name: "report_id",
          type: "u64"
        },
        {
          name: "report_type",
          type: {
            defined: {
              name: "ReportType"
            }
          }
        },
        {
          name: "date_range_start",
          type: "i64"
        },
        {
          name: "date_range_end",
          type: "i64"
        }
      ]
    },
    init_reentrancy_guard: {
      name: "init_reentrancy_guard",
      expectedAccounts: [
        {
          name: "reentrancy_guard",
          pda: true
        },
        {
          name: "authority",
          pda: false
        },
        {
          name: "system_program",
          pda: false
        }
      ],
      accounts: [
        {
          name: "reentrancy_guard",
          writable: true,
          signer: false,
          optional: false,
          docs: [],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  114,
                  101,
                  101,
                  110,
                  116,
                  114,
                  97,
                  110,
                  99,
                  121,
                  95,
                  103,
                  117,
                  97,
                  114,
                  100
                ]
              }
            ]
          }
        },
        {
          name: "authority",
          writable: true,
          signer: true,
          optional: false,
          docs: []
        },
        {
          name: "system_program",
          writable: false,
          signer: false,
          optional: false,
          docs: [],
          address: "11111111111111111111111111111111"
        }
      ],
      docs: "Initialize the global reentrancy guard PDA This must be called once by a program admin before any reentrancy-protected instructions can be used",
      discriminator: [
        156,
        109,
        115,
        85,
        12,
        60,
        245,
        99
      ],
      args: []
    },
    initialize_audit_trail: {
      name: "initialize_audit_trail",
      expectedAccounts: [
        {
          name: "audit_trail",
          pda: true
        },
        {
          name: "entity",
          pda: false
        },
        {
          name: "authority",
          pda: false
        },
        {
          name: "system_program",
          pda: false
        }
      ],
      accounts: [
        {
          name: "audit_trail",
          writable: true,
          signer: false,
          optional: false,
          docs: [],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  97,
                  117,
                  100,
                  105,
                  116,
                  95,
                  116,
                  114,
                  97,
                  105,
                  108
                ]
              },
              {
                kind: "account",
                path: "entity"
              }
            ]
          }
        },
        {
          name: "entity",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "Entity being audited"
          ]
        },
        {
          name: "authority",
          writable: true,
          signer: true,
          optional: false,
          docs: []
        },
        {
          name: "system_program",
          writable: false,
          signer: false,
          optional: false,
          docs: [],
          address: "11111111111111111111111111111111"
        }
      ],
      docs: "",
      discriminator: [
        145,
        182,
        236,
        249,
        212,
        17,
        175,
        161
      ],
      args: [
        {
          name: "entity_type",
          type: "string"
        },
        {
          name: "config",
          type: {
            defined: {
              name: "AuditConfig"
            }
          }
        }
      ]
    },
    initialize_governance_proposal: {
      name: "initialize_governance_proposal",
      expectedAccounts: [
        {
          name: "proposal",
          pda: true
        },
        {
          name: "proposer",
          pda: false
        },
        {
          name: "system_program",
          pda: false
        }
      ],
      accounts: [
        {
          name: "proposal",
          writable: true,
          signer: false,
          optional: false,
          docs: [],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  103,
                  111,
                  118,
                  101,
                  114,
                  110,
                  97,
                  110,
                  99,
                  101,
                  95,
                  112,
                  114,
                  111,
                  112,
                  111,
                  115,
                  97,
                  108
                ]
              },
              {
                kind: "arg",
                path: "proposal_id"
              }
            ]
          }
        },
        {
          name: "proposer",
          writable: true,
          signer: true,
          optional: false,
          docs: []
        },
        {
          name: "system_program",
          writable: false,
          signer: false,
          optional: false,
          docs: [],
          address: "11111111111111111111111111111111"
        }
      ],
      docs: "",
      discriminator: [
        137,
        84,
        234,
        206,
        17,
        58,
        54,
        215
      ],
      args: [
        {
          name: "proposal_id",
          type: "u64"
        },
        {
          name: "title",
          type: "string"
        },
        {
          name: "description",
          type: "string"
        },
        {
          name: "proposal_type",
          type: {
            defined: {
              name: "ProposalType"
            }
          }
        },
        {
          name: "execution_params",
          type: {
            defined: {
              name: "ExecutionParams"
            }
          }
        }
      ]
    },
    initialize_protocol_config: {
      name: "initialize_protocol_config",
      expectedAccounts: [
        {
          name: "config",
          pda: true
        },
        {
          name: "authority",
          pda: false
        },
        {
          name: "treasury",
          pda: false
        },
        {
          name: "buyback_pool",
          pda: false
        },
        {
          name: "moderator_pool",
          pda: false
        },
        {
          name: "system_program",
          pda: false
        }
      ],
      accounts: [
        {
          name: "config",
          writable: true,
          signer: false,
          optional: false,
          docs: [],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  112,
                  114,
                  111,
                  116,
                  111,
                  99,
                  111,
                  108,
                  95,
                  99,
                  111,
                  110,
                  102,
                  105,
                  103
                ]
              }
            ]
          }
        },
        {
          name: "authority",
          writable: true,
          signer: true,
          optional: false,
          docs: [
            "Authority who will control the config (typically DAO or multisig)"
          ]
        },
        {
          name: "treasury",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "Treasury wallet to receive protocol fees"
          ]
        },
        {
          name: "buyback_pool",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "Buyback pool wallet for token buybacks"
          ]
        },
        {
          name: "moderator_pool",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "Moderator pool for dispute fees"
          ]
        },
        {
          name: "system_program",
          writable: false,
          signer: false,
          optional: false,
          docs: [],
          address: "11111111111111111111111111111111"
        }
      ],
      docs: "Initialize the global protocol configuration  Sets up fee infrastructure with all fees initially disabled (set to 0). Fees will be enabled via governance after mainnet deployment.  NOTE: Fee structure is in place but set to 0 until mainnet.",
      discriminator: [
        28,
        50,
        43,
        233,
        244,
        98,
        123,
        118
      ],
      args: []
    },
    initialize_rbac_config: {
      name: "initialize_rbac_config",
      expectedAccounts: [
        {
          name: "rbac_config",
          pda: true
        },
        {
          name: "authority",
          pda: false
        },
        {
          name: "system_program",
          pda: false
        }
      ],
      accounts: [
        {
          name: "rbac_config",
          writable: true,
          signer: false,
          optional: false,
          docs: [],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  114,
                  98,
                  97,
                  99,
                  95,
                  99,
                  111,
                  110,
                  102,
                  105,
                  103
                ]
              },
              {
                kind: "account",
                path: "authority"
              }
            ]
          }
        },
        {
          name: "authority",
          writable: true,
          signer: true,
          optional: false,
          docs: []
        },
        {
          name: "system_program",
          writable: false,
          signer: false,
          optional: false,
          docs: [],
          address: "11111111111111111111111111111111"
        }
      ],
      docs: "",
      discriminator: [
        215,
        68,
        129,
        228,
        237,
        165,
        0,
        240
      ],
      args: [
        {
          name: "initial_roles",
          type: {
            vec: {
              defined: {
                name: "Role"
              }
            }
          }
        }
      ]
    },
    initialize_reputation_metrics: {
      name: "initialize_reputation_metrics",
      expectedAccounts: [
        {
          name: "reputation_metrics",
          pda: true
        },
        {
          name: "agent",
          pda: false
        },
        {
          name: "authority",
          pda: false
        },
        {
          name: "system_program",
          pda: false
        },
        {
          name: "clock",
          pda: false
        }
      ],
      accounts: [
        {
          name: "reputation_metrics",
          writable: true,
          signer: false,
          optional: false,
          docs: [
            "Reputation metrics account"
          ],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  114,
                  101,
                  112,
                  117,
                  116,
                  97,
                  116,
                  105,
                  111,
                  110,
                  95,
                  109,
                  101,
                  116,
                  114,
                  105,
                  99,
                  115
                ]
              },
              {
                kind: "account",
                path: "agent"
              }
            ]
          }
        },
        {
          name: "agent",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "Agent account"
          ]
        },
        {
          name: "authority",
          writable: true,
          signer: true,
          optional: false,
          docs: [
            "Authority (agent owner)"
          ]
        },
        {
          name: "system_program",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "System program"
          ],
          address: "11111111111111111111111111111111"
        },
        {
          name: "clock",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "Clock for timestamps"
          ],
          address: "SysvarC1ock11111111111111111111111111111111"
        }
      ],
      docs: "Initialize reputation metrics for an agent  Creates a new reputation tracking account that monitors: - Payment success/failure rates - Service ratings from clients - Response time performance - Dispute resolution history",
      discriminator: [
        228,
        11,
        207,
        44,
        52,
        188,
        169,
        237
      ],
      args: []
    },
    initialize_staking_config: {
      name: "initialize_staking_config",
      expectedAccounts: [
        {
          name: "staking_config",
          pda: true
        },
        {
          name: "authority",
          pda: false
        },
        {
          name: "system_program",
          pda: false
        }
      ],
      accounts: [
        {
          name: "staking_config",
          writable: true,
          signer: false,
          optional: false,
          docs: [],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  115,
                  116,
                  97,
                  107,
                  105,
                  110,
                  103,
                  95,
                  99,
                  111,
                  110,
                  102,
                  105,
                  103
                ]
              }
            ]
          }
        },
        {
          name: "authority",
          writable: true,
          signer: true,
          optional: false,
          docs: []
        },
        {
          name: "system_program",
          writable: false,
          signer: false,
          optional: false,
          docs: [],
          address: "11111111111111111111111111111111"
        }
      ],
      docs: "Initialize GHOST token staking configuration (admin only)",
      discriminator: [
        78,
        164,
        6,
        115,
        206,
        48,
        168,
        105
      ],
      args: [
        {
          name: "min_stake",
          type: "u64"
        },
        {
          name: "treasury",
          type: "pubkey"
        }
      ]
    },
    issue_credential: {
      name: "issue_credential",
      expectedAccounts: [
        {
          name: "credential",
          pda: true
        },
        {
          name: "credential_template",
          pda: false
        },
        {
          name: "credential_type",
          pda: false
        },
        {
          name: "subject",
          pda: false
        },
        {
          name: "issuer",
          pda: false
        },
        {
          name: "system_program",
          pda: false
        }
      ],
      accounts: [
        {
          name: "credential",
          writable: true,
          signer: false,
          optional: false,
          docs: [],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  99,
                  114,
                  101,
                  100,
                  101,
                  110,
                  116,
                  105,
                  97,
                  108
                ]
              },
              {
                kind: "account",
                path: "credential_template"
              },
              {
                kind: "account",
                path: "subject"
              },
              {
                kind: "arg",
                path: "credential_id"
              }
            ]
          }
        },
        {
          name: "credential_template",
          writable: true,
          signer: false,
          optional: false,
          docs: []
        },
        {
          name: "credential_type",
          writable: true,
          signer: false,
          optional: false,
          docs: []
        },
        {
          name: "subject",
          writable: false,
          signer: false,
          optional: false,
          docs: []
        },
        {
          name: "issuer",
          writable: true,
          signer: true,
          optional: false,
          docs: []
        },
        {
          name: "system_program",
          writable: false,
          signer: false,
          optional: false,
          docs: [],
          address: "11111111111111111111111111111111"
        }
      ],
      docs: "Issue a new credential to a subject The subject_data is stored off-chain; only the hash is stored on-chain.",
      discriminator: [
        255,
        193,
        171,
        224,
        68,
        171,
        194,
        87
      ],
      args: [
        {
          name: "credential_id",
          type: "string"
        },
        {
          name: "subject_data_hash",
          type: {
            array: [
              "u8",
              32
            ]
          }
        },
        {
          name: "subject_data_uri",
          type: "string"
        },
        {
          name: "expires_at",
          type: {
            option: "i64"
          }
        },
        {
          name: "source_account",
          type: {
            option: "pubkey"
          }
        }
      ]
    },
    manage_agent_status: {
      name: "manage_agent_status",
      expectedAccounts: [
        {
          name: "agent",
          pda: true
        },
        {
          name: "owner",
          pda: false
        },
        {
          name: "clock",
          pda: false
        }
      ],
      accounts: [
        {
          name: "agent",
          writable: true,
          signer: false,
          optional: false,
          docs: [
            "Agent account with strict validation"
          ],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  97,
                  103,
                  101,
                  110,
                  116
                ]
              },
              {
                kind: "account",
                path: "owner"
              }
            ]
          }
        },
        {
          name: "owner",
          writable: false,
          signer: true,
          optional: false,
          docs: [
            "Owner authority"
          ]
        },
        {
          name: "clock",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "Clock sysvar for timestamp validation"
          ],
          address: "SysvarC1ock11111111111111111111111111111111"
        }
      ],
      docs: "",
      discriminator: [
        164,
        219,
        91,
        38,
        45,
        31,
        33,
        47
      ],
      args: [
        {
          name: "new_status",
          type: "bool"
        }
      ]
    },
    record_payai_payment: {
      name: "record_payai_payment",
      expectedAccounts: [
        {
          name: "reputation_metrics",
          pda: true
        },
        {
          name: "agent",
          pda: false
        },
        {
          name: "authority",
          pda: false
        },
        {
          name: "clock",
          pda: false
        }
      ],
      accounts: [
        {
          name: "reputation_metrics",
          writable: true,
          signer: false,
          optional: false,
          docs: [
            "Reputation metrics account"
          ],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  114,
                  101,
                  112,
                  117,
                  116,
                  97,
                  116,
                  105,
                  111,
                  110,
                  95,
                  109,
                  101,
                  116,
                  114,
                  105,
                  99,
                  115
                ]
              },
              {
                kind: "account",
                path: "agent"
              }
            ]
          }
        },
        {
          name: "agent",
          writable: true,
          signer: false,
          optional: false,
          docs: [
            "Agent account"
          ]
        },
        {
          name: "authority",
          writable: false,
          signer: true,
          optional: false,
          docs: [
            "Authority (can be the payment verifier or agent owner)"
          ]
        },
        {
          name: "clock",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "Clock for timestamps"
          ],
          address: "SysvarC1ock11111111111111111111111111111111"
        }
      ],
      docs: "Record a PayAI payment transaction for reputation tracking  Consumes payment data from PayAI protocol to update agent reputation. This does NOT facilitate payments - it only tracks them for reputation.  Parameters: - payment_signature: PayAI transaction signature - amount: Payment amount in lamports - response_time_ms: Service response time - success: Whether payment completed successfully",
      discriminator: [
        165,
        202,
        159,
        139,
        65,
        65,
        36,
        163
      ],
      args: [
        {
          name: "payment_signature",
          type: "string"
        },
        {
          name: "amount",
          type: "u64"
        },
        {
          name: "response_time_ms",
          type: "u64"
        },
        {
          name: "success",
          type: "bool"
        }
      ]
    },
    register_agent: {
      name: "register_agent",
      expectedAccounts: [
        {
          name: "agent_account",
          pda: true
        },
        {
          name: "staking_account",
          pda: true
        },
        {
          name: "signer",
          pda: false
        },
        {
          name: "system_program",
          pda: false
        },
        {
          name: "clock",
          pda: false
        }
      ],
      accounts: [
        {
          name: "agent_account",
          writable: true,
          signer: false,
          optional: false,
          docs: [
            "Agent account with enhanced 2025 PDA security"
          ],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  97,
                  103,
                  101,
                  110,
                  116
                ]
              },
              {
                kind: "account",
                path: "signer"
              },
              {
                kind: "arg",
                path: "agent_id"
              }
            ]
          }
        },
        {
          name: "staking_account",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "Staking account - REQUIRED for Sybil resistance (must have >= 1K GHOST staked)"
          ],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  115,
                  116,
                  97,
                  107,
                  105,
                  110,
                  103
                ]
              },
              {
                kind: "account",
                path: "signer"
              }
            ]
          }
        },
        {
          name: "signer",
          writable: true,
          signer: true,
          optional: false,
          docs: [
            "User registry with enhanced validation",
            "Authority with enhanced verification"
          ]
        },
        {
          name: "system_program",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "System program for account creation"
          ],
          address: "11111111111111111111111111111111"
        },
        {
          name: "clock",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "Clock sysvar for timestamp validation"
          ],
          address: "SysvarC1ock11111111111111111111111111111111"
        }
      ],
      docs: "",
      discriminator: [
        135,
        157,
        66,
        195,
        2,
        113,
        175,
        30
      ],
      args: [
        {
          name: "agent_type",
          type: "u8"
        },
        {
          name: "name",
          type: "string"
        },
        {
          name: "description",
          type: "string"
        },
        {
          name: "metadata_uri",
          type: "string"
        },
        {
          name: "_agent_id",
          type: "string"
        },
        {
          name: "pricing_model",
          type: {
            defined: {
              name: "PricingModel"
            }
          }
        }
      ]
    },
    register_agent_compressed: {
      name: "register_agent_compressed",
      expectedAccounts: [
        {
          name: "tree_authority",
          pda: true
        },
        {
          name: "merkle_tree",
          pda: false
        },
        {
          name: "user_registry",
          pda: true
        },
        {
          name: "signer",
          pda: false
        },
        {
          name: "compression_program",
          pda: false
        },
        {
          name: "log_wrapper",
          pda: false
        },
        {
          name: "system_program",
          pda: false
        },
        {
          name: "clock",
          pda: false
        }
      ],
      accounts: [
        {
          name: "tree_authority",
          writable: true,
          signer: false,
          optional: false,
          docs: [
            "Tree authority PDA that manages the compressed Agent tree"
          ],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  97,
                  103,
                  101,
                  110,
                  116,
                  95,
                  116,
                  114,
                  101,
                  101,
                  95,
                  99,
                  111,
                  110,
                  102,
                  105,
                  103
                ]
              },
              {
                kind: "account",
                path: "signer"
              }
            ]
          }
        },
        {
          name: "merkle_tree",
          writable: true,
          signer: false,
          optional: false,
          docs: [
            "The Merkle tree account that stores compressed Agent data"
          ]
        },
        {
          name: "user_registry",
          writable: true,
          signer: false,
          optional: false,
          docs: [
            "User registry with enhanced validation"
          ],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  117,
                  115,
                  101,
                  114,
                  95,
                  114,
                  101,
                  103,
                  105,
                  115,
                  116,
                  114,
                  121
                ]
              },
              {
                kind: "account",
                path: "signer"
              }
            ]
          }
        },
        {
          name: "signer",
          writable: true,
          signer: true,
          optional: false,
          docs: [
            "Authority with enhanced verification"
          ]
        },
        {
          name: "compression_program",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "SPL Account Compression program"
          ],
          address: "cmtDvXumGCrqC1Age74AVPhSRVXJMd8PJS91L8KbNCK"
        },
        {
          name: "log_wrapper",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "SPL Noop program for logging"
          ],
          address: "noopb9bkMVfRPU8AsbpTUg8AQkHtKwMYZiFUjNRtMmV"
        },
        {
          name: "system_program",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "System program for account creation"
          ],
          address: "11111111111111111111111111111111"
        },
        {
          name: "clock",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "Clock sysvar for timestamps"
          ],
          address: "SysvarC1ock11111111111111111111111111111111"
        }
      ],
      docs: "Register Agent using ZK compression (solves error 2006 with 5000x cost reduction)",
      discriminator: [
        15,
        6,
        94,
        55,
        65,
        80,
        123,
        248
      ],
      args: [
        {
          name: "agent_type",
          type: "u8"
        },
        {
          name: "metadata_uri",
          type: "string"
        },
        {
          name: "agent_id",
          type: "string"
        },
        {
          name: "name",
          type: "string"
        },
        {
          name: "description",
          type: "string"
        },
        {
          name: "pricing_model",
          type: {
            defined: {
              name: "PricingModel"
            }
          }
        }
      ]
    },
    reset_reentrancy_guard: {
      name: "reset_reentrancy_guard",
      expectedAccounts: [
        {
          name: "reentrancy_guard",
          pda: true
        },
        {
          name: "authority",
          pda: false
        }
      ],
      accounts: [
        {
          name: "reentrancy_guard",
          writable: true,
          signer: false,
          optional: false,
          docs: [],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  114,
                  101,
                  101,
                  110,
                  116,
                  114,
                  97,
                  110,
                  99,
                  121,
                  95,
                  103,
                  117,
                  97,
                  114,
                  100
                ]
              }
            ]
          }
        },
        {
          name: "authority",
          writable: true,
          signer: true,
          optional: false,
          docs: []
        }
      ],
      docs: "Reset a stuck reentrancy guard (admin only) Use this to recover from stuck states after failed transactions",
      discriminator: [
        93,
        74,
        168,
        125,
        46,
        153,
        9,
        255
      ],
      args: []
    },
    resolve_did_document: {
      name: "resolve_did_document",
      expectedAccounts: [
        {
          name: "did_document",
          pda: true
        },
        {
          name: "did_controller",
          pda: false
        }
      ],
      accounts: [
        {
          name: "did_document",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "DID document account"
          ],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  100,
                  105,
                  100,
                  95,
                  100,
                  111,
                  99,
                  117,
                  109,
                  101,
                  110,
                  116
                ]
              },
              {
                kind: "account",
                path: "did_controller"
              }
            ]
          }
        },
        {
          name: "did_controller",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "Controller public key (used for PDA derivation)"
          ]
        }
      ],
      docs: "Resolve a DID document (read-only)  Returns the DID document data for off-chain resolution. This instruction exists for compatibility with standard DID resolution flows.",
      discriminator: [
        168,
        180,
        218,
        211,
        184,
        19,
        102,
        12
      ],
      args: []
    },
    revoke_authorization: {
      name: "revoke_authorization",
      expectedAccounts: [
        {
          name: "agent",
          pda: false
        },
        {
          name: "authorization",
          pda: true
        },
        {
          name: "authority",
          pda: false
        }
      ],
      accounts: [
        {
          name: "agent",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "Agent revoking authorization"
          ]
        },
        {
          name: "authorization",
          writable: true,
          signer: false,
          optional: false,
          docs: [
            "Authorization account (PDA)"
          ],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  97,
                  103,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104
                ]
              },
              {
                kind: "account",
                path: "agent"
              },
              {
                kind: "account",
                path: "authorization.authorized_source",
                account: "AgentReputationAuth"
              },
              {
                kind: "arg",
                path: "_nonce"
              }
            ]
          }
        },
        {
          name: "authority",
          writable: false,
          signer: true,
          optional: false,
          docs: [
            "Authority (agent owner)"
          ]
        }
      ],
      docs: "Revoke agent authorization  Allows an agent to revoke a previously granted authorization. Once revoked, the facilitator can no longer update reputation.  Parameters: - nonce: Optional nonce identifying the specific authorization to revoke",
      discriminator: [
        222,
        179,
        207,
        59,
        191,
        78,
        24,
        248
      ],
      args: [
        {
          name: "nonce",
          type: {
            option: "string"
          }
        }
      ]
    },
    revoke_credential: {
      name: "revoke_credential",
      expectedAccounts: [
        {
          name: "credential",
          pda: false
        },
        {
          name: "issuer",
          pda: false
        }
      ],
      accounts: [
        {
          name: "credential",
          writable: true,
          signer: false,
          optional: false,
          docs: []
        },
        {
          name: "issuer",
          writable: true,
          signer: true,
          optional: false,
          docs: []
        }
      ],
      docs: "Revoke an issued credential Only the original issuer can revoke.",
      discriminator: [
        38,
        123,
        95,
        95,
        223,
        158,
        169,
        87
      ],
      args: []
    },
    slash_stake: {
      name: "slash_stake",
      expectedAccounts: [
        {
          name: "staking_account",
          pda: true
        },
        {
          name: "staking_config",
          pda: true
        },
        {
          name: "staking_vault",
          pda: true
        },
        {
          name: "treasury",
          pda: false
        },
        {
          name: "authority",
          pda: false
        },
        {
          name: "token_program",
          pda: false
        }
      ],
      accounts: [
        {
          name: "staking_account",
          writable: true,
          signer: false,
          optional: false,
          docs: [],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  115,
                  116,
                  97,
                  107,
                  105,
                  110,
                  103
                ]
              },
              {
                kind: "arg",
                path: "owner"
              }
            ]
          }
        },
        {
          name: "staking_config",
          writable: false,
          signer: false,
          optional: false,
          docs: [],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  115,
                  116,
                  97,
                  107,
                  105,
                  110,
                  103,
                  95,
                  99,
                  111,
                  110,
                  102,
                  105,
                  103
                ]
              }
            ]
          }
        },
        {
          name: "staking_vault",
          writable: true,
          signer: false,
          optional: false,
          docs: [],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  115,
                  116,
                  97,
                  107,
                  105,
                  110,
                  103,
                  95,
                  118,
                  97,
                  117,
                  108,
                  116
                ]
              },
              {
                kind: "account",
                path: "staking_config"
              }
            ]
          }
        },
        {
          name: "treasury",
          writable: true,
          signer: false,
          optional: false,
          docs: []
        },
        {
          name: "authority",
          writable: false,
          signer: true,
          optional: false,
          docs: []
        },
        {
          name: "token_program",
          writable: false,
          signer: false,
          optional: false,
          docs: [],
          address: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
        }
      ],
      docs: "Slash staked tokens (admin only, for fraud/disputes)",
      discriminator: [
        190,
        242,
        137,
        27,
        41,
        18,
        233,
        37
      ],
      args: [
        {
          name: "owner",
          type: "pubkey"
        },
        {
          name: "reason",
          type: {
            defined: {
              name: "SlashReason"
            }
          }
        },
        {
          name: "custom_amount",
          type: {
            option: "u64"
          }
        }
      ]
    },
    stake_ghost: {
      name: "stake_ghost",
      expectedAccounts: [
        {
          name: "staking_account",
          pda: true
        },
        {
          name: "owner_token_account",
          pda: false
        },
        {
          name: "staking_vault",
          pda: true
        },
        {
          name: "staking_config",
          pda: false
        },
        {
          name: "ghost_mint",
          pda: false
        },
        {
          name: "owner",
          pda: false
        },
        {
          name: "token_program",
          pda: false
        },
        {
          name: "system_program",
          pda: false
        },
        {
          name: "rent",
          pda: false
        }
      ],
      accounts: [
        {
          name: "staking_account",
          writable: true,
          signer: false,
          optional: false,
          docs: [],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  115,
                  116,
                  97,
                  107,
                  105,
                  110,
                  103
                ]
              },
              {
                kind: "account",
                path: "owner"
              }
            ]
          }
        },
        {
          name: "owner_token_account",
          writable: true,
          signer: false,
          optional: false,
          docs: []
        },
        {
          name: "staking_vault",
          writable: true,
          signer: false,
          optional: false,
          docs: [
            "Staking vault to hold all staked GHOST tokens",
            "Automatically initialized on first stake using init_if_needed"
          ],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  115,
                  116,
                  97,
                  107,
                  105,
                  110,
                  103,
                  95,
                  118,
                  97,
                  117,
                  108,
                  116
                ]
              },
              {
                kind: "account",
                path: "staking_config"
              }
            ]
          }
        },
        {
          name: "staking_config",
          writable: false,
          signer: false,
          optional: false,
          docs: []
        },
        {
          name: "ghost_mint",
          writable: false,
          signer: false,
          optional: false,
          docs: []
        },
        {
          name: "owner",
          writable: true,
          signer: true,
          optional: false,
          docs: []
        },
        {
          name: "token_program",
          writable: false,
          signer: false,
          optional: false,
          docs: [],
          address: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
        },
        {
          name: "system_program",
          writable: false,
          signer: false,
          optional: false,
          docs: [],
          address: "11111111111111111111111111111111"
        },
        {
          name: "rent",
          writable: false,
          signer: false,
          optional: false,
          docs: [],
          address: "SysvarRent111111111111111111111111111111111"
        }
      ],
      docs: "Stake GHOST tokens to boost agent reputation",
      discriminator: [
        5,
        196,
        24,
        54,
        196,
        56,
        173,
        191
      ],
      args: [
        {
          name: "amount",
          type: "u64"
        },
        {
          name: "lock_duration",
          type: "i64"
        }
      ]
    },
    submit_delivery: {
      name: "submit_delivery",
      expectedAccounts: [
        {
          name: "escrow",
          pda: true
        },
        {
          name: "agent",
          pda: false
        },
        {
          name: "agent_owner",
          pda: false
        }
      ],
      accounts: [
        {
          name: "escrow",
          writable: true,
          signer: false,
          optional: false,
          docs: [],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  103,
                  104,
                  111,
                  115,
                  116,
                  95,
                  112,
                  114,
                  111,
                  116,
                  101,
                  99,
                  116
                ]
              },
              {
                kind: "account",
                path: "escrow.client",
                account: "GhostProtectEscrow"
              },
              {
                kind: "account",
                path: "escrow.escrow_id",
                account: "GhostProtectEscrow"
              }
            ]
          }
        },
        {
          name: "agent",
          writable: false,
          signer: false,
          optional: false,
          docs: []
        },
        {
          name: "agent_owner",
          writable: false,
          signer: true,
          optional: false,
          docs: []
        }
      ],
      docs: "Agent submits work delivery proof",
      discriminator: [
        217,
        177,
        33,
        54,
        136,
        185,
        123,
        96
      ],
      args: [
        {
          name: "delivery_proof",
          type: "string"
        }
      ]
    },
    submit_service_rating: {
      name: "submit_service_rating",
      expectedAccounts: [
        {
          name: "reputation_metrics",
          pda: true
        },
        {
          name: "agent",
          pda: false
        },
        {
          name: "client",
          pda: false
        },
        {
          name: "clock",
          pda: false
        }
      ],
      accounts: [
        {
          name: "reputation_metrics",
          writable: true,
          signer: false,
          optional: false,
          docs: [
            "Reputation metrics account"
          ],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  114,
                  101,
                  112,
                  117,
                  116,
                  97,
                  116,
                  105,
                  111,
                  110,
                  95,
                  109,
                  101,
                  116,
                  114,
                  105,
                  99,
                  115
                ]
              },
              {
                kind: "account",
                path: "agent"
              }
            ]
          }
        },
        {
          name: "agent",
          writable: true,
          signer: false,
          optional: false,
          docs: [
            "Agent account"
          ]
        },
        {
          name: "client",
          writable: false,
          signer: true,
          optional: false,
          docs: [
            "Client submitting the rating"
          ]
        },
        {
          name: "clock",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "Clock for timestamps"
          ],
          address: "SysvarC1ock11111111111111111111111111111111"
        }
      ],
      docs: "Submit a service rating after a completed transaction  Allows clients to rate agent service quality (1-5 scale). Ratings are factored into the overall reputation score calculation.  Parameters: - rating: Service rating from 1 (poor) to 5 (excellent) - payment_signature: Associated PayAI transaction signature",
      discriminator: [
        23,
        160,
        228,
        88,
        168,
        145,
        129,
        19
      ],
      args: [
        {
          name: "rating",
          type: "u8"
        },
        {
          name: "payment_signature",
          type: "string"
        }
      ]
    },
    unstake_ghost: {
      name: "unstake_ghost",
      expectedAccounts: [
        {
          name: "staking_account",
          pda: true
        },
        {
          name: "staking_config",
          pda: true
        },
        {
          name: "staking_vault",
          pda: true
        },
        {
          name: "owner_token_account",
          pda: false
        },
        {
          name: "owner",
          pda: false
        },
        {
          name: "token_program",
          pda: false
        }
      ],
      accounts: [
        {
          name: "staking_account",
          writable: true,
          signer: false,
          optional: false,
          docs: [],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  115,
                  116,
                  97,
                  107,
                  105,
                  110,
                  103
                ]
              },
              {
                kind: "account",
                path: "owner"
              }
            ]
          }
        },
        {
          name: "staking_config",
          writable: false,
          signer: false,
          optional: false,
          docs: [],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  115,
                  116,
                  97,
                  107,
                  105,
                  110,
                  103,
                  95,
                  99,
                  111,
                  110,
                  102,
                  105,
                  103
                ]
              }
            ]
          }
        },
        {
          name: "staking_vault",
          writable: true,
          signer: false,
          optional: false,
          docs: [],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  115,
                  116,
                  97,
                  107,
                  105,
                  110,
                  103,
                  95,
                  118,
                  97,
                  117,
                  108,
                  116
                ]
              },
              {
                kind: "account",
                path: "staking_config"
              }
            ]
          }
        },
        {
          name: "owner_token_account",
          writable: true,
          signer: false,
          optional: false,
          docs: []
        },
        {
          name: "owner",
          writable: true,
          signer: true,
          optional: false,
          docs: []
        },
        {
          name: "token_program",
          writable: false,
          signer: false,
          optional: false,
          docs: [],
          address: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
        }
      ],
      docs: "Unstake GHOST tokens after lock period expires",
      discriminator: [
        252,
        101,
        172,
        252,
        1,
        4,
        12,
        116
      ],
      args: []
    },
    update_agent: {
      name: "update_agent",
      expectedAccounts: [
        {
          name: "agent_account",
          pda: true
        },
        {
          name: "signer",
          pda: false
        },
        {
          name: "clock",
          pda: false
        }
      ],
      accounts: [
        {
          name: "agent_account",
          writable: true,
          signer: false,
          optional: false,
          docs: [
            "Agent account with canonical PDA validation"
          ],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  97,
                  103,
                  101,
                  110,
                  116
                ]
              },
              {
                kind: "account",
                path: "signer"
              },
              {
                kind: "arg",
                path: "agent_id"
              }
            ]
          }
        },
        {
          name: "signer",
          writable: true,
          signer: true,
          optional: false,
          docs: [
            "Enhanced authority verification"
          ]
        },
        {
          name: "clock",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "Clock sysvar for rate limiting"
          ],
          address: "SysvarC1ock11111111111111111111111111111111"
        }
      ],
      docs: "",
      discriminator: [
        85,
        2,
        178,
        9,
        119,
        139,
        102,
        164
      ],
      args: [
        {
          name: "_agent_type",
          type: "u8"
        },
        {
          name: "name",
          type: {
            option: "string"
          }
        },
        {
          name: "description",
          type: {
            option: "string"
          }
        },
        {
          name: "metadata_uri",
          type: "string"
        },
        {
          name: "_agent_id",
          type: "string"
        },
        {
          name: "pricing_model",
          type: {
            option: {
              defined: {
                name: "PricingModel"
              }
            }
          }
        }
      ]
    },
    update_agent_reputation: {
      name: "update_agent_reputation",
      expectedAccounts: [
        {
          name: "agent_account",
          pda: true
        },
        {
          name: "signer",
          pda: false
        },
        {
          name: "clock",
          pda: false
        }
      ],
      accounts: [
        {
          name: "agent_account",
          writable: true,
          signer: false,
          optional: false,
          docs: [
            "Agent account with canonical PDA validation"
          ],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  97,
                  103,
                  101,
                  110,
                  116
                ]
              },
              {
                kind: "account",
                path: "signer"
              },
              {
                kind: "arg",
                path: "agent_id"
              }
            ]
          }
        },
        {
          name: "signer",
          writable: true,
          signer: true,
          optional: false,
          docs: [
            "Enhanced authority verification"
          ]
        },
        {
          name: "clock",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "Clock sysvar for rate limiting"
          ],
          address: "SysvarC1ock11111111111111111111111111111111"
        }
      ],
      docs: "",
      discriminator: [
        80,
        227,
        92,
        245,
        231,
        37,
        99,
        180
      ],
      args: [
        {
          name: "agent_id",
          type: "string"
        },
        {
          name: "reputation_score",
          type: "u64"
        }
      ]
    },
    update_agent_service: {
      name: "update_agent_service",
      expectedAccounts: [
        {
          name: "agent",
          pda: true
        },
        {
          name: "owner",
          pda: false
        },
        {
          name: "system_program",
          pda: false
        }
      ],
      accounts: [
        {
          name: "agent",
          writable: true,
          signer: false,
          optional: false,
          docs: [
            "Agent account with enhanced 2025 security patterns"
          ],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  97,
                  103,
                  101,
                  110,
                  116
                ]
              },
              {
                kind: "account",
                path: "owner"
              }
            ]
          }
        },
        {
          name: "owner",
          writable: true,
          signer: true,
          optional: false,
          docs: [
            "Owner must be signer for security (2025 pattern)"
          ]
        },
        {
          name: "system_program",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "System program for account operations"
          ],
          address: "11111111111111111111111111111111"
        }
      ],
      docs: "",
      discriminator: [
        87,
        146,
        181,
        198,
        252,
        68,
        243,
        102
      ],
      args: [
        {
          name: "service_data",
          type: {
            defined: {
              name: "AgentServiceData"
            }
          }
        }
      ]
    },
    update_crosschain_status: {
      name: "update_crosschain_status",
      expectedAccounts: [
        {
          name: "credential",
          pda: false
        },
        {
          name: "issuer",
          pda: false
        }
      ],
      accounts: [
        {
          name: "credential",
          writable: true,
          signer: false,
          optional: false,
          docs: []
        },
        {
          name: "issuer",
          writable: true,
          signer: true,
          optional: false,
          docs: []
        }
      ],
      docs: "Update the cross-chain sync status after syncing to Crossmint",
      discriminator: [
        22,
        167,
        59,
        238,
        22,
        231,
        239,
        146
      ],
      args: [
        {
          name: "crossmint_credential_id",
          type: "string"
        },
        {
          name: "status",
          type: {
            defined: {
              name: "CrossChainStatus"
            }
          }
        }
      ]
    },
    update_did_document: {
      name: "update_did_document",
      expectedAccounts: [
        {
          name: "did_document",
          pda: true
        },
        {
          name: "controller",
          pda: false
        },
        {
          name: "clock",
          pda: false
        }
      ],
      accounts: [
        {
          name: "did_document",
          writable: true,
          signer: false,
          optional: false,
          docs: [
            "DID document account with canonical PDA validation"
          ],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  100,
                  105,
                  100,
                  95,
                  100,
                  111,
                  99,
                  117,
                  109,
                  101,
                  110,
                  116
                ]
              },
              {
                kind: "account",
                path: "controller"
              }
            ]
          }
        },
        {
          name: "controller",
          writable: true,
          signer: true,
          optional: false,
          docs: [
            "Controller of the DID (must match document controller)"
          ]
        },
        {
          name: "clock",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "Clock sysvar for timestamp validation"
          ],
          address: "SysvarC1ock11111111111111111111111111111111"
        }
      ],
      docs: "Update an existing DID document  Add or remove verification methods and service endpoints. Only the controller can update the DID document.  Parameters: - add_verification_method: Optional verification method to add - remove_verification_method_id: Optional method ID to remove - add_service_endpoint: Optional service endpoint to add - remove_service_endpoint_id: Optional service ID to remove",
      discriminator: [
        64,
        216,
        17,
        91,
        205,
        94,
        45,
        57
      ],
      args: [
        {
          name: "add_verification_method",
          type: {
            option: {
              defined: {
                name: "VerificationMethod"
              }
            }
          }
        },
        {
          name: "remove_verification_method_id",
          type: {
            option: "string"
          }
        },
        {
          name: "add_service_endpoint",
          type: {
            option: {
              defined: {
                name: "ServiceEndpoint"
              }
            }
          }
        },
        {
          name: "remove_service_endpoint_id",
          type: {
            option: "string"
          }
        }
      ]
    },
    update_protocol_config: {
      name: "update_protocol_config",
      expectedAccounts: [
        {
          name: "config",
          pda: true
        },
        {
          name: "authority",
          pda: false
        }
      ],
      accounts: [
        {
          name: "config",
          writable: true,
          signer: false,
          optional: false,
          docs: [],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  112,
                  114,
                  111,
                  116,
                  111,
                  99,
                  111,
                  108,
                  95,
                  99,
                  111,
                  110,
                  102,
                  105,
                  103
                ]
              }
            ]
          }
        },
        {
          name: "authority",
          writable: false,
          signer: true,
          optional: false,
          docs: []
        }
      ],
      docs: "Update protocol configuration parameters",
      discriminator: [
        197,
        97,
        123,
        54,
        221,
        168,
        11,
        135
      ],
      args: [
        {
          name: "escrow_fee_bps",
          type: {
            option: "u16"
          }
        },
        {
          name: "agent_registration_fee",
          type: {
            option: "u64"
          }
        },
        {
          name: "listing_fee",
          type: {
            option: "u64"
          }
        },
        {
          name: "dispute_fee_bps",
          type: {
            option: "u16"
          }
        },
        {
          name: "fees_enabled",
          type: {
            option: "bool"
          }
        },
        {
          name: "treasury",
          type: {
            option: "pubkey"
          }
        },
        {
          name: "buyback_pool",
          type: {
            option: "pubkey"
          }
        },
        {
          name: "moderator_pool",
          type: {
            option: "pubkey"
          }
        }
      ]
    },
    update_reputation_tags: {
      name: "update_reputation_tags",
      expectedAccounts: [
        {
          name: "reputation_metrics",
          pda: true
        },
        {
          name: "agent",
          pda: false
        },
        {
          name: "authority",
          pda: false
        },
        {
          name: "clock",
          pda: false
        }
      ],
      accounts: [
        {
          name: "reputation_metrics",
          writable: true,
          signer: false,
          optional: false,
          docs: [
            "Reputation metrics account"
          ],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  114,
                  101,
                  112,
                  117,
                  116,
                  97,
                  116,
                  105,
                  111,
                  110,
                  95,
                  109,
                  101,
                  116,
                  114,
                  105,
                  99,
                  115
                ]
              },
              {
                kind: "account",
                path: "agent"
              }
            ]
          }
        },
        {
          name: "agent",
          writable: true,
          signer: false,
          optional: false,
          docs: [
            "Agent account"
          ]
        },
        {
          name: "authority",
          writable: false,
          signer: true,
          optional: false,
          docs: [
            "Authority (can be the agent owner or authorized updater)"
          ]
        },
        {
          name: "clock",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "Clock for timestamps"
          ],
          address: "SysvarC1ock11111111111111111111111111111111"
        }
      ],
      docs: 'Update reputation tags for an agent  Adds or updates granular reputation tags with confidence scores. Tags are categorized into skill, behavior, and compliance tags. Each tag has a confidence score (0-10000 basis points) and evidence count.  Tag decay: Tags automatically decay at 10 bp/day and become stale after 90 days. This ensures reputation data stays current and reflects recent performance.  Parameters: - skill_tags: Skill tags to add (e.g., "rust", "smart-contracts") - max 20 - behavior_tags: Behavior tags (e.g., "responsive", "reliable") - max 20 - compliance_tags: Compliance tags (e.g., "kyc-verified") - max 10 - tag_scores: Tag scores with confidence and evidence - max 50',
      discriminator: [
        206,
        96,
        254,
        186,
        129,
        180,
        103,
        198
      ],
      args: [
        {
          name: "skill_tags",
          type: {
            vec: "string"
          }
        },
        {
          name: "behavior_tags",
          type: {
            vec: "string"
          }
        },
        {
          name: "compliance_tags",
          type: {
            vec: "string"
          }
        },
        {
          name: "tag_scores",
          type: {
            vec: {
              defined: {
                name: "TagScore"
              }
            }
          }
        }
      ]
    },
    update_reputation_with_auth: {
      name: "update_reputation_with_auth",
      expectedAccounts: [
        {
          name: "agent",
          pda: false
        },
        {
          name: "reputation_metrics",
          pda: true
        },
        {
          name: "authorization",
          pda: true
        },
        {
          name: "usage_record",
          pda: true
        },
        {
          name: "authorized_source",
          pda: false
        },
        {
          name: "system_program",
          pda: false
        },
        {
          name: "clock",
          pda: false
        }
      ],
      accounts: [
        {
          name: "agent",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "Agent whose reputation is being updated"
          ]
        },
        {
          name: "reputation_metrics",
          writable: true,
          signer: false,
          optional: false,
          docs: [
            "Agent reputation metrics"
          ],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  114,
                  101,
                  112,
                  117,
                  116,
                  97,
                  116,
                  105,
                  111,
                  110,
                  95,
                  109,
                  101,
                  116,
                  114,
                  105,
                  99,
                  115
                ]
              },
              {
                kind: "account",
                path: "agent"
              }
            ]
          }
        },
        {
          name: "authorization",
          writable: true,
          signer: false,
          optional: false,
          docs: [
            "Authorization account (PDA)"
          ],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  97,
                  103,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104
                ]
              },
              {
                kind: "account",
                path: "agent"
              },
              {
                kind: "account",
                path: "authorized_source"
              },
              {
                kind: "arg",
                path: "_nonce"
              }
            ]
          }
        },
        {
          name: "usage_record",
          writable: true,
          signer: false,
          optional: false,
          docs: [
            "Usage record account (optional, for audit trail)"
          ],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  97,
                  117,
                  116,
                  104,
                  95,
                  117,
                  115,
                  97,
                  103,
                  101
                ]
              },
              {
                kind: "account",
                path: "authorization"
              },
              {
                kind: "account",
                path: "authorization.current_index",
                account: "AgentReputationAuth"
              }
            ]
          }
        },
        {
          name: "authorized_source",
          writable: true,
          signer: true,
          optional: false,
          docs: [
            "Authorized source (e.g., PayAI facilitator)"
          ]
        },
        {
          name: "system_program",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "System program"
          ],
          address: "11111111111111111111111111111111"
        },
        {
          name: "clock",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "Clock for timestamps"
          ],
          address: "SysvarC1ock11111111111111111111111111111111"
        }
      ],
      docs: "Update agent reputation using authorization  Facilitators (e.g., PayAI) use this to update agent reputation using a pre-existing authorization from the agent.  Parameters: - reputation_change: Change to reputation score (can be positive or negative) - transaction_signature: Transaction signature for audit trail - metadata: Optional metadata about the reputation update - nonce: Optional nonce matching the authorization",
      discriminator: [
        61,
        236,
        225,
        167,
        134,
        43,
        53,
        93
      ],
      args: [
        {
          name: "reputation_change",
          type: "i64"
        },
        {
          name: "transaction_signature",
          type: "string"
        },
        {
          name: "metadata",
          type: {
            option: "string"
          }
        },
        {
          name: "nonce",
          type: {
            option: "string"
          }
        }
      ]
    },
    update_source_reputation: {
      name: "update_source_reputation",
      expectedAccounts: [
        {
          name: "reputation_metrics",
          pda: true
        },
        {
          name: "agent",
          pda: false
        },
        {
          name: "authority",
          pda: false
        },
        {
          name: "clock",
          pda: false
        }
      ],
      accounts: [
        {
          name: "reputation_metrics",
          writable: true,
          signer: false,
          optional: false,
          docs: [
            "Reputation metrics account"
          ],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  114,
                  101,
                  112,
                  117,
                  116,
                  97,
                  116,
                  105,
                  111,
                  110,
                  95,
                  109,
                  101,
                  116,
                  114,
                  105,
                  99,
                  115
                ]
              },
              {
                kind: "account",
                path: "agent"
              }
            ]
          }
        },
        {
          name: "agent",
          writable: true,
          signer: false,
          optional: false,
          docs: [
            "Agent account"
          ]
        },
        {
          name: "authority",
          writable: false,
          signer: true,
          optional: false,
          docs: [
            "Authority (can be oracle, agent owner, or authorized updater)"
          ]
        },
        {
          name: "clock",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "Clock for timestamps"
          ],
          address: "SysvarC1ock11111111111111111111111111111111"
        }
      ],
      docs: 'Update reputation from a specific source  Updates or adds a reputation score from an external source (e.g., GitHub, custom webhook). Automatically aggregates all sources and detects conflicts.  Parameters: - source_name: Source identifier (e.g., "github", "custom-webhook") - score: Reputation score from source (0-1000) - weight: Source weight in basis points (0-10000) - data_points: Number of metrics contributing to score - reliability: Source reliability in basis points (0-10000)',
      discriminator: [
        161,
        240,
        255,
        69,
        130,
        227,
        71,
        123
      ],
      args: [
        {
          name: "source_name",
          type: "string"
        },
        {
          name: "score",
          type: "u16"
        },
        {
          name: "weight",
          type: "u16"
        },
        {
          name: "data_points",
          type: "u32"
        },
        {
          name: "reliability",
          type: "u16"
        }
      ]
    },
    verify_agent: {
      name: "verify_agent",
      expectedAccounts: [
        {
          name: "agent_verification",
          pda: true
        },
        {
          name: "agent",
          pda: false
        },
        {
          name: "verifier",
          pda: false
        },
        {
          name: "system_program",
          pda: false
        },
        {
          name: "clock",
          pda: false
        }
      ],
      accounts: [
        {
          name: "agent_verification",
          writable: true,
          signer: false,
          optional: false,
          docs: [
            "Verification account with enhanced PDA security"
          ],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  97,
                  103,
                  101,
                  110,
                  116,
                  95,
                  118,
                  101,
                  114,
                  105,
                  102,
                  105,
                  99,
                  97,
                  116,
                  105,
                  111,
                  110
                ]
              },
              {
                kind: "account",
                path: "agent"
              },
              {
                kind: "account",
                path: "verifier"
              }
            ]
          }
        },
        {
          name: "agent",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "Agent account being verified (enhanced validation)"
          ]
        },
        {
          name: "verifier",
          writable: true,
          signer: true,
          optional: false,
          docs: [
            "Verifier authority with enhanced permissions"
          ]
        },
        {
          name: "system_program",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "System program for account operations"
          ],
          address: "11111111111111111111111111111111"
        },
        {
          name: "clock",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "Clock sysvar for timestamp validation"
          ],
          address: "SysvarC1ock11111111111111111111111111111111"
        }
      ],
      docs: "",
      discriminator: [
        206,
        212,
        108,
        12,
        105,
        61,
        100,
        66
      ],
      args: [
        {
          name: "agent_pubkey",
          type: "pubkey"
        },
        {
          name: "service_endpoint",
          type: "string"
        },
        {
          name: "supported_capabilities",
          type: {
            vec: "u64"
          }
        },
        {
          name: "verified_at",
          type: "i64"
        }
      ]
    },
    verify_authorization: {
      name: "verify_authorization",
      expectedAccounts: [
        {
          name: "agent",
          pda: false
        },
        {
          name: "authorization",
          pda: true
        },
        {
          name: "clock",
          pda: false
        }
      ],
      accounts: [
        {
          name: "agent",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "Agent account"
          ]
        },
        {
          name: "authorization",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "Authorization account (PDA)"
          ],
          pda: {
            seeds: [
              {
                kind: "const",
                value: [
                  97,
                  103,
                  101,
                  110,
                  116,
                  95,
                  97,
                  117,
                  116,
                  104
                ]
              },
              {
                kind: "account",
                path: "agent"
              },
              {
                kind: "account",
                path: "authorization.authorized_source",
                account: "AgentReputationAuth"
              },
              {
                kind: "arg",
                path: "_nonce"
              }
            ]
          }
        },
        {
          name: "clock",
          writable: false,
          signer: false,
          optional: false,
          docs: [
            "Clock for timestamp validation"
          ],
          address: "SysvarC1ock11111111111111111111111111111111"
        }
      ],
      docs: "Verify agent authorization (view-only)  Checks if an authorization is valid and returns its status. This is a read-only instruction for verification purposes.  Parameters: - nonce: Optional nonce identifying the specific authorization to verify",
      discriminator: [
        43,
        9,
        131,
        59,
        74,
        118,
        113,
        170
      ],
      args: [
        {
          name: "nonce",
          type: {
            option: "string"
          }
        }
      ]
    }
  };
  InstructionValidationError = class extends Error {
    instruction;
    expectedAccounts;
    providedAccounts;
    accountDetails;
    constructor(instruction, expectedAccounts, providedAccounts, message, accountDetails) {
      super(message);
      this.name = "InstructionValidationError";
      this.instruction = instruction;
      this.expectedAccounts = expectedAccounts;
      this.providedAccounts = providedAccounts;
      this.accountDetails = accountDetails;
    }
  };
  INSTRUCTION_MAPPINGS = instructionAccountMappings;
  GhostSpeakSDKError = class extends Error {
    originalError;
    operation;
    instructionName;
    constructor(operation, originalError, instructionName) {
      const enhancedError = enhanceErrorMessage(originalError, instructionName ?? "unknown");
      super(enhancedError);
      this.name = "GhostSpeakSDKError";
      this.operation = operation;
      this.originalError = originalError;
      this.instructionName = instructionName;
    }
  };
  ipfs_client_exports = {};
  __export2(ipfs_client_exports, {
    IPFSClient: () => IPFSClient
  });
  sharedTestStorage = /* @__PURE__ */ new Map;
  SYSTEM_PROGRAM_ADDRESS = address("11111111111111111111111111111111");
  address("11111111111111111111111111111111");
  address("SysvarRecentB1ockHashes11111111111111111111");
  address("SysvarStakeHistory1111111111111111111111111");
  address("Sysvar1nstructions1111111111111111111111111");
  TOKEN_PROGRAM_ADDRESS = address("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");
  TOKEN_2022_PROGRAM_ADDRESS = address("TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb");
  ASSOCIATED_TOKEN_PROGRAM_ADDRESS = address("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL");
  address("So11111111111111111111111111111111111111112");
  NATIVE_MINT_ADDRESS = address("9pan9bMn5HatX4EJdBwg9VgCa7Uz5HL8N1m5D3NdXejP");
  address("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s");
  ReputationTier2 = /* @__PURE__ */ ((ReputationTier3) => {
    ReputationTier3["None"] = "None";
    ReputationTier3["Bronze"] = "Bronze";
    ReputationTier3["Silver"] = "Silver";
    ReputationTier3["Gold"] = "Gold";
    ReputationTier3["Platinum"] = "Platinum";
    return ReputationTier3;
  })(ReputationTier2 || {});
  BadgeType = /* @__PURE__ */ ((BadgeType2) => {
    BadgeType2["FirstJob"] = "FirstJob";
    BadgeType2["TenJobs"] = "TenJobs";
    BadgeType2["HundredJobs"] = "HundredJobs";
    BadgeType2["ThousandJobs"] = "ThousandJobs";
    BadgeType2["PerfectRating"] = "PerfectRating";
    BadgeType2["QuickResponder"] = "QuickResponder";
    BadgeType2["HighEarner"] = "HighEarner";
    BadgeType2["DisputeResolver"] = "DisputeResolver";
    BadgeType2["CategoryExpert"] = "CategoryExpert";
    BadgeType2["CrossCategoryMaster"] = "CrossCategoryMaster";
    return BadgeType2;
  })(BadgeType || {});
  REPUTATION_CONSTANTS = {
    MAX_REPUTATION_SCORE: 1e4,
    MIN_REPUTATION_FOR_SLASH: 1000,
    REPUTATION_DECAY_RATE_BPS: 10,
    BRONZE_TIER_THRESHOLD: 2000,
    SILVER_TIER_THRESHOLD: 5000,
    GOLD_TIER_THRESHOLD: 7500,
    PLATINUM_TIER_THRESHOLD: 9000,
    MAX_REPUTATION_CATEGORIES: 10,
    MAX_PERFORMANCE_HISTORY: 365,
    MAX_BADGES: 20
  };
});

// ../node_modules/.bun/@solana+functional@5.1.0+1fb4c65d43e298b9/node_modules/@solana/functional/dist/index.node.mjs
function pipe(init, ...fns) {
  return fns.reduce((acc, fn) => fn(acc), init);
}
var init_index_node12 = () => {};

// ../node_modules/.bun/@solana+instructions@5.1.0+1fb4c65d43e298b9/node_modules/@solana/instructions/dist/index.node.mjs
function isInstructionForProgram(instruction, programAddress) {
  return instruction.programAddress === programAddress;
}
function assertIsInstructionForProgram(instruction, programAddress) {
  if (instruction.programAddress !== programAddress) {
    throw new SolanaError(SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH, {
      actualProgramAddress: instruction.programAddress,
      expectedProgramAddress: programAddress
    });
  }
}
function isInstructionWithAccounts(instruction) {
  return instruction.accounts !== undefined;
}
function assertIsInstructionWithAccounts(instruction) {
  if (instruction.accounts === undefined) {
    throw new SolanaError(SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS, {
      data: instruction.data,
      programAddress: instruction.programAddress
    });
  }
}
function isInstructionWithData(instruction) {
  return instruction.data !== undefined;
}
function assertIsInstructionWithData(instruction) {
  if (instruction.data === undefined) {
    throw new SolanaError(SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA, {
      accountAddresses: instruction.accounts?.map((a) => a.address),
      programAddress: instruction.programAddress
    });
  }
}
function downgradeRoleToNonSigner(role) {
  return role & ~IS_SIGNER_BITMASK;
}
function downgradeRoleToReadonly(role) {
  return role & ~IS_WRITABLE_BITMASK;
}
function isSignerRole(role) {
  return role >= 2;
}
function isWritableRole(role) {
  return (role & IS_WRITABLE_BITMASK) !== 0;
}
function mergeRoles(roleA, roleB) {
  return roleA | roleB;
}
function upgradeRoleToSigner(role) {
  return role | IS_SIGNER_BITMASK;
}
function upgradeRoleToWritable(role) {
  return role | IS_WRITABLE_BITMASK;
}
var AccountRole, IS_SIGNER_BITMASK = 2, IS_WRITABLE_BITMASK = 1;
var init_index_node13 = __esm(() => {
  init_index_node();
  AccountRole = /* @__PURE__ */ ((AccountRole2) => {
    AccountRole2[AccountRole2["WRITABLE_SIGNER"] = 3] = "WRITABLE_SIGNER";
    AccountRole2[AccountRole2["READONLY_SIGNER"] = 2] = "READONLY_SIGNER";
    AccountRole2[AccountRole2["WRITABLE"] = 1] = "WRITABLE";
    AccountRole2[AccountRole2["READONLY"] = 0] = "READONLY";
    return AccountRole2;
  })(AccountRole || {});
});

// ../node_modules/.bun/@solana+transaction-messages@5.1.0+7f9e3d21594a24ff/node_modules/@solana/transaction-messages/dist/index.node.mjs
function isTransactionMessageWithBlockhashLifetime(transactionMessage) {
  return "lifetimeConstraint" in transactionMessage && typeof transactionMessage.lifetimeConstraint.blockhash === "string" && typeof transactionMessage.lifetimeConstraint.lastValidBlockHeight === "bigint" && isBlockhash(transactionMessage.lifetimeConstraint.blockhash);
}
function assertIsTransactionMessageWithBlockhashLifetime(transactionMessage) {
  if (!isTransactionMessageWithBlockhashLifetime(transactionMessage)) {
    throw new SolanaError(SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME);
  }
}
function setTransactionMessageLifetimeUsingBlockhash(blockhashLifetimeConstraint, transactionMessage) {
  if ("lifetimeConstraint" in transactionMessage && transactionMessage.lifetimeConstraint && "blockhash" in transactionMessage.lifetimeConstraint && transactionMessage.lifetimeConstraint.blockhash === blockhashLifetimeConstraint.blockhash && transactionMessage.lifetimeConstraint.lastValidBlockHeight === blockhashLifetimeConstraint.lastValidBlockHeight) {
    return transactionMessage;
  }
  return Object.freeze({
    ...transactionMessage,
    lifetimeConstraint: Object.freeze(blockhashLifetimeConstraint)
  });
}
function assertValidBaseString2(alphabet4, testValue, givenValue = testValue) {
  if (!testValue.match(new RegExp(`^[${alphabet4}]*$`))) {
    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {
      alphabet: alphabet4,
      base: alphabet4.length,
      value: givenValue
    });
  }
}
function partitionLeadingZeroes2(value, zeroCharacter) {
  const [leadingZeros, tailChars] = value.split(new RegExp(`((?!${zeroCharacter}).*)`));
  return [leadingZeros, tailChars];
}
function getBigIntFromBaseX2(value, alphabet4) {
  const base = BigInt(alphabet4.length);
  let sum = 0n;
  for (const char of value) {
    sum *= base;
    sum += BigInt(alphabet4.indexOf(char));
  }
  return sum;
}
function getBaseXFromBigInt2(value, alphabet4) {
  const base = BigInt(alphabet4.length);
  const tailChars = [];
  while (value > 0n) {
    tailChars.unshift(alphabet4[Number(value % base)]);
    value /= base;
  }
  return tailChars.join("");
}
function getAddressTableLookupEncoder() {
  if (!memoizedAddressTableLookupEncoder) {
    const indexEncoder = getArrayEncoder(getU8Encoder(), { size: getShortU16Encoder() });
    memoizedAddressTableLookupEncoder = getStructEncoder([
      ["lookupTableAddress", getAddressEncoder()],
      ["writableIndexes", indexEncoder],
      ["readonlyIndexes", indexEncoder]
    ]);
  }
  return memoizedAddressTableLookupEncoder;
}
function getAddressTableLookupDecoder() {
  if (!memoizedAddressTableLookupDecoder) {
    const indexEncoder = getArrayDecoder(getU8Decoder(), { size: getShortU16Decoder() });
    memoizedAddressTableLookupDecoder = getStructDecoder([
      ["lookupTableAddress", getAddressDecoder()],
      ["writableIndexes", indexEncoder],
      ["readonlyIndexes", indexEncoder]
    ]);
  }
  return memoizedAddressTableLookupDecoder;
}
function getMemoizedU8Encoder() {
  if (!memoizedU8Encoder)
    memoizedU8Encoder = getU8Encoder();
  return memoizedU8Encoder;
}
function getMemoizedU8Decoder() {
  if (!memoizedU8Decoder)
    memoizedU8Decoder = getU8Decoder();
  return memoizedU8Decoder;
}
function getMessageHeaderEncoder() {
  return getStructEncoder([
    ["numSignerAccounts", getMemoizedU8Encoder()],
    ["numReadonlySignerAccounts", getMemoizedU8Encoder()],
    ["numReadonlyNonSignerAccounts", getMemoizedU8Encoder()]
  ]);
}
function getMessageHeaderDecoder() {
  return getStructDecoder([
    ["numSignerAccounts", getMemoizedU8Decoder()],
    ["numReadonlySignerAccounts", getMemoizedU8Decoder()],
    ["numReadonlyNonSignerAccounts", getMemoizedU8Decoder()]
  ]);
}
function getInstructionEncoder() {
  if (!memoizedGetInstructionEncoder) {
    memoizedGetInstructionEncoder = transformEncoder(getStructEncoder([
      ["programAddressIndex", getU8Encoder()],
      ["accountIndices", getArrayEncoder(getU8Encoder(), { size: getShortU16Encoder() })],
      ["data", addEncoderSizePrefix(getBytesEncoder(), getShortU16Encoder())]
    ]), (instruction) => {
      if (instruction.accountIndices !== undefined && instruction.data !== undefined) {
        return instruction;
      }
      return {
        ...instruction,
        accountIndices: instruction.accountIndices ?? [],
        data: instruction.data ?? new Uint8Array(0)
      };
    });
  }
  return memoizedGetInstructionEncoder;
}
function getInstructionDecoder() {
  if (!memoizedGetInstructionDecoder) {
    memoizedGetInstructionDecoder = transformDecoder(getStructDecoder([
      ["programAddressIndex", getU8Decoder()],
      ["accountIndices", getArrayDecoder(getU8Decoder(), { size: getShortU16Decoder() })],
      [
        "data",
        addDecoderSizePrefix(getBytesDecoder(), getShortU16Decoder())
      ]
    ]), (instruction) => {
      if (instruction.accountIndices.length && instruction.data.byteLength) {
        return instruction;
      }
      const { accountIndices, data: data2, ...rest } = instruction;
      return {
        ...rest,
        ...accountIndices.length ? { accountIndices } : null,
        ...data2.byteLength ? { data: data2 } : null
      };
    });
  }
  return memoizedGetInstructionDecoder;
}
function getTransactionVersionEncoder() {
  return createEncoder({
    getSizeFromValue: (value) => value === "legacy" ? 0 : 1,
    maxSize: 1,
    write: (value, bytes, offset) => {
      if (value === "legacy") {
        return offset;
      }
      if (value < 0 || value > 127) {
        throw new SolanaError(SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE, {
          actualVersion: value
        });
      }
      if (value > MAX_SUPPORTED_TRANSACTION_VERSION) {
        throw new SolanaError(SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_NOT_SUPPORTED, {
          unsupportedVersion: value
        });
      }
      bytes.set([value | VERSION_FLAG_MASK], offset);
      return offset + 1;
    }
  });
}
function getTransactionVersionDecoder() {
  return createDecoder({
    maxSize: 1,
    read: (bytes, offset) => {
      const firstByte = bytes[offset];
      if ((firstByte & VERSION_FLAG_MASK) === 0) {
        return ["legacy", offset];
      } else {
        const version = firstByte ^ VERSION_FLAG_MASK;
        if (version > MAX_SUPPORTED_TRANSACTION_VERSION) {
          throw new SolanaError(SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_NOT_SUPPORTED, {
            unsupportedVersion: version
          });
        }
        return [version, offset + 1];
      }
    }
  });
}
function getTransactionVersionCodec() {
  return combineCodec(getTransactionVersionEncoder(), getTransactionVersionDecoder());
}
function getCompiledMessageLegacyEncoder() {
  return getStructEncoder(getPreludeStructEncoderTuple());
}
function getCompiledMessageVersionedEncoder() {
  return transformEncoder(getStructEncoder([
    ...getPreludeStructEncoderTuple(),
    ["addressTableLookups", getAddressTableLookupArrayEncoder()]
  ]), (value) => {
    if (value.version === "legacy") {
      return value;
    }
    return {
      ...value,
      addressTableLookups: value.addressTableLookups ?? []
    };
  });
}
function getPreludeStructEncoderTuple() {
  const lifetimeTokenEncoder = getUnionEncoder([
    getConstantEncoder(new Uint8Array(32)),
    fixEncoderSize(getBase58Encoder2(), 32)
  ], (value) => value === undefined ? 0 : 1);
  return [
    ["version", getTransactionVersionEncoder()],
    ["header", getMessageHeaderEncoder()],
    ["staticAccounts", getArrayEncoder(getAddressEncoder(), { size: getShortU16Encoder() })],
    ["lifetimeToken", lifetimeTokenEncoder],
    ["instructions", getArrayEncoder(getInstructionEncoder(), { size: getShortU16Encoder() })]
  ];
}
function getPreludeStructDecoderTuple() {
  return [
    ["version", getTransactionVersionDecoder()],
    ["header", getMessageHeaderDecoder()],
    ["staticAccounts", getArrayDecoder(getAddressDecoder(), { size: getShortU16Decoder() })],
    ["lifetimeToken", fixDecoderSize(getBase58Decoder2(), 32)],
    ["instructions", getArrayDecoder(getInstructionDecoder(), { size: getShortU16Decoder() })],
    ["addressTableLookups", getAddressTableLookupArrayDecoder()]
  ];
}
function getAddressTableLookupArrayEncoder() {
  return getArrayEncoder(getAddressTableLookupEncoder(), { size: getShortU16Encoder() });
}
function getAddressTableLookupArrayDecoder() {
  return getArrayDecoder(getAddressTableLookupDecoder(), { size: getShortU16Decoder() });
}
function getCompiledTransactionMessageEncoder() {
  return createEncoder({
    getSizeFromValue: (compiledMessage) => {
      if (compiledMessage.version === "legacy") {
        return getCompiledMessageLegacyEncoder().getSizeFromValue(compiledMessage);
      } else {
        return getCompiledMessageVersionedEncoder().getSizeFromValue(compiledMessage);
      }
    },
    write: (compiledMessage, bytes, offset) => {
      if (compiledMessage.version === "legacy") {
        return getCompiledMessageLegacyEncoder().write(compiledMessage, bytes, offset);
      } else {
        return getCompiledMessageVersionedEncoder().write(compiledMessage, bytes, offset);
      }
    }
  });
}
function getCompiledTransactionMessageDecoder() {
  return transformDecoder(getStructDecoder(getPreludeStructDecoderTuple()), ({ addressTableLookups, ...restOfMessage }) => {
    if (restOfMessage.version === "legacy" || !addressTableLookups?.length) {
      return restOfMessage;
    }
    return { ...restOfMessage, addressTableLookups };
  });
}
function getCompiledTransactionMessageCodec() {
  return combineCodec(getCompiledTransactionMessageEncoder(), getCompiledTransactionMessageDecoder());
}
function upsert(addressMap, address2, update) {
  addressMap[address2] = update(addressMap[address2] ?? { role: AccountRole.READONLY });
}
function getAddressMapFromInstructions(feePayer, instructions) {
  const addressMap = {
    [feePayer]: { [TYPE2]: 0, role: AccountRole.WRITABLE_SIGNER }
  };
  const addressesOfInvokedPrograms = /* @__PURE__ */ new Set;
  for (const instruction of instructions) {
    upsert(addressMap, instruction.programAddress, (entry) => {
      addressesOfInvokedPrograms.add(instruction.programAddress);
      if (TYPE2 in entry) {
        if (isWritableRole(entry.role)) {
          switch (entry[TYPE2]) {
            case 0:
              throw new SolanaError(SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES, {
                programAddress: instruction.programAddress
              });
            default:
              throw new SolanaError(SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE, {
                programAddress: instruction.programAddress
              });
          }
        }
        if (entry[TYPE2] === 2) {
          return entry;
        }
      }
      return { [TYPE2]: 2, role: AccountRole.READONLY };
    });
    let addressComparator;
    if (!instruction.accounts) {
      continue;
    }
    for (const account of instruction.accounts) {
      upsert(addressMap, account.address, (entry) => {
        const {
          address: _,
          ...accountMeta
        } = account;
        if (TYPE2 in entry) {
          switch (entry[TYPE2]) {
            case 0:
              return entry;
            case 1: {
              const nextRole = mergeRoles(entry.role, accountMeta.role);
              if ("lookupTableAddress" in accountMeta) {
                const shouldReplaceEntry = entry.lookupTableAddress !== accountMeta.lookupTableAddress && (addressComparator ||= getAddressComparator())(accountMeta.lookupTableAddress, entry.lookupTableAddress) < 0;
                if (shouldReplaceEntry) {
                  return {
                    [TYPE2]: 1,
                    ...accountMeta,
                    role: nextRole
                  };
                }
              } else if (isSignerRole(accountMeta.role)) {
                return {
                  [TYPE2]: 2,
                  role: nextRole
                };
              }
              if (entry.role !== nextRole) {
                return {
                  ...entry,
                  role: nextRole
                };
              } else {
                return entry;
              }
            }
            case 2: {
              const nextRole = mergeRoles(entry.role, accountMeta.role);
              if (addressesOfInvokedPrograms.has(account.address)) {
                if (isWritableRole(accountMeta.role)) {
                  throw new SolanaError(SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE, {
                    programAddress: account.address
                  });
                }
                if (entry.role !== nextRole) {
                  return {
                    ...entry,
                    role: nextRole
                  };
                } else {
                  return entry;
                }
              } else if ("lookupTableAddress" in accountMeta && !isSignerRole(entry.role)) {
                return {
                  ...accountMeta,
                  [TYPE2]: 1,
                  role: nextRole
                };
              } else {
                if (entry.role !== nextRole) {
                  return {
                    ...entry,
                    role: nextRole
                  };
                } else {
                  return entry;
                }
              }
            }
          }
        }
        if ("lookupTableAddress" in accountMeta) {
          return {
            ...accountMeta,
            [TYPE2]: 1
          };
        } else {
          return {
            ...accountMeta,
            [TYPE2]: 2
          };
        }
      });
    }
  }
  return addressMap;
}
function getOrderedAccountsFromAddressMap(addressMap) {
  let addressComparator;
  const orderedAccounts = Object.entries(addressMap).sort(([leftAddress, leftEntry], [rightAddress, rightEntry]) => {
    if (leftEntry[TYPE2] !== rightEntry[TYPE2]) {
      if (leftEntry[TYPE2] === 0) {
        return -1;
      } else if (rightEntry[TYPE2] === 0) {
        return 1;
      } else if (leftEntry[TYPE2] === 2) {
        return -1;
      } else if (rightEntry[TYPE2] === 2) {
        return 1;
      }
    }
    const leftIsSigner = isSignerRole(leftEntry.role);
    if (leftIsSigner !== isSignerRole(rightEntry.role)) {
      return leftIsSigner ? -1 : 1;
    }
    const leftIsWritable = isWritableRole(leftEntry.role);
    if (leftIsWritable !== isWritableRole(rightEntry.role)) {
      return leftIsWritable ? -1 : 1;
    }
    addressComparator ||= getAddressComparator();
    if (leftEntry[TYPE2] === 1 && rightEntry[TYPE2] === 1 && leftEntry.lookupTableAddress !== rightEntry.lookupTableAddress) {
      return addressComparator(leftEntry.lookupTableAddress, rightEntry.lookupTableAddress);
    } else {
      return addressComparator(leftAddress, rightAddress);
    }
  }).map(([address2, addressMeta]) => ({
    address: address2,
    ...addressMeta
  }));
  return orderedAccounts;
}
function getCompiledAddressTableLookups(orderedAccounts) {
  const index = {};
  for (const account of orderedAccounts) {
    if (!("lookupTableAddress" in account)) {
      continue;
    }
    const entry = index[account.lookupTableAddress] ||= {
      readonlyIndexes: [],
      writableIndexes: []
    };
    if (account.role === AccountRole.WRITABLE) {
      entry.writableIndexes.push(account.addressIndex);
    } else {
      entry.readonlyIndexes.push(account.addressIndex);
    }
  }
  return Object.keys(index).sort(getAddressComparator()).map((lookupTableAddress) => ({
    lookupTableAddress,
    ...index[lookupTableAddress]
  }));
}
function getCompiledMessageHeader(orderedAccounts) {
  let numReadonlyNonSignerAccounts = 0;
  let numReadonlySignerAccounts = 0;
  let numSignerAccounts = 0;
  for (const account of orderedAccounts) {
    if ("lookupTableAddress" in account) {
      break;
    }
    const accountIsWritable = isWritableRole(account.role);
    if (isSignerRole(account.role)) {
      numSignerAccounts++;
      if (!accountIsWritable) {
        numReadonlySignerAccounts++;
      }
    } else if (!accountIsWritable) {
      numReadonlyNonSignerAccounts++;
    }
  }
  return {
    numReadonlyNonSignerAccounts,
    numReadonlySignerAccounts,
    numSignerAccounts
  };
}
function getAccountIndex(orderedAccounts) {
  const out = {};
  for (const [index, account] of orderedAccounts.entries()) {
    out[account.address] = index;
  }
  return out;
}
function getCompiledInstructions(instructions, orderedAccounts) {
  const accountIndex = getAccountIndex(orderedAccounts);
  return instructions.map(({ accounts, data: data2, programAddress }) => {
    return {
      programAddressIndex: accountIndex[programAddress],
      ...accounts ? { accountIndices: accounts.map(({ address: address2 }) => accountIndex[address2]) } : null,
      ...data2 ? { data: data2 } : null
    };
  });
}
function getCompiledLifetimeToken(lifetimeConstraint) {
  if ("nonce" in lifetimeConstraint) {
    return lifetimeConstraint.nonce;
  }
  return lifetimeConstraint.blockhash;
}
function getCompiledStaticAccounts(orderedAccounts) {
  const firstLookupTableAccountIndex = orderedAccounts.findIndex((account) => ("lookupTableAddress" in account));
  const orderedStaticAccounts = firstLookupTableAccountIndex === -1 ? orderedAccounts : orderedAccounts.slice(0, firstLookupTableAccountIndex);
  return orderedStaticAccounts.map(({ address: address2 }) => address2);
}
function compileTransactionMessage(transactionMessage) {
  const addressMap = getAddressMapFromInstructions(transactionMessage.feePayer.address, transactionMessage.instructions);
  const orderedAccounts = getOrderedAccountsFromAddressMap(addressMap);
  const lifetimeConstraint = transactionMessage.lifetimeConstraint;
  return {
    ...transactionMessage.version !== "legacy" ? { addressTableLookups: getCompiledAddressTableLookups(orderedAccounts) } : null,
    ...lifetimeConstraint ? { lifetimeToken: getCompiledLifetimeToken(lifetimeConstraint) } : null,
    header: getCompiledMessageHeader(orderedAccounts),
    instructions: getCompiledInstructions(transactionMessage.instructions, orderedAccounts),
    staticAccounts: getCompiledStaticAccounts(orderedAccounts),
    version: transactionMessage.version
  };
}
function findAddressInLookupTables(address2, role, addressesByLookupTableAddress) {
  for (const [lookupTableAddress, addresses] of Object.entries(addressesByLookupTableAddress)) {
    for (let i = 0;i < addresses.length; i++) {
      if (address2 === addresses[i]) {
        return {
          address: address2,
          addressIndex: i,
          lookupTableAddress,
          role
        };
      }
    }
  }
}
function compressTransactionMessageUsingAddressLookupTables(transactionMessage, addressesByLookupTableAddress) {
  const programAddresses = new Set(transactionMessage.instructions.map((ix) => ix.programAddress));
  const eligibleLookupAddresses = new Set(Object.values(addressesByLookupTableAddress).flatMap((a) => a).filter((address2) => !programAddresses.has(address2)));
  const newInstructions = [];
  let updatedAnyInstructions = false;
  for (const instruction of transactionMessage.instructions) {
    if (!instruction.accounts) {
      newInstructions.push(instruction);
      continue;
    }
    const newAccounts = [];
    let updatedAnyAccounts = false;
    for (const account of instruction.accounts) {
      if ("lookupTableAddress" in account || !eligibleLookupAddresses.has(account.address) || isSignerRole(account.role)) {
        newAccounts.push(account);
        continue;
      }
      const lookupMetaAccount = findAddressInLookupTables(account.address, account.role, addressesByLookupTableAddress);
      newAccounts.push(Object.freeze(lookupMetaAccount));
      updatedAnyAccounts = true;
      updatedAnyInstructions = true;
    }
    newInstructions.push(Object.freeze(updatedAnyAccounts ? { ...instruction, accounts: newAccounts } : instruction));
  }
  return Object.freeze(updatedAnyInstructions ? { ...transactionMessage, instructions: newInstructions } : transactionMessage);
}
function createTransactionMessage(config) {
  return Object.freeze({
    instructions: Object.freeze([]),
    version: config.version
  });
}
function createAdvanceNonceAccountInstruction(nonceAccountAddress, nonceAuthorityAddress) {
  return {
    accounts: [
      { address: nonceAccountAddress, role: AccountRole.WRITABLE },
      {
        address: RECENT_BLOCKHASHES_SYSVAR_ADDRESS,
        role: AccountRole.READONLY
      },
      { address: nonceAuthorityAddress, role: AccountRole.READONLY_SIGNER }
    ],
    data: new Uint8Array([4, 0, 0, 0]),
    programAddress: SYSTEM_PROGRAM_ADDRESS2
  };
}
function isAdvanceNonceAccountInstruction(instruction) {
  return instruction.programAddress === SYSTEM_PROGRAM_ADDRESS2 && instruction.data != null && isAdvanceNonceAccountInstructionData(instruction.data) && instruction.accounts?.length === 3 && instruction.accounts[0].address != null && instruction.accounts[0].role === AccountRole.WRITABLE && instruction.accounts[1].address === RECENT_BLOCKHASHES_SYSVAR_ADDRESS && instruction.accounts[1].role === AccountRole.READONLY && instruction.accounts[2].address != null && isSignerRole(instruction.accounts[2].role);
}
function isAdvanceNonceAccountInstructionData(data2) {
  return data2.byteLength === 4 && data2[0] === 4 && data2[1] === 0 && data2[2] === 0 && data2[3] === 0;
}
function isTransactionMessageWithDurableNonceLifetime(transactionMessage) {
  return "lifetimeConstraint" in transactionMessage && typeof transactionMessage.lifetimeConstraint.nonce === "string" && transactionMessage.instructions[0] != null && isAdvanceNonceAccountInstruction(transactionMessage.instructions[0]);
}
function assertIsTransactionMessageWithDurableNonceLifetime(transactionMessage) {
  if (!isTransactionMessageWithDurableNonceLifetime(transactionMessage)) {
    throw new SolanaError(SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME);
  }
}
function isAdvanceNonceAccountInstructionForNonce(instruction, nonceAccountAddress, nonceAuthorityAddress) {
  return instruction.accounts[0].address === nonceAccountAddress && instruction.accounts[2].address === nonceAuthorityAddress;
}
function setTransactionMessageLifetimeUsingDurableNonce({
  nonce,
  nonceAccountAddress,
  nonceAuthorityAddress
}, transactionMessage) {
  let newInstructions;
  const firstInstruction = transactionMessage.instructions[0];
  if (firstInstruction && isAdvanceNonceAccountInstruction(firstInstruction)) {
    if (isAdvanceNonceAccountInstructionForNonce(firstInstruction, nonceAccountAddress, nonceAuthorityAddress)) {
      if (isTransactionMessageWithDurableNonceLifetime(transactionMessage) && transactionMessage.lifetimeConstraint.nonce === nonce) {
        return transactionMessage;
      } else {
        newInstructions = [firstInstruction, ...transactionMessage.instructions.slice(1)];
      }
    } else {
      newInstructions = [
        Object.freeze(createAdvanceNonceAccountInstruction(nonceAccountAddress, nonceAuthorityAddress)),
        ...transactionMessage.instructions.slice(1)
      ];
    }
  } else {
    newInstructions = [
      Object.freeze(createAdvanceNonceAccountInstruction(nonceAccountAddress, nonceAuthorityAddress)),
      ...transactionMessage.instructions
    ];
  }
  return Object.freeze({
    ...transactionMessage,
    instructions: Object.freeze(newInstructions),
    lifetimeConstraint: Object.freeze({ nonce })
  });
}
function setTransactionMessageFeePayer(feePayer, transactionMessage) {
  if ("feePayer" in transactionMessage && feePayer === transactionMessage.feePayer?.address && isAddressOnlyFeePayer(transactionMessage.feePayer)) {
    return transactionMessage;
  }
  const out = {
    ...transactionMessage,
    feePayer: Object.freeze({ address: feePayer })
  };
  Object.freeze(out);
  return out;
}
function isAddressOnlyFeePayer(feePayer) {
  return !!feePayer && "address" in feePayer && typeof feePayer.address === "string" && Object.keys(feePayer).length === 1;
}
function appendTransactionMessageInstruction(instruction, transactionMessage) {
  return appendTransactionMessageInstructions([instruction], transactionMessage);
}
function appendTransactionMessageInstructions(instructions, transactionMessage) {
  return Object.freeze({
    ...transactionMessage,
    instructions: Object.freeze([
      ...transactionMessage.instructions,
      ...instructions
    ])
  });
}
function prependTransactionMessageInstruction(instruction, transactionMessage) {
  return prependTransactionMessageInstructions([instruction], transactionMessage);
}
function prependTransactionMessageInstructions(instructions, transactionMessage) {
  return Object.freeze({
    ...transactionMessage,
    instructions: Object.freeze([
      ...instructions,
      ...transactionMessage.instructions
    ])
  });
}
function getAccountMetas(message) {
  const { header } = message;
  const numWritableSignerAccounts = header.numSignerAccounts - header.numReadonlySignerAccounts;
  const numWritableNonSignerAccounts = message.staticAccounts.length - header.numSignerAccounts - header.numReadonlyNonSignerAccounts;
  const accountMetas = [];
  let accountIndex = 0;
  for (let i = 0;i < numWritableSignerAccounts; i++) {
    accountMetas.push({
      address: message.staticAccounts[accountIndex],
      role: AccountRole.WRITABLE_SIGNER
    });
    accountIndex++;
  }
  for (let i = 0;i < header.numReadonlySignerAccounts; i++) {
    accountMetas.push({
      address: message.staticAccounts[accountIndex],
      role: AccountRole.READONLY_SIGNER
    });
    accountIndex++;
  }
  for (let i = 0;i < numWritableNonSignerAccounts; i++) {
    accountMetas.push({
      address: message.staticAccounts[accountIndex],
      role: AccountRole.WRITABLE
    });
    accountIndex++;
  }
  for (let i = 0;i < header.numReadonlyNonSignerAccounts; i++) {
    accountMetas.push({
      address: message.staticAccounts[accountIndex],
      role: AccountRole.READONLY
    });
    accountIndex++;
  }
  return accountMetas;
}
function getAddressLookupMetas(compiledAddressTableLookups, addressesByLookupTableAddress) {
  const compiledAddressTableLookupAddresses = compiledAddressTableLookups.map((l) => l.lookupTableAddress);
  const missing = compiledAddressTableLookupAddresses.filter((a) => addressesByLookupTableAddress[a] === undefined);
  if (missing.length > 0) {
    throw new SolanaError(SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING, {
      lookupTableAddresses: missing
    });
  }
  const readOnlyMetas = [];
  const writableMetas = [];
  for (const lookup of compiledAddressTableLookups) {
    const addresses = addressesByLookupTableAddress[lookup.lookupTableAddress];
    const readonlyIndexes = lookup.readonlyIndexes;
    const writableIndexes = lookup.writableIndexes;
    const highestIndex = Math.max(...readonlyIndexes, ...writableIndexes);
    if (highestIndex >= addresses.length) {
      throw new SolanaError(SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE, {
        highestKnownIndex: addresses.length - 1,
        highestRequestedIndex: highestIndex,
        lookupTableAddress: lookup.lookupTableAddress
      });
    }
    const readOnlyForLookup = readonlyIndexes.map((r) => ({
      address: addresses[r],
      addressIndex: r,
      lookupTableAddress: lookup.lookupTableAddress,
      role: AccountRole.READONLY
    }));
    readOnlyMetas.push(...readOnlyForLookup);
    const writableForLookup = writableIndexes.map((w) => ({
      address: addresses[w],
      addressIndex: w,
      lookupTableAddress: lookup.lookupTableAddress,
      role: AccountRole.WRITABLE
    }));
    writableMetas.push(...writableForLookup);
  }
  return [...writableMetas, ...readOnlyMetas];
}
function convertInstruction(instruction, accountMetas) {
  const programAddress = accountMetas[instruction.programAddressIndex]?.address;
  if (!programAddress) {
    throw new SolanaError(SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND, {
      index: instruction.programAddressIndex
    });
  }
  const accounts = instruction.accountIndices?.map((accountIndex) => accountMetas[accountIndex]);
  const { data: data2 } = instruction;
  return Object.freeze({
    programAddress,
    ...accounts && accounts.length ? { accounts: Object.freeze(accounts) } : {},
    ...data2 && data2.length ? { data: data2 } : {}
  });
}
function getLifetimeConstraint(messageLifetimeToken, firstInstruction, lastValidBlockHeight) {
  if (!firstInstruction || !isAdvanceNonceAccountInstruction(firstInstruction)) {
    return {
      blockhash: messageLifetimeToken,
      lastValidBlockHeight: lastValidBlockHeight ?? 2n ** 64n - 1n
    };
  } else {
    const nonceAccountAddress = firstInstruction.accounts[0].address;
    assertIsAddress(nonceAccountAddress);
    const nonceAuthorityAddress = firstInstruction.accounts[2].address;
    assertIsAddress(nonceAuthorityAddress);
    return {
      nonce: messageLifetimeToken,
      nonceAccountAddress,
      nonceAuthorityAddress
    };
  }
}
function decompileTransactionMessage(compiledTransactionMessage, config) {
  const feePayer = compiledTransactionMessage.staticAccounts[0];
  if (!feePayer) {
    throw new SolanaError(SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING);
  }
  const accountMetas = getAccountMetas(compiledTransactionMessage);
  const accountLookupMetas = "addressTableLookups" in compiledTransactionMessage && compiledTransactionMessage.addressTableLookups !== undefined && compiledTransactionMessage.addressTableLookups.length > 0 ? getAddressLookupMetas(compiledTransactionMessage.addressTableLookups, config?.addressesByLookupTableAddress ?? {}) : [];
  const transactionMetas = [...accountMetas, ...accountLookupMetas];
  const instructions = compiledTransactionMessage.instructions.map((compiledInstruction) => convertInstruction(compiledInstruction, transactionMetas));
  const firstInstruction = instructions[0];
  const lifetimeConstraint = getLifetimeConstraint(compiledTransactionMessage.lifetimeToken, firstInstruction, config?.lastValidBlockHeight);
  return pipe(createTransactionMessage({ version: compiledTransactionMessage.version }), (m) => setTransactionMessageFeePayer(feePayer, m), (m) => instructions.reduce((acc, instruction) => appendTransactionMessageInstruction(instruction, acc), m), (m) => ("blockhash" in lifetimeConstraint) ? setTransactionMessageLifetimeUsingBlockhash(lifetimeConstraint, m) : setTransactionMessageLifetimeUsingDurableNonce(lifetimeConstraint, m));
}
var getBaseXEncoder2 = (alphabet4) => {
  return createEncoder({
    getSizeFromValue: (value) => {
      const [leadingZeroes, tailChars] = partitionLeadingZeroes2(value, alphabet4[0]);
      if (!tailChars)
        return value.length;
      const base10Number = getBigIntFromBaseX2(tailChars, alphabet4);
      return leadingZeroes.length + Math.ceil(base10Number.toString(16).length / 2);
    },
    write(value, bytes, offset) {
      assertValidBaseString2(alphabet4, value);
      if (value === "")
        return offset;
      const [leadingZeroes, tailChars] = partitionLeadingZeroes2(value, alphabet4[0]);
      if (!tailChars) {
        bytes.set(new Uint8Array(leadingZeroes.length).fill(0), offset);
        return offset + leadingZeroes.length;
      }
      let base10Number = getBigIntFromBaseX2(tailChars, alphabet4);
      const tailBytes = [];
      while (base10Number > 0n) {
        tailBytes.unshift(Number(base10Number % 256n));
        base10Number /= 256n;
      }
      const bytesToAdd = [...Array(leadingZeroes.length).fill(0), ...tailBytes];
      bytes.set(bytesToAdd, offset);
      return offset + bytesToAdd.length;
    }
  });
}, getBaseXDecoder2 = (alphabet4) => {
  return createDecoder({
    read(rawBytes, offset) {
      const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);
      if (bytes.length === 0)
        return ["", 0];
      let trailIndex = bytes.findIndex((n) => n !== 0);
      trailIndex = trailIndex === -1 ? bytes.length : trailIndex;
      const leadingZeroes = alphabet4[0].repeat(trailIndex);
      if (trailIndex === bytes.length)
        return [leadingZeroes, rawBytes.length];
      const base10Number = bytes.slice(trailIndex).reduce((sum, byte) => sum * 256n + BigInt(byte), 0n);
      const tailChars = getBaseXFromBigInt2(base10Number, alphabet4);
      return [leadingZeroes + tailChars, rawBytes.length];
    }
  });
}, alphabet22 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz", getBase58Encoder2 = () => getBaseXEncoder2(alphabet22), getBase58Decoder2 = () => getBaseXDecoder2(alphabet22), memoizedAddressTableLookupEncoder, memoizedAddressTableLookupDecoder, memoizedU8Encoder, memoizedU8Decoder, memoizedGetInstructionEncoder, memoizedGetInstructionDecoder, MAX_SUPPORTED_TRANSACTION_VERSION = 0, VERSION_FLAG_MASK = 128, TYPE2, RECENT_BLOCKHASHES_SYSVAR_ADDRESS = "SysvarRecentB1ockHashes11111111111111111111", SYSTEM_PROGRAM_ADDRESS2 = "11111111111111111111111111111111";
var init_index_node14 = __esm(() => {
  init_index_node();
  init_index_node11();
  init_index_node5();
  init_index_node2();
  init_index_node8();
  init_index_node7();
  init_index_node13();
  init_index_node12();
  TYPE2 = Symbol("AddressMapTypeProperty");
});

// ../node_modules/.bun/@solana+keys@5.1.0+7f9e3d21594a24ff/node_modules/@solana/keys/dist/index.node.mjs
function addPkcs8Header(bytes) {
  return new Uint8Array([
    48,
    46,
    2,
    1,
    0,
    48,
    5,
    6,
    3,
    43,
    101,
    112,
    4,
    34,
    4,
    32,
    ...bytes
  ]);
}
async function createPrivateKeyFromBytes(bytes, extractable = false) {
  const actualLength = bytes.byteLength;
  if (actualLength !== 32) {
    throw new SolanaError(SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH, {
      actualLength
    });
  }
  const privateKeyBytesPkcs8 = addPkcs8Header(bytes);
  return await crypto.subtle.importKey("pkcs8", privateKeyBytesPkcs8, ED25519_ALGORITHM_IDENTIFIER, extractable, [
    "sign"
  ]);
}
async function getPublicKeyFromPrivateKey(privateKey, extractable = false) {
  assertKeyExporterIsAvailable();
  if (privateKey.extractable === false) {
    throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY, { key: privateKey });
  }
  const jwk = await crypto.subtle.exportKey("jwk", privateKey);
  return await crypto.subtle.importKey("jwk", {
    crv: "Ed25519",
    ext: extractable,
    key_ops: ["verify"],
    kty: "OKP",
    x: jwk.x
  }, "Ed25519", extractable, ["verify"]);
}
function assertIsSignature(putativeSignature) {
  if (!base58Encoder)
    base58Encoder = getBase58Encoder();
  if (putativeSignature.length < 64 || putativeSignature.length > 88) {
    throw new SolanaError(SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE, {
      actualLength: putativeSignature.length
    });
  }
  const bytes = base58Encoder.encode(putativeSignature);
  assertIsSignatureBytes(bytes);
}
function assertIsSignatureBytes(putativeSignatureBytes) {
  const numBytes = putativeSignatureBytes.byteLength;
  if (numBytes !== 64) {
    throw new SolanaError(SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH, {
      actualLength: numBytes
    });
  }
}
function isSignature(putativeSignature) {
  if (!base58Encoder)
    base58Encoder = getBase58Encoder();
  if (putativeSignature.length < 64 || putativeSignature.length > 88) {
    return false;
  }
  const bytes = base58Encoder.encode(putativeSignature);
  return isSignatureBytes(bytes);
}
function isSignatureBytes(putativeSignatureBytes) {
  return putativeSignatureBytes.byteLength === 64;
}
async function signBytes(key, data2) {
  assertSigningCapabilityIsAvailable();
  const signedData = await crypto.subtle.sign(ED25519_ALGORITHM_IDENTIFIER, key, data2);
  return new Uint8Array(signedData);
}
function signature(putativeSignature) {
  assertIsSignature(putativeSignature);
  return putativeSignature;
}
function signatureBytes(putativeSignatureBytes) {
  assertIsSignatureBytes(putativeSignatureBytes);
  return putativeSignatureBytes;
}
async function verifySignature(key, signature2, data2) {
  assertVerificationCapabilityIsAvailable();
  return await crypto.subtle.verify(ED25519_ALGORITHM_IDENTIFIER, key, signature2, data2);
}
async function generateKeyPair() {
  await assertKeyGenerationIsAvailable();
  const keyPair = await crypto.subtle.generateKey(ED25519_ALGORITHM_IDENTIFIER, false, ["sign", "verify"]);
  return keyPair;
}
async function createKeyPairFromBytes(bytes, extractable = false) {
  assertPRNGIsAvailable();
  if (bytes.byteLength !== 64) {
    throw new SolanaError(SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH, { byteLength: bytes.byteLength });
  }
  const [publicKey, privateKey] = await Promise.all([
    crypto.subtle.importKey("raw", bytes.slice(32), ED25519_ALGORITHM_IDENTIFIER, true, [
      "verify"
    ]),
    createPrivateKeyFromBytes(bytes.slice(0, 32), extractable)
  ]);
  const randomBytes = new Uint8Array(32);
  crypto.getRandomValues(randomBytes);
  const signedData = await signBytes(privateKey, randomBytes);
  const isValid = await verifySignature(publicKey, signedData, randomBytes);
  if (!isValid) {
    throw new SolanaError(SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY);
  }
  return { privateKey, publicKey };
}
async function createKeyPairFromPrivateKeyBytes(bytes, extractable = false) {
  const privateKeyPromise = createPrivateKeyFromBytes(bytes, extractable);
  const [publicKey, privateKey] = await Promise.all([
    (extractable ? privateKeyPromise : createPrivateKeyFromBytes(bytes, true)).then(async (privateKey2) => await getPublicKeyFromPrivateKey(privateKey2, true)),
    privateKeyPromise
  ]);
  return { privateKey, publicKey };
}
var ED25519_ALGORITHM_IDENTIFIER, base58Encoder;
var init_index_node15 = __esm(() => {
  init_index_node4();
  init_index_node();
  init_index_node3();
  ED25519_ALGORITHM_IDENTIFIER = Object.freeze({ name: "Ed25519" });
});

// ../node_modules/.bun/@solana+transactions@5.1.0+7f9e3d21594a24ff/node_modules/@solana/transactions/dist/index.node.mjs
function getSignaturesToEncode(signaturesMap) {
  const signatures = Object.values(signaturesMap);
  if (signatures.length === 0) {
    throw new SolanaError(SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES);
  }
  return signatures.map((signature2) => {
    if (!signature2) {
      return new Uint8Array(64).fill(0);
    }
    return signature2;
  });
}
function getSignaturesEncoder() {
  return transformEncoder(getArrayEncoder(fixEncoderSize(getBytesEncoder(), 64), { size: getShortU16Encoder() }), getSignaturesToEncode);
}
function getTransactionEncoder() {
  return getStructEncoder([
    ["signatures", getSignaturesEncoder()],
    ["messageBytes", getBytesEncoder()]
  ]);
}
function getTransactionDecoder() {
  return transformDecoder(getStructDecoder([
    ["signatures", getArrayDecoder(fixDecoderSize(getBytesDecoder(), 64), { size: getShortU16Decoder() })],
    ["messageBytes", getBytesDecoder()]
  ]), decodePartiallyDecodedTransaction);
}
function getTransactionCodec() {
  return combineCodec(getTransactionEncoder(), getTransactionDecoder());
}
function decodePartiallyDecodedTransaction(transaction) {
  const { messageBytes, signatures } = transaction;
  const signerAddressesDecoder = getTupleDecoder([
    getTransactionVersionDecoder(),
    padRightDecoder(getU8Decoder(), 2),
    getArrayDecoder(getAddressDecoder(), { size: getShortU16Decoder() })
  ]);
  const [_txVersion, numRequiredSignatures, staticAddresses] = signerAddressesDecoder.decode(messageBytes);
  const signerAddresses = staticAddresses.slice(0, numRequiredSignatures);
  if (signerAddresses.length !== signatures.length) {
    throw new SolanaError(SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH, {
      numRequiredSignatures,
      signaturesLength: signatures.length,
      signerAddresses
    });
  }
  const signaturesMap = {};
  signerAddresses.forEach((address2, index) => {
    const signatureForAddress = signatures[index];
    if (signatureForAddress.every((b) => b === 0)) {
      signaturesMap[address2] = null;
    } else {
      signaturesMap[address2] = signatureForAddress;
    }
  });
  return {
    messageBytes,
    signatures: Object.freeze(signaturesMap)
  };
}
function compiledInstructionIsAdvanceNonceInstruction(instruction, staticAddresses) {
  return staticAddresses[instruction.programAddressIndex] === SYSTEM_PROGRAM_ADDRESS3 && instruction.data != null && isAdvanceNonceAccountInstructionData2(instruction.data) && instruction.accountIndices?.length === 3;
}
function isAdvanceNonceAccountInstructionData2(data2) {
  return data2.byteLength === 4 && data2[0] === 4 && data2[1] === 0 && data2[2] === 0 && data2[3] === 0;
}
async function getTransactionLifetimeConstraintFromCompiledTransactionMessage(compiledTransactionMessage) {
  const firstInstruction = compiledTransactionMessage.instructions[0];
  const { staticAccounts } = compiledTransactionMessage;
  if (firstInstruction && compiledInstructionIsAdvanceNonceInstruction(firstInstruction, staticAccounts)) {
    const nonceAccountAddress = staticAccounts[firstInstruction.accountIndices[0]];
    if (!nonceAccountAddress) {
      throw new SolanaError(SOLANA_ERROR__TRANSACTION__NONCE_ACCOUNT_CANNOT_BE_IN_LOOKUP_TABLE, {
        nonce: compiledTransactionMessage.lifetimeToken
      });
    }
    return {
      nonce: compiledTransactionMessage.lifetimeToken,
      nonceAccountAddress
    };
  } else {
    return {
      blockhash: compiledTransactionMessage.lifetimeToken,
      lastValidBlockHeight: 0xffffffffffffffffn
    };
  }
}
function isTransactionWithBlockhashLifetime(transaction) {
  return "lifetimeConstraint" in transaction && "blockhash" in transaction.lifetimeConstraint && typeof transaction.lifetimeConstraint.blockhash === "string" && typeof transaction.lifetimeConstraint.lastValidBlockHeight === "bigint" && isBlockhash(transaction.lifetimeConstraint.blockhash);
}
function assertIsTransactionWithBlockhashLifetime(transaction) {
  if (!isTransactionWithBlockhashLifetime(transaction)) {
    throw new SolanaError(SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME);
  }
}
function isTransactionWithDurableNonceLifetime(transaction) {
  return "lifetimeConstraint" in transaction && "nonce" in transaction.lifetimeConstraint && typeof transaction.lifetimeConstraint.nonce === "string" && typeof transaction.lifetimeConstraint.nonceAccountAddress === "string" && isAddress(transaction.lifetimeConstraint.nonceAccountAddress);
}
function assertIsTransactionWithDurableNonceLifetime(transaction) {
  if (!isTransactionWithDurableNonceLifetime(transaction)) {
    throw new SolanaError(SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME);
  }
}
function compileTransaction(transactionMessage) {
  const compiledMessage = compileTransactionMessage(transactionMessage);
  const messageBytes = getCompiledTransactionMessageEncoder().encode(compiledMessage);
  const transactionSigners = compiledMessage.staticAccounts.slice(0, compiledMessage.header.numSignerAccounts);
  const signatures = {};
  for (const signerAddress of transactionSigners) {
    signatures[signerAddress] = null;
  }
  let lifetimeConstraint;
  if (isTransactionMessageWithBlockhashLifetime(transactionMessage)) {
    lifetimeConstraint = {
      blockhash: transactionMessage.lifetimeConstraint.blockhash,
      lastValidBlockHeight: transactionMessage.lifetimeConstraint.lastValidBlockHeight
    };
  } else if (isTransactionMessageWithDurableNonceLifetime(transactionMessage)) {
    lifetimeConstraint = {
      nonce: transactionMessage.lifetimeConstraint.nonce,
      nonceAccountAddress: transactionMessage.instructions[0].accounts[0].address
    };
  }
  return Object.freeze({
    ...lifetimeConstraint ? { lifetimeConstraint } : undefined,
    messageBytes,
    signatures: Object.freeze(signatures)
  });
}
function getSignatureFromTransaction(transaction) {
  if (!base58Decoder)
    base58Decoder = getBase58Decoder();
  const signatureBytes2 = Object.values(transaction.signatures)[0];
  if (!signatureBytes2) {
    throw new SolanaError(SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING);
  }
  const transactionSignature = base58Decoder.decode(signatureBytes2);
  return transactionSignature;
}
async function partiallySignTransaction(keyPairs, transaction) {
  let newSignatures;
  let unexpectedSigners;
  await Promise.all(keyPairs.map(async (keyPair) => {
    const address2 = await getAddressFromPublicKey(keyPair.publicKey);
    const existingSignature = transaction.signatures[address2];
    if (existingSignature === undefined) {
      unexpectedSigners ||= /* @__PURE__ */ new Set;
      unexpectedSigners.add(address2);
      return;
    }
    if (unexpectedSigners) {
      return;
    }
    const newSignature = await signBytes(keyPair.privateKey, transaction.messageBytes);
    if (existingSignature !== null && bytesEqual(newSignature, existingSignature)) {
      return;
    }
    newSignatures ||= {};
    newSignatures[address2] = newSignature;
  }));
  if (unexpectedSigners && unexpectedSigners.size > 0) {
    const expectedSigners = Object.keys(transaction.signatures);
    throw new SolanaError(SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION, {
      expectedAddresses: expectedSigners,
      unexpectedAddresses: [...unexpectedSigners]
    });
  }
  if (!newSignatures) {
    return transaction;
  }
  return Object.freeze({
    ...transaction,
    signatures: Object.freeze({
      ...transaction.signatures,
      ...newSignatures
    })
  });
}
async function signTransaction(keyPairs, transaction) {
  const out = await partiallySignTransaction(keyPairs, transaction);
  assertIsFullySignedTransaction(out);
  Object.freeze(out);
  return out;
}
function isFullySignedTransaction(transaction) {
  return Object.entries(transaction.signatures).every(([_, signatureBytes2]) => !!signatureBytes2);
}
function assertIsFullySignedTransaction(transaction) {
  const missingSigs = [];
  Object.entries(transaction.signatures).forEach(([address2, signatureBytes2]) => {
    if (!signatureBytes2) {
      missingSigs.push(address2);
    }
  });
  if (missingSigs.length > 0) {
    throw new SolanaError(SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING, {
      addresses: missingSigs
    });
  }
}
function getBase64EncodedWireTransaction(transaction) {
  const wireTransactionBytes = getTransactionEncoder().encode(transaction);
  return getBase64Decoder().decode(wireTransactionBytes);
}
function getTransactionSize(transaction) {
  return getTransactionEncoder().getSizeFromValue(transaction);
}
function isTransactionWithinSizeLimit(transaction) {
  return getTransactionSize(transaction) <= TRANSACTION_SIZE_LIMIT;
}
function assertIsTransactionWithinSizeLimit(transaction) {
  const transactionSize = getTransactionSize(transaction);
  if (transactionSize > TRANSACTION_SIZE_LIMIT) {
    throw new SolanaError(SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT, {
      transactionSize,
      transactionSizeLimit: TRANSACTION_SIZE_LIMIT
    });
  }
}
function isSendableTransaction(transaction) {
  return isFullySignedTransaction(transaction) && isTransactionWithinSizeLimit(transaction);
}
function assertIsSendableTransaction(transaction) {
  assertIsFullySignedTransaction(transaction);
  assertIsTransactionWithinSizeLimit(transaction);
}
function getTransactionMessageSize(transactionMessage) {
  return getTransactionSize(compileTransaction(transactionMessage));
}
function isTransactionMessageWithinSizeLimit(transactionMessage) {
  return getTransactionMessageSize(transactionMessage) <= TRANSACTION_SIZE_LIMIT;
}
function assertIsTransactionMessageWithinSizeLimit(transactionMessage) {
  const transactionSize = getTransactionMessageSize(transactionMessage);
  if (transactionSize > TRANSACTION_SIZE_LIMIT) {
    throw new SolanaError(SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT, {
      transactionSize,
      transactionSizeLimit: TRANSACTION_SIZE_LIMIT
    });
  }
}
var SYSTEM_PROGRAM_ADDRESS3 = "11111111111111111111111111111111", base58Decoder, TRANSACTION_PACKET_SIZE = 1280, TRANSACTION_PACKET_HEADER, TRANSACTION_SIZE_LIMIT;
var init_index_node16 = __esm(() => {
  init_index_node5();
  init_index_node2();
  init_index_node8();
  init_index_node7();
  init_index_node();
  init_index_node14();
  init_index_node11();
  init_index_node3();
  init_index_node15();
  TRANSACTION_PACKET_HEADER = 40 + 8;
  TRANSACTION_SIZE_LIMIT = TRANSACTION_PACKET_SIZE - TRANSACTION_PACKET_HEADER;
});

// ../node_modules/.bun/@solana+promises@5.1.0+1fb4c65d43e298b9/node_modules/@solana/promises/dist/index.node.mjs
function isObject(value) {
  return value !== null && (typeof value === "object" || typeof value === "function");
}
function addRaceContender(contender) {
  const deferreds = /* @__PURE__ */ new Set;
  const record = { deferreds, settled: false };
  Promise.resolve(contender).then((value) => {
    for (const { resolve } of deferreds) {
      resolve(value);
    }
    deferreds.clear();
    record.settled = true;
  }, (err) => {
    for (const { reject } of deferreds) {
      reject(err);
    }
    deferreds.clear();
    record.settled = true;
  });
  return record;
}
async function safeRace(contenders) {
  let deferred;
  const result = new Promise((resolve, reject) => {
    deferred = { reject, resolve };
    for (const contender of contenders) {
      if (!isObject(contender)) {
        Promise.resolve(contender).then(resolve, reject);
        continue;
      }
      let record = wm.get(contender);
      if (record === undefined) {
        record = addRaceContender(contender);
        record.deferreds.add(deferred);
        wm.set(contender, record);
      } else if (record.settled) {
        Promise.resolve(contender).then(resolve, reject);
      } else {
        record.deferreds.add(deferred);
      }
    }
  });
  return await result.finally(() => {
    for (const contender of contenders) {
      if (isObject(contender)) {
        const record = wm.get(contender);
        record.deferreds.delete(deferred);
      }
    }
  });
}
function getAbortablePromise(promise, abortSignal) {
  if (!abortSignal) {
    return promise;
  } else {
    return safeRace([
      new Promise((_, reject) => {
        if (abortSignal.aborted) {
          reject(abortSignal.reason);
        } else {
          abortSignal.addEventListener("abort", function() {
            reject(this.reason);
          });
        }
      }),
      promise
    ]);
  }
}
var wm;
var init_index_node17 = __esm(() => {
  wm = /* @__PURE__ */ new WeakMap;
});

// ../node_modules/.bun/@solana+instruction-plans@5.1.0+7f9e3d21594a24ff/node_modules/@solana/instruction-plans/dist/index.node.mjs
function parallelInstructionPlan(plans) {
  return Object.freeze({
    kind: "parallel",
    plans: parseSingleInstructionPlans(plans)
  });
}
function sequentialInstructionPlan(plans) {
  return Object.freeze({
    divisible: true,
    kind: "sequential",
    plans: parseSingleInstructionPlans(plans)
  });
}
function nonDivisibleSequentialInstructionPlan(plans) {
  return Object.freeze({
    divisible: false,
    kind: "sequential",
    plans: parseSingleInstructionPlans(plans)
  });
}
function singleInstructionPlan(instruction) {
  return Object.freeze({ instruction, kind: "single" });
}
function parseSingleInstructionPlans(plans) {
  return plans.map((plan) => ("kind" in plan) ? plan : singleInstructionPlan(plan));
}
function getLinearMessagePackerInstructionPlan({
  getInstruction,
  totalLength: totalBytes
}) {
  return Object.freeze({
    getMessagePacker: () => {
      let offset = 0;
      return Object.freeze({
        done: () => offset >= totalBytes,
        packMessageToCapacity: (message) => {
          if (offset >= totalBytes) {
            throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_PACKER_ALREADY_COMPLETE);
          }
          const messageSizeWithBaseInstruction = getTransactionMessageSize(appendTransactionMessageInstruction(getInstruction(offset, 0), message));
          const freeSpace = TRANSACTION_SIZE_LIMIT - messageSizeWithBaseInstruction - 1;
          if (freeSpace <= 0) {
            const messageSize = getTransactionMessageSize(message);
            throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN, {
              numBytesRequired: messageSizeWithBaseInstruction - messageSize + 1,
              numFreeBytes: TRANSACTION_SIZE_LIMIT - messageSize - 1
            });
          }
          const length = Math.min(totalBytes - offset, freeSpace);
          const instruction = getInstruction(offset, length);
          offset += length;
          return appendTransactionMessageInstruction(instruction, message);
        }
      });
    },
    kind: "messagePacker"
  });
}
function getMessagePackerInstructionPlanFromInstructions(instructions) {
  return Object.freeze({
    getMessagePacker: () => {
      let instructionIndex = 0;
      return Object.freeze({
        done: () => instructionIndex >= instructions.length,
        packMessageToCapacity: (message) => {
          if (instructionIndex >= instructions.length) {
            throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_PACKER_ALREADY_COMPLETE);
          }
          const originalMessageSize = getTransactionMessageSize(message);
          for (let index = instructionIndex;index < instructions.length; index++) {
            message = appendTransactionMessageInstruction(instructions[index], message);
            const messageSize = getTransactionMessageSize(message);
            if (messageSize > TRANSACTION_SIZE_LIMIT) {
              if (index === instructionIndex) {
                throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN, {
                  numBytesRequired: messageSize - originalMessageSize,
                  numFreeBytes: TRANSACTION_SIZE_LIMIT - originalMessageSize
                });
              }
              instructionIndex = index;
              return message;
            }
          }
          instructionIndex = instructions.length;
          return message;
        }
      });
    },
    kind: "messagePacker"
  });
}
function getReallocMessagePackerInstructionPlan({
  getInstruction,
  totalSize
}) {
  const numberOfInstructions = Math.ceil(totalSize / REALLOC_LIMIT);
  const lastInstructionSize = totalSize % REALLOC_LIMIT;
  const instructions = new Array(numberOfInstructions).fill(0).map((_, i) => getInstruction(i === numberOfInstructions - 1 ? lastInstructionSize : REALLOC_LIMIT));
  return getMessagePackerInstructionPlanFromInstructions(instructions);
}
function sequentialTransactionPlanResult(plans) {
  return Object.freeze({ divisible: true, kind: "sequential", plans });
}
function nonDivisibleSequentialTransactionPlanResult(plans) {
  return Object.freeze({ divisible: false, kind: "sequential", plans });
}
function parallelTransactionPlanResult(plans) {
  return Object.freeze({ kind: "parallel", plans });
}
function successfulSingleTransactionPlanResult(transactionMessage, transaction, context) {
  return Object.freeze({
    kind: "single",
    message: transactionMessage,
    status: Object.freeze({
      context: context ?? {},
      kind: "successful",
      signature: getSignatureFromTransaction(transaction),
      transaction
    })
  });
}
function successfulSingleTransactionPlanResultFromSignature(transactionMessage, signature2, context) {
  return Object.freeze({
    kind: "single",
    message: transactionMessage,
    status: Object.freeze({ context: context ?? {}, kind: "successful", signature: signature2 })
  });
}
function failedSingleTransactionPlanResult(transactionMessage, error) {
  return Object.freeze({
    kind: "single",
    message: transactionMessage,
    status: Object.freeze({ error, kind: "failed" })
  });
}
function canceledSingleTransactionPlanResult(transactionMessage) {
  return Object.freeze({
    kind: "single",
    message: transactionMessage,
    status: Object.freeze({ kind: "canceled" })
  });
}
function flattenTransactionPlanResult(result) {
  const transactionPlanResults = [];
  function traverse3(result2) {
    if (result2.kind === "single") {
      transactionPlanResults.push(result2);
    } else {
      for (const subResult of result2.plans) {
        traverse3(subResult);
      }
    }
  }
  traverse3(result);
  return transactionPlanResults;
}
function summarizeTransactionPlanResult(result) {
  const successfulTransactions = [];
  const failedTransactions = [];
  const canceledTransactions = [];
  const flattenedResults = flattenTransactionPlanResult(result);
  for (const singleResult of flattenedResults) {
    switch (singleResult.status.kind) {
      case "successful": {
        successfulTransactions.push(singleResult);
        break;
      }
      case "failed": {
        failedTransactions.push(singleResult);
        break;
      }
      case "canceled": {
        canceledTransactions.push(singleResult);
        break;
      }
    }
  }
  return Object.freeze({
    canceledTransactions,
    failedTransactions,
    successful: failedTransactions.length === 0 && canceledTransactions.length === 0,
    successfulTransactions
  });
}
function createTransactionPlanExecutor(config) {
  return async (plan, { abortSignal } = {}) => {
    const context = {
      ...config,
      abortSignal,
      canceled: abortSignal?.aborted ?? false
    };
    const cancelHandler = () => {
      context.canceled = true;
    };
    abortSignal?.addEventListener("abort", cancelHandler);
    const transactionPlanResult = await traverse(plan, context);
    abortSignal?.removeEventListener("abort", cancelHandler);
    if (context.canceled) {
      const abortReason = abortSignal?.aborted ? abortSignal.reason : undefined;
      const context2 = { cause: findErrorFromTransactionPlanResult(transactionPlanResult) ?? abortReason };
      Object.defineProperty(context2, "transactionPlanResult", {
        configurable: false,
        enumerable: false,
        value: transactionPlanResult,
        writable: false
      });
      throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_TO_EXECUTE_TRANSACTION_PLAN, context2);
    }
    return transactionPlanResult;
  };
}
async function traverse(transactionPlan, context) {
  const kind = transactionPlan.kind;
  switch (kind) {
    case "sequential":
      return await traverseSequential(transactionPlan, context);
    case "parallel":
      return await traverseParallel(transactionPlan, context);
    case "single":
      return await traverseSingle(transactionPlan, context);
    default:
      throw new SolanaError(SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_TRANSACTION_PLAN_KIND, { kind });
  }
}
async function traverseSequential(transactionPlan, context) {
  const results = [];
  for (const subPlan of transactionPlan.plans) {
    const result = await traverse(subPlan, context);
    results.push(result);
  }
  return transactionPlan.divisible ? sequentialTransactionPlanResult(results) : nonDivisibleSequentialTransactionPlanResult(results);
}
async function traverseParallel(transactionPlan, context) {
  const results = await Promise.all(transactionPlan.plans.map((plan) => traverse(plan, context)));
  return parallelTransactionPlanResult(results);
}
async function traverseSingle(transactionPlan, context) {
  if (context.canceled) {
    return canceledSingleTransactionPlanResult(transactionPlan.message);
  }
  try {
    const result = await getAbortablePromise(context.executeTransactionMessage(transactionPlan.message, { abortSignal: context.abortSignal }), context.abortSignal);
    if ("transaction" in result) {
      return successfulSingleTransactionPlanResult(transactionPlan.message, result.transaction, result.context);
    } else {
      return successfulSingleTransactionPlanResultFromSignature(transactionPlan.message, result.signature, result.context);
    }
  } catch (error) {
    context.canceled = true;
    return failedSingleTransactionPlanResult(transactionPlan.message, error);
  }
}
function findErrorFromTransactionPlanResult(result) {
  if (result.kind === "single") {
    return result.status.kind === "failed" ? result.status.error : undefined;
  }
  for (const plan of result.plans) {
    const error = findErrorFromTransactionPlanResult(plan);
    if (error) {
      return error;
    }
  }
}
function parallelTransactionPlan(plans) {
  return Object.freeze({ kind: "parallel", plans: parseSingleTransactionPlans(plans) });
}
function sequentialTransactionPlan(plans) {
  return Object.freeze({ divisible: true, kind: "sequential", plans: parseSingleTransactionPlans(plans) });
}
function nonDivisibleSequentialTransactionPlan(plans) {
  return Object.freeze({ divisible: false, kind: "sequential", plans: parseSingleTransactionPlans(plans) });
}
function singleTransactionPlan(transactionMessage) {
  return Object.freeze({ kind: "single", message: transactionMessage });
}
function parseSingleTransactionPlans(plans) {
  return plans.map((plan) => ("kind" in plan) ? plan : singleTransactionPlan(plan));
}
function getAllSingleTransactionPlans(transactionPlan) {
  if (transactionPlan.kind === "single") {
    return [transactionPlan];
  }
  return transactionPlan.plans.flatMap(getAllSingleTransactionPlans);
}
function createTransactionPlanner(config) {
  return async (instructionPlan, { abortSignal } = {}) => {
    const plan = await traverse2(instructionPlan, {
      abortSignal,
      createTransactionMessage: config.createTransactionMessage,
      onTransactionMessageUpdated: config.onTransactionMessageUpdated ?? ((msg) => msg),
      parent: null,
      parentCandidates: []
    });
    if (!plan) {
      throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__EMPTY_INSTRUCTION_PLAN);
    }
    return freezeTransactionPlan(plan);
  };
}
async function traverse2(instructionPlan, context) {
  context.abortSignal?.throwIfAborted();
  const kind = instructionPlan.kind;
  switch (kind) {
    case "sequential":
      return await traverseSequential2(instructionPlan, context);
    case "parallel":
      return await traverseParallel2(instructionPlan, context);
    case "single":
      return await traverseSingle2(instructionPlan, context);
    case "messagePacker":
      return await traverseMessagePacker(instructionPlan, context);
    default:
      throw new SolanaError(SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_INSTRUCTION_PLAN_KIND, { kind });
  }
}
async function traverseSequential2(instructionPlan, context) {
  let candidate = null;
  const mustEntirelyFitInParentCandidate = context.parent && (context.parent.kind === "parallel" || !instructionPlan.divisible);
  if (mustEntirelyFitInParentCandidate) {
    const candidate2 = await selectAndMutateCandidate(context, context.parentCandidates, (message) => fitEntirePlanInsideMessage(instructionPlan, message));
    if (candidate2) {
      return null;
    }
  } else {
    candidate = context.parentCandidates.length > 0 ? context.parentCandidates[0] : null;
  }
  const transactionPlans = [];
  for (const plan of instructionPlan.plans) {
    const transactionPlan = await traverse2(plan, {
      ...context,
      parent: instructionPlan,
      parentCandidates: candidate ? [candidate] : []
    });
    if (transactionPlan) {
      candidate = getSequentialCandidate(transactionPlan);
      const newPlans = transactionPlan.kind === "sequential" && (transactionPlan.divisible || !instructionPlan.divisible) ? transactionPlan.plans : [transactionPlan];
      transactionPlans.push(...newPlans);
    }
  }
  if (transactionPlans.length === 1) {
    return transactionPlans[0];
  }
  if (transactionPlans.length === 0) {
    return null;
  }
  return {
    divisible: instructionPlan.divisible,
    kind: "sequential",
    plans: transactionPlans
  };
}
async function traverseParallel2(instructionPlan, context) {
  const candidates = [...context.parentCandidates];
  const transactionPlans = [];
  const sortedChildren = Array.from(instructionPlan.plans).sort((a, b) => Number(a.kind === "messagePacker") - Number(b.kind === "messagePacker"));
  for (const plan of sortedChildren) {
    const transactionPlan = await traverse2(plan, {
      ...context,
      parent: instructionPlan,
      parentCandidates: candidates
    });
    if (transactionPlan) {
      candidates.push(...getParallelCandidates(transactionPlan));
      const newPlans = transactionPlan.kind === "parallel" ? transactionPlan.plans : [transactionPlan];
      transactionPlans.push(...newPlans);
    }
  }
  if (transactionPlans.length === 1) {
    return transactionPlans[0];
  }
  if (transactionPlans.length === 0) {
    return null;
  }
  return { kind: "parallel", plans: transactionPlans };
}
async function traverseSingle2(instructionPlan, context) {
  const predicate = (message2) => appendTransactionMessageInstructions([instructionPlan.instruction], message2);
  const candidate = await selectAndMutateCandidate(context, context.parentCandidates, predicate);
  if (candidate) {
    return null;
  }
  const message = await createNewMessage(context, predicate);
  return { kind: "single", message };
}
async function traverseMessagePacker(instructionPlan, context) {
  const messagePacker = instructionPlan.getMessagePacker();
  const transactionPlans = [];
  const candidates = [...context.parentCandidates];
  while (!messagePacker.done()) {
    const candidate = await selectAndMutateCandidate(context, candidates, messagePacker.packMessageToCapacity);
    if (!candidate) {
      const message = await createNewMessage(context, messagePacker.packMessageToCapacity);
      const newPlan = { kind: "single", message };
      transactionPlans.push(newPlan);
    }
  }
  if (transactionPlans.length === 1) {
    return transactionPlans[0];
  }
  if (transactionPlans.length === 0) {
    return null;
  }
  if (context.parent?.kind === "parallel") {
    return { kind: "parallel", plans: transactionPlans };
  }
  return {
    divisible: context.parent?.kind === "sequential" ? context.parent.divisible : true,
    kind: "sequential",
    plans: transactionPlans
  };
}
function getSequentialCandidate(latestPlan) {
  if (latestPlan.kind === "single") {
    return latestPlan;
  }
  if (latestPlan.kind === "sequential" && latestPlan.plans.length > 0) {
    return getSequentialCandidate(latestPlan.plans[latestPlan.plans.length - 1]);
  }
  return null;
}
function getParallelCandidates(latestPlan) {
  return getAllSingleTransactionPlans(latestPlan);
}
async function selectAndMutateCandidate(context, candidates, predicate) {
  for (const candidate of candidates) {
    try {
      const message = await getAbortablePromise(Promise.resolve(context.onTransactionMessageUpdated(predicate(candidate.message), {
        abortSignal: context.abortSignal
      })), context.abortSignal);
      if (getTransactionMessageSize(message) <= TRANSACTION_SIZE_LIMIT) {
        candidate.message = message;
        return candidate;
      }
    } catch (error) {
      if (isSolanaError(error, SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN))
        ;
      else {
        throw error;
      }
    }
  }
  return null;
}
async function createNewMessage(context, predicate) {
  const newMessage = await getAbortablePromise(Promise.resolve(context.createTransactionMessage({ abortSignal: context.abortSignal })), context.abortSignal);
  const updatedMessage = await getAbortablePromise(Promise.resolve(context.onTransactionMessageUpdated(predicate(newMessage), { abortSignal: context.abortSignal })), context.abortSignal);
  const updatedMessageSize = getTransactionMessageSize(updatedMessage);
  if (updatedMessageSize > TRANSACTION_SIZE_LIMIT) {
    const newMessageSize = getTransactionMessageSize(newMessage);
    throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN, {
      numBytesRequired: updatedMessageSize - newMessageSize,
      numFreeBytes: TRANSACTION_SIZE_LIMIT - newMessageSize
    });
  }
  return updatedMessage;
}
function freezeTransactionPlan(plan) {
  const kind = plan.kind;
  switch (kind) {
    case "single":
      return singleTransactionPlan(plan.message);
    case "sequential":
      return plan.divisible ? sequentialTransactionPlan(plan.plans.map(freezeTransactionPlan)) : nonDivisibleSequentialTransactionPlan(plan.plans.map(freezeTransactionPlan));
    case "parallel":
      return parallelTransactionPlan(plan.plans.map(freezeTransactionPlan));
    default:
      throw new SolanaError(SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_TRANSACTION_PLAN_KIND, { kind });
  }
}
function fitEntirePlanInsideMessage(instructionPlan, message) {
  let newMessage = message;
  const kind = instructionPlan.kind;
  switch (kind) {
    case "sequential":
    case "parallel":
      for (const plan of instructionPlan.plans) {
        newMessage = fitEntirePlanInsideMessage(plan, newMessage);
      }
      return newMessage;
    case "single":
      newMessage = appendTransactionMessageInstructions([instructionPlan.instruction], message);
      const newMessageSize = getTransactionMessageSize(newMessage);
      if (newMessageSize > TRANSACTION_SIZE_LIMIT) {
        const baseMessageSize = getTransactionMessageSize(message);
        throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN, {
          numBytesRequired: newMessageSize - baseMessageSize,
          numFreeBytes: TRANSACTION_SIZE_LIMIT - baseMessageSize
        });
      }
      return newMessage;
    case "messagePacker":
      const messagePacker = instructionPlan.getMessagePacker();
      while (!messagePacker.done()) {
        newMessage = messagePacker.packMessageToCapacity(message);
      }
      return newMessage;
    default:
      throw new SolanaError(SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_INSTRUCTION_PLAN_KIND, { kind });
  }
}
var REALLOC_LIMIT = 10240;
var init_index_node18 = __esm(() => {
  init_index_node();
  init_index_node14();
  init_index_node16();
  init_index_node17();
});

// ../node_modules/.bun/@solana+offchain-messages@5.1.0+7f9e3d21594a24ff/node_modules/@solana/offchain-messages/dist/index.node.mjs
function isOffchainMessageApplicationDomain(putativeApplicationDomain) {
  return isAddress(putativeApplicationDomain);
}
function assertIsOffchainMessageApplicationDomain(putativeApplicationDomain) {
  try {
    assertIsAddress(putativeApplicationDomain);
  } catch (error) {
    if (isSolanaError(error, SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE)) {
      throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__APPLICATION_DOMAIN_STRING_LENGTH_OUT_OF_RANGE, error.context);
    }
    if (isSolanaError(error, SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH)) {
      throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__INVALID_APPLICATION_DOMAIN_BYTE_LENGTH, error.context);
    }
    throw error;
  }
}
function offchainMessageApplicationDomain(putativeApplicationDomain) {
  assertIsOffchainMessageApplicationDomain(putativeApplicationDomain);
  return putativeApplicationDomain;
}
function getOffchainMessageApplicationDomainEncoder() {
  return transformEncoder(getAddressEncoder(), (putativeApplicationDomain) => offchainMessageApplicationDomain(putativeApplicationDomain));
}
function getOffchainMessageApplicationDomainDecoder() {
  return getAddressDecoder();
}
function getOffchainMessageApplicationDomainCodec() {
  return combineCodec(getOffchainMessageApplicationDomainEncoder(), getOffchainMessageApplicationDomainDecoder());
}
function getOffchainMessageSigningDomainDecoder() {
  return getConstantDecoder(OFFCHAIN_MESSAGE_SIGNING_DOMAIN_BYTES);
}
function getOffchainMessageSigningDomainEncoder() {
  return getConstantEncoder(OFFCHAIN_MESSAGE_SIGNING_DOMAIN_BYTES);
}
function getSigningDomainPrefixedDecoder(...fields) {
  return getHiddenPrefixDecoder(getStructDecoder(fields), [getOffchainMessageSigningDomainDecoder()]);
}
function getSigningDomainPrefixedEncoder(...fields) {
  return getHiddenPrefixEncoder(getStructEncoder(fields), [getOffchainMessageSigningDomainEncoder()]);
}
function getVersionTransformer(fixedVersion) {
  return (version) => {
    if (version > 1) {
      throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__VERSION_NUMBER_NOT_SUPPORTED, {
        unsupportedVersion: version
      });
    }
    if (fixedVersion != null && version !== fixedVersion) {
      throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__UNEXPECTED_VERSION, {
        actualVersion: version,
        expectedVersion: fixedVersion
      });
    }
    return version;
  };
}
function createOffchainMessagePreambleDecoder(version, ...fields) {
  return getSigningDomainPrefixedDecoder(["version", transformDecoder(getU8Decoder(), getVersionTransformer(version))], ...fields);
}
function createOffchainMessagePreambleEncoder(version, ...fields) {
  return getSigningDomainPrefixedEncoder(["version", transformEncoder(getU8Encoder(), getVersionTransformer(version))], ...fields);
}
function decodeRequiredSignatoryAddresses(bytes) {
  const { version, bytesAfterVersion } = getSigningDomainPrefixedDecoder(["version", transformDecoder(getU8Decoder(), getVersionTransformer())], ["bytesAfterVersion", getBytesDecoder()]).decode(bytes);
  return offsetDecoder(transformDecoder(getArrayDecoder(getAddressDecoder(), { size: getU8Decoder() }), (signatoryAddresses) => {
    if (signatoryAddresses.length === 0) {
      throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO);
    }
    return signatoryAddresses;
  }), {
    preOffset: ({ preOffset }) => preOffset + (version === 0 ? 32 + 1 : 0)
  }).decode(bytesAfterVersion);
}
function getSignatoriesComparator() {
  return (x, y) => {
    if (x.length !== y.length) {
      return x.length < y.length ? -1 : 1;
    }
    for (let ii = 0;ii < x.length; ii++) {
      if (x[ii] === y[ii]) {
        continue;
      } else {
        return x[ii] < y[ii] ? -1 : 1;
      }
    }
    return 0;
  };
}
function getSignaturesToEncode2(signaturesMap) {
  const signatures = Object.values(signaturesMap);
  if (signatures.length === 0) {
    throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_ENVELOPE_SIGNATURES_CANNOT_BE_ZERO);
  }
  return signatures.map((signature2) => {
    if (!signature2) {
      return new Uint8Array(64).fill(0);
    }
    return signature2;
  });
}
function getSignaturesEncoder2() {
  return transformEncoder(getArrayEncoder(fixEncoderSize(getBytesEncoder(), 64), { size: getU8Encoder() }), getSignaturesToEncode2);
}
function getOffchainMessageEnvelopeEncoder() {
  return transformEncoder(getStructEncoder([
    ["signatures", getSignaturesEncoder2()],
    ["content", getBytesEncoder()]
  ]), (envelope) => {
    const signaturesMapAddresses = Object.keys(envelope.signatures).map(address);
    if (signaturesMapAddresses.length === 0) {
      throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_ENVELOPE_SIGNATURES_CANNOT_BE_ZERO);
    }
    const signatoryAddresses = decodeAndValidateRequiredSignatoryAddresses(envelope.content);
    const missingRequiredSigners = [];
    const unexpectedSigners = [];
    for (const address2 of signatoryAddresses) {
      if (!signaturesMapAddresses.includes(address2)) {
        missingRequiredSigners.push(address2);
      }
    }
    for (const address2 of signaturesMapAddresses) {
      if (!signatoryAddresses.includes(address2)) {
        unexpectedSigners.push(address2);
      }
    }
    if (missingRequiredSigners.length || unexpectedSigners.length) {
      throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__ENVELOPE_SIGNERS_MISMATCH, {
        missingRequiredSigners,
        unexpectedSigners
      });
    }
    const orderedSignatureMap = {};
    for (const address2 of signatoryAddresses) {
      orderedSignatureMap[address2] = envelope.signatures[address2];
    }
    return {
      ...envelope,
      signatures: orderedSignatureMap
    };
  });
}
function getOffchainMessageEnvelopeDecoder() {
  return transformDecoder(getStructDecoder([
    ["signatures", getArrayDecoder(fixDecoderSize(getBytesDecoder(), 64), { size: getU8Decoder() })],
    ["content", getBytesDecoder()]
  ]), decodePartiallyDecodedOffchainMessageEnvelope);
}
function getOffchainMessageEnvelopeCodec() {
  return combineCodec(getOffchainMessageEnvelopeEncoder(), getOffchainMessageEnvelopeDecoder());
}
function decodePartiallyDecodedOffchainMessageEnvelope(offchainMessageEnvelope) {
  const { content, signatures } = offchainMessageEnvelope;
  if (signatures.length === 0) {
    throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_ENVELOPE_SIGNATURES_CANNOT_BE_ZERO);
  }
  const signatoryAddresses = decodeAndValidateRequiredSignatoryAddresses(content);
  if (signatoryAddresses.length !== signatures.length) {
    throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_SIGNATURES_MISMATCH, {
      numRequiredSignatures: signatoryAddresses.length,
      signatoryAddresses,
      signaturesLength: signatures.length
    });
  }
  const signaturesMap = {};
  signatoryAddresses.forEach((address2, index) => {
    const signatureForAddress = signatures[index];
    if (signatureForAddress.every((b) => b === 0)) {
      signaturesMap[address2] = null;
    } else {
      signaturesMap[address2] = signatureForAddress;
    }
  });
  return Object.freeze({
    content,
    signatures: Object.freeze(signaturesMap)
  });
}
function decodeAndValidateRequiredSignatoryAddresses(bytes) {
  const signatoryAddresses = decodeRequiredSignatoryAddresses(bytes);
  if (signatoryAddresses.length === 0) {
    throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO);
  }
  return signatoryAddresses;
}
function assertIsOffchainMessageContentRestrictedAsciiOf1232BytesMax(putativeContent) {
  if (putativeContent.format !== 0) {
    throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_FORMAT_MISMATCH, {
      actualMessageFormat: putativeContent.format,
      expectedMessageFormat: 0
    });
  }
  if (putativeContent.text.length === 0) {
    throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_MUST_BE_NON_EMPTY);
  }
  if (isTextRestrictedAscii(putativeContent.text) === false) {
    throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__RESTRICTED_ASCII_BODY_CHARACTER_OUT_OF_RANGE);
  }
  const length = getUtf8Encoder().getSizeFromValue(putativeContent.text);
  if (length > MAX_BODY_BYTES_HARDWARE_WALLET_SIGNABLE) {
    throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__MAXIMUM_LENGTH_EXCEEDED, {
      actualBytes: length,
      maxBytes: MAX_BODY_BYTES_HARDWARE_WALLET_SIGNABLE
    });
  }
}
function isOffchainMessageContentRestrictedAsciiOf1232BytesMax(putativeContent) {
  if (putativeContent.format !== 0 || putativeContent.text.length === 0 || isTextRestrictedAscii(putativeContent.text) === false) {
    return false;
  }
  const length = getUtf8Encoder().getSizeFromValue(putativeContent.text);
  return length <= MAX_BODY_BYTES_HARDWARE_WALLET_SIGNABLE;
}
function offchainMessageContentRestrictedAsciiOf1232BytesMax(text) {
  const putativeContent = Object.freeze({
    format: 0,
    text
  });
  assertIsOffchainMessageContentRestrictedAsciiOf1232BytesMax(putativeContent);
  return putativeContent;
}
function assertIsOffchainMessageContentUtf8Of1232BytesMax(putativeContent) {
  if (putativeContent.text.length === 0) {
    throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_MUST_BE_NON_EMPTY);
  }
  if (putativeContent.format !== 1) {
    throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_FORMAT_MISMATCH, {
      actualMessageFormat: putativeContent.format,
      expectedMessageFormat: 1
    });
  }
  const length = getUtf8Encoder().getSizeFromValue(putativeContent.text);
  if (length > MAX_BODY_BYTES_HARDWARE_WALLET_SIGNABLE) {
    throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__MAXIMUM_LENGTH_EXCEEDED, {
      actualBytes: length,
      maxBytes: MAX_BODY_BYTES_HARDWARE_WALLET_SIGNABLE
    });
  }
}
function isOffchainMessageContentUtf8Of1232BytesMax(putativeContent) {
  if (putativeContent.format !== 1 || putativeContent.text.length === 0) {
    return false;
  }
  const length = getUtf8Encoder().getSizeFromValue(putativeContent.text);
  return length <= MAX_BODY_BYTES_HARDWARE_WALLET_SIGNABLE;
}
function offchainMessageContentUtf8Of1232BytesMax(text) {
  const putativeContent = Object.freeze({
    format: 1,
    text
  });
  assertIsOffchainMessageContentUtf8Of1232BytesMax(putativeContent);
  return putativeContent;
}
function assertIsOffchainMessageContentUtf8Of65535BytesMax(putativeContent) {
  if (putativeContent.format !== 2) {
    throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_FORMAT_MISMATCH, {
      actualMessageFormat: putativeContent.format,
      expectedMessageFormat: 2
    });
  }
  if (putativeContent.text.length === 0) {
    throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_MUST_BE_NON_EMPTY);
  }
  const length = getUtf8Encoder().getSizeFromValue(putativeContent.text);
  if (length > MAX_BODY_BYTES) {
    throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__MAXIMUM_LENGTH_EXCEEDED, {
      actualBytes: length,
      maxBytes: MAX_BODY_BYTES
    });
  }
}
function isOffchainMessageContentUtf8Of65535BytesMax(putativeContent) {
  if (putativeContent.format !== 2 || putativeContent.text.length === 0) {
    return false;
  }
  const length = getUtf8Encoder().getSizeFromValue(putativeContent.text);
  return length <= MAX_BODY_BYTES;
}
function offchainMessageContentUtf8Of65535BytesMax(text) {
  const putativeContent = Object.freeze({
    format: 2,
    text
  });
  assertIsOffchainMessageContentUtf8Of65535BytesMax(putativeContent);
  return putativeContent;
}
function isTextRestrictedAscii(putativeRestrictedAsciiString) {
  return /^[\x20-\x7e]+$/.test(putativeRestrictedAsciiString);
}
function assertIsOffchainMessageRestrictedAsciiOf1232BytesMax(putativeMessage) {
  assertIsOffchainMessageContentRestrictedAsciiOf1232BytesMax(putativeMessage.content);
}
function assertIsOffchainMessageUtf8Of1232BytesMax(putativeMessage) {
  assertIsOffchainMessageContentUtf8Of1232BytesMax(putativeMessage.content);
}
function assertIsOffchainMessageUtf8Of65535BytesMax(putativeMessage) {
  assertIsOffchainMessageContentUtf8Of65535BytesMax(putativeMessage.content);
}
function getOffchainMessageContentFormatDecoder() {
  return getEnumDecoder(OffchainMessageContentFormat, {
    useValuesAsDiscriminators: true
  });
}
function getOffchainMessageContentFormatEncoder() {
  return getEnumEncoder(OffchainMessageContentFormat, {
    useValuesAsDiscriminators: true
  });
}
function getOffchainMessageV0PreambleDecoder() {
  return createOffchainMessagePreambleDecoder(0, ["applicationDomain", getOffchainMessageApplicationDomainDecoder()], ["messageFormat", getOffchainMessageContentFormatDecoder()], [
    "requiredSignatories",
    transformDecoder(getArrayDecoder(getAddressDecoder(), { size: getU8Decoder() }), (signatoryAddresses) => {
      if (signatoryAddresses.length === 0) {
        throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO);
      }
      return signatoryAddresses.map((address2) => Object.freeze({ address: address2 }));
    })
  ], ["messageLength", getU16Decoder()]);
}
function getOffchainMessageV0PreambleEncoder() {
  return createOffchainMessagePreambleEncoder(0, ["applicationDomain", getOffchainMessageApplicationDomainEncoder()], ["messageFormat", getOffchainMessageContentFormatEncoder()], [
    "requiredSignatories",
    transformEncoder(getArrayEncoder(getAddressEncoder(), { size: getU8Encoder() }), (signatoryAddresses) => {
      if (signatoryAddresses.length === 0) {
        throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO);
      }
      return signatoryAddresses.map(({ address: address2 }) => address2);
    })
  ], ["messageLength", getU16Encoder()]);
}
function getOffchainMessageV0Decoder() {
  return transformDecoder(getTupleDecoder([getOffchainMessageV0PreambleDecoder(), getUtf8Decoder()]), ([{ messageLength, messageFormat, requiredSignatories, ...preambleRest }, text]) => {
    const actualLength = getUtf8Encoder().getSizeFromValue(text);
    if (messageLength !== actualLength) {
      throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_LENGTH_MISMATCH, {
        actualLength,
        specifiedLength: messageLength
      });
    }
    const offchainMessage = Object.freeze({
      ...preambleRest,
      content: Object.freeze({
        format: messageFormat,
        text
      }),
      requiredSignatories: Object.freeze(requiredSignatories)
    });
    switch (messageFormat) {
      case 0: {
        assertIsOffchainMessageRestrictedAsciiOf1232BytesMax(offchainMessage);
        return offchainMessage;
      }
      case 1: {
        assertIsOffchainMessageUtf8Of1232BytesMax(offchainMessage);
        return offchainMessage;
      }
      case 2: {
        assertIsOffchainMessageUtf8Of65535BytesMax(offchainMessage);
        return offchainMessage;
      }
      default: {
        throw new SolanaError(SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE, {
          unexpectedValue: messageFormat
        });
      }
    }
  });
}
function getOffchainMessageV0Encoder() {
  return transformEncoder(getTupleEncoder([getOffchainMessageV0PreambleEncoder(), getUtf8Encoder()]), (offchainMessage) => {
    const { content, ...preamble } = offchainMessage;
    switch (offchainMessage.content.format) {
      case 0: {
        assertIsOffchainMessageRestrictedAsciiOf1232BytesMax(offchainMessage);
        break;
      }
      case 1: {
        assertIsOffchainMessageUtf8Of1232BytesMax(offchainMessage);
        break;
      }
      case 2: {
        assertIsOffchainMessageUtf8Of65535BytesMax(offchainMessage);
        break;
      }
      default: {
        throw new SolanaError(SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE, {
          unexpectedValue: offchainMessage.content
        });
      }
    }
    const messageLength = getUtf8Encoder().getSizeFromValue(content.text);
    const compiledPreamble = {
      ...preamble,
      messageFormat: content.format,
      messageLength
    };
    return [compiledPreamble, content.text];
  });
}
function getOffchainMessageV0Codec() {
  return combineCodec(getOffchainMessageV0Encoder(), getOffchainMessageV0Decoder());
}
function getOffchainMessageV1PreambleDecoder() {
  return createOffchainMessagePreambleDecoder(1, [
    "requiredSignatories",
    transformDecoder(getArrayDecoder(fixDecoderSize(getBytesDecoder(), 32), { size: getU8Decoder() }), (signatoryAddressesBytes) => {
      if (signatoryAddressesBytes.length === 0) {
        throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO);
      }
      const comparator = getSignatoriesComparator();
      for (let ii = 0;ii < signatoryAddressesBytes.length - 1; ii++) {
        switch (comparator(signatoryAddressesBytes[ii], signatoryAddressesBytes[ii + 1])) {
          case 0:
            throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATORIES_MUST_BE_UNIQUE);
          case 1:
            throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATORIES_MUST_BE_SORTED);
        }
      }
      const addressDecoder = getAddressDecoder();
      return signatoryAddressesBytes.map((addressBytes) => Object.freeze({
        address: addressDecoder.decode(addressBytes)
      }));
    })
  ]);
}
function getOffchainMessageV1PreambleEncoder() {
  return createOffchainMessagePreambleEncoder(1, [
    "requiredSignatories",
    transformEncoder(transformEncoder(getArrayEncoder(getBytesEncoder(), { size: getU8Encoder() }), (signatoryAddressesBytes) => {
      return signatoryAddressesBytes.toSorted(getSignatoriesComparator());
    }), (signatoryAddresses) => {
      if (signatoryAddresses.length === 0) {
        throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO);
      }
      const seenSignatories = /* @__PURE__ */ new Set;
      for (const { address: address2 } of signatoryAddresses) {
        if (seenSignatories.has(address2)) {
          throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATORIES_MUST_BE_UNIQUE);
        }
        seenSignatories.add(address2);
      }
      const addressEncoder = getAddressEncoder();
      return signatoryAddresses.map(({ address: address2 }) => addressEncoder.encode(address2));
    })
  ]);
}
function getOffchainMessageV1Decoder() {
  return transformDecoder(getTupleDecoder([getOffchainMessageV1PreambleDecoder(), getUtf8Decoder()]), ([{ requiredSignatories, ...preambleRest }, text]) => {
    if (text.length === 0) {
      throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_MUST_BE_NON_EMPTY);
    }
    return Object.freeze({
      ...preambleRest,
      content: text,
      requiredSignatories: Object.freeze(requiredSignatories)
    });
  });
}
function getOffchainMessageV1Encoder() {
  return transformEncoder(getTupleEncoder([getOffchainMessageV1PreambleEncoder(), getUtf8Encoder()]), (offchainMessage) => {
    const { content, ...compiledPreamble } = offchainMessage;
    if (content.length === 0) {
      throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_MUST_BE_NON_EMPTY);
    }
    return [compiledPreamble, content];
  });
}
function getOffchainMessageV1Codec() {
  return combineCodec(getOffchainMessageV1Encoder(), getOffchainMessageV1Decoder());
}
function getOffchainMessageDecoder() {
  return createDecoder({
    read(bytes, offset) {
      const version = getHiddenPrefixDecoder(getU8Decoder(), [
        getOffchainMessageSigningDomainDecoder()
      ]).decode(bytes, offset);
      switch (version) {
        case 0:
          return getOffchainMessageV0Decoder().read(bytes, offset);
        case 1:
          return getOffchainMessageV1Decoder().read(bytes, offset);
        default:
          throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__VERSION_NUMBER_NOT_SUPPORTED, {
            unsupportedVersion: version
          });
      }
    }
  });
}
function getOffchainMessageEncoder() {
  return createEncoder({
    getSizeFromValue: (offchainMessage) => {
      const { version } = offchainMessage;
      switch (version) {
        case 0:
          return getOffchainMessageV0Encoder().getSizeFromValue(offchainMessage);
        case 1:
          return getOffchainMessageV1Encoder().getSizeFromValue(offchainMessage);
        default:
          throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__VERSION_NUMBER_NOT_SUPPORTED, {
            unsupportedVersion: version
          });
      }
    },
    write: (offchainMessage, bytes, offset) => {
      const { version } = offchainMessage;
      switch (version) {
        case 0:
          return getOffchainMessageV0Encoder().write(offchainMessage, bytes, offset);
        case 1:
          return getOffchainMessageV1Encoder().write(offchainMessage, bytes, offset);
        default:
          throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__VERSION_NUMBER_NOT_SUPPORTED, {
            unsupportedVersion: version
          });
      }
    }
  });
}
function getOffchainMessageCodec() {
  return combineCodec(getOffchainMessageEncoder(), getOffchainMessageDecoder());
}
function compileOffchainMessageEnvelopeUsingEncoder(offchainMessage, encoder2) {
  const offchainMessageBytes = encoder2.encode(offchainMessage);
  const signatures = {};
  for (const { address: address2 } of offchainMessage.requiredSignatories) {
    signatures[address2] = null;
  }
  return Object.freeze({
    content: offchainMessageBytes,
    signatures: Object.freeze(signatures)
  });
}
function compileOffchainMessageV0Envelope(offchainMessage) {
  return compileOffchainMessageEnvelopeUsingEncoder(offchainMessage, getOffchainMessageV0Encoder());
}
function compileOffchainMessageV1Envelope(offchainMessage) {
  return compileOffchainMessageEnvelopeUsingEncoder(offchainMessage, getOffchainMessageV1Encoder());
}
function compileOffchainMessageEnvelope(offchainMessage) {
  const { version } = offchainMessage;
  switch (version) {
    case 0:
      return compileOffchainMessageV0Envelope(offchainMessage);
    case 1:
      return compileOffchainMessageV1Envelope(offchainMessage);
    default:
      throw new SolanaError(SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE, {
        unexpectedValue: version
      });
  }
}
async function partiallySignOffchainMessageEnvelope(keyPairs, offchainMessageEnvelope) {
  let newSignatures;
  let unexpectedSigners;
  const requiredSignatoryAddresses = decodeRequiredSignatoryAddresses(offchainMessageEnvelope.content);
  await Promise.all(keyPairs.map(async (keyPair) => {
    const address2 = await getAddressFromPublicKey(keyPair.publicKey);
    if (!requiredSignatoryAddresses.includes(address2)) {
      unexpectedSigners ||= /* @__PURE__ */ new Set;
      unexpectedSigners.add(address2);
      return;
    }
    if (unexpectedSigners) {
      return;
    }
    const existingSignature = offchainMessageEnvelope.signatures[address2];
    const newSignature = await signBytes(keyPair.privateKey, offchainMessageEnvelope.content);
    if (existingSignature != null && bytesEqual(newSignature, existingSignature)) {
      return;
    }
    newSignatures ||= {};
    newSignatures[address2] = newSignature;
  }));
  if (unexpectedSigners && unexpectedSigners.size > 0) {
    throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__ADDRESSES_CANNOT_SIGN_OFFCHAIN_MESSAGE, {
      expectedAddresses: requiredSignatoryAddresses,
      unexpectedAddresses: [...unexpectedSigners]
    });
  }
  if (!newSignatures) {
    return offchainMessageEnvelope;
  }
  return Object.freeze({
    ...offchainMessageEnvelope,
    signatures: Object.freeze({
      ...offchainMessageEnvelope.signatures,
      ...newSignatures
    })
  });
}
async function signOffchainMessageEnvelope(keyPairs, offchainMessageEnvelope) {
  const out = await partiallySignOffchainMessageEnvelope(keyPairs, offchainMessageEnvelope);
  assertIsFullySignedOffchainMessageEnvelope(out);
  Object.freeze(out);
  return out;
}
function isFullySignedOffchainMessageEnvelope(offchainMessage) {
  return Object.entries(offchainMessage.signatures).every(([_, signatureBytes2]) => !!signatureBytes2);
}
function assertIsFullySignedOffchainMessageEnvelope(offchainMessage) {
  const missingSigs = [];
  Object.entries(offchainMessage.signatures).forEach(([address2, signatureBytes2]) => {
    if (!signatureBytes2) {
      missingSigs.push(address2);
    }
  });
  if (missingSigs.length > 0) {
    throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURES_MISSING, {
      addresses: missingSigs
    });
  }
}
async function verifyOffchainMessageEnvelope(offchainMessageEnvelope) {
  let errorContext;
  const requiredSignatories = decodeRequiredSignatoryAddresses(offchainMessageEnvelope.content);
  await Promise.all(requiredSignatories.map(async (address2) => {
    const signature2 = offchainMessageEnvelope.signatures[address2];
    if (signature2 == null) {
      errorContext ||= {};
      errorContext.signatoriesWithMissingSignatures ||= [];
      errorContext.signatoriesWithMissingSignatures.push(address2);
    } else {
      const publicKey = await getPublicKeyFromAddress(address2);
      if (await verifySignature(publicKey, signature2, offchainMessageEnvelope.content)) {
        return true;
      } else {
        errorContext ||= {};
        errorContext.signatoriesWithInvalidSignatures ||= [];
        errorContext.signatoriesWithInvalidSignatures.push(address2);
      }
    }
  }));
  if (errorContext) {
    throw new SolanaError(SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURE_VERIFICATION_FAILURE, errorContext);
  }
}
var OFFCHAIN_MESSAGE_SIGNING_DOMAIN_BYTES, MAX_BODY_BYTES = 65535, MAX_BODY_BYTES_HARDWARE_WALLET_SIGNABLE = 1232, OffchainMessageContentFormat;
var init_index_node19 = __esm(() => {
  init_index_node5();
  init_index_node();
  init_index_node2();
  init_index_node8();
  init_index_node7();
  init_index_node3();
  init_index_node15();
  OFFCHAIN_MESSAGE_SIGNING_DOMAIN_BYTES = new Uint8Array([
    255,
    115,
    111,
    108,
    97,
    110,
    97,
    32,
    111,
    102,
    102,
    99,
    104,
    97,
    105,
    110
  ]);
  OffchainMessageContentFormat = /* @__PURE__ */ ((OffchainMessageContentFormat3) => {
    OffchainMessageContentFormat3[OffchainMessageContentFormat3["RESTRICTED_ASCII_1232_BYTES_MAX"] = 0] = "RESTRICTED_ASCII_1232_BYTES_MAX";
    OffchainMessageContentFormat3[OffchainMessageContentFormat3["UTF8_1232_BYTES_MAX"] = 1] = "UTF8_1232_BYTES_MAX";
    OffchainMessageContentFormat3[OffchainMessageContentFormat3["UTF8_65535_BYTES_MAX"] = 2] = "UTF8_65535_BYTES_MAX";
    return OffchainMessageContentFormat3;
  })(OffchainMessageContentFormat || {});
});

// ../node_modules/.bun/@solana+programs@5.1.0+7f9e3d21594a24ff/node_modules/@solana/programs/dist/index.node.mjs
function isProgramError(error, transactionMessage, programAddress, code) {
  if (!isSolanaError(error, SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM)) {
    return false;
  }
  const instructionProgramAddress = transactionMessage.instructions[error.context.index]?.programAddress;
  if (!instructionProgramAddress || instructionProgramAddress !== programAddress) {
    return false;
  }
  return typeof code === "undefined" || error.context.code === code;
}
var init_index_node20 = __esm(() => {
  init_index_node();
});

// ../node_modules/.bun/@solana+rpc-spec-types@5.1.0+1fb4c65d43e298b9/node_modules/@solana/rpc-spec-types/dist/index.node.mjs
function parseJsonWithBigInts(json2) {
  return JSON.parse(wrapIntegersInBigIntValueObject(json2), (_, value) => {
    return isBigIntValueObject(value) ? unwrapBigIntValueObject(value) : value;
  });
}
function wrapIntegersInBigIntValueObject(json2) {
  const out = [];
  let inQuote = false;
  for (let ii = 0;ii < json2.length; ii++) {
    let isEscaped = false;
    if (json2[ii] === "\\") {
      out.push(json2[ii++]);
      isEscaped = !isEscaped;
    }
    if (json2[ii] === '"') {
      out.push(json2[ii]);
      if (!isEscaped) {
        inQuote = !inQuote;
      }
      continue;
    }
    if (!inQuote) {
      const consumedNumber = consumeNumber(json2, ii);
      if (consumedNumber?.length) {
        ii += consumedNumber.length - 1;
        if (consumedNumber.match(/\.|[eE]-/)) {
          out.push(consumedNumber);
        } else {
          out.push(wrapBigIntValueObject(consumedNumber));
        }
        continue;
      }
    }
    out.push(json2[ii]);
  }
  return out.join("");
}
function consumeNumber(json2, ii) {
  const JSON_NUMBER_REGEX = /^-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?/;
  if (!json2[ii]?.match(/[-\d]/)) {
    return null;
  }
  const numberMatch = json2.slice(ii).match(JSON_NUMBER_REGEX);
  return numberMatch ? numberMatch[0] : null;
}
function wrapBigIntValueObject(value) {
  return `{"$n":"${value}"}`;
}
function unwrapBigIntValueObject({ $n }) {
  if ($n.match(/[eE]/)) {
    const [units, exponent] = $n.split(/[eE]/);
    return BigInt(units) * BigInt(10) ** BigInt(exponent);
  }
  return BigInt($n);
}
function isBigIntValueObject(value) {
  return !!value && typeof value === "object" && "$n" in value && typeof value.$n === "string";
}
function getNextMessageId() {
  const id = _nextMessageId;
  _nextMessageId++;
  return id.toString();
}
function createRpcMessage(request) {
  return {
    id: getNextMessageId(),
    jsonrpc: "2.0",
    method: request.methodName,
    params: request.params
  };
}
function stringifyJsonWithBigInts(value, space) {
  return unwrapBigIntValueObject2(JSON.stringify(value, (_, v) => typeof v === "bigint" ? wrapBigIntValueObject2(v) : v, space));
}
function wrapBigIntValueObject2(value) {
  return { $n: `${value}` };
}
function unwrapBigIntValueObject2(value) {
  return value.replace(/\{\s*"\$n"\s*:\s*"(-?\d+)"\s*\}/g, "$1");
}
var _nextMessageId = 0n;
var init_index_node21 = () => {};

// ../node_modules/.bun/@solana+rpc-spec@5.1.0+1fb4c65d43e298b9/node_modules/@solana/rpc-spec/dist/index.node.mjs
function createRpc(rpcConfig) {
  return makeProxy(rpcConfig);
}
function makeProxy(rpcConfig) {
  return new Proxy(rpcConfig.api, {
    defineProperty() {
      return false;
    },
    deleteProperty() {
      return false;
    },
    get(target, p, receiver) {
      if (p === "then") {
        return;
      }
      return function(...rawParams) {
        const methodName = p.toString();
        const getApiPlan = Reflect.get(target, methodName, receiver);
        if (!getApiPlan) {
          throw new SolanaError(SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD, {
            method: methodName,
            params: rawParams
          });
        }
        const apiPlan = getApiPlan(...rawParams);
        return createPendingRpcRequest(rpcConfig, apiPlan);
      };
    }
  });
}
function createPendingRpcRequest({ transport }, plan) {
  return {
    async send(options2) {
      return await plan.execute({ signal: options2?.abortSignal, transport });
    }
  };
}
function createJsonRpcApi(config) {
  return new Proxy({}, {
    defineProperty() {
      return false;
    },
    deleteProperty() {
      return false;
    },
    get(...args) {
      const [_, p] = args;
      const methodName = p.toString();
      return function(...rawParams) {
        const rawRequest = Object.freeze({ methodName, params: rawParams });
        const request = config?.requestTransformer ? config?.requestTransformer(rawRequest) : rawRequest;
        return Object.freeze({
          execute: async ({ signal, transport }) => {
            const payload = createRpcMessage(request);
            const response = await transport({ payload, signal });
            if (!config?.responseTransformer) {
              return response;
            }
            return config.responseTransformer(response, request);
          }
        });
      };
    }
  });
}
function isJsonRpcPayload(payload) {
  if (payload == null || typeof payload !== "object" || Array.isArray(payload)) {
    return false;
  }
  return "jsonrpc" in payload && payload.jsonrpc === "2.0" && "method" in payload && typeof payload.method === "string" && "params" in payload;
}
var init_index_node22 = __esm(() => {
  init_index_node();
  init_index_node21();
});

// ../node_modules/.bun/@solana+rpc-transformers@5.1.0+7f9e3d21594a24ff/node_modules/@solana/rpc-transformers/dist/index.node.mjs
function downcastNodeToNumberIfBigint(value) {
  return typeof value === "bigint" ? Number(value) : value;
}
function getTreeWalker(visitors) {
  return function traverse(node, state) {
    if (Array.isArray(node)) {
      return node.map((element, ii) => {
        const nextState = {
          ...state,
          keyPath: [...state.keyPath, ii]
        };
        return traverse(element, nextState);
      });
    } else if (typeof node === "object" && node !== null) {
      const out = {};
      for (const propName in node) {
        if (!Object.prototype.hasOwnProperty.call(node, propName)) {
          continue;
        }
        const nextState = {
          ...state,
          keyPath: [...state.keyPath, propName]
        };
        out[propName] = traverse(node[propName], nextState);
      }
      return out;
    } else {
      return visitors.reduce((acc, visitNode) => visitNode(acc, state), node);
    }
  };
}
function getTreeWalkerRequestTransformer(visitors, initialState) {
  return (request) => {
    const traverse3 = getTreeWalker(visitors);
    return Object.freeze({
      ...request,
      params: traverse3(request.params, initialState)
    });
  };
}
function getTreeWalkerResponseTransformer(visitors, initialState) {
  return (json2) => getTreeWalker(visitors)(json2, initialState);
}
function getBigIntDowncastRequestTransformer() {
  return getTreeWalkerRequestTransformer([downcastNodeToNumberIfBigint], { keyPath: [] });
}
function applyDefaultCommitment({
  commitmentPropertyName,
  params,
  optionsObjectPositionInParams,
  overrideCommitment
}) {
  const paramInTargetPosition = params[optionsObjectPositionInParams];
  if (paramInTargetPosition === undefined || paramInTargetPosition && typeof paramInTargetPosition === "object" && !Array.isArray(paramInTargetPosition)) {
    if (paramInTargetPosition && commitmentPropertyName in paramInTargetPosition) {
      if (!paramInTargetPosition[commitmentPropertyName] || paramInTargetPosition[commitmentPropertyName] === "finalized") {
        const nextParams = [...params];
        const {
          [commitmentPropertyName]: _,
          ...rest
        } = paramInTargetPosition;
        if (Object.keys(rest).length > 0) {
          nextParams[optionsObjectPositionInParams] = rest;
        } else {
          if (optionsObjectPositionInParams === nextParams.length - 1) {
            nextParams.length--;
          } else {
            nextParams[optionsObjectPositionInParams] = undefined;
          }
        }
        return nextParams;
      }
    } else if (overrideCommitment !== "finalized") {
      const nextParams = [...params];
      nextParams[optionsObjectPositionInParams] = {
        ...paramInTargetPosition,
        [commitmentPropertyName]: overrideCommitment
      };
      return nextParams;
    }
  }
  return params;
}
function getDefaultCommitmentRequestTransformer({
  defaultCommitment,
  optionsObjectPositionByMethod
}) {
  return (request) => {
    const { params, methodName } = request;
    if (!Array.isArray(params)) {
      return request;
    }
    const optionsObjectPositionInParams = optionsObjectPositionByMethod[methodName];
    if (optionsObjectPositionInParams == null) {
      return request;
    }
    return Object.freeze({
      methodName,
      params: applyDefaultCommitment({
        commitmentPropertyName: methodName === "sendTransaction" ? "preflightCommitment" : "commitment",
        optionsObjectPositionInParams,
        overrideCommitment: defaultCommitment,
        params
      })
    });
  };
}
function getIntegerOverflowNodeVisitor(onIntegerOverflow) {
  return (value, { keyPath }) => {
    if (typeof value === "bigint") {
      if (onIntegerOverflow && (value > Number.MAX_SAFE_INTEGER || value < -Number.MAX_SAFE_INTEGER)) {
        onIntegerOverflow(keyPath, value);
      }
    }
    return value;
  };
}
function getIntegerOverflowRequestTransformer(onIntegerOverflow) {
  return (request) => {
    const transformer = getTreeWalkerRequestTransformer([getIntegerOverflowNodeVisitor((...args) => onIntegerOverflow(request, ...args))], { keyPath: [] });
    return transformer(request);
  };
}
function getDefaultRequestTransformerForSolanaRpc(config) {
  const handleIntegerOverflow = config?.onIntegerOverflow;
  return (request) => {
    return pipe(request, handleIntegerOverflow ? getIntegerOverflowRequestTransformer(handleIntegerOverflow) : (r) => r, getBigIntDowncastRequestTransformer(), getDefaultCommitmentRequestTransformer({
      defaultCommitment: config?.defaultCommitment,
      optionsObjectPositionByMethod: OPTIONS_OBJECT_POSITION_BY_METHOD
    }));
  };
}
function getBigIntUpcastVisitor(allowedNumericKeyPaths) {
  return function upcastNodeToBigIntIfNumber(value, { keyPath }) {
    const isInteger = typeof value === "number" && Number.isInteger(value) || typeof value === "bigint";
    if (!isInteger)
      return value;
    if (keyPathIsAllowedToBeNumeric(keyPath, allowedNumericKeyPaths)) {
      return Number(value);
    } else {
      return BigInt(value);
    }
  };
}
function keyPathIsAllowedToBeNumeric(keyPath, allowedNumericKeyPaths) {
  return allowedNumericKeyPaths.some((prohibitedKeyPath) => {
    if (prohibitedKeyPath.length !== keyPath.length) {
      return false;
    }
    for (let ii = keyPath.length - 1;ii >= 0; ii--) {
      const keyPathPart = keyPath[ii];
      const prohibitedKeyPathPart = prohibitedKeyPath[ii];
      if (prohibitedKeyPathPart !== keyPathPart && (prohibitedKeyPathPart !== KEYPATH_WILDCARD || typeof keyPathPart !== "number")) {
        return false;
      }
    }
    return true;
  });
}
function getBigIntUpcastResponseTransformer(allowedNumericKeyPaths) {
  return getTreeWalkerResponseTransformer([getBigIntUpcastVisitor(allowedNumericKeyPaths)], { keyPath: [] });
}
function getResultResponseTransformer() {
  return (json2) => json2.result;
}
function getThrowSolanaErrorResponseTransformer() {
  return (json2) => {
    const jsonRpcResponse = json2;
    if ("error" in jsonRpcResponse) {
      throw getSolanaErrorFromJsonRpcError(jsonRpcResponse.error);
    }
    return jsonRpcResponse;
  };
}
function getDefaultResponseTransformerForSolanaRpc(config) {
  return (response, request) => {
    const methodName = request.methodName;
    const keyPaths = config?.allowedNumericKeyPaths && methodName ? config.allowedNumericKeyPaths[methodName] : undefined;
    return pipe(response, (r) => getThrowSolanaErrorResponseTransformer()(r, request), (r) => getResultResponseTransformer()(r, request), (r) => getBigIntUpcastResponseTransformer(keyPaths ?? [])(r, request));
  };
}
function getDefaultResponseTransformerForSolanaRpcSubscriptions(config) {
  return (response, request) => {
    const methodName = request.methodName;
    const keyPaths = config?.allowedNumericKeyPaths && methodName ? config.allowedNumericKeyPaths[methodName] : undefined;
    return pipe(response, (r) => getBigIntUpcastResponseTransformer(keyPaths ?? [])(r, request));
  };
}
var KEYPATH_WILDCARD, OPTIONS_OBJECT_POSITION_BY_METHOD, jsonParsedTokenAccountsConfigs, jsonParsedAccountsConfigs, innerInstructionsConfigs, messageConfig;
var init_index_node23 = __esm(() => {
  init_index_node12();
  init_index_node();
  KEYPATH_WILDCARD = {};
  OPTIONS_OBJECT_POSITION_BY_METHOD = {
    accountNotifications: 1,
    blockNotifications: 1,
    getAccountInfo: 1,
    getBalance: 1,
    getBlock: 1,
    getBlockHeight: 0,
    getBlockProduction: 0,
    getBlocks: 2,
    getBlocksWithLimit: 2,
    getEpochInfo: 0,
    getFeeForMessage: 1,
    getInflationGovernor: 0,
    getInflationReward: 1,
    getLargestAccounts: 0,
    getLatestBlockhash: 0,
    getLeaderSchedule: 1,
    getMinimumBalanceForRentExemption: 1,
    getMultipleAccounts: 1,
    getProgramAccounts: 1,
    getSignaturesForAddress: 1,
    getSlot: 0,
    getSlotLeader: 0,
    getStakeMinimumDelegation: 0,
    getSupply: 0,
    getTokenAccountBalance: 1,
    getTokenAccountsByDelegate: 2,
    getTokenAccountsByOwner: 2,
    getTokenLargestAccounts: 1,
    getTokenSupply: 1,
    getTransaction: 1,
    getTransactionCount: 0,
    getVoteAccounts: 0,
    isBlockhashValid: 1,
    logsNotifications: 1,
    programNotifications: 1,
    requestAirdrop: 2,
    sendTransaction: 1,
    signatureNotifications: 1,
    simulateTransaction: 1
  };
  jsonParsedTokenAccountsConfigs = [
    ["data", "parsed", "info", "tokenAmount", "decimals"],
    ["data", "parsed", "info", "tokenAmount", "uiAmount"],
    ["data", "parsed", "info", "rentExemptReserve", "decimals"],
    ["data", "parsed", "info", "rentExemptReserve", "uiAmount"],
    ["data", "parsed", "info", "delegatedAmount", "decimals"],
    ["data", "parsed", "info", "delegatedAmount", "uiAmount"],
    ["data", "parsed", "info", "extensions", KEYPATH_WILDCARD, "state", "olderTransferFee", "transferFeeBasisPoints"],
    ["data", "parsed", "info", "extensions", KEYPATH_WILDCARD, "state", "newerTransferFee", "transferFeeBasisPoints"],
    ["data", "parsed", "info", "extensions", KEYPATH_WILDCARD, "state", "preUpdateAverageRate"],
    ["data", "parsed", "info", "extensions", KEYPATH_WILDCARD, "state", "currentRate"]
  ];
  jsonParsedAccountsConfigs = [
    ...jsonParsedTokenAccountsConfigs,
    ["data", "parsed", "info", "lastExtendedSlotStartIndex"],
    ["data", "parsed", "info", "slashPenalty"],
    ["data", "parsed", "info", "warmupCooldownRate"],
    ["data", "parsed", "info", "decimals"],
    ["data", "parsed", "info", "numRequiredSigners"],
    ["data", "parsed", "info", "numValidSigners"],
    ["data", "parsed", "info", "stake", "delegation", "warmupCooldownRate"],
    ["data", "parsed", "info", "exemptionThreshold"],
    ["data", "parsed", "info", "burnPercent"],
    ["data", "parsed", "info", "commission"],
    ["data", "parsed", "info", "votes", KEYPATH_WILDCARD, "confirmationCount"]
  ];
  innerInstructionsConfigs = [
    ["index"],
    ["instructions", KEYPATH_WILDCARD, "accounts", KEYPATH_WILDCARD],
    ["instructions", KEYPATH_WILDCARD, "programIdIndex"],
    ["instructions", KEYPATH_WILDCARD, "stackHeight"]
  ];
  messageConfig = [
    ["addressTableLookups", KEYPATH_WILDCARD, "writableIndexes", KEYPATH_WILDCARD],
    ["addressTableLookups", KEYPATH_WILDCARD, "readonlyIndexes", KEYPATH_WILDCARD],
    ["header", "numReadonlySignedAccounts"],
    ["header", "numReadonlyUnsignedAccounts"],
    ["header", "numRequiredSignatures"],
    ["instructions", KEYPATH_WILDCARD, "accounts", KEYPATH_WILDCARD],
    ["instructions", KEYPATH_WILDCARD, "programIdIndex"],
    ["instructions", KEYPATH_WILDCARD, "stackHeight"]
  ];
});

// ../node_modules/.bun/@solana+rpc-api@5.1.0+7f9e3d21594a24ff/node_modules/@solana/rpc-api/dist/index.node.mjs
function createSolanaRpcApi(config) {
  return createJsonRpcApi({
    requestTransformer: getDefaultRequestTransformerForSolanaRpc(config),
    responseTransformer: getDefaultResponseTransformerForSolanaRpc({
      allowedNumericKeyPaths: getAllowedNumericKeypaths()
    })
  });
}
function getAllowedNumericKeypaths() {
  if (!memoizedKeypaths) {
    memoizedKeypaths = {
      getAccountInfo: jsonParsedAccountsConfigs.map((c) => ["value", ...c]),
      getBlock: [
        ["transactions", KEYPATH_WILDCARD, "meta", "preTokenBalances", KEYPATH_WILDCARD, "accountIndex"],
        [
          "transactions",
          KEYPATH_WILDCARD,
          "meta",
          "preTokenBalances",
          KEYPATH_WILDCARD,
          "uiTokenAmount",
          "decimals"
        ],
        ["transactions", KEYPATH_WILDCARD, "meta", "postTokenBalances", KEYPATH_WILDCARD, "accountIndex"],
        [
          "transactions",
          KEYPATH_WILDCARD,
          "meta",
          "postTokenBalances",
          KEYPATH_WILDCARD,
          "uiTokenAmount",
          "decimals"
        ],
        ["transactions", KEYPATH_WILDCARD, "meta", "rewards", KEYPATH_WILDCARD, "commission"],
        ...innerInstructionsConfigs.map((c) => [
          "transactions",
          KEYPATH_WILDCARD,
          "meta",
          "innerInstructions",
          KEYPATH_WILDCARD,
          ...c
        ]),
        ...messageConfig.map((c) => ["transactions", KEYPATH_WILDCARD, "transaction", "message", ...c]),
        ["rewards", KEYPATH_WILDCARD, "commission"]
      ],
      getClusterNodes: [
        [KEYPATH_WILDCARD, "featureSet"],
        [KEYPATH_WILDCARD, "shredVersion"]
      ],
      getInflationGovernor: [["initial"], ["foundation"], ["foundationTerm"], ["taper"], ["terminal"]],
      getInflationRate: [["foundation"], ["total"], ["validator"]],
      getInflationReward: [[KEYPATH_WILDCARD, "commission"]],
      getMultipleAccounts: jsonParsedAccountsConfigs.map((c) => ["value", KEYPATH_WILDCARD, ...c]),
      getProgramAccounts: jsonParsedAccountsConfigs.flatMap((c) => [
        ["value", KEYPATH_WILDCARD, "account", ...c],
        [KEYPATH_WILDCARD, "account", ...c]
      ]),
      getRecentPerformanceSamples: [[KEYPATH_WILDCARD, "samplePeriodSecs"]],
      getTokenAccountBalance: [
        ["value", "decimals"],
        ["value", "uiAmount"]
      ],
      getTokenAccountsByDelegate: jsonParsedTokenAccountsConfigs.map((c) => [
        "value",
        KEYPATH_WILDCARD,
        "account",
        ...c
      ]),
      getTokenAccountsByOwner: jsonParsedTokenAccountsConfigs.map((c) => [
        "value",
        KEYPATH_WILDCARD,
        "account",
        ...c
      ]),
      getTokenLargestAccounts: [
        ["value", KEYPATH_WILDCARD, "decimals"],
        ["value", KEYPATH_WILDCARD, "uiAmount"]
      ],
      getTokenSupply: [
        ["value", "decimals"],
        ["value", "uiAmount"]
      ],
      getTransaction: [
        ["meta", "preTokenBalances", KEYPATH_WILDCARD, "accountIndex"],
        ["meta", "preTokenBalances", KEYPATH_WILDCARD, "uiTokenAmount", "decimals"],
        ["meta", "postTokenBalances", KEYPATH_WILDCARD, "accountIndex"],
        ["meta", "postTokenBalances", KEYPATH_WILDCARD, "uiTokenAmount", "decimals"],
        ["meta", "rewards", KEYPATH_WILDCARD, "commission"],
        ...innerInstructionsConfigs.map((c) => ["meta", "innerInstructions", KEYPATH_WILDCARD, ...c]),
        ...messageConfig.map((c) => ["transaction", "message", ...c])
      ],
      getVersion: [["feature-set"]],
      getVoteAccounts: [
        ["current", KEYPATH_WILDCARD, "commission"],
        ["delinquent", KEYPATH_WILDCARD, "commission"]
      ],
      simulateTransaction: [
        ["value", "loadedAccountsDataSize"],
        ...jsonParsedAccountsConfigs.map((c) => ["value", "accounts", KEYPATH_WILDCARD, ...c]),
        ...innerInstructionsConfigs.map((c) => ["value", "innerInstructions", KEYPATH_WILDCARD, ...c])
      ]
    };
  }
  return memoizedKeypaths;
}
var memoizedKeypaths;
var init_index_node24 = __esm(() => {
  init_index_node22();
  init_index_node23();
});

// ../node_modules/.bun/@solana+rpc-transport-http@5.1.0+1fb4c65d43e298b9/node_modules/@solana/rpc-transport-http/dist/index.node.mjs
function assertIsAllowedHttpRequestHeaders(headers) {
  const badHeaders = Object.keys(headers).filter((headerName) => {
    const lowercaseHeaderName = headerName.toLowerCase();
    return DISALLOWED_HEADERS[headerName.toLowerCase()] === true || FORBIDDEN_HEADERS[headerName.toLowerCase()] === true || lowercaseHeaderName.startsWith("proxy-") || lowercaseHeaderName.startsWith("sec-");
  });
  if (badHeaders.length > 0) {
    throw new SolanaError(SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN, {
      headers: badHeaders
    });
  }
}
function normalizeHeaders(headers) {
  const out = {};
  for (const headerName in headers) {
    out[headerName.toLowerCase()] = headers[headerName];
  }
  return out;
}
function createHttpTransport(config) {
  if (false)
    ;
  const { fromJson, headers, toJson, url } = config;
  if (headers) {
    assertIsAllowedHttpRequestHeaders(headers);
  }
  let dispatcherConfig;
  if ("dispatcher_NODE_ONLY" in config) {
    dispatcherConfig = { dispatcher: config.dispatcher_NODE_ONLY };
  }
  const customHeaders = headers && normalizeHeaders(headers);
  return async function makeHttpRequest({
    payload,
    signal
  }) {
    const body = toJson ? toJson(payload) : JSON.stringify(payload);
    const requestInfo = {
      ...dispatcherConfig,
      body,
      headers: {
        ...customHeaders,
        accept: "application/json",
        "content-length": body.length.toString(),
        "content-type": "application/json; charset=utf-8"
      },
      method: "POST",
      signal
    };
    const response = await fetch(url, requestInfo);
    if (!response.ok) {
      throw new SolanaError(SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR, {
        headers: response.headers,
        message: response.statusText,
        statusCode: response.status
      });
    }
    if (fromJson) {
      return fromJson(await response.text(), payload);
    }
    return await response.json();
  };
}
function isSolanaRequest(payload) {
  return isJsonRpcPayload(payload) && SOLANA_RPC_METHODS.includes(payload.method);
}
function createHttpTransportForSolanaRpc(config) {
  return createHttpTransport({
    ...config,
    fromJson: (rawResponse, payload) => isSolanaRequest(payload) ? parseJsonWithBigInts(rawResponse) : JSON.parse(rawResponse),
    toJson: (payload) => isSolanaRequest(payload) ? stringifyJsonWithBigInts(payload) : JSON.stringify(payload)
  });
}
var DISALLOWED_HEADERS, FORBIDDEN_HEADERS, SOLANA_RPC_METHODS;
var init_index_node25 = __esm(() => {
  init_index_node();
  init_index_node21();
  init_index_node22();
  DISALLOWED_HEADERS = {
    accept: true,
    "content-length": true,
    "content-type": true
  };
  FORBIDDEN_HEADERS = /* @__PURE__ */ Object.assign({
    "accept-charset": true,
    "access-control-request-headers": true,
    "access-control-request-method": true,
    connection: true,
    "content-length": true,
    cookie: true,
    date: true,
    dnt: true,
    expect: true,
    host: true,
    "keep-alive": true,
    "permissions-policy": true,
    referer: true,
    te: true,
    trailer: true,
    "transfer-encoding": true,
    upgrade: true,
    via: true
  }, undefined, undefined);
  SOLANA_RPC_METHODS = [
    "getAccountInfo",
    "getBalance",
    "getBlock",
    "getBlockCommitment",
    "getBlockHeight",
    "getBlockProduction",
    "getBlocks",
    "getBlocksWithLimit",
    "getBlockTime",
    "getClusterNodes",
    "getEpochInfo",
    "getEpochSchedule",
    "getFeeForMessage",
    "getFirstAvailableBlock",
    "getGenesisHash",
    "getHealth",
    "getHighestSnapshotSlot",
    "getIdentity",
    "getInflationGovernor",
    "getInflationRate",
    "getInflationReward",
    "getLargestAccounts",
    "getLatestBlockhash",
    "getLeaderSchedule",
    "getMaxRetransmitSlot",
    "getMaxShredInsertSlot",
    "getMinimumBalanceForRentExemption",
    "getMultipleAccounts",
    "getProgramAccounts",
    "getRecentPerformanceSamples",
    "getRecentPrioritizationFees",
    "getSignaturesForAddress",
    "getSignatureStatuses",
    "getSlot",
    "getSlotLeader",
    "getSlotLeaders",
    "getStakeMinimumDelegation",
    "getSupply",
    "getTokenAccountBalance",
    "getTokenAccountsByDelegate",
    "getTokenAccountsByOwner",
    "getTokenLargestAccounts",
    "getTokenSupply",
    "getTransaction",
    "getTransactionCount",
    "getVersion",
    "getVoteAccounts",
    "index",
    "isBlockhashValid",
    "minimumLedgerSlot",
    "requestAirdrop",
    "sendTransaction",
    "simulateTransaction"
  ];
});

// ../node_modules/.bun/@solana+fast-stable-stringify@5.1.0+1fb4c65d43e298b9/node_modules/@solana/fast-stable-stringify/dist/index.node.mjs
function stringify(val, isArrayProp) {
  let i, max, str, keys, key, propVal, toStr;
  if (val === true) {
    return "true";
  }
  if (val === false) {
    return "false";
  }
  switch (typeof val) {
    case "object":
      if (val === null) {
        return null;
      } else if ("toJSON" in val && typeof val.toJSON === "function") {
        return stringify(val.toJSON(), isArrayProp);
      } else {
        toStr = objToString.call(val);
        if (toStr === "[object Array]") {
          str = "[";
          max = val.length - 1;
          for (i = 0;i < max; i++) {
            str += stringify(val[i], true) + ",";
          }
          if (max > -1) {
            str += stringify(val[i], true);
          }
          return str + "]";
        } else if (toStr === "[object Object]") {
          keys = objKeys(val).sort();
          max = keys.length;
          str = "";
          i = 0;
          while (i < max) {
            key = keys[i];
            propVal = stringify(val[key], false);
            if (propVal !== undefined) {
              if (str) {
                str += ",";
              }
              str += JSON.stringify(key) + ":" + propVal;
            }
            i++;
          }
          return "{" + str + "}";
        } else {
          return JSON.stringify(val);
        }
      }
    case "function":
    case "undefined":
      return isArrayProp ? null : undefined;
    case "bigint":
      return `${val.toString()}n`;
    case "string":
      return JSON.stringify(val);
    default:
      return isFinite(val) ? val : null;
  }
}
function index_default(val) {
  const returnVal = stringify(val, false);
  if (returnVal !== undefined) {
    return "" + returnVal;
  }
}
var objToString, objKeys;
var init_index_node26 = __esm(() => {
  objToString = Object.prototype.toString;
  objKeys = Object.keys || function(obj) {
    const keys = [];
    for (const name in obj) {
      keys.push(name);
    }
    return keys;
  };
});

// ../node_modules/.bun/@solana+rpc@5.1.0+7f9e3d21594a24ff/node_modules/@solana/rpc/dist/index.node.mjs
var exports_index_node2 = {};
__export(exports_index_node2, {
  isJsonRpcPayload: () => isJsonRpcPayload,
  createSolanaRpcFromTransport: () => createSolanaRpcFromTransport,
  createSolanaRpcApi: () => createSolanaRpcApi,
  createSolanaRpc: () => createSolanaRpc,
  createRpc: () => createRpc,
  createJsonRpcApi: () => createJsonRpcApi,
  createDefaultRpcTransport: () => createDefaultRpcTransport,
  DEFAULT_RPC_CONFIG: () => DEFAULT_RPC_CONFIG
});
import { setMaxListeners } from "events";
function createSolanaJsonRpcIntegerOverflowError(methodName, keyPath, value) {
  let argumentLabel = "";
  if (typeof keyPath[0] === "number") {
    const argPosition = keyPath[0] + 1;
    const lastDigit = argPosition % 10;
    const lastTwoDigits = argPosition % 100;
    if (lastDigit == 1 && lastTwoDigits != 11) {
      argumentLabel = argPosition + "st";
    } else if (lastDigit == 2 && lastTwoDigits != 12) {
      argumentLabel = argPosition + "nd";
    } else if (lastDigit == 3 && lastTwoDigits != 13) {
      argumentLabel = argPosition + "rd";
    } else {
      argumentLabel = argPosition + "th";
    }
  } else {
    argumentLabel = `\`${keyPath[0].toString()}\``;
  }
  const path = keyPath.length > 1 ? keyPath.slice(1).map((pathPart) => typeof pathPart === "number" ? `[${pathPart}]` : pathPart).join(".") : undefined;
  const error = new SolanaError(SOLANA_ERROR__RPC__INTEGER_OVERFLOW, {
    argumentLabel,
    keyPath,
    methodName,
    optionalPathLabel: path ? ` at path \`${path}\`` : "",
    value,
    ...path !== undefined ? { path } : undefined
  });
  safeCaptureStackTrace(error, createSolanaJsonRpcIntegerOverflowError);
  return error;
}
function createExplicitAbortToken() {
  return {
    EXPLICIT_ABORT_TOKEN: "This object is thrown from the request that underlies a series of coalesced requests when the last request in that series aborts"
  };
}
function getRpcTransportWithRequestCoalescing(transport, getDeduplicationKey) {
  let coalescedRequestsByDeduplicationKey;
  return async function makeCoalescedHttpRequest(request) {
    const { payload, signal } = request;
    const deduplicationKey = getDeduplicationKey(payload);
    if (deduplicationKey === undefined) {
      return await transport(request);
    }
    if (!coalescedRequestsByDeduplicationKey) {
      queueMicrotask(() => {
        coalescedRequestsByDeduplicationKey = undefined;
      });
      coalescedRequestsByDeduplicationKey = {};
    }
    if (coalescedRequestsByDeduplicationKey[deduplicationKey] == null) {
      const abortController = new e2;
      const responsePromise = (async () => {
        try {
          return await transport({
            ...request,
            signal: abortController.signal
          });
        } catch (e22) {
          if (e22 === (EXPLICIT_ABORT_TOKEN ||= createExplicitAbortToken())) {
            return;
          }
          throw e22;
        }
      })();
      coalescedRequestsByDeduplicationKey[deduplicationKey] = {
        abortController,
        numConsumers: 0,
        responsePromise
      };
    }
    const coalescedRequest = coalescedRequestsByDeduplicationKey[deduplicationKey];
    coalescedRequest.numConsumers++;
    if (signal) {
      const responsePromise = coalescedRequest.responsePromise;
      return await new Promise((resolve, reject) => {
        const handleAbort = (e22) => {
          signal.removeEventListener("abort", handleAbort);
          coalescedRequest.numConsumers -= 1;
          queueMicrotask(() => {
            if (coalescedRequest.numConsumers === 0) {
              const abortController = coalescedRequest.abortController;
              abortController.abort(EXPLICIT_ABORT_TOKEN ||= createExplicitAbortToken());
            }
          });
          reject(e22.target.reason);
        };
        signal.addEventListener("abort", handleAbort);
        responsePromise.then(resolve).catch(reject).finally(() => {
          signal.removeEventListener("abort", handleAbort);
        });
      });
    } else {
      return await coalescedRequest.responsePromise;
    }
  };
}
function getSolanaRpcPayloadDeduplicationKey(payload) {
  return isJsonRpcPayload(payload) ? index_default([payload.method, payload.params]) : undefined;
}
function normalizeHeaders2(headers) {
  const out = {};
  for (const headerName in headers) {
    out[headerName.toLowerCase()] = headers[headerName];
  }
  return out;
}
function createDefaultRpcTransport(config) {
  return pipe(createHttpTransportForSolanaRpc({
    ...config,
    headers: {
      ...{
        "accept-encoding": "br,gzip,deflate"
      },
      ...config.headers ? normalizeHeaders2(config.headers) : undefined,
      ...{
        "solana-client": `js/${"5.1.0"}`
      }
    }
  }), (transport) => getRpcTransportWithRequestCoalescing(transport, getSolanaRpcPayloadDeduplicationKey));
}
function createSolanaRpc(clusterUrl, config) {
  return createSolanaRpcFromTransport(createDefaultRpcTransport({ url: clusterUrl, ...config }));
}
function createSolanaRpcFromTransport(transport) {
  return createRpc({
    api: createSolanaRpcApi(DEFAULT_RPC_CONFIG),
    transport
  });
}
var DEFAULT_RPC_CONFIG, e2, EXPLICIT_ABORT_TOKEN;
var init_index_node27 = __esm(() => {
  init_index_node24();
  init_index_node22();
  init_index_node();
  init_index_node12();
  init_index_node25();
  init_index_node26();
  init_index_node24();
  init_index_node22();
  DEFAULT_RPC_CONFIG = {
    defaultCommitment: "confirmed",
    onIntegerOverflow(request, keyPath, value) {
      throw createSolanaJsonRpcIntegerOverflowError(request.methodName, keyPath, value);
    }
  };
  e2 = class extends globalThis.AbortController {
    constructor(...t) {
      super(...t), setMaxListeners(Number.MAX_SAFE_INTEGER, this.signal);
    }
  };
});

// ../node_modules/.bun/@solana+subscribable@5.1.0+1fb4c65d43e298b9/node_modules/@solana/subscribable/dist/index.node.mjs
import { setMaxListeners as setMaxListeners2 } from "events";
function createExplicitAbortToken2() {
  return Symbol("This symbol is thrown from a socket's iterator when the connection is explicitly aborted by the user");
}
function createAsyncIterableFromDataPublisher({
  abortSignal,
  dataChannelName,
  dataPublisher,
  errorChannelName
}) {
  const iteratorState = /* @__PURE__ */ new Map;
  function publishErrorToAllIterators(reason) {
    for (const [iteratorKey, state] of iteratorState.entries()) {
      if (state.__hasPolled) {
        iteratorState.delete(iteratorKey);
        state.onError(reason);
      } else {
        state.publishQueue.push({
          __type: 1,
          err: reason
        });
      }
    }
  }
  const abortController = new e3;
  abortSignal.addEventListener("abort", () => {
    abortController.abort();
    publishErrorToAllIterators(EXPLICIT_ABORT_TOKEN2 ||= createExplicitAbortToken2());
  });
  const options2 = { signal: abortController.signal };
  let firstError = UNINITIALIZED;
  dataPublisher.on(errorChannelName, (err) => {
    if (firstError === UNINITIALIZED) {
      firstError = err;
      abortController.abort();
      publishErrorToAllIterators(err);
    }
  }, options2);
  dataPublisher.on(dataChannelName, (data2) => {
    iteratorState.forEach((state, iteratorKey) => {
      if (state.__hasPolled) {
        const { onData } = state;
        iteratorState.set(iteratorKey, { __hasPolled: false, publishQueue: [] });
        onData(data2);
      } else {
        state.publishQueue.push({
          __type: 0,
          data: data2
        });
      }
    });
  }, options2);
  return {
    async* [Symbol.asyncIterator]() {
      if (abortSignal.aborted) {
        return;
      }
      if (firstError !== UNINITIALIZED) {
        throw firstError;
      }
      const iteratorKey = Symbol();
      iteratorState.set(iteratorKey, { __hasPolled: false, publishQueue: [] });
      try {
        while (true) {
          const state = iteratorState.get(iteratorKey);
          if (!state) {
            throw new SolanaError(SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING);
          }
          if (state.__hasPolled) {
            throw new SolanaError(SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE);
          }
          const publishQueue = state.publishQueue;
          try {
            if (publishQueue.length) {
              state.publishQueue = [];
              for (const item of publishQueue) {
                if (item.__type === 0) {
                  yield item.data;
                } else {
                  throw item.err;
                }
              }
            } else {
              yield await new Promise((resolve, reject) => {
                iteratorState.set(iteratorKey, {
                  __hasPolled: true,
                  onData: resolve,
                  onError: reject
                });
              });
            }
          } catch (e22) {
            if (e22 === (EXPLICIT_ABORT_TOKEN2 ||= createExplicitAbortToken2())) {
              return;
            } else {
              throw e22;
            }
          }
        }
      } finally {
        iteratorState.delete(iteratorKey);
      }
    }
  };
}
function getDataPublisherFromEventEmitter(eventEmitter) {
  return {
    on(channelName, subscriber, options2) {
      function innerListener(ev) {
        if (ev instanceof CustomEvent) {
          const data2 = ev.detail;
          subscriber(data2);
        } else {
          subscriber();
        }
      }
      eventEmitter.addEventListener(channelName, innerListener, options2);
      return () => {
        eventEmitter.removeEventListener(channelName, innerListener);
      };
    }
  };
}
function demultiplexDataPublisher(publisher, sourceChannelName, messageTransformer) {
  let innerPublisherState;
  const eventTarget = new s;
  const demultiplexedDataPublisher = getDataPublisherFromEventEmitter(eventTarget);
  return {
    ...demultiplexedDataPublisher,
    on(channelName, subscriber, options2) {
      if (!innerPublisherState) {
        const innerPublisherUnsubscribe = publisher.on(sourceChannelName, (sourceMessage) => {
          const transformResult = messageTransformer(sourceMessage);
          if (!transformResult) {
            return;
          }
          const [destinationChannelName, message] = transformResult;
          eventTarget.dispatchEvent(new CustomEvent(destinationChannelName, {
            detail: message
          }));
        });
        innerPublisherState = {
          dispose: innerPublisherUnsubscribe,
          numSubscribers: 0
        };
      }
      innerPublisherState.numSubscribers++;
      const unsubscribe = demultiplexedDataPublisher.on(channelName, subscriber, options2);
      let isActive = true;
      function handleUnsubscribe() {
        if (!isActive) {
          return;
        }
        isActive = false;
        options2?.signal.removeEventListener("abort", handleUnsubscribe);
        innerPublisherState.numSubscribers--;
        if (innerPublisherState.numSubscribers === 0) {
          innerPublisherState.dispose();
          innerPublisherState = undefined;
        }
        unsubscribe();
      }
      options2?.signal.addEventListener("abort", handleUnsubscribe);
      return handleUnsubscribe;
    }
  };
}
var e3, s, EXPLICIT_ABORT_TOKEN2, UNINITIALIZED;
var init_index_node28 = __esm(() => {
  init_index_node();
  e3 = class extends globalThis.AbortController {
    constructor(...t) {
      super(...t), setMaxListeners2(Number.MAX_SAFE_INTEGER, this.signal);
    }
  };
  s = class extends globalThis.EventTarget {
    constructor(...t) {
      super(...t), setMaxListeners2(Number.MAX_SAFE_INTEGER, this);
    }
  };
  UNINITIALIZED = Symbol();
});

// ../node_modules/.bun/@solana+rpc-subscriptions-spec@5.1.0+1fb4c65d43e298b9/node_modules/@solana/rpc-subscriptions-spec/dist/index.node.mjs
import { setMaxListeners as setMaxListeners3 } from "events";
function createSubscriptionRpc(rpcConfig) {
  return new Proxy(rpcConfig.api, {
    defineProperty() {
      return false;
    },
    deleteProperty() {
      return false;
    },
    get(target, p, receiver) {
      if (p === "then") {
        return;
      }
      return function(...rawParams) {
        const notificationName = p.toString();
        const createRpcSubscriptionPlan = Reflect.get(target, notificationName, receiver);
        if (!createRpcSubscriptionPlan) {
          throw new SolanaError(SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN, {
            notificationName
          });
        }
        const subscriptionPlan = createRpcSubscriptionPlan(...rawParams);
        return createPendingRpcSubscription(rpcConfig.transport, subscriptionPlan);
      };
    }
  });
}
function createPendingRpcSubscription(transport, subscriptionsPlan) {
  return {
    async subscribe({ abortSignal }) {
      const notificationsDataPublisher = await transport({
        signal: abortSignal,
        ...subscriptionsPlan
      });
      return createAsyncIterableFromDataPublisher({
        abortSignal,
        dataChannelName: "notification",
        dataPublisher: notificationsDataPublisher,
        errorChannelName: "error"
      });
    }
  };
}
function createRpcSubscriptionsApi(config) {
  return new Proxy({}, {
    defineProperty() {
      return false;
    },
    deleteProperty() {
      return false;
    },
    get(...args) {
      const [_, p] = args;
      const methodName = p.toString();
      return function(...params) {
        const rawRequest = { methodName, params };
        const request = config.requestTransformer ? config.requestTransformer(rawRequest) : rawRequest;
        return {
          execute(planConfig) {
            return config.planExecutor({ ...planConfig, request });
          },
          request
        };
      };
    }
  });
}
function transformChannelInboundMessages(channel, transform) {
  return Object.freeze({
    ...channel,
    on(type, subscriber, options2) {
      if (type !== "message") {
        return channel.on(type, subscriber, options2);
      }
      return channel.on("message", (message) => subscriber(transform(message)), options2);
    }
  });
}
function transformChannelOutboundMessages(channel, transform) {
  return Object.freeze({
    ...channel,
    send: (message) => channel.send(transform(message))
  });
}
function decrementSubscriberCountAndReturnNewCount(channel, subscriptionId) {
  return augmentSubscriberCountAndReturnNewCount(-1, channel, subscriptionId);
}
function incrementSubscriberCount(channel, subscriptionId) {
  augmentSubscriberCountAndReturnNewCount(1, channel, subscriptionId);
}
function getSubscriberCountBySubscriptionIdForChannel(channel) {
  let subscriberCountBySubscriptionId = subscriberCountBySubscriptionIdByChannel.get(channel);
  if (!subscriberCountBySubscriptionId) {
    subscriberCountBySubscriptionIdByChannel.set(channel, subscriberCountBySubscriptionId = {});
  }
  return subscriberCountBySubscriptionId;
}
function augmentSubscriberCountAndReturnNewCount(amount, channel, subscriptionId) {
  if (subscriptionId === undefined) {
    return;
  }
  const subscriberCountBySubscriptionId = getSubscriberCountBySubscriptionIdForChannel(channel);
  if (!subscriberCountBySubscriptionId[subscriptionId] && amount > 0) {
    subscriberCountBySubscriptionId[subscriptionId] = 0;
  }
  const newCount = amount + subscriberCountBySubscriptionId[subscriptionId];
  if (newCount <= 0) {
    delete subscriberCountBySubscriptionId[subscriptionId];
  } else {
    subscriberCountBySubscriptionId[subscriptionId] = newCount;
  }
  return newCount;
}
function getMemoizedDemultiplexedNotificationPublisherFromChannelAndResponseTransformer(channel, subscribeRequest, responseTransformer) {
  let publisherByResponseTransformer = cache.get(channel);
  if (!publisherByResponseTransformer) {
    cache.set(channel, publisherByResponseTransformer = /* @__PURE__ */ new WeakMap);
  }
  const responseTransformerKey = responseTransformer ?? channel;
  let publisher = publisherByResponseTransformer.get(responseTransformerKey);
  if (!publisher) {
    publisherByResponseTransformer.set(responseTransformerKey, publisher = demultiplexDataPublisher(channel, "message", (rawMessage) => {
      const message = rawMessage;
      if (!("method" in message)) {
        return;
      }
      const transformedNotification = responseTransformer ? responseTransformer(message.params.result, subscribeRequest) : message.params.result;
      return [`notification:${message.params.subscription}`, transformedNotification];
    }));
  }
  return publisher;
}
async function executeRpcPubSubSubscriptionPlan({
  channel,
  responseTransformer,
  signal,
  subscribeRequest,
  unsubscribeMethodName
}) {
  let subscriptionId;
  channel.on("error", () => {
    subscriptionId = undefined;
    subscriberCountBySubscriptionIdByChannel.delete(channel);
  }, { signal });
  const abortPromise = new Promise((_, reject) => {
    function handleAbort() {
      if (decrementSubscriberCountAndReturnNewCount(channel, subscriptionId) === 0) {
        const unsubscribePayload = createRpcMessage({
          methodName: unsubscribeMethodName,
          params: [subscriptionId]
        });
        subscriptionId = undefined;
        channel.send(unsubscribePayload).catch(() => {});
      }
      reject(this.reason);
    }
    if (signal.aborted) {
      handleAbort.call(signal);
    } else {
      signal.addEventListener("abort", handleAbort);
    }
  });
  const subscribePayload = createRpcMessage(subscribeRequest);
  await channel.send(subscribePayload);
  const subscriptionIdPromise = new Promise((resolve, reject) => {
    const abortController = new e4;
    signal.addEventListener("abort", abortController.abort.bind(abortController));
    const options2 = { signal: abortController.signal };
    channel.on("error", (err) => {
      abortController.abort();
      reject(err);
    }, options2);
    channel.on("message", (message) => {
      if (message && typeof message === "object" && "id" in message && message.id === subscribePayload.id) {
        abortController.abort();
        if ("error" in message) {
          reject(getSolanaErrorFromJsonRpcError(message.error));
        } else {
          resolve(message.result);
        }
      }
    }, options2);
  });
  subscriptionId = await safeRace([abortPromise, subscriptionIdPromise]);
  if (subscriptionId == null) {
    throw new SolanaError(SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID);
  }
  incrementSubscriberCount(channel, subscriptionId);
  const notificationPublisher = getMemoizedDemultiplexedNotificationPublisherFromChannelAndResponseTransformer(channel, subscribeRequest, responseTransformer);
  const notificationKey = `notification:${subscriptionId}`;
  return {
    on(type, listener, options2) {
      switch (type) {
        case "notification":
          return notificationPublisher.on(notificationKey, listener, options2);
        case "error":
          return channel.on("error", listener, options2);
        default:
          throw new SolanaError(SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED, {
            channelName: type,
            supportedChannelNames: ["notification", "error"]
          });
      }
    }
  };
}
var e4, subscriberCountBySubscriptionIdByChannel, cache;
var init_index_node29 = __esm(() => {
  init_index_node();
  init_index_node28();
  init_index_node17();
  init_index_node21();
  e4 = class extends globalThis.AbortController {
    constructor(...t) {
      super(...t), setMaxListeners3(Number.MAX_SAFE_INTEGER, this.signal);
    }
  };
  subscriberCountBySubscriptionIdByChannel = /* @__PURE__ */ new WeakMap;
  cache = /* @__PURE__ */ new WeakMap;
});

// ../node_modules/.bun/@solana+rpc-subscriptions-api@5.1.0+7f9e3d21594a24ff/node_modules/@solana/rpc-subscriptions-api/dist/index.node.mjs
function createSolanaRpcSubscriptionsApi_INTERNAL(config) {
  const requestTransformer = getDefaultRequestTransformerForSolanaRpc(config);
  const responseTransformer = getDefaultResponseTransformerForSolanaRpcSubscriptions({
    allowedNumericKeyPaths: getAllowedNumericKeypaths2()
  });
  return createRpcSubscriptionsApi({
    planExecutor({ request, ...rest }) {
      return executeRpcPubSubSubscriptionPlan({
        ...rest,
        responseTransformer,
        subscribeRequest: { ...request, methodName: request.methodName.replace(/Notifications$/, "Subscribe") },
        unsubscribeMethodName: request.methodName.replace(/Notifications$/, "Unsubscribe")
      });
    },
    requestTransformer
  });
}
function createSolanaRpcSubscriptionsApi(config) {
  return createSolanaRpcSubscriptionsApi_INTERNAL(config);
}
function createSolanaRpcSubscriptionsApi_UNSTABLE(config) {
  return createSolanaRpcSubscriptionsApi_INTERNAL(config);
}
function getAllowedNumericKeypaths2() {
  if (!memoizedKeypaths2) {
    memoizedKeypaths2 = {
      accountNotifications: jsonParsedAccountsConfigs.map((c) => ["value", ...c]),
      blockNotifications: [
        [
          "value",
          "block",
          "transactions",
          KEYPATH_WILDCARD,
          "meta",
          "preTokenBalances",
          KEYPATH_WILDCARD,
          "accountIndex"
        ],
        [
          "value",
          "block",
          "transactions",
          KEYPATH_WILDCARD,
          "meta",
          "preTokenBalances",
          KEYPATH_WILDCARD,
          "uiTokenAmount",
          "decimals"
        ],
        [
          "value",
          "block",
          "transactions",
          KEYPATH_WILDCARD,
          "meta",
          "postTokenBalances",
          KEYPATH_WILDCARD,
          "accountIndex"
        ],
        [
          "value",
          "block",
          "transactions",
          KEYPATH_WILDCARD,
          "meta",
          "postTokenBalances",
          KEYPATH_WILDCARD,
          "uiTokenAmount",
          "decimals"
        ],
        ["value", "block", "transactions", KEYPATH_WILDCARD, "meta", "rewards", KEYPATH_WILDCARD, "commission"],
        [
          "value",
          "block",
          "transactions",
          KEYPATH_WILDCARD,
          "meta",
          "innerInstructions",
          KEYPATH_WILDCARD,
          "index"
        ],
        [
          "value",
          "block",
          "transactions",
          KEYPATH_WILDCARD,
          "meta",
          "innerInstructions",
          KEYPATH_WILDCARD,
          "instructions",
          KEYPATH_WILDCARD,
          "programIdIndex"
        ],
        [
          "value",
          "block",
          "transactions",
          KEYPATH_WILDCARD,
          "meta",
          "innerInstructions",
          KEYPATH_WILDCARD,
          "instructions",
          KEYPATH_WILDCARD,
          "accounts",
          KEYPATH_WILDCARD
        ],
        [
          "value",
          "block",
          "transactions",
          KEYPATH_WILDCARD,
          "transaction",
          "message",
          "addressTableLookups",
          KEYPATH_WILDCARD,
          "writableIndexes",
          KEYPATH_WILDCARD
        ],
        [
          "value",
          "block",
          "transactions",
          KEYPATH_WILDCARD,
          "transaction",
          "message",
          "addressTableLookups",
          KEYPATH_WILDCARD,
          "readonlyIndexes",
          KEYPATH_WILDCARD
        ],
        [
          "value",
          "block",
          "transactions",
          KEYPATH_WILDCARD,
          "transaction",
          "message",
          "instructions",
          KEYPATH_WILDCARD,
          "programIdIndex"
        ],
        [
          "value",
          "block",
          "transactions",
          KEYPATH_WILDCARD,
          "transaction",
          "message",
          "instructions",
          KEYPATH_WILDCARD,
          "accounts",
          KEYPATH_WILDCARD
        ],
        [
          "value",
          "block",
          "transactions",
          KEYPATH_WILDCARD,
          "transaction",
          "message",
          "header",
          "numReadonlySignedAccounts"
        ],
        [
          "value",
          "block",
          "transactions",
          KEYPATH_WILDCARD,
          "transaction",
          "message",
          "header",
          "numReadonlyUnsignedAccounts"
        ],
        [
          "value",
          "block",
          "transactions",
          KEYPATH_WILDCARD,
          "transaction",
          "message",
          "header",
          "numRequiredSignatures"
        ],
        ["value", "block", "rewards", KEYPATH_WILDCARD, "commission"]
      ],
      programNotifications: jsonParsedAccountsConfigs.flatMap((c) => [
        ["value", KEYPATH_WILDCARD, "account", ...c],
        [KEYPATH_WILDCARD, "account", ...c]
      ])
    };
  }
  return memoizedKeypaths2;
}
var memoizedKeypaths2;
var init_index_node30 = __esm(() => {
  init_index_node29();
  init_index_node23();
});

// ../node_modules/.bun/ws@8.18.3+4789783d1fa00420/node_modules/ws/lib/constants.js
var require_constants = __commonJS((exports, module) => {
  var BINARY_TYPES = ["nodebuffer", "arraybuffer", "fragments"];
  var hasBlob = typeof Blob !== "undefined";
  if (hasBlob)
    BINARY_TYPES.push("blob");
  module.exports = {
    BINARY_TYPES,
    EMPTY_BUFFER: Buffer.alloc(0),
    GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
    hasBlob,
    kForOnEventAttribute: Symbol("kIsForOnEventAttribute"),
    kListener: Symbol("kListener"),
    kStatusCode: Symbol("status-code"),
    kWebSocket: Symbol("websocket"),
    NOOP: () => {}
  };
});

// ../node_modules/.bun/node-gyp-build@4.8.4/node_modules/node-gyp-build/node-gyp-build.js
var require_node_gyp_build = __commonJS((exports, module) => {
  var fs = __require("fs");
  var path = __require("path");
  var os = __require("os");
  var runtimeRequire = typeof __webpack_require__ === "function" ? __non_webpack_require__ : __require;
  var vars = process.config && process.config.variables || {};
  var prebuildsOnly = !!process.env.PREBUILDS_ONLY;
  var abi = process.versions.modules;
  var runtime = isElectron() ? "electron" : isNwjs() ? "node-webkit" : "node";
  var arch = process.env.npm_config_arch || os.arch();
  var platform = process.env.npm_config_platform || os.platform();
  var libc = process.env.LIBC || (isAlpine(platform) ? "musl" : "glibc");
  var armv = process.env.ARM_VERSION || (arch === "arm64" ? "8" : vars.arm_version) || "";
  var uv = (process.versions.uv || "").split(".")[0];
  module.exports = load;
  function load(dir) {
    return runtimeRequire(load.resolve(dir));
  }
  load.resolve = load.path = function(dir) {
    dir = path.resolve(dir || ".");
    try {
      var name = runtimeRequire(path.join(dir, "package.json")).name.toUpperCase().replace(/-/g, "_");
      if (process.env[name + "_PREBUILD"])
        dir = process.env[name + "_PREBUILD"];
    } catch (err) {}
    if (!prebuildsOnly) {
      var release = getFirst(path.join(dir, "build/Release"), matchBuild);
      if (release)
        return release;
      var debug = getFirst(path.join(dir, "build/Debug"), matchBuild);
      if (debug)
        return debug;
    }
    var prebuild = resolve(dir);
    if (prebuild)
      return prebuild;
    var nearby = resolve(path.dirname(process.execPath));
    if (nearby)
      return nearby;
    var target = [
      "platform=" + platform,
      "arch=" + arch,
      "runtime=" + runtime,
      "abi=" + abi,
      "uv=" + uv,
      armv ? "armv=" + armv : "",
      "libc=" + libc,
      "node=" + process.versions.node,
      process.versions.electron ? "electron=" + process.versions.electron : "",
      typeof __webpack_require__ === "function" ? "webpack=true" : ""
    ].filter(Boolean).join(" ");
    throw new Error("No native build was found for " + target + `
    loaded from: ` + dir + `
`);
    function resolve(dir2) {
      var tuples = readdirSync(path.join(dir2, "prebuilds")).map(parseTuple);
      var tuple = tuples.filter(matchTuple(platform, arch)).sort(compareTuples)[0];
      if (!tuple)
        return;
      var prebuilds = path.join(dir2, "prebuilds", tuple.name);
      var parsed = readdirSync(prebuilds).map(parseTags);
      var candidates = parsed.filter(matchTags(runtime, abi));
      var winner = candidates.sort(compareTags(runtime))[0];
      if (winner)
        return path.join(prebuilds, winner.file);
    }
  };
  function readdirSync(dir) {
    try {
      return fs.readdirSync(dir);
    } catch (err) {
      return [];
    }
  }
  function getFirst(dir, filter) {
    var files = readdirSync(dir).filter(filter);
    return files[0] && path.join(dir, files[0]);
  }
  function matchBuild(name) {
    return /\.node$/.test(name);
  }
  function parseTuple(name) {
    var arr = name.split("-");
    if (arr.length !== 2)
      return;
    var platform2 = arr[0];
    var architectures = arr[1].split("+");
    if (!platform2)
      return;
    if (!architectures.length)
      return;
    if (!architectures.every(Boolean))
      return;
    return { name, platform: platform2, architectures };
  }
  function matchTuple(platform2, arch2) {
    return function(tuple) {
      if (tuple == null)
        return false;
      if (tuple.platform !== platform2)
        return false;
      return tuple.architectures.includes(arch2);
    };
  }
  function compareTuples(a, b) {
    return a.architectures.length - b.architectures.length;
  }
  function parseTags(file) {
    var arr = file.split(".");
    var extension = arr.pop();
    var tags = { file, specificity: 0 };
    if (extension !== "node")
      return;
    for (var i = 0;i < arr.length; i++) {
      var tag = arr[i];
      if (tag === "node" || tag === "electron" || tag === "node-webkit") {
        tags.runtime = tag;
      } else if (tag === "napi") {
        tags.napi = true;
      } else if (tag.slice(0, 3) === "abi") {
        tags.abi = tag.slice(3);
      } else if (tag.slice(0, 2) === "uv") {
        tags.uv = tag.slice(2);
      } else if (tag.slice(0, 4) === "armv") {
        tags.armv = tag.slice(4);
      } else if (tag === "glibc" || tag === "musl") {
        tags.libc = tag;
      } else {
        continue;
      }
      tags.specificity++;
    }
    return tags;
  }
  function matchTags(runtime2, abi2) {
    return function(tags) {
      if (tags == null)
        return false;
      if (tags.runtime && tags.runtime !== runtime2 && !runtimeAgnostic(tags))
        return false;
      if (tags.abi && tags.abi !== abi2 && !tags.napi)
        return false;
      if (tags.uv && tags.uv !== uv)
        return false;
      if (tags.armv && tags.armv !== armv)
        return false;
      if (tags.libc && tags.libc !== libc)
        return false;
      return true;
    };
  }
  function runtimeAgnostic(tags) {
    return tags.runtime === "node" && tags.napi;
  }
  function compareTags(runtime2) {
    return function(a, b) {
      if (a.runtime !== b.runtime) {
        return a.runtime === runtime2 ? -1 : 1;
      } else if (a.abi !== b.abi) {
        return a.abi ? -1 : 1;
      } else if (a.specificity !== b.specificity) {
        return a.specificity > b.specificity ? -1 : 1;
      } else {
        return 0;
      }
    };
  }
  function isNwjs() {
    return !!(process.versions && process.versions.nw);
  }
  function isElectron() {
    if (process.versions && process.versions.electron)
      return true;
    if (process.env.ELECTRON_RUN_AS_NODE)
      return true;
    return typeof window !== "undefined" && window.process && window.process.type === "renderer";
  }
  function isAlpine(platform2) {
    return platform2 === "linux" && fs.existsSync("/etc/alpine-release");
  }
  load.parseTags = parseTags;
  load.matchTags = matchTags;
  load.compareTags = compareTags;
  load.parseTuple = parseTuple;
  load.matchTuple = matchTuple;
  load.compareTuples = compareTuples;
});

// ../node_modules/.bun/node-gyp-build@4.8.4/node_modules/node-gyp-build/index.js
var require_node_gyp_build2 = __commonJS((exports, module) => {
  var runtimeRequire = typeof __webpack_require__ === "function" ? __non_webpack_require__ : __require;
  if (typeof runtimeRequire.addon === "function") {
    module.exports = runtimeRequire.addon.bind(runtimeRequire);
  } else {
    module.exports = require_node_gyp_build();
  }
});

// ../node_modules/.bun/bufferutil@4.1.0/node_modules/bufferutil/fallback.js
var require_fallback = __commonJS((exports, module) => {
  var mask = (source, mask2, output, offset, length) => {
    for (var i = 0;i < length; i++) {
      output[offset + i] = source[i] ^ mask2[i & 3];
    }
  };
  var unmask = (buffer2, mask2) => {
    const length = buffer2.length;
    for (var i = 0;i < length; i++) {
      buffer2[i] ^= mask2[i & 3];
    }
  };
  module.exports = { mask, unmask };
});

// ../node_modules/.bun/bufferutil@4.1.0/node_modules/bufferutil/index.js
var require_bufferutil = __commonJS((exports, module) => {
  var __dirname = "/Users/home/projects/GhostSpeak/node_modules/.bun/bufferutil@4.1.0/node_modules/bufferutil";
  try {
    module.exports = require_node_gyp_build2()(__dirname);
  } catch (e5) {
    module.exports = require_fallback();
  }
});

// ../node_modules/.bun/ws@8.18.3+4789783d1fa00420/node_modules/ws/lib/buffer-util.js
var require_buffer_util = __commonJS((exports, module) => {
  var { EMPTY_BUFFER } = require_constants();
  var FastBuffer = Buffer[Symbol.species];
  function concat(list, totalLength) {
    if (list.length === 0)
      return EMPTY_BUFFER;
    if (list.length === 1)
      return list[0];
    const target = Buffer.allocUnsafe(totalLength);
    let offset = 0;
    for (let i = 0;i < list.length; i++) {
      const buf = list[i];
      target.set(buf, offset);
      offset += buf.length;
    }
    if (offset < totalLength) {
      return new FastBuffer(target.buffer, target.byteOffset, offset);
    }
    return target;
  }
  function _mask(source, mask, output, offset, length) {
    for (let i = 0;i < length; i++) {
      output[offset + i] = source[i] ^ mask[i & 3];
    }
  }
  function _unmask(buffer2, mask) {
    for (let i = 0;i < buffer2.length; i++) {
      buffer2[i] ^= mask[i & 3];
    }
  }
  function toArrayBuffer2(buf) {
    if (buf.length === buf.buffer.byteLength) {
      return buf.buffer;
    }
    return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);
  }
  function toBuffer(data2) {
    toBuffer.readOnly = true;
    if (Buffer.isBuffer(data2))
      return data2;
    let buf;
    if (data2 instanceof ArrayBuffer) {
      buf = new FastBuffer(data2);
    } else if (ArrayBuffer.isView(data2)) {
      buf = new FastBuffer(data2.buffer, data2.byteOffset, data2.byteLength);
    } else {
      buf = Buffer.from(data2);
      toBuffer.readOnly = false;
    }
    return buf;
  }
  module.exports = {
    concat,
    mask: _mask,
    toArrayBuffer: toArrayBuffer2,
    toBuffer,
    unmask: _unmask
  };
  if (!process.env.WS_NO_BUFFER_UTIL) {
    try {
      const bufferUtil = require_bufferutil();
      module.exports.mask = function(source, mask, output, offset, length) {
        if (length < 48)
          _mask(source, mask, output, offset, length);
        else
          bufferUtil.mask(source, mask, output, offset, length);
      };
      module.exports.unmask = function(buffer2, mask) {
        if (buffer2.length < 32)
          _unmask(buffer2, mask);
        else
          bufferUtil.unmask(buffer2, mask);
      };
    } catch (e5) {}
  }
});

// ../node_modules/.bun/ws@8.18.3+4789783d1fa00420/node_modules/ws/lib/limiter.js
var require_limiter = __commonJS((exports, module) => {
  var kDone = Symbol("kDone");
  var kRun = Symbol("kRun");

  class Limiter {
    constructor(concurrency) {
      this[kDone] = () => {
        this.pending--;
        this[kRun]();
      };
      this.concurrency = concurrency || Infinity;
      this.jobs = [];
      this.pending = 0;
    }
    add(job) {
      this.jobs.push(job);
      this[kRun]();
    }
    [kRun]() {
      if (this.pending === this.concurrency)
        return;
      if (this.jobs.length) {
        const job = this.jobs.shift();
        this.pending++;
        job(this[kDone]);
      }
    }
  }
  module.exports = Limiter;
});

// ../node_modules/.bun/ws@8.18.3+4789783d1fa00420/node_modules/ws/lib/permessage-deflate.js
var require_permessage_deflate = __commonJS((exports, module) => {
  var zlib = __require("zlib");
  var bufferUtil = require_buffer_util();
  var Limiter = require_limiter();
  var { kStatusCode } = require_constants();
  var FastBuffer = Buffer[Symbol.species];
  var TRAILER = Buffer.from([0, 0, 255, 255]);
  var kPerMessageDeflate = Symbol("permessage-deflate");
  var kTotalLength = Symbol("total-length");
  var kCallback = Symbol("callback");
  var kBuffers = Symbol("buffers");
  var kError = Symbol("error");
  var zlibLimiter;

  class PerMessageDeflate {
    constructor(options2, isServer, maxPayload) {
      this._maxPayload = maxPayload | 0;
      this._options = options2 || {};
      this._threshold = this._options.threshold !== undefined ? this._options.threshold : 1024;
      this._isServer = !!isServer;
      this._deflate = null;
      this._inflate = null;
      this.params = null;
      if (!zlibLimiter) {
        const concurrency = this._options.concurrencyLimit !== undefined ? this._options.concurrencyLimit : 10;
        zlibLimiter = new Limiter(concurrency);
      }
    }
    static get extensionName() {
      return "permessage-deflate";
    }
    offer() {
      const params = {};
      if (this._options.serverNoContextTakeover) {
        params.server_no_context_takeover = true;
      }
      if (this._options.clientNoContextTakeover) {
        params.client_no_context_takeover = true;
      }
      if (this._options.serverMaxWindowBits) {
        params.server_max_window_bits = this._options.serverMaxWindowBits;
      }
      if (this._options.clientMaxWindowBits) {
        params.client_max_window_bits = this._options.clientMaxWindowBits;
      } else if (this._options.clientMaxWindowBits == null) {
        params.client_max_window_bits = true;
      }
      return params;
    }
    accept(configurations) {
      configurations = this.normalizeParams(configurations);
      this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
      return this.params;
    }
    cleanup() {
      if (this._inflate) {
        this._inflate.close();
        this._inflate = null;
      }
      if (this._deflate) {
        const callback = this._deflate[kCallback];
        this._deflate.close();
        this._deflate = null;
        if (callback) {
          callback(new Error("The deflate stream was closed while data was being processed"));
        }
      }
    }
    acceptAsServer(offers) {
      const opts = this._options;
      const accepted = offers.find((params) => {
        if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params.client_max_window_bits) {
          return false;
        }
        return true;
      });
      if (!accepted) {
        throw new Error("None of the extension offers can be accepted");
      }
      if (opts.serverNoContextTakeover) {
        accepted.server_no_context_takeover = true;
      }
      if (opts.clientNoContextTakeover) {
        accepted.client_no_context_takeover = true;
      }
      if (typeof opts.serverMaxWindowBits === "number") {
        accepted.server_max_window_bits = opts.serverMaxWindowBits;
      }
      if (typeof opts.clientMaxWindowBits === "number") {
        accepted.client_max_window_bits = opts.clientMaxWindowBits;
      } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
        delete accepted.client_max_window_bits;
      }
      return accepted;
    }
    acceptAsClient(response) {
      const params = response[0];
      if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
        throw new Error('Unexpected parameter "client_no_context_takeover"');
      }
      if (!params.client_max_window_bits) {
        if (typeof this._options.clientMaxWindowBits === "number") {
          params.client_max_window_bits = this._options.clientMaxWindowBits;
        }
      } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params.client_max_window_bits > this._options.clientMaxWindowBits) {
        throw new Error('Unexpected or invalid parameter "client_max_window_bits"');
      }
      return params;
    }
    normalizeParams(configurations) {
      configurations.forEach((params) => {
        Object.keys(params).forEach((key) => {
          let value = params[key];
          if (value.length > 1) {
            throw new Error(`Parameter "${key}" must have only a single value`);
          }
          value = value[0];
          if (key === "client_max_window_bits") {
            if (value !== true) {
              const num = +value;
              if (!Number.isInteger(num) || num < 8 || num > 15) {
                throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
              }
              value = num;
            } else if (!this._isServer) {
              throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
            }
          } else if (key === "server_max_window_bits") {
            const num = +value;
            if (!Number.isInteger(num) || num < 8 || num > 15) {
              throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
            }
            value = num;
          } else if (key === "client_no_context_takeover" || key === "server_no_context_takeover") {
            if (value !== true) {
              throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
            }
          } else {
            throw new Error(`Unknown parameter "${key}"`);
          }
          params[key] = value;
        });
      });
      return configurations;
    }
    decompress(data2, fin, callback) {
      zlibLimiter.add((done) => {
        this._decompress(data2, fin, (err, result) => {
          done();
          callback(err, result);
        });
      });
    }
    compress(data2, fin, callback) {
      zlibLimiter.add((done) => {
        this._compress(data2, fin, (err, result) => {
          done();
          callback(err, result);
        });
      });
    }
    _decompress(data2, fin, callback) {
      const endpoint = this._isServer ? "client" : "server";
      if (!this._inflate) {
        const key = `${endpoint}_max_window_bits`;
        const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
        this._inflate = zlib.createInflateRaw({
          ...this._options.zlibInflateOptions,
          windowBits
        });
        this._inflate[kPerMessageDeflate] = this;
        this._inflate[kTotalLength] = 0;
        this._inflate[kBuffers] = [];
        this._inflate.on("error", inflateOnError);
        this._inflate.on("data", inflateOnData);
      }
      this._inflate[kCallback] = callback;
      this._inflate.write(data2);
      if (fin)
        this._inflate.write(TRAILER);
      this._inflate.flush(() => {
        const err = this._inflate[kError];
        if (err) {
          this._inflate.close();
          this._inflate = null;
          callback(err);
          return;
        }
        const data3 = bufferUtil.concat(this._inflate[kBuffers], this._inflate[kTotalLength]);
        if (this._inflate._readableState.endEmitted) {
          this._inflate.close();
          this._inflate = null;
        } else {
          this._inflate[kTotalLength] = 0;
          this._inflate[kBuffers] = [];
          if (fin && this.params[`${endpoint}_no_context_takeover`]) {
            this._inflate.reset();
          }
        }
        callback(null, data3);
      });
    }
    _compress(data2, fin, callback) {
      const endpoint = this._isServer ? "server" : "client";
      if (!this._deflate) {
        const key = `${endpoint}_max_window_bits`;
        const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
        this._deflate = zlib.createDeflateRaw({
          ...this._options.zlibDeflateOptions,
          windowBits
        });
        this._deflate[kTotalLength] = 0;
        this._deflate[kBuffers] = [];
        this._deflate.on("data", deflateOnData);
      }
      this._deflate[kCallback] = callback;
      this._deflate.write(data2);
      this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
        if (!this._deflate) {
          return;
        }
        let data3 = bufferUtil.concat(this._deflate[kBuffers], this._deflate[kTotalLength]);
        if (fin) {
          data3 = new FastBuffer(data3.buffer, data3.byteOffset, data3.length - 4);
        }
        this._deflate[kCallback] = null;
        this._deflate[kTotalLength] = 0;
        this._deflate[kBuffers] = [];
        if (fin && this.params[`${endpoint}_no_context_takeover`]) {
          this._deflate.reset();
        }
        callback(null, data3);
      });
    }
  }
  module.exports = PerMessageDeflate;
  function deflateOnData(chunk) {
    this[kBuffers].push(chunk);
    this[kTotalLength] += chunk.length;
  }
  function inflateOnData(chunk) {
    this[kTotalLength] += chunk.length;
    if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
      this[kBuffers].push(chunk);
      return;
    }
    this[kError] = new RangeError("Max payload size exceeded");
    this[kError].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH";
    this[kError][kStatusCode] = 1009;
    this.removeListener("data", inflateOnData);
    this.reset();
  }
  function inflateOnError(err) {
    this[kPerMessageDeflate]._inflate = null;
    if (this[kError]) {
      this[kCallback](this[kError]);
      return;
    }
    err[kStatusCode] = 1007;
    this[kCallback](err);
  }
});

// ../node_modules/.bun/utf-8-validate@5.0.10/node_modules/utf-8-validate/fallback.js
var require_fallback2 = __commonJS((exports, module) => {
  function isValidUTF8(buf) {
    const len = buf.length;
    let i = 0;
    while (i < len) {
      if ((buf[i] & 128) === 0) {
        i++;
      } else if ((buf[i] & 224) === 192) {
        if (i + 1 === len || (buf[i + 1] & 192) !== 128 || (buf[i] & 254) === 192) {
          return false;
        }
        i += 2;
      } else if ((buf[i] & 240) === 224) {
        if (i + 2 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || buf[i] === 224 && (buf[i + 1] & 224) === 128 || buf[i] === 237 && (buf[i + 1] & 224) === 160) {
          return false;
        }
        i += 3;
      } else if ((buf[i] & 248) === 240) {
        if (i + 3 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || (buf[i + 3] & 192) !== 128 || buf[i] === 240 && (buf[i + 1] & 240) === 128 || buf[i] === 244 && buf[i + 1] > 143 || buf[i] > 244) {
          return false;
        }
        i += 4;
      } else {
        return false;
      }
    }
    return true;
  }
  module.exports = isValidUTF8;
});

// ../node_modules/.bun/utf-8-validate@5.0.10/node_modules/utf-8-validate/index.js
var require_utf_8_validate = __commonJS((exports, module) => {
  var __dirname = "/Users/home/projects/GhostSpeak/node_modules/.bun/utf-8-validate@5.0.10/node_modules/utf-8-validate";
  try {
    module.exports = require_node_gyp_build2()(__dirname);
  } catch (e5) {
    module.exports = require_fallback2();
  }
});

// ../node_modules/.bun/ws@8.18.3+4789783d1fa00420/node_modules/ws/lib/validation.js
var require_validation = __commonJS((exports, module) => {
  var { isUtf8 } = __require("buffer");
  var { hasBlob } = require_constants();
  var tokenChars = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    0,
    1,
    0
  ];
  function isValidStatusCode(code) {
    return code >= 1000 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3000 && code <= 4999;
  }
  function _isValidUTF8(buf) {
    const len = buf.length;
    let i = 0;
    while (i < len) {
      if ((buf[i] & 128) === 0) {
        i++;
      } else if ((buf[i] & 224) === 192) {
        if (i + 1 === len || (buf[i + 1] & 192) !== 128 || (buf[i] & 254) === 192) {
          return false;
        }
        i += 2;
      } else if ((buf[i] & 240) === 224) {
        if (i + 2 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || buf[i] === 224 && (buf[i + 1] & 224) === 128 || buf[i] === 237 && (buf[i + 1] & 224) === 160) {
          return false;
        }
        i += 3;
      } else if ((buf[i] & 248) === 240) {
        if (i + 3 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || (buf[i + 3] & 192) !== 128 || buf[i] === 240 && (buf[i + 1] & 240) === 128 || buf[i] === 244 && buf[i + 1] > 143 || buf[i] > 244) {
          return false;
        }
        i += 4;
      } else {
        return false;
      }
    }
    return true;
  }
  function isBlob(value) {
    return hasBlob && typeof value === "object" && typeof value.arrayBuffer === "function" && typeof value.type === "string" && typeof value.stream === "function" && (value[Symbol.toStringTag] === "Blob" || value[Symbol.toStringTag] === "File");
  }
  module.exports = {
    isBlob,
    isValidStatusCode,
    isValidUTF8: _isValidUTF8,
    tokenChars
  };
  if (isUtf8) {
    module.exports.isValidUTF8 = function(buf) {
      return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);
    };
  } else if (!process.env.WS_NO_UTF_8_VALIDATE) {
    try {
      const isValidUTF8 = require_utf_8_validate();
      module.exports.isValidUTF8 = function(buf) {
        return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);
      };
    } catch (e5) {}
  }
});

// ../node_modules/.bun/ws@8.18.3+4789783d1fa00420/node_modules/ws/lib/receiver.js
var require_receiver = __commonJS((exports, module) => {
  var { Writable } = __require("stream");
  var PerMessageDeflate = require_permessage_deflate();
  var {
    BINARY_TYPES,
    EMPTY_BUFFER,
    kStatusCode,
    kWebSocket
  } = require_constants();
  var { concat, toArrayBuffer: toArrayBuffer2, unmask } = require_buffer_util();
  var { isValidStatusCode, isValidUTF8 } = require_validation();
  var FastBuffer = Buffer[Symbol.species];
  var GET_INFO = 0;
  var GET_PAYLOAD_LENGTH_16 = 1;
  var GET_PAYLOAD_LENGTH_64 = 2;
  var GET_MASK = 3;
  var GET_DATA = 4;
  var INFLATING = 5;
  var DEFER_EVENT = 6;

  class Receiver extends Writable {
    constructor(options2 = {}) {
      super();
      this._allowSynchronousEvents = options2.allowSynchronousEvents !== undefined ? options2.allowSynchronousEvents : true;
      this._binaryType = options2.binaryType || BINARY_TYPES[0];
      this._extensions = options2.extensions || {};
      this._isServer = !!options2.isServer;
      this._maxPayload = options2.maxPayload | 0;
      this._skipUTF8Validation = !!options2.skipUTF8Validation;
      this[kWebSocket] = undefined;
      this._bufferedBytes = 0;
      this._buffers = [];
      this._compressed = false;
      this._payloadLength = 0;
      this._mask = undefined;
      this._fragmented = 0;
      this._masked = false;
      this._fin = false;
      this._opcode = 0;
      this._totalPayloadLength = 0;
      this._messageLength = 0;
      this._fragments = [];
      this._errored = false;
      this._loop = false;
      this._state = GET_INFO;
    }
    _write(chunk, encoding, cb) {
      if (this._opcode === 8 && this._state == GET_INFO)
        return cb();
      this._bufferedBytes += chunk.length;
      this._buffers.push(chunk);
      this.startLoop(cb);
    }
    consume(n) {
      this._bufferedBytes -= n;
      if (n === this._buffers[0].length)
        return this._buffers.shift();
      if (n < this._buffers[0].length) {
        const buf = this._buffers[0];
        this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n, buf.length - n);
        return new FastBuffer(buf.buffer, buf.byteOffset, n);
      }
      const dst = Buffer.allocUnsafe(n);
      do {
        const buf = this._buffers[0];
        const offset = dst.length - n;
        if (n >= buf.length) {
          dst.set(this._buffers.shift(), offset);
        } else {
          dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
          this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n, buf.length - n);
        }
        n -= buf.length;
      } while (n > 0);
      return dst;
    }
    startLoop(cb) {
      this._loop = true;
      do {
        switch (this._state) {
          case GET_INFO:
            this.getInfo(cb);
            break;
          case GET_PAYLOAD_LENGTH_16:
            this.getPayloadLength16(cb);
            break;
          case GET_PAYLOAD_LENGTH_64:
            this.getPayloadLength64(cb);
            break;
          case GET_MASK:
            this.getMask();
            break;
          case GET_DATA:
            this.getData(cb);
            break;
          case INFLATING:
          case DEFER_EVENT:
            this._loop = false;
            return;
        }
      } while (this._loop);
      if (!this._errored)
        cb();
    }
    getInfo(cb) {
      if (this._bufferedBytes < 2) {
        this._loop = false;
        return;
      }
      const buf = this.consume(2);
      if ((buf[0] & 48) !== 0) {
        const error = this.createError(RangeError, "RSV2 and RSV3 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_2_3");
        cb(error);
        return;
      }
      const compressed = (buf[0] & 64) === 64;
      if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
        const error = this.createError(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
        cb(error);
        return;
      }
      this._fin = (buf[0] & 128) === 128;
      this._opcode = buf[0] & 15;
      this._payloadLength = buf[1] & 127;
      if (this._opcode === 0) {
        if (compressed) {
          const error = this.createError(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
          cb(error);
          return;
        }
        if (!this._fragmented) {
          const error = this.createError(RangeError, "invalid opcode 0", true, 1002, "WS_ERR_INVALID_OPCODE");
          cb(error);
          return;
        }
        this._opcode = this._fragmented;
      } else if (this._opcode === 1 || this._opcode === 2) {
        if (this._fragmented) {
          const error = this.createError(RangeError, `invalid opcode ${this._opcode}`, true, 1002, "WS_ERR_INVALID_OPCODE");
          cb(error);
          return;
        }
        this._compressed = compressed;
      } else if (this._opcode > 7 && this._opcode < 11) {
        if (!this._fin) {
          const error = this.createError(RangeError, "FIN must be set", true, 1002, "WS_ERR_EXPECTED_FIN");
          cb(error);
          return;
        }
        if (compressed) {
          const error = this.createError(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
          cb(error);
          return;
        }
        if (this._payloadLength > 125 || this._opcode === 8 && this._payloadLength === 1) {
          const error = this.createError(RangeError, `invalid payload length ${this._payloadLength}`, true, 1002, "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH");
          cb(error);
          return;
        }
      } else {
        const error = this.createError(RangeError, `invalid opcode ${this._opcode}`, true, 1002, "WS_ERR_INVALID_OPCODE");
        cb(error);
        return;
      }
      if (!this._fin && !this._fragmented)
        this._fragmented = this._opcode;
      this._masked = (buf[1] & 128) === 128;
      if (this._isServer) {
        if (!this._masked) {
          const error = this.createError(RangeError, "MASK must be set", true, 1002, "WS_ERR_EXPECTED_MASK");
          cb(error);
          return;
        }
      } else if (this._masked) {
        const error = this.createError(RangeError, "MASK must be clear", true, 1002, "WS_ERR_UNEXPECTED_MASK");
        cb(error);
        return;
      }
      if (this._payloadLength === 126)
        this._state = GET_PAYLOAD_LENGTH_16;
      else if (this._payloadLength === 127)
        this._state = GET_PAYLOAD_LENGTH_64;
      else
        this.haveLength(cb);
    }
    getPayloadLength16(cb) {
      if (this._bufferedBytes < 2) {
        this._loop = false;
        return;
      }
      this._payloadLength = this.consume(2).readUInt16BE(0);
      this.haveLength(cb);
    }
    getPayloadLength64(cb) {
      if (this._bufferedBytes < 8) {
        this._loop = false;
        return;
      }
      const buf = this.consume(8);
      const num = buf.readUInt32BE(0);
      if (num > Math.pow(2, 53 - 32) - 1) {
        const error = this.createError(RangeError, "Unsupported WebSocket frame: payload length > 2^53 - 1", false, 1009, "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH");
        cb(error);
        return;
      }
      this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
      this.haveLength(cb);
    }
    haveLength(cb) {
      if (this._payloadLength && this._opcode < 8) {
        this._totalPayloadLength += this._payloadLength;
        if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
          const error = this.createError(RangeError, "Max payload size exceeded", false, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH");
          cb(error);
          return;
        }
      }
      if (this._masked)
        this._state = GET_MASK;
      else
        this._state = GET_DATA;
    }
    getMask() {
      if (this._bufferedBytes < 4) {
        this._loop = false;
        return;
      }
      this._mask = this.consume(4);
      this._state = GET_DATA;
    }
    getData(cb) {
      let data2 = EMPTY_BUFFER;
      if (this._payloadLength) {
        if (this._bufferedBytes < this._payloadLength) {
          this._loop = false;
          return;
        }
        data2 = this.consume(this._payloadLength);
        if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) {
          unmask(data2, this._mask);
        }
      }
      if (this._opcode > 7) {
        this.controlMessage(data2, cb);
        return;
      }
      if (this._compressed) {
        this._state = INFLATING;
        this.decompress(data2, cb);
        return;
      }
      if (data2.length) {
        this._messageLength = this._totalPayloadLength;
        this._fragments.push(data2);
      }
      this.dataMessage(cb);
    }
    decompress(data2, cb) {
      const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
      perMessageDeflate.decompress(data2, this._fin, (err, buf) => {
        if (err)
          return cb(err);
        if (buf.length) {
          this._messageLength += buf.length;
          if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
            const error = this.createError(RangeError, "Max payload size exceeded", false, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH");
            cb(error);
            return;
          }
          this._fragments.push(buf);
        }
        this.dataMessage(cb);
        if (this._state === GET_INFO)
          this.startLoop(cb);
      });
    }
    dataMessage(cb) {
      if (!this._fin) {
        this._state = GET_INFO;
        return;
      }
      const messageLength = this._messageLength;
      const fragments = this._fragments;
      this._totalPayloadLength = 0;
      this._messageLength = 0;
      this._fragmented = 0;
      this._fragments = [];
      if (this._opcode === 2) {
        let data2;
        if (this._binaryType === "nodebuffer") {
          data2 = concat(fragments, messageLength);
        } else if (this._binaryType === "arraybuffer") {
          data2 = toArrayBuffer2(concat(fragments, messageLength));
        } else if (this._binaryType === "blob") {
          data2 = new Blob(fragments);
        } else {
          data2 = fragments;
        }
        if (this._allowSynchronousEvents) {
          this.emit("message", data2, true);
          this._state = GET_INFO;
        } else {
          this._state = DEFER_EVENT;
          setImmediate(() => {
            this.emit("message", data2, true);
            this._state = GET_INFO;
            this.startLoop(cb);
          });
        }
      } else {
        const buf = concat(fragments, messageLength);
        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
          const error = this.createError(Error, "invalid UTF-8 sequence", true, 1007, "WS_ERR_INVALID_UTF8");
          cb(error);
          return;
        }
        if (this._state === INFLATING || this._allowSynchronousEvents) {
          this.emit("message", buf, false);
          this._state = GET_INFO;
        } else {
          this._state = DEFER_EVENT;
          setImmediate(() => {
            this.emit("message", buf, false);
            this._state = GET_INFO;
            this.startLoop(cb);
          });
        }
      }
    }
    controlMessage(data2, cb) {
      if (this._opcode === 8) {
        if (data2.length === 0) {
          this._loop = false;
          this.emit("conclude", 1005, EMPTY_BUFFER);
          this.end();
        } else {
          const code = data2.readUInt16BE(0);
          if (!isValidStatusCode(code)) {
            const error = this.createError(RangeError, `invalid status code ${code}`, true, 1002, "WS_ERR_INVALID_CLOSE_CODE");
            cb(error);
            return;
          }
          const buf = new FastBuffer(data2.buffer, data2.byteOffset + 2, data2.length - 2);
          if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
            const error = this.createError(Error, "invalid UTF-8 sequence", true, 1007, "WS_ERR_INVALID_UTF8");
            cb(error);
            return;
          }
          this._loop = false;
          this.emit("conclude", code, buf);
          this.end();
        }
        this._state = GET_INFO;
        return;
      }
      if (this._allowSynchronousEvents) {
        this.emit(this._opcode === 9 ? "ping" : "pong", data2);
        this._state = GET_INFO;
      } else {
        this._state = DEFER_EVENT;
        setImmediate(() => {
          this.emit(this._opcode === 9 ? "ping" : "pong", data2);
          this._state = GET_INFO;
          this.startLoop(cb);
        });
      }
    }
    createError(ErrorCtor, message, prefix, statusCode, errorCode) {
      this._loop = false;
      this._errored = true;
      const err = new ErrorCtor(prefix ? `Invalid WebSocket frame: ${message}` : message);
      Error.captureStackTrace(err, this.createError);
      err.code = errorCode;
      err[kStatusCode] = statusCode;
      return err;
    }
  }
  module.exports = Receiver;
});

// ../node_modules/.bun/ws@8.18.3+4789783d1fa00420/node_modules/ws/lib/sender.js
var require_sender = __commonJS((exports, module) => {
  var { Duplex } = __require("stream");
  var { randomFillSync } = __require("crypto");
  var PerMessageDeflate = require_permessage_deflate();
  var { EMPTY_BUFFER, kWebSocket, NOOP } = require_constants();
  var { isBlob, isValidStatusCode } = require_validation();
  var { mask: applyMask, toBuffer } = require_buffer_util();
  var kByteLength = Symbol("kByteLength");
  var maskBuffer = Buffer.alloc(4);
  var RANDOM_POOL_SIZE = 8 * 1024;
  var randomPool;
  var randomPoolPointer = RANDOM_POOL_SIZE;
  var DEFAULT = 0;
  var DEFLATING = 1;
  var GET_BLOB_DATA = 2;

  class Sender {
    constructor(socket, extensions, generateMask) {
      this._extensions = extensions || {};
      if (generateMask) {
        this._generateMask = generateMask;
        this._maskBuffer = Buffer.alloc(4);
      }
      this._socket = socket;
      this._firstFragment = true;
      this._compress = false;
      this._bufferedBytes = 0;
      this._queue = [];
      this._state = DEFAULT;
      this.onerror = NOOP;
      this[kWebSocket] = undefined;
    }
    static frame(data2, options2) {
      let mask;
      let merge = false;
      let offset = 2;
      let skipMasking = false;
      if (options2.mask) {
        mask = options2.maskBuffer || maskBuffer;
        if (options2.generateMask) {
          options2.generateMask(mask);
        } else {
          if (randomPoolPointer === RANDOM_POOL_SIZE) {
            if (randomPool === undefined) {
              randomPool = Buffer.alloc(RANDOM_POOL_SIZE);
            }
            randomFillSync(randomPool, 0, RANDOM_POOL_SIZE);
            randomPoolPointer = 0;
          }
          mask[0] = randomPool[randomPoolPointer++];
          mask[1] = randomPool[randomPoolPointer++];
          mask[2] = randomPool[randomPoolPointer++];
          mask[3] = randomPool[randomPoolPointer++];
        }
        skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
        offset = 6;
      }
      let dataLength;
      if (typeof data2 === "string") {
        if ((!options2.mask || skipMasking) && options2[kByteLength] !== undefined) {
          dataLength = options2[kByteLength];
        } else {
          data2 = Buffer.from(data2);
          dataLength = data2.length;
        }
      } else {
        dataLength = data2.length;
        merge = options2.mask && options2.readOnly && !skipMasking;
      }
      let payloadLength = dataLength;
      if (dataLength >= 65536) {
        offset += 8;
        payloadLength = 127;
      } else if (dataLength > 125) {
        offset += 2;
        payloadLength = 126;
      }
      const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);
      target[0] = options2.fin ? options2.opcode | 128 : options2.opcode;
      if (options2.rsv1)
        target[0] |= 64;
      target[1] = payloadLength;
      if (payloadLength === 126) {
        target.writeUInt16BE(dataLength, 2);
      } else if (payloadLength === 127) {
        target[2] = target[3] = 0;
        target.writeUIntBE(dataLength, 4, 6);
      }
      if (!options2.mask)
        return [target, data2];
      target[1] |= 128;
      target[offset - 4] = mask[0];
      target[offset - 3] = mask[1];
      target[offset - 2] = mask[2];
      target[offset - 1] = mask[3];
      if (skipMasking)
        return [target, data2];
      if (merge) {
        applyMask(data2, mask, target, offset, dataLength);
        return [target];
      }
      applyMask(data2, mask, data2, 0, dataLength);
      return [target, data2];
    }
    close(code, data2, mask, cb) {
      let buf;
      if (code === undefined) {
        buf = EMPTY_BUFFER;
      } else if (typeof code !== "number" || !isValidStatusCode(code)) {
        throw new TypeError("First argument must be a valid error code number");
      } else if (data2 === undefined || !data2.length) {
        buf = Buffer.allocUnsafe(2);
        buf.writeUInt16BE(code, 0);
      } else {
        const length = Buffer.byteLength(data2);
        if (length > 123) {
          throw new RangeError("The message must not be greater than 123 bytes");
        }
        buf = Buffer.allocUnsafe(2 + length);
        buf.writeUInt16BE(code, 0);
        if (typeof data2 === "string") {
          buf.write(data2, 2);
        } else {
          buf.set(data2, 2);
        }
      }
      const options2 = {
        [kByteLength]: buf.length,
        fin: true,
        generateMask: this._generateMask,
        mask,
        maskBuffer: this._maskBuffer,
        opcode: 8,
        readOnly: false,
        rsv1: false
      };
      if (this._state !== DEFAULT) {
        this.enqueue([this.dispatch, buf, false, options2, cb]);
      } else {
        this.sendFrame(Sender.frame(buf, options2), cb);
      }
    }
    ping(data2, mask, cb) {
      let byteLength;
      let readOnly;
      if (typeof data2 === "string") {
        byteLength = Buffer.byteLength(data2);
        readOnly = false;
      } else if (isBlob(data2)) {
        byteLength = data2.size;
        readOnly = false;
      } else {
        data2 = toBuffer(data2);
        byteLength = data2.length;
        readOnly = toBuffer.readOnly;
      }
      if (byteLength > 125) {
        throw new RangeError("The data size must not be greater than 125 bytes");
      }
      const options2 = {
        [kByteLength]: byteLength,
        fin: true,
        generateMask: this._generateMask,
        mask,
        maskBuffer: this._maskBuffer,
        opcode: 9,
        readOnly,
        rsv1: false
      };
      if (isBlob(data2)) {
        if (this._state !== DEFAULT) {
          this.enqueue([this.getBlobData, data2, false, options2, cb]);
        } else {
          this.getBlobData(data2, false, options2, cb);
        }
      } else if (this._state !== DEFAULT) {
        this.enqueue([this.dispatch, data2, false, options2, cb]);
      } else {
        this.sendFrame(Sender.frame(data2, options2), cb);
      }
    }
    pong(data2, mask, cb) {
      let byteLength;
      let readOnly;
      if (typeof data2 === "string") {
        byteLength = Buffer.byteLength(data2);
        readOnly = false;
      } else if (isBlob(data2)) {
        byteLength = data2.size;
        readOnly = false;
      } else {
        data2 = toBuffer(data2);
        byteLength = data2.length;
        readOnly = toBuffer.readOnly;
      }
      if (byteLength > 125) {
        throw new RangeError("The data size must not be greater than 125 bytes");
      }
      const options2 = {
        [kByteLength]: byteLength,
        fin: true,
        generateMask: this._generateMask,
        mask,
        maskBuffer: this._maskBuffer,
        opcode: 10,
        readOnly,
        rsv1: false
      };
      if (isBlob(data2)) {
        if (this._state !== DEFAULT) {
          this.enqueue([this.getBlobData, data2, false, options2, cb]);
        } else {
          this.getBlobData(data2, false, options2, cb);
        }
      } else if (this._state !== DEFAULT) {
        this.enqueue([this.dispatch, data2, false, options2, cb]);
      } else {
        this.sendFrame(Sender.frame(data2, options2), cb);
      }
    }
    send(data2, options2, cb) {
      const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
      let opcode = options2.binary ? 2 : 1;
      let rsv1 = options2.compress;
      let byteLength;
      let readOnly;
      if (typeof data2 === "string") {
        byteLength = Buffer.byteLength(data2);
        readOnly = false;
      } else if (isBlob(data2)) {
        byteLength = data2.size;
        readOnly = false;
      } else {
        data2 = toBuffer(data2);
        byteLength = data2.length;
        readOnly = toBuffer.readOnly;
      }
      if (this._firstFragment) {
        this._firstFragment = false;
        if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? "server_no_context_takeover" : "client_no_context_takeover"]) {
          rsv1 = byteLength >= perMessageDeflate._threshold;
        }
        this._compress = rsv1;
      } else {
        rsv1 = false;
        opcode = 0;
      }
      if (options2.fin)
        this._firstFragment = true;
      const opts = {
        [kByteLength]: byteLength,
        fin: options2.fin,
        generateMask: this._generateMask,
        mask: options2.mask,
        maskBuffer: this._maskBuffer,
        opcode,
        readOnly,
        rsv1
      };
      if (isBlob(data2)) {
        if (this._state !== DEFAULT) {
          this.enqueue([this.getBlobData, data2, this._compress, opts, cb]);
        } else {
          this.getBlobData(data2, this._compress, opts, cb);
        }
      } else if (this._state !== DEFAULT) {
        this.enqueue([this.dispatch, data2, this._compress, opts, cb]);
      } else {
        this.dispatch(data2, this._compress, opts, cb);
      }
    }
    getBlobData(blob, compress, options2, cb) {
      this._bufferedBytes += options2[kByteLength];
      this._state = GET_BLOB_DATA;
      blob.arrayBuffer().then((arrayBuffer) => {
        if (this._socket.destroyed) {
          const err = new Error("The socket was closed while the blob was being read");
          process.nextTick(callCallbacks, this, err, cb);
          return;
        }
        this._bufferedBytes -= options2[kByteLength];
        const data2 = toBuffer(arrayBuffer);
        if (!compress) {
          this._state = DEFAULT;
          this.sendFrame(Sender.frame(data2, options2), cb);
          this.dequeue();
        } else {
          this.dispatch(data2, compress, options2, cb);
        }
      }).catch((err) => {
        process.nextTick(onError, this, err, cb);
      });
    }
    dispatch(data2, compress, options2, cb) {
      if (!compress) {
        this.sendFrame(Sender.frame(data2, options2), cb);
        return;
      }
      const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
      this._bufferedBytes += options2[kByteLength];
      this._state = DEFLATING;
      perMessageDeflate.compress(data2, options2.fin, (_, buf) => {
        if (this._socket.destroyed) {
          const err = new Error("The socket was closed while data was being compressed");
          callCallbacks(this, err, cb);
          return;
        }
        this._bufferedBytes -= options2[kByteLength];
        this._state = DEFAULT;
        options2.readOnly = false;
        this.sendFrame(Sender.frame(buf, options2), cb);
        this.dequeue();
      });
    }
    dequeue() {
      while (this._state === DEFAULT && this._queue.length) {
        const params = this._queue.shift();
        this._bufferedBytes -= params[3][kByteLength];
        Reflect.apply(params[0], this, params.slice(1));
      }
    }
    enqueue(params) {
      this._bufferedBytes += params[3][kByteLength];
      this._queue.push(params);
    }
    sendFrame(list, cb) {
      if (list.length === 2) {
        this._socket.cork();
        this._socket.write(list[0]);
        this._socket.write(list[1], cb);
        this._socket.uncork();
      } else {
        this._socket.write(list[0], cb);
      }
    }
  }
  module.exports = Sender;
  function callCallbacks(sender, err, cb) {
    if (typeof cb === "function")
      cb(err);
    for (let i = 0;i < sender._queue.length; i++) {
      const params = sender._queue[i];
      const callback = params[params.length - 1];
      if (typeof callback === "function")
        callback(err);
    }
  }
  function onError(sender, err, cb) {
    callCallbacks(sender, err, cb);
    sender.onerror(err);
  }
});

// ../node_modules/.bun/ws@8.18.3+4789783d1fa00420/node_modules/ws/lib/event-target.js
var require_event_target = __commonJS((exports, module) => {
  var { kForOnEventAttribute, kListener } = require_constants();
  var kCode = Symbol("kCode");
  var kData = Symbol("kData");
  var kError = Symbol("kError");
  var kMessage = Symbol("kMessage");
  var kReason = Symbol("kReason");
  var kTarget = Symbol("kTarget");
  var kType = Symbol("kType");
  var kWasClean = Symbol("kWasClean");

  class Event {
    constructor(type) {
      this[kTarget] = null;
      this[kType] = type;
    }
    get target() {
      return this[kTarget];
    }
    get type() {
      return this[kType];
    }
  }
  Object.defineProperty(Event.prototype, "target", { enumerable: true });
  Object.defineProperty(Event.prototype, "type", { enumerable: true });

  class CloseEvent extends Event {
    constructor(type, options2 = {}) {
      super(type);
      this[kCode] = options2.code === undefined ? 0 : options2.code;
      this[kReason] = options2.reason === undefined ? "" : options2.reason;
      this[kWasClean] = options2.wasClean === undefined ? false : options2.wasClean;
    }
    get code() {
      return this[kCode];
    }
    get reason() {
      return this[kReason];
    }
    get wasClean() {
      return this[kWasClean];
    }
  }
  Object.defineProperty(CloseEvent.prototype, "code", { enumerable: true });
  Object.defineProperty(CloseEvent.prototype, "reason", { enumerable: true });
  Object.defineProperty(CloseEvent.prototype, "wasClean", { enumerable: true });

  class ErrorEvent extends Event {
    constructor(type, options2 = {}) {
      super(type);
      this[kError] = options2.error === undefined ? null : options2.error;
      this[kMessage] = options2.message === undefined ? "" : options2.message;
    }
    get error() {
      return this[kError];
    }
    get message() {
      return this[kMessage];
    }
  }
  Object.defineProperty(ErrorEvent.prototype, "error", { enumerable: true });
  Object.defineProperty(ErrorEvent.prototype, "message", { enumerable: true });

  class MessageEvent extends Event {
    constructor(type, options2 = {}) {
      super(type);
      this[kData] = options2.data === undefined ? null : options2.data;
    }
    get data() {
      return this[kData];
    }
  }
  Object.defineProperty(MessageEvent.prototype, "data", { enumerable: true });
  var EventTarget = {
    addEventListener(type, handler, options2 = {}) {
      for (const listener of this.listeners(type)) {
        if (!options2[kForOnEventAttribute] && listener[kListener] === handler && !listener[kForOnEventAttribute]) {
          return;
        }
      }
      let wrapper;
      if (type === "message") {
        wrapper = function onMessage(data2, isBinary) {
          const event = new MessageEvent("message", {
            data: isBinary ? data2 : data2.toString()
          });
          event[kTarget] = this;
          callListener(handler, this, event);
        };
      } else if (type === "close") {
        wrapper = function onClose(code, message) {
          const event = new CloseEvent("close", {
            code,
            reason: message.toString(),
            wasClean: this._closeFrameReceived && this._closeFrameSent
          });
          event[kTarget] = this;
          callListener(handler, this, event);
        };
      } else if (type === "error") {
        wrapper = function onError(error) {
          const event = new ErrorEvent("error", {
            error,
            message: error.message
          });
          event[kTarget] = this;
          callListener(handler, this, event);
        };
      } else if (type === "open") {
        wrapper = function onOpen() {
          const event = new Event("open");
          event[kTarget] = this;
          callListener(handler, this, event);
        };
      } else {
        return;
      }
      wrapper[kForOnEventAttribute] = !!options2[kForOnEventAttribute];
      wrapper[kListener] = handler;
      if (options2.once) {
        this.once(type, wrapper);
      } else {
        this.on(type, wrapper);
      }
    },
    removeEventListener(type, handler) {
      for (const listener of this.listeners(type)) {
        if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {
          this.removeListener(type, listener);
          break;
        }
      }
    }
  };
  module.exports = {
    CloseEvent,
    ErrorEvent,
    Event,
    EventTarget,
    MessageEvent
  };
  function callListener(listener, thisArg, event) {
    if (typeof listener === "object" && listener.handleEvent) {
      listener.handleEvent.call(listener, event);
    } else {
      listener.call(thisArg, event);
    }
  }
});

// ../node_modules/.bun/ws@8.18.3+4789783d1fa00420/node_modules/ws/lib/extension.js
var require_extension = __commonJS((exports, module) => {
  var { tokenChars } = require_validation();
  function push(dest, name, elem) {
    if (dest[name] === undefined)
      dest[name] = [elem];
    else
      dest[name].push(elem);
  }
  function parse(header) {
    const offers = Object.create(null);
    let params = Object.create(null);
    let mustUnescape = false;
    let isEscaping = false;
    let inQuotes = false;
    let extensionName;
    let paramName;
    let start = -1;
    let code = -1;
    let end = -1;
    let i = 0;
    for (;i < header.length; i++) {
      code = header.charCodeAt(i);
      if (extensionName === undefined) {
        if (end === -1 && tokenChars[code] === 1) {
          if (start === -1)
            start = i;
        } else if (i !== 0 && (code === 32 || code === 9)) {
          if (end === -1 && start !== -1)
            end = i;
        } else if (code === 59 || code === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (end === -1)
            end = i;
          const name = header.slice(start, end);
          if (code === 44) {
            push(offers, name, params);
            params = Object.create(null);
          } else {
            extensionName = name;
          }
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      } else if (paramName === undefined) {
        if (end === -1 && tokenChars[code] === 1) {
          if (start === -1)
            start = i;
        } else if (code === 32 || code === 9) {
          if (end === -1 && start !== -1)
            end = i;
        } else if (code === 59 || code === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (end === -1)
            end = i;
          push(params, header.slice(start, end), true);
          if (code === 44) {
            push(offers, extensionName, params);
            params = Object.create(null);
            extensionName = undefined;
          }
          start = end = -1;
        } else if (code === 61 && start !== -1 && end === -1) {
          paramName = header.slice(start, i);
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      } else {
        if (isEscaping) {
          if (tokenChars[code] !== 1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (start === -1)
            start = i;
          else if (!mustUnescape)
            mustUnescape = true;
          isEscaping = false;
        } else if (inQuotes) {
          if (tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (code === 34 && start !== -1) {
            inQuotes = false;
            end = i;
          } else if (code === 92) {
            isEscaping = true;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else if (code === 34 && header.charCodeAt(i - 1) === 61) {
          inQuotes = true;
        } else if (end === -1 && tokenChars[code] === 1) {
          if (start === -1)
            start = i;
        } else if (start !== -1 && (code === 32 || code === 9)) {
          if (end === -1)
            end = i;
        } else if (code === 59 || code === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (end === -1)
            end = i;
          let value = header.slice(start, end);
          if (mustUnescape) {
            value = value.replace(/\\/g, "");
            mustUnescape = false;
          }
          push(params, paramName, value);
          if (code === 44) {
            push(offers, extensionName, params);
            params = Object.create(null);
            extensionName = undefined;
          }
          paramName = undefined;
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      }
    }
    if (start === -1 || inQuotes || code === 32 || code === 9) {
      throw new SyntaxError("Unexpected end of input");
    }
    if (end === -1)
      end = i;
    const token = header.slice(start, end);
    if (extensionName === undefined) {
      push(offers, token, params);
    } else {
      if (paramName === undefined) {
        push(params, token, true);
      } else if (mustUnescape) {
        push(params, paramName, token.replace(/\\/g, ""));
      } else {
        push(params, paramName, token);
      }
      push(offers, extensionName, params);
    }
    return offers;
  }
  function format(extensions) {
    return Object.keys(extensions).map((extension) => {
      let configurations = extensions[extension];
      if (!Array.isArray(configurations))
        configurations = [configurations];
      return configurations.map((params) => {
        return [extension].concat(Object.keys(params).map((k) => {
          let values = params[k];
          if (!Array.isArray(values))
            values = [values];
          return values.map((v) => v === true ? k : `${k}=${v}`).join("; ");
        })).join("; ");
      }).join(", ");
    }).join(", ");
  }
  module.exports = { format, parse };
});

// ../node_modules/.bun/ws@8.18.3+4789783d1fa00420/node_modules/ws/lib/websocket.js
var require_websocket = __commonJS((exports, module) => {
  var EventEmitter = __require("events");
  var https = __require("https");
  var http = __require("http");
  var net = __require("net");
  var tls = __require("tls");
  var { randomBytes, createHash } = __require("crypto");
  var { Duplex, Readable } = __require("stream");
  var { URL: URL2 } = __require("url");
  var PerMessageDeflate = require_permessage_deflate();
  var Receiver = require_receiver();
  var Sender = require_sender();
  var { isBlob } = require_validation();
  var {
    BINARY_TYPES,
    EMPTY_BUFFER,
    GUID,
    kForOnEventAttribute,
    kListener,
    kStatusCode,
    kWebSocket,
    NOOP
  } = require_constants();
  var {
    EventTarget: { addEventListener, removeEventListener }
  } = require_event_target();
  var { format, parse } = require_extension();
  var { toBuffer } = require_buffer_util();
  var closeTimeout = 30 * 1000;
  var kAborted = Symbol("kAborted");
  var protocolVersions = [8, 13];
  var readyStates = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"];
  var subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;

  class WebSocket extends EventEmitter {
    constructor(address2, protocols, options2) {
      super();
      this._binaryType = BINARY_TYPES[0];
      this._closeCode = 1006;
      this._closeFrameReceived = false;
      this._closeFrameSent = false;
      this._closeMessage = EMPTY_BUFFER;
      this._closeTimer = null;
      this._errorEmitted = false;
      this._extensions = {};
      this._paused = false;
      this._protocol = "";
      this._readyState = WebSocket.CONNECTING;
      this._receiver = null;
      this._sender = null;
      this._socket = null;
      if (address2 !== null) {
        this._bufferedAmount = 0;
        this._isServer = false;
        this._redirects = 0;
        if (protocols === undefined) {
          protocols = [];
        } else if (!Array.isArray(protocols)) {
          if (typeof protocols === "object" && protocols !== null) {
            options2 = protocols;
            protocols = [];
          } else {
            protocols = [protocols];
          }
        }
        initAsClient(this, address2, protocols, options2);
      } else {
        this._autoPong = options2.autoPong;
        this._isServer = true;
      }
    }
    get binaryType() {
      return this._binaryType;
    }
    set binaryType(type) {
      if (!BINARY_TYPES.includes(type))
        return;
      this._binaryType = type;
      if (this._receiver)
        this._receiver._binaryType = type;
    }
    get bufferedAmount() {
      if (!this._socket)
        return this._bufferedAmount;
      return this._socket._writableState.length + this._sender._bufferedBytes;
    }
    get extensions() {
      return Object.keys(this._extensions).join();
    }
    get isPaused() {
      return this._paused;
    }
    get onclose() {
      return null;
    }
    get onerror() {
      return null;
    }
    get onopen() {
      return null;
    }
    get onmessage() {
      return null;
    }
    get protocol() {
      return this._protocol;
    }
    get readyState() {
      return this._readyState;
    }
    get url() {
      return this._url;
    }
    setSocket(socket, head, options2) {
      const receiver = new Receiver({
        allowSynchronousEvents: options2.allowSynchronousEvents,
        binaryType: this.binaryType,
        extensions: this._extensions,
        isServer: this._isServer,
        maxPayload: options2.maxPayload,
        skipUTF8Validation: options2.skipUTF8Validation
      });
      const sender = new Sender(socket, this._extensions, options2.generateMask);
      this._receiver = receiver;
      this._sender = sender;
      this._socket = socket;
      receiver[kWebSocket] = this;
      sender[kWebSocket] = this;
      socket[kWebSocket] = this;
      receiver.on("conclude", receiverOnConclude);
      receiver.on("drain", receiverOnDrain);
      receiver.on("error", receiverOnError);
      receiver.on("message", receiverOnMessage);
      receiver.on("ping", receiverOnPing);
      receiver.on("pong", receiverOnPong);
      sender.onerror = senderOnError;
      if (socket.setTimeout)
        socket.setTimeout(0);
      if (socket.setNoDelay)
        socket.setNoDelay();
      if (head.length > 0)
        socket.unshift(head);
      socket.on("close", socketOnClose);
      socket.on("data", socketOnData);
      socket.on("end", socketOnEnd);
      socket.on("error", socketOnError);
      this._readyState = WebSocket.OPEN;
      this.emit("open");
    }
    emitClose() {
      if (!this._socket) {
        this._readyState = WebSocket.CLOSED;
        this.emit("close", this._closeCode, this._closeMessage);
        return;
      }
      if (this._extensions[PerMessageDeflate.extensionName]) {
        this._extensions[PerMessageDeflate.extensionName].cleanup();
      }
      this._receiver.removeAllListeners();
      this._readyState = WebSocket.CLOSED;
      this.emit("close", this._closeCode, this._closeMessage);
    }
    close(code, data2) {
      if (this.readyState === WebSocket.CLOSED)
        return;
      if (this.readyState === WebSocket.CONNECTING) {
        const msg = "WebSocket was closed before the connection was established";
        abortHandshake(this, this._req, msg);
        return;
      }
      if (this.readyState === WebSocket.CLOSING) {
        if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {
          this._socket.end();
        }
        return;
      }
      this._readyState = WebSocket.CLOSING;
      this._sender.close(code, data2, !this._isServer, (err) => {
        if (err)
          return;
        this._closeFrameSent = true;
        if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {
          this._socket.end();
        }
      });
      setCloseTimer(this);
    }
    pause() {
      if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {
        return;
      }
      this._paused = true;
      this._socket.pause();
    }
    ping(data2, mask, cb) {
      if (this.readyState === WebSocket.CONNECTING) {
        throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
      }
      if (typeof data2 === "function") {
        cb = data2;
        data2 = mask = undefined;
      } else if (typeof mask === "function") {
        cb = mask;
        mask = undefined;
      }
      if (typeof data2 === "number")
        data2 = data2.toString();
      if (this.readyState !== WebSocket.OPEN) {
        sendAfterClose(this, data2, cb);
        return;
      }
      if (mask === undefined)
        mask = !this._isServer;
      this._sender.ping(data2 || EMPTY_BUFFER, mask, cb);
    }
    pong(data2, mask, cb) {
      if (this.readyState === WebSocket.CONNECTING) {
        throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
      }
      if (typeof data2 === "function") {
        cb = data2;
        data2 = mask = undefined;
      } else if (typeof mask === "function") {
        cb = mask;
        mask = undefined;
      }
      if (typeof data2 === "number")
        data2 = data2.toString();
      if (this.readyState !== WebSocket.OPEN) {
        sendAfterClose(this, data2, cb);
        return;
      }
      if (mask === undefined)
        mask = !this._isServer;
      this._sender.pong(data2 || EMPTY_BUFFER, mask, cb);
    }
    resume() {
      if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {
        return;
      }
      this._paused = false;
      if (!this._receiver._writableState.needDrain)
        this._socket.resume();
    }
    send(data2, options2, cb) {
      if (this.readyState === WebSocket.CONNECTING) {
        throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
      }
      if (typeof options2 === "function") {
        cb = options2;
        options2 = {};
      }
      if (typeof data2 === "number")
        data2 = data2.toString();
      if (this.readyState !== WebSocket.OPEN) {
        sendAfterClose(this, data2, cb);
        return;
      }
      const opts = {
        binary: typeof data2 !== "string",
        mask: !this._isServer,
        compress: true,
        fin: true,
        ...options2
      };
      if (!this._extensions[PerMessageDeflate.extensionName]) {
        opts.compress = false;
      }
      this._sender.send(data2 || EMPTY_BUFFER, opts, cb);
    }
    terminate() {
      if (this.readyState === WebSocket.CLOSED)
        return;
      if (this.readyState === WebSocket.CONNECTING) {
        const msg = "WebSocket was closed before the connection was established";
        abortHandshake(this, this._req, msg);
        return;
      }
      if (this._socket) {
        this._readyState = WebSocket.CLOSING;
        this._socket.destroy();
      }
    }
  }
  Object.defineProperty(WebSocket, "CONNECTING", {
    enumerable: true,
    value: readyStates.indexOf("CONNECTING")
  });
  Object.defineProperty(WebSocket.prototype, "CONNECTING", {
    enumerable: true,
    value: readyStates.indexOf("CONNECTING")
  });
  Object.defineProperty(WebSocket, "OPEN", {
    enumerable: true,
    value: readyStates.indexOf("OPEN")
  });
  Object.defineProperty(WebSocket.prototype, "OPEN", {
    enumerable: true,
    value: readyStates.indexOf("OPEN")
  });
  Object.defineProperty(WebSocket, "CLOSING", {
    enumerable: true,
    value: readyStates.indexOf("CLOSING")
  });
  Object.defineProperty(WebSocket.prototype, "CLOSING", {
    enumerable: true,
    value: readyStates.indexOf("CLOSING")
  });
  Object.defineProperty(WebSocket, "CLOSED", {
    enumerable: true,
    value: readyStates.indexOf("CLOSED")
  });
  Object.defineProperty(WebSocket.prototype, "CLOSED", {
    enumerable: true,
    value: readyStates.indexOf("CLOSED")
  });
  [
    "binaryType",
    "bufferedAmount",
    "extensions",
    "isPaused",
    "protocol",
    "readyState",
    "url"
  ].forEach((property) => {
    Object.defineProperty(WebSocket.prototype, property, { enumerable: true });
  });
  ["open", "error", "close", "message"].forEach((method) => {
    Object.defineProperty(WebSocket.prototype, `on${method}`, {
      enumerable: true,
      get() {
        for (const listener of this.listeners(method)) {
          if (listener[kForOnEventAttribute])
            return listener[kListener];
        }
        return null;
      },
      set(handler) {
        for (const listener of this.listeners(method)) {
          if (listener[kForOnEventAttribute]) {
            this.removeListener(method, listener);
            break;
          }
        }
        if (typeof handler !== "function")
          return;
        this.addEventListener(method, handler, {
          [kForOnEventAttribute]: true
        });
      }
    });
  });
  WebSocket.prototype.addEventListener = addEventListener;
  WebSocket.prototype.removeEventListener = removeEventListener;
  module.exports = WebSocket;
  function initAsClient(websocket, address2, protocols, options2) {
    const opts = {
      allowSynchronousEvents: true,
      autoPong: true,
      protocolVersion: protocolVersions[1],
      maxPayload: 100 * 1024 * 1024,
      skipUTF8Validation: false,
      perMessageDeflate: true,
      followRedirects: false,
      maxRedirects: 10,
      ...options2,
      socketPath: undefined,
      hostname: undefined,
      protocol: undefined,
      timeout: undefined,
      method: "GET",
      host: undefined,
      path: undefined,
      port: undefined
    };
    websocket._autoPong = opts.autoPong;
    if (!protocolVersions.includes(opts.protocolVersion)) {
      throw new RangeError(`Unsupported protocol version: ${opts.protocolVersion} ` + `(supported versions: ${protocolVersions.join(", ")})`);
    }
    let parsedUrl;
    if (address2 instanceof URL2) {
      parsedUrl = address2;
    } else {
      try {
        parsedUrl = new URL2(address2);
      } catch (e5) {
        throw new SyntaxError(`Invalid URL: ${address2}`);
      }
    }
    if (parsedUrl.protocol === "http:") {
      parsedUrl.protocol = "ws:";
    } else if (parsedUrl.protocol === "https:") {
      parsedUrl.protocol = "wss:";
    }
    websocket._url = parsedUrl.href;
    const isSecure = parsedUrl.protocol === "wss:";
    const isIpcUrl = parsedUrl.protocol === "ws+unix:";
    let invalidUrlMessage;
    if (parsedUrl.protocol !== "ws:" && !isSecure && !isIpcUrl) {
      invalidUrlMessage = `The URL's protocol must be one of "ws:", "wss:", ` + '"http:", "https:", or "ws+unix:"';
    } else if (isIpcUrl && !parsedUrl.pathname) {
      invalidUrlMessage = "The URL's pathname is empty";
    } else if (parsedUrl.hash) {
      invalidUrlMessage = "The URL contains a fragment identifier";
    }
    if (invalidUrlMessage) {
      const err = new SyntaxError(invalidUrlMessage);
      if (websocket._redirects === 0) {
        throw err;
      } else {
        emitErrorAndClose(websocket, err);
        return;
      }
    }
    const defaultPort = isSecure ? 443 : 80;
    const key = randomBytes(16).toString("base64");
    const request = isSecure ? https.request : http.request;
    const protocolSet = new Set;
    let perMessageDeflate;
    opts.createConnection = opts.createConnection || (isSecure ? tlsConnect : netConnect);
    opts.defaultPort = opts.defaultPort || defaultPort;
    opts.port = parsedUrl.port || defaultPort;
    opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
    opts.headers = {
      ...opts.headers,
      "Sec-WebSocket-Version": opts.protocolVersion,
      "Sec-WebSocket-Key": key,
      Connection: "Upgrade",
      Upgrade: "websocket"
    };
    opts.path = parsedUrl.pathname + parsedUrl.search;
    opts.timeout = opts.handshakeTimeout;
    if (opts.perMessageDeflate) {
      perMessageDeflate = new PerMessageDeflate(opts.perMessageDeflate !== true ? opts.perMessageDeflate : {}, false, opts.maxPayload);
      opts.headers["Sec-WebSocket-Extensions"] = format({
        [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
      });
    }
    if (protocols.length) {
      for (const protocol of protocols) {
        if (typeof protocol !== "string" || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) {
          throw new SyntaxError("An invalid or duplicated subprotocol was specified");
        }
        protocolSet.add(protocol);
      }
      opts.headers["Sec-WebSocket-Protocol"] = protocols.join(",");
    }
    if (opts.origin) {
      if (opts.protocolVersion < 13) {
        opts.headers["Sec-WebSocket-Origin"] = opts.origin;
      } else {
        opts.headers.Origin = opts.origin;
      }
    }
    if (parsedUrl.username || parsedUrl.password) {
      opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
    }
    if (isIpcUrl) {
      const parts = opts.path.split(":");
      opts.socketPath = parts[0];
      opts.path = parts[1];
    }
    let req;
    if (opts.followRedirects) {
      if (websocket._redirects === 0) {
        websocket._originalIpc = isIpcUrl;
        websocket._originalSecure = isSecure;
        websocket._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;
        const headers = options2 && options2.headers;
        options2 = { ...options2, headers: {} };
        if (headers) {
          for (const [key2, value] of Object.entries(headers)) {
            options2.headers[key2.toLowerCase()] = value;
          }
        }
      } else if (websocket.listenerCount("redirect") === 0) {
        const isSameHost = isIpcUrl ? websocket._originalIpc ? opts.socketPath === websocket._originalHostOrSocketPath : false : websocket._originalIpc ? false : parsedUrl.host === websocket._originalHostOrSocketPath;
        if (!isSameHost || websocket._originalSecure && !isSecure) {
          delete opts.headers.authorization;
          delete opts.headers.cookie;
          if (!isSameHost)
            delete opts.headers.host;
          opts.auth = undefined;
        }
      }
      if (opts.auth && !options2.headers.authorization) {
        options2.headers.authorization = "Basic " + Buffer.from(opts.auth).toString("base64");
      }
      req = websocket._req = request(opts);
      if (websocket._redirects) {
        websocket.emit("redirect", websocket.url, req);
      }
    } else {
      req = websocket._req = request(opts);
    }
    if (opts.timeout) {
      req.on("timeout", () => {
        abortHandshake(websocket, req, "Opening handshake has timed out");
      });
    }
    req.on("error", (err) => {
      if (req === null || req[kAborted])
        return;
      req = websocket._req = null;
      emitErrorAndClose(websocket, err);
    });
    req.on("response", (res) => {
      const location = res.headers.location;
      const statusCode = res.statusCode;
      if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
        if (++websocket._redirects > opts.maxRedirects) {
          abortHandshake(websocket, req, "Maximum redirects exceeded");
          return;
        }
        req.abort();
        let addr;
        try {
          addr = new URL2(location, address2);
        } catch (e5) {
          const err = new SyntaxError(`Invalid URL: ${location}`);
          emitErrorAndClose(websocket, err);
          return;
        }
        initAsClient(websocket, addr, protocols, options2);
      } else if (!websocket.emit("unexpected-response", req, res)) {
        abortHandshake(websocket, req, `Unexpected server response: ${res.statusCode}`);
      }
    });
    req.on("upgrade", (res, socket, head) => {
      websocket.emit("upgrade", res);
      if (websocket.readyState !== WebSocket.CONNECTING)
        return;
      req = websocket._req = null;
      const upgrade = res.headers.upgrade;
      if (upgrade === undefined || upgrade.toLowerCase() !== "websocket") {
        abortHandshake(websocket, socket, "Invalid Upgrade header");
        return;
      }
      const digest = createHash("sha1").update(key + GUID).digest("base64");
      if (res.headers["sec-websocket-accept"] !== digest) {
        abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Accept header");
        return;
      }
      const serverProt = res.headers["sec-websocket-protocol"];
      let protError;
      if (serverProt !== undefined) {
        if (!protocolSet.size) {
          protError = "Server sent a subprotocol but none was requested";
        } else if (!protocolSet.has(serverProt)) {
          protError = "Server sent an invalid subprotocol";
        }
      } else if (protocolSet.size) {
        protError = "Server sent no subprotocol";
      }
      if (protError) {
        abortHandshake(websocket, socket, protError);
        return;
      }
      if (serverProt)
        websocket._protocol = serverProt;
      const secWebSocketExtensions = res.headers["sec-websocket-extensions"];
      if (secWebSocketExtensions !== undefined) {
        if (!perMessageDeflate) {
          const message = "Server sent a Sec-WebSocket-Extensions header but no extension " + "was requested";
          abortHandshake(websocket, socket, message);
          return;
        }
        let extensions;
        try {
          extensions = parse(secWebSocketExtensions);
        } catch (err) {
          const message = "Invalid Sec-WebSocket-Extensions header";
          abortHandshake(websocket, socket, message);
          return;
        }
        const extensionNames = Object.keys(extensions);
        if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {
          const message = "Server indicated an extension that was not requested";
          abortHandshake(websocket, socket, message);
          return;
        }
        try {
          perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
        } catch (err) {
          const message = "Invalid Sec-WebSocket-Extensions header";
          abortHandshake(websocket, socket, message);
          return;
        }
        websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
      }
      websocket.setSocket(socket, head, {
        allowSynchronousEvents: opts.allowSynchronousEvents,
        generateMask: opts.generateMask,
        maxPayload: opts.maxPayload,
        skipUTF8Validation: opts.skipUTF8Validation
      });
    });
    if (opts.finishRequest) {
      opts.finishRequest(req, websocket);
    } else {
      req.end();
    }
  }
  function emitErrorAndClose(websocket, err) {
    websocket._readyState = WebSocket.CLOSING;
    websocket._errorEmitted = true;
    websocket.emit("error", err);
    websocket.emitClose();
  }
  function netConnect(options2) {
    options2.path = options2.socketPath;
    return net.connect(options2);
  }
  function tlsConnect(options2) {
    options2.path = undefined;
    if (!options2.servername && options2.servername !== "") {
      options2.servername = net.isIP(options2.host) ? "" : options2.host;
    }
    return tls.connect(options2);
  }
  function abortHandshake(websocket, stream, message) {
    websocket._readyState = WebSocket.CLOSING;
    const err = new Error(message);
    Error.captureStackTrace(err, abortHandshake);
    if (stream.setHeader) {
      stream[kAborted] = true;
      stream.abort();
      if (stream.socket && !stream.socket.destroyed) {
        stream.socket.destroy();
      }
      process.nextTick(emitErrorAndClose, websocket, err);
    } else {
      stream.destroy(err);
      stream.once("error", websocket.emit.bind(websocket, "error"));
      stream.once("close", websocket.emitClose.bind(websocket));
    }
  }
  function sendAfterClose(websocket, data2, cb) {
    if (data2) {
      const length = isBlob(data2) ? data2.size : toBuffer(data2).length;
      if (websocket._socket)
        websocket._sender._bufferedBytes += length;
      else
        websocket._bufferedAmount += length;
    }
    if (cb) {
      const err = new Error(`WebSocket is not open: readyState ${websocket.readyState} ` + `(${readyStates[websocket.readyState]})`);
      process.nextTick(cb, err);
    }
  }
  function receiverOnConclude(code, reason) {
    const websocket = this[kWebSocket];
    websocket._closeFrameReceived = true;
    websocket._closeMessage = reason;
    websocket._closeCode = code;
    if (websocket._socket[kWebSocket] === undefined)
      return;
    websocket._socket.removeListener("data", socketOnData);
    process.nextTick(resume, websocket._socket);
    if (code === 1005)
      websocket.close();
    else
      websocket.close(code, reason);
  }
  function receiverOnDrain() {
    const websocket = this[kWebSocket];
    if (!websocket.isPaused)
      websocket._socket.resume();
  }
  function receiverOnError(err) {
    const websocket = this[kWebSocket];
    if (websocket._socket[kWebSocket] !== undefined) {
      websocket._socket.removeListener("data", socketOnData);
      process.nextTick(resume, websocket._socket);
      websocket.close(err[kStatusCode]);
    }
    if (!websocket._errorEmitted) {
      websocket._errorEmitted = true;
      websocket.emit("error", err);
    }
  }
  function receiverOnFinish() {
    this[kWebSocket].emitClose();
  }
  function receiverOnMessage(data2, isBinary) {
    this[kWebSocket].emit("message", data2, isBinary);
  }
  function receiverOnPing(data2) {
    const websocket = this[kWebSocket];
    if (websocket._autoPong)
      websocket.pong(data2, !this._isServer, NOOP);
    websocket.emit("ping", data2);
  }
  function receiverOnPong(data2) {
    this[kWebSocket].emit("pong", data2);
  }
  function resume(stream) {
    stream.resume();
  }
  function senderOnError(err) {
    const websocket = this[kWebSocket];
    if (websocket.readyState === WebSocket.CLOSED)
      return;
    if (websocket.readyState === WebSocket.OPEN) {
      websocket._readyState = WebSocket.CLOSING;
      setCloseTimer(websocket);
    }
    this._socket.end();
    if (!websocket._errorEmitted) {
      websocket._errorEmitted = true;
      websocket.emit("error", err);
    }
  }
  function setCloseTimer(websocket) {
    websocket._closeTimer = setTimeout(websocket._socket.destroy.bind(websocket._socket), closeTimeout);
  }
  function socketOnClose() {
    const websocket = this[kWebSocket];
    this.removeListener("close", socketOnClose);
    this.removeListener("data", socketOnData);
    this.removeListener("end", socketOnEnd);
    websocket._readyState = WebSocket.CLOSING;
    let chunk;
    if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk = websocket._socket.read()) !== null) {
      websocket._receiver.write(chunk);
    }
    websocket._receiver.end();
    this[kWebSocket] = undefined;
    clearTimeout(websocket._closeTimer);
    if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {
      websocket.emitClose();
    } else {
      websocket._receiver.on("error", receiverOnFinish);
      websocket._receiver.on("finish", receiverOnFinish);
    }
  }
  function socketOnData(chunk) {
    if (!this[kWebSocket]._receiver.write(chunk)) {
      this.pause();
    }
  }
  function socketOnEnd() {
    const websocket = this[kWebSocket];
    websocket._readyState = WebSocket.CLOSING;
    websocket._receiver.end();
    this.end();
  }
  function socketOnError() {
    const websocket = this[kWebSocket];
    this.removeListener("error", socketOnError);
    this.on("error", NOOP);
    if (websocket) {
      websocket._readyState = WebSocket.CLOSING;
      this.destroy();
    }
  }
});

// ../node_modules/.bun/ws@8.18.3+4789783d1fa00420/node_modules/ws/lib/stream.js
var require_stream = __commonJS((exports, module) => {
  var WebSocket = require_websocket();
  var { Duplex } = __require("stream");
  function emitClose(stream) {
    stream.emit("close");
  }
  function duplexOnEnd() {
    if (!this.destroyed && this._writableState.finished) {
      this.destroy();
    }
  }
  function duplexOnError(err) {
    this.removeListener("error", duplexOnError);
    this.destroy();
    if (this.listenerCount("error") === 0) {
      this.emit("error", err);
    }
  }
  function createWebSocketStream(ws, options2) {
    let terminateOnDestroy = true;
    const duplex = new Duplex({
      ...options2,
      autoDestroy: false,
      emitClose: false,
      objectMode: false,
      writableObjectMode: false
    });
    ws.on("message", function message(msg, isBinary) {
      const data2 = !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;
      if (!duplex.push(data2))
        ws.pause();
    });
    ws.once("error", function error(err) {
      if (duplex.destroyed)
        return;
      terminateOnDestroy = false;
      duplex.destroy(err);
    });
    ws.once("close", function close() {
      if (duplex.destroyed)
        return;
      duplex.push(null);
    });
    duplex._destroy = function(err, callback) {
      if (ws.readyState === ws.CLOSED) {
        callback(err);
        process.nextTick(emitClose, duplex);
        return;
      }
      let called = false;
      ws.once("error", function error(err2) {
        called = true;
        callback(err2);
      });
      ws.once("close", function close() {
        if (!called)
          callback(err);
        process.nextTick(emitClose, duplex);
      });
      if (terminateOnDestroy)
        ws.terminate();
    };
    duplex._final = function(callback) {
      if (ws.readyState === ws.CONNECTING) {
        ws.once("open", function open() {
          duplex._final(callback);
        });
        return;
      }
      if (ws._socket === null)
        return;
      if (ws._socket._writableState.finished) {
        callback();
        if (duplex._readableState.endEmitted)
          duplex.destroy();
      } else {
        ws._socket.once("finish", function finish() {
          callback();
        });
        ws.close();
      }
    };
    duplex._read = function() {
      if (ws.isPaused)
        ws.resume();
    };
    duplex._write = function(chunk, encoding, callback) {
      if (ws.readyState === ws.CONNECTING) {
        ws.once("open", function open() {
          duplex._write(chunk, encoding, callback);
        });
        return;
      }
      ws.send(chunk, callback);
    };
    duplex.on("end", duplexOnEnd);
    duplex.on("error", duplexOnError);
    return duplex;
  }
  module.exports = createWebSocketStream;
});

// ../node_modules/.bun/ws@8.18.3+4789783d1fa00420/node_modules/ws/lib/subprotocol.js
var require_subprotocol = __commonJS((exports, module) => {
  var { tokenChars } = require_validation();
  function parse(header) {
    const protocols = new Set;
    let start = -1;
    let end = -1;
    let i = 0;
    for (i;i < header.length; i++) {
      const code = header.charCodeAt(i);
      if (end === -1 && tokenChars[code] === 1) {
        if (start === -1)
          start = i;
      } else if (i !== 0 && (code === 32 || code === 9)) {
        if (end === -1 && start !== -1)
          end = i;
      } else if (code === 44) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
        if (end === -1)
          end = i;
        const protocol2 = header.slice(start, end);
        if (protocols.has(protocol2)) {
          throw new SyntaxError(`The "${protocol2}" subprotocol is duplicated`);
        }
        protocols.add(protocol2);
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    }
    if (start === -1 || end !== -1) {
      throw new SyntaxError("Unexpected end of input");
    }
    const protocol = header.slice(start, i);
    if (protocols.has(protocol)) {
      throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
    }
    protocols.add(protocol);
    return protocols;
  }
  module.exports = { parse };
});

// ../node_modules/.bun/ws@8.18.3+4789783d1fa00420/node_modules/ws/lib/websocket-server.js
var require_websocket_server = __commonJS((exports, module) => {
  var EventEmitter = __require("events");
  var http = __require("http");
  var { Duplex } = __require("stream");
  var { createHash } = __require("crypto");
  var extension = require_extension();
  var PerMessageDeflate = require_permessage_deflate();
  var subprotocol = require_subprotocol();
  var WebSocket = require_websocket();
  var { GUID, kWebSocket } = require_constants();
  var keyRegex = /^[+/0-9A-Za-z]{22}==$/;
  var RUNNING = 0;
  var CLOSING = 1;
  var CLOSED = 2;

  class WebSocketServer extends EventEmitter {
    constructor(options2, callback) {
      super();
      options2 = {
        allowSynchronousEvents: true,
        autoPong: true,
        maxPayload: 100 * 1024 * 1024,
        skipUTF8Validation: false,
        perMessageDeflate: false,
        handleProtocols: null,
        clientTracking: true,
        verifyClient: null,
        noServer: false,
        backlog: null,
        server: null,
        host: null,
        path: null,
        port: null,
        WebSocket,
        ...options2
      };
      if (options2.port == null && !options2.server && !options2.noServer || options2.port != null && (options2.server || options2.noServer) || options2.server && options2.noServer) {
        throw new TypeError('One and only one of the "port", "server", or "noServer" options ' + "must be specified");
      }
      if (options2.port != null) {
        this._server = http.createServer((req, res) => {
          const body = http.STATUS_CODES[426];
          res.writeHead(426, {
            "Content-Length": body.length,
            "Content-Type": "text/plain"
          });
          res.end(body);
        });
        this._server.listen(options2.port, options2.host, options2.backlog, callback);
      } else if (options2.server) {
        this._server = options2.server;
      }
      if (this._server) {
        const emitConnection = this.emit.bind(this, "connection");
        this._removeListeners = addListeners(this._server, {
          listening: this.emit.bind(this, "listening"),
          error: this.emit.bind(this, "error"),
          upgrade: (req, socket, head) => {
            this.handleUpgrade(req, socket, head, emitConnection);
          }
        });
      }
      if (options2.perMessageDeflate === true)
        options2.perMessageDeflate = {};
      if (options2.clientTracking) {
        this.clients = new Set;
        this._shouldEmitClose = false;
      }
      this.options = options2;
      this._state = RUNNING;
    }
    address() {
      if (this.options.noServer) {
        throw new Error('The server is operating in "noServer" mode');
      }
      if (!this._server)
        return null;
      return this._server.address();
    }
    close(cb) {
      if (this._state === CLOSED) {
        if (cb) {
          this.once("close", () => {
            cb(new Error("The server is not running"));
          });
        }
        process.nextTick(emitClose, this);
        return;
      }
      if (cb)
        this.once("close", cb);
      if (this._state === CLOSING)
        return;
      this._state = CLOSING;
      if (this.options.noServer || this.options.server) {
        if (this._server) {
          this._removeListeners();
          this._removeListeners = this._server = null;
        }
        if (this.clients) {
          if (!this.clients.size) {
            process.nextTick(emitClose, this);
          } else {
            this._shouldEmitClose = true;
          }
        } else {
          process.nextTick(emitClose, this);
        }
      } else {
        const server = this._server;
        this._removeListeners();
        this._removeListeners = this._server = null;
        server.close(() => {
          emitClose(this);
        });
      }
    }
    shouldHandle(req) {
      if (this.options.path) {
        const index = req.url.indexOf("?");
        const pathname = index !== -1 ? req.url.slice(0, index) : req.url;
        if (pathname !== this.options.path)
          return false;
      }
      return true;
    }
    handleUpgrade(req, socket, head, cb) {
      socket.on("error", socketOnError);
      const key = req.headers["sec-websocket-key"];
      const upgrade = req.headers.upgrade;
      const version = +req.headers["sec-websocket-version"];
      if (req.method !== "GET") {
        const message = "Invalid HTTP method";
        abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);
        return;
      }
      if (upgrade === undefined || upgrade.toLowerCase() !== "websocket") {
        const message = "Invalid Upgrade header";
        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
        return;
      }
      if (key === undefined || !keyRegex.test(key)) {
        const message = "Missing or invalid Sec-WebSocket-Key header";
        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
        return;
      }
      if (version !== 13 && version !== 8) {
        const message = "Missing or invalid Sec-WebSocket-Version header";
        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message, {
          "Sec-WebSocket-Version": "13, 8"
        });
        return;
      }
      if (!this.shouldHandle(req)) {
        abortHandshake(socket, 400);
        return;
      }
      const secWebSocketProtocol = req.headers["sec-websocket-protocol"];
      let protocols = new Set;
      if (secWebSocketProtocol !== undefined) {
        try {
          protocols = subprotocol.parse(secWebSocketProtocol);
        } catch (err) {
          const message = "Invalid Sec-WebSocket-Protocol header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
      }
      const secWebSocketExtensions = req.headers["sec-websocket-extensions"];
      const extensions = {};
      if (this.options.perMessageDeflate && secWebSocketExtensions !== undefined) {
        const perMessageDeflate = new PerMessageDeflate(this.options.perMessageDeflate, true, this.options.maxPayload);
        try {
          const offers = extension.parse(secWebSocketExtensions);
          if (offers[PerMessageDeflate.extensionName]) {
            perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
            extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
          }
        } catch (err) {
          const message = "Invalid or unacceptable Sec-WebSocket-Extensions header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
      }
      if (this.options.verifyClient) {
        const info = {
          origin: req.headers[`${version === 8 ? "sec-websocket-origin" : "origin"}`],
          secure: !!(req.socket.authorized || req.socket.encrypted),
          req
        };
        if (this.options.verifyClient.length === 2) {
          this.options.verifyClient(info, (verified, code, message, headers) => {
            if (!verified) {
              return abortHandshake(socket, code || 401, message, headers);
            }
            this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
          });
          return;
        }
        if (!this.options.verifyClient(info))
          return abortHandshake(socket, 401);
      }
      this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
    }
    completeUpgrade(extensions, key, protocols, req, socket, head, cb) {
      if (!socket.readable || !socket.writable)
        return socket.destroy();
      if (socket[kWebSocket]) {
        throw new Error("server.handleUpgrade() was called more than once with the same " + "socket, possibly due to a misconfiguration");
      }
      if (this._state > RUNNING)
        return abortHandshake(socket, 503);
      const digest = createHash("sha1").update(key + GUID).digest("base64");
      const headers = [
        "HTTP/1.1 101 Switching Protocols",
        "Upgrade: websocket",
        "Connection: Upgrade",
        `Sec-WebSocket-Accept: ${digest}`
      ];
      const ws = new this.options.WebSocket(null, undefined, this.options);
      if (protocols.size) {
        const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;
        if (protocol) {
          headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
          ws._protocol = protocol;
        }
      }
      if (extensions[PerMessageDeflate.extensionName]) {
        const params = extensions[PerMessageDeflate.extensionName].params;
        const value = extension.format({
          [PerMessageDeflate.extensionName]: [params]
        });
        headers.push(`Sec-WebSocket-Extensions: ${value}`);
        ws._extensions = extensions;
      }
      this.emit("headers", headers, req);
      socket.write(headers.concat(`\r
`).join(`\r
`));
      socket.removeListener("error", socketOnError);
      ws.setSocket(socket, head, {
        allowSynchronousEvents: this.options.allowSynchronousEvents,
        maxPayload: this.options.maxPayload,
        skipUTF8Validation: this.options.skipUTF8Validation
      });
      if (this.clients) {
        this.clients.add(ws);
        ws.on("close", () => {
          this.clients.delete(ws);
          if (this._shouldEmitClose && !this.clients.size) {
            process.nextTick(emitClose, this);
          }
        });
      }
      cb(ws, req);
    }
  }
  module.exports = WebSocketServer;
  function addListeners(server, map) {
    for (const event of Object.keys(map))
      server.on(event, map[event]);
    return function removeListeners() {
      for (const event of Object.keys(map)) {
        server.removeListener(event, map[event]);
      }
    };
  }
  function emitClose(server) {
    server._state = CLOSED;
    server.emit("close");
  }
  function socketOnError() {
    this.destroy();
  }
  function abortHandshake(socket, code, message, headers) {
    message = message || http.STATUS_CODES[code];
    headers = {
      Connection: "close",
      "Content-Type": "text/html",
      "Content-Length": Buffer.byteLength(message),
      ...headers
    };
    socket.once("finish", socket.destroy);
    socket.end(`HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\r
` + Object.keys(headers).map((h) => `${h}: ${headers[h]}`).join(`\r
`) + `\r
\r
` + message);
  }
  function abortHandshakeOrEmitwsClientError(server, req, socket, code, message, headers) {
    if (server.listenerCount("wsClientError")) {
      const err = new Error(message);
      Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);
      server.emit("wsClientError", err, socket, req);
    } else {
      abortHandshake(socket, code, message, headers);
    }
  }
});

// ../node_modules/.bun/ws@8.18.3+4789783d1fa00420/node_modules/ws/wrapper.mjs
var import_stream, import_receiver, import_sender, import_websocket, import_websocket_server, wrapper_default;
var init_wrapper = __esm(() => {
  import_stream = __toESM(require_stream(), 1);
  import_receiver = __toESM(require_receiver(), 1);
  import_sender = __toESM(require_sender(), 1);
  import_websocket = __toESM(require_websocket(), 1);
  import_websocket_server = __toESM(require_websocket_server(), 1);
  wrapper_default = import_websocket.default;
});

// ../node_modules/.bun/@solana+rpc-subscriptions-channel-websocket@5.1.0+01c1f2a48c7bfde6/node_modules/@solana/rpc-subscriptions-channel-websocket/dist/index.node.mjs
import { setMaxListeners as setMaxListeners4 } from "events";
function createWebSocketChannel({
  sendBufferHighWatermark,
  signal,
  url
}) {
  if (signal.aborted) {
    return Promise.reject(signal.reason);
  }
  let bufferDrainWatcher;
  let hasConnected = false;
  const listenerRemovers = /* @__PURE__ */ new Set;
  function cleanupListeners() {
    listenerRemovers.forEach((r) => {
      r();
    });
    listenerRemovers.clear();
  }
  function handleAbort() {
    cleanupListeners();
    if (!hasConnected) {
      rejectOpen(signal.reason);
    }
    if (webSocket.readyState !== l.CLOSED && webSocket.readyState !== l.CLOSING) {
      webSocket.close(NORMAL_CLOSURE_CODE);
    }
  }
  function handleClose(ev) {
    cleanupListeners();
    bufferDrainWatcher?.onCancel();
    signal.removeEventListener("abort", handleAbort);
    webSocket.removeEventListener("close", handleClose);
    webSocket.removeEventListener("error", handleError);
    webSocket.removeEventListener("message", handleMessage);
    webSocket.removeEventListener("open", handleOpen);
    if (!signal.aborted && !(ev.wasClean && ev.code === NORMAL_CLOSURE_CODE)) {
      eventTarget.dispatchEvent(new CustomEvent("error", {
        detail: new SolanaError(SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED, {
          cause: ev
        })
      }));
    }
  }
  function handleError(ev) {
    if (signal.aborted) {
      return;
    }
    if (!hasConnected) {
      const failedToConnectError = new SolanaError(SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT, {
        errorEvent: ev
      });
      rejectOpen(failedToConnectError);
      eventTarget.dispatchEvent(new CustomEvent("error", {
        detail: failedToConnectError
      }));
    }
  }
  function handleMessage(ev) {
    if (signal.aborted) {
      return;
    }
    eventTarget.dispatchEvent(new CustomEvent("message", { detail: ev.data }));
  }
  const eventTarget = new s2;
  const dataPublisher = getDataPublisherFromEventEmitter(eventTarget);
  function handleOpen() {
    hasConnected = true;
    resolveOpen({
      ...dataPublisher,
      async send(message) {
        if (webSocket.readyState !== l.OPEN) {
          throw new SolanaError(SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED);
        }
        if (!bufferDrainWatcher && webSocket.bufferedAmount > sendBufferHighWatermark) {
          let onCancel;
          const promise = new Promise((resolve, reject) => {
            const intervalId = setInterval(() => {
              if (webSocket.readyState !== l.OPEN || !(webSocket.bufferedAmount > sendBufferHighWatermark)) {
                clearInterval(intervalId);
                bufferDrainWatcher = undefined;
                resolve();
              }
            }, 16);
            onCancel = () => {
              bufferDrainWatcher = undefined;
              clearInterval(intervalId);
              reject(new SolanaError(SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED));
            };
          });
          bufferDrainWatcher = {
            onCancel,
            promise
          };
        }
        if (bufferDrainWatcher) {
          if (ArrayBuffer.isView(message) && !(message instanceof DataView)) {
            const TypedArrayConstructor = message.constructor;
            message = new TypedArrayConstructor(message);
          }
          await bufferDrainWatcher.promise;
        }
        webSocket.send(message);
      }
    });
  }
  const webSocket = new l(url);
  signal.addEventListener("abort", handleAbort);
  webSocket.addEventListener("close", handleClose);
  webSocket.addEventListener("error", handleError);
  webSocket.addEventListener("message", handleMessage);
  webSocket.addEventListener("open", handleOpen);
  let rejectOpen;
  let resolveOpen;
  return new Promise((resolve, reject) => {
    rejectOpen = reject;
    resolveOpen = resolve;
  });
}
var s2, l, NORMAL_CLOSURE_CODE = 1000;
var init_index_node31 = __esm(() => {
  init_index_node();
  init_index_node28();
  init_wrapper();
  s2 = class extends globalThis.EventTarget {
    constructor(...t) {
      super(...t), setMaxListeners4(Number.MAX_SAFE_INTEGER, this);
    }
  };
  l = globalThis.WebSocket ? globalThis.WebSocket : wrapper_default;
});

// ../node_modules/.bun/@solana+rpc-subscriptions@5.1.0+b7f519a64bbf2dd5/node_modules/@solana/rpc-subscriptions/dist/index.node.mjs
import { setMaxListeners as setMaxListeners5 } from "events";
function createSolanaJsonRpcIntegerOverflowError2(methodName, keyPath, value) {
  let argumentLabel = "";
  if (typeof keyPath[0] === "number") {
    const argPosition = keyPath[0] + 1;
    const lastDigit = argPosition % 10;
    const lastTwoDigits = argPosition % 100;
    if (lastDigit == 1 && lastTwoDigits != 11) {
      argumentLabel = argPosition + "st";
    } else if (lastDigit == 2 && lastTwoDigits != 12) {
      argumentLabel = argPosition + "nd";
    } else if (lastDigit == 3 && lastTwoDigits != 13) {
      argumentLabel = argPosition + "rd";
    } else {
      argumentLabel = argPosition + "th";
    }
  } else {
    argumentLabel = `\`${keyPath[0].toString()}\``;
  }
  const path = keyPath.length > 1 ? keyPath.slice(1).map((pathPart) => typeof pathPart === "number" ? `[${pathPart}]` : pathPart).join(".") : undefined;
  const error = new SolanaError(SOLANA_ERROR__RPC__INTEGER_OVERFLOW, {
    argumentLabel,
    keyPath,
    methodName,
    optionalPathLabel: path ? ` at path \`${path}\`` : "",
    value,
    ...path !== undefined ? { path } : undefined
  });
  safeCaptureStackTrace(error, createSolanaJsonRpcIntegerOverflowError2);
  return error;
}
function getRpcSubscriptionsChannelWithAutoping({
  abortSignal: callerAbortSignal,
  channel,
  intervalMs
}) {
  let intervalId;
  function sendPing() {
    channel.send(PING_PAYLOAD).catch((e22) => {
      if (isSolanaError(e22, SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED)) {
        pingerAbortController.abort();
      }
    });
  }
  function restartPingTimer() {
    clearInterval(intervalId);
    intervalId = setInterval(sendPing, intervalMs);
  }
  const pingerAbortController = new e5;
  pingerAbortController.signal.addEventListener("abort", () => {
    clearInterval(intervalId);
  });
  callerAbortSignal.addEventListener("abort", () => {
    pingerAbortController.abort();
  });
  channel.on("error", () => {
    pingerAbortController.abort();
  }, { signal: pingerAbortController.signal });
  channel.on("message", restartPingTimer, { signal: pingerAbortController.signal });
  {
    restartPingTimer();
  }
  return {
    ...channel,
    send(...args) {
      if (!pingerAbortController.signal.aborted) {
        restartPingTimer();
      }
      return channel.send(...args);
    }
  };
}
function createChannelPool() {
  return {
    entries: [],
    freeChannelIndex: -1
  };
}
function getChannelPoolingChannelCreator(createChannel, { maxSubscriptionsPerChannel, minChannels }) {
  const pool = createChannelPool();
  function recomputeFreeChannelIndex() {
    if (pool.entries.length < minChannels) {
      pool.freeChannelIndex = -1;
      return;
    }
    let mostFreeChannel;
    for (let ii = 0;ii < pool.entries.length; ii++) {
      const nextPoolIndex = (pool.freeChannelIndex + ii + 2) % pool.entries.length;
      const nextPoolEntry = pool.entries[nextPoolIndex];
      if (nextPoolEntry.subscriptionCount < maxSubscriptionsPerChannel && (!mostFreeChannel || mostFreeChannel.subscriptionCount >= nextPoolEntry.subscriptionCount)) {
        mostFreeChannel = {
          poolIndex: nextPoolIndex,
          subscriptionCount: nextPoolEntry.subscriptionCount
        };
      }
    }
    pool.freeChannelIndex = mostFreeChannel?.poolIndex ?? -1;
  }
  return function getExistingChannelWithMostCapacityOrCreateChannel({ abortSignal }) {
    let poolEntry;
    function destroyPoolEntry() {
      const index = pool.entries.findIndex((entry) => entry === poolEntry);
      pool.entries.splice(index, 1);
      poolEntry.dispose();
      recomputeFreeChannelIndex();
    }
    if (pool.freeChannelIndex === -1) {
      const abortController = new e5;
      const newChannelPromise = createChannel({ abortSignal: abortController.signal });
      newChannelPromise.then((newChannel) => {
        newChannel.on("error", destroyPoolEntry, { signal: abortController.signal });
      }).catch(destroyPoolEntry);
      poolEntry = {
        channel: newChannelPromise,
        dispose() {
          abortController.abort();
        },
        subscriptionCount: 0
      };
      pool.entries.push(poolEntry);
    } else {
      poolEntry = pool.entries[pool.freeChannelIndex];
    }
    poolEntry.subscriptionCount++;
    abortSignal.addEventListener("abort", function destroyConsumer() {
      poolEntry.subscriptionCount--;
      if (poolEntry.subscriptionCount === 0) {
        destroyPoolEntry();
      } else if (pool.freeChannelIndex !== -1) {
        pool.freeChannelIndex--;
        recomputeFreeChannelIndex();
      }
    });
    recomputeFreeChannelIndex();
    return poolEntry.channel;
  };
}
function getRpcSubscriptionsChannelWithJSONSerialization(channel) {
  return pipe(channel, (c) => transformChannelInboundMessages(c, JSON.parse), (c) => transformChannelOutboundMessages(c, JSON.stringify));
}
function getRpcSubscriptionsChannelWithBigIntJSONSerialization(channel) {
  return pipe(channel, (c) => transformChannelInboundMessages(c, parseJsonWithBigInts), (c) => transformChannelOutboundMessages(c, stringifyJsonWithBigInts));
}
function createDefaultSolanaRpcSubscriptionsChannelCreator(config) {
  return createDefaultRpcSubscriptionsChannelCreatorImpl({
    ...config,
    jsonSerializer: getRpcSubscriptionsChannelWithBigIntJSONSerialization
  });
}
function createDefaultRpcSubscriptionsChannelCreator(config) {
  return createDefaultRpcSubscriptionsChannelCreatorImpl({
    ...config,
    jsonSerializer: getRpcSubscriptionsChannelWithJSONSerialization
  });
}
function createDefaultRpcSubscriptionsChannelCreatorImpl(config) {
  if (/^wss?:/i.test(config.url) === false) {
    const protocolMatch = config.url.match(/^([^:]+):/);
    throw new DOMException(protocolMatch ? `Failed to construct 'WebSocket': The URL's scheme must be either 'ws' or 'wss'. '${protocolMatch[1]}:' is not allowed.` : `Failed to construct 'WebSocket': The URL '${config.url}' is invalid.`);
  }
  const { intervalMs, ...rest } = config;
  const createDefaultRpcSubscriptionsChannel = ({ abortSignal }) => {
    return createWebSocketChannel({
      ...rest,
      sendBufferHighWatermark: config.sendBufferHighWatermark ?? 131072,
      signal: abortSignal
    }).then(config.jsonSerializer).then((channel) => getRpcSubscriptionsChannelWithAutoping({
      abortSignal,
      channel,
      intervalMs: intervalMs ?? 5000
    }));
  };
  return getChannelPoolingChannelCreator(createDefaultRpcSubscriptionsChannel, {
    maxSubscriptionsPerChannel: config.maxSubscriptionsPerChannel ?? 100,
    minChannels: config.minChannels ?? 1
  });
}
function getRpcSubscriptionsTransportWithSubscriptionCoalescing(transport) {
  const cache2 = /* @__PURE__ */ new Map;
  return function rpcSubscriptionsTransportWithSubscriptionCoalescing(config) {
    const { request, signal } = config;
    const subscriptionConfigurationHash = index_default([request.methodName, request.params]);
    let cachedDataPublisherPromise = cache2.get(subscriptionConfigurationHash);
    if (!cachedDataPublisherPromise) {
      const abortController = new e5;
      const dataPublisherPromise = transport({
        ...config,
        signal: abortController.signal
      });
      dataPublisherPromise.then((dataPublisher) => {
        dataPublisher.on("error", () => {
          cache2.delete(subscriptionConfigurationHash);
          abortController.abort();
        }, { signal: abortController.signal });
      }).catch(() => {});
      cache2.set(subscriptionConfigurationHash, cachedDataPublisherPromise = {
        abortController,
        dataPublisherPromise,
        numSubscribers: 0
      });
    }
    cachedDataPublisherPromise.numSubscribers++;
    signal.addEventListener("abort", () => {
      cachedDataPublisherPromise.numSubscribers--;
      if (cachedDataPublisherPromise.numSubscribers === 0) {
        queueMicrotask(() => {
          if (cachedDataPublisherPromise.numSubscribers === 0) {
            cache2.delete(subscriptionConfigurationHash);
            cachedDataPublisherPromise.abortController.abort();
          }
        });
      }
    }, { signal: cachedDataPublisherPromise.abortController.signal });
    return cachedDataPublisherPromise.dataPublisherPromise;
  };
}
function createDefaultRpcSubscriptionsTransport({
  createChannel
}) {
  return pipe(createRpcSubscriptionsTransportFromChannelCreator(createChannel), (transport) => getRpcSubscriptionsTransportWithSubscriptionCoalescing(transport));
}
function createRpcSubscriptionsTransportFromChannelCreator(createChannel) {
  return async ({ execute, signal }) => {
    const channel = await createChannel({ abortSignal: signal });
    return await execute({ channel, signal });
  };
}
function createSolanaRpcSubscriptionsImpl(clusterUrl, config) {
  const transport = createDefaultRpcSubscriptionsTransport({
    createChannel: createDefaultSolanaRpcSubscriptionsChannelCreator({ ...config, url: clusterUrl })
  });
  return createSolanaRpcSubscriptionsFromTransport(transport);
}
function createSolanaRpcSubscriptions(clusterUrl, config) {
  return createSolanaRpcSubscriptionsImpl(clusterUrl, config);
}
function createSolanaRpcSubscriptions_UNSTABLE(clusterUrl, config) {
  return createSolanaRpcSubscriptionsImpl(clusterUrl, config);
}
function createSolanaRpcSubscriptionsFromTransport(transport) {
  return createSubscriptionRpc({
    api: createSolanaRpcSubscriptionsApi(DEFAULT_RPC_SUBSCRIPTIONS_CONFIG),
    transport
  });
}
var DEFAULT_RPC_SUBSCRIPTIONS_CONFIG, e5, PING_PAYLOAD;
var init_index_node32 = __esm(() => {
  init_index_node30();
  init_index_node29();
  init_index_node();
  init_index_node31();
  init_index_node12();
  init_index_node21();
  init_index_node26();
  init_index_node30();
  init_index_node29();
  DEFAULT_RPC_SUBSCRIPTIONS_CONFIG = {
    defaultCommitment: "confirmed",
    onIntegerOverflow(request, keyPath, value) {
      throw createSolanaJsonRpcIntegerOverflowError2(request.methodName, keyPath, value);
    }
  };
  e5 = class extends globalThis.AbortController {
    constructor(...t) {
      super(...t), setMaxListeners5(Number.MAX_SAFE_INTEGER, this.signal);
    }
  };
  PING_PAYLOAD = {
    jsonrpc: "2.0",
    method: "ping"
  };
});

// ../node_modules/.bun/@solana+signers@5.1.0+7f9e3d21594a24ff/node_modules/@solana/signers/dist/index.node.mjs
function deduplicateSigners(signers) {
  const deduplicated = {};
  signers.forEach((signer) => {
    if (!deduplicated[signer.address]) {
      deduplicated[signer.address] = signer;
    } else if (deduplicated[signer.address] !== signer) {
      throw new SolanaError(SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS, {
        address: signer.address
      });
    }
  });
  return Object.values(deduplicated);
}
function isTransactionModifyingSigner(value) {
  return "modifyAndSignTransactions" in value && typeof value.modifyAndSignTransactions === "function";
}
function assertIsTransactionModifyingSigner(value) {
  if (!isTransactionModifyingSigner(value)) {
    throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER, {
      address: value.address
    });
  }
}
function isTransactionPartialSigner(value) {
  return "signTransactions" in value && typeof value.signTransactions === "function";
}
function assertIsTransactionPartialSigner(value) {
  if (!isTransactionPartialSigner(value)) {
    throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER, {
      address: value.address
    });
  }
}
function isTransactionSendingSigner(value) {
  return "signAndSendTransactions" in value && typeof value.signAndSendTransactions === "function";
}
function assertIsTransactionSendingSigner(value) {
  if (!isTransactionSendingSigner(value)) {
    throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER, {
      address: value.address
    });
  }
}
function isTransactionSigner(value) {
  return isTransactionPartialSigner(value) || isTransactionModifyingSigner(value) || isTransactionSendingSigner(value);
}
function assertIsTransactionSigner(value) {
  if (!isTransactionSigner(value)) {
    throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER, {
      address: value.address
    });
  }
}
function getSignersFromInstruction(instruction) {
  return deduplicateSigners((instruction.accounts ?? []).flatMap((account) => ("signer" in account) ? account.signer : []));
}
function getSignersFromTransactionMessage(transaction) {
  return deduplicateSigners([
    ...transaction.feePayer && isTransactionSigner(transaction.feePayer) ? [transaction.feePayer] : [],
    ...transaction.instructions.flatMap(getSignersFromInstruction)
  ]);
}
function addSignersToInstruction(signers, instruction) {
  if (!instruction.accounts || instruction.accounts.length === 0) {
    return instruction;
  }
  const signerByAddress = new Map(deduplicateSigners(signers).map((signer) => [signer.address, signer]));
  return Object.freeze({
    ...instruction,
    accounts: instruction.accounts.map((account) => {
      const signer = signerByAddress.get(account.address);
      if (!isSignerRole(account.role) || "signer" in account || !signer) {
        return account;
      }
      return Object.freeze({ ...account, signer });
    })
  });
}
function addSignersToTransactionMessage(signers, transactionMessage) {
  const feePayerSigner = hasAddressOnlyFeePayer(transactionMessage) ? signers.find((signer) => signer.address === transactionMessage.feePayer.address) : undefined;
  if (!feePayerSigner && transactionMessage.instructions.length === 0) {
    return transactionMessage;
  }
  return Object.freeze({
    ...transactionMessage,
    ...feePayerSigner ? { feePayer: feePayerSigner } : null,
    instructions: transactionMessage.instructions.map((instruction) => addSignersToInstruction(signers, instruction))
  });
}
function hasAddressOnlyFeePayer(message) {
  return !!message && "feePayer" in message && !!message.feePayer && typeof message.feePayer.address === "string" && !isTransactionSigner(message.feePayer);
}
function setTransactionMessageFeePayerSigner(feePayer, transactionMessage) {
  Object.freeze(feePayer);
  const out = { ...transactionMessage, feePayer };
  Object.freeze(out);
  return out;
}
function isMessagePartialSigner(value) {
  return "signMessages" in value && typeof value.signMessages === "function";
}
function assertIsMessagePartialSigner(value) {
  if (!isMessagePartialSigner(value)) {
    throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER, {
      address: value.address
    });
  }
}
function isKeyPairSigner(value) {
  return "keyPair" in value && typeof value.keyPair === "object" && isMessagePartialSigner(value) && isTransactionPartialSigner(value);
}
function assertIsKeyPairSigner(value) {
  if (!isKeyPairSigner(value)) {
    throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER, {
      address: value.address
    });
  }
}
async function createSignerFromKeyPair(keyPair) {
  const address2 = await getAddressFromPublicKey(keyPair.publicKey);
  const out = {
    address: address2,
    keyPair,
    signMessages: (messages) => Promise.all(messages.map(async (message) => Object.freeze({ [address2]: await signBytes(keyPair.privateKey, message.content) }))),
    signTransactions: (transactions) => Promise.all(transactions.map(async (transaction) => {
      const signedTransaction = await partiallySignTransaction([keyPair], transaction);
      return Object.freeze({ [address2]: signedTransaction.signatures[address2] });
    }))
  };
  return Object.freeze(out);
}
async function generateKeyPairSigner() {
  return await createSignerFromKeyPair(await generateKeyPair());
}
async function createKeyPairSignerFromBytes(bytes, extractable) {
  return await createSignerFromKeyPair(await createKeyPairFromBytes(bytes, extractable));
}
async function createKeyPairSignerFromPrivateKeyBytes(bytes, extractable) {
  return await createSignerFromKeyPair(await createKeyPairFromPrivateKeyBytes(bytes, extractable));
}
function isMessageModifyingSigner(value) {
  return isAddress(value.address) && "modifyAndSignMessages" in value && typeof value.modifyAndSignMessages === "function";
}
function assertIsMessageModifyingSigner(value) {
  if (!isMessageModifyingSigner(value)) {
    throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER, {
      address: value.address
    });
  }
}
function isMessageSigner(value) {
  return isMessagePartialSigner(value) || isMessageModifyingSigner(value);
}
function assertIsMessageSigner(value) {
  if (!isMessageSigner(value)) {
    throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER, {
      address: value.address
    });
  }
}
function createNoopSigner(address2) {
  const out = {
    address: address2,
    signMessages: (messages) => Promise.resolve(messages.map(() => Object.freeze({}))),
    signTransactions: (transactions) => Promise.resolve(transactions.map(() => Object.freeze({})))
  };
  return Object.freeze(out);
}
function getSignersFromOffchainMessage({
  requiredSignatories
}) {
  const messageSigners = requiredSignatories.filter(isMessageSigner);
  return deduplicateSigners(messageSigners);
}
async function partiallySignOffchainMessageWithSigners(offchainMessage, config) {
  const { partialSigners, modifyingSigners } = categorizeMessageSigners(getSignersFromOffchainMessage(offchainMessage));
  return await signModifyingAndPartialMessageSigners(offchainMessage, modifyingSigners, partialSigners, config);
}
async function signOffchainMessageWithSigners(offchainMessage, config) {
  const signedOffchainMessageEnvelope = await partiallySignOffchainMessageWithSigners(offchainMessage, config);
  assertIsFullySignedOffchainMessageEnvelope(signedOffchainMessageEnvelope);
  return signedOffchainMessageEnvelope;
}
function categorizeMessageSigners(signers) {
  const modifyingSigners = identifyMessageModifyingSigners(signers);
  const partialSigners = signers.filter(isMessagePartialSigner).filter((signer) => !modifyingSigners.includes(signer));
  return Object.freeze({ modifyingSigners, partialSigners });
}
function identifyMessageModifyingSigners(signers) {
  const modifyingSigners = signers.filter(isMessageModifyingSigner);
  if (modifyingSigners.length === 0)
    return [];
  const nonPartialSigners = modifyingSigners.filter((signer) => !isMessagePartialSigner(signer));
  if (nonPartialSigners.length > 0)
    return nonPartialSigners;
  return [modifyingSigners[0]];
}
async function signModifyingAndPartialMessageSigners(offchainMessage, modifyingSigners = [], partialSigners = [], config) {
  const offchainMessageEnvelope = compileOffchainMessageEnvelope(offchainMessage);
  const modifiedOffchainMessage = await modifyingSigners.reduce(async (offchainMessageEnvelope2, modifyingSigner) => {
    config?.abortSignal?.throwIfAborted();
    const [message] = await modifyingSigner.modifyAndSignMessages([await offchainMessageEnvelope2], config);
    return Object.freeze(message);
  }, Promise.resolve(offchainMessageEnvelope));
  config?.abortSignal?.throwIfAborted();
  const signatureDictionaries = await Promise.all(partialSigners.map(async (partialSigner) => {
    const [signatures] = await partialSigner.signMessages([modifiedOffchainMessage], config);
    return signatures;
  }));
  return Object.freeze({
    ...modifiedOffchainMessage,
    signatures: Object.freeze(signatureDictionaries.reduce((signatures, signatureDictionary) => {
      return { ...signatures, ...signatureDictionary };
    }, modifiedOffchainMessage.signatures ?? {}))
  });
}
function isTransactionMessageWithSingleSendingSigner(transaction) {
  try {
    assertIsTransactionMessageWithSingleSendingSigner(transaction);
    return true;
  } catch {
    return false;
  }
}
function assertIsTransactionMessageWithSingleSendingSigner(transaction) {
  const signers = getSignersFromTransactionMessage(transaction);
  const sendingSigners = signers.filter(isTransactionSendingSigner);
  if (sendingSigners.length === 0) {
    throw new SolanaError(SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING);
  }
  const sendingOnlySigners = sendingSigners.filter((signer) => !isTransactionPartialSigner(signer) && !isTransactionModifyingSigner(signer));
  if (sendingOnlySigners.length > 1) {
    throw new SolanaError(SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS);
  }
}
async function partiallySignTransactionMessageWithSigners(transactionMessage, config) {
  const { partialSigners, modifyingSigners } = categorizeTransactionSigners(deduplicateSigners(getSignersFromTransactionMessage(transactionMessage).filter(isTransactionSigner)), { identifySendingSigner: false });
  return await signModifyingAndPartialTransactionSigners(transactionMessage, modifyingSigners, partialSigners, config);
}
async function signTransactionMessageWithSigners(transactionMessage, config) {
  const signedTransaction = await partiallySignTransactionMessageWithSigners(transactionMessage, config);
  assertIsFullySignedTransaction(signedTransaction);
  return signedTransaction;
}
async function signAndSendTransactionMessageWithSigners(transaction, config) {
  assertIsTransactionMessageWithSingleSendingSigner(transaction);
  const abortSignal = config?.abortSignal;
  const { partialSigners, modifyingSigners, sendingSigner } = categorizeTransactionSigners(deduplicateSigners(getSignersFromTransactionMessage(transaction).filter(isTransactionSigner)));
  abortSignal?.throwIfAborted();
  const signedTransaction = await signModifyingAndPartialTransactionSigners(transaction, modifyingSigners, partialSigners, config);
  if (!sendingSigner) {
    throw new SolanaError(SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING);
  }
  abortSignal?.throwIfAborted();
  const [signature2] = await sendingSigner.signAndSendTransactions([signedTransaction], config);
  abortSignal?.throwIfAborted();
  return signature2;
}
function categorizeTransactionSigners(signers, config = {}) {
  const identifySendingSigner = config.identifySendingSigner ?? true;
  const sendingSigner = identifySendingSigner ? identifyTransactionSendingSigner(signers) : null;
  const otherSigners = signers.filter((signer) => signer !== sendingSigner && (isTransactionModifyingSigner(signer) || isTransactionPartialSigner(signer)));
  const modifyingSigners = identifyTransactionModifyingSigners(otherSigners);
  const partialSigners = otherSigners.filter(isTransactionPartialSigner).filter((signer) => !modifyingSigners.includes(signer));
  return Object.freeze({ modifyingSigners, partialSigners, sendingSigner });
}
function identifyTransactionSendingSigner(signers) {
  const sendingSigners = signers.filter(isTransactionSendingSigner);
  if (sendingSigners.length === 0)
    return null;
  const sendingOnlySigners = sendingSigners.filter((signer) => !isTransactionModifyingSigner(signer) && !isTransactionPartialSigner(signer));
  if (sendingOnlySigners.length > 0) {
    return sendingOnlySigners[0];
  }
  return sendingSigners[0];
}
function identifyTransactionModifyingSigners(signers) {
  const modifyingSigners = signers.filter(isTransactionModifyingSigner);
  if (modifyingSigners.length === 0)
    return [];
  const nonPartialSigners = modifyingSigners.filter((signer) => !isTransactionPartialSigner(signer));
  if (nonPartialSigners.length > 0)
    return nonPartialSigners;
  return [modifyingSigners[0]];
}
async function signModifyingAndPartialTransactionSigners(transactionMessage, modifyingSigners = [], partialSigners = [], config) {
  const transaction = compileTransaction(transactionMessage);
  const modifiedTransaction = await modifyingSigners.reduce(async (transaction2, modifyingSigner) => {
    config?.abortSignal?.throwIfAborted();
    const [tx] = await modifyingSigner.modifyAndSignTransactions([await transaction2], config);
    return Object.freeze(tx);
  }, Promise.resolve(transaction));
  config?.abortSignal?.throwIfAborted();
  const signatureDictionaries = await Promise.all(partialSigners.map(async (partialSigner) => {
    const [signatures] = await partialSigner.signTransactions([modifiedTransaction], config);
    return signatures;
  }));
  return Object.freeze({
    ...modifiedTransaction,
    signatures: Object.freeze(signatureDictionaries.reduce((signatures, signatureDictionary) => {
      return { ...signatures, ...signatureDictionary };
    }, modifiedTransaction.signatures ?? {}))
  });
}
function createSignableMessage(content, signatures = {}) {
  return Object.freeze({
    content: typeof content === "string" ? new o2().encode(content) : content,
    signatures: Object.freeze({ ...signatures })
  });
}
var o2;
var init_index_node33 = __esm(() => {
  init_index_node();
  init_index_node13();
  init_index_node5();
  init_index_node15();
  init_index_node16();
  init_index_node19();
  o2 = globalThis.TextEncoder;
});

// ../node_modules/.bun/@solana+transaction-confirmation@5.1.0+b7f519a64bbf2dd5/node_modules/@solana/transaction-confirmation/dist/index.node.mjs
import { setMaxListeners as setMaxListeners6 } from "events";
function createBlockHeightExceedencePromiseFactory({
  rpc,
  rpcSubscriptions
}) {
  return async function getBlockHeightExceedencePromise({
    abortSignal: callerAbortSignal,
    commitment,
    lastValidBlockHeight
  }) {
    callerAbortSignal.throwIfAborted();
    const abortController = new e6;
    const handleAbort = () => {
      abortController.abort();
    };
    callerAbortSignal.addEventListener("abort", handleAbort, { signal: abortController.signal });
    async function getBlockHeightAndDifferenceBetweenSlotHeightAndBlockHeight() {
      const { absoluteSlot, blockHeight } = await rpc.getEpochInfo({ commitment }).send({ abortSignal: abortController.signal });
      return {
        blockHeight,
        differenceBetweenSlotHeightAndBlockHeight: absoluteSlot - blockHeight
      };
    }
    try {
      const [slotNotifications, { blockHeight: initialBlockHeight, differenceBetweenSlotHeightAndBlockHeight }] = await Promise.all([
        rpcSubscriptions.slotNotifications().subscribe({ abortSignal: abortController.signal }),
        getBlockHeightAndDifferenceBetweenSlotHeightAndBlockHeight()
      ]);
      callerAbortSignal.throwIfAborted();
      let currentBlockHeight = initialBlockHeight;
      if (currentBlockHeight <= lastValidBlockHeight) {
        let lastKnownDifferenceBetweenSlotHeightAndBlockHeight = differenceBetweenSlotHeightAndBlockHeight;
        for await (const slotNotification of slotNotifications) {
          const { slot } = slotNotification;
          if (slot - lastKnownDifferenceBetweenSlotHeightAndBlockHeight > lastValidBlockHeight) {
            const {
              blockHeight: recheckedBlockHeight,
              differenceBetweenSlotHeightAndBlockHeight: currentDifferenceBetweenSlotHeightAndBlockHeight
            } = await getBlockHeightAndDifferenceBetweenSlotHeightAndBlockHeight();
            currentBlockHeight = recheckedBlockHeight;
            if (currentBlockHeight > lastValidBlockHeight) {
              break;
            } else {
              lastKnownDifferenceBetweenSlotHeightAndBlockHeight = currentDifferenceBetweenSlotHeightAndBlockHeight;
            }
          }
        }
      }
      callerAbortSignal.throwIfAborted();
      throw new SolanaError(SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED, {
        currentBlockHeight,
        lastValidBlockHeight
      });
    } finally {
      abortController.abort();
    }
  };
}
function createNonceInvalidationPromiseFactory({
  rpc,
  rpcSubscriptions
}) {
  return async function getNonceInvalidationPromise({
    abortSignal: callerAbortSignal,
    commitment,
    currentNonceValue: expectedNonceValue,
    nonceAccountAddress
  }) {
    const abortController = new e6;
    function handleAbort() {
      abortController.abort();
    }
    callerAbortSignal.addEventListener("abort", handleAbort, { signal: abortController.signal });
    const accountNotifications = await rpcSubscriptions.accountNotifications(nonceAccountAddress, { commitment, encoding: "base64" }).subscribe({ abortSignal: abortController.signal });
    const base58Decoder2 = getBase58Decoder();
    const base64Encoder = getBase64Encoder();
    function getNonceFromAccountData([base64EncodedBytes]) {
      const data2 = base64Encoder.encode(base64EncodedBytes);
      const nonceValueBytes = data2.slice(NONCE_VALUE_OFFSET, NONCE_VALUE_OFFSET + 32);
      return base58Decoder2.decode(nonceValueBytes);
    }
    const nonceAccountDidAdvancePromise = (async () => {
      for await (const accountNotification of accountNotifications) {
        const nonceValue = getNonceFromAccountData(accountNotification.value.data);
        if (nonceValue !== expectedNonceValue) {
          throw new SolanaError(SOLANA_ERROR__INVALID_NONCE, {
            actualNonceValue: nonceValue,
            expectedNonceValue
          });
        }
      }
    })();
    const nonceIsAlreadyInvalidPromise = (async () => {
      const { value: nonceAccount } = await rpc.getAccountInfo(nonceAccountAddress, {
        commitment,
        dataSlice: { length: 32, offset: NONCE_VALUE_OFFSET },
        encoding: "base58"
      }).send({ abortSignal: abortController.signal });
      if (!nonceAccount) {
        throw new SolanaError(SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND, {
          nonceAccountAddress
        });
      }
      const nonceValue = nonceAccount.data[0];
      if (nonceValue !== expectedNonceValue) {
        throw new SolanaError(SOLANA_ERROR__INVALID_NONCE, {
          actualNonceValue: nonceValue,
          expectedNonceValue
        });
      } else {
        await new Promise(() => {});
      }
    })();
    try {
      return await safeRace([nonceAccountDidAdvancePromise, nonceIsAlreadyInvalidPromise]);
    } finally {
      abortController.abort();
    }
  };
}
function createRecentSignatureConfirmationPromiseFactory({
  rpc,
  rpcSubscriptions
}) {
  return async function getRecentSignatureConfirmationPromise({
    abortSignal: callerAbortSignal,
    commitment,
    signature: signature2
  }) {
    const abortController = new e6;
    function handleAbort() {
      abortController.abort();
    }
    callerAbortSignal.addEventListener("abort", handleAbort, { signal: abortController.signal });
    const signatureStatusNotifications = await rpcSubscriptions.signatureNotifications(signature2, { commitment }).subscribe({ abortSignal: abortController.signal });
    const signatureDidCommitPromise = (async () => {
      for await (const signatureStatusNotification of signatureStatusNotifications) {
        if (signatureStatusNotification.value.err) {
          throw getSolanaErrorFromTransactionError(signatureStatusNotification.value.err);
        } else {
          return;
        }
      }
    })();
    const signatureStatusLookupPromise = (async () => {
      const { value: signatureStatusResults } = await rpc.getSignatureStatuses([signature2]).send({ abortSignal: abortController.signal });
      const signatureStatus = signatureStatusResults[0];
      if (signatureStatus?.err) {
        throw getSolanaErrorFromTransactionError(signatureStatus.err);
      } else if (signatureStatus?.confirmationStatus && commitmentComparator(signatureStatus.confirmationStatus, commitment) >= 0) {
        return;
      } else {
        await new Promise(() => {});
      }
    })();
    try {
      return await safeRace([signatureDidCommitPromise, signatureStatusLookupPromise]);
    } finally {
      abortController.abort();
    }
  };
}
async function getTimeoutPromise({ abortSignal: callerAbortSignal, commitment }) {
  return await new Promise((_, reject) => {
    const handleAbort = (e22) => {
      clearTimeout(timeoutId);
      const abortError = new DOMException(e22.target.reason, "AbortError");
      reject(abortError);
    };
    callerAbortSignal.addEventListener("abort", handleAbort);
    const timeoutMs = commitment === "processed" ? 30000 : 60000;
    const startMs = performance.now();
    const timeoutId = setTimeout(() => {
      const elapsedMs = performance.now() - startMs;
      reject(new DOMException(`Timeout elapsed after ${elapsedMs} ms`, "TimeoutError"));
    }, timeoutMs);
  });
}
async function raceStrategies(signature2, config, getSpecificStrategiesForRace) {
  const { abortSignal: callerAbortSignal, commitment, getRecentSignatureConfirmationPromise } = config;
  callerAbortSignal?.throwIfAborted();
  const abortController = new e6;
  if (callerAbortSignal) {
    const handleAbort = () => {
      abortController.abort();
    };
    callerAbortSignal.addEventListener("abort", handleAbort, { signal: abortController.signal });
  }
  try {
    const specificStrategies = getSpecificStrategiesForRace({
      ...config,
      abortSignal: abortController.signal
    });
    return await safeRace([
      getRecentSignatureConfirmationPromise({
        abortSignal: abortController.signal,
        commitment,
        signature: signature2
      }),
      ...specificStrategies
    ]);
  } finally {
    abortController.abort();
  }
}
async function waitForDurableNonceTransactionConfirmation(config) {
  await raceStrategies(getSignatureFromTransaction(config.transaction), config, function getSpecificStrategiesForRace({ abortSignal, commitment, getNonceInvalidationPromise, transaction }) {
    return [
      getNonceInvalidationPromise({
        abortSignal,
        commitment,
        currentNonceValue: transaction.lifetimeConstraint.nonce,
        nonceAccountAddress: transaction.lifetimeConstraint.nonceAccountAddress
      })
    ];
  });
}
async function waitForRecentTransactionConfirmation(config) {
  await raceStrategies(getSignatureFromTransaction(config.transaction), config, function getSpecificStrategiesForRace({
    abortSignal,
    commitment,
    getBlockHeightExceedencePromise,
    transaction
  }) {
    return [
      getBlockHeightExceedencePromise({
        abortSignal,
        commitment,
        lastValidBlockHeight: transaction.lifetimeConstraint.lastValidBlockHeight
      })
    ];
  });
}
async function waitForRecentTransactionConfirmationUntilTimeout(config) {
  await raceStrategies(config.signature, config, function getSpecificStrategiesForRace({ abortSignal, commitment, getTimeoutPromise: getTimeoutPromise2 }) {
    return [
      getTimeoutPromise2({
        abortSignal,
        commitment
      })
    ];
  });
}
var e6, NONCE_VALUE_OFFSET;
var init_index_node34 = __esm(() => {
  init_index_node();
  init_index_node3();
  init_index_node17();
  init_index_node11();
  init_index_node16();
  e6 = class extends globalThis.AbortController {
    constructor(...t) {
      super(...t), setMaxListeners6(Number.MAX_SAFE_INTEGER, this.signal);
    }
  };
  NONCE_VALUE_OFFSET = 4 + 4 + 32;
});

// ../node_modules/.bun/@solana+kit@5.1.0+b7f519a64bbf2dd5/node_modules/@solana/kit/dist/index.node.mjs
var exports_index_node3 = {};
__export(exports_index_node3, {
  wrapNullable: () => wrapNullable,
  verifySignature: () => verifySignature,
  verifyOffchainMessageEnvelope: () => verifyOffchainMessageEnvelope,
  upgradeRoleToWritable: () => upgradeRoleToWritable,
  upgradeRoleToSigner: () => upgradeRoleToSigner,
  unwrapOptionRecursively: () => unwrapOptionRecursively,
  unwrapOption: () => unwrapOption,
  unixTimestamp: () => unixTimestamp,
  transformEncoder: () => transformEncoder,
  transformDecoder: () => transformDecoder,
  transformCodec: () => transformCodec,
  transformChannelOutboundMessages: () => transformChannelOutboundMessages,
  transformChannelInboundMessages: () => transformChannelInboundMessages,
  testnet: () => testnet,
  summarizeTransactionPlanResult: () => summarizeTransactionPlanResult,
  successfulSingleTransactionPlanResultFromSignature: () => successfulSingleTransactionPlanResultFromSignature,
  successfulSingleTransactionPlanResult: () => successfulSingleTransactionPlanResult,
  stringifiedNumber: () => stringifiedNumber,
  stringifiedBigInt: () => stringifiedBigInt,
  some: () => some,
  singleTransactionPlan: () => singleTransactionPlan,
  singleInstructionPlan: () => singleInstructionPlan,
  signatureBytes: () => signatureBytes,
  signature: () => signature,
  signTransactionMessageWithSigners: () => signTransactionMessageWithSigners,
  signTransaction: () => signTransaction,
  signOffchainMessageWithSigners: () => signOffchainMessageWithSigners,
  signOffchainMessageEnvelope: () => signOffchainMessageEnvelope,
  signBytes: () => signBytes,
  signAndSendTransactionMessageWithSigners: () => signAndSendTransactionMessageWithSigners,
  setTransactionMessageLifetimeUsingDurableNonce: () => setTransactionMessageLifetimeUsingDurableNonce,
  setTransactionMessageLifetimeUsingBlockhash: () => setTransactionMessageLifetimeUsingBlockhash,
  setTransactionMessageFeePayerSigner: () => setTransactionMessageFeePayerSigner,
  setTransactionMessageFeePayer: () => setTransactionMessageFeePayer,
  sequentialTransactionPlanResult: () => sequentialTransactionPlanResult,
  sequentialTransactionPlan: () => sequentialTransactionPlan,
  sequentialInstructionPlan: () => sequentialInstructionPlan,
  sendTransactionWithoutConfirmingFactory: () => sendTransactionWithoutConfirmingFactory,
  sendAndConfirmTransactionFactory: () => sendAndConfirmTransactionFactory,
  sendAndConfirmDurableNonceTransactionFactory: () => sendAndConfirmDurableNonceTransactionFactory,
  safeCaptureStackTrace: () => safeCaptureStackTrace,
  reverseEncoder: () => reverseEncoder,
  reverseDecoder: () => reverseDecoder,
  reverseCodec: () => reverseCodec,
  resizeEncoder: () => resizeEncoder,
  resizeDecoder: () => resizeDecoder,
  resizeCodec: () => resizeCodec,
  removeNullCharacters: () => removeNullCharacters,
  prependTransactionMessageInstructions: () => prependTransactionMessageInstructions,
  prependTransactionMessageInstruction: () => prependTransactionMessageInstruction,
  pipe: () => pipe,
  partiallySignTransactionMessageWithSigners: () => partiallySignTransactionMessageWithSigners,
  partiallySignTransaction: () => partiallySignTransaction,
  partiallySignOffchainMessageWithSigners: () => partiallySignOffchainMessageWithSigners,
  partiallySignOffchainMessageEnvelope: () => partiallySignOffchainMessageEnvelope,
  parseJsonRpcAccount: () => parseJsonRpcAccount,
  parseBase64RpcAccount: () => parseBase64RpcAccount,
  parseBase58RpcAccount: () => parseBase58RpcAccount,
  parallelTransactionPlanResult: () => parallelTransactionPlanResult,
  parallelTransactionPlan: () => parallelTransactionPlan,
  parallelInstructionPlan: () => parallelInstructionPlan,
  padRightEncoder: () => padRightEncoder,
  padRightDecoder: () => padRightDecoder,
  padRightCodec: () => padRightCodec,
  padNullCharacters: () => padNullCharacters,
  padLeftEncoder: () => padLeftEncoder,
  padLeftDecoder: () => padLeftDecoder,
  padLeftCodec: () => padLeftCodec,
  padBytes: () => padBytes,
  offsetEncoder: () => offsetEncoder,
  offsetDecoder: () => offsetDecoder,
  offsetCodec: () => offsetCodec,
  offchainMessageContentUtf8Of65535BytesMax: () => offchainMessageContentUtf8Of65535BytesMax,
  offchainMessageContentUtf8Of1232BytesMax: () => offchainMessageContentUtf8Of1232BytesMax,
  offchainMessageContentRestrictedAsciiOf1232BytesMax: () => offchainMessageContentRestrictedAsciiOf1232BytesMax,
  offchainMessageApplicationDomain: () => offchainMessageApplicationDomain,
  offCurveAddress: () => offCurveAddress,
  none: () => none,
  nonDivisibleSequentialTransactionPlanResult: () => nonDivisibleSequentialTransactionPlanResult,
  nonDivisibleSequentialTransactionPlan: () => nonDivisibleSequentialTransactionPlan,
  nonDivisibleSequentialInstructionPlan: () => nonDivisibleSequentialInstructionPlan,
  mergeRoles: () => mergeRoles,
  mergeBytes: () => mergeBytes,
  mainnet: () => mainnet,
  lamports: () => lamports,
  isWritableRole: () => isWritableRole,
  isVariableSize: () => isVariableSize,
  isUnixTimestamp: () => isUnixTimestamp,
  isTransactionWithinSizeLimit: () => isTransactionWithinSizeLimit,
  isTransactionWithDurableNonceLifetime: () => isTransactionWithDurableNonceLifetime,
  isTransactionWithBlockhashLifetime: () => isTransactionWithBlockhashLifetime,
  isTransactionSigner: () => isTransactionSigner,
  isTransactionSendingSigner: () => isTransactionSendingSigner,
  isTransactionPartialSigner: () => isTransactionPartialSigner,
  isTransactionModifyingSigner: () => isTransactionModifyingSigner,
  isTransactionMessageWithinSizeLimit: () => isTransactionMessageWithinSizeLimit,
  isTransactionMessageWithSingleSendingSigner: () => isTransactionMessageWithSingleSendingSigner,
  isTransactionMessageWithDurableNonceLifetime: () => isTransactionMessageWithDurableNonceLifetime,
  isTransactionMessageWithBlockhashLifetime: () => isTransactionMessageWithBlockhashLifetime,
  isStringifiedNumber: () => isStringifiedNumber,
  isStringifiedBigInt: () => isStringifiedBigInt,
  isSome: () => isSome,
  isSolanaError: () => isSolanaError,
  isSignerRole: () => isSignerRole,
  isSignatureBytes: () => isSignatureBytes,
  isSignature: () => isSignature,
  isSendableTransaction: () => isSendableTransaction,
  isProgramError: () => isProgramError,
  isProgramDerivedAddress: () => isProgramDerivedAddress,
  isOption: () => isOption,
  isOffchainMessageContentUtf8Of65535BytesMax: () => isOffchainMessageContentUtf8Of65535BytesMax,
  isOffchainMessageContentUtf8Of1232BytesMax: () => isOffchainMessageContentUtf8Of1232BytesMax,
  isOffchainMessageContentRestrictedAsciiOf1232BytesMax: () => isOffchainMessageContentRestrictedAsciiOf1232BytesMax,
  isOffchainMessageApplicationDomain: () => isOffchainMessageApplicationDomain,
  isOffCurveAddress: () => isOffCurveAddress,
  isNone: () => isNone,
  isMessageSigner: () => isMessageSigner,
  isMessagePartialSigner: () => isMessagePartialSigner,
  isMessageModifyingSigner: () => isMessageModifyingSigner,
  isLamports: () => isLamports,
  isKeyPairSigner: () => isKeyPairSigner,
  isJsonRpcPayload: () => isJsonRpcPayload,
  isInstructionWithData: () => isInstructionWithData,
  isInstructionWithAccounts: () => isInstructionWithAccounts,
  isInstructionForProgram: () => isInstructionForProgram,
  isFullySignedTransaction: () => isFullySignedTransaction,
  isFullySignedOffchainMessageEnvelope: () => isFullySignedOffchainMessageEnvelope,
  isFixedSize: () => isFixedSize,
  isBlockhash: () => isBlockhash,
  isAdvanceNonceAccountInstruction: () => isAdvanceNonceAccountInstruction,
  isAddress: () => isAddress,
  getUtf8Encoder: () => getUtf8Encoder,
  getUtf8Decoder: () => getUtf8Decoder,
  getUtf8Codec: () => getUtf8Codec,
  getUnitEncoder: () => getUnitEncoder,
  getUnitDecoder: () => getUnitDecoder,
  getUnitCodec: () => getUnitCodec,
  getUnionEncoder: () => getUnionEncoder,
  getUnionDecoder: () => getUnionDecoder,
  getUnionCodec: () => getUnionCodec,
  getU8Encoder: () => getU8Encoder,
  getU8Decoder: () => getU8Decoder,
  getU8Codec: () => getU8Codec,
  getU64Encoder: () => getU64Encoder,
  getU64Decoder: () => getU64Decoder,
  getU64Codec: () => getU64Codec,
  getU32Encoder: () => getU32Encoder,
  getU32Decoder: () => getU32Decoder,
  getU32Codec: () => getU32Codec,
  getU16Encoder: () => getU16Encoder,
  getU16Decoder: () => getU16Decoder,
  getU16Codec: () => getU16Codec,
  getU128Encoder: () => getU128Encoder,
  getU128Decoder: () => getU128Decoder,
  getU128Codec: () => getU128Codec,
  getTupleEncoder: () => getTupleEncoder,
  getTupleDecoder: () => getTupleDecoder,
  getTupleCodec: () => getTupleCodec,
  getTransactionVersionEncoder: () => getTransactionVersionEncoder,
  getTransactionVersionDecoder: () => getTransactionVersionDecoder,
  getTransactionVersionCodec: () => getTransactionVersionCodec,
  getTransactionSize: () => getTransactionSize,
  getTransactionMessageSize: () => getTransactionMessageSize,
  getTransactionLifetimeConstraintFromCompiledTransactionMessage: () => getTransactionLifetimeConstraintFromCompiledTransactionMessage,
  getTransactionEncoder: () => getTransactionEncoder,
  getTransactionDecoder: () => getTransactionDecoder,
  getTransactionCodec: () => getTransactionCodec,
  getStructEncoder: () => getStructEncoder,
  getStructDecoder: () => getStructDecoder,
  getStructCodec: () => getStructCodec,
  getSolanaErrorFromTransactionError: () => getSolanaErrorFromTransactionError,
  getSolanaErrorFromJsonRpcError: () => getSolanaErrorFromJsonRpcError,
  getSolanaErrorFromInstructionError: () => getSolanaErrorFromInstructionError,
  getSignersFromTransactionMessage: () => getSignersFromTransactionMessage,
  getSignersFromOffchainMessage: () => getSignersFromOffchainMessage,
  getSignersFromInstruction: () => getSignersFromInstruction,
  getSignatureFromTransaction: () => getSignatureFromTransaction,
  getShortU16Encoder: () => getShortU16Encoder,
  getShortU16Decoder: () => getShortU16Decoder,
  getShortU16Codec: () => getShortU16Codec,
  getSetEncoder: () => getSetEncoder,
  getSetDecoder: () => getSetDecoder,
  getSetCodec: () => getSetCodec,
  getRpcSubscriptionsTransportWithSubscriptionCoalescing: () => getRpcSubscriptionsTransportWithSubscriptionCoalescing,
  getRpcSubscriptionsChannelWithJSONSerialization: () => getRpcSubscriptionsChannelWithJSONSerialization,
  getRpcSubscriptionsChannelWithBigIntJSONSerialization: () => getRpcSubscriptionsChannelWithBigIntJSONSerialization,
  getRpcSubscriptionsChannelWithAutoping: () => getRpcSubscriptionsChannelWithAutoping,
  getReallocMessagePackerInstructionPlan: () => getReallocMessagePackerInstructionPlan,
  getPublicKeyFromPrivateKey: () => getPublicKeyFromPrivateKey,
  getPublicKeyFromAddress: () => getPublicKeyFromAddress,
  getProgramDerivedAddress: () => getProgramDerivedAddress,
  getOptionEncoder: () => getOptionEncoder,
  getOptionDecoder: () => getOptionDecoder,
  getOptionCodec: () => getOptionCodec,
  getOffchainMessageV1Encoder: () => getOffchainMessageV1Encoder,
  getOffchainMessageV1Decoder: () => getOffchainMessageV1Decoder,
  getOffchainMessageV1Codec: () => getOffchainMessageV1Codec,
  getOffchainMessageV0Encoder: () => getOffchainMessageV0Encoder,
  getOffchainMessageV0Decoder: () => getOffchainMessageV0Decoder,
  getOffchainMessageV0Codec: () => getOffchainMessageV0Codec,
  getOffchainMessageEnvelopeEncoder: () => getOffchainMessageEnvelopeEncoder,
  getOffchainMessageEnvelopeDecoder: () => getOffchainMessageEnvelopeDecoder,
  getOffchainMessageEnvelopeCodec: () => getOffchainMessageEnvelopeCodec,
  getOffchainMessageEncoder: () => getOffchainMessageEncoder,
  getOffchainMessageDecoder: () => getOffchainMessageDecoder,
  getOffchainMessageCodec: () => getOffchainMessageCodec,
  getOffchainMessageApplicationDomainEncoder: () => getOffchainMessageApplicationDomainEncoder,
  getOffchainMessageApplicationDomainDecoder: () => getOffchainMessageApplicationDomainDecoder,
  getOffchainMessageApplicationDomainCodec: () => getOffchainMessageApplicationDomainCodec,
  getNullableEncoder: () => getNullableEncoder,
  getNullableDecoder: () => getNullableDecoder,
  getNullableCodec: () => getNullableCodec,
  getMessagePackerInstructionPlanFromInstructions: () => getMessagePackerInstructionPlanFromInstructions,
  getMapEncoder: () => getMapEncoder,
  getMapDecoder: () => getMapDecoder,
  getMapCodec: () => getMapCodec,
  getLiteralUnionEncoder: () => getLiteralUnionEncoder,
  getLiteralUnionDecoder: () => getLiteralUnionDecoder,
  getLiteralUnionCodec: () => getLiteralUnionCodec,
  getLinearMessagePackerInstructionPlan: () => getLinearMessagePackerInstructionPlan,
  getLamportsEncoder: () => getLamportsEncoder,
  getLamportsDecoder: () => getLamportsDecoder,
  getLamportsCodec: () => getLamportsCodec,
  getI8Encoder: () => getI8Encoder,
  getI8Decoder: () => getI8Decoder,
  getI8Codec: () => getI8Codec,
  getI64Encoder: () => getI64Encoder,
  getI64Decoder: () => getI64Decoder,
  getI64Codec: () => getI64Codec,
  getI32Encoder: () => getI32Encoder,
  getI32Decoder: () => getI32Decoder,
  getI32Codec: () => getI32Codec,
  getI16Encoder: () => getI16Encoder,
  getI16Decoder: () => getI16Decoder,
  getI16Codec: () => getI16Codec,
  getI128Encoder: () => getI128Encoder,
  getI128Decoder: () => getI128Decoder,
  getI128Codec: () => getI128Codec,
  getHiddenSuffixEncoder: () => getHiddenSuffixEncoder,
  getHiddenSuffixDecoder: () => getHiddenSuffixDecoder,
  getHiddenSuffixCodec: () => getHiddenSuffixCodec,
  getHiddenPrefixEncoder: () => getHiddenPrefixEncoder,
  getHiddenPrefixDecoder: () => getHiddenPrefixDecoder,
  getHiddenPrefixCodec: () => getHiddenPrefixCodec,
  getF64Encoder: () => getF64Encoder,
  getF64Decoder: () => getF64Decoder,
  getF64Codec: () => getF64Codec,
  getF32Encoder: () => getF32Encoder,
  getF32Decoder: () => getF32Decoder,
  getF32Codec: () => getF32Codec,
  getEnumEncoder: () => getEnumEncoder,
  getEnumDecoder: () => getEnumDecoder,
  getEnumCodec: () => getEnumCodec,
  getEncodedSize: () => getEncodedSize,
  getDiscriminatedUnionEncoder: () => getDiscriminatedUnionEncoder,
  getDiscriminatedUnionDecoder: () => getDiscriminatedUnionDecoder,
  getDiscriminatedUnionCodec: () => getDiscriminatedUnionCodec,
  getDefaultLamportsEncoder: () => getDefaultLamportsEncoder,
  getDefaultLamportsDecoder: () => getDefaultLamportsDecoder,
  getDefaultLamportsCodec: () => getDefaultLamportsCodec,
  getConstantEncoder: () => getConstantEncoder,
  getConstantDecoder: () => getConstantDecoder,
  getConstantCodec: () => getConstantCodec,
  getCompiledTransactionMessageEncoder: () => getCompiledTransactionMessageEncoder,
  getCompiledTransactionMessageDecoder: () => getCompiledTransactionMessageDecoder,
  getCompiledTransactionMessageCodec: () => getCompiledTransactionMessageCodec,
  getChannelPoolingChannelCreator: () => getChannelPoolingChannelCreator,
  getBytesEncoder: () => getBytesEncoder,
  getBytesDecoder: () => getBytesDecoder,
  getBytesCodec: () => getBytesCodec,
  getBooleanEncoder: () => getBooleanEncoder,
  getBooleanDecoder: () => getBooleanDecoder,
  getBooleanCodec: () => getBooleanCodec,
  getBlockhashEncoder: () => getBlockhashEncoder,
  getBlockhashDecoder: () => getBlockhashDecoder,
  getBlockhashComparator: () => getBlockhashComparator,
  getBlockhashCodec: () => getBlockhashCodec,
  getBitArrayEncoder: () => getBitArrayEncoder,
  getBitArrayDecoder: () => getBitArrayDecoder,
  getBitArrayCodec: () => getBitArrayCodec,
  getBaseXResliceEncoder: () => getBaseXResliceEncoder,
  getBaseXResliceDecoder: () => getBaseXResliceDecoder,
  getBaseXResliceCodec: () => getBaseXResliceCodec,
  getBaseXEncoder: () => getBaseXEncoder,
  getBaseXDecoder: () => getBaseXDecoder,
  getBaseXCodec: () => getBaseXCodec,
  getBase64Encoder: () => getBase64Encoder,
  getBase64EncodedWireTransaction: () => getBase64EncodedWireTransaction,
  getBase64Decoder: () => getBase64Decoder,
  getBase64Codec: () => getBase64Codec,
  getBase58Encoder: () => getBase58Encoder,
  getBase58Decoder: () => getBase58Decoder,
  getBase58Codec: () => getBase58Codec,
  getBase16Encoder: () => getBase16Encoder,
  getBase16Decoder: () => getBase16Decoder,
  getBase16Codec: () => getBase16Codec,
  getBase10Encoder: () => getBase10Encoder,
  getBase10Decoder: () => getBase10Decoder,
  getBase10Codec: () => getBase10Codec,
  getArrayEncoder: () => getArrayEncoder,
  getArrayDecoder: () => getArrayDecoder,
  getArrayCodec: () => getArrayCodec,
  getAllSingleTransactionPlans: () => getAllSingleTransactionPlans,
  getAddressFromPublicKey: () => getAddressFromPublicKey,
  getAddressEncoder: () => getAddressEncoder,
  getAddressDecoder: () => getAddressDecoder,
  getAddressComparator: () => getAddressComparator,
  getAddressCodec: () => getAddressCodec,
  generateKeyPairSigner: () => generateKeyPairSigner,
  generateKeyPair: () => generateKeyPair,
  flattenTransactionPlanResult: () => flattenTransactionPlanResult,
  fixEncoderSize: () => fixEncoderSize,
  fixDecoderSize: () => fixDecoderSize,
  fixCodecSize: () => fixCodecSize,
  fixBytes: () => fixBytes,
  fetchJsonParsedAccounts: () => fetchJsonParsedAccounts,
  fetchJsonParsedAccount: () => fetchJsonParsedAccount,
  fetchEncodedAccounts: () => fetchEncodedAccounts,
  fetchEncodedAccount: () => fetchEncodedAccount,
  fetchAddressesForLookupTables: () => fetchAddressesForLookupTables,
  failedSingleTransactionPlanResult: () => failedSingleTransactionPlanResult,
  executeRpcPubSubSubscriptionPlan: () => executeRpcPubSubSubscriptionPlan,
  downgradeRoleToReadonly: () => downgradeRoleToReadonly,
  downgradeRoleToNonSigner: () => downgradeRoleToNonSigner,
  devnet: () => devnet,
  decompileTransactionMessageFetchingLookupTables: () => decompileTransactionMessageFetchingLookupTables,
  decompileTransactionMessage: () => decompileTransactionMessage,
  decodeAccount: () => decodeAccount,
  createTransactionPlanner: () => createTransactionPlanner,
  createTransactionPlanExecutor: () => createTransactionPlanExecutor,
  createTransactionMessage: () => createTransactionMessage,
  createSubscriptionRpc: () => createSubscriptionRpc,
  createSolanaRpcSubscriptions_UNSTABLE: () => createSolanaRpcSubscriptions_UNSTABLE,
  createSolanaRpcSubscriptionsFromTransport: () => createSolanaRpcSubscriptionsFromTransport,
  createSolanaRpcSubscriptionsApi_UNSTABLE: () => createSolanaRpcSubscriptionsApi_UNSTABLE,
  createSolanaRpcSubscriptionsApi: () => createSolanaRpcSubscriptionsApi,
  createSolanaRpcSubscriptions: () => createSolanaRpcSubscriptions,
  createSolanaRpcFromTransport: () => createSolanaRpcFromTransport,
  createSolanaRpcApi: () => createSolanaRpcApi,
  createSolanaRpc: () => createSolanaRpc,
  createSignerFromKeyPair: () => createSignerFromKeyPair,
  createSignableMessage: () => createSignableMessage,
  createRpcSubscriptionsTransportFromChannelCreator: () => createRpcSubscriptionsTransportFromChannelCreator,
  createRpcSubscriptionsApi: () => createRpcSubscriptionsApi,
  createRpcMessage: () => createRpcMessage,
  createRpc: () => createRpc,
  createPrivateKeyFromBytes: () => createPrivateKeyFromBytes,
  createNoopSigner: () => createNoopSigner,
  createKeyPairSignerFromPrivateKeyBytes: () => createKeyPairSignerFromPrivateKeyBytes,
  createKeyPairSignerFromBytes: () => createKeyPairSignerFromBytes,
  createKeyPairFromPrivateKeyBytes: () => createKeyPairFromPrivateKeyBytes,
  createKeyPairFromBytes: () => createKeyPairFromBytes,
  createJsonRpcApi: () => createJsonRpcApi,
  createEncoder: () => createEncoder,
  createDefaultSolanaRpcSubscriptionsChannelCreator: () => createDefaultSolanaRpcSubscriptionsChannelCreator,
  createDefaultRpcTransport: () => createDefaultRpcTransport,
  createDefaultRpcSubscriptionsTransport: () => createDefaultRpcSubscriptionsTransport,
  createDefaultRpcSubscriptionsChannelCreator: () => createDefaultRpcSubscriptionsChannelCreator,
  createDecoderThatConsumesEntireByteArray: () => createDecoderThatConsumesEntireByteArray,
  createDecoder: () => createDecoder,
  createCodec: () => createCodec,
  createAddressWithSeed: () => createAddressWithSeed,
  containsBytes: () => containsBytes,
  compressTransactionMessageUsingAddressLookupTables: () => compressTransactionMessageUsingAddressLookupTables,
  compileTransactionMessage: () => compileTransactionMessage,
  compileTransaction: () => compileTransaction,
  compileOffchainMessageV1Envelope: () => compileOffchainMessageV1Envelope,
  compileOffchainMessageV0Envelope: () => compileOffchainMessageV0Envelope,
  compileOffchainMessageEnvelope: () => compileOffchainMessageEnvelope,
  commitmentComparator: () => commitmentComparator,
  combineCodec: () => combineCodec,
  canceledSingleTransactionPlanResult: () => canceledSingleTransactionPlanResult,
  bytesEqual: () => bytesEqual,
  blockhash: () => blockhash,
  assertValidNumberOfItemsForCodec: () => assertValidNumberOfItemsForCodec,
  assertValidBaseString: () => assertValidBaseString,
  assertNumberIsBetweenForCodec: () => assertNumberIsBetweenForCodec,
  assertIsVariableSize: () => assertIsVariableSize,
  assertIsUnixTimestamp: () => assertIsUnixTimestamp,
  assertIsTransactionWithinSizeLimit: () => assertIsTransactionWithinSizeLimit,
  assertIsTransactionWithDurableNonceLifetime: () => assertIsTransactionWithDurableNonceLifetime,
  assertIsTransactionWithBlockhashLifetime: () => assertIsTransactionWithBlockhashLifetime,
  assertIsTransactionSigner: () => assertIsTransactionSigner,
  assertIsTransactionSendingSigner: () => assertIsTransactionSendingSigner,
  assertIsTransactionPartialSigner: () => assertIsTransactionPartialSigner,
  assertIsTransactionModifyingSigner: () => assertIsTransactionModifyingSigner,
  assertIsTransactionMessageWithinSizeLimit: () => assertIsTransactionMessageWithinSizeLimit,
  assertIsTransactionMessageWithSingleSendingSigner: () => assertIsTransactionMessageWithSingleSendingSigner,
  assertIsTransactionMessageWithDurableNonceLifetime: () => assertIsTransactionMessageWithDurableNonceLifetime,
  assertIsTransactionMessageWithBlockhashLifetime: () => assertIsTransactionMessageWithBlockhashLifetime,
  assertIsStringifiedNumber: () => assertIsStringifiedNumber,
  assertIsStringifiedBigInt: () => assertIsStringifiedBigInt,
  assertIsSignatureBytes: () => assertIsSignatureBytes,
  assertIsSignature: () => assertIsSignature,
  assertIsSendableTransaction: () => assertIsSendableTransaction,
  assertIsProgramDerivedAddress: () => assertIsProgramDerivedAddress,
  assertIsOffchainMessageUtf8Of65535BytesMax: () => assertIsOffchainMessageUtf8Of65535BytesMax,
  assertIsOffchainMessageUtf8Of1232BytesMax: () => assertIsOffchainMessageUtf8Of1232BytesMax,
  assertIsOffchainMessageRestrictedAsciiOf1232BytesMax: () => assertIsOffchainMessageRestrictedAsciiOf1232BytesMax,
  assertIsOffchainMessageContentUtf8Of65535BytesMax: () => assertIsOffchainMessageContentUtf8Of65535BytesMax,
  assertIsOffchainMessageContentUtf8Of1232BytesMax: () => assertIsOffchainMessageContentUtf8Of1232BytesMax,
  assertIsOffchainMessageContentRestrictedAsciiOf1232BytesMax: () => assertIsOffchainMessageContentRestrictedAsciiOf1232BytesMax,
  assertIsOffchainMessageApplicationDomain: () => assertIsOffchainMessageApplicationDomain,
  assertIsOffCurveAddress: () => assertIsOffCurveAddress,
  assertIsMessageSigner: () => assertIsMessageSigner,
  assertIsMessagePartialSigner: () => assertIsMessagePartialSigner,
  assertIsMessageModifyingSigner: () => assertIsMessageModifyingSigner,
  assertIsLamports: () => assertIsLamports,
  assertIsKeyPairSigner: () => assertIsKeyPairSigner,
  assertIsInstructionWithData: () => assertIsInstructionWithData,
  assertIsInstructionWithAccounts: () => assertIsInstructionWithAccounts,
  assertIsInstructionForProgram: () => assertIsInstructionForProgram,
  assertIsFullySignedTransaction: () => assertIsFullySignedTransaction,
  assertIsFullySignedOffchainMessageEnvelope: () => assertIsFullySignedOffchainMessageEnvelope,
  assertIsFixedSize: () => assertIsFixedSize,
  assertIsBlockhash: () => assertIsBlockhash,
  assertIsAddress: () => assertIsAddress,
  assertByteArrayOffsetIsNotOutOfRange: () => assertByteArrayOffsetIsNotOutOfRange,
  assertByteArrayIsNotEmptyForCodec: () => assertByteArrayIsNotEmptyForCodec,
  assertByteArrayHasEnoughBytesForCodec: () => assertByteArrayHasEnoughBytesForCodec,
  assertAccountsExist: () => assertAccountsExist,
  assertAccountsDecoded: () => assertAccountsDecoded,
  assertAccountExists: () => assertAccountExists,
  assertAccountDecoded: () => assertAccountDecoded,
  appendTransactionMessageInstructions: () => appendTransactionMessageInstructions,
  appendTransactionMessageInstruction: () => appendTransactionMessageInstruction,
  airdropFactory: () => airdropFactory,
  address: () => address,
  addSignersToTransactionMessage: () => addSignersToTransactionMessage,
  addSignersToInstruction: () => addSignersToInstruction,
  addEncoderSizePrefix: () => addEncoderSizePrefix,
  addEncoderSentinel: () => addEncoderSentinel,
  addDecoderSizePrefix: () => addDecoderSizePrefix,
  addDecoderSentinel: () => addDecoderSentinel,
  addCodecSizePrefix: () => addCodecSizePrefix,
  addCodecSentinel: () => addCodecSentinel,
  TRANSACTION_SIZE_LIMIT: () => TRANSACTION_SIZE_LIMIT,
  TRANSACTION_PACKET_SIZE: () => TRANSACTION_PACKET_SIZE,
  TRANSACTION_PACKET_HEADER: () => TRANSACTION_PACKET_HEADER,
  SolanaError: () => SolanaError,
  SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE: () => SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE,
  SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_NOT_SUPPORTED: () => SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_NOT_SUPPORTED,
  SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING: () => SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING,
  SOLANA_ERROR__TRANSACTION__NONCE_ACCOUNT_CANNOT_BE_IN_LOOKUP_TABLE: () => SOLANA_ERROR__TRANSACTION__NONCE_ACCOUNT_CANNOT_BE_IN_LOOKUP_TABLE,
  SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH: () => SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH,
  SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE: () => SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE,
  SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES: () => SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES,
  SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING: () => SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING,
  SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE: () => SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE,
  SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING: () => SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING,
  SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING: () => SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING,
  SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT: () => SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT,
  SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT: () => SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT,
  SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND: () => SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND,
  SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING: () => SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING,
  SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE: () => SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE,
  SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING: () => SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING,
  SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME: () => SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME,
  SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME: () => SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME,
  SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT: () => SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT,
  SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES: () => SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES,
  SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING: () => SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING,
  SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION: () => SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION,
  SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT: () => SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT,
  SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT: () => SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT,
  SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT: () => SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT,
  SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT: () => SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT,
  SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT: () => SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT,
  SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION: () => SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION,
  SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN: () => SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN,
  SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION: () => SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION,
  SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS: () => SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS,
  SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE: () => SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE,
  SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE: () => SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE,
  SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED: () => SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED,
  SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED: () => SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED,
  SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND: () => SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND,
  SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE: () => SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE,
  SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED: () => SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED,
  SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT: () => SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT,
  SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT: () => SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT,
  SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION: () => SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION,
  SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT: () => SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT,
  SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER: () => SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER,
  SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX: () => SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX,
  SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA: () => SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA,
  SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX: () => SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX,
  SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE: () => SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE,
  SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT: () => SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT,
  SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE: () => SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE,
  SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION: () => SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION,
  SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE: () => SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE,
  SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP: () => SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP,
  SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND: () => SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND,
  SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED: () => SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED,
  SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND: () => SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND,
  SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND: () => SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND,
  SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE: () => SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE,
  SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE: () => SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE,
  SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING: () => SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING,
  SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE: () => SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE,
  SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED: () => SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED,
  SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED: () => SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED,
  SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED: () => SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED,
  SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED: () => SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED,
  SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED: () => SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED,
  SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT: () => SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT,
  SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED: () => SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED,
  SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY: () => SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY,
  SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED: () => SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED,
  SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING: () => SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING,
  SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS: () => SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS,
  SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER: () => SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER,
  SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER: () => SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER,
  SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER: () => SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER,
  SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER: () => SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER,
  SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER: () => SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER,
  SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER: () => SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER,
  SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER: () => SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER,
  SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER: () => SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER,
  SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS: () => SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS,
  SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN: () => SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN,
  SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR: () => SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR,
  SOLANA_ERROR__RPC__INTEGER_OVERFLOW: () => SOLANA_ERROR__RPC__INTEGER_OVERFLOW,
  SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD: () => SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD,
  SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID: () => SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID,
  SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT: () => SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT,
  SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED: () => SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED,
  SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED: () => SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED,
  SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN: () => SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN,
  SOLANA_ERROR__OFFCHAIN_MESSAGE__VERSION_NUMBER_NOT_SUPPORTED: () => SOLANA_ERROR__OFFCHAIN_MESSAGE__VERSION_NUMBER_NOT_SUPPORTED,
  SOLANA_ERROR__OFFCHAIN_MESSAGE__UNEXPECTED_VERSION: () => SOLANA_ERROR__OFFCHAIN_MESSAGE__UNEXPECTED_VERSION,
  SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURE_VERIFICATION_FAILURE: () => SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURE_VERIFICATION_FAILURE,
  SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURES_MISSING: () => SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATURES_MISSING,
  SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATORIES_MUST_BE_UNIQUE: () => SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATORIES_MUST_BE_UNIQUE,
  SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATORIES_MUST_BE_SORTED: () => SOLANA_ERROR__OFFCHAIN_MESSAGE__SIGNATORIES_MUST_BE_SORTED,
  SOLANA_ERROR__OFFCHAIN_MESSAGE__RESTRICTED_ASCII_BODY_CHARACTER_OUT_OF_RANGE: () => SOLANA_ERROR__OFFCHAIN_MESSAGE__RESTRICTED_ASCII_BODY_CHARACTER_OUT_OF_RANGE,
  SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_SIGNATURES_MISMATCH: () => SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_SIGNATURES_MISMATCH,
  SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO: () => SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_REQUIRED_SIGNERS_CANNOT_BE_ZERO,
  SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_ENVELOPE_SIGNATURES_CANNOT_BE_ZERO: () => SOLANA_ERROR__OFFCHAIN_MESSAGE__NUM_ENVELOPE_SIGNATURES_CANNOT_BE_ZERO,
  SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_MUST_BE_NON_EMPTY: () => SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_MUST_BE_NON_EMPTY,
  SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_LENGTH_MISMATCH: () => SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_LENGTH_MISMATCH,
  SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_FORMAT_MISMATCH: () => SOLANA_ERROR__OFFCHAIN_MESSAGE__MESSAGE_FORMAT_MISMATCH,
  SOLANA_ERROR__OFFCHAIN_MESSAGE__MAXIMUM_LENGTH_EXCEEDED: () => SOLANA_ERROR__OFFCHAIN_MESSAGE__MAXIMUM_LENGTH_EXCEEDED,
  SOLANA_ERROR__OFFCHAIN_MESSAGE__INVALID_APPLICATION_DOMAIN_BYTE_LENGTH: () => SOLANA_ERROR__OFFCHAIN_MESSAGE__INVALID_APPLICATION_DOMAIN_BYTE_LENGTH,
  SOLANA_ERROR__OFFCHAIN_MESSAGE__ENVELOPE_SIGNERS_MISMATCH: () => SOLANA_ERROR__OFFCHAIN_MESSAGE__ENVELOPE_SIGNERS_MISMATCH,
  SOLANA_ERROR__OFFCHAIN_MESSAGE__APPLICATION_DOMAIN_STRING_LENGTH_OUT_OF_RANGE: () => SOLANA_ERROR__OFFCHAIN_MESSAGE__APPLICATION_DOMAIN_STRING_LENGTH_OUT_OF_RANGE,
  SOLANA_ERROR__OFFCHAIN_MESSAGE__ADDRESSES_CANNOT_SIGN_OFFCHAIN_MESSAGE: () => SOLANA_ERROR__OFFCHAIN_MESSAGE__ADDRESSES_CANNOT_SIGN_OFFCHAIN_MESSAGE,
  SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND: () => SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND,
  SOLANA_ERROR__MALFORMED_NUMBER_STRING: () => SOLANA_ERROR__MALFORMED_NUMBER_STRING,
  SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR: () => SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR,
  SOLANA_ERROR__MALFORMED_BIGINT_STRING: () => SOLANA_ERROR__MALFORMED_BIGINT_STRING,
  SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE: () => SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE,
  SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE: () => SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE,
  SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY: () => SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY,
  SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH: () => SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH,
  SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH: () => SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH,
  SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH: () => SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH,
  SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION: () => SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION,
  SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE: () => SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE,
  SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH: () => SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH,
  SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE: () => SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE,
  SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE: () => SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE,
  SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED: () => SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED,
  SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_NOT_EPOCH_BOUNDARY: () => SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_NOT_EPOCH_BOUNDARY,
  SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE: () => SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE,
  SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT: () => SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT,
  SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY: () => SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY,
  SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED: () => SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED,
  SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_UNREACHABLE: () => SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_UNREACHABLE,
  SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED: () => SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED,
  SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX: () => SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX,
  SOLANA_ERROR__JSON_RPC__SERVER_ERROR_EPOCH_REWARDS_PERIOD_ACTIVE: () => SOLANA_ERROR__JSON_RPC__SERVER_ERROR_EPOCH_REWARDS_PERIOD_ACTIVE,
  SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET: () => SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET,
  SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE: () => SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE,
  SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP: () => SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP,
  SOLANA_ERROR__JSON_RPC__SCAN_ERROR: () => SOLANA_ERROR__JSON_RPC__SCAN_ERROR,
  SOLANA_ERROR__JSON_RPC__PARSE_ERROR: () => SOLANA_ERROR__JSON_RPC__PARSE_ERROR,
  SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND: () => SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND,
  SOLANA_ERROR__JSON_RPC__INVALID_REQUEST: () => SOLANA_ERROR__JSON_RPC__INVALID_REQUEST,
  SOLANA_ERROR__JSON_RPC__INVALID_PARAMS: () => SOLANA_ERROR__JSON_RPC__INVALID_PARAMS,
  SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR: () => SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR,
  SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE: () => SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE,
  SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING: () => SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING,
  SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE: () => SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE,
  SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_TRANSACTION_PLAN_KIND: () => SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_TRANSACTION_PLAN_KIND,
  SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_INSTRUCTION_PLAN_KIND: () => SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_INSTRUCTION_PLAN_KIND,
  SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED: () => SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED,
  SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING: () => SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING,
  SOLANA_ERROR__INVALID_NONCE: () => SOLANA_ERROR__INVALID_NONCE,
  SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH: () => SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH,
  SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH: () => SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH,
  SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA: () => SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA,
  SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS: () => SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS,
  SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_PACKER_ALREADY_COMPLETE: () => SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_PACKER_ALREADY_COMPLETE,
  SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN: () => SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN,
  SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_TO_EXECUTE_TRANSACTION_PLAN: () => SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_TO_EXECUTE_TRANSACTION_PLAN,
  SOLANA_ERROR__INSTRUCTION_PLANS__EMPTY_INSTRUCTION_PLAN: () => SOLANA_ERROR__INSTRUCTION_PLANS__EMPTY_INSTRUCTION_PLAN,
  SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR: () => SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR,
  SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID: () => SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID,
  SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN: () => SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN,
  SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT: () => SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT,
  SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION: () => SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION,
  SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED: () => SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED,
  SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED: () => SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED,
  SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE: () => SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE,
  SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED: () => SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED,
  SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE: () => SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE,
  SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE: () => SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE,
  SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE: () => SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE,
  SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION: () => SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION,
  SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS: () => SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS,
  SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID: () => SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID,
  SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE: () => SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE,
  SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT: () => SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT,
  SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED: () => SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED,
  SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED: () => SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED,
  SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED: () => SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED,
  SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED: () => SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED,
  SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS: () => SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS,
  SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC: () => SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC,
  SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA: () => SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA,
  SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR: () => SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR,
  SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT: () => SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT,
  SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER: () => SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER,
  SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA: () => SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA,
  SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS: () => SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS,
  SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID: () => SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID,
  SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY: () => SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY,
  SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE: () => SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE,
  SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER: () => SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER,
  SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR: () => SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR,
  SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND: () => SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND,
  SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED: () => SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED,
  SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED: () => SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED,
  SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE: () => SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE,
  SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED: () => SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED,
  SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT: () => SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT,
  SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC: () => SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC,
  SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX: () => SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX,
  SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM: () => SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM,
  SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED: () => SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED,
  SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH: () => SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH,
  SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS: () => SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS,
  SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR: () => SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR,
  SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW: () => SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW,
  SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT: () => SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT,
  SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE: () => SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE,
  SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL: () => SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL,
  SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED: () => SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED,
  SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING: () => SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING,
  SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED: () => SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED,
  SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED: () => SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED,
  SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED: () => SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED,
  SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE: () => SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE,
  SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES: () => SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES,
  SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE: () => SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE,
  SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE: () => SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE,
  SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE: () => SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE,
  SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE: () => SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE,
  SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS: () => SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS,
  SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT: () => SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT,
  SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT: () => SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT,
  SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT: () => SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT,
  SOLANA_ERROR__CODECS__INVALID_CONSTANT: () => SOLANA_ERROR__CODECS__INVALID_CONSTANT,
  SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH: () => SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH,
  SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE: () => SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE,
  SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH: () => SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH,
  SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH: () => SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH,
  SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH: () => SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH,
  SOLANA_ERROR__CODECS__EXPECTED_DECODER_TO_CONSUME_ENTIRE_BYTE_ARRAY: () => SOLANA_ERROR__CODECS__EXPECTED_DECODER_TO_CONSUME_ENTIRE_BYTE_ARRAY,
  SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE: () => SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE,
  SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH: () => SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH,
  SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH: () => SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH,
  SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH: () => SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH,
  SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL: () => SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL,
  SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS: () => SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS,
  SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY: () => SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY,
  SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED: () => SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED,
  SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE: () => SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE,
  SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE: () => SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE,
  SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER: () => SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER,
  SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE: () => SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE,
  SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED: () => SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED,
  SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED: () => SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED,
  SOLANA_ERROR__ADDRESSES__MALFORMED_PDA: () => SOLANA_ERROR__ADDRESSES__MALFORMED_PDA,
  SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE: () => SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE,
  SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS: () => SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS,
  SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY: () => SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY,
  SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH: () => SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH,
  SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS: () => SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS,
  SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED: () => SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED,
  SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND: () => SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND,
  SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT: () => SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT,
  SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT: () => SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT,
  SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED: () => SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED,
  SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND: () => SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND,
  OffchainMessageContentFormat: () => OffchainMessageContentFormat,
  MAX_SUPPORTED_TRANSACTION_VERSION: () => MAX_SUPPORTED_TRANSACTION_VERSION,
  Endian: () => Endian,
  DEFAULT_RPC_SUBSCRIPTIONS_CONFIG: () => DEFAULT_RPC_SUBSCRIPTIONS_CONFIG,
  DEFAULT_RPC_CONFIG: () => DEFAULT_RPC_CONFIG,
  BASE_ACCOUNT_SIZE: () => BASE_ACCOUNT_SIZE,
  AccountRole: () => AccountRole
});
async function requestAndConfirmAirdrop_INTERNAL_ONLY_DO_NOT_EXPORT({
  abortSignal,
  commitment,
  confirmSignatureOnlyTransaction,
  lamports: lamports2,
  recipientAddress,
  rpc: rpc2
}) {
  const airdropTransactionSignature = await rpc2.requestAirdrop(recipientAddress, lamports2, { commitment }).send({ abortSignal });
  await confirmSignatureOnlyTransaction({
    abortSignal,
    commitment,
    signature: airdropTransactionSignature
  });
  return airdropTransactionSignature;
}
function airdropFactory({
  rpc: rpc2,
  rpcSubscriptions
}) {
  const getRecentSignatureConfirmationPromise = createRecentSignatureConfirmationPromiseFactory({
    rpc: rpc2,
    rpcSubscriptions
  });
  async function confirmSignatureOnlyTransaction(config) {
    await waitForRecentTransactionConfirmationUntilTimeout({
      ...config,
      getRecentSignatureConfirmationPromise,
      getTimeoutPromise
    });
  }
  return async function airdrop(config) {
    return await requestAndConfirmAirdrop_INTERNAL_ONLY_DO_NOT_EXPORT({
      ...config,
      confirmSignatureOnlyTransaction,
      rpc: rpc2
    });
  };
}
async function fetchAddressesForLookupTables(lookupTableAddresses, rpc2, config) {
  if (lookupTableAddresses.length === 0) {
    return {};
  }
  const fetchedLookupTables = await fetchJsonParsedAccounts(rpc2, lookupTableAddresses, config);
  assertAccountsDecoded(fetchedLookupTables);
  assertAccountsExist(fetchedLookupTables);
  return fetchedLookupTables.reduce((acc, lookup) => {
    return {
      ...acc,
      [lookup.address]: lookup.data.addresses
    };
  }, {});
}
async function decompileTransactionMessageFetchingLookupTables(compiledTransactionMessage, rpc2, config) {
  const lookupTables = "addressTableLookups" in compiledTransactionMessage && compiledTransactionMessage.addressTableLookups !== undefined && compiledTransactionMessage.addressTableLookups.length > 0 ? compiledTransactionMessage.addressTableLookups : [];
  const lookupTableAddresses = lookupTables.map((l2) => l2.lookupTableAddress);
  const { lastValidBlockHeight, ...fetchAccountsConfig } = config ?? {};
  const addressesByLookupTableAddress = lookupTableAddresses.length > 0 ? await fetchAddressesForLookupTables(lookupTableAddresses, rpc2, fetchAccountsConfig) : {};
  return decompileTransactionMessage(compiledTransactionMessage, {
    addressesByLookupTableAddress,
    lastValidBlockHeight
  });
}
function getSendTransactionConfigWithAdjustedPreflightCommitment(commitment, config) {
  if (!config?.preflightCommitment && commitmentComparator(commitment, "finalized") < 0) {
    return {
      ...config,
      preflightCommitment: commitment
    };
  }
  return config;
}
async function sendTransaction_INTERNAL_ONLY_DO_NOT_EXPORT({
  abortSignal,
  commitment,
  rpc: rpc2,
  transaction,
  ...sendTransactionConfig
}) {
  const base64EncodedWireTransaction = getBase64EncodedWireTransaction(transaction);
  return await rpc2.sendTransaction(base64EncodedWireTransaction, {
    ...getSendTransactionConfigWithAdjustedPreflightCommitment(commitment, sendTransactionConfig),
    encoding: "base64"
  }).send({ abortSignal });
}
async function sendAndConfirmDurableNonceTransaction_INTERNAL_ONLY_DO_NOT_EXPORT({
  abortSignal,
  commitment,
  confirmDurableNonceTransaction,
  rpc: rpc2,
  transaction,
  ...sendTransactionConfig
}) {
  const transactionSignature = await sendTransaction_INTERNAL_ONLY_DO_NOT_EXPORT({
    ...sendTransactionConfig,
    abortSignal,
    commitment,
    rpc: rpc2,
    transaction
  });
  await confirmDurableNonceTransaction({
    abortSignal,
    commitment,
    transaction
  });
  return transactionSignature;
}
async function sendAndConfirmTransactionWithBlockhashLifetime_INTERNAL_ONLY_DO_NOT_EXPORT({
  abortSignal,
  commitment,
  confirmRecentTransaction,
  rpc: rpc2,
  transaction,
  ...sendTransactionConfig
}) {
  const transactionSignature = await sendTransaction_INTERNAL_ONLY_DO_NOT_EXPORT({
    ...sendTransactionConfig,
    abortSignal,
    commitment,
    rpc: rpc2,
    transaction
  });
  await confirmRecentTransaction({
    abortSignal,
    commitment,
    transaction
  });
  return transactionSignature;
}
function sendAndConfirmDurableNonceTransactionFactory({
  rpc: rpc2,
  rpcSubscriptions
}) {
  const getNonceInvalidationPromise = createNonceInvalidationPromiseFactory({ rpc: rpc2, rpcSubscriptions });
  const getRecentSignatureConfirmationPromise = createRecentSignatureConfirmationPromiseFactory({
    rpc: rpc2,
    rpcSubscriptions
  });
  async function confirmDurableNonceTransaction(config) {
    await waitForDurableNonceTransactionConfirmation({
      ...config,
      getNonceInvalidationPromise,
      getRecentSignatureConfirmationPromise
    });
  }
  return async function sendAndConfirmDurableNonceTransaction(transaction, config) {
    await sendAndConfirmDurableNonceTransaction_INTERNAL_ONLY_DO_NOT_EXPORT({
      ...config,
      confirmDurableNonceTransaction,
      rpc: rpc2,
      transaction
    });
  };
}
function sendAndConfirmTransactionFactory({
  rpc: rpc2,
  rpcSubscriptions
}) {
  const getBlockHeightExceedencePromise = createBlockHeightExceedencePromiseFactory({
    rpc: rpc2,
    rpcSubscriptions
  });
  const getRecentSignatureConfirmationPromise = createRecentSignatureConfirmationPromiseFactory({
    rpc: rpc2,
    rpcSubscriptions
  });
  async function confirmRecentTransaction(config) {
    await waitForRecentTransactionConfirmation({
      ...config,
      getBlockHeightExceedencePromise,
      getRecentSignatureConfirmationPromise
    });
  }
  return async function sendAndConfirmTransaction(transaction, config) {
    await sendAndConfirmTransactionWithBlockhashLifetime_INTERNAL_ONLY_DO_NOT_EXPORT({
      ...config,
      confirmRecentTransaction,
      rpc: rpc2,
      transaction
    });
  };
}
function sendTransactionWithoutConfirmingFactory({
  rpc: rpc2
}) {
  return async function sendTransactionWithoutConfirming(transaction, config) {
    await sendTransaction_INTERNAL_ONLY_DO_NOT_EXPORT({
      ...config,
      rpc: rpc2,
      transaction
    });
  };
}
var init_index_node35 = __esm(() => {
  init_index_node6();
  init_index_node11();
  init_index_node14();
  init_index_node16();
  init_index_node34();
  init_index_node21();
  init_index_node6();
  init_index_node5();
  init_index_node10();
  init_index_node();
  init_index_node12();
  init_index_node13();
  init_index_node18();
  init_index_node15();
  init_index_node19();
  init_index_node20();
  init_index_node27();
  init_index_node32();
  init_index_node11();
  init_index_node33();
  init_index_node14();
  init_index_node16();
});

// ../packages/sdk-typescript/dist/chunk-IHVDQ4YI.js
function getAccessAuditConfigEncoder() {
  return getStructEncoder([
    ["auditEnabled", getBooleanEncoder()],
    ["realTimeMonitoring", getBooleanEncoder()],
    ["retentionPeriod", getI64Encoder()]
  ]);
}
function getAccessAuditConfigDecoder() {
  return getStructDecoder([
    ["auditEnabled", getBooleanDecoder()],
    ["realTimeMonitoring", getBooleanDecoder()],
    ["retentionPeriod", getI64Decoder()]
  ]);
}
function getAccessAuditConfigCodec() {
  return combineCodec(getAccessAuditConfigEncoder(), getAccessAuditConfigDecoder());
}
function getAccessPolicyEncoder() {
  return getStructEncoder([
    ["policyId", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["name", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["description", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["policyType", getPolicyTypeEncoder()],
    ["rules", getArrayEncoder(getPolicyRuleEncoder())],
    ["scope", getPolicyScopeEncoder()],
    ["priority", getU8Encoder()],
    ["status", getPolicyStatusEncoder()],
    ["effectiveDate", getI64Encoder()],
    ["expirationDate", getOptionEncoder(getI64Encoder())],
    ["metadata", getPolicyMetadataEncoder()]
  ]);
}
function getAccessPolicyDecoder() {
  return getStructDecoder([
    ["policyId", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["name", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["description", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["policyType", getPolicyTypeDecoder()],
    ["rules", getArrayDecoder(getPolicyRuleDecoder())],
    ["scope", getPolicyScopeDecoder()],
    ["priority", getU8Decoder()],
    ["status", getPolicyStatusDecoder()],
    ["effectiveDate", getI64Decoder()],
    ["expirationDate", getOptionDecoder(getI64Decoder())],
    ["metadata", getPolicyMetadataDecoder()]
  ]);
}
function getAccessPolicyCodec() {
  return combineCodec(getAccessPolicyEncoder(), getAccessPolicyDecoder());
}
function getAccessTierEncoder() {
  return getEnumEncoder(AccessTier);
}
function getAccessTierDecoder() {
  return getEnumDecoder(AccessTier);
}
function getAccessTierCodec() {
  return combineCodec(getAccessTierEncoder(), getAccessTierDecoder());
}
function getAccountLockoutPoliciesEncoder() {
  return getStructEncoder([
    ["maxFailedAttempts", getU8Encoder()],
    ["lockoutDuration", getI64Encoder()],
    ["progressiveLockout", getBooleanEncoder()],
    ["unlockMethods", getArrayEncoder(getUnlockMethodEncoder())],
    [
      "notificationRequirements",
      getArrayEncoder(getNotificationRequirementEncoder())
    ]
  ]);
}
function getAccountLockoutPoliciesDecoder() {
  return getStructDecoder([
    ["maxFailedAttempts", getU8Decoder()],
    ["lockoutDuration", getI64Decoder()],
    ["progressiveLockout", getBooleanDecoder()],
    ["unlockMethods", getArrayDecoder(getUnlockMethodDecoder())],
    [
      "notificationRequirements",
      getArrayDecoder(getNotificationRequirementDecoder())
    ]
  ]);
}
function getAccountLockoutPoliciesCodec() {
  return combineCodec(getAccountLockoutPoliciesEncoder(), getAccountLockoutPoliciesDecoder());
}
function getActivationRequirementEncoder() {
  return getStructEncoder([
    ["requirementType", getActivationRequirementTypeEncoder()],
    ["approvers", getArrayEncoder(getAddressEncoder())],
    ["minApprovals", getU8Encoder()],
    ["approvalTimeout", getI64Encoder()],
    [
      "evidenceRequirements",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ]
  ]);
}
function getActivationRequirementDecoder() {
  return getStructDecoder([
    ["requirementType", getActivationRequirementTypeDecoder()],
    ["approvers", getArrayDecoder(getAddressDecoder())],
    ["minApprovals", getU8Decoder()],
    ["approvalTimeout", getI64Decoder()],
    [
      "evidenceRequirements",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ]
  ]);
}
function getActivationRequirementCodec() {
  return combineCodec(getActivationRequirementEncoder(), getActivationRequirementDecoder());
}
function getActivationRequirementTypeEncoder() {
  return getEnumEncoder(ActivationRequirementType);
}
function getActivationRequirementTypeDecoder() {
  return getEnumDecoder(ActivationRequirementType);
}
function getActivationRequirementTypeCodec() {
  return combineCodec(getActivationRequirementTypeEncoder(), getActivationRequirementTypeDecoder());
}
function getActionEncoder() {
  return getStructEncoder([
    ["name", getUtf8Encoder()],
    ["actionType", getActionTypeEncoder()],
    [
      "parameters",
      getArrayEncoder(getStructEncoder([
        ["0", getUtf8Encoder()],
        ["1", getUtf8Encoder()]
      ]))
    ],
    ["constraints", getArrayEncoder(getActionConstraintEncoder())]
  ]);
}
function getActionDecoder() {
  return getStructDecoder([
    ["name", getUtf8Decoder()],
    ["actionType", getActionTypeDecoder()],
    [
      "parameters",
      getArrayDecoder(getStructDecoder([
        ["0", getUtf8Decoder()],
        ["1", getUtf8Decoder()]
      ]))
    ],
    ["constraints", getArrayDecoder(getActionConstraintDecoder())]
  ]);
}
function getActionCodec() {
  return combineCodec(getActionEncoder(), getActionDecoder());
}
function getActionConstraintEncoder() {
  return getStructEncoder([
    ["name", getUtf8Encoder()],
    ["preConditions", getArrayEncoder(getUtf8Encoder())],
    ["postConditions", getArrayEncoder(getUtf8Encoder())]
  ]);
}
function getActionConstraintDecoder() {
  return getStructDecoder([
    ["name", getUtf8Decoder()],
    ["preConditions", getArrayDecoder(getUtf8Decoder())],
    ["postConditions", getArrayDecoder(getUtf8Decoder())]
  ]);
}
function getActionConstraintCodec() {
  return combineCodec(getActionConstraintEncoder(), getActionConstraintDecoder());
}
function getActionTypeEncoder() {
  return getU8Encoder();
}
function getActionTypeDecoder() {
  return getU8Decoder();
}
function getActionTypeCodec() {
  return combineCodec(getActionTypeEncoder(), getActionTypeDecoder());
}
function getAgentRegisteredEventEncoder() {
  return getStructEncoder([
    ["agent", getAddressEncoder()],
    ["owner", getAddressEncoder()],
    ["name", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["timestamp", getI64Encoder()]
  ]);
}
function getAgentRegisteredEventDecoder() {
  return getStructDecoder([
    ["agent", getAddressDecoder()],
    ["owner", getAddressDecoder()],
    ["name", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["timestamp", getI64Decoder()]
  ]);
}
function getAgentRegisteredEventCodec() {
  return combineCodec(getAgentRegisteredEventEncoder(), getAgentRegisteredEventDecoder());
}
function getAgentServiceUpdatedEventEncoder() {
  return getStructEncoder([
    ["agent", getAddressEncoder()],
    ["owner", getAddressEncoder()],
    ["timestamp", getI64Encoder()],
    [
      "serviceEndpoint",
      addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())
    ],
    ["isActive", getBooleanEncoder()]
  ]);
}
function getAgentServiceUpdatedEventDecoder() {
  return getStructDecoder([
    ["agent", getAddressDecoder()],
    ["owner", getAddressDecoder()],
    ["timestamp", getI64Decoder()],
    [
      "serviceEndpoint",
      addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())
    ],
    ["isActive", getBooleanDecoder()]
  ]);
}
function getAgentServiceUpdatedEventCodec() {
  return combineCodec(getAgentServiceUpdatedEventEncoder(), getAgentServiceUpdatedEventDecoder());
}
function getAgentStatusChangedEventEncoder() {
  return getStructEncoder([
    ["agent", getAddressEncoder()],
    ["previousStatus", getBooleanEncoder()],
    ["newStatus", getBooleanEncoder()],
    ["timestamp", getI64Encoder()],
    ["authority", getAddressEncoder()]
  ]);
}
function getAgentStatusChangedEventDecoder() {
  return getStructDecoder([
    ["agent", getAddressDecoder()],
    ["previousStatus", getBooleanDecoder()],
    ["newStatus", getBooleanDecoder()],
    ["timestamp", getI64Decoder()],
    ["authority", getAddressDecoder()]
  ]);
}
function getAgentStatusChangedEventCodec() {
  return combineCodec(getAgentStatusChangedEventEncoder(), getAgentStatusChangedEventDecoder());
}
function getAgentUpdatedEventEncoder() {
  return getStructEncoder([
    ["agent", getAddressEncoder()],
    ["owner", getAddressEncoder()],
    ["timestamp", getI64Encoder()]
  ]);
}
function getAgentUpdatedEventDecoder() {
  return getStructDecoder([
    ["agent", getAddressDecoder()],
    ["owner", getAddressDecoder()],
    ["timestamp", getI64Decoder()]
  ]);
}
function getAgentUpdatedEventCodec() {
  return combineCodec(getAgentUpdatedEventEncoder(), getAgentUpdatedEventDecoder());
}
function getAgentVerificationDataEncoder() {
  return getStructEncoder([
    ["agentPubkey", getAddressEncoder()],
    [
      "serviceEndpoint",
      addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())
    ],
    ["supportedCapabilities", getArrayEncoder(getU64Encoder())],
    ["verifiedAt", getI64Encoder()]
  ]);
}
function getAgentVerificationDataDecoder() {
  return getStructDecoder([
    ["agentPubkey", getAddressDecoder()],
    [
      "serviceEndpoint",
      addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())
    ],
    ["supportedCapabilities", getArrayDecoder(getU64Decoder())],
    ["verifiedAt", getI64Decoder()]
  ]);
}
function getAgentVerificationDataCodec() {
  return combineCodec(getAgentVerificationDataEncoder(), getAgentVerificationDataDecoder());
}
function getAgingPolicyEncoder() {
  return getStructEncoder([
    ["biometricType", getBiometricTypeEncoder()],
    ["maxAge", getI64Encoder()],
    [
      "refreshRequirements",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    ["degradationHandling", getDegradationHandlingEncoder()]
  ]);
}
function getAgingPolicyDecoder() {
  return getStructDecoder([
    ["biometricType", getBiometricTypeDecoder()],
    ["maxAge", getI64Decoder()],
    [
      "refreshRequirements",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    ["degradationHandling", getDegradationHandlingDecoder()]
  ]);
}
function getAgingPolicyCodec() {
  return combineCodec(getAgingPolicyEncoder(), getAgingPolicyDecoder());
}
function getApprovalLevelEncoder() {
  return getStructEncoder([
    ["actionType", getAuditActionEncoder()],
    ["requiredApprovers", getArrayEncoder(getAddressEncoder())],
    ["minApprovals", getU8Encoder()],
    ["approvalTimeout", getI64Encoder()]
  ]);
}
function getApprovalLevelDecoder() {
  return getStructDecoder([
    ["actionType", getAuditActionDecoder()],
    ["requiredApprovers", getArrayDecoder(getAddressDecoder())],
    ["minApprovals", getU8Decoder()],
    ["approvalTimeout", getI64Decoder()]
  ]);
}
function getApprovalLevelCodec() {
  return combineCodec(getApprovalLevelEncoder(), getApprovalLevelDecoder());
}
function getArbitratorDecisionEncoder() {
  return getDiscriminatedUnionEncoder([
    [
      "FavorClient",
      getStructEncoder([
        ["reason", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())]
      ])
    ],
    [
      "FavorAgent",
      getStructEncoder([
        ["reason", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())]
      ])
    ],
    [
      "Split",
      getStructEncoder([
        ["clientPercentage", getU8Encoder()],
        ["reason", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())]
      ])
    ]
  ]);
}
function getArbitratorDecisionDecoder() {
  return getDiscriminatedUnionDecoder([
    [
      "FavorClient",
      getStructDecoder([
        ["reason", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())]
      ])
    ],
    [
      "FavorAgent",
      getStructDecoder([
        ["reason", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())]
      ])
    ],
    [
      "Split",
      getStructDecoder([
        ["clientPercentage", getU8Decoder()],
        ["reason", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())]
      ])
    ]
  ]);
}
function getArbitratorDecisionCodec() {
  return combineCodec(getArbitratorDecisionEncoder(), getArbitratorDecisionDecoder());
}
function arbitratorDecision(kind, data2) {
  return Array.isArray(data2) ? { __kind: kind, fields: data2 } : { __kind: kind, ...data2 ?? {} };
}
function isArbitratorDecision(kind, value) {
  return value.__kind === kind;
}
function getAuditActionEncoder() {
  return getEnumEncoder(AuditAction);
}
function getAuditActionDecoder() {
  return getEnumDecoder(AuditAction);
}
function getAuditActionCodec() {
  return combineCodec(getAuditActionEncoder(), getAuditActionDecoder());
}
function getAuditConfigEncoder() {
  return getStructEncoder([
    ["maxEntries", getU32Encoder()],
    ["retentionPeriod", getI64Encoder()],
    ["autoArchive", getBooleanEncoder()],
    ["reportingFrequency", getReportingFrequencyEncoder()],
    ["approvalLevels", getArrayEncoder(getApprovalLevelEncoder())],
    ["encryptionRequired", getBooleanEncoder()],
    ["backupFrequency", getBackupFrequencyEncoder()]
  ]);
}
function getAuditConfigDecoder() {
  return getStructDecoder([
    ["maxEntries", getU32Decoder()],
    ["retentionPeriod", getI64Decoder()],
    ["autoArchive", getBooleanDecoder()],
    ["reportingFrequency", getReportingFrequencyDecoder()],
    ["approvalLevels", getArrayDecoder(getApprovalLevelDecoder())],
    ["encryptionRequired", getBooleanDecoder()],
    ["backupFrequency", getBackupFrequencyDecoder()]
  ]);
}
function getAuditConfigCodec() {
  return combineCodec(getAuditConfigEncoder(), getAuditConfigDecoder());
}
function getAuditContextEncoder() {
  return getStructEncoder([
    ["transactionSignature", getOptionEncoder(getUtf8Encoder())],
    ["amount", getOptionEncoder(getU64Encoder())],
    ["token", getOptionEncoder(getAddressEncoder())],
    [
      "metadata",
      getArrayEncoder(getStructEncoder([
        ["0", getUtf8Encoder()],
        ["1", getUtf8Encoder()]
      ]))
    ],
    ["riskScore", getOptionEncoder(getU32Encoder())],
    ["location", getOptionEncoder(getUtf8Encoder())],
    ["clientInfo", getOptionEncoder(getUtf8Encoder())]
  ]);
}
function getAuditContextDecoder() {
  return getStructDecoder([
    ["transactionSignature", getOptionDecoder(getUtf8Decoder())],
    ["amount", getOptionDecoder(getU64Decoder())],
    ["token", getOptionDecoder(getAddressDecoder())],
    [
      "metadata",
      getArrayDecoder(getStructDecoder([
        ["0", getUtf8Decoder()],
        ["1", getUtf8Decoder()]
      ]))
    ],
    ["riskScore", getOptionDecoder(getU32Decoder())],
    ["location", getOptionDecoder(getUtf8Decoder())],
    ["clientInfo", getOptionDecoder(getUtf8Decoder())]
  ]);
}
function getAuditContextCodec() {
  return combineCodec(getAuditContextEncoder(), getAuditContextDecoder());
}
function getAuditEntryEncoder() {
  return getStructEncoder([
    ["entryId", getU64Encoder()],
    ["timestamp", getI64Encoder()],
    ["action", getAuditActionEncoder()],
    ["actor", getAddressEncoder()],
    ["target", getOptionEncoder(getAddressEncoder())],
    ["context", getAuditContextEncoder()],
    ["complianceFlags", getComplianceFlagsEncoder()],
    ["previousHash", fixEncoderSize(getBytesEncoder(), 32)],
    ["entryHash", fixEncoderSize(getBytesEncoder(), 32)],
    ["signature", getOptionEncoder(fixEncoderSize(getBytesEncoder(), 64))]
  ]);
}
function getAuditEntryDecoder() {
  return getStructDecoder([
    ["entryId", getU64Decoder()],
    ["timestamp", getI64Decoder()],
    ["action", getAuditActionDecoder()],
    ["actor", getAddressDecoder()],
    ["target", getOptionDecoder(getAddressDecoder())],
    ["context", getAuditContextDecoder()],
    ["complianceFlags", getComplianceFlagsDecoder()],
    ["previousHash", fixDecoderSize(getBytesDecoder(), 32)],
    ["entryHash", fixDecoderSize(getBytesDecoder(), 32)],
    ["signature", getOptionDecoder(fixDecoderSize(getBytesDecoder(), 64))]
  ]);
}
function getAuditEntryCodec() {
  return combineCodec(getAuditEntryEncoder(), getAuditEntryDecoder());
}
function getAuditTrailInitializedEventEncoder() {
  return getStructEncoder([
    ["entity", getAddressEncoder()],
    ["entityType", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["timestamp", getI64Encoder()]
  ]);
}
function getAuditTrailInitializedEventDecoder() {
  return getStructDecoder([
    ["entity", getAddressDecoder()],
    ["entityType", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["timestamp", getI64Decoder()]
  ]);
}
function getAuditTrailInitializedEventCodec() {
  return combineCodec(getAuditTrailInitializedEventEncoder(), getAuditTrailInitializedEventDecoder());
}
function getAuthenticationLevelEncoder() {
  return getEnumEncoder(AuthenticationLevel);
}
function getAuthenticationLevelDecoder() {
  return getEnumDecoder(AuthenticationLevel);
}
function getAuthenticationLevelCodec() {
  return combineCodec(getAuthenticationLevelEncoder(), getAuthenticationLevelDecoder());
}
function getAuthenticationMethodEncoder() {
  return getEnumEncoder(AuthenticationMethod);
}
function getAuthenticationMethodDecoder() {
  return getEnumDecoder(AuthenticationMethod);
}
function getAuthenticationMethodCodec() {
  return combineCodec(getAuthenticationMethodEncoder(), getAuthenticationMethodDecoder());
}
function getAuthenticationPoliciesEncoder() {
  return getStructEncoder([
    ["mfaRequired", getBooleanEncoder()],
    ["supportedMethods", getArrayEncoder(getAuthenticationMethodEncoder())],
    ["strengthRequirements", getAuthenticationStrengthEncoder()],
    ["lockoutPolicies", getAccountLockoutPoliciesEncoder()],
    ["biometricPolicies", getOptionEncoder(getBiometricPoliciesEncoder())]
  ]);
}
function getAuthenticationPoliciesDecoder() {
  return getStructDecoder([
    ["mfaRequired", getBooleanDecoder()],
    ["supportedMethods", getArrayDecoder(getAuthenticationMethodDecoder())],
    ["strengthRequirements", getAuthenticationStrengthDecoder()],
    ["lockoutPolicies", getAccountLockoutPoliciesDecoder()],
    ["biometricPolicies", getOptionDecoder(getBiometricPoliciesDecoder())]
  ]);
}
function getAuthenticationPoliciesCodec() {
  return combineCodec(getAuthenticationPoliciesEncoder(), getAuthenticationPoliciesDecoder());
}
function getAuthenticationStrengthEncoder() {
  return getStructEncoder([
    ["minimumLevel", getAuthenticationLevelEncoder()],
    ["riskBased", getBooleanEncoder()],
    ["adaptive", getBooleanEncoder()],
    ["stepUpTriggers", getArrayEncoder(getStepUpTriggerEncoder())]
  ]);
}
function getAuthenticationStrengthDecoder() {
  return getStructDecoder([
    ["minimumLevel", getAuthenticationLevelDecoder()],
    ["riskBased", getBooleanDecoder()],
    ["adaptive", getBooleanDecoder()],
    ["stepUpTriggers", getArrayDecoder(getStepUpTriggerDecoder())]
  ]);
}
function getAuthenticationStrengthCodec() {
  return combineCodec(getAuthenticationStrengthEncoder(), getAuthenticationStrengthDecoder());
}
function getAuthorizationPoliciesEncoder() {
  return getStructEncoder([
    ["defaultDeny", getBooleanEncoder()],
    ["explicitPermissionsRequired", getBooleanEncoder()]
  ]);
}
function getAuthorizationPoliciesDecoder() {
  return getStructDecoder([
    ["defaultDeny", getBooleanDecoder()],
    ["explicitPermissionsRequired", getBooleanDecoder()]
  ]);
}
function getAuthorizationPoliciesCodec() {
  return combineCodec(getAuthorizationPoliciesEncoder(), getAuthorizationPoliciesDecoder());
}
function getBackupFrequencyEncoder() {
  return getEnumEncoder(BackupFrequency);
}
function getBackupFrequencyDecoder() {
  return getEnumDecoder(BackupFrequency);
}
function getBackupFrequencyCodec() {
  return combineCodec(getBackupFrequencyEncoder(), getBackupFrequencyDecoder());
}
function getBiometricPoliciesEncoder() {
  return getStructEncoder([
    ["supportedTypes", getArrayEncoder(getBiometricTypeEncoder())],
    ["qualityRequirements", getBiometricQualityEncoder()],
    ["livenessDetection", getBooleanEncoder()],
    ["templateProtection", getBiometricProtectionEncoder()]
  ]);
}
function getBiometricPoliciesDecoder() {
  return getStructDecoder([
    ["supportedTypes", getArrayDecoder(getBiometricTypeDecoder())],
    ["qualityRequirements", getBiometricQualityDecoder()],
    ["livenessDetection", getBooleanDecoder()],
    ["templateProtection", getBiometricProtectionDecoder()]
  ]);
}
function getBiometricPoliciesCodec() {
  return combineCodec(getBiometricPoliciesEncoder(), getBiometricPoliciesDecoder());
}
function getBiometricProtectionEncoder() {
  return getStructEncoder([
    ["encryptionRequired", getBooleanEncoder()],
    ["storageMethod", getBiometricStorageMethodEncoder()],
    ["revocationSupport", getBooleanEncoder()],
    ["agingPolicies", getArrayEncoder(getAgingPolicyEncoder())]
  ]);
}
function getBiometricProtectionDecoder() {
  return getStructDecoder([
    ["encryptionRequired", getBooleanDecoder()],
    ["storageMethod", getBiometricStorageMethodDecoder()],
    ["revocationSupport", getBooleanDecoder()],
    ["agingPolicies", getArrayDecoder(getAgingPolicyDecoder())]
  ]);
}
function getBiometricProtectionCodec() {
  return combineCodec(getBiometricProtectionEncoder(), getBiometricProtectionDecoder());
}
function getBiometricStorageMethodEncoder() {
  return getEnumEncoder(BiometricStorageMethod);
}
function getBiometricStorageMethodDecoder() {
  return getEnumDecoder(BiometricStorageMethod);
}
function getBiometricStorageMethodCodec() {
  return combineCodec(getBiometricStorageMethodEncoder(), getBiometricStorageMethodDecoder());
}
function getBiometricTypeEncoder() {
  return getEnumEncoder(BiometricType);
}
function getBiometricTypeDecoder() {
  return getEnumDecoder(BiometricType);
}
function getBiometricTypeCodec() {
  return combineCodec(getBiometricTypeEncoder(), getBiometricTypeDecoder());
}
function getBiometricQualityEncoder() {
  return getStructEncoder([
    ["minimumQuality", getU8Encoder()],
    ["assessmentMethod", getUtf8Encoder()],
    ["multipleSamples", getBooleanEncoder()],
    [
      "qualityThresholds",
      getArrayEncoder(getStructEncoder([
        ["0", getUtf8Encoder()],
        ["1", getU8Encoder()]
      ]))
    ]
  ]);
}
function getBiometricQualityDecoder() {
  return getStructDecoder([
    ["minimumQuality", getU8Decoder()],
    ["assessmentMethod", getUtf8Decoder()],
    ["multipleSamples", getBooleanDecoder()],
    [
      "qualityThresholds",
      getArrayDecoder(getStructDecoder([
        ["0", getUtf8Decoder()],
        ["1", getU8Decoder()]
      ]))
    ]
  ]);
}
function getBiometricQualityCodec() {
  return combineCodec(getBiometricQualityEncoder(), getBiometricQualityDecoder());
}
function getComplianceFlagsEncoder() {
  return getStructEncoder([
    ["requiresReporting", getBooleanEncoder()],
    ["highRisk", getBooleanEncoder()],
    ["sensitiveData", getBooleanEncoder()],
    ["crossBorder", getBooleanEncoder()],
    ["largeAmount", getBooleanEncoder()],
    ["suspicious", getBooleanEncoder()],
    ["manualReview", getBooleanEncoder()],
    [
      "jurisdiction",
      getOptionEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ]
  ]);
}
function getComplianceFlagsDecoder() {
  return getStructDecoder([
    ["requiresReporting", getBooleanDecoder()],
    ["highRisk", getBooleanDecoder()],
    ["sensitiveData", getBooleanDecoder()],
    ["crossBorder", getBooleanDecoder()],
    ["largeAmount", getBooleanDecoder()],
    ["suspicious", getBooleanDecoder()],
    ["manualReview", getBooleanDecoder()],
    [
      "jurisdiction",
      getOptionDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ]
  ]);
}
function getComplianceFlagsCodec() {
  return combineCodec(getComplianceFlagsEncoder(), getComplianceFlagsDecoder());
}
function getComplianceMetricsEncoder() {
  return getStructEncoder([
    ["complianceScore", getU8Encoder()],
    ["policyAdherenceRate", getU8Encoder()],
    ["avgIncidentResponseTime", getU64Encoder()],
    ["falsePositiveRate", getU8Encoder()],
    ["coveragePercentage", getU8Encoder()],
    ["auditReadinessScore", getU8Encoder()]
  ]);
}
function getComplianceMetricsDecoder() {
  return getStructDecoder([
    ["complianceScore", getU8Decoder()],
    ["policyAdherenceRate", getU8Decoder()],
    ["avgIncidentResponseTime", getU64Decoder()],
    ["falsePositiveRate", getU8Decoder()],
    ["coveragePercentage", getU8Decoder()],
    ["auditReadinessScore", getU8Decoder()]
  ]);
}
function getComplianceMetricsCodec() {
  return combineCodec(getComplianceMetricsEncoder(), getComplianceMetricsDecoder());
}
function getCompliancePoliciesEncoder() {
  return getStructEncoder([
    [
      "frameworks",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    [
      "auditRequirements",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    [
      "reportingRequirements",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ]
  ]);
}
function getCompliancePoliciesDecoder() {
  return getStructDecoder([
    [
      "frameworks",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    [
      "auditRequirements",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    [
      "reportingRequirements",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ]
  ]);
}
function getCompliancePoliciesCodec() {
  return combineCodec(getCompliancePoliciesEncoder(), getCompliancePoliciesDecoder());
}
function getComplianceStatusEncoder() {
  return getStructEncoder([
    ["complianceScore", getU8Encoder()],
    ["lastReview", getI64Encoder()],
    ["nextReview", getI64Encoder()],
    ["complianceOfficers", getArrayEncoder(getAddressEncoder())]
  ]);
}
function getComplianceStatusDecoder() {
  return getStructDecoder([
    ["complianceScore", getU8Decoder()],
    ["lastReview", getI64Decoder()],
    ["nextReview", getI64Decoder()],
    ["complianceOfficers", getArrayDecoder(getAddressDecoder())]
  ]);
}
function getComplianceStatusCodec() {
  return combineCodec(getComplianceStatusEncoder(), getComplianceStatusDecoder());
}
function getComplianceReportGeneratedEventEncoder() {
  return getStructEncoder([
    ["report", getAddressEncoder()],
    ["reportId", getU64Encoder()],
    ["reportType", getReportTypeEncoder()],
    ["complianceRate", getU64Encoder()]
  ]);
}
function getComplianceReportGeneratedEventDecoder() {
  return getStructDecoder([
    ["report", getAddressDecoder()],
    ["reportId", getU64Decoder()],
    ["reportType", getReportTypeDecoder()],
    ["complianceRate", getU64Decoder()]
  ]);
}
function getComplianceReportGeneratedEventCodec() {
  return combineCodec(getComplianceReportGeneratedEventEncoder(), getComplianceReportGeneratedEventDecoder());
}
function getCompressedAgentCreatedEventEncoder() {
  return getStructEncoder([
    ["agentId", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["owner", getAddressEncoder()],
    ["treeAuthority", getAddressEncoder()],
    ["merkleTree", getAddressEncoder()],
    ["dataHash", fixEncoderSize(getBytesEncoder(), 32)],
    ["index", getU64Encoder()],
    ["metadataUri", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["createdAt", getI64Encoder()]
  ]);
}
function getCompressedAgentCreatedEventDecoder() {
  return getStructDecoder([
    ["agentId", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["owner", getAddressDecoder()],
    ["treeAuthority", getAddressDecoder()],
    ["merkleTree", getAddressDecoder()],
    ["dataHash", fixDecoderSize(getBytesDecoder(), 32)],
    ["index", getU64Decoder()],
    ["metadataUri", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["createdAt", getI64Decoder()]
  ]);
}
function getCompressedAgentCreatedEventCodec() {
  return combineCodec(getCompressedAgentCreatedEventEncoder(), getCompressedAgentCreatedEventDecoder());
}
function getConditionTypeEncoder() {
  return getEnumEncoder(ConditionType);
}
function getConditionTypeDecoder() {
  return getEnumDecoder(ConditionType);
}
function getConditionTypeCodec() {
  return combineCodec(getConditionTypeEncoder(), getConditionTypeDecoder());
}
function getConstraintConditionEncoder() {
  return getStructEncoder([
    ["attribute", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["operator", getConstraintOperatorEncoder()],
    ["value", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["valueType", getValueTypeEncoder()]
  ]);
}
function getConstraintConditionDecoder() {
  return getStructDecoder([
    ["attribute", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["operator", getConstraintOperatorDecoder()],
    ["value", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["valueType", getValueTypeDecoder()]
  ]);
}
function getConstraintConditionCodec() {
  return combineCodec(getConstraintConditionEncoder(), getConstraintConditionDecoder());
}
function getConstraintOperatorEncoder() {
  return getEnumEncoder(ConstraintOperator);
}
function getConstraintOperatorDecoder() {
  return getEnumDecoder(ConstraintOperator);
}
function getConstraintOperatorCodec() {
  return combineCodec(getConstraintOperatorEncoder(), getConstraintOperatorDecoder());
}
function getCredentialKindEncoder() {
  return getEnumEncoder(CredentialKind);
}
function getCredentialKindDecoder() {
  return getEnumDecoder(CredentialKind);
}
function getCredentialKindCodec() {
  return combineCodec(getCredentialKindEncoder(), getCredentialKindDecoder());
}
function getCredentialStatusEncoder() {
  return getEnumEncoder(CredentialStatus);
}
function getCredentialStatusDecoder() {
  return getEnumDecoder(CredentialStatus);
}
function getCredentialStatusCodec() {
  return combineCodec(getCredentialStatusEncoder(), getCredentialStatusDecoder());
}
function getCrossChainStatusEncoder() {
  return getEnumEncoder(CrossChainStatus);
}
function getCrossChainStatusDecoder() {
  return getEnumDecoder(CrossChainStatus);
}
function getCrossChainStatusCodec() {
  return combineCodec(getCrossChainStatusEncoder(), getCrossChainStatusDecoder());
}
function getDataAccessLevelEncoder() {
  return getEnumEncoder(DataAccessLevel);
}
function getDataAccessLevelDecoder() {
  return getEnumDecoder(DataAccessLevel);
}
function getDataAccessLevelCodec() {
  return combineCodec(getDataAccessLevelEncoder(), getDataAccessLevelDecoder());
}
function getDataProtectionPoliciesEncoder() {
  return getStructEncoder([
    ["encryptionRequired", getBooleanEncoder()],
    ["classificationRequired", getBooleanEncoder()],
    ["dlpEnabled", getBooleanEncoder()]
  ]);
}
function getDataProtectionPoliciesDecoder() {
  return getStructDecoder([
    ["encryptionRequired", getBooleanDecoder()],
    ["classificationRequired", getBooleanDecoder()],
    ["dlpEnabled", getBooleanDecoder()]
  ]);
}
function getDataProtectionPoliciesCodec() {
  return combineCodec(getDataProtectionPoliciesEncoder(), getDataProtectionPoliciesDecoder());
}
function getDegradationHandlingEncoder() {
  return getEnumEncoder(DegradationHandling);
}
function getDegradationHandlingDecoder() {
  return getEnumDecoder(DegradationHandling);
}
function getDegradationHandlingCodec() {
  return combineCodec(getDegradationHandlingEncoder(), getDegradationHandlingDecoder());
}
function getDelegationInfoEncoder() {
  return getStructEncoder([
    ["delegator", getAddressEncoder()],
    ["delegatedAt", getI64Encoder()],
    ["scope", getDelegationScopeEncoder()],
    ["expiresAt", getOptionEncoder(getI64Encoder())]
  ]);
}
function getDelegationInfoDecoder() {
  return getStructDecoder([
    ["delegator", getAddressDecoder()],
    ["delegatedAt", getI64Decoder()],
    ["scope", getDelegationScopeDecoder()],
    ["expiresAt", getOptionDecoder(getI64Decoder())]
  ]);
}
function getDelegationInfoCodec() {
  return combineCodec(getDelegationInfoEncoder(), getDelegationInfoDecoder());
}
function getDelegationScopeEncoder() {
  return getDiscriminatedUnionEncoder([
    ["All", getUnitEncoder()],
    [
      "ProposalType",
      getStructEncoder([
        ["fields", getTupleEncoder([getProposalTypeEncoder()])]
      ])
    ],
    ["SingleProposal", getUnitEncoder()],
    ["Limited", getUnitEncoder()]
  ]);
}
function getDelegationScopeDecoder() {
  return getDiscriminatedUnionDecoder([
    ["All", getUnitDecoder()],
    [
      "ProposalType",
      getStructDecoder([
        ["fields", getTupleDecoder([getProposalTypeDecoder()])]
      ])
    ],
    ["SingleProposal", getUnitDecoder()],
    ["Limited", getUnitDecoder()]
  ]);
}
function getDelegationScopeCodec() {
  return combineCodec(getDelegationScopeEncoder(), getDelegationScopeDecoder());
}
function delegationScope(kind, data2) {
  return Array.isArray(data2) ? { __kind: kind, fields: data2 } : { __kind: kind, ...data2 ?? {} };
}
function isDelegationScope(kind, value) {
  return value.__kind === kind;
}
function getDeliverySubmittedEventEncoder() {
  return getStructEncoder([
    ["escrowId", getU64Encoder()],
    ["agent", getAddressEncoder()],
    ["deliveryProof", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())]
  ]);
}
function getDeliverySubmittedEventDecoder() {
  return getStructDecoder([
    ["escrowId", getU64Decoder()],
    ["agent", getAddressDecoder()],
    ["deliveryProof", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())]
  ]);
}
function getDeliverySubmittedEventCodec() {
  return combineCodec(getDeliverySubmittedEventEncoder(), getDeliverySubmittedEventDecoder());
}
function getDisputeFiledEventEncoder() {
  return getStructEncoder([
    ["escrowId", getU64Encoder()],
    ["client", getAddressEncoder()],
    ["reason", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())]
  ]);
}
function getDisputeFiledEventDecoder() {
  return getStructDecoder([
    ["escrowId", getU64Decoder()],
    ["client", getAddressDecoder()],
    ["reason", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())]
  ]);
}
function getDisputeFiledEventCodec() {
  return combineCodec(getDisputeFiledEventEncoder(), getDisputeFiledEventDecoder());
}
function getDisputeResolvedEventEncoder() {
  return getStructEncoder([
    ["escrowId", getU64Encoder()],
    ["decision", getArbitratorDecisionEncoder()],
    ["arbitrator", getAddressEncoder()]
  ]);
}
function getDisputeResolvedEventDecoder() {
  return getStructDecoder([
    ["escrowId", getU64Decoder()],
    ["decision", getArbitratorDecisionDecoder()],
    ["arbitrator", getAddressDecoder()]
  ]);
}
function getDisputeResolvedEventCodec() {
  return combineCodec(getDisputeResolvedEventEncoder(), getDisputeResolvedEventDecoder());
}
function getEmergencyAccessConfigEncoder() {
  return getStructEncoder([
    ["breakGlassEnabled", getBooleanEncoder()],
    ["emergencyContacts", getArrayEncoder(getAddressEncoder())],
    ["approvalRequired", getBooleanEncoder()]
  ]);
}
function getEmergencyAccessConfigDecoder() {
  return getStructDecoder([
    ["breakGlassEnabled", getBooleanDecoder()],
    ["emergencyContacts", getArrayDecoder(getAddressDecoder())],
    ["approvalRequired", getBooleanDecoder()]
  ]);
}
function getEmergencyAccessConfigCodec() {
  return combineCodec(getEmergencyAccessConfigEncoder(), getEmergencyAccessConfigDecoder());
}
function getEmergencyConfigEncoder() {
  return getStructEncoder([
    ["emergencyContacts", getArrayEncoder(getAddressEncoder())],
    ["emergencyThreshold", getU8Encoder()],
    ["emergencyTimeout", getI64Encoder()],
    ["emergencyTransactionTypes", getArrayEncoder(getTransactionTypeEncoder())],
    ["freezeEnabled", getBooleanEncoder()],
    ["frozen", getBooleanEncoder()],
    ["frozenAt", getOptionEncoder(getI64Encoder())],
    ["autoUnfreezeDuration", getOptionEncoder(getI64Encoder())]
  ]);
}
function getEmergencyConfigDecoder() {
  return getStructDecoder([
    ["emergencyContacts", getArrayDecoder(getAddressDecoder())],
    ["emergencyThreshold", getU8Decoder()],
    ["emergencyTimeout", getI64Decoder()],
    ["emergencyTransactionTypes", getArrayDecoder(getTransactionTypeDecoder())],
    ["freezeEnabled", getBooleanDecoder()],
    ["frozen", getBooleanDecoder()],
    ["frozenAt", getOptionDecoder(getI64Decoder())],
    ["autoUnfreezeDuration", getOptionDecoder(getI64Decoder())]
  ]);
}
function getEmergencyConfigCodec() {
  return combineCodec(getEmergencyConfigEncoder(), getEmergencyConfigDecoder());
}
function getEnforcementLevelEncoder() {
  return getEnumEncoder(EnforcementLevel);
}
function getEnforcementLevelDecoder() {
  return getEnumDecoder(EnforcementLevel);
}
function getEnforcementLevelCodec() {
  return combineCodec(getEnforcementLevelEncoder(), getEnforcementLevelDecoder());
}
function getEscrowCompletedEventEncoder() {
  return getStructEncoder([
    ["escrowId", getU64Encoder()],
    ["agent", getAddressEncoder()],
    ["amount", getU64Encoder()]
  ]);
}
function getEscrowCompletedEventDecoder() {
  return getStructDecoder([
    ["escrowId", getU64Decoder()],
    ["agent", getAddressDecoder()],
    ["amount", getU64Decoder()]
  ]);
}
function getEscrowCompletedEventCodec() {
  return combineCodec(getEscrowCompletedEventEncoder(), getEscrowCompletedEventDecoder());
}
function getEscrowCreatedEventEncoder() {
  return getStructEncoder([
    ["escrowId", getU64Encoder()],
    ["client", getAddressEncoder()],
    ["agent", getAddressEncoder()],
    ["amount", getU64Encoder()],
    ["deadline", getI64Encoder()]
  ]);
}
function getEscrowCreatedEventDecoder() {
  return getStructDecoder([
    ["escrowId", getU64Decoder()],
    ["client", getAddressDecoder()],
    ["agent", getAddressDecoder()],
    ["amount", getU64Decoder()],
    ["deadline", getI64Decoder()]
  ]);
}
function getEscrowCreatedEventCodec() {
  return combineCodec(getEscrowCreatedEventEncoder(), getEscrowCreatedEventDecoder());
}
function getEscrowStatusEncoder() {
  return getEnumEncoder(EscrowStatus);
}
function getEscrowStatusDecoder() {
  return getEnumDecoder(EscrowStatus);
}
function getEscrowStatusCodec() {
  return combineCodec(getEscrowStatusEncoder(), getEscrowStatusDecoder());
}
function getExecutionConditionEncoder() {
  return getStructEncoder([
    ["conditionType", getConditionTypeEncoder()],
    ["targetValue", getU64Encoder()],
    ["currentValue", getU64Encoder()],
    ["met", getBooleanEncoder()],
    ["description", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())]
  ]);
}
function getExecutionConditionDecoder() {
  return getStructDecoder([
    ["conditionType", getConditionTypeDecoder()],
    ["targetValue", getU64Decoder()],
    ["currentValue", getU64Decoder()],
    ["met", getBooleanDecoder()],
    ["description", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())]
  ]);
}
function getExecutionConditionCodec() {
  return combineCodec(getExecutionConditionEncoder(), getExecutionConditionDecoder());
}
function getExecutionParamsEncoder() {
  return getStructEncoder([
    ["instructions", getArrayEncoder(getProposalInstructionEncoder())],
    ["executionDelay", getI64Encoder()],
    ["executionConditions", getArrayEncoder(getExecutionConditionEncoder())],
    ["cancellable", getBooleanEncoder()],
    ["autoExecute", getBooleanEncoder()],
    ["executionAuthority", getAddressEncoder()]
  ]);
}
function getExecutionParamsDecoder() {
  return getStructDecoder([
    ["instructions", getArrayDecoder(getProposalInstructionDecoder())],
    ["executionDelay", getI64Decoder()],
    ["executionConditions", getArrayDecoder(getExecutionConditionDecoder())],
    ["cancellable", getBooleanDecoder()],
    ["autoExecute", getBooleanDecoder()],
    ["executionAuthority", getAddressDecoder()]
  ]);
}
function getExecutionParamsCodec() {
  return combineCodec(getExecutionParamsEncoder(), getExecutionParamsDecoder());
}
function getGeographicRegionEncoder() {
  return getStructEncoder([
    ["name", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["latitudeRange", getLatitudeRangeEncoder()],
    ["longitudeRange", getLongitudeRangeEncoder()],
    ["radius", getOptionEncoder(getU32Encoder())]
  ]);
}
function getGeographicRegionDecoder() {
  return getStructDecoder([
    ["name", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["latitudeRange", getLatitudeRangeDecoder()],
    ["longitudeRange", getLongitudeRangeDecoder()],
    ["radius", getOptionDecoder(getU32Decoder())]
  ]);
}
function getGeographicRegionCodec() {
  return combineCodec(getGeographicRegionEncoder(), getGeographicRegionDecoder());
}
function getGhostSlashedEventEncoder() {
  return getStructEncoder([
    ["agent", getAddressEncoder()],
    ["amount", getU64Encoder()],
    ["reason", getSlashReasonEncoder()],
    ["newTier", getAccessTierEncoder()]
  ]);
}
function getGhostSlashedEventDecoder() {
  return getStructDecoder([
    ["agent", getAddressDecoder()],
    ["amount", getU64Decoder()],
    ["reason", getSlashReasonDecoder()],
    ["newTier", getAccessTierDecoder()]
  ]);
}
function getGhostSlashedEventCodec() {
  return combineCodec(getGhostSlashedEventEncoder(), getGhostSlashedEventDecoder());
}
function getGhostStakedEventEncoder() {
  return getStructEncoder([
    ["agent", getAddressEncoder()],
    ["amount", getU64Encoder()],
    ["unlockAt", getI64Encoder()],
    ["reputationBoostBps", getU16Encoder()],
    ["tier", getAccessTierEncoder()],
    ["dailyApiCalls", getU32Encoder()],
    ["votingPower", getU64Encoder()]
  ]);
}
function getGhostStakedEventDecoder() {
  return getStructDecoder([
    ["agent", getAddressDecoder()],
    ["amount", getU64Decoder()],
    ["unlockAt", getI64Decoder()],
    ["reputationBoostBps", getU16Decoder()],
    ["tier", getAccessTierDecoder()],
    ["dailyApiCalls", getU32Decoder()],
    ["votingPower", getU64Decoder()]
  ]);
}
function getGhostStakedEventCodec() {
  return combineCodec(getGhostStakedEventEncoder(), getGhostStakedEventDecoder());
}
function getGhostUnstakedEventEncoder() {
  return getStructEncoder([
    ["agent", getAddressEncoder()],
    ["amount", getU64Encoder()]
  ]);
}
function getGhostUnstakedEventDecoder() {
  return getStructDecoder([
    ["agent", getAddressDecoder()],
    ["amount", getU64Decoder()]
  ]);
}
function getGhostUnstakedEventCodec() {
  return combineCodec(getGhostUnstakedEventEncoder(), getGhostUnstakedEventDecoder());
}
function getGovernanceProposalCreatedEventEncoder() {
  return getStructEncoder([
    ["proposal", getAddressEncoder()],
    ["proposalId", getU64Encoder()],
    ["proposer", getAddressEncoder()],
    ["title", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())]
  ]);
}
function getGovernanceProposalCreatedEventDecoder() {
  return getStructDecoder([
    ["proposal", getAddressDecoder()],
    ["proposalId", getU64Decoder()],
    ["proposer", getAddressDecoder()],
    ["title", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())]
  ]);
}
function getGovernanceProposalCreatedEventCodec() {
  return combineCodec(getGovernanceProposalCreatedEventEncoder(), getGovernanceProposalCreatedEventDecoder());
}
function getHierarchicalBoundaryEncoder() {
  return getStructEncoder([
    ["level", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["value", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["includeDescendants", getBooleanEncoder()]
  ]);
}
function getHierarchicalBoundaryDecoder() {
  return getStructDecoder([
    ["level", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["value", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["includeDescendants", getBooleanDecoder()]
  ]);
}
function getHierarchicalBoundaryCodec() {
  return combineCodec(getHierarchicalBoundaryEncoder(), getHierarchicalBoundaryDecoder());
}
function getIncidentResponsePoliciesEncoder() {
  return getStructEncoder([
    ["responseTeam", getArrayEncoder(getAddressEncoder())],
    [
      "escalationProcedures",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    [
      "notificationRequirements",
      getArrayEncoder(getNotificationRequirementEncoder())
    ]
  ]);
}
function getIncidentResponsePoliciesDecoder() {
  return getStructDecoder([
    ["responseTeam", getArrayDecoder(getAddressDecoder())],
    [
      "escalationProcedures",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    [
      "notificationRequirements",
      getArrayDecoder(getNotificationRequirementDecoder())
    ]
  ]);
}
function getIncidentResponsePoliciesCodec() {
  return combineCodec(getIncidentResponsePoliciesEncoder(), getIncidentResponsePoliciesDecoder());
}
function getLatitudeRangeEncoder() {
  return getStructEncoder([
    ["min", getF64Encoder()],
    ["max", getF64Encoder()]
  ]);
}
function getLatitudeRangeDecoder() {
  return getStructDecoder([
    ["min", getF64Decoder()],
    ["max", getF64Decoder()]
  ]);
}
function getLatitudeRangeCodec() {
  return combineCodec(getLatitudeRangeEncoder(), getLatitudeRangeDecoder());
}
function getLocationConstraintsEncoder() {
  return getStructEncoder([
    [
      "allowedCountries",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    [
      "blockedCountries",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    [
      "allowedIpRanges",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    [
      "blockedIpRanges",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    ["geofencingEnabled", getBooleanEncoder()],
    ["allowedRegions", getArrayEncoder(getGeographicRegionEncoder())]
  ]);
}
function getLocationConstraintsDecoder() {
  return getStructDecoder([
    [
      "allowedCountries",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    [
      "blockedCountries",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    [
      "allowedIpRanges",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    [
      "blockedIpRanges",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    ["geofencingEnabled", getBooleanDecoder()],
    ["allowedRegions", getArrayDecoder(getGeographicRegionDecoder())]
  ]);
}
function getLocationConstraintsCodec() {
  return combineCodec(getLocationConstraintsEncoder(), getLocationConstraintsDecoder());
}
function getLongitudeRangeEncoder() {
  return getStructEncoder([
    ["min", getF64Encoder()],
    ["max", getF64Encoder()]
  ]);
}
function getLongitudeRangeDecoder() {
  return getStructDecoder([
    ["min", getF64Decoder()],
    ["max", getF64Decoder()]
  ]);
}
function getLongitudeRangeCodec() {
  return combineCodec(getLongitudeRangeEncoder(), getLongitudeRangeDecoder());
}
function getMultisigCreatedEventEncoder() {
  return getStructEncoder([
    ["multisigId", getU64Encoder()],
    ["multisigType", getMultisigTypeEncoder()],
    ["owner", getAddressEncoder()],
    ["threshold", getU8Encoder()],
    ["signerCount", getU8Encoder()],
    ["timestamp", getI64Encoder()]
  ]);
}
function getMultisigCreatedEventDecoder() {
  return getStructDecoder([
    ["multisigId", getU64Decoder()],
    ["multisigType", getMultisigTypeDecoder()],
    ["owner", getAddressDecoder()],
    ["threshold", getU8Decoder()],
    ["signerCount", getU8Decoder()],
    ["timestamp", getI64Decoder()]
  ]);
}
function getMultisigCreatedEventCodec() {
  return combineCodec(getMultisigCreatedEventEncoder(), getMultisigCreatedEventDecoder());
}
function getMultisigSignatureEncoder() {
  return getStructEncoder([
    ["signer", getAddressEncoder()],
    ["signature", fixEncoderSize(getBytesEncoder(), 64)],
    ["signedAt", getI64Encoder()],
    [
      "signatureMethod",
      addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())
    ],
    [
      "verificationData",
      getOptionEncoder(addEncoderSizePrefix(getBytesEncoder(), getU32Encoder()))
    ]
  ]);
}
function getMultisigSignatureDecoder() {
  return getStructDecoder([
    ["signer", getAddressDecoder()],
    ["signature", fixDecoderSize(getBytesDecoder(), 64)],
    ["signedAt", getI64Decoder()],
    [
      "signatureMethod",
      addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())
    ],
    [
      "verificationData",
      getOptionDecoder(addDecoderSizePrefix(getBytesDecoder(), getU32Decoder()))
    ]
  ]);
}
function getMultisigSignatureCodec() {
  return combineCodec(getMultisigSignatureEncoder(), getMultisigSignatureDecoder());
}
function getMultisigTypeEncoder() {
  return getEnumEncoder(MultisigType);
}
function getMultisigTypeDecoder() {
  return getEnumDecoder(MultisigType);
}
function getMultisigTypeCodec() {
  return combineCodec(getMultisigTypeEncoder(), getMultisigTypeDecoder());
}
function getMultisigTypeConfigEncoder() {
  return getStructEncoder([
    ["multisigType", getMultisigTypeEncoder()],
    ["timelockSeconds", getI64Encoder()],
    ["minSigners", getU8Encoder()],
    ["maxSigners", getU8Encoder()],
    ["minReputationScore", getU16Encoder()],
    ["requiresTokenHoldings", getBooleanEncoder()],
    ["minTokenBalance", getU64Encoder()]
  ]);
}
function getMultisigTypeConfigDecoder() {
  return getStructDecoder([
    ["multisigType", getMultisigTypeDecoder()],
    ["timelockSeconds", getI64Decoder()],
    ["minSigners", getU8Decoder()],
    ["maxSigners", getU8Decoder()],
    ["minReputationScore", getU16Decoder()],
    ["requiresTokenHoldings", getBooleanDecoder()],
    ["minTokenBalance", getU64Decoder()]
  ]);
}
function getMultisigTypeConfigCodec() {
  return combineCodec(getMultisigTypeConfigEncoder(), getMultisigTypeConfigDecoder());
}
function getMultisigConfigEncoder() {
  return getStructEncoder([
    ["maxSigners", getU8Encoder()],
    ["defaultTimeout", getI64Encoder()],
    ["allowEmergencyOverride", getBooleanEncoder()],
    ["emergencyThreshold", getOptionEncoder(getU8Encoder())],
    ["autoExecute", getBooleanEncoder()],
    ["signerChangeThreshold", getU8Encoder()],
    ["allowedTransactionTypes", getArrayEncoder(getTransactionTypeEncoder())]
  ]);
}
function getMultisigConfigDecoder() {
  return getStructDecoder([
    ["maxSigners", getU8Decoder()],
    ["defaultTimeout", getI64Decoder()],
    ["allowEmergencyOverride", getBooleanDecoder()],
    ["emergencyThreshold", getOptionDecoder(getU8Decoder())],
    ["autoExecute", getBooleanDecoder()],
    ["signerChangeThreshold", getU8Decoder()],
    ["allowedTransactionTypes", getArrayDecoder(getTransactionTypeDecoder())]
  ]);
}
function getMultisigConfigCodec() {
  return combineCodec(getMultisigConfigEncoder(), getMultisigConfigDecoder());
}
function getNetworkSecurityPoliciesEncoder() {
  return getStructEncoder([
    ["firewallRequired", getBooleanEncoder()],
    ["intrusionDetection", getBooleanEncoder()],
    ["trafficMonitoring", getBooleanEncoder()]
  ]);
}
function getNetworkSecurityPoliciesDecoder() {
  return getStructDecoder([
    ["firewallRequired", getBooleanDecoder()],
    ["intrusionDetection", getBooleanDecoder()],
    ["trafficMonitoring", getBooleanDecoder()]
  ]);
}
function getNetworkSecurityPoliciesCodec() {
  return combineCodec(getNetworkSecurityPoliciesEncoder(), getNetworkSecurityPoliciesDecoder());
}
function getNotificationMethodEncoder() {
  return getEnumEncoder(NotificationMethod);
}
function getNotificationMethodDecoder() {
  return getEnumDecoder(NotificationMethod);
}
function getNotificationMethodCodec() {
  return combineCodec(getNotificationMethodEncoder(), getNotificationMethodDecoder());
}
function getNotificationPriorityEncoder() {
  return getEnumEncoder(NotificationPriority);
}
function getNotificationPriorityDecoder() {
  return getEnumDecoder(NotificationPriority);
}
function getNotificationPriorityCodec() {
  return combineCodec(getNotificationPriorityEncoder(), getNotificationPriorityDecoder());
}
function getNotificationRequirementEncoder() {
  return getStructEncoder([
    ["eventType", getSecurityEventTypeEncoder()],
    ["targets", getArrayEncoder(getNotificationTargetEncoder())],
    ["method", getNotificationMethodEncoder()],
    ["timing", getNotificationTimingEncoder()]
  ]);
}
function getNotificationRequirementDecoder() {
  return getStructDecoder([
    ["eventType", getSecurityEventTypeDecoder()],
    ["targets", getArrayDecoder(getNotificationTargetDecoder())],
    ["method", getNotificationMethodDecoder()],
    ["timing", getNotificationTimingDecoder()]
  ]);
}
function getNotificationRequirementCodec() {
  return combineCodec(getNotificationRequirementEncoder(), getNotificationRequirementDecoder());
}
function getNotificationTargetEncoder() {
  return getStructEncoder([
    ["targetType", getNotificationTargetTypeEncoder()],
    ["targetId", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["priority", getNotificationPriorityEncoder()]
  ]);
}
function getNotificationTargetDecoder() {
  return getStructDecoder([
    ["targetType", getNotificationTargetTypeDecoder()],
    ["targetId", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["priority", getNotificationPriorityDecoder()]
  ]);
}
function getNotificationTargetCodec() {
  return combineCodec(getNotificationTargetEncoder(), getNotificationTargetDecoder());
}
function getNotificationTargetTypeEncoder() {
  return getEnumEncoder(NotificationTargetType);
}
function getNotificationTargetTypeDecoder() {
  return getEnumDecoder(NotificationTargetType);
}
function getNotificationTargetTypeCodec() {
  return combineCodec(getNotificationTargetTypeEncoder(), getNotificationTargetTypeDecoder());
}
function getNotificationTimingEncoder() {
  return getEnumEncoder(NotificationTiming);
}
function getNotificationTimingDecoder() {
  return getEnumDecoder(NotificationTiming);
}
function getNotificationTimingCodec() {
  return combineCodec(getNotificationTimingEncoder(), getNotificationTimingDecoder());
}
function getPasswordPoliciesEncoder() {
  return getStructEncoder([
    ["minimumLength", getU8Encoder()],
    [
      "complexityRequirements",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    ["historyCount", getU8Encoder()],
    ["maxAge", getI64Encoder()]
  ]);
}
function getPasswordPoliciesDecoder() {
  return getStructDecoder([
    ["minimumLength", getU8Decoder()],
    [
      "complexityRequirements",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    ["historyCount", getU8Decoder()],
    ["maxAge", getI64Decoder()]
  ]);
}
function getPasswordPoliciesCodec() {
  return combineCodec(getPasswordPoliciesEncoder(), getPasswordPoliciesDecoder());
}
function getPendingTransactionEncoder() {
  return getStructEncoder([
    ["transactionId", getU64Encoder()],
    ["transactionType", getTransactionTypeEncoder()],
    ["target", getAddressEncoder()],
    ["data", addEncoderSizePrefix(getBytesEncoder(), getU32Encoder())],
    ["requiredSignatures", getU8Encoder()],
    ["signatures", getArrayEncoder(getMultisigSignatureEncoder())],
    ["createdAt", getI64Encoder()],
    ["expiresAt", getI64Encoder()],
    ["priority", getTransactionPriorityEncoder()],
    ["executionConditions", getArrayEncoder(getExecutionConditionEncoder())],
    ["status", getTransactionStatusEncoder()],
    ["timeLock", getOptionEncoder(getTimeLockEncoder())]
  ]);
}
function getPendingTransactionDecoder() {
  return getStructDecoder([
    ["transactionId", getU64Decoder()],
    ["transactionType", getTransactionTypeDecoder()],
    ["target", getAddressDecoder()],
    ["data", addDecoderSizePrefix(getBytesDecoder(), getU32Decoder())],
    ["requiredSignatures", getU8Decoder()],
    ["signatures", getArrayDecoder(getMultisigSignatureDecoder())],
    ["createdAt", getI64Decoder()],
    ["expiresAt", getI64Decoder()],
    ["priority", getTransactionPriorityDecoder()],
    ["executionConditions", getArrayDecoder(getExecutionConditionDecoder())],
    ["status", getTransactionStatusDecoder()],
    ["timeLock", getOptionDecoder(getTimeLockDecoder())]
  ]);
}
function getPendingTransactionCodec() {
  return combineCodec(getPendingTransactionEncoder(), getPendingTransactionDecoder());
}
function getPermissionEncoder() {
  return getStructEncoder([
    ["permissionId", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["name", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["description", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["resourceType", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["actions", getArrayEncoder(getActionEncoder())],
    ["scope", getPermissionScopeEncoder()],
    ["constraints", getArrayEncoder(getPermissionConstraintEncoder())],
    ["metadata", getPermissionMetadataEncoder()]
  ]);
}
function getPermissionDecoder() {
  return getStructDecoder([
    ["permissionId", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["name", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["description", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["resourceType", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["actions", getArrayDecoder(getActionDecoder())],
    ["scope", getPermissionScopeDecoder()],
    ["constraints", getArrayDecoder(getPermissionConstraintDecoder())],
    ["metadata", getPermissionMetadataDecoder()]
  ]);
}
function getPermissionCodec() {
  return combineCodec(getPermissionEncoder(), getPermissionDecoder());
}
function getPermissionConstraintEncoder() {
  return getStructEncoder([
    ["constraintType", getPermissionConstraintTypeEncoder()],
    ["conditions", getArrayEncoder(getConstraintConditionEncoder())],
    ["enforcement", getEnforcementLevelEncoder()]
  ]);
}
function getPermissionConstraintDecoder() {
  return getStructDecoder([
    ["constraintType", getPermissionConstraintTypeDecoder()],
    ["conditions", getArrayDecoder(getConstraintConditionDecoder())],
    ["enforcement", getEnforcementLevelDecoder()]
  ]);
}
function getPermissionConstraintCodec() {
  return combineCodec(getPermissionConstraintEncoder(), getPermissionConstraintDecoder());
}
function getPermissionConstraintTypeEncoder() {
  return getEnumEncoder(PermissionConstraintType);
}
function getPermissionConstraintTypeDecoder() {
  return getEnumDecoder(PermissionConstraintType);
}
function getPermissionConstraintTypeCodec() {
  return combineCodec(getPermissionConstraintTypeEncoder(), getPermissionConstraintTypeDecoder());
}
function getPermissionMetadataEncoder() {
  return getStructEncoder([
    [
      "businessJustification",
      addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())
    ],
    ["riskAssessment", getRiskAssessmentEncoder()],
    [
      "complianceMapping",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    [
      "relatedPermissions",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    ["owner", getOptionEncoder(getAddressEncoder())],
    ["lastReview", getOptionEncoder(getI64Encoder())],
    ["reviewFrequency", getI64Encoder()]
  ]);
}
function getPermissionMetadataDecoder() {
  return getStructDecoder([
    [
      "businessJustification",
      addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())
    ],
    ["riskAssessment", getRiskAssessmentDecoder()],
    [
      "complianceMapping",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    [
      "relatedPermissions",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    ["owner", getOptionDecoder(getAddressDecoder())],
    ["lastReview", getOptionDecoder(getI64Decoder())],
    ["reviewFrequency", getI64Decoder()]
  ]);
}
function getPermissionMetadataCodec() {
  return combineCodec(getPermissionMetadataEncoder(), getPermissionMetadataDecoder());
}
function getPermissionScopeEncoder() {
  return getStructEncoder([
    ["scopeType", getScopeTypeEncoder()],
    ["boundaries", getScopeBoundariesEncoder()],
    ["hierarchical", getBooleanEncoder()],
    ["inherited", getBooleanEncoder()]
  ]);
}
function getPermissionScopeDecoder() {
  return getStructDecoder([
    ["scopeType", getScopeTypeDecoder()],
    ["boundaries", getScopeBoundariesDecoder()],
    ["hierarchical", getBooleanDecoder()],
    ["inherited", getBooleanDecoder()]
  ]);
}
function getPermissionScopeCodec() {
  return combineCodec(getPermissionScopeEncoder(), getPermissionScopeDecoder());
}
function getPolicyMetadataEncoder() {
  return getStructEncoder([
    ["author", getOptionEncoder(getAddressEncoder())],
    ["approver", getOptionEncoder(getAddressEncoder())],
    ["approvalDate", getOptionEncoder(getI64Encoder())],
    [
      "businessJustification",
      addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())
    ],
    [
      "complianceReferences",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    [
      "riskAssessment",
      getOptionEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    ["reviewSchedule", getReviewScheduleEncoder()]
  ]);
}
function getPolicyMetadataDecoder() {
  return getStructDecoder([
    ["author", getOptionDecoder(getAddressDecoder())],
    ["approver", getOptionDecoder(getAddressDecoder())],
    ["approvalDate", getOptionDecoder(getI64Decoder())],
    [
      "businessJustification",
      addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())
    ],
    [
      "complianceReferences",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    [
      "riskAssessment",
      getOptionDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    ["reviewSchedule", getReviewScheduleDecoder()]
  ]);
}
function getPolicyMetadataCodec() {
  return combineCodec(getPolicyMetadataEncoder(), getPolicyMetadataDecoder());
}
function getPolicyRuleEncoder() {
  return getStructEncoder([
    ["ruleId", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["conditions", getArrayEncoder(getRuleConditionEncoder())],
    ["effect", getRuleEffectEncoder()],
    ["priority", getU8Encoder()],
    ["enabled", getBooleanEncoder()]
  ]);
}
function getPolicyRuleDecoder() {
  return getStructDecoder([
    ["ruleId", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["conditions", getArrayDecoder(getRuleConditionDecoder())],
    ["effect", getRuleEffectDecoder()],
    ["priority", getU8Decoder()],
    ["enabled", getBooleanDecoder()]
  ]);
}
function getPolicyRuleCodec() {
  return combineCodec(getPolicyRuleEncoder(), getPolicyRuleDecoder());
}
function getPolicyScopeEncoder() {
  return getStructEncoder([
    [
      "subjects",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    [
      "resources",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    [
      "actions",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    ["inheritance", getScopeInheritanceEncoder()]
  ]);
}
function getPolicyScopeDecoder() {
  return getStructDecoder([
    [
      "subjects",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    [
      "resources",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    [
      "actions",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    ["inheritance", getScopeInheritanceDecoder()]
  ]);
}
function getPolicyScopeCodec() {
  return combineCodec(getPolicyScopeEncoder(), getPolicyScopeDecoder());
}
function getPolicyStatusEncoder() {
  return getEnumEncoder(PolicyStatus);
}
function getPolicyStatusDecoder() {
  return getEnumDecoder(PolicyStatus);
}
function getPolicyStatusCodec() {
  return combineCodec(getPolicyStatusEncoder(), getPolicyStatusDecoder());
}
function getPolicyTypeEncoder() {
  return getEnumEncoder(PolicyType);
}
function getPolicyTypeDecoder() {
  return getEnumDecoder(PolicyType);
}
function getPolicyTypeCodec() {
  return combineCodec(getPolicyTypeEncoder(), getPolicyTypeDecoder());
}
function getPricingModelEncoder() {
  return getEnumEncoder(PricingModel);
}
function getPricingModelDecoder() {
  return getEnumDecoder(PricingModel);
}
function getPricingModelCodec() {
  return combineCodec(getPricingModelEncoder(), getPricingModelDecoder());
}
function getProposalAccountEncoder() {
  return getStructEncoder([
    ["pubkey", getAddressEncoder()],
    ["isSigner", getBooleanEncoder()],
    ["isWritable", getBooleanEncoder()],
    ["description", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())]
  ]);
}
function getProposalAccountDecoder() {
  return getStructDecoder([
    ["pubkey", getAddressDecoder()],
    ["isSigner", getBooleanDecoder()],
    ["isWritable", getBooleanDecoder()],
    ["description", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())]
  ]);
}
function getProposalAccountCodec() {
  return combineCodec(getProposalAccountEncoder(), getProposalAccountDecoder());
}
function getProposalInstructionEncoder() {
  return getStructEncoder([
    ["programId", getAddressEncoder()],
    ["accounts", getArrayEncoder(getProposalAccountEncoder())],
    ["data", addEncoderSizePrefix(getBytesEncoder(), getU32Encoder())],
    ["description", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())]
  ]);
}
function getProposalInstructionDecoder() {
  return getStructDecoder([
    ["programId", getAddressDecoder()],
    ["accounts", getArrayDecoder(getProposalAccountDecoder())],
    ["data", addDecoderSizePrefix(getBytesDecoder(), getU32Decoder())],
    ["description", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())]
  ]);
}
function getProposalInstructionCodec() {
  return combineCodec(getProposalInstructionEncoder(), getProposalInstructionDecoder());
}
function getProposalMetadataEncoder() {
  return getStructEncoder([
    [
      "ipfsHash",
      getOptionEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    [
      "externalReferences",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    [
      "tags",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    [
      "riskAssessment",
      getOptionEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    [
      "impactAnalysis",
      getOptionEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    [
      "implementationTimeline",
      getOptionEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ]
  ]);
}
function getProposalMetadataDecoder() {
  return getStructDecoder([
    [
      "ipfsHash",
      getOptionDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    [
      "externalReferences",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    [
      "tags",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    [
      "riskAssessment",
      getOptionDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    [
      "impactAnalysis",
      getOptionDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    [
      "implementationTimeline",
      getOptionDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ]
  ]);
}
function getProposalMetadataCodec() {
  return combineCodec(getProposalMetadataEncoder(), getProposalMetadataDecoder());
}
function getProposalStatusEncoder() {
  return getEnumEncoder(ProposalStatus);
}
function getProposalStatusDecoder() {
  return getEnumDecoder(ProposalStatus);
}
function getProposalStatusCodec() {
  return combineCodec(getProposalStatusEncoder(), getProposalStatusDecoder());
}
function getProposalTypeEncoder() {
  return getEnumEncoder(ProposalType);
}
function getProposalTypeDecoder() {
  return getEnumDecoder(ProposalType);
}
function getProposalTypeCodec() {
  return combineCodec(getProposalTypeEncoder(), getProposalTypeDecoder());
}
function getProtocolConfigUpdatedEventEncoder() {
  return getStructEncoder([
    ["authority", getAddressEncoder()],
    ["feesEnabled", getBooleanEncoder()],
    ["escrowFeeBps", getU16Encoder()],
    ["agentRegistrationFee", getU64Encoder()],
    ["listingFee", getU64Encoder()],
    ["disputeFeeBps", getU16Encoder()],
    ["timestamp", getI64Encoder()]
  ]);
}
function getProtocolConfigUpdatedEventDecoder() {
  return getStructDecoder([
    ["authority", getAddressDecoder()],
    ["feesEnabled", getBooleanDecoder()],
    ["escrowFeeBps", getU16Decoder()],
    ["agentRegistrationFee", getU64Decoder()],
    ["listingFee", getU64Decoder()],
    ["disputeFeeBps", getU16Decoder()],
    ["timestamp", getI64Decoder()]
  ]);
}
function getProtocolConfigUpdatedEventCodec() {
  return combineCodec(getProtocolConfigUpdatedEventEncoder(), getProtocolConfigUpdatedEventDecoder());
}
function getQuorumMethodEncoder() {
  return getEnumEncoder(QuorumMethod);
}
function getQuorumMethodDecoder() {
  return getEnumDecoder(QuorumMethod);
}
function getQuorumMethodCodec() {
  return combineCodec(getQuorumMethodEncoder(), getQuorumMethodDecoder());
}
function getQuorumRequirementsEncoder() {
  return getStructEncoder([
    ["minimumParticipation", getU8Encoder()],
    ["approvalThreshold", getU8Encoder()],
    ["superMajorityRequired", getBooleanEncoder()],
    ["minimumVotingPower", getU64Encoder()],
    ["quorumMethod", getQuorumMethodEncoder()]
  ]);
}
function getQuorumRequirementsDecoder() {
  return getStructDecoder([
    ["minimumParticipation", getU8Decoder()],
    ["approvalThreshold", getU8Decoder()],
    ["superMajorityRequired", getBooleanDecoder()],
    ["minimumVotingPower", getU64Decoder()],
    ["quorumMethod", getQuorumMethodDecoder()]
  ]);
}
function getQuorumRequirementsCodec() {
  return combineCodec(getQuorumRequirementsEncoder(), getQuorumRequirementsDecoder());
}
function getRbacConfigInitializedEventEncoder() {
  return getStructEncoder([
    ["rbacConfig", getAddressEncoder()],
    ["authority", getAddressEncoder()],
    ["rolesCount", getU32Encoder()]
  ]);
}
function getRbacConfigInitializedEventDecoder() {
  return getStructDecoder([
    ["rbacConfig", getAddressDecoder()],
    ["authority", getAddressDecoder()],
    ["rolesCount", getU32Decoder()]
  ]);
}
function getRbacConfigInitializedEventCodec() {
  return combineCodec(getRbacConfigInitializedEventEncoder(), getRbacConfigInitializedEventDecoder());
}
function getReentrancyStateEncoder() {
  return getEnumEncoder(ReentrancyState);
}
function getReentrancyStateDecoder() {
  return getEnumDecoder(ReentrancyState);
}
function getReentrancyStateCodec() {
  return combineCodec(getReentrancyStateEncoder(), getReentrancyStateDecoder());
}
function getReportDataEncoder() {
  return getStructEncoder([
    ["summary", getReportSummaryEncoder()],
    ["entries", getArrayEncoder(getReportEntryEncoder())],
    ["complianceMetrics", getComplianceMetricsEncoder()],
    ["riskIndicators", getArrayEncoder(getRiskIndicatorEncoder())],
    [
      "recommendations",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ]
  ]);
}
function getReportDataDecoder() {
  return getStructDecoder([
    ["summary", getReportSummaryDecoder()],
    ["entries", getArrayDecoder(getReportEntryDecoder())],
    ["complianceMetrics", getComplianceMetricsDecoder()],
    ["riskIndicators", getArrayDecoder(getRiskIndicatorDecoder())],
    [
      "recommendations",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ]
  ]);
}
function getReportDataCodec() {
  return combineCodec(getReportDataEncoder(), getReportDataDecoder());
}
function getReportEntryEncoder() {
  return getStructEncoder([
    ["timestamp", getI64Encoder()],
    ["eventId", getUtf8Encoder()],
    ["entryType", getUtf8Encoder()],
    ["amount", getOptionEncoder(getU64Encoder())],
    ["parties", getArrayEncoder(getAddressEncoder())]
  ]);
}
function getReportEntryDecoder() {
  return getStructDecoder([
    ["timestamp", getI64Decoder()],
    ["eventId", getUtf8Decoder()],
    ["entryType", getUtf8Decoder()],
    ["amount", getOptionDecoder(getU64Decoder())],
    ["parties", getArrayDecoder(getAddressDecoder())]
  ]);
}
function getReportEntryCodec() {
  return combineCodec(getReportEntryEncoder(), getReportEntryDecoder());
}
function getReportingFrequencyEncoder() {
  return getEnumEncoder(ReportingFrequency);
}
function getReportingFrequencyDecoder() {
  return getEnumDecoder(ReportingFrequency);
}
function getReportingFrequencyCodec() {
  return combineCodec(getReportingFrequencyEncoder(), getReportingFrequencyDecoder());
}
function getReportStatusEncoder() {
  return getEnumEncoder(ReportStatus);
}
function getReportStatusDecoder() {
  return getEnumDecoder(ReportStatus);
}
function getReportStatusCodec() {
  return combineCodec(getReportStatusEncoder(), getReportStatusDecoder());
}
function getReportSummaryEncoder() {
  return getStructEncoder([
    ["totalTransactions", getU64Encoder()],
    ["totalVolume", getU64Encoder()],
    ["highRiskTransactions", getU64Encoder()],
    ["complianceViolations", getU64Encoder()],
    ["securityIncidents", getU64Encoder()],
    ["averageRiskScore", getU8Encoder()]
  ]);
}
function getReportSummaryDecoder() {
  return getStructDecoder([
    ["totalTransactions", getU64Decoder()],
    ["totalVolume", getU64Decoder()],
    ["highRiskTransactions", getU64Decoder()],
    ["complianceViolations", getU64Decoder()],
    ["securityIncidents", getU64Decoder()],
    ["averageRiskScore", getU8Decoder()]
  ]);
}
function getReportSummaryCodec() {
  return combineCodec(getReportSummaryEncoder(), getReportSummaryDecoder());
}
function getReportTypeEncoder() {
  return getEnumEncoder(ReportType);
}
function getReportTypeDecoder() {
  return getEnumDecoder(ReportType);
}
function getReportTypeCodec() {
  return combineCodec(getReportTypeEncoder(), getReportTypeDecoder());
}
function getResourceConstraintsEncoder() {
  return getStructEncoder([
    ["allowedResourceTypes", getArrayEncoder(getUtf8Encoder())],
    ["blockedResourceTypes", getArrayEncoder(getUtf8Encoder())],
    [
      "accessLimits",
      getArrayEncoder(getStructEncoder([
        ["0", getUtf8Encoder()],
        ["1", getU64Encoder()]
      ]))
    ],
    ["compartments", getArrayEncoder(getUtf8Encoder())]
  ]);
}
function getResourceConstraintsDecoder() {
  return getStructDecoder([
    ["allowedResourceTypes", getArrayDecoder(getUtf8Decoder())],
    ["blockedResourceTypes", getArrayDecoder(getUtf8Decoder())],
    [
      "accessLimits",
      getArrayDecoder(getStructDecoder([
        ["0", getUtf8Decoder()],
        ["1", getU64Decoder()]
      ]))
    ],
    ["compartments", getArrayDecoder(getUtf8Decoder())]
  ]);
}
function getResourceConstraintsCodec() {
  return combineCodec(getResourceConstraintsEncoder(), getResourceConstraintsDecoder());
}
function getReputationMetricsInitializedEventEncoder() {
  return getStructEncoder([
    ["agent", getAddressEncoder()],
    ["timestamp", getI64Encoder()]
  ]);
}
function getReputationMetricsInitializedEventDecoder() {
  return getStructDecoder([
    ["agent", getAddressDecoder()],
    ["timestamp", getI64Decoder()]
  ]);
}
function getReputationMetricsInitializedEventCodec() {
  return combineCodec(getReputationMetricsInitializedEventEncoder(), getReputationMetricsInitializedEventDecoder());
}
function getReputationPaymentRecordedEventEncoder() {
  return getStructEncoder([
    ["agent", getAddressEncoder()],
    [
      "paymentSignature",
      addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())
    ],
    ["amount", getU64Encoder()],
    ["responseTimeMs", getU64Encoder()],
    ["success", getBooleanEncoder()],
    ["newReputationScore", getU64Encoder()],
    ["timestamp", getI64Encoder()]
  ]);
}
function getReputationPaymentRecordedEventDecoder() {
  return getStructDecoder([
    ["agent", getAddressDecoder()],
    [
      "paymentSignature",
      addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())
    ],
    ["amount", getU64Decoder()],
    ["responseTimeMs", getU64Decoder()],
    ["success", getBooleanDecoder()],
    ["newReputationScore", getU64Decoder()],
    ["timestamp", getI64Decoder()]
  ]);
}
function getReputationPaymentRecordedEventCodec() {
  return combineCodec(getReputationPaymentRecordedEventEncoder(), getReputationPaymentRecordedEventDecoder());
}
function getReputationRatingSubmittedEventEncoder() {
  return getStructEncoder([
    ["agent", getAddressEncoder()],
    ["client", getAddressEncoder()],
    ["rating", getU8Encoder()],
    ["newReputationScore", getU64Encoder()],
    ["timestamp", getI64Encoder()]
  ]);
}
function getReputationRatingSubmittedEventDecoder() {
  return getStructDecoder([
    ["agent", getAddressDecoder()],
    ["client", getAddressDecoder()],
    ["rating", getU8Decoder()],
    ["newReputationScore", getU64Decoder()],
    ["timestamp", getI64Decoder()]
  ]);
}
function getReputationRatingSubmittedEventCodec() {
  return combineCodec(getReputationRatingSubmittedEventEncoder(), getReputationRatingSubmittedEventDecoder());
}
function getReputationTagsUpdatedEventEncoder() {
  return getStructEncoder([
    ["agent", getAddressEncoder()],
    ["totalTags", getU32Encoder()],
    ["skillTagsCount", getU32Encoder()],
    ["behaviorTagsCount", getU32Encoder()],
    ["complianceTagsCount", getU32Encoder()],
    ["tagScoresCount", getU32Encoder()],
    ["timestamp", getI64Encoder()]
  ]);
}
function getReputationTagsUpdatedEventDecoder() {
  return getStructDecoder([
    ["agent", getAddressDecoder()],
    ["totalTags", getU32Decoder()],
    ["skillTagsCount", getU32Decoder()],
    ["behaviorTagsCount", getU32Decoder()],
    ["complianceTagsCount", getU32Decoder()],
    ["tagScoresCount", getU32Decoder()],
    ["timestamp", getI64Decoder()]
  ]);
}
function getReputationTagsUpdatedEventCodec() {
  return combineCodec(getReputationTagsUpdatedEventEncoder(), getReputationTagsUpdatedEventDecoder());
}
function getReviewScheduleEncoder() {
  return getStructEncoder([
    ["frequency", getI64Encoder()],
    ["lastReview", getOptionEncoder(getI64Encoder())],
    ["nextReview", getI64Encoder()],
    ["reviewOwners", getArrayEncoder(getAddressEncoder())],
    [
      "reviewCriteria",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ]
  ]);
}
function getReviewScheduleDecoder() {
  return getStructDecoder([
    ["frequency", getI64Decoder()],
    ["lastReview", getOptionDecoder(getI64Decoder())],
    ["nextReview", getI64Decoder()],
    ["reviewOwners", getArrayDecoder(getAddressDecoder())],
    [
      "reviewCriteria",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ]
  ]);
}
function getReviewScheduleCodec() {
  return combineCodec(getReviewScheduleEncoder(), getReviewScheduleDecoder());
}
function getRiskAcceptanceEncoder() {
  return getStructEncoder([
    ["accepted", getBooleanEncoder()],
    ["acceptingAuthority", getOptionEncoder(getAddressEncoder())],
    ["acceptanceDate", getOptionEncoder(getI64Encoder())],
    [
      "reasoning",
      getOptionEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    ["reviewDate", getOptionEncoder(getI64Encoder())]
  ]);
}
function getRiskAcceptanceDecoder() {
  return getStructDecoder([
    ["accepted", getBooleanDecoder()],
    ["acceptingAuthority", getOptionDecoder(getAddressDecoder())],
    ["acceptanceDate", getOptionDecoder(getI64Decoder())],
    [
      "reasoning",
      getOptionDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    ["reviewDate", getOptionDecoder(getI64Decoder())]
  ]);
}
function getRiskAcceptanceCodec() {
  return combineCodec(getRiskAcceptanceEncoder(), getRiskAcceptanceDecoder());
}
function getRiskAssessmentEncoder() {
  return getStructEncoder([
    ["riskScore", getU8Encoder()],
    ["riskFactors", getArrayEncoder(getRiskFactorEncoder())],
    [
      "mitigationMeasures",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    ["riskAcceptance", getRiskAcceptanceEncoder()]
  ]);
}
function getRiskAssessmentDecoder() {
  return getStructDecoder([
    ["riskScore", getU8Decoder()],
    ["riskFactors", getArrayDecoder(getRiskFactorDecoder())],
    [
      "mitigationMeasures",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    ["riskAcceptance", getRiskAcceptanceDecoder()]
  ]);
}
function getRiskAssessmentCodec() {
  return combineCodec(getRiskAssessmentEncoder(), getRiskAssessmentDecoder());
}
function getRiskCategoryEncoder() {
  return getEnumEncoder(RiskCategory);
}
function getRiskCategoryDecoder() {
  return getEnumDecoder(RiskCategory);
}
function getRiskCategoryCodec() {
  return combineCodec(getRiskCategoryEncoder(), getRiskCategoryDecoder());
}
function getRiskFactorEncoder() {
  return getStructEncoder([
    ["name", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["category", getRiskCategoryEncoder()],
    ["impact", getU8Encoder()],
    ["likelihood", getU8Encoder()],
    ["riskScore", getU8Encoder()]
  ]);
}
function getRiskFactorDecoder() {
  return getStructDecoder([
    ["name", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["category", getRiskCategoryDecoder()],
    ["impact", getU8Decoder()],
    ["likelihood", getU8Decoder()],
    ["riskScore", getU8Decoder()]
  ]);
}
function getRiskFactorCodec() {
  return combineCodec(getRiskFactorEncoder(), getRiskFactorDecoder());
}
function getRiskIndicatorEncoder() {
  return getStructEncoder([
    ["name", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["currentValue", getU64Encoder()],
    ["thresholdValue", getU64Encoder()],
    ["trend", getTrendDirectionEncoder()],
    ["severity", getViolationSeverityEncoder()],
    [
      "recommendedActions",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ]
  ]);
}
function getRiskIndicatorDecoder() {
  return getStructDecoder([
    ["name", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["currentValue", getU64Decoder()],
    ["thresholdValue", getU64Decoder()],
    ["trend", getTrendDirectionDecoder()],
    ["severity", getViolationSeverityDecoder()],
    [
      "recommendedActions",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ]
  ]);
}
function getRiskIndicatorCodec() {
  return combineCodec(getRiskIndicatorEncoder(), getRiskIndicatorDecoder());
}
function getRiskLevelEncoder() {
  return getEnumEncoder(RiskLevel);
}
function getRiskLevelDecoder() {
  return getEnumDecoder(RiskLevel);
}
function getRiskLevelCodec() {
  return combineCodec(getRiskLevelEncoder(), getRiskLevelDecoder());
}
function getRoleEncoder() {
  return getStructEncoder([
    ["roleId", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["name", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["description", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["roleType", getRoleTypeEncoder()],
    [
      "permissions",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    ["constraints", getRoleConstraintsEncoder()],
    [
      "inheritsFrom",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    ["metadata", getRoleMetadataEncoder()],
    ["status", getRoleStatusEncoder()],
    ["createdAt", getI64Encoder()],
    ["modifiedAt", getI64Encoder()]
  ]);
}
function getRoleDecoder() {
  return getStructDecoder([
    ["roleId", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["name", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["description", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["roleType", getRoleTypeDecoder()],
    [
      "permissions",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    ["constraints", getRoleConstraintsDecoder()],
    [
      "inheritsFrom",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    ["metadata", getRoleMetadataDecoder()],
    ["status", getRoleStatusDecoder()],
    ["createdAt", getI64Decoder()],
    ["modifiedAt", getI64Decoder()]
  ]);
}
function getRoleCodec() {
  return combineCodec(getRoleEncoder(), getRoleDecoder());
}
function getRoleConstraintsEncoder() {
  return getStructEncoder([
    ["timeConstraints", getOptionEncoder(getTimeConstraintsEncoder())],
    ["locationConstraints", getOptionEncoder(getLocationConstraintsEncoder())],
    ["resourceConstraints", getOptionEncoder(getResourceConstraintsEncoder())],
    ["sessionConstraints", getOptionEncoder(getSessionConstraintsEncoder())],
    ["sodConstraints", getArrayEncoder(getSodConstraintEncoder())],
    ["maxConcurrentSessions", getOptionEncoder(getU32Encoder())],
    [
      "activationRequirements",
      getArrayEncoder(getActivationRequirementEncoder())
    ]
  ]);
}
function getRoleConstraintsDecoder() {
  return getStructDecoder([
    ["timeConstraints", getOptionDecoder(getTimeConstraintsDecoder())],
    ["locationConstraints", getOptionDecoder(getLocationConstraintsDecoder())],
    ["resourceConstraints", getOptionDecoder(getResourceConstraintsDecoder())],
    ["sessionConstraints", getOptionDecoder(getSessionConstraintsDecoder())],
    ["sodConstraints", getArrayDecoder(getSodConstraintDecoder())],
    ["maxConcurrentSessions", getOptionDecoder(getU32Decoder())],
    [
      "activationRequirements",
      getArrayDecoder(getActivationRequirementDecoder())
    ]
  ]);
}
function getRoleConstraintsCodec() {
  return combineCodec(getRoleConstraintsEncoder(), getRoleConstraintsDecoder());
}
function getRoleMetadataEncoder() {
  return getStructEncoder([
    [
      "businessPurpose",
      addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())
    ],
    ["riskLevel", getRiskLevelEncoder()],
    ["dataAccessLevel", getDataAccessLevelEncoder()],
    [
      "complianceRequirements",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    ["roleOwner", getOptionEncoder(getAddressEncoder())],
    ["roleCustodian", getOptionEncoder(getAddressEncoder())],
    ["reviewFrequency", getI64Encoder()],
    ["lastReview", getOptionEncoder(getI64Encoder())],
    ["nextReview", getOptionEncoder(getI64Encoder())]
  ]);
}
function getRoleMetadataDecoder() {
  return getStructDecoder([
    [
      "businessPurpose",
      addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())
    ],
    ["riskLevel", getRiskLevelDecoder()],
    ["dataAccessLevel", getDataAccessLevelDecoder()],
    [
      "complianceRequirements",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    ["roleOwner", getOptionDecoder(getAddressDecoder())],
    ["roleCustodian", getOptionDecoder(getAddressDecoder())],
    ["reviewFrequency", getI64Decoder()],
    ["lastReview", getOptionDecoder(getI64Decoder())],
    ["nextReview", getOptionDecoder(getI64Decoder())]
  ]);
}
function getRoleMetadataCodec() {
  return combineCodec(getRoleMetadataEncoder(), getRoleMetadataDecoder());
}
function getRoleStatusEncoder() {
  return getEnumEncoder(RoleStatus);
}
function getRoleStatusDecoder() {
  return getEnumDecoder(RoleStatus);
}
function getRoleStatusCodec() {
  return combineCodec(getRoleStatusEncoder(), getRoleStatusDecoder());
}
function getRoleTypeEncoder() {
  return getEnumEncoder(RoleType);
}
function getRoleTypeDecoder() {
  return getEnumDecoder(RoleType);
}
function getRoleTypeCodec() {
  return combineCodec(getRoleTypeEncoder(), getRoleTypeDecoder());
}
function getRuleEffectEncoder() {
  return getEnumEncoder(RuleEffect);
}
function getRuleEffectDecoder() {
  return getEnumDecoder(RuleEffect);
}
function getRuleEffectCodec() {
  return combineCodec(getRuleEffectEncoder(), getRuleEffectDecoder());
}
function getRuleConditionEncoder() {
  return getStructEncoder([
    ["conditionType", getConditionTypeEncoder()],
    ["subjectAttributes", getArrayEncoder(pairEncoder)],
    ["resourceAttributes", getArrayEncoder(pairEncoder)],
    ["actionAttributes", getArrayEncoder(pairEncoder)],
    ["environmentAttributes", getArrayEncoder(pairEncoder)]
  ]);
}
function getRuleConditionDecoder() {
  return getStructDecoder([
    ["conditionType", getConditionTypeDecoder()],
    ["subjectAttributes", getArrayDecoder(pairDecoder)],
    ["resourceAttributes", getArrayDecoder(pairDecoder)],
    ["actionAttributes", getArrayDecoder(pairDecoder)],
    ["environmentAttributes", getArrayDecoder(pairDecoder)]
  ]);
}
function getRuleConditionCodec() {
  return combineCodec(getRuleConditionEncoder(), getRuleConditionDecoder());
}
function getScopeBoundariesEncoder() {
  return getStructEncoder([
    [
      "includedResources",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    [
      "excludedResources",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    [
      "resourcePatterns",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    [
      "hierarchicalBoundaries",
      getArrayEncoder(getHierarchicalBoundaryEncoder())
    ]
  ]);
}
function getScopeBoundariesDecoder() {
  return getStructDecoder([
    [
      "includedResources",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    [
      "excludedResources",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    [
      "resourcePatterns",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    [
      "hierarchicalBoundaries",
      getArrayDecoder(getHierarchicalBoundaryDecoder())
    ]
  ]);
}
function getScopeBoundariesCodec() {
  return combineCodec(getScopeBoundariesEncoder(), getScopeBoundariesDecoder());
}
function getScopeInheritanceEncoder() {
  return getEnumEncoder(ScopeInheritance);
}
function getScopeInheritanceDecoder() {
  return getEnumDecoder(ScopeInheritance);
}
function getScopeInheritanceCodec() {
  return combineCodec(getScopeInheritanceEncoder(), getScopeInheritanceDecoder());
}
function getScopeTypeEncoder() {
  return getEnumEncoder(ScopeType);
}
function getScopeTypeDecoder() {
  return getEnumDecoder(ScopeType);
}
function getScopeTypeCodec() {
  return combineCodec(getScopeTypeEncoder(), getScopeTypeDecoder());
}
function getSecurityEventTypeEncoder() {
  return getEnumEncoder(SecurityEventType);
}
function getSecurityEventTypeDecoder() {
  return getEnumDecoder(SecurityEventType);
}
function getSecurityEventTypeCodec() {
  return combineCodec(getSecurityEventTypeEncoder(), getSecurityEventTypeDecoder());
}
function getSecurityPoliciesEncoder() {
  return getStructEncoder([
    ["authentication", getAuthenticationPoliciesEncoder()],
    ["authorization", getAuthorizationPoliciesEncoder()],
    ["password", getPasswordPoliciesEncoder()],
    ["session", getSessionPoliciesEncoder()],
    ["dataProtection", getDataProtectionPoliciesEncoder()],
    ["networkSecurity", getNetworkSecurityPoliciesEncoder()],
    ["incidentResponse", getIncidentResponsePoliciesEncoder()],
    ["compliance", getCompliancePoliciesEncoder()]
  ]);
}
function getSecurityPoliciesDecoder() {
  return getStructDecoder([
    ["authentication", getAuthenticationPoliciesDecoder()],
    ["authorization", getAuthorizationPoliciesDecoder()],
    ["password", getPasswordPoliciesDecoder()],
    ["session", getSessionPoliciesDecoder()],
    ["dataProtection", getDataProtectionPoliciesDecoder()],
    ["networkSecurity", getNetworkSecurityPoliciesDecoder()],
    ["incidentResponse", getIncidentResponsePoliciesDecoder()],
    ["compliance", getCompliancePoliciesDecoder()]
  ]);
}
function getSecurityPoliciesCodec() {
  return combineCodec(getSecurityPoliciesEncoder(), getSecurityPoliciesDecoder());
}
function getServiceEndpointEncoder() {
  return getStructEncoder([
    ["id", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["serviceType", getServiceEndpointTypeEncoder()],
    [
      "serviceEndpoint",
      addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())
    ],
    ["description", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())]
  ]);
}
function getServiceEndpointDecoder() {
  return getStructDecoder([
    ["id", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["serviceType", getServiceEndpointTypeDecoder()],
    [
      "serviceEndpoint",
      addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())
    ],
    ["description", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())]
  ]);
}
function getServiceEndpointCodec() {
  return combineCodec(getServiceEndpointEncoder(), getServiceEndpointDecoder());
}
function getServiceEndpointTypeEncoder() {
  return getEnumEncoder(ServiceEndpointType);
}
function getServiceEndpointTypeDecoder() {
  return getEnumDecoder(ServiceEndpointType);
}
function getServiceEndpointTypeCodec() {
  return combineCodec(getServiceEndpointTypeEncoder(), getServiceEndpointTypeDecoder());
}
function getSessionConstraintsEncoder() {
  return getStructEncoder([
    ["maxSessionDuration", getI64Encoder()],
    ["idleTimeout", getI64Encoder()],
    ["reauthInterval", getI64Encoder()],
    ["mfaRequired", getBooleanEncoder()],
    ["deviceFingerprinting", getBooleanEncoder()],
    ["sessionEncryption", getBooleanEncoder()]
  ]);
}
function getSessionConstraintsDecoder() {
  return getStructDecoder([
    ["maxSessionDuration", getI64Decoder()],
    ["idleTimeout", getI64Decoder()],
    ["reauthInterval", getI64Decoder()],
    ["mfaRequired", getBooleanDecoder()],
    ["deviceFingerprinting", getBooleanDecoder()],
    ["sessionEncryption", getBooleanDecoder()]
  ]);
}
function getSessionConstraintsCodec() {
  return combineCodec(getSessionConstraintsEncoder(), getSessionConstraintsDecoder());
}
function getSessionPoliciesEncoder() {
  return getStructEncoder([
    ["maxSessionDuration", getI64Encoder()],
    ["idleTimeout", getI64Encoder()],
    ["concurrentSessions", getU8Encoder()]
  ]);
}
function getSessionPoliciesDecoder() {
  return getStructDecoder([
    ["maxSessionDuration", getI64Decoder()],
    ["idleTimeout", getI64Decoder()],
    ["concurrentSessions", getU8Decoder()]
  ]);
}
function getSessionPoliciesCodec() {
  return combineCodec(getSessionPoliciesEncoder(), getSessionPoliciesDecoder());
}
function getSlashReasonEncoder() {
  return getEnumEncoder(SlashReason);
}
function getSlashReasonDecoder() {
  return getEnumDecoder(SlashReason);
}
function getSlashReasonCodec() {
  return combineCodec(getSlashReasonEncoder(), getSlashReasonDecoder());
}
function getSodConstraintEncoder() {
  return getStructEncoder([
    ["name", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    [
      "conflictingRoles",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    ["constraintType", getSodConstraintTypeEncoder()],
    ["enforcementLevel", getEnforcementLevelEncoder()],
    [
      "exceptionProcedures",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ]
  ]);
}
function getSodConstraintDecoder() {
  return getStructDecoder([
    ["name", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    [
      "conflictingRoles",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    ["constraintType", getSodConstraintTypeDecoder()],
    ["enforcementLevel", getEnforcementLevelDecoder()],
    [
      "exceptionProcedures",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ]
  ]);
}
function getSodConstraintCodec() {
  return combineCodec(getSodConstraintEncoder(), getSodConstraintDecoder());
}
function getSodConstraintTypeEncoder() {
  return getEnumEncoder(SodConstraintType);
}
function getSodConstraintTypeDecoder() {
  return getEnumDecoder(SodConstraintType);
}
function getSodConstraintTypeCodec() {
  return combineCodec(getSodConstraintTypeEncoder(), getSodConstraintTypeDecoder());
}
function getSourceReputationUpdatedEventEncoder() {
  return getStructEncoder([
    ["agent", getAddressEncoder()],
    ["sourceName", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["sourceScore", getU16Encoder()],
    ["weightedAggregateScore", getU64Encoder()],
    ["hasConflict", getBooleanEncoder()],
    ["totalSources", getU32Encoder()],
    ["timestamp", getI64Encoder()]
  ]);
}
function getSourceReputationUpdatedEventDecoder() {
  return getStructDecoder([
    ["agent", getAddressDecoder()],
    ["sourceName", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["sourceScore", getU16Decoder()],
    ["weightedAggregateScore", getU64Decoder()],
    ["hasConflict", getBooleanDecoder()],
    ["totalSources", getU32Decoder()],
    ["timestamp", getI64Decoder()]
  ]);
}
function getSourceReputationUpdatedEventCodec() {
  return combineCodec(getSourceReputationUpdatedEventEncoder(), getSourceReputationUpdatedEventDecoder());
}
function getSourceScoreEncoder() {
  return getStructEncoder([
    ["sourceName", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["score", getU16Encoder()],
    ["weight", getU16Encoder()],
    ["dataPoints", getU32Encoder()],
    ["reliability", getU16Encoder()],
    ["lastUpdated", getI64Encoder()]
  ]);
}
function getSourceScoreDecoder() {
  return getStructDecoder([
    ["sourceName", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["score", getU16Decoder()],
    ["weight", getU16Decoder()],
    ["dataPoints", getU32Decoder()],
    ["reliability", getU16Decoder()],
    ["lastUpdated", getI64Decoder()]
  ]);
}
function getSourceScoreCodec() {
  return combineCodec(getSourceScoreEncoder(), getSourceScoreDecoder());
}
function getStepUpTriggerEncoder() {
  return getEnumEncoder(StepUpTrigger);
}
function getStepUpTriggerDecoder() {
  return getEnumDecoder(StepUpTrigger);
}
function getStepUpTriggerCodec() {
  return combineCodec(getStepUpTriggerEncoder(), getStepUpTriggerDecoder());
}
function getSubmissionDetailsEncoder() {
  return getStructEncoder([
    ["submittedAt", getI64Encoder()],
    ["regulatoryBody", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    [
      "submissionReference",
      addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())
    ],
    ["acknowledged", getBooleanEncoder()],
    ["acknowledgedAt", getOptionEncoder(getI64Encoder())],
    [
      "regulatoryResponse",
      getOptionEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ]
  ]);
}
function getSubmissionDetailsDecoder() {
  return getStructDecoder([
    ["submittedAt", getI64Decoder()],
    ["regulatoryBody", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    [
      "submissionReference",
      addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())
    ],
    ["acknowledged", getBooleanDecoder()],
    ["acknowledgedAt", getOptionDecoder(getI64Decoder())],
    [
      "regulatoryResponse",
      getOptionDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ]
  ]);
}
function getSubmissionDetailsCodec() {
  return combineCodec(getSubmissionDetailsEncoder(), getSubmissionDetailsDecoder());
}
function getTagDecayAppliedEventEncoder() {
  return getStructEncoder([
    ["agent", getAddressEncoder()],
    ["tagsRemoved", getU32Encoder()],
    ["remainingTags", getU32Encoder()],
    ["timestamp", getI64Encoder()]
  ]);
}
function getTagDecayAppliedEventDecoder() {
  return getStructDecoder([
    ["agent", getAddressDecoder()],
    ["tagsRemoved", getU32Decoder()],
    ["remainingTags", getU32Decoder()],
    ["timestamp", getI64Decoder()]
  ]);
}
function getTagDecayAppliedEventCodec() {
  return combineCodec(getTagDecayAppliedEventEncoder(), getTagDecayAppliedEventDecoder());
}
function getTagScoreEncoder() {
  return getStructEncoder([
    ["tagName", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["confidence", getU16Encoder()],
    ["evidenceCount", getU32Encoder()],
    ["lastUpdated", getI64Encoder()]
  ]);
}
function getTagScoreDecoder() {
  return getStructDecoder([
    ["tagName", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["confidence", getU16Decoder()],
    ["evidenceCount", getU32Decoder()],
    ["lastUpdated", getI64Decoder()]
  ]);
}
function getTagScoreCodec() {
  return combineCodec(getTagScoreEncoder(), getTagScoreDecoder());
}
function getTierUpdatedEventEncoder() {
  return getStructEncoder([
    ["agent", getAddressEncoder()],
    ["oldTier", getAccessTierEncoder()],
    ["newTier", getAccessTierEncoder()],
    ["totalStaked", getU64Encoder()],
    ["dailyApiCalls", getU32Encoder()],
    ["votingPower", getU64Encoder()]
  ]);
}
function getTierUpdatedEventDecoder() {
  return getStructDecoder([
    ["agent", getAddressDecoder()],
    ["oldTier", getAccessTierDecoder()],
    ["newTier", getAccessTierDecoder()],
    ["totalStaked", getU64Decoder()],
    ["dailyApiCalls", getU32Decoder()],
    ["votingPower", getU64Decoder()]
  ]);
}
function getTierUpdatedEventCodec() {
  return combineCodec(getTierUpdatedEventEncoder(), getTierUpdatedEventDecoder());
}
function getTimeConstraintsEncoder() {
  return getStructEncoder([
    ["allowedHours", addEncoderSizePrefix(getBytesEncoder(), getU32Encoder())],
    ["allowedDays", addEncoderSizePrefix(getBytesEncoder(), getU32Encoder())],
    ["timezone", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["maxSessionDuration", getOptionEncoder(getI64Encoder())],
    ["expiresAt", getOptionEncoder(getI64Encoder())],
    ["reactivationPeriod", getOptionEncoder(getI64Encoder())]
  ]);
}
function getTimeConstraintsDecoder() {
  return getStructDecoder([
    ["allowedHours", addDecoderSizePrefix(getBytesDecoder(), getU32Decoder())],
    ["allowedDays", addDecoderSizePrefix(getBytesDecoder(), getU32Decoder())],
    ["timezone", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["maxSessionDuration", getOptionDecoder(getI64Decoder())],
    ["expiresAt", getOptionDecoder(getI64Decoder())],
    ["reactivationPeriod", getOptionDecoder(getI64Decoder())]
  ]);
}
function getTimeConstraintsCodec() {
  return combineCodec(getTimeConstraintsEncoder(), getTimeConstraintsDecoder());
}
function getTimeLockEncoder() {
  return getStructEncoder([
    ["duration", getI64Encoder()],
    ["lockedAt", getI64Encoder()],
    ["unlocksAt", getI64Encoder()],
    ["earlyUnlockConditions", getArrayEncoder(getExecutionConditionEncoder())],
    ["lockType", getTimeLockTypeEncoder()],
    ["cancellable", getBooleanEncoder()]
  ]);
}
function getTimeLockDecoder() {
  return getStructDecoder([
    ["duration", getI64Decoder()],
    ["lockedAt", getI64Decoder()],
    ["unlocksAt", getI64Decoder()],
    ["earlyUnlockConditions", getArrayDecoder(getExecutionConditionDecoder())],
    ["lockType", getTimeLockTypeDecoder()],
    ["cancellable", getBooleanDecoder()]
  ]);
}
function getTimeLockCodec() {
  return combineCodec(getTimeLockEncoder(), getTimeLockDecoder());
}
function getTimeLockTypeEncoder() {
  return getEnumEncoder(TimeLockType);
}
function getTimeLockTypeDecoder() {
  return getEnumDecoder(TimeLockType);
}
function getTimeLockTypeCodec() {
  return combineCodec(getTimeLockTypeEncoder(), getTimeLockTypeDecoder());
}
function getTransactionPriorityEncoder() {
  return getEnumEncoder(TransactionPriority);
}
function getTransactionPriorityDecoder() {
  return getEnumDecoder(TransactionPriority);
}
function getTransactionPriorityCodec() {
  return combineCodec(getTransactionPriorityEncoder(), getTransactionPriorityDecoder());
}
function getTransactionStatusEncoder() {
  return getEnumEncoder(TransactionStatus);
}
function getTransactionStatusDecoder() {
  return getEnumDecoder(TransactionStatus);
}
function getTransactionStatusCodec() {
  return combineCodec(getTransactionStatusEncoder(), getTransactionStatusDecoder());
}
function getTransactionTypeEncoder() {
  return getEnumEncoder(TransactionType);
}
function getTransactionTypeDecoder() {
  return getEnumDecoder(TransactionType);
}
function getTransactionTypeCodec() {
  return combineCodec(getTransactionTypeEncoder(), getTransactionTypeDecoder());
}
function getTrendDirectionEncoder() {
  return getEnumEncoder(TrendDirection);
}
function getTrendDirectionDecoder() {
  return getEnumDecoder(TrendDirection);
}
function getTrendDirectionCodec() {
  return combineCodec(getTrendDirectionEncoder(), getTrendDirectionDecoder());
}
function getUnlockMethodEncoder() {
  return getEnumEncoder(UnlockMethod);
}
function getUnlockMethodDecoder() {
  return getEnumDecoder(UnlockMethod);
}
function getUnlockMethodCodec() {
  return combineCodec(getUnlockMethodEncoder(), getUnlockMethodDecoder());
}
function getValueTypeEncoder() {
  return getEnumEncoder(ValueType);
}
function getValueTypeDecoder() {
  return getEnumDecoder(ValueType);
}
function getValueTypeCodec() {
  return combineCodec(getValueTypeEncoder(), getValueTypeDecoder());
}
function getVerificationMethodEncoder() {
  return getStructEncoder([
    ["id", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["methodType", getVerificationMethodTypeEncoder()],
    ["controller", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    [
      "publicKeyMultibase",
      addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())
    ],
    ["relationships", getArrayEncoder(getVerificationRelationshipEncoder())],
    ["createdAt", getI64Encoder()],
    ["revoked", getBooleanEncoder()]
  ]);
}
function getVerificationMethodDecoder() {
  return getStructDecoder([
    ["id", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["methodType", getVerificationMethodTypeDecoder()],
    ["controller", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    [
      "publicKeyMultibase",
      addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())
    ],
    ["relationships", getArrayDecoder(getVerificationRelationshipDecoder())],
    ["createdAt", getI64Decoder()],
    ["revoked", getBooleanDecoder()]
  ]);
}
function getVerificationMethodCodec() {
  return combineCodec(getVerificationMethodEncoder(), getVerificationMethodDecoder());
}
function getVerificationMethodTypeEncoder() {
  return getEnumEncoder(VerificationMethodType);
}
function getVerificationMethodTypeDecoder() {
  return getEnumDecoder(VerificationMethodType);
}
function getVerificationMethodTypeCodec() {
  return combineCodec(getVerificationMethodTypeEncoder(), getVerificationMethodTypeDecoder());
}
function getVerificationRelationshipEncoder() {
  return getEnumEncoder(VerificationRelationship);
}
function getVerificationRelationshipDecoder() {
  return getEnumDecoder(VerificationRelationship);
}
function getVerificationRelationshipCodec() {
  return combineCodec(getVerificationRelationshipEncoder(), getVerificationRelationshipDecoder());
}
function getViolationSeverityEncoder() {
  return getEnumEncoder(ViolationSeverity);
}
function getViolationSeverityDecoder() {
  return getEnumDecoder(ViolationSeverity);
}
function getViolationSeverityCodec() {
  return combineCodec(getViolationSeverityEncoder(), getViolationSeverityDecoder());
}
function getVoteEncoder() {
  return getStructEncoder([
    ["voter", getAddressEncoder()],
    ["choice", getVoteChoiceEncoder()],
    ["votingPower", getU64Encoder()],
    ["votedAt", getI64Encoder()],
    [
      "reasoning",
      getOptionEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    ["delegationInfo", getOptionEncoder(getDelegationInfoEncoder())]
  ]);
}
function getVoteDecoder() {
  return getStructDecoder([
    ["voter", getAddressDecoder()],
    ["choice", getVoteChoiceDecoder()],
    ["votingPower", getU64Decoder()],
    ["votedAt", getI64Decoder()],
    [
      "reasoning",
      getOptionDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    ["delegationInfo", getOptionDecoder(getDelegationInfoDecoder())]
  ]);
}
function getVoteCodec() {
  return combineCodec(getVoteEncoder(), getVoteDecoder());
}
function getVoteChoiceEncoder() {
  return getEnumEncoder(VoteChoice);
}
function getVoteChoiceDecoder() {
  return getEnumDecoder(VoteChoice);
}
function getVoteChoiceCodec() {
  return combineCodec(getVoteChoiceEncoder(), getVoteChoiceDecoder());
}
function getVotingResultsEncoder() {
  return getStructEncoder([
    ["votesFor", getU64Encoder()],
    ["votesAgainst", getU64Encoder()],
    ["votesAbstain", getU64Encoder()],
    ["totalVotingPower", getU64Encoder()],
    ["participationRate", getU8Encoder()],
    ["individualVotes", getArrayEncoder(getVoteEncoder())],
    ["weightedVoting", getBooleanEncoder()],
    ["quorumReached", getBooleanEncoder()],
    ["approvalThresholdMet", getBooleanEncoder()]
  ]);
}
function getVotingResultsDecoder() {
  return getStructDecoder([
    ["votesFor", getU64Decoder()],
    ["votesAgainst", getU64Decoder()],
    ["votesAbstain", getU64Decoder()],
    ["totalVotingPower", getU64Decoder()],
    ["participationRate", getU8Decoder()],
    ["individualVotes", getArrayDecoder(getVoteDecoder())],
    ["weightedVoting", getBooleanDecoder()],
    ["quorumReached", getBooleanDecoder()],
    ["approvalThresholdMet", getBooleanDecoder()]
  ]);
}
function getVotingResultsCodec() {
  return combineCodec(getVotingResultsEncoder(), getVotingResultsDecoder());
}
function getAgentDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(AGENT_DISCRIMINATOR);
}
function getAgentEncoder() {
  return transformEncoder(getStructEncoder([
    ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
    ["owner", getAddressEncoder()],
    ["agentId", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["agentType", getU8Encoder()],
    ["name", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["description", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    [
      "capabilities",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    ["pricingModel", getPricingModelEncoder()],
    ["reputationScore", getU32Encoder()],
    ["totalJobsCompleted", getU32Encoder()],
    ["totalEarnings", getU64Encoder()],
    ["isActive", getBooleanEncoder()],
    ["createdAt", getI64Encoder()],
    ["updatedAt", getI64Encoder()],
    ["originalPrice", getU64Encoder()],
    ["genomeHash", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["isReplicable", getBooleanEncoder()],
    ["replicationFee", getU64Encoder()],
    [
      "serviceEndpoint",
      addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())
    ],
    ["isVerified", getBooleanEncoder()],
    ["verificationTimestamp", getI64Encoder()],
    ["metadataUri", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    [
      "frameworkOrigin",
      addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())
    ],
    ["supportedTokens", getArrayEncoder(getAddressEncoder())],
    ["cnftMint", getOptionEncoder(getAddressEncoder())],
    ["merkleTree", getOptionEncoder(getAddressEncoder())],
    ["supportsA2a", getBooleanEncoder()],
    ["transferHook", getOptionEncoder(getAddressEncoder())],
    ["parentAgent", getOptionEncoder(getAddressEncoder())],
    ["generation", getU32Encoder()],
    ["x402Enabled", getBooleanEncoder()],
    ["x402PaymentAddress", getAddressEncoder()],
    ["x402AcceptedTokens", getArrayEncoder(getAddressEncoder())],
    ["x402PricePerCall", getU64Encoder()],
    [
      "x402ServiceEndpoint",
      addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())
    ],
    ["x402TotalPayments", getU64Encoder()],
    ["x402TotalCalls", getU64Encoder()],
    ["lastPaymentTimestamp", getI64Encoder()],
    ["apiSpecUri", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["apiVersion", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["bump", getU8Encoder()]
  ]), (value) => ({ ...value, discriminator: AGENT_DISCRIMINATOR }));
}
function getAgentDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    ["owner", getAddressDecoder()],
    ["agentId", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["agentType", getU8Decoder()],
    ["name", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["description", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    [
      "capabilities",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    ["pricingModel", getPricingModelDecoder()],
    ["reputationScore", getU32Decoder()],
    ["totalJobsCompleted", getU32Decoder()],
    ["totalEarnings", getU64Decoder()],
    ["isActive", getBooleanDecoder()],
    ["createdAt", getI64Decoder()],
    ["updatedAt", getI64Decoder()],
    ["originalPrice", getU64Decoder()],
    ["genomeHash", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["isReplicable", getBooleanDecoder()],
    ["replicationFee", getU64Decoder()],
    [
      "serviceEndpoint",
      addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())
    ],
    ["isVerified", getBooleanDecoder()],
    ["verificationTimestamp", getI64Decoder()],
    ["metadataUri", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    [
      "frameworkOrigin",
      addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())
    ],
    ["supportedTokens", getArrayDecoder(getAddressDecoder())],
    ["cnftMint", getOptionDecoder(getAddressDecoder())],
    ["merkleTree", getOptionDecoder(getAddressDecoder())],
    ["supportsA2a", getBooleanDecoder()],
    ["transferHook", getOptionDecoder(getAddressDecoder())],
    ["parentAgent", getOptionDecoder(getAddressDecoder())],
    ["generation", getU32Decoder()],
    ["x402Enabled", getBooleanDecoder()],
    ["x402PaymentAddress", getAddressDecoder()],
    ["x402AcceptedTokens", getArrayDecoder(getAddressDecoder())],
    ["x402PricePerCall", getU64Decoder()],
    [
      "x402ServiceEndpoint",
      addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())
    ],
    ["x402TotalPayments", getU64Decoder()],
    ["x402TotalCalls", getU64Decoder()],
    ["lastPaymentTimestamp", getI64Decoder()],
    ["apiSpecUri", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["apiVersion", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["bump", getU8Decoder()]
  ]);
}
function getAgentCodec() {
  return combineCodec(getAgentEncoder(), getAgentDecoder());
}
function decodeAgent(encodedAccount) {
  return decodeAccount(encodedAccount, getAgentDecoder());
}
async function fetchAgent(rpc2, address2, config) {
  const maybeAccount = await fetchMaybeAgent(rpc2, address2, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeAgent(rpc2, address2, config) {
  const maybeAccount = await fetchEncodedAccount(rpc2, address2, config);
  return decodeAgent(maybeAccount);
}
async function fetchAllAgent(rpc2, addresses2, config) {
  const maybeAccounts = await fetchAllMaybeAgent(rpc2, addresses2, config);
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeAgent(rpc2, addresses2, config) {
  const maybeAccounts = await fetchEncodedAccounts(rpc2, addresses2, config);
  return maybeAccounts.map((maybeAccount) => decodeAgent(maybeAccount));
}
var AccessTier, ActivationRequirementType, ActionType, AuditAction, AuthenticationLevel, AuthenticationMethod, BackupFrequency, BiometricStorageMethod, BiometricType, ConditionType, ConstraintOperator, CredentialKind, CredentialStatus, CrossChainStatus, DataAccessLevel, DegradationHandling, EnforcementLevel, EscrowStatus, MultisigType, NotificationMethod, NotificationPriority, NotificationTargetType, NotificationTiming, PermissionConstraintType, PolicyStatus, PolicyType, PricingModel, ProposalStatus, ProposalType, QuorumMethod, ReentrancyState, ReportingFrequency, ReportStatus, ReportType, RiskCategory, RiskLevel, RoleStatus, RoleType, RuleEffect, pairEncoder, pairDecoder, ScopeInheritance, ScopeType, SecurityEventType, ServiceEndpointType, SlashReason, SodConstraintType, StepUpTrigger, TimeLockType, TransactionPriority, TransactionStatus, TransactionType, TrendDirection, UnlockMethod, ValueType, VerificationMethodType, VerificationRelationship, ViolationSeverity, VoteChoice, AGENT_DISCRIMINATOR;
var init_chunk_IHVDQ4YI = __esm(() => {
  init_index_node35();
  AccessTier = /* @__PURE__ */ ((AccessTier2) => {
    AccessTier2[AccessTier2["None"] = 0] = "None";
    AccessTier2[AccessTier2["Basic"] = 1] = "Basic";
    AccessTier2[AccessTier2["Verified"] = 2] = "Verified";
    AccessTier2[AccessTier2["Pro"] = 3] = "Pro";
    AccessTier2[AccessTier2["Whale"] = 4] = "Whale";
    return AccessTier2;
  })(AccessTier || {});
  ActivationRequirementType = /* @__PURE__ */ ((ActivationRequirementType2) => {
    ActivationRequirementType2[ActivationRequirementType2["ManagerApproval"] = 0] = "ManagerApproval";
    ActivationRequirementType2[ActivationRequirementType2["PeerReview"] = 1] = "PeerReview";
    ActivationRequirementType2[ActivationRequirementType2["SecurityClearance"] = 2] = "SecurityClearance";
    ActivationRequirementType2[ActivationRequirementType2["BackgroundCheck"] = 3] = "BackgroundCheck";
    ActivationRequirementType2[ActivationRequirementType2["TrainingCompletion"] = 4] = "TrainingCompletion";
    ActivationRequirementType2[ActivationRequirementType2["CertificationRequired"] = 5] = "CertificationRequired";
    ActivationRequirementType2[ActivationRequirementType2["BusinessJustification"] = 6] = "BusinessJustification";
    ActivationRequirementType2[ActivationRequirementType2["TechnicalAssessment"] = 7] = "TechnicalAssessment";
    return ActivationRequirementType2;
  })(ActivationRequirementType || {});
  ActionType = /* @__PURE__ */ ((ActionType2) => {
    ActionType2[ActionType2["Create"] = 0] = "Create";
    ActionType2[ActionType2["Read"] = 1] = "Read";
    ActionType2[ActionType2["Update"] = 2] = "Update";
    ActionType2[ActionType2["Delete"] = 3] = "Delete";
    ActionType2[ActionType2["Execute"] = 4] = "Execute";
    ActionType2[ActionType2["Approve"] = 5] = "Approve";
    ActionType2[ActionType2["Reject"] = 6] = "Reject";
    ActionType2[ActionType2["Transfer"] = 7] = "Transfer";
    ActionType2[ActionType2["Lock"] = 8] = "Lock";
    ActionType2[ActionType2["Unlock"] = 9] = "Unlock";
    return ActionType2;
  })(ActionType || {});
  AuditAction = /* @__PURE__ */ ((AuditAction2) => {
    AuditAction2[AuditAction2["AgentRegistered"] = 0] = "AgentRegistered";
    AuditAction2[AuditAction2["AgentUpdated"] = 1] = "AgentUpdated";
    AuditAction2[AuditAction2["AgentDeactivated"] = 2] = "AgentDeactivated";
    AuditAction2[AuditAction2["AgentVerified"] = 3] = "AgentVerified";
    AuditAction2[AuditAction2["PaymentProcessed"] = 4] = "PaymentProcessed";
    AuditAction2[AuditAction2["EscrowCreated"] = 5] = "EscrowCreated";
    AuditAction2[AuditAction2["EscrowReleased"] = 6] = "EscrowReleased";
    AuditAction2[AuditAction2["FundsWithdrawn"] = 7] = "FundsWithdrawn";
    AuditAction2[AuditAction2["ProposalCreated"] = 8] = "ProposalCreated";
    AuditAction2[AuditAction2["VoteCast"] = 9] = "VoteCast";
    AuditAction2[AuditAction2["ProposalExecuted"] = 10] = "ProposalExecuted";
    AuditAction2[AuditAction2["GovernanceUpdated"] = 11] = "GovernanceUpdated";
    AuditAction2[AuditAction2["AccessGranted"] = 12] = "AccessGranted";
    AuditAction2[AuditAction2["AccessRevoked"] = 13] = "AccessRevoked";
    AuditAction2[AuditAction2["SecurityPolicyUpdated"] = 14] = "SecurityPolicyUpdated";
    AuditAction2[AuditAction2["SuspiciousActivity"] = 15] = "SuspiciousActivity";
    AuditAction2[AuditAction2["ComplianceReportGenerated"] = 16] = "ComplianceReportGenerated";
    AuditAction2[AuditAction2["RegulatorySubmission"] = 17] = "RegulatorySubmission";
    AuditAction2[AuditAction2["AuditRequested"] = 18] = "AuditRequested";
    AuditAction2[AuditAction2["ViolationDetected"] = 19] = "ViolationDetected";
    AuditAction2[AuditAction2["SystemConfigUpdated"] = 20] = "SystemConfigUpdated";
    AuditAction2[AuditAction2["EmergencyAction"] = 21] = "EmergencyAction";
    AuditAction2[AuditAction2["MaintenancePerformed"] = 22] = "MaintenancePerformed";
    AuditAction2[AuditAction2["WorkOrderCreated"] = 23] = "WorkOrderCreated";
    AuditAction2[AuditAction2["WorkOrderCompleted"] = 24] = "WorkOrderCompleted";
    AuditAction2[AuditAction2["DisputeRaised"] = 25] = "DisputeRaised";
    AuditAction2[AuditAction2["DisputeResolved"] = 26] = "DisputeResolved";
    AuditAction2[AuditAction2["MultisigCreated"] = 27] = "MultisigCreated";
    AuditAction2[AuditAction2["MultisigSigned"] = 28] = "MultisigSigned";
    AuditAction2[AuditAction2["MultisigExecuted"] = 29] = "MultisigExecuted";
    AuditAction2[AuditAction2["RiskAssessmentPerformed"] = 30] = "RiskAssessmentPerformed";
    AuditAction2[AuditAction2["RiskThresholdExceeded"] = 31] = "RiskThresholdExceeded";
    AuditAction2[AuditAction2["RiskMitigationApplied"] = 32] = "RiskMitigationApplied";
    return AuditAction2;
  })(AuditAction || {});
  AuthenticationLevel = /* @__PURE__ */ ((AuthenticationLevel2) => {
    AuthenticationLevel2[AuthenticationLevel2["Low"] = 0] = "Low";
    AuthenticationLevel2[AuthenticationLevel2["Medium"] = 1] = "Medium";
    AuthenticationLevel2[AuthenticationLevel2["High"] = 2] = "High";
    AuthenticationLevel2[AuthenticationLevel2["VeryHigh"] = 3] = "VeryHigh";
    return AuthenticationLevel2;
  })(AuthenticationLevel || {});
  AuthenticationMethod = /* @__PURE__ */ ((AuthenticationMethod2) => {
    AuthenticationMethod2[AuthenticationMethod2["Password"] = 0] = "Password";
    AuthenticationMethod2[AuthenticationMethod2["DigitalSignature"] = 1] = "DigitalSignature";
    AuthenticationMethod2[AuthenticationMethod2["Biometric"] = 2] = "Biometric";
    AuthenticationMethod2[AuthenticationMethod2["Token"] = 3] = "Token";
    AuthenticationMethod2[AuthenticationMethod2["Certificate"] = 4] = "Certificate";
    AuthenticationMethod2[AuthenticationMethod2["Sms"] = 5] = "Sms";
    AuthenticationMethod2[AuthenticationMethod2["Email"] = 6] = "Email";
    AuthenticationMethod2[AuthenticationMethod2["App"] = 7] = "App";
    AuthenticationMethod2[AuthenticationMethod2["Hardware"] = 8] = "Hardware";
    return AuthenticationMethod2;
  })(AuthenticationMethod || {});
  BackupFrequency = /* @__PURE__ */ ((BackupFrequency2) => {
    BackupFrequency2[BackupFrequency2["Hourly"] = 0] = "Hourly";
    BackupFrequency2[BackupFrequency2["Daily"] = 1] = "Daily";
    BackupFrequency2[BackupFrequency2["Weekly"] = 2] = "Weekly";
    BackupFrequency2[BackupFrequency2["Monthly"] = 3] = "Monthly";
    return BackupFrequency2;
  })(BackupFrequency || {});
  BiometricStorageMethod = /* @__PURE__ */ ((BiometricStorageMethod2) => {
    BiometricStorageMethod2[BiometricStorageMethod2["OnDevice"] = 0] = "OnDevice";
    BiometricStorageMethod2[BiometricStorageMethod2["Encrypted"] = 1] = "Encrypted";
    BiometricStorageMethod2[BiometricStorageMethod2["Hashed"] = 2] = "Hashed";
    BiometricStorageMethod2[BiometricStorageMethod2["Distributed"] = 3] = "Distributed";
    BiometricStorageMethod2[BiometricStorageMethod2["None"] = 4] = "None";
    return BiometricStorageMethod2;
  })(BiometricStorageMethod || {});
  BiometricType = /* @__PURE__ */ ((BiometricType2) => {
    BiometricType2[BiometricType2["Fingerprint"] = 0] = "Fingerprint";
    BiometricType2[BiometricType2["FaceRecognition"] = 1] = "FaceRecognition";
    BiometricType2[BiometricType2["IrisRecognition"] = 2] = "IrisRecognition";
    BiometricType2[BiometricType2["VoiceRecognition"] = 3] = "VoiceRecognition";
    BiometricType2[BiometricType2["Signature"] = 4] = "Signature";
    BiometricType2[BiometricType2["Gait"] = 5] = "Gait";
    BiometricType2[BiometricType2["Behavioral"] = 6] = "Behavioral";
    return BiometricType2;
  })(BiometricType || {});
  ConditionType = /* @__PURE__ */ ((ConditionType2) => {
    ConditionType2[ConditionType2["TimeDelay"] = 0] = "TimeDelay";
    ConditionType2[ConditionType2["TokenBalance"] = 1] = "TokenBalance";
    ConditionType2[ConditionType2["PriceThreshold"] = 2] = "PriceThreshold";
    ConditionType2[ConditionType2["VoteCount"] = 3] = "VoteCount";
    ConditionType2[ConditionType2["ExternalOracle"] = 4] = "ExternalOracle";
    ConditionType2[ConditionType2["CustomLogic"] = 5] = "CustomLogic";
    return ConditionType2;
  })(ConditionType || {});
  ConstraintOperator = /* @__PURE__ */ ((ConstraintOperator2) => {
    ConstraintOperator2[ConstraintOperator2["Equals"] = 0] = "Equals";
    ConstraintOperator2[ConstraintOperator2["NotEquals"] = 1] = "NotEquals";
    ConstraintOperator2[ConstraintOperator2["GreaterThan"] = 2] = "GreaterThan";
    ConstraintOperator2[ConstraintOperator2["LessThan"] = 3] = "LessThan";
    ConstraintOperator2[ConstraintOperator2["GreaterThanOrEqual"] = 4] = "GreaterThanOrEqual";
    ConstraintOperator2[ConstraintOperator2["LessThanOrEqual"] = 5] = "LessThanOrEqual";
    ConstraintOperator2[ConstraintOperator2["Contains"] = 6] = "Contains";
    ConstraintOperator2[ConstraintOperator2["NotContains"] = 7] = "NotContains";
    ConstraintOperator2[ConstraintOperator2["In"] = 8] = "In";
    ConstraintOperator2[ConstraintOperator2["NotIn"] = 9] = "NotIn";
    ConstraintOperator2[ConstraintOperator2["Matches"] = 10] = "Matches";
    ConstraintOperator2[ConstraintOperator2["NotMatches"] = 11] = "NotMatches";
    return ConstraintOperator2;
  })(ConstraintOperator || {});
  CredentialKind = /* @__PURE__ */ ((CredentialKind2) => {
    CredentialKind2[CredentialKind2["AgentIdentity"] = 0] = "AgentIdentity";
    CredentialKind2[CredentialKind2["ReputationScore"] = 1] = "ReputationScore";
    CredentialKind2[CredentialKind2["JobCompletion"] = 2] = "JobCompletion";
    CredentialKind2[CredentialKind2["DelegatedSigner"] = 3] = "DelegatedSigner";
    CredentialKind2[CredentialKind2["Custom"] = 4] = "Custom";
    return CredentialKind2;
  })(CredentialKind || {});
  CredentialStatus = /* @__PURE__ */ ((CredentialStatus2) => {
    CredentialStatus2[CredentialStatus2["Pending"] = 0] = "Pending";
    CredentialStatus2[CredentialStatus2["Active"] = 1] = "Active";
    CredentialStatus2[CredentialStatus2["Revoked"] = 2] = "Revoked";
    CredentialStatus2[CredentialStatus2["Expired"] = 3] = "Expired";
    return CredentialStatus2;
  })(CredentialStatus || {});
  CrossChainStatus = /* @__PURE__ */ ((CrossChainStatus2) => {
    CrossChainStatus2[CrossChainStatus2["NotSynced"] = 0] = "NotSynced";
    CrossChainStatus2[CrossChainStatus2["SyncPending"] = 1] = "SyncPending";
    CrossChainStatus2[CrossChainStatus2["SyncedToCrossmint"] = 2] = "SyncedToCrossmint";
    CrossChainStatus2[CrossChainStatus2["SyncFailed"] = 3] = "SyncFailed";
    return CrossChainStatus2;
  })(CrossChainStatus || {});
  DataAccessLevel = /* @__PURE__ */ ((DataAccessLevel2) => {
    DataAccessLevel2[DataAccessLevel2["Public"] = 0] = "Public";
    DataAccessLevel2[DataAccessLevel2["Internal"] = 1] = "Internal";
    DataAccessLevel2[DataAccessLevel2["Confidential"] = 2] = "Confidential";
    DataAccessLevel2[DataAccessLevel2["Restricted"] = 3] = "Restricted";
    DataAccessLevel2[DataAccessLevel2["TopSecret"] = 4] = "TopSecret";
    return DataAccessLevel2;
  })(DataAccessLevel || {});
  DegradationHandling = /* @__PURE__ */ ((DegradationHandling2) => {
    DegradationHandling2[DegradationHandling2["RequireRefresh"] = 0] = "RequireRefresh";
    DegradationHandling2[DegradationHandling2["GradualDegradation"] = 1] = "GradualDegradation";
    DegradationHandling2[DegradationHandling2["ImmediateExpiry"] = 2] = "ImmediateExpiry";
    DegradationHandling2[DegradationHandling2["AdaptiveThreshold"] = 3] = "AdaptiveThreshold";
    return DegradationHandling2;
  })(DegradationHandling || {});
  EnforcementLevel = /* @__PURE__ */ ((EnforcementLevel2) => {
    EnforcementLevel2[EnforcementLevel2["Hard"] = 0] = "Hard";
    EnforcementLevel2[EnforcementLevel2["Soft"] = 1] = "Soft";
    EnforcementLevel2[EnforcementLevel2["Advisory"] = 2] = "Advisory";
    EnforcementLevel2[EnforcementLevel2["ExceptionBased"] = 3] = "ExceptionBased";
    return EnforcementLevel2;
  })(EnforcementLevel || {});
  EscrowStatus = /* @__PURE__ */ ((EscrowStatus2) => {
    EscrowStatus2[EscrowStatus2["Active"] = 0] = "Active";
    EscrowStatus2[EscrowStatus2["Completed"] = 1] = "Completed";
    EscrowStatus2[EscrowStatus2["Disputed"] = 2] = "Disputed";
    EscrowStatus2[EscrowStatus2["Cancelled"] = 3] = "Cancelled";
    return EscrowStatus2;
  })(EscrowStatus || {});
  MultisigType = /* @__PURE__ */ ((MultisigType2) => {
    MultisigType2[MultisigType2["Protocol"] = 0] = "Protocol";
    MultisigType2[MultisigType2["Dao"] = 1] = "Dao";
    MultisigType2[MultisigType2["Dispute"] = 2] = "Dispute";
    MultisigType2[MultisigType2["AgentConsortium"] = 3] = "AgentConsortium";
    MultisigType2[MultisigType2["AgentTreasury"] = 4] = "AgentTreasury";
    MultisigType2[MultisigType2["Custom"] = 5] = "Custom";
    return MultisigType2;
  })(MultisigType || {});
  NotificationMethod = /* @__PURE__ */ ((NotificationMethod2) => {
    NotificationMethod2[NotificationMethod2["OnChain"] = 0] = "OnChain";
    NotificationMethod2[NotificationMethod2["Email"] = 1] = "Email";
    NotificationMethod2[NotificationMethod2["Sms"] = 2] = "Sms";
    NotificationMethod2[NotificationMethod2["Push"] = 3] = "Push";
    NotificationMethod2[NotificationMethod2["InApp"] = 4] = "InApp";
    NotificationMethod2[NotificationMethod2["All"] = 5] = "All";
    return NotificationMethod2;
  })(NotificationMethod || {});
  NotificationPriority = /* @__PURE__ */ ((NotificationPriority2) => {
    NotificationPriority2[NotificationPriority2["Low"] = 0] = "Low";
    NotificationPriority2[NotificationPriority2["Medium"] = 1] = "Medium";
    NotificationPriority2[NotificationPriority2["High"] = 2] = "High";
    NotificationPriority2[NotificationPriority2["Critical"] = 3] = "Critical";
    NotificationPriority2[NotificationPriority2["Emergency"] = 4] = "Emergency";
    return NotificationPriority2;
  })(NotificationPriority || {});
  NotificationTargetType = /* @__PURE__ */ ((NotificationTargetType2) => {
    NotificationTargetType2[NotificationTargetType2["User"] = 0] = "User";
    NotificationTargetType2[NotificationTargetType2["Administrator"] = 1] = "Administrator";
    NotificationTargetType2[NotificationTargetType2["SecurityTeam"] = 2] = "SecurityTeam";
    NotificationTargetType2[NotificationTargetType2["ComplianceTeam"] = 3] = "ComplianceTeam";
    NotificationTargetType2[NotificationTargetType2["Manager"] = 4] = "Manager";
    NotificationTargetType2[NotificationTargetType2["AuditTeam"] = 5] = "AuditTeam";
    NotificationTargetType2[NotificationTargetType2["ExternalSystem"] = 6] = "ExternalSystem";
    return NotificationTargetType2;
  })(NotificationTargetType || {});
  NotificationTiming = /* @__PURE__ */ ((NotificationTiming2) => {
    NotificationTiming2[NotificationTiming2["Immediate"] = 0] = "Immediate";
    NotificationTiming2[NotificationTiming2["Delayed"] = 1] = "Delayed";
    NotificationTiming2[NotificationTiming2["Batched"] = 2] = "Batched";
    NotificationTiming2[NotificationTiming2["Scheduled"] = 3] = "Scheduled";
    return NotificationTiming2;
  })(NotificationTiming || {});
  PermissionConstraintType = /* @__PURE__ */ ((PermissionConstraintType2) => {
    PermissionConstraintType2[PermissionConstraintType2["Temporal"] = 0] = "Temporal";
    PermissionConstraintType2[PermissionConstraintType2["Contextual"] = 1] = "Contextual";
    PermissionConstraintType2[PermissionConstraintType2["Conditional"] = 2] = "Conditional";
    PermissionConstraintType2[PermissionConstraintType2["ResourceBased"] = 3] = "ResourceBased";
    PermissionConstraintType2[PermissionConstraintType2["AttributeBased"] = 4] = "AttributeBased";
    PermissionConstraintType2[PermissionConstraintType2["RiskBased"] = 5] = "RiskBased";
    return PermissionConstraintType2;
  })(PermissionConstraintType || {});
  PolicyStatus = /* @__PURE__ */ ((PolicyStatus2) => {
    PolicyStatus2[PolicyStatus2["Active"] = 0] = "Active";
    PolicyStatus2[PolicyStatus2["Inactive"] = 1] = "Inactive";
    PolicyStatus2[PolicyStatus2["Draft"] = 2] = "Draft";
    PolicyStatus2[PolicyStatus2["UnderReview"] = 3] = "UnderReview";
    PolicyStatus2[PolicyStatus2["Deprecated"] = 4] = "Deprecated";
    PolicyStatus2[PolicyStatus2["Suspended"] = 5] = "Suspended";
    return PolicyStatus2;
  })(PolicyStatus || {});
  PolicyType = /* @__PURE__ */ ((PolicyType2) => {
    PolicyType2[PolicyType2["Allow"] = 0] = "Allow";
    PolicyType2[PolicyType2["Deny"] = 1] = "Deny";
    PolicyType2[PolicyType2["Conditional"] = 2] = "Conditional";
    PolicyType2[PolicyType2["Delegated"] = 3] = "Delegated";
    PolicyType2[PolicyType2["Temporary"] = 4] = "Temporary";
    PolicyType2[PolicyType2["Emergency"] = 5] = "Emergency";
    return PolicyType2;
  })(PolicyType || {});
  PricingModel = /* @__PURE__ */ ((PricingModel2) => {
    PricingModel2[PricingModel2["Fixed"] = 0] = "Fixed";
    PricingModel2[PricingModel2["Hourly"] = 1] = "Hourly";
    PricingModel2[PricingModel2["PerTask"] = 2] = "PerTask";
    PricingModel2[PricingModel2["Subscription"] = 3] = "Subscription";
    PricingModel2[PricingModel2["Auction"] = 4] = "Auction";
    PricingModel2[PricingModel2["Dynamic"] = 5] = "Dynamic";
    PricingModel2[PricingModel2["RevenueShare"] = 6] = "RevenueShare";
    PricingModel2[PricingModel2["Tiered"] = 7] = "Tiered";
    return PricingModel2;
  })(PricingModel || {});
  ProposalStatus = /* @__PURE__ */ ((ProposalStatus2) => {
    ProposalStatus2[ProposalStatus2["Draft"] = 0] = "Draft";
    ProposalStatus2[ProposalStatus2["Active"] = 1] = "Active";
    ProposalStatus2[ProposalStatus2["Passed"] = 2] = "Passed";
    ProposalStatus2[ProposalStatus2["Failed"] = 3] = "Failed";
    ProposalStatus2[ProposalStatus2["Executed"] = 4] = "Executed";
    ProposalStatus2[ProposalStatus2["Cancelled"] = 5] = "Cancelled";
    ProposalStatus2[ProposalStatus2["Expired"] = 6] = "Expired";
    ProposalStatus2[ProposalStatus2["Queued"] = 7] = "Queued";
    return ProposalStatus2;
  })(ProposalStatus || {});
  ProposalType = /* @__PURE__ */ ((ProposalType2) => {
    ProposalType2[ProposalType2["ParameterUpdate"] = 0] = "ParameterUpdate";
    ProposalType2[ProposalType2["ProtocolUpgrade"] = 1] = "ProtocolUpgrade";
    ProposalType2[ProposalType2["TreasuryOperation"] = 2] = "TreasuryOperation";
    ProposalType2[ProposalType2["FeeUpdate"] = 3] = "FeeUpdate";
    ProposalType2[ProposalType2["SecurityUpdate"] = 4] = "SecurityUpdate";
    ProposalType2[ProposalType2["GovernanceUpdate"] = 5] = "GovernanceUpdate";
    ProposalType2[ProposalType2["EmergencyAction"] = 6] = "EmergencyAction";
    ProposalType2[ProposalType2["Custom"] = 7] = "Custom";
    return ProposalType2;
  })(ProposalType || {});
  QuorumMethod = /* @__PURE__ */ ((QuorumMethod2) => {
    QuorumMethod2[QuorumMethod2["Absolute"] = 0] = "Absolute";
    QuorumMethod2[QuorumMethod2["Relative"] = 1] = "Relative";
    QuorumMethod2[QuorumMethod2["Weighted"] = 2] = "Weighted";
    QuorumMethod2[QuorumMethod2["Dynamic"] = 3] = "Dynamic";
    return QuorumMethod2;
  })(QuorumMethod || {});
  ReentrancyState = /* @__PURE__ */ ((ReentrancyState2) => {
    ReentrancyState2[ReentrancyState2["Unlocked"] = 0] = "Unlocked";
    ReentrancyState2[ReentrancyState2["Locked"] = 1] = "Locked";
    return ReentrancyState2;
  })(ReentrancyState || {});
  ReportingFrequency = /* @__PURE__ */ ((ReportingFrequency2) => {
    ReportingFrequency2[ReportingFrequency2["Daily"] = 0] = "Daily";
    ReportingFrequency2[ReportingFrequency2["Weekly"] = 1] = "Weekly";
    ReportingFrequency2[ReportingFrequency2["Monthly"] = 2] = "Monthly";
    ReportingFrequency2[ReportingFrequency2["Quarterly"] = 3] = "Quarterly";
    ReportingFrequency2[ReportingFrequency2["Annually"] = 4] = "Annually";
    ReportingFrequency2[ReportingFrequency2["OnDemand"] = 5] = "OnDemand";
    return ReportingFrequency2;
  })(ReportingFrequency || {});
  ReportStatus = /* @__PURE__ */ ((ReportStatus2) => {
    ReportStatus2[ReportStatus2["Draft"] = 0] = "Draft";
    ReportStatus2[ReportStatus2["Generated"] = 1] = "Generated";
    ReportStatus2[ReportStatus2["Reviewed"] = 2] = "Reviewed";
    ReportStatus2[ReportStatus2["Approved"] = 3] = "Approved";
    ReportStatus2[ReportStatus2["Submitted"] = 4] = "Submitted";
    ReportStatus2[ReportStatus2["Acknowledged"] = 5] = "Acknowledged";
    ReportStatus2[ReportStatus2["Rejected"] = 6] = "Rejected";
    return ReportStatus2;
  })(ReportStatus || {});
  ReportType = /* @__PURE__ */ ((ReportType2) => {
    ReportType2[ReportType2["FinancialTransactions"] = 0] = "FinancialTransactions";
    ReportType2[ReportType2["SuspiciousActivity"] = 1] = "SuspiciousActivity";
    ReportType2[ReportType2["RegulatoryCompliance"] = 2] = "RegulatoryCompliance";
    ReportType2[ReportType2["SecurityIncidents"] = 3] = "SecurityIncidents";
    ReportType2[ReportType2["AuditSummary"] = 4] = "AuditSummary";
    ReportType2[ReportType2["RiskAssessment"] = 5] = "RiskAssessment";
    ReportType2[ReportType2["GovernanceActivity"] = 6] = "GovernanceActivity";
    ReportType2[ReportType2["DataPrivacyCompliance"] = 7] = "DataPrivacyCompliance";
    return ReportType2;
  })(ReportType || {});
  RiskCategory = /* @__PURE__ */ ((RiskCategory2) => {
    RiskCategory2[RiskCategory2["Operational"] = 0] = "Operational";
    RiskCategory2[RiskCategory2["Financial"] = 1] = "Financial";
    RiskCategory2[RiskCategory2["Compliance"] = 2] = "Compliance";
    RiskCategory2[RiskCategory2["Security"] = 3] = "Security";
    RiskCategory2[RiskCategory2["Reputational"] = 4] = "Reputational";
    RiskCategory2[RiskCategory2["Technical"] = 5] = "Technical";
    RiskCategory2[RiskCategory2["Legal"] = 6] = "Legal";
    return RiskCategory2;
  })(RiskCategory || {});
  RiskLevel = /* @__PURE__ */ ((RiskLevel2) => {
    RiskLevel2[RiskLevel2["Low"] = 0] = "Low";
    RiskLevel2[RiskLevel2["Medium"] = 1] = "Medium";
    RiskLevel2[RiskLevel2["High"] = 2] = "High";
    RiskLevel2[RiskLevel2["Critical"] = 3] = "Critical";
    return RiskLevel2;
  })(RiskLevel || {});
  RoleStatus = /* @__PURE__ */ ((RoleStatus2) => {
    RoleStatus2[RoleStatus2["Active"] = 0] = "Active";
    RoleStatus2[RoleStatus2["Inactive"] = 1] = "Inactive";
    RoleStatus2[RoleStatus2["Deprecated"] = 2] = "Deprecated";
    RoleStatus2[RoleStatus2["UnderReview"] = 3] = "UnderReview";
    RoleStatus2[RoleStatus2["Suspended"] = 4] = "Suspended";
    return RoleStatus2;
  })(RoleStatus || {});
  RoleType = /* @__PURE__ */ ((RoleType2) => {
    RoleType2[RoleType2["Administrative"] = 0] = "Administrative";
    RoleType2[RoleType2["Operational"] = 1] = "Operational";
    RoleType2[RoleType2["ReadOnly"] = 2] = "ReadOnly";
    RoleType2[RoleType2["Compliance"] = 3] = "Compliance";
    RoleType2[RoleType2["Emergency"] = 4] = "Emergency";
    RoleType2[RoleType2["Custom"] = 5] = "Custom";
    RoleType2[RoleType2["Service"] = 6] = "Service";
    RoleType2[RoleType2["Guest"] = 7] = "Guest";
    return RoleType2;
  })(RoleType || {});
  RuleEffect = /* @__PURE__ */ ((RuleEffect2) => {
    RuleEffect2[RuleEffect2["Allow"] = 0] = "Allow";
    RuleEffect2[RuleEffect2["Deny"] = 1] = "Deny";
    RuleEffect2[RuleEffect2["AuditOnly"] = 2] = "AuditOnly";
    RuleEffect2[RuleEffect2["RequireApproval"] = 3] = "RequireApproval";
    RuleEffect2[RuleEffect2["RequireMfa"] = 4] = "RequireMfa";
    RuleEffect2[RuleEffect2["RequireJustification"] = 5] = "RequireJustification";
    return RuleEffect2;
  })(RuleEffect || {});
  pairEncoder = getStructEncoder([
    ["0", getUtf8Encoder()],
    ["1", getUtf8Encoder()]
  ]);
  pairDecoder = getStructDecoder([
    ["0", getUtf8Decoder()],
    ["1", getUtf8Decoder()]
  ]);
  ScopeInheritance = /* @__PURE__ */ ((ScopeInheritance2) => {
    ScopeInheritance2[ScopeInheritance2["None"] = 0] = "None";
    ScopeInheritance2[ScopeInheritance2["Hierarchical"] = 1] = "Hierarchical";
    ScopeInheritance2[ScopeInheritance2["Delegated"] = 2] = "Delegated";
    ScopeInheritance2[ScopeInheritance2["Inherited"] = 3] = "Inherited";
    return ScopeInheritance2;
  })(ScopeInheritance || {});
  ScopeType = /* @__PURE__ */ ((ScopeType2) => {
    ScopeType2[ScopeType2["Global"] = 0] = "Global";
    ScopeType2[ScopeType2["Organization"] = 1] = "Organization";
    ScopeType2[ScopeType2["Department"] = 2] = "Department";
    ScopeType2[ScopeType2["Project"] = 3] = "Project";
    ScopeType2[ScopeType2["Resource"] = 4] = "Resource";
    ScopeType2[ScopeType2["Individual"] = 5] = "Individual";
    return ScopeType2;
  })(ScopeType || {});
  SecurityEventType = /* @__PURE__ */ ((SecurityEventType2) => {
    SecurityEventType2[SecurityEventType2["AccountLockout"] = 0] = "AccountLockout";
    SecurityEventType2[SecurityEventType2["PasswordChange"] = 1] = "PasswordChange";
    SecurityEventType2[SecurityEventType2["PrivilegeEscalation"] = 2] = "PrivilegeEscalation";
    SecurityEventType2[SecurityEventType2["SuspiciousActivity"] = 3] = "SuspiciousActivity";
    SecurityEventType2[SecurityEventType2["PolicyViolation"] = 4] = "PolicyViolation";
    SecurityEventType2[SecurityEventType2["AccessDenied"] = 5] = "AccessDenied";
    SecurityEventType2[SecurityEventType2["DataBreach"] = 6] = "DataBreach";
    SecurityEventType2[SecurityEventType2["SystemCompromise"] = 7] = "SystemCompromise";
    return SecurityEventType2;
  })(SecurityEventType || {});
  ServiceEndpointType = /* @__PURE__ */ ((ServiceEndpointType2) => {
    ServiceEndpointType2[ServiceEndpointType2["AIAgentService"] = 0] = "AIAgentService";
    ServiceEndpointType2[ServiceEndpointType2["DIDCommMessaging"] = 1] = "DIDCommMessaging";
    ServiceEndpointType2[ServiceEndpointType2["CredentialRepository"] = 2] = "CredentialRepository";
    ServiceEndpointType2[ServiceEndpointType2["LinkedDomains"] = 3] = "LinkedDomains";
    ServiceEndpointType2[ServiceEndpointType2["Custom"] = 4] = "Custom";
    return ServiceEndpointType2;
  })(ServiceEndpointType || {});
  SlashReason = /* @__PURE__ */ ((SlashReason2) => {
    SlashReason2[SlashReason2["Fraud"] = 0] = "Fraud";
    SlashReason2[SlashReason2["DisputeLoss"] = 1] = "DisputeLoss";
    SlashReason2[SlashReason2["Custom"] = 2] = "Custom";
    return SlashReason2;
  })(SlashReason || {});
  SodConstraintType = /* @__PURE__ */ ((SodConstraintType2) => {
    SodConstraintType2[SodConstraintType2["Static"] = 0] = "Static";
    SodConstraintType2[SodConstraintType2["Dynamic"] = 1] = "Dynamic";
    SodConstraintType2[SodConstraintType2["Temporal"] = 2] = "Temporal";
    SodConstraintType2[SodConstraintType2["Contextual"] = 3] = "Contextual";
    return SodConstraintType2;
  })(SodConstraintType || {});
  StepUpTrigger = /* @__PURE__ */ ((StepUpTrigger2) => {
    StepUpTrigger2[StepUpTrigger2["HighRiskAction"] = 0] = "HighRiskAction";
    StepUpTrigger2[StepUpTrigger2["SensitiveData"] = 1] = "SensitiveData";
    StepUpTrigger2[StepUpTrigger2["LargeTransaction"] = 2] = "LargeTransaction";
    StepUpTrigger2[StepUpTrigger2["NewDevice"] = 3] = "NewDevice";
    StepUpTrigger2[StepUpTrigger2["UnusualLocation"] = 4] = "UnusualLocation";
    StepUpTrigger2[StepUpTrigger2["TimeBasedRisk"] = 5] = "TimeBasedRisk";
    StepUpTrigger2[StepUpTrigger2["BehaviorAnomaly"] = 6] = "BehaviorAnomaly";
    return StepUpTrigger2;
  })(StepUpTrigger || {});
  TimeLockType = /* @__PURE__ */ ((TimeLockType2) => {
    TimeLockType2[TimeLockType2["Standard"] = 0] = "Standard";
    TimeLockType2[TimeLockType2["Vesting"] = 1] = "Vesting";
    TimeLockType2[TimeLockType2["Emergency"] = 2] = "Emergency";
    TimeLockType2[TimeLockType2["Governance"] = 3] = "Governance";
    return TimeLockType2;
  })(TimeLockType || {});
  TransactionPriority = /* @__PURE__ */ ((TransactionPriority2) => {
    TransactionPriority2[TransactionPriority2["Low"] = 0] = "Low";
    TransactionPriority2[TransactionPriority2["Normal"] = 1] = "Normal";
    TransactionPriority2[TransactionPriority2["High"] = 2] = "High";
    TransactionPriority2[TransactionPriority2["Critical"] = 3] = "Critical";
    TransactionPriority2[TransactionPriority2["Emergency"] = 4] = "Emergency";
    return TransactionPriority2;
  })(TransactionPriority || {});
  TransactionStatus = /* @__PURE__ */ ((TransactionStatus2) => {
    TransactionStatus2[TransactionStatus2["Pending"] = 0] = "Pending";
    TransactionStatus2[TransactionStatus2["PartiallyApproved"] = 1] = "PartiallyApproved";
    TransactionStatus2[TransactionStatus2["FullyApproved"] = 2] = "FullyApproved";
    TransactionStatus2[TransactionStatus2["Executed"] = 3] = "Executed";
    TransactionStatus2[TransactionStatus2["Cancelled"] = 4] = "Cancelled";
    TransactionStatus2[TransactionStatus2["Expired"] = 5] = "Expired";
    TransactionStatus2[TransactionStatus2["Failed"] = 6] = "Failed";
    return TransactionStatus2;
  })(TransactionStatus || {});
  TransactionType = /* @__PURE__ */ ((TransactionType2) => {
    TransactionType2[TransactionType2["Transfer"] = 0] = "Transfer";
    TransactionType2[TransactionType2["Withdrawal"] = 1] = "Withdrawal";
    TransactionType2[TransactionType2["EscrowRelease"] = 2] = "EscrowRelease";
    TransactionType2[TransactionType2["ProposalCreation"] = 3] = "ProposalCreation";
    TransactionType2[TransactionType2["VoteExecution"] = 4] = "VoteExecution";
    TransactionType2[TransactionType2["ParameterUpdate"] = 5] = "ParameterUpdate";
    TransactionType2[TransactionType2["SignerAddition"] = 6] = "SignerAddition";
    TransactionType2[TransactionType2["SignerRemoval"] = 7] = "SignerRemoval";
    TransactionType2[TransactionType2["ThresholdUpdate"] = 8] = "ThresholdUpdate";
    TransactionType2[TransactionType2["ConfigUpdate"] = 9] = "ConfigUpdate";
    TransactionType2[TransactionType2["EmergencyFreeze"] = 10] = "EmergencyFreeze";
    TransactionType2[TransactionType2["EmergencyUnfreeze"] = 11] = "EmergencyUnfreeze";
    TransactionType2[TransactionType2["SecurityPolicyUpdate"] = 12] = "SecurityPolicyUpdate";
    TransactionType2[TransactionType2["ProtocolUpgrade"] = 13] = "ProtocolUpgrade";
    TransactionType2[TransactionType2["FeatureToggle"] = 14] = "FeatureToggle";
    TransactionType2[TransactionType2["RiskParameterUpdate"] = 15] = "RiskParameterUpdate";
    TransactionType2[TransactionType2["CustomInstruction"] = 16] = "CustomInstruction";
    return TransactionType2;
  })(TransactionType || {});
  TrendDirection = /* @__PURE__ */ ((TrendDirection2) => {
    TrendDirection2[TrendDirection2["Increasing"] = 0] = "Increasing";
    TrendDirection2[TrendDirection2["Decreasing"] = 1] = "Decreasing";
    TrendDirection2[TrendDirection2["Stable"] = 2] = "Stable";
    TrendDirection2[TrendDirection2["Unknown"] = 3] = "Unknown";
    return TrendDirection2;
  })(TrendDirection || {});
  UnlockMethod = /* @__PURE__ */ ((UnlockMethod2) => {
    UnlockMethod2[UnlockMethod2["TimeBasedAutoUnlock"] = 0] = "TimeBasedAutoUnlock";
    UnlockMethod2[UnlockMethod2["AdminUnlock"] = 1] = "AdminUnlock";
    UnlockMethod2[UnlockMethod2["SelfServiceUnlock"] = 2] = "SelfServiceUnlock";
    UnlockMethod2[UnlockMethod2["MultiFactorUnlock"] = 3] = "MultiFactorUnlock";
    UnlockMethod2[UnlockMethod2["SupervisorUnlock"] = 4] = "SupervisorUnlock";
    return UnlockMethod2;
  })(UnlockMethod || {});
  ValueType = /* @__PURE__ */ ((ValueType2) => {
    ValueType2[ValueType2["String"] = 0] = "String";
    ValueType2[ValueType2["Number"] = 1] = "Number";
    ValueType2[ValueType2["Boolean"] = 2] = "Boolean";
    ValueType2[ValueType2["Date"] = 3] = "Date";
    ValueType2[ValueType2["Time"] = 4] = "Time";
    ValueType2[ValueType2["Duration"] = 5] = "Duration";
    ValueType2[ValueType2["List"] = 6] = "List";
    ValueType2[ValueType2["Object"] = 7] = "Object";
    return ValueType2;
  })(ValueType || {});
  VerificationMethodType = /* @__PURE__ */ ((VerificationMethodType2) => {
    VerificationMethodType2[VerificationMethodType2["Ed25519VerificationKey2020"] = 0] = "Ed25519VerificationKey2020";
    VerificationMethodType2[VerificationMethodType2["X25519KeyAgreementKey2020"] = 1] = "X25519KeyAgreementKey2020";
    VerificationMethodType2[VerificationMethodType2["EcdsaSecp256k1VerificationKey2019"] = 2] = "EcdsaSecp256k1VerificationKey2019";
    return VerificationMethodType2;
  })(VerificationMethodType || {});
  VerificationRelationship = /* @__PURE__ */ ((VerificationRelationship2) => {
    VerificationRelationship2[VerificationRelationship2["Authentication"] = 0] = "Authentication";
    VerificationRelationship2[VerificationRelationship2["AssertionMethod"] = 1] = "AssertionMethod";
    VerificationRelationship2[VerificationRelationship2["KeyAgreement"] = 2] = "KeyAgreement";
    VerificationRelationship2[VerificationRelationship2["CapabilityInvocation"] = 3] = "CapabilityInvocation";
    VerificationRelationship2[VerificationRelationship2["CapabilityDelegation"] = 4] = "CapabilityDelegation";
    return VerificationRelationship2;
  })(VerificationRelationship || {});
  ViolationSeverity = /* @__PURE__ */ ((ViolationSeverity2) => {
    ViolationSeverity2[ViolationSeverity2["Low"] = 0] = "Low";
    ViolationSeverity2[ViolationSeverity2["Medium"] = 1] = "Medium";
    ViolationSeverity2[ViolationSeverity2["High"] = 2] = "High";
    ViolationSeverity2[ViolationSeverity2["Critical"] = 3] = "Critical";
    return ViolationSeverity2;
  })(ViolationSeverity || {});
  VoteChoice = /* @__PURE__ */ ((VoteChoice2) => {
    VoteChoice2[VoteChoice2["For"] = 0] = "For";
    VoteChoice2[VoteChoice2["Against"] = 1] = "Against";
    VoteChoice2[VoteChoice2["Abstain"] = 2] = "Abstain";
    return VoteChoice2;
  })(VoteChoice || {});
  AGENT_DISCRIMINATOR = new Uint8Array([
    47,
    166,
    112,
    147,
    155,
    197,
    86,
    7
  ]);
});

// ../packages/sdk-typescript/dist/chunk-AL3HQN73.js
function identifyGhostspeakMarketplaceAccount(account) {
  const data2 = "data" in account ? account.data : account;
  if (containsBytes(data2, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([47, 166, 112, 147, 155, 197, 86, 7])), 0)) {
    return 0;
  }
  if (containsBytes(data2, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([30, 249, 165, 44, 155, 194, 188, 175])), 0)) {
    return 1;
  }
  if (containsBytes(data2, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([145, 145, 156, 0, 197, 232, 130, 245])), 0)) {
    return 2;
  }
  if (containsBytes(data2, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([128, 155, 95, 241, 66, 207, 166, 59])), 0)) {
    return 3;
  }
  if (containsBytes(data2, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([171, 223, 253, 181, 134, 88, 66, 26])), 0)) {
    return 4;
  }
  if (containsBytes(data2, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([109, 102, 102, 17, 210, 84, 85, 210])), 0)) {
    return 5;
  }
  if (containsBytes(data2, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([75, 146, 78, 26, 130, 240, 228, 35])), 0)) {
    return 6;
  }
  if (containsBytes(data2, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([145, 44, 68, 220, 67, 46, 100, 135])), 0)) {
    return 7;
  }
  if (containsBytes(data2, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([229, 129, 99, 91, 179, 207, 66, 75])), 0)) {
    return 8;
  }
  if (containsBytes(data2, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([132, 171, 20, 181, 39, 219, 217, 112])), 0)) {
    return 9;
  }
  if (containsBytes(data2, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([109, 220, 168, 224, 33, 173, 192, 166])), 0)) {
    return 10;
  }
  if (containsBytes(data2, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([38, 0, 98, 160, 102, 4, 51, 160])), 0)) {
    return 11;
  }
  if (containsBytes(data2, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([53, 107, 240, 190, 43, 73, 65, 143])), 0)) {
    return 12;
  }
  if (containsBytes(data2, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([224, 116, 121, 186, 68, 161, 79, 236])), 0)) {
    return 13;
  }
  if (containsBytes(data2, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([207, 91, 250, 28, 152, 179, 215, 209])), 0)) {
    return 14;
  }
  if (containsBytes(data2, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([177, 94, 184, 202, 221, 112, 110, 38])), 0)) {
    return 15;
  }
  if (containsBytes(data2, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([207, 227, 141, 11, 194, 21, 193, 32])), 0)) {
    return 16;
  }
  if (containsBytes(data2, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([8, 160, 71, 30, 66, 150, 108, 33])), 0)) {
    return 17;
  }
  if (containsBytes(data2, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([52, 178, 251, 157, 180, 186, 98, 234])), 0)) {
    return 18;
  }
  if (containsBytes(data2, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([45, 134, 252, 82, 37, 57, 84, 25])), 0)) {
    return 19;
  }
  if (containsBytes(data2, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([37, 84, 98, 14, 130, 63, 210, 138])), 0)) {
    return 20;
  }
  throw new Error("The provided account could not be identified as a ghostspeakMarketplace account.");
}
function identifyGhostspeakMarketplaceInstruction(instruction) {
  const data2 = "data" in instruction ? instruction.data : instruction;
  if (containsBytes(data2, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([252, 139, 87, 21, 195, 152, 29, 217])), 0)) {
    return 0;
  }
  if (containsBytes(data2, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([28, 233, 51, 115, 33, 220, 41, 28])), 0)) {
    return 1;
  }
  if (containsBytes(data2, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([225, 89, 166, 101, 215, 40, 191, 4])), 0)) {
    return 2;
  }
  if (containsBytes(data2, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([48, 219, 232, 202, 151, 97, 230, 20])), 0)) {
    return 3;
  }
  if (containsBytes(data2, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([183, 109, 12, 128, 134, 8, 139, 144])), 0)) {
    return 4;
  }
  if (containsBytes(data2, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([211, 208, 67, 175, 20, 248, 8, 227])), 0)) {
    return 5;
  }
  if (containsBytes(data2, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([253, 40, 200, 239, 69, 147, 82, 182])), 0)) {
    return 6;
  }
  if (containsBytes(data2, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([253, 215, 165, 116, 36, 108, 68, 80])), 0)) {
    return 7;
  }
  if (containsBytes(data2, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([148, 146, 240, 10, 226, 215, 167, 174])), 0)) {
    return 8;
  }
  if (containsBytes(data2, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([205, 171, 239, 225, 82, 126, 96, 166])), 0)) {
    return 9;
  }
  if (containsBytes(data2, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([177, 8, 195, 104, 56, 34, 84, 162])), 0)) {
    return 10;
  }
  if (containsBytes(data2, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([110, 174, 221, 244, 36, 206, 60, 237])), 0)) {
    return 11;
  }
  if (containsBytes(data2, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([77, 13, 56, 161, 67, 155, 206, 119])), 0)) {
    return 12;
  }
  if (containsBytes(data2, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([9, 115, 79, 19, 158, 209, 221, 38])), 0)) {
    return 13;
  }
  if (containsBytes(data2, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([210, 63, 221, 114, 212, 97, 195, 156])), 0)) {
    return 14;
  }
  if (containsBytes(data2, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([213, 97, 79, 234, 22, 228, 14, 32])), 0)) {
    return 15;
  }
  if (containsBytes(data2, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([156, 109, 115, 85, 12, 60, 245, 99])), 0)) {
    return 16;
  }
  if (containsBytes(data2, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([145, 182, 236, 249, 212, 17, 175, 161])), 0)) {
    return 17;
  }
  if (containsBytes(data2, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([137, 84, 234, 206, 17, 58, 54, 215])), 0)) {
    return 18;
  }
  if (containsBytes(data2, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([28, 50, 43, 233, 244, 98, 123, 118])), 0)) {
    return 19;
  }
  if (containsBytes(data2, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([215, 68, 129, 228, 237, 165, 0, 240])), 0)) {
    return 20;
  }
  if (containsBytes(data2, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([228, 11, 207, 44, 52, 188, 169, 237])), 0)) {
    return 21;
  }
  if (containsBytes(data2, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([78, 164, 6, 115, 206, 48, 168, 105])), 0)) {
    return 22;
  }
  if (containsBytes(data2, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([255, 193, 171, 224, 68, 171, 194, 87])), 0)) {
    return 23;
  }
  if (containsBytes(data2, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([164, 219, 91, 38, 45, 31, 33, 47])), 0)) {
    return 24;
  }
  if (containsBytes(data2, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([165, 202, 159, 139, 65, 65, 36, 163])), 0)) {
    return 25;
  }
  if (containsBytes(data2, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([135, 157, 66, 195, 2, 113, 175, 30])), 0)) {
    return 26;
  }
  if (containsBytes(data2, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([15, 6, 94, 55, 65, 80, 123, 248])), 0)) {
    return 27;
  }
  if (containsBytes(data2, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([93, 74, 168, 125, 46, 153, 9, 255])), 0)) {
    return 28;
  }
  if (containsBytes(data2, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([168, 180, 218, 211, 184, 19, 102, 12])), 0)) {
    return 29;
  }
  if (containsBytes(data2, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([222, 179, 207, 59, 191, 78, 24, 248])), 0)) {
    return 30;
  }
  if (containsBytes(data2, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([38, 123, 95, 95, 223, 158, 169, 87])), 0)) {
    return 31;
  }
  if (containsBytes(data2, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([190, 242, 137, 27, 41, 18, 233, 37])), 0)) {
    return 32;
  }
  if (containsBytes(data2, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([5, 196, 24, 54, 196, 56, 173, 191])), 0)) {
    return 33;
  }
  if (containsBytes(data2, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([217, 177, 33, 54, 136, 185, 123, 96])), 0)) {
    return 34;
  }
  if (containsBytes(data2, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([23, 160, 228, 88, 168, 145, 129, 19])), 0)) {
    return 35;
  }
  if (containsBytes(data2, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([252, 101, 172, 252, 1, 4, 12, 116])), 0)) {
    return 36;
  }
  if (containsBytes(data2, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([85, 2, 178, 9, 119, 139, 102, 164])), 0)) {
    return 37;
  }
  if (containsBytes(data2, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([80, 227, 92, 245, 231, 37, 99, 180])), 0)) {
    return 38;
  }
  if (containsBytes(data2, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([87, 146, 181, 198, 252, 68, 243, 102])), 0)) {
    return 39;
  }
  if (containsBytes(data2, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([22, 167, 59, 238, 22, 231, 239, 146])), 0)) {
    return 40;
  }
  if (containsBytes(data2, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([64, 216, 17, 91, 205, 94, 45, 57])), 0)) {
    return 41;
  }
  if (containsBytes(data2, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([197, 97, 123, 54, 221, 168, 11, 135])), 0)) {
    return 42;
  }
  if (containsBytes(data2, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([206, 96, 254, 186, 129, 180, 103, 198])), 0)) {
    return 43;
  }
  if (containsBytes(data2, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([61, 236, 225, 167, 134, 43, 53, 93])), 0)) {
    return 44;
  }
  if (containsBytes(data2, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([161, 240, 255, 69, 130, 227, 71, 123])), 0)) {
    return 45;
  }
  if (containsBytes(data2, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([206, 212, 108, 12, 105, 61, 100, 66])), 0)) {
    return 46;
  }
  if (containsBytes(data2, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([43, 9, 131, 59, 74, 118, 113, 170])), 0)) {
    return 47;
  }
  throw new Error("The provided instruction could not be identified as a ghostspeakMarketplace instruction.");
}
function expectSome(value) {
  if (value === null || value === undefined) {
    throw new Error("Expected a value but received null or undefined.");
  }
  return value;
}
function expectAddress(value) {
  if (!value) {
    throw new Error("Expected a Address.");
  }
  if (typeof value === "object" && "address" in value) {
    return value.address;
  }
  if (Array.isArray(value)) {
    return value[0];
  }
  return value;
}
function getAccountMetaFactory(programAddress, optionalAccountStrategy) {
  return (account) => {
    if (!account.value) {
      if (optionalAccountStrategy === "omitted")
        return;
      return Object.freeze({
        address: programAddress,
        role: AccountRole.READONLY
      });
    }
    const writableRole = account.isWritable ? AccountRole.WRITABLE : AccountRole.READONLY;
    return Object.freeze({
      address: expectAddress(account.value),
      role: isTransactionSigner2(account.value) ? upgradeRoleToSigner(writableRole) : writableRole,
      ...isTransactionSigner2(account.value) ? { signer: account.value } : {}
    });
  };
}
function isTransactionSigner2(value) {
  return !!value && typeof value === "object" && "address" in value && isTransactionSigner(value);
}
var GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS = "4wHjA2a5YC4twZb4NQpwZpixo5FgxxzuJUrCG7UnF9pB", GhostspeakMarketplaceAccount, GhostspeakMarketplaceInstruction;
var init_chunk_AL3HQN73 = __esm(() => {
  init_index_node35();
  GhostspeakMarketplaceAccount = /* @__PURE__ */ ((GhostspeakMarketplaceAccount2) => {
    GhostspeakMarketplaceAccount2[GhostspeakMarketplaceAccount2["Agent"] = 0] = "Agent";
    GhostspeakMarketplaceAccount2[GhostspeakMarketplaceAccount2["AgentReputationAuth"] = 1] = "AgentReputationAuth";
    GhostspeakMarketplaceAccount2[GhostspeakMarketplaceAccount2["AgentTreeConfig"] = 2] = "AgentTreeConfig";
    GhostspeakMarketplaceAccount2[GhostspeakMarketplaceAccount2["AgentVerification"] = 3] = "AgentVerification";
    GhostspeakMarketplaceAccount2[GhostspeakMarketplaceAccount2["AuditTrail"] = 4] = "AuditTrail";
    GhostspeakMarketplaceAccount2[GhostspeakMarketplaceAccount2["AuthorizationUsageRecord"] = 5] = "AuthorizationUsageRecord";
    GhostspeakMarketplaceAccount2[GhostspeakMarketplaceAccount2["ComplianceReport"] = 6] = "ComplianceReport";
    GhostspeakMarketplaceAccount2[GhostspeakMarketplaceAccount2["Credential"] = 7] = "Credential";
    GhostspeakMarketplaceAccount2[GhostspeakMarketplaceAccount2["CredentialTemplate"] = 8] = "CredentialTemplate";
    GhostspeakMarketplaceAccount2[GhostspeakMarketplaceAccount2["CredentialType"] = 9] = "CredentialType";
    GhostspeakMarketplaceAccount2[GhostspeakMarketplaceAccount2["DidDocument"] = 10] = "DidDocument";
    GhostspeakMarketplaceAccount2[GhostspeakMarketplaceAccount2["GhostProtectEscrow"] = 11] = "GhostProtectEscrow";
    GhostspeakMarketplaceAccount2[GhostspeakMarketplaceAccount2["GovernanceProposal"] = 12] = "GovernanceProposal";
    GhostspeakMarketplaceAccount2[GhostspeakMarketplaceAccount2["Multisig"] = 13] = "Multisig";
    GhostspeakMarketplaceAccount2[GhostspeakMarketplaceAccount2["ProtocolConfig"] = 14] = "ProtocolConfig";
    GhostspeakMarketplaceAccount2[GhostspeakMarketplaceAccount2["RbacConfig"] = 15] = "RbacConfig";
    GhostspeakMarketplaceAccount2[GhostspeakMarketplaceAccount2["ReentrancyGuard"] = 16] = "ReentrancyGuard";
    GhostspeakMarketplaceAccount2[GhostspeakMarketplaceAccount2["ReputationMetrics"] = 17] = "ReputationMetrics";
    GhostspeakMarketplaceAccount2[GhostspeakMarketplaceAccount2["StakingAccount"] = 18] = "StakingAccount";
    GhostspeakMarketplaceAccount2[GhostspeakMarketplaceAccount2["StakingConfig"] = 19] = "StakingConfig";
    GhostspeakMarketplaceAccount2[GhostspeakMarketplaceAccount2["UserRegistry"] = 20] = "UserRegistry";
    return GhostspeakMarketplaceAccount2;
  })(GhostspeakMarketplaceAccount || {});
  GhostspeakMarketplaceInstruction = /* @__PURE__ */ ((GhostspeakMarketplaceInstruction2) => {
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["ActivateAgent"] = 0] = "ActivateAgent";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["ApproveDelivery"] = 1] = "ApproveDelivery";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["ArbitrateDispute"] = 2] = "ArbitrateDispute";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["CreateAgentAuthorization"] = 3] = "CreateAgentAuthorization";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["CreateCredentialTemplate"] = 4] = "CreateCredentialTemplate";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["CreateCredentialType"] = 5] = "CreateCredentialType";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["CreateDidDocument"] = 6] = "CreateDidDocument";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["CreateEscrow"] = 7] = "CreateEscrow";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["CreateMultisig"] = 8] = "CreateMultisig";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["DeactivateAgent"] = 9] = "DeactivateAgent";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["DeactivateCredentialTemplate"] = 10] = "DeactivateCredentialTemplate";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["DeactivateCredentialType"] = 11] = "DeactivateCredentialType";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["DeactivateDidDocument"] = 12] = "DeactivateDidDocument";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["EnableProtocolFees"] = 13] = "EnableProtocolFees";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["FileDispute"] = 14] = "FileDispute";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["GenerateComplianceReport"] = 15] = "GenerateComplianceReport";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["InitReentrancyGuard"] = 16] = "InitReentrancyGuard";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["InitializeAuditTrail"] = 17] = "InitializeAuditTrail";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["InitializeGovernanceProposal"] = 18] = "InitializeGovernanceProposal";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["InitializeProtocolConfig"] = 19] = "InitializeProtocolConfig";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["InitializeRbacConfig"] = 20] = "InitializeRbacConfig";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["InitializeReputationMetrics"] = 21] = "InitializeReputationMetrics";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["InitializeStakingConfig"] = 22] = "InitializeStakingConfig";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["IssueCredential"] = 23] = "IssueCredential";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["ManageAgentStatus"] = 24] = "ManageAgentStatus";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["RecordPayaiPayment"] = 25] = "RecordPayaiPayment";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["RegisterAgent"] = 26] = "RegisterAgent";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["RegisterAgentCompressed"] = 27] = "RegisterAgentCompressed";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["ResetReentrancyGuard"] = 28] = "ResetReentrancyGuard";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["ResolveDidDocument"] = 29] = "ResolveDidDocument";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["RevokeAuthorization"] = 30] = "RevokeAuthorization";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["RevokeCredential"] = 31] = "RevokeCredential";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["SlashStake"] = 32] = "SlashStake";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["StakeGhost"] = 33] = "StakeGhost";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["SubmitDelivery"] = 34] = "SubmitDelivery";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["SubmitServiceRating"] = 35] = "SubmitServiceRating";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["UnstakeGhost"] = 36] = "UnstakeGhost";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["UpdateAgent"] = 37] = "UpdateAgent";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["UpdateAgentReputation"] = 38] = "UpdateAgentReputation";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["UpdateAgentService"] = 39] = "UpdateAgentService";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["UpdateCrosschainStatus"] = 40] = "UpdateCrosschainStatus";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["UpdateDidDocument"] = 41] = "UpdateDidDocument";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["UpdateProtocolConfig"] = 42] = "UpdateProtocolConfig";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["UpdateReputationTags"] = 43] = "UpdateReputationTags";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["UpdateReputationWithAuth"] = 44] = "UpdateReputationWithAuth";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["UpdateSourceReputation"] = 45] = "UpdateSourceReputation";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["VerifyAgent"] = 46] = "VerifyAgent";
    GhostspeakMarketplaceInstruction2[GhostspeakMarketplaceInstruction2["VerifyAuthorization"] = 47] = "VerifyAuthorization";
    return GhostspeakMarketplaceInstruction2;
  })(GhostspeakMarketplaceInstruction || {});
});

// ../packages/sdk-typescript/dist/chunk-S74EH3KD.js
function getAgentReputationAuthDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(AGENT_REPUTATION_AUTH_DISCRIMINATOR);
}
function getAgentReputationAuthEncoder() {
  return transformEncoder(getStructEncoder([
    ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
    ["agent", getAddressEncoder()],
    ["authorizedSource", getAddressEncoder()],
    ["indexLimit", getU64Encoder()],
    ["currentIndex", getU64Encoder()],
    ["expiresAt", getI64Encoder()],
    ["network", getU8Encoder()],
    ["signature", fixEncoderSize(getBytesEncoder(), 64)],
    [
      "nonce",
      getOptionEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    ["revoked", getBooleanEncoder()],
    ["createdAt", getI64Encoder()],
    ["lastUsedAt", getOptionEncoder(getI64Encoder())],
    ["totalReputationChange", getI64Encoder()],
    ["bump", getU8Encoder()]
  ]), (value) => ({
    ...value,
    discriminator: AGENT_REPUTATION_AUTH_DISCRIMINATOR
  }));
}
function getAgentReputationAuthDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    ["agent", getAddressDecoder()],
    ["authorizedSource", getAddressDecoder()],
    ["indexLimit", getU64Decoder()],
    ["currentIndex", getU64Decoder()],
    ["expiresAt", getI64Decoder()],
    ["network", getU8Decoder()],
    ["signature", fixDecoderSize(getBytesDecoder(), 64)],
    [
      "nonce",
      getOptionDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    ["revoked", getBooleanDecoder()],
    ["createdAt", getI64Decoder()],
    ["lastUsedAt", getOptionDecoder(getI64Decoder())],
    ["totalReputationChange", getI64Decoder()],
    ["bump", getU8Decoder()]
  ]);
}
function getAgentReputationAuthCodec() {
  return combineCodec(getAgentReputationAuthEncoder(), getAgentReputationAuthDecoder());
}
function decodeAgentReputationAuth(encodedAccount) {
  return decodeAccount(encodedAccount, getAgentReputationAuthDecoder());
}
async function fetchAgentReputationAuth(rpc2, address2, config) {
  const maybeAccount = await fetchMaybeAgentReputationAuth(rpc2, address2, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeAgentReputationAuth(rpc2, address2, config) {
  const maybeAccount = await fetchEncodedAccount(rpc2, address2, config);
  return decodeAgentReputationAuth(maybeAccount);
}
async function fetchAllAgentReputationAuth(rpc2, addresses2, config) {
  const maybeAccounts = await fetchAllMaybeAgentReputationAuth(rpc2, addresses2, config);
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeAgentReputationAuth(rpc2, addresses2, config) {
  const maybeAccounts = await fetchEncodedAccounts(rpc2, addresses2, config);
  return maybeAccounts.map((maybeAccount) => decodeAgentReputationAuth(maybeAccount));
}
function getAgentTreeConfigDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(AGENT_TREE_CONFIG_DISCRIMINATOR);
}
function getAgentTreeConfigEncoder() {
  return transformEncoder(getStructEncoder([
    ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
    ["treeCreator", getAddressEncoder()],
    ["treeDelegate", getAddressEncoder()],
    ["numMinted", getU64Encoder()],
    ["bump", getU8Encoder()]
  ]), (value) => ({ ...value, discriminator: AGENT_TREE_CONFIG_DISCRIMINATOR }));
}
function getAgentTreeConfigDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    ["treeCreator", getAddressDecoder()],
    ["treeDelegate", getAddressDecoder()],
    ["numMinted", getU64Decoder()],
    ["bump", getU8Decoder()]
  ]);
}
function getAgentTreeConfigCodec() {
  return combineCodec(getAgentTreeConfigEncoder(), getAgentTreeConfigDecoder());
}
function decodeAgentTreeConfig(encodedAccount) {
  return decodeAccount(encodedAccount, getAgentTreeConfigDecoder());
}
async function fetchAgentTreeConfig(rpc2, address2, config) {
  const maybeAccount = await fetchMaybeAgentTreeConfig(rpc2, address2, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeAgentTreeConfig(rpc2, address2, config) {
  const maybeAccount = await fetchEncodedAccount(rpc2, address2, config);
  return decodeAgentTreeConfig(maybeAccount);
}
async function fetchAllAgentTreeConfig(rpc2, addresses2, config) {
  const maybeAccounts = await fetchAllMaybeAgentTreeConfig(rpc2, addresses2, config);
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeAgentTreeConfig(rpc2, addresses2, config) {
  const maybeAccounts = await fetchEncodedAccounts(rpc2, addresses2, config);
  return maybeAccounts.map((maybeAccount) => decodeAgentTreeConfig(maybeAccount));
}
function getAgentTreeConfigSize() {
  return 81;
}
function getAgentVerificationDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(AGENT_VERIFICATION_DISCRIMINATOR);
}
function getAgentVerificationEncoder() {
  return transformEncoder(getStructEncoder([
    ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
    ["agent", getAddressEncoder()],
    ["verifier", getAddressEncoder()],
    ["verificationData", getAgentVerificationDataEncoder()],
    ["createdAt", getI64Encoder()],
    ["expiresAt", getI64Encoder()],
    ["isActive", getBooleanEncoder()],
    ["bump", getU8Encoder()]
  ]), (value) => ({ ...value, discriminator: AGENT_VERIFICATION_DISCRIMINATOR }));
}
function getAgentVerificationDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    ["agent", getAddressDecoder()],
    ["verifier", getAddressDecoder()],
    ["verificationData", getAgentVerificationDataDecoder()],
    ["createdAt", getI64Decoder()],
    ["expiresAt", getI64Decoder()],
    ["isActive", getBooleanDecoder()],
    ["bump", getU8Decoder()]
  ]);
}
function getAgentVerificationCodec() {
  return combineCodec(getAgentVerificationEncoder(), getAgentVerificationDecoder());
}
function decodeAgentVerification(encodedAccount) {
  return decodeAccount(encodedAccount, getAgentVerificationDecoder());
}
async function fetchAgentVerification(rpc2, address2, config) {
  const maybeAccount = await fetchMaybeAgentVerification(rpc2, address2, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeAgentVerification(rpc2, address2, config) {
  const maybeAccount = await fetchEncodedAccount(rpc2, address2, config);
  return decodeAgentVerification(maybeAccount);
}
async function fetchAllAgentVerification(rpc2, addresses2, config) {
  const maybeAccounts = await fetchAllMaybeAgentVerification(rpc2, addresses2, config);
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeAgentVerification(rpc2, addresses2, config) {
  const maybeAccounts = await fetchEncodedAccounts(rpc2, addresses2, config);
  return maybeAccounts.map((maybeAccount) => decodeAgentVerification(maybeAccount));
}
function getAuditTrailDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(AUDIT_TRAIL_DISCRIMINATOR);
}
function getAuditTrailEncoder() {
  return transformEncoder(getStructEncoder([
    ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
    ["authority", getAddressEncoder()],
    ["trailId", getU64Encoder()],
    ["createdAt", getI64Encoder()],
    ["updatedAt", getI64Encoder()],
    ["version", getU8Encoder()],
    ["entries", getArrayEncoder(getAuditEntryEncoder())],
    ["config", getAuditConfigEncoder()],
    ["complianceStatus", getComplianceStatusEncoder()],
    ["hashChain", getArrayEncoder(fixEncoderSize(getBytesEncoder(), 32))],
    ["reserved", fixEncoderSize(getBytesEncoder(), 128)]
  ]), (value) => ({ ...value, discriminator: AUDIT_TRAIL_DISCRIMINATOR }));
}
function getAuditTrailDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    ["authority", getAddressDecoder()],
    ["trailId", getU64Decoder()],
    ["createdAt", getI64Decoder()],
    ["updatedAt", getI64Decoder()],
    ["version", getU8Decoder()],
    ["entries", getArrayDecoder(getAuditEntryDecoder())],
    ["config", getAuditConfigDecoder()],
    ["complianceStatus", getComplianceStatusDecoder()],
    ["hashChain", getArrayDecoder(fixDecoderSize(getBytesDecoder(), 32))],
    ["reserved", fixDecoderSize(getBytesDecoder(), 128)]
  ]);
}
function getAuditTrailCodec() {
  return combineCodec(getAuditTrailEncoder(), getAuditTrailDecoder());
}
function decodeAuditTrail(encodedAccount) {
  return decodeAccount(encodedAccount, getAuditTrailDecoder());
}
async function fetchAuditTrail(rpc2, address2, config) {
  const maybeAccount = await fetchMaybeAuditTrail(rpc2, address2, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeAuditTrail(rpc2, address2, config) {
  const maybeAccount = await fetchEncodedAccount(rpc2, address2, config);
  return decodeAuditTrail(maybeAccount);
}
async function fetchAllAuditTrail(rpc2, addresses2, config) {
  const maybeAccounts = await fetchAllMaybeAuditTrail(rpc2, addresses2, config);
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeAuditTrail(rpc2, addresses2, config) {
  const maybeAccounts = await fetchEncodedAccounts(rpc2, addresses2, config);
  return maybeAccounts.map((maybeAccount) => decodeAuditTrail(maybeAccount));
}
function getAuthorizationUsageRecordDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(AUTHORIZATION_USAGE_RECORD_DISCRIMINATOR);
}
function getAuthorizationUsageRecordEncoder() {
  return transformEncoder(getStructEncoder([
    ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
    ["authorization", getAddressEncoder()],
    ["agent", getAddressEncoder()],
    ["authorizedSource", getAddressEncoder()],
    ["usageIndex", getU64Encoder()],
    ["reputationChange", getI64Encoder()],
    ["usedAt", getI64Encoder()],
    [
      "transactionSignature",
      addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())
    ],
    [
      "metadata",
      getOptionEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    ["bump", getU8Encoder()]
  ]), (value) => ({
    ...value,
    discriminator: AUTHORIZATION_USAGE_RECORD_DISCRIMINATOR
  }));
}
function getAuthorizationUsageRecordDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    ["authorization", getAddressDecoder()],
    ["agent", getAddressDecoder()],
    ["authorizedSource", getAddressDecoder()],
    ["usageIndex", getU64Decoder()],
    ["reputationChange", getI64Decoder()],
    ["usedAt", getI64Decoder()],
    [
      "transactionSignature",
      addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())
    ],
    [
      "metadata",
      getOptionDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    ["bump", getU8Decoder()]
  ]);
}
function getAuthorizationUsageRecordCodec() {
  return combineCodec(getAuthorizationUsageRecordEncoder(), getAuthorizationUsageRecordDecoder());
}
function decodeAuthorizationUsageRecord(encodedAccount) {
  return decodeAccount(encodedAccount, getAuthorizationUsageRecordDecoder());
}
async function fetchAuthorizationUsageRecord(rpc2, address2, config) {
  const maybeAccount = await fetchMaybeAuthorizationUsageRecord(rpc2, address2, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeAuthorizationUsageRecord(rpc2, address2, config) {
  const maybeAccount = await fetchEncodedAccount(rpc2, address2, config);
  return decodeAuthorizationUsageRecord(maybeAccount);
}
async function fetchAllAuthorizationUsageRecord(rpc2, addresses2, config) {
  const maybeAccounts = await fetchAllMaybeAuthorizationUsageRecord(rpc2, addresses2, config);
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeAuthorizationUsageRecord(rpc2, addresses2, config) {
  const maybeAccounts = await fetchEncodedAccounts(rpc2, addresses2, config);
  return maybeAccounts.map((maybeAccount) => decodeAuthorizationUsageRecord(maybeAccount));
}
function getComplianceReportDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(COMPLIANCE_REPORT_DISCRIMINATOR);
}
function getComplianceReportEncoder() {
  return transformEncoder(getStructEncoder([
    ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
    ["reportId", getU64Encoder()],
    ["reportType", getReportTypeEncoder()],
    ["generatedAt", getI64Encoder()],
    ["periodStart", getI64Encoder()],
    ["periodEnd", getI64Encoder()],
    ["reportData", getReportDataEncoder()],
    ["signature", fixEncoderSize(getBytesEncoder(), 64)],
    ["status", getReportStatusEncoder()],
    ["submissionDetails", getOptionEncoder(getSubmissionDetailsEncoder())],
    ["reserved", fixEncoderSize(getBytesEncoder(), 64)]
  ]), (value) => ({ ...value, discriminator: COMPLIANCE_REPORT_DISCRIMINATOR }));
}
function getComplianceReportDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    ["reportId", getU64Decoder()],
    ["reportType", getReportTypeDecoder()],
    ["generatedAt", getI64Decoder()],
    ["periodStart", getI64Decoder()],
    ["periodEnd", getI64Decoder()],
    ["reportData", getReportDataDecoder()],
    ["signature", fixDecoderSize(getBytesDecoder(), 64)],
    ["status", getReportStatusDecoder()],
    ["submissionDetails", getOptionDecoder(getSubmissionDetailsDecoder())],
    ["reserved", fixDecoderSize(getBytesDecoder(), 64)]
  ]);
}
function getComplianceReportCodec() {
  return combineCodec(getComplianceReportEncoder(), getComplianceReportDecoder());
}
function decodeComplianceReport(encodedAccount) {
  return decodeAccount(encodedAccount, getComplianceReportDecoder());
}
async function fetchComplianceReport(rpc2, address2, config) {
  const maybeAccount = await fetchMaybeComplianceReport(rpc2, address2, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeComplianceReport(rpc2, address2, config) {
  const maybeAccount = await fetchEncodedAccount(rpc2, address2, config);
  return decodeComplianceReport(maybeAccount);
}
async function fetchAllComplianceReport(rpc2, addresses2, config) {
  const maybeAccounts = await fetchAllMaybeComplianceReport(rpc2, addresses2, config);
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeComplianceReport(rpc2, addresses2, config) {
  const maybeAccounts = await fetchEncodedAccounts(rpc2, addresses2, config);
  return maybeAccounts.map((maybeAccount) => decodeComplianceReport(maybeAccount));
}
function getCredentialDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(CREDENTIAL_DISCRIMINATOR);
}
function getCredentialEncoder() {
  return transformEncoder(getStructEncoder([
    ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
    ["template", getAddressEncoder()],
    ["subject", getAddressEncoder()],
    ["issuer", getAddressEncoder()],
    ["credentialId", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["subjectDataHash", fixEncoderSize(getBytesEncoder(), 32)],
    [
      "subjectDataUri",
      addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())
    ],
    ["status", getCredentialStatusEncoder()],
    ["signature", fixEncoderSize(getBytesEncoder(), 64)],
    ["issuedAt", getI64Encoder()],
    ["expiresAt", getOptionEncoder(getI64Encoder())],
    ["revokedAt", getOptionEncoder(getI64Encoder())],
    ["crossChainStatus", getCrossChainStatusEncoder()],
    [
      "crossmintCredentialId",
      getOptionEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    ["sourceAccount", getOptionEncoder(getAddressEncoder())],
    ["bump", getU8Encoder()]
  ]), (value) => ({ ...value, discriminator: CREDENTIAL_DISCRIMINATOR }));
}
function getCredentialDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    ["template", getAddressDecoder()],
    ["subject", getAddressDecoder()],
    ["issuer", getAddressDecoder()],
    ["credentialId", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["subjectDataHash", fixDecoderSize(getBytesDecoder(), 32)],
    ["subjectDataUri", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["status", getCredentialStatusDecoder()],
    ["signature", fixDecoderSize(getBytesDecoder(), 64)],
    ["issuedAt", getI64Decoder()],
    ["expiresAt", getOptionDecoder(getI64Decoder())],
    ["revokedAt", getOptionDecoder(getI64Decoder())],
    ["crossChainStatus", getCrossChainStatusDecoder()],
    [
      "crossmintCredentialId",
      getOptionDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    ["sourceAccount", getOptionDecoder(getAddressDecoder())],
    ["bump", getU8Decoder()]
  ]);
}
function getCredentialCodec() {
  return combineCodec(getCredentialEncoder(), getCredentialDecoder());
}
function decodeCredential(encodedAccount) {
  return decodeAccount(encodedAccount, getCredentialDecoder());
}
async function fetchCredential(rpc2, address2, config) {
  const maybeAccount = await fetchMaybeCredential(rpc2, address2, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeCredential(rpc2, address2, config) {
  const maybeAccount = await fetchEncodedAccount(rpc2, address2, config);
  return decodeCredential(maybeAccount);
}
async function fetchAllCredential(rpc2, addresses2, config) {
  const maybeAccounts = await fetchAllMaybeCredential(rpc2, addresses2, config);
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeCredential(rpc2, addresses2, config) {
  const maybeAccounts = await fetchEncodedAccounts(rpc2, addresses2, config);
  return maybeAccounts.map((maybeAccount) => decodeCredential(maybeAccount));
}
function getCredentialTemplateDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(CREDENTIAL_TEMPLATE_DISCRIMINATOR);
}
function getCredentialTemplateEncoder() {
  return transformEncoder(getStructEncoder([
    ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
    ["credentialType", getAddressEncoder()],
    ["name", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["imageUri", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["issuer", getAddressEncoder()],
    ["isActive", getBooleanEncoder()],
    ["totalIssued", getU64Encoder()],
    ["createdAt", getI64Encoder()],
    [
      "crossmintTemplateId",
      getOptionEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    ["bump", getU8Encoder()]
  ]), (value) => ({ ...value, discriminator: CREDENTIAL_TEMPLATE_DISCRIMINATOR }));
}
function getCredentialTemplateDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    ["credentialType", getAddressDecoder()],
    ["name", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["imageUri", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["issuer", getAddressDecoder()],
    ["isActive", getBooleanDecoder()],
    ["totalIssued", getU64Decoder()],
    ["createdAt", getI64Decoder()],
    [
      "crossmintTemplateId",
      getOptionDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    ["bump", getU8Decoder()]
  ]);
}
function getCredentialTemplateCodec() {
  return combineCodec(getCredentialTemplateEncoder(), getCredentialTemplateDecoder());
}
function decodeCredentialTemplate(encodedAccount) {
  return decodeAccount(encodedAccount, getCredentialTemplateDecoder());
}
async function fetchCredentialTemplate(rpc2, address2, config) {
  const maybeAccount = await fetchMaybeCredentialTemplate(rpc2, address2, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeCredentialTemplate(rpc2, address2, config) {
  const maybeAccount = await fetchEncodedAccount(rpc2, address2, config);
  return decodeCredentialTemplate(maybeAccount);
}
async function fetchAllCredentialTemplate(rpc2, addresses2, config) {
  const maybeAccounts = await fetchAllMaybeCredentialTemplate(rpc2, addresses2, config);
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeCredentialTemplate(rpc2, addresses2, config) {
  const maybeAccounts = await fetchEncodedAccounts(rpc2, addresses2, config);
  return maybeAccounts.map((maybeAccount) => decodeCredentialTemplate(maybeAccount));
}
function getCredentialTypeDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(CREDENTIAL_TYPE_DISCRIMINATOR);
}
function getCredentialTypeEncoder() {
  return transformEncoder(getStructEncoder([
    ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
    ["authority", getAddressEncoder()],
    ["name", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["kind", getCredentialKindEncoder()],
    ["schemaUri", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["description", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["isActive", getBooleanEncoder()],
    ["totalIssued", getU64Encoder()],
    ["createdAt", getI64Encoder()],
    ["bump", getU8Encoder()]
  ]), (value) => ({ ...value, discriminator: CREDENTIAL_TYPE_DISCRIMINATOR }));
}
function getCredentialTypeDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    ["authority", getAddressDecoder()],
    ["name", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["kind", getCredentialKindDecoder()],
    ["schemaUri", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["description", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["isActive", getBooleanDecoder()],
    ["totalIssued", getU64Decoder()],
    ["createdAt", getI64Decoder()],
    ["bump", getU8Decoder()]
  ]);
}
function getCredentialTypeCodec() {
  return combineCodec(getCredentialTypeEncoder(), getCredentialTypeDecoder());
}
function decodeCredentialType(encodedAccount) {
  return decodeAccount(encodedAccount, getCredentialTypeDecoder());
}
async function fetchCredentialType(rpc2, address2, config) {
  const maybeAccount = await fetchMaybeCredentialType(rpc2, address2, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeCredentialType(rpc2, address2, config) {
  const maybeAccount = await fetchEncodedAccount(rpc2, address2, config);
  return decodeCredentialType(maybeAccount);
}
async function fetchAllCredentialType(rpc2, addresses2, config) {
  const maybeAccounts = await fetchAllMaybeCredentialType(rpc2, addresses2, config);
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeCredentialType(rpc2, addresses2, config) {
  const maybeAccounts = await fetchEncodedAccounts(rpc2, addresses2, config);
  return maybeAccounts.map((maybeAccount) => decodeCredentialType(maybeAccount));
}
function getDidDocumentDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(DID_DOCUMENT_DISCRIMINATOR);
}
function getDidDocumentEncoder() {
  return transformEncoder(getStructEncoder([
    ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
    ["did", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["controller", getAddressEncoder()],
    ["verificationMethods", getArrayEncoder(getVerificationMethodEncoder())],
    ["serviceEndpoints", getArrayEncoder(getServiceEndpointEncoder())],
    [
      "context",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    [
      "alsoKnownAs",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    ["createdAt", getI64Encoder()],
    ["updatedAt", getI64Encoder()],
    ["version", getU32Encoder()],
    ["deactivated", getBooleanEncoder()],
    ["deactivatedAt", getOptionEncoder(getI64Encoder())],
    ["bump", getU8Encoder()]
  ]), (value) => ({ ...value, discriminator: DID_DOCUMENT_DISCRIMINATOR }));
}
function getDidDocumentDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    ["did", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["controller", getAddressDecoder()],
    ["verificationMethods", getArrayDecoder(getVerificationMethodDecoder())],
    ["serviceEndpoints", getArrayDecoder(getServiceEndpointDecoder())],
    [
      "context",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    [
      "alsoKnownAs",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    ["createdAt", getI64Decoder()],
    ["updatedAt", getI64Decoder()],
    ["version", getU32Decoder()],
    ["deactivated", getBooleanDecoder()],
    ["deactivatedAt", getOptionDecoder(getI64Decoder())],
    ["bump", getU8Decoder()]
  ]);
}
function getDidDocumentCodec() {
  return combineCodec(getDidDocumentEncoder(), getDidDocumentDecoder());
}
function decodeDidDocument(encodedAccount) {
  return decodeAccount(encodedAccount, getDidDocumentDecoder());
}
async function fetchDidDocument(rpc2, address2, config) {
  const maybeAccount = await fetchMaybeDidDocument(rpc2, address2, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeDidDocument(rpc2, address2, config) {
  const maybeAccount = await fetchEncodedAccount(rpc2, address2, config);
  return decodeDidDocument(maybeAccount);
}
async function fetchAllDidDocument(rpc2, addresses2, config) {
  const maybeAccounts = await fetchAllMaybeDidDocument(rpc2, addresses2, config);
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeDidDocument(rpc2, addresses2, config) {
  const maybeAccounts = await fetchEncodedAccounts(rpc2, addresses2, config);
  return maybeAccounts.map((maybeAccount) => decodeDidDocument(maybeAccount));
}
function getGhostProtectEscrowDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(GHOST_PROTECT_ESCROW_DISCRIMINATOR);
}
function getGhostProtectEscrowEncoder() {
  return transformEncoder(getStructEncoder([
    ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
    ["escrowId", getU64Encoder()],
    ["client", getAddressEncoder()],
    ["agent", getAddressEncoder()],
    ["amount", getU64Encoder()],
    ["tokenMint", getAddressEncoder()],
    ["status", getEscrowStatusEncoder()],
    [
      "jobDescription",
      addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())
    ],
    [
      "deliveryProof",
      getOptionEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    ["deadline", getI64Encoder()],
    ["createdAt", getI64Encoder()],
    ["completedAt", getOptionEncoder(getI64Encoder())],
    [
      "disputeReason",
      getOptionEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    ["arbitratorDecision", getOptionEncoder(getArbitratorDecisionEncoder())],
    ["bump", getU8Encoder()]
  ]), (value) => ({
    ...value,
    discriminator: GHOST_PROTECT_ESCROW_DISCRIMINATOR
  }));
}
function getGhostProtectEscrowDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    ["escrowId", getU64Decoder()],
    ["client", getAddressDecoder()],
    ["agent", getAddressDecoder()],
    ["amount", getU64Decoder()],
    ["tokenMint", getAddressDecoder()],
    ["status", getEscrowStatusDecoder()],
    ["jobDescription", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    [
      "deliveryProof",
      getOptionDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    ["deadline", getI64Decoder()],
    ["createdAt", getI64Decoder()],
    ["completedAt", getOptionDecoder(getI64Decoder())],
    [
      "disputeReason",
      getOptionDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    ["arbitratorDecision", getOptionDecoder(getArbitratorDecisionDecoder())],
    ["bump", getU8Decoder()]
  ]);
}
function getGhostProtectEscrowCodec() {
  return combineCodec(getGhostProtectEscrowEncoder(), getGhostProtectEscrowDecoder());
}
function decodeGhostProtectEscrow(encodedAccount) {
  return decodeAccount(encodedAccount, getGhostProtectEscrowDecoder());
}
async function fetchGhostProtectEscrow(rpc2, address2, config) {
  const maybeAccount = await fetchMaybeGhostProtectEscrow(rpc2, address2, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeGhostProtectEscrow(rpc2, address2, config) {
  const maybeAccount = await fetchEncodedAccount(rpc2, address2, config);
  return decodeGhostProtectEscrow(maybeAccount);
}
async function fetchAllGhostProtectEscrow(rpc2, addresses2, config) {
  const maybeAccounts = await fetchAllMaybeGhostProtectEscrow(rpc2, addresses2, config);
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeGhostProtectEscrow(rpc2, addresses2, config) {
  const maybeAccounts = await fetchEncodedAccounts(rpc2, addresses2, config);
  return maybeAccounts.map((maybeAccount) => decodeGhostProtectEscrow(maybeAccount));
}
function getGovernanceProposalDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(GOVERNANCE_PROPOSAL_DISCRIMINATOR);
}
function getGovernanceProposalEncoder() {
  return transformEncoder(getStructEncoder([
    ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
    ["proposalId", getU64Encoder()],
    ["proposer", getAddressEncoder()],
    ["title", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["description", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["proposalType", getProposalTypeEncoder()],
    ["createdAt", getI64Encoder()],
    ["votingStartsAt", getI64Encoder()],
    ["votingEndsAt", getI64Encoder()],
    ["executionTimestamp", getOptionEncoder(getI64Encoder())],
    ["status", getProposalStatusEncoder()],
    ["votingResults", getVotingResultsEncoder()],
    ["executionParams", getExecutionParamsEncoder()],
    ["quorumRequirements", getQuorumRequirementsEncoder()],
    ["metadata", getProposalMetadataEncoder()],
    ["reserved", fixEncoderSize(getBytesEncoder(), 64)]
  ]), (value) => ({ ...value, discriminator: GOVERNANCE_PROPOSAL_DISCRIMINATOR }));
}
function getGovernanceProposalDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    ["proposalId", getU64Decoder()],
    ["proposer", getAddressDecoder()],
    ["title", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["description", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["proposalType", getProposalTypeDecoder()],
    ["createdAt", getI64Decoder()],
    ["votingStartsAt", getI64Decoder()],
    ["votingEndsAt", getI64Decoder()],
    ["executionTimestamp", getOptionDecoder(getI64Decoder())],
    ["status", getProposalStatusDecoder()],
    ["votingResults", getVotingResultsDecoder()],
    ["executionParams", getExecutionParamsDecoder()],
    ["quorumRequirements", getQuorumRequirementsDecoder()],
    ["metadata", getProposalMetadataDecoder()],
    ["reserved", fixDecoderSize(getBytesDecoder(), 64)]
  ]);
}
function getGovernanceProposalCodec() {
  return combineCodec(getGovernanceProposalEncoder(), getGovernanceProposalDecoder());
}
function decodeGovernanceProposal(encodedAccount) {
  return decodeAccount(encodedAccount, getGovernanceProposalDecoder());
}
async function fetchGovernanceProposal(rpc2, address2, config) {
  const maybeAccount = await fetchMaybeGovernanceProposal(rpc2, address2, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeGovernanceProposal(rpc2, address2, config) {
  const maybeAccount = await fetchEncodedAccount(rpc2, address2, config);
  return decodeGovernanceProposal(maybeAccount);
}
async function fetchAllGovernanceProposal(rpc2, addresses2, config) {
  const maybeAccounts = await fetchAllMaybeGovernanceProposal(rpc2, addresses2, config);
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeGovernanceProposal(rpc2, addresses2, config) {
  const maybeAccounts = await fetchEncodedAccounts(rpc2, addresses2, config);
  return maybeAccounts.map((maybeAccount) => decodeGovernanceProposal(maybeAccount));
}
function getMultisigDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(MULTISIG_DISCRIMINATOR);
}
function getMultisigEncoder() {
  return transformEncoder(getStructEncoder([
    ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
    ["multisigId", getU64Encoder()],
    ["multisigType", getMultisigTypeEncoder()],
    ["threshold", getU8Encoder()],
    ["signers", getArrayEncoder(getAddressEncoder())],
    ["owner", getAddressEncoder()],
    ["createdAt", getI64Encoder()],
    ["updatedAt", getI64Encoder()],
    ["nonce", getU64Encoder()],
    ["pendingTransactions", getArrayEncoder(getPendingTransactionEncoder())],
    ["config", getMultisigConfigEncoder()],
    ["emergencyConfig", getEmergencyConfigEncoder()],
    ["typeConfig", getMultisigTypeConfigEncoder()],
    ["reserved", fixEncoderSize(getBytesEncoder(), 64)]
  ]), (value) => ({ ...value, discriminator: MULTISIG_DISCRIMINATOR }));
}
function getMultisigDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    ["multisigId", getU64Decoder()],
    ["multisigType", getMultisigTypeDecoder()],
    ["threshold", getU8Decoder()],
    ["signers", getArrayDecoder(getAddressDecoder())],
    ["owner", getAddressDecoder()],
    ["createdAt", getI64Decoder()],
    ["updatedAt", getI64Decoder()],
    ["nonce", getU64Decoder()],
    ["pendingTransactions", getArrayDecoder(getPendingTransactionDecoder())],
    ["config", getMultisigConfigDecoder()],
    ["emergencyConfig", getEmergencyConfigDecoder()],
    ["typeConfig", getMultisigTypeConfigDecoder()],
    ["reserved", fixDecoderSize(getBytesDecoder(), 64)]
  ]);
}
function getMultisigCodec() {
  return combineCodec(getMultisigEncoder(), getMultisigDecoder());
}
function decodeMultisig(encodedAccount) {
  return decodeAccount(encodedAccount, getMultisigDecoder());
}
async function fetchMultisig(rpc2, address2, config) {
  const maybeAccount = await fetchMaybeMultisig(rpc2, address2, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeMultisig(rpc2, address2, config) {
  const maybeAccount = await fetchEncodedAccount(rpc2, address2, config);
  return decodeMultisig(maybeAccount);
}
async function fetchAllMultisig(rpc2, addresses2, config) {
  const maybeAccounts = await fetchAllMaybeMultisig(rpc2, addresses2, config);
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeMultisig(rpc2, addresses2, config) {
  const maybeAccounts = await fetchEncodedAccounts(rpc2, addresses2, config);
  return maybeAccounts.map((maybeAccount) => decodeMultisig(maybeAccount));
}
function getProtocolConfigDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(PROTOCOL_CONFIG_DISCRIMINATOR);
}
function getProtocolConfigEncoder() {
  return transformEncoder(getStructEncoder([
    ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
    ["authority", getAddressEncoder()],
    ["treasury", getAddressEncoder()],
    ["buybackPool", getAddressEncoder()],
    ["moderatorPool", getAddressEncoder()],
    ["escrowFeeBps", getU16Encoder()],
    ["agentRegistrationFee", getU64Encoder()],
    ["listingFee", getU64Encoder()],
    ["disputeFeeBps", getU16Encoder()],
    ["feesEnabled", getBooleanEncoder()],
    ["updatedAt", getI64Encoder()],
    ["bump", getU8Encoder()],
    ["reserved", fixEncoderSize(getBytesEncoder(), 64)]
  ]), (value) => ({ ...value, discriminator: PROTOCOL_CONFIG_DISCRIMINATOR }));
}
function getProtocolConfigDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    ["authority", getAddressDecoder()],
    ["treasury", getAddressDecoder()],
    ["buybackPool", getAddressDecoder()],
    ["moderatorPool", getAddressDecoder()],
    ["escrowFeeBps", getU16Decoder()],
    ["agentRegistrationFee", getU64Decoder()],
    ["listingFee", getU64Decoder()],
    ["disputeFeeBps", getU16Decoder()],
    ["feesEnabled", getBooleanDecoder()],
    ["updatedAt", getI64Decoder()],
    ["bump", getU8Decoder()],
    ["reserved", fixDecoderSize(getBytesDecoder(), 64)]
  ]);
}
function getProtocolConfigCodec() {
  return combineCodec(getProtocolConfigEncoder(), getProtocolConfigDecoder());
}
function decodeProtocolConfig(encodedAccount) {
  return decodeAccount(encodedAccount, getProtocolConfigDecoder());
}
async function fetchProtocolConfig(rpc2, address2, config) {
  const maybeAccount = await fetchMaybeProtocolConfig(rpc2, address2, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeProtocolConfig(rpc2, address2, config) {
  const maybeAccount = await fetchEncodedAccount(rpc2, address2, config);
  return decodeProtocolConfig(maybeAccount);
}
async function fetchAllProtocolConfig(rpc2, addresses2, config) {
  const maybeAccounts = await fetchAllMaybeProtocolConfig(rpc2, addresses2, config);
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeProtocolConfig(rpc2, addresses2, config) {
  const maybeAccounts = await fetchEncodedAccounts(rpc2, addresses2, config);
  return maybeAccounts.map((maybeAccount) => decodeProtocolConfig(maybeAccount));
}
function getProtocolConfigSize() {
  return 230;
}
function getRbacConfigDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(RBAC_CONFIG_DISCRIMINATOR);
}
function getRbacConfigEncoder() {
  return transformEncoder(getStructEncoder([
    ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
    ["authority", getAddressEncoder()],
    ["createdAt", getI64Encoder()],
    ["updatedAt", getI64Encoder()],
    ["version", getU8Encoder()],
    ["roles", getArrayEncoder(getRoleEncoder())],
    ["permissions", getArrayEncoder(getPermissionEncoder())],
    ["accessPolicies", getArrayEncoder(getAccessPolicyEncoder())],
    ["securityPolicies", getSecurityPoliciesEncoder()],
    ["auditConfig", getAccessAuditConfigEncoder()],
    ["emergencyAccess", getEmergencyAccessConfigEncoder()],
    ["reserved", fixEncoderSize(getBytesEncoder(), 128)]
  ]), (value) => ({ ...value, discriminator: RBAC_CONFIG_DISCRIMINATOR }));
}
function getRbacConfigDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    ["authority", getAddressDecoder()],
    ["createdAt", getI64Decoder()],
    ["updatedAt", getI64Decoder()],
    ["version", getU8Decoder()],
    ["roles", getArrayDecoder(getRoleDecoder())],
    ["permissions", getArrayDecoder(getPermissionDecoder())],
    ["accessPolicies", getArrayDecoder(getAccessPolicyDecoder())],
    ["securityPolicies", getSecurityPoliciesDecoder()],
    ["auditConfig", getAccessAuditConfigDecoder()],
    ["emergencyAccess", getEmergencyAccessConfigDecoder()],
    ["reserved", fixDecoderSize(getBytesDecoder(), 128)]
  ]);
}
function getRbacConfigCodec() {
  return combineCodec(getRbacConfigEncoder(), getRbacConfigDecoder());
}
function decodeRbacConfig(encodedAccount) {
  return decodeAccount(encodedAccount, getRbacConfigDecoder());
}
async function fetchRbacConfig(rpc2, address2, config) {
  const maybeAccount = await fetchMaybeRbacConfig(rpc2, address2, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeRbacConfig(rpc2, address2, config) {
  const maybeAccount = await fetchEncodedAccount(rpc2, address2, config);
  return decodeRbacConfig(maybeAccount);
}
async function fetchAllRbacConfig(rpc2, addresses2, config) {
  const maybeAccounts = await fetchAllMaybeRbacConfig(rpc2, addresses2, config);
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeRbacConfig(rpc2, addresses2, config) {
  const maybeAccounts = await fetchEncodedAccounts(rpc2, addresses2, config);
  return maybeAccounts.map((maybeAccount) => decodeRbacConfig(maybeAccount));
}
function getReentrancyGuardDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(REENTRANCY_GUARD_DISCRIMINATOR);
}
function getReentrancyGuardEncoder() {
  return transformEncoder(getStructEncoder([
    ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
    ["state", getReentrancyStateEncoder()],
    ["nonce", getU64Encoder()],
    ["lastInteraction", getI64Encoder()],
    ["authority", getAddressEncoder()],
    ["bump", getU8Encoder()]
  ]), (value) => ({ ...value, discriminator: REENTRANCY_GUARD_DISCRIMINATOR }));
}
function getReentrancyGuardDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    ["state", getReentrancyStateDecoder()],
    ["nonce", getU64Decoder()],
    ["lastInteraction", getI64Decoder()],
    ["authority", getAddressDecoder()],
    ["bump", getU8Decoder()]
  ]);
}
function getReentrancyGuardCodec() {
  return combineCodec(getReentrancyGuardEncoder(), getReentrancyGuardDecoder());
}
function decodeReentrancyGuard(encodedAccount) {
  return decodeAccount(encodedAccount, getReentrancyGuardDecoder());
}
async function fetchReentrancyGuard(rpc2, address2, config) {
  const maybeAccount = await fetchMaybeReentrancyGuard(rpc2, address2, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeReentrancyGuard(rpc2, address2, config) {
  const maybeAccount = await fetchEncodedAccount(rpc2, address2, config);
  return decodeReentrancyGuard(maybeAccount);
}
async function fetchAllReentrancyGuard(rpc2, addresses2, config) {
  const maybeAccounts = await fetchAllMaybeReentrancyGuard(rpc2, addresses2, config);
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeReentrancyGuard(rpc2, addresses2, config) {
  const maybeAccounts = await fetchEncodedAccounts(rpc2, addresses2, config);
  return maybeAccounts.map((maybeAccount) => decodeReentrancyGuard(maybeAccount));
}
function getReentrancyGuardSize() {
  return 58;
}
function getReputationMetricsDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(REPUTATION_METRICS_DISCRIMINATOR);
}
function getReputationMetricsEncoder() {
  return transformEncoder(getStructEncoder([
    ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
    ["agent", getAddressEncoder()],
    ["successfulPayments", getU64Encoder()],
    ["failedPayments", getU64Encoder()],
    ["totalResponseTime", getU64Encoder()],
    ["responseTimeCount", getU64Encoder()],
    ["totalDisputes", getU32Encoder()],
    ["disputesResolved", getU32Encoder()],
    ["totalRating", getU32Encoder()],
    ["totalRatingsCount", getU32Encoder()],
    ["paymentHistory7d", getArrayEncoder(getU64Encoder(), { size: 7 })],
    ["createdAt", getI64Encoder()],
    ["updatedAt", getI64Encoder()],
    [
      "skillTags",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    [
      "behaviorTags",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    [
      "complianceTags",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    ["tagScores", getArrayEncoder(getTagScoreEncoder())],
    ["tagUpdatedAt", getI64Encoder()],
    ["sourceScores", getArrayEncoder(getSourceScoreEncoder())],
    [
      "primarySource",
      addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())
    ],
    ["lastAggregation", getI64Encoder()],
    [
      "conflictFlags",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    ["bump", getU8Encoder()]
  ]), (value) => ({ ...value, discriminator: REPUTATION_METRICS_DISCRIMINATOR }));
}
function getReputationMetricsDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    ["agent", getAddressDecoder()],
    ["successfulPayments", getU64Decoder()],
    ["failedPayments", getU64Decoder()],
    ["totalResponseTime", getU64Decoder()],
    ["responseTimeCount", getU64Decoder()],
    ["totalDisputes", getU32Decoder()],
    ["disputesResolved", getU32Decoder()],
    ["totalRating", getU32Decoder()],
    ["totalRatingsCount", getU32Decoder()],
    ["paymentHistory7d", getArrayDecoder(getU64Decoder(), { size: 7 })],
    ["createdAt", getI64Decoder()],
    ["updatedAt", getI64Decoder()],
    [
      "skillTags",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    [
      "behaviorTags",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    [
      "complianceTags",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    ["tagScores", getArrayDecoder(getTagScoreDecoder())],
    ["tagUpdatedAt", getI64Decoder()],
    ["sourceScores", getArrayDecoder(getSourceScoreDecoder())],
    ["primarySource", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["lastAggregation", getI64Decoder()],
    [
      "conflictFlags",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    ["bump", getU8Decoder()]
  ]);
}
function getReputationMetricsCodec() {
  return combineCodec(getReputationMetricsEncoder(), getReputationMetricsDecoder());
}
function decodeReputationMetrics(encodedAccount) {
  return decodeAccount(encodedAccount, getReputationMetricsDecoder());
}
async function fetchReputationMetrics(rpc2, address2, config) {
  const maybeAccount = await fetchMaybeReputationMetrics(rpc2, address2, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeReputationMetrics(rpc2, address2, config) {
  const maybeAccount = await fetchEncodedAccount(rpc2, address2, config);
  return decodeReputationMetrics(maybeAccount);
}
async function fetchAllReputationMetrics(rpc2, addresses2, config) {
  const maybeAccounts = await fetchAllMaybeReputationMetrics(rpc2, addresses2, config);
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeReputationMetrics(rpc2, addresses2, config) {
  const maybeAccounts = await fetchEncodedAccounts(rpc2, addresses2, config);
  return maybeAccounts.map((maybeAccount) => decodeReputationMetrics(maybeAccount));
}
function getStakingAccountDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(STAKING_ACCOUNT_DISCRIMINATOR);
}
function getStakingAccountEncoder() {
  return transformEncoder(getStructEncoder([
    ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
    ["owner", getAddressEncoder()],
    ["amountStaked", getU64Encoder()],
    ["stakedAt", getI64Encoder()],
    ["lockDuration", getI64Encoder()],
    ["unlockAt", getI64Encoder()],
    ["reputationBoostBps", getU16Encoder()],
    ["hasVerifiedBadge", getBooleanEncoder()],
    ["hasPremiumBenefits", getBooleanEncoder()],
    ["totalSlashed", getU64Encoder()],
    ["tier", getAccessTierEncoder()],
    ["apiCallsRemaining", getU32Encoder()],
    ["lastQuotaReset", getI64Encoder()],
    ["votingPower", getU64Encoder()],
    ["bump", getU8Encoder()]
  ]), (value) => ({ ...value, discriminator: STAKING_ACCOUNT_DISCRIMINATOR }));
}
function getStakingAccountDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    ["owner", getAddressDecoder()],
    ["amountStaked", getU64Decoder()],
    ["stakedAt", getI64Decoder()],
    ["lockDuration", getI64Decoder()],
    ["unlockAt", getI64Decoder()],
    ["reputationBoostBps", getU16Decoder()],
    ["hasVerifiedBadge", getBooleanDecoder()],
    ["hasPremiumBenefits", getBooleanDecoder()],
    ["totalSlashed", getU64Decoder()],
    ["tier", getAccessTierDecoder()],
    ["apiCallsRemaining", getU32Decoder()],
    ["lastQuotaReset", getI64Decoder()],
    ["votingPower", getU64Decoder()],
    ["bump", getU8Decoder()]
  ]);
}
function getStakingAccountCodec() {
  return combineCodec(getStakingAccountEncoder(), getStakingAccountDecoder());
}
function decodeStakingAccount(encodedAccount) {
  return decodeAccount(encodedAccount, getStakingAccountDecoder());
}
async function fetchStakingAccount(rpc2, address2, config) {
  const maybeAccount = await fetchMaybeStakingAccount(rpc2, address2, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeStakingAccount(rpc2, address2, config) {
  const maybeAccount = await fetchEncodedAccount(rpc2, address2, config);
  return decodeStakingAccount(maybeAccount);
}
async function fetchAllStakingAccount(rpc2, addresses2, config) {
  const maybeAccounts = await fetchAllMaybeStakingAccount(rpc2, addresses2, config);
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeStakingAccount(rpc2, addresses2, config) {
  const maybeAccounts = await fetchEncodedAccounts(rpc2, addresses2, config);
  return maybeAccounts.map((maybeAccount) => decodeStakingAccount(maybeAccount));
}
function getStakingAccountSize() {
  return 106;
}
function getStakingConfigDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(STAKING_CONFIG_DISCRIMINATOR);
}
function getStakingConfigEncoder() {
  return transformEncoder(getStructEncoder([
    ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
    ["authority", getAddressEncoder()],
    ["minStake", getU64Encoder()],
    ["minLockDuration", getI64Encoder()],
    ["fraudSlashBps", getU16Encoder()],
    ["disputeSlashBps", getU16Encoder()],
    ["treasury", getAddressEncoder()],
    ["bump", getU8Encoder()]
  ]), (value) => ({ ...value, discriminator: STAKING_CONFIG_DISCRIMINATOR }));
}
function getStakingConfigDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    ["authority", getAddressDecoder()],
    ["minStake", getU64Decoder()],
    ["minLockDuration", getI64Decoder()],
    ["fraudSlashBps", getU16Decoder()],
    ["disputeSlashBps", getU16Decoder()],
    ["treasury", getAddressDecoder()],
    ["bump", getU8Decoder()]
  ]);
}
function getStakingConfigCodec() {
  return combineCodec(getStakingConfigEncoder(), getStakingConfigDecoder());
}
function decodeStakingConfig(encodedAccount) {
  return decodeAccount(encodedAccount, getStakingConfigDecoder());
}
async function fetchStakingConfig(rpc2, address2, config) {
  const maybeAccount = await fetchMaybeStakingConfig(rpc2, address2, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeStakingConfig(rpc2, address2, config) {
  const maybeAccount = await fetchEncodedAccount(rpc2, address2, config);
  return decodeStakingConfig(maybeAccount);
}
async function fetchAllStakingConfig(rpc2, addresses2, config) {
  const maybeAccounts = await fetchAllMaybeStakingConfig(rpc2, addresses2, config);
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeStakingConfig(rpc2, addresses2, config) {
  const maybeAccounts = await fetchEncodedAccounts(rpc2, addresses2, config);
  return maybeAccounts.map((maybeAccount) => decodeStakingConfig(maybeAccount));
}
function getStakingConfigSize() {
  return 93;
}
function getUserRegistryDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(USER_REGISTRY_DISCRIMINATOR);
}
function getUserRegistryEncoder() {
  return transformEncoder(getStructEncoder([
    ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
    ["user", getAddressEncoder()],
    ["agentCount", getU16Encoder()],
    ["listingCount", getU16Encoder()],
    ["workOrderCount", getU16Encoder()],
    ["channelCount", getU16Encoder()],
    ["totalVolumeTraded", getU64Encoder()],
    ["lastActivity", getI64Encoder()],
    ["createdAt", getI64Encoder()],
    ["isRateLimited", getBooleanEncoder()],
    ["rateLimitExpiry", getI64Encoder()],
    ["lastExtensionRegistration", getI64Encoder()],
    ["lastDisputeFiling", getI64Encoder()],
    ["lastEvidenceSubmission", getI64Encoder()],
    ["lastBatchExecution", getI64Encoder()],
    ["lastDashboardUpdate", getI64Encoder()],
    ["lastBulkDealCreation", getI64Encoder()],
    ["lastDashboardCreation", getI64Encoder()],
    ["bump", getU8Encoder()]
  ]), (value) => ({ ...value, discriminator: USER_REGISTRY_DISCRIMINATOR }));
}
function getUserRegistryDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    ["user", getAddressDecoder()],
    ["agentCount", getU16Decoder()],
    ["listingCount", getU16Decoder()],
    ["workOrderCount", getU16Decoder()],
    ["channelCount", getU16Decoder()],
    ["totalVolumeTraded", getU64Decoder()],
    ["lastActivity", getI64Decoder()],
    ["createdAt", getI64Decoder()],
    ["isRateLimited", getBooleanDecoder()],
    ["rateLimitExpiry", getI64Decoder()],
    ["lastExtensionRegistration", getI64Decoder()],
    ["lastDisputeFiling", getI64Decoder()],
    ["lastEvidenceSubmission", getI64Decoder()],
    ["lastBatchExecution", getI64Decoder()],
    ["lastDashboardUpdate", getI64Decoder()],
    ["lastBulkDealCreation", getI64Decoder()],
    ["lastDashboardCreation", getI64Decoder()],
    ["bump", getU8Decoder()]
  ]);
}
function getUserRegistryCodec() {
  return combineCodec(getUserRegistryEncoder(), getUserRegistryDecoder());
}
function decodeUserRegistry(encodedAccount) {
  return decodeAccount(encodedAccount, getUserRegistryDecoder());
}
async function fetchUserRegistry(rpc2, address2, config) {
  const maybeAccount = await fetchMaybeUserRegistry(rpc2, address2, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeUserRegistry(rpc2, address2, config) {
  const maybeAccount = await fetchEncodedAccount(rpc2, address2, config);
  return decodeUserRegistry(maybeAccount);
}
async function fetchAllUserRegistry(rpc2, addresses2, config) {
  const maybeAccounts = await fetchAllMaybeUserRegistry(rpc2, addresses2, config);
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeUserRegistry(rpc2, addresses2, config) {
  const maybeAccounts = await fetchEncodedAccounts(rpc2, addresses2, config);
  return maybeAccounts.map((maybeAccount) => decodeUserRegistry(maybeAccount));
}
function getUserRegistrySize() {
  return 138;
}
function getGhostspeakMarketplaceErrorMessage(code) {
  if (true) {
    return ghostspeakMarketplaceErrorMessages[code];
  }
  return "Error message not available in production bundles.";
}
function isGhostspeakMarketplaceError(error, transactionMessage, code) {
  return isProgramError(error, transactionMessage, GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS, code);
}
function getActivateAgentDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(ACTIVATE_AGENT_DISCRIMINATOR);
}
function getActivateAgentInstructionDataEncoder() {
  return transformEncoder(getStructEncoder([
    ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
    ["agentId", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())]
  ]), (value) => ({ ...value, discriminator: ACTIVATE_AGENT_DISCRIMINATOR }));
}
function getActivateAgentInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    ["agentId", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())]
  ]);
}
function getActivateAgentInstructionDataCodec() {
  return combineCodec(getActivateAgentInstructionDataEncoder(), getActivateAgentInstructionDataDecoder());
}
async function getActivateAgentInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    agentAccount: { value: input.agentAccount ?? null, isWritable: true },
    signer: { value: input.signer ?? null, isWritable: true },
    clock: { value: input.clock ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.agentAccount.value) {
    accounts2.agentAccount.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([97, 103, 101, 110, 116])),
        getAddressEncoder().encode(expectAddress(accounts2.signer.value)),
        getUtf8Encoder().encode(expectSome(args.agentId))
      ]
    });
  }
  if (!accounts2.clock.value) {
    accounts2.clock.value = "SysvarC1ock11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.agentAccount),
      getAccountMeta(accounts2.signer),
      getAccountMeta(accounts2.clock)
    ],
    data: getActivateAgentInstructionDataEncoder().encode(args),
    programAddress
  });
}
function getActivateAgentInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    agentAccount: { value: input.agentAccount ?? null, isWritable: true },
    signer: { value: input.signer ?? null, isWritable: true },
    clock: { value: input.clock ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.clock.value) {
    accounts2.clock.value = "SysvarC1ock11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.agentAccount),
      getAccountMeta(accounts2.signer),
      getAccountMeta(accounts2.clock)
    ],
    data: getActivateAgentInstructionDataEncoder().encode(args),
    programAddress
  });
}
function parseActivateAgentInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      agentAccount: getNextAccount(),
      signer: getNextAccount(),
      clock: getNextAccount()
    },
    data: getActivateAgentInstructionDataDecoder().decode(instruction.data)
  };
}
function getApproveDeliveryDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(APPROVE_DELIVERY_DISCRIMINATOR);
}
function getApproveDeliveryInstructionDataEncoder() {
  return transformEncoder(getStructEncoder([["discriminator", fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({ ...value, discriminator: APPROVE_DELIVERY_DISCRIMINATOR }));
}
function getApproveDeliveryInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)]
  ]);
}
function getApproveDeliveryInstructionDataCodec() {
  return combineCodec(getApproveDeliveryInstructionDataEncoder(), getApproveDeliveryInstructionDataDecoder());
}
function getApproveDeliveryInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    escrow: { value: input.escrow ?? null, isWritable: true },
    escrowVault: { value: input.escrowVault ?? null, isWritable: true },
    agentTokenAccount: {
      value: input.agentTokenAccount ?? null,
      isWritable: true
    },
    client: { value: input.client ?? null, isWritable: false },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  if (!accounts2.tokenProgram.value) {
    accounts2.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.escrow),
      getAccountMeta(accounts2.escrowVault),
      getAccountMeta(accounts2.agentTokenAccount),
      getAccountMeta(accounts2.client),
      getAccountMeta(accounts2.tokenProgram)
    ],
    data: getApproveDeliveryInstructionDataEncoder().encode({}),
    programAddress
  });
}
function parseApproveDeliveryInstruction(instruction) {
  if (instruction.accounts.length < 5) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      escrow: getNextAccount(),
      escrowVault: getNextAccount(),
      agentTokenAccount: getNextAccount(),
      client: getNextAccount(),
      tokenProgram: getNextAccount()
    },
    data: getApproveDeliveryInstructionDataDecoder().decode(instruction.data)
  };
}
function getArbitrateDisputeDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(ARBITRATE_DISPUTE_DISCRIMINATOR);
}
function getArbitrateDisputeInstructionDataEncoder() {
  return transformEncoder(getStructEncoder([
    ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
    ["decision", getArbitratorDecisionEncoder()]
  ]), (value) => ({ ...value, discriminator: ARBITRATE_DISPUTE_DISCRIMINATOR }));
}
function getArbitrateDisputeInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    ["decision", getArbitratorDecisionDecoder()]
  ]);
}
function getArbitrateDisputeInstructionDataCodec() {
  return combineCodec(getArbitrateDisputeInstructionDataEncoder(), getArbitrateDisputeInstructionDataDecoder());
}
function getArbitrateDisputeInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    escrow: { value: input.escrow ?? null, isWritable: true },
    escrowVault: { value: input.escrowVault ?? null, isWritable: true },
    agentTokenAccount: {
      value: input.agentTokenAccount ?? null,
      isWritable: true
    },
    clientTokenAccount: {
      value: input.clientTokenAccount ?? null,
      isWritable: true
    },
    agentStaking: { value: input.agentStaking ?? null, isWritable: true },
    arbitrator: { value: input.arbitrator ?? null, isWritable: false },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.tokenProgram.value) {
    accounts2.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.escrow),
      getAccountMeta(accounts2.escrowVault),
      getAccountMeta(accounts2.agentTokenAccount),
      getAccountMeta(accounts2.clientTokenAccount),
      getAccountMeta(accounts2.agentStaking),
      getAccountMeta(accounts2.arbitrator),
      getAccountMeta(accounts2.tokenProgram)
    ],
    data: getArbitrateDisputeInstructionDataEncoder().encode(args),
    programAddress
  });
}
function parseArbitrateDisputeInstruction(instruction) {
  if (instruction.accounts.length < 7) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      escrow: getNextAccount(),
      escrowVault: getNextAccount(),
      agentTokenAccount: getNextAccount(),
      clientTokenAccount: getNextAccount(),
      agentStaking: getNextAccount(),
      arbitrator: getNextAccount(),
      tokenProgram: getNextAccount()
    },
    data: getArbitrateDisputeInstructionDataDecoder().decode(instruction.data)
  };
}
function getCreateCredentialTemplateDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(CREATE_CREDENTIAL_TEMPLATE_DISCRIMINATOR);
}
function getCreateCredentialTemplateInstructionDataEncoder() {
  return transformEncoder(getStructEncoder([
    ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
    ["name", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["imageUri", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    [
      "crossmintTemplateId",
      getOptionEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ]
  ]), (value) => ({
    ...value,
    discriminator: CREATE_CREDENTIAL_TEMPLATE_DISCRIMINATOR
  }));
}
function getCreateCredentialTemplateInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    ["name", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["imageUri", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    [
      "crossmintTemplateId",
      getOptionDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ]
  ]);
}
function getCreateCredentialTemplateInstructionDataCodec() {
  return combineCodec(getCreateCredentialTemplateInstructionDataEncoder(), getCreateCredentialTemplateInstructionDataDecoder());
}
async function getCreateCredentialTemplateInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    credentialTemplate: {
      value: input.credentialTemplate ?? null,
      isWritable: true
    },
    credentialType: { value: input.credentialType ?? null, isWritable: false },
    issuer: { value: input.issuer ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.credentialTemplate.value) {
    accounts2.credentialTemplate.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([
          99,
          114,
          101,
          100,
          101,
          110,
          116,
          105,
          97,
          108,
          95,
          116,
          101,
          109,
          112,
          108,
          97,
          116,
          101
        ])),
        getAddressEncoder().encode(expectAddress(accounts2.credentialType.value)),
        getUtf8Encoder().encode(expectSome(args.name))
      ]
    });
  }
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.credentialTemplate),
      getAccountMeta(accounts2.credentialType),
      getAccountMeta(accounts2.issuer),
      getAccountMeta(accounts2.systemProgram)
    ],
    data: getCreateCredentialTemplateInstructionDataEncoder().encode(args),
    programAddress
  });
}
function getCreateCredentialTemplateInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    credentialTemplate: {
      value: input.credentialTemplate ?? null,
      isWritable: true
    },
    credentialType: { value: input.credentialType ?? null, isWritable: false },
    issuer: { value: input.issuer ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.credentialTemplate),
      getAccountMeta(accounts2.credentialType),
      getAccountMeta(accounts2.issuer),
      getAccountMeta(accounts2.systemProgram)
    ],
    data: getCreateCredentialTemplateInstructionDataEncoder().encode(args),
    programAddress
  });
}
function parseCreateCredentialTemplateInstruction(instruction) {
  if (instruction.accounts.length < 4) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      credentialTemplate: getNextAccount(),
      credentialType: getNextAccount(),
      issuer: getNextAccount(),
      systemProgram: getNextAccount()
    },
    data: getCreateCredentialTemplateInstructionDataDecoder().decode(instruction.data)
  };
}
function getCreateCredentialTypeDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(CREATE_CREDENTIAL_TYPE_DISCRIMINATOR);
}
function getCreateCredentialTypeInstructionDataEncoder() {
  return transformEncoder(getStructEncoder([
    ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
    ["name", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["kind", getCredentialKindEncoder()],
    ["schemaUri", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["description", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())]
  ]), (value) => ({
    ...value,
    discriminator: CREATE_CREDENTIAL_TYPE_DISCRIMINATOR
  }));
}
function getCreateCredentialTypeInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    ["name", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["kind", getCredentialKindDecoder()],
    ["schemaUri", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["description", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())]
  ]);
}
function getCreateCredentialTypeInstructionDataCodec() {
  return combineCodec(getCreateCredentialTypeInstructionDataEncoder(), getCreateCredentialTypeInstructionDataDecoder());
}
async function getCreateCredentialTypeInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    credentialType: { value: input.credentialType ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.credentialType.value) {
    accounts2.credentialType.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([
          99,
          114,
          101,
          100,
          101,
          110,
          116,
          105,
          97,
          108,
          95,
          116,
          121,
          112,
          101
        ])),
        getUtf8Encoder().encode(expectSome(args.name))
      ]
    });
  }
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.credentialType),
      getAccountMeta(accounts2.authority),
      getAccountMeta(accounts2.systemProgram)
    ],
    data: getCreateCredentialTypeInstructionDataEncoder().encode(args),
    programAddress
  });
}
function getCreateCredentialTypeInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    credentialType: { value: input.credentialType ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.credentialType),
      getAccountMeta(accounts2.authority),
      getAccountMeta(accounts2.systemProgram)
    ],
    data: getCreateCredentialTypeInstructionDataEncoder().encode(args),
    programAddress
  });
}
function parseCreateCredentialTypeInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      credentialType: getNextAccount(),
      authority: getNextAccount(),
      systemProgram: getNextAccount()
    },
    data: getCreateCredentialTypeInstructionDataDecoder().decode(instruction.data)
  };
}
function getCreateDidDocumentDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(CREATE_DID_DOCUMENT_DISCRIMINATOR);
}
function getCreateDidDocumentInstructionDataEncoder() {
  return transformEncoder(getStructEncoder([
    ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
    ["didString", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["verificationMethods", getArrayEncoder(getVerificationMethodEncoder())],
    ["serviceEndpoints", getArrayEncoder(getServiceEndpointEncoder())]
  ]), (value) => ({ ...value, discriminator: CREATE_DID_DOCUMENT_DISCRIMINATOR }));
}
function getCreateDidDocumentInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    ["didString", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["verificationMethods", getArrayDecoder(getVerificationMethodDecoder())],
    ["serviceEndpoints", getArrayDecoder(getServiceEndpointDecoder())]
  ]);
}
function getCreateDidDocumentInstructionDataCodec() {
  return combineCodec(getCreateDidDocumentInstructionDataEncoder(), getCreateDidDocumentInstructionDataDecoder());
}
async function getCreateDidDocumentInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    didDocument: { value: input.didDocument ?? null, isWritable: true },
    controller: { value: input.controller ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    clock: { value: input.clock ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.didDocument.value) {
    accounts2.didDocument.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([
          100,
          105,
          100,
          95,
          100,
          111,
          99,
          117,
          109,
          101,
          110,
          116
        ])),
        getAddressEncoder().encode(expectAddress(accounts2.controller.value))
      ]
    });
  }
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  if (!accounts2.clock.value) {
    accounts2.clock.value = "SysvarC1ock11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.didDocument),
      getAccountMeta(accounts2.controller),
      getAccountMeta(accounts2.systemProgram),
      getAccountMeta(accounts2.clock)
    ],
    data: getCreateDidDocumentInstructionDataEncoder().encode(args),
    programAddress
  });
}
function getCreateDidDocumentInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    didDocument: { value: input.didDocument ?? null, isWritable: true },
    controller: { value: input.controller ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    clock: { value: input.clock ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  if (!accounts2.clock.value) {
    accounts2.clock.value = "SysvarC1ock11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.didDocument),
      getAccountMeta(accounts2.controller),
      getAccountMeta(accounts2.systemProgram),
      getAccountMeta(accounts2.clock)
    ],
    data: getCreateDidDocumentInstructionDataEncoder().encode(args),
    programAddress
  });
}
function parseCreateDidDocumentInstruction(instruction) {
  if (instruction.accounts.length < 4) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      didDocument: getNextAccount(),
      controller: getNextAccount(),
      systemProgram: getNextAccount(),
      clock: getNextAccount()
    },
    data: getCreateDidDocumentInstructionDataDecoder().decode(instruction.data)
  };
}
function getCreateEscrowDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(CREATE_ESCROW_DISCRIMINATOR);
}
function getCreateEscrowInstructionDataEncoder() {
  return transformEncoder(getStructEncoder([
    ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
    ["escrowId", getU64Encoder()],
    ["amount", getU64Encoder()],
    [
      "jobDescription",
      addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())
    ],
    ["deadline", getI64Encoder()]
  ]), (value) => ({ ...value, discriminator: CREATE_ESCROW_DISCRIMINATOR }));
}
function getCreateEscrowInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    ["escrowId", getU64Decoder()],
    ["amount", getU64Decoder()],
    ["jobDescription", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["deadline", getI64Decoder()]
  ]);
}
function getCreateEscrowInstructionDataCodec() {
  return combineCodec(getCreateEscrowInstructionDataEncoder(), getCreateEscrowInstructionDataDecoder());
}
async function getCreateEscrowInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    escrow: { value: input.escrow ?? null, isWritable: true },
    agent: { value: input.agent ?? null, isWritable: false },
    clientTokenAccount: {
      value: input.clientTokenAccount ?? null,
      isWritable: true
    },
    escrowVault: { value: input.escrowVault ?? null, isWritable: true },
    tokenMint: { value: input.tokenMint ?? null, isWritable: false },
    client: { value: input.client ?? null, isWritable: true },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.escrow.value) {
    accounts2.escrow.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([
          103,
          104,
          111,
          115,
          116,
          95,
          112,
          114,
          111,
          116,
          101,
          99,
          116
        ])),
        getAddressEncoder().encode(expectAddress(accounts2.client.value)),
        getU64Encoder().encode(expectSome(args.escrowId))
      ]
    });
  }
  if (!accounts2.tokenProgram.value) {
    accounts2.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.escrow),
      getAccountMeta(accounts2.agent),
      getAccountMeta(accounts2.clientTokenAccount),
      getAccountMeta(accounts2.escrowVault),
      getAccountMeta(accounts2.tokenMint),
      getAccountMeta(accounts2.client),
      getAccountMeta(accounts2.tokenProgram),
      getAccountMeta(accounts2.systemProgram)
    ],
    data: getCreateEscrowInstructionDataEncoder().encode(args),
    programAddress
  });
}
function getCreateEscrowInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    escrow: { value: input.escrow ?? null, isWritable: true },
    agent: { value: input.agent ?? null, isWritable: false },
    clientTokenAccount: {
      value: input.clientTokenAccount ?? null,
      isWritable: true
    },
    escrowVault: { value: input.escrowVault ?? null, isWritable: true },
    tokenMint: { value: input.tokenMint ?? null, isWritable: false },
    client: { value: input.client ?? null, isWritable: true },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.tokenProgram.value) {
    accounts2.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.escrow),
      getAccountMeta(accounts2.agent),
      getAccountMeta(accounts2.clientTokenAccount),
      getAccountMeta(accounts2.escrowVault),
      getAccountMeta(accounts2.tokenMint),
      getAccountMeta(accounts2.client),
      getAccountMeta(accounts2.tokenProgram),
      getAccountMeta(accounts2.systemProgram)
    ],
    data: getCreateEscrowInstructionDataEncoder().encode(args),
    programAddress
  });
}
function parseCreateEscrowInstruction(instruction) {
  if (instruction.accounts.length < 8) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      escrow: getNextAccount(),
      agent: getNextAccount(),
      clientTokenAccount: getNextAccount(),
      escrowVault: getNextAccount(),
      tokenMint: getNextAccount(),
      client: getNextAccount(),
      tokenProgram: getNextAccount(),
      systemProgram: getNextAccount()
    },
    data: getCreateEscrowInstructionDataDecoder().decode(instruction.data)
  };
}
function getCreateMultisigDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(CREATE_MULTISIG_DISCRIMINATOR);
}
function getCreateMultisigInstructionDataEncoder() {
  return transformEncoder(getStructEncoder([
    ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
    ["multisigId", getU64Encoder()],
    ["threshold", getU8Encoder()],
    ["signers", getArrayEncoder(getAddressEncoder())],
    ["config", getMultisigConfigEncoder()]
  ]), (value) => ({ ...value, discriminator: CREATE_MULTISIG_DISCRIMINATOR }));
}
function getCreateMultisigInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    ["multisigId", getU64Decoder()],
    ["threshold", getU8Decoder()],
    ["signers", getArrayDecoder(getAddressDecoder())],
    ["config", getMultisigConfigDecoder()]
  ]);
}
function getCreateMultisigInstructionDataCodec() {
  return combineCodec(getCreateMultisigInstructionDataEncoder(), getCreateMultisigInstructionDataDecoder());
}
async function getCreateMultisigInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    multisig: { value: input.multisig ?? null, isWritable: true },
    owner: { value: input.owner ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.multisig.value) {
    accounts2.multisig.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([109, 117, 108, 116, 105, 115, 105, 103])),
        getAddressEncoder().encode(expectAddress(accounts2.owner.value)),
        getU64Encoder().encode(expectSome(args.multisigId))
      ]
    });
  }
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.multisig),
      getAccountMeta(accounts2.owner),
      getAccountMeta(accounts2.systemProgram)
    ],
    data: getCreateMultisigInstructionDataEncoder().encode(args),
    programAddress
  });
}
function getCreateMultisigInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    multisig: { value: input.multisig ?? null, isWritable: true },
    owner: { value: input.owner ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.multisig),
      getAccountMeta(accounts2.owner),
      getAccountMeta(accounts2.systemProgram)
    ],
    data: getCreateMultisigInstructionDataEncoder().encode(args),
    programAddress
  });
}
function parseCreateMultisigInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      multisig: getNextAccount(),
      owner: getNextAccount(),
      systemProgram: getNextAccount()
    },
    data: getCreateMultisigInstructionDataDecoder().decode(instruction.data)
  };
}
function getDeactivateAgentDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(DEACTIVATE_AGENT_DISCRIMINATOR);
}
function getDeactivateAgentInstructionDataEncoder() {
  return transformEncoder(getStructEncoder([
    ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
    ["agentId", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())]
  ]), (value) => ({ ...value, discriminator: DEACTIVATE_AGENT_DISCRIMINATOR }));
}
function getDeactivateAgentInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    ["agentId", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())]
  ]);
}
function getDeactivateAgentInstructionDataCodec() {
  return combineCodec(getDeactivateAgentInstructionDataEncoder(), getDeactivateAgentInstructionDataDecoder());
}
async function getDeactivateAgentInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    agentAccount: { value: input.agentAccount ?? null, isWritable: true },
    signer: { value: input.signer ?? null, isWritable: true },
    clock: { value: input.clock ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.agentAccount.value) {
    accounts2.agentAccount.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([97, 103, 101, 110, 116])),
        getAddressEncoder().encode(expectAddress(accounts2.signer.value)),
        getUtf8Encoder().encode(expectSome(args.agentId))
      ]
    });
  }
  if (!accounts2.clock.value) {
    accounts2.clock.value = "SysvarC1ock11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.agentAccount),
      getAccountMeta(accounts2.signer),
      getAccountMeta(accounts2.clock)
    ],
    data: getDeactivateAgentInstructionDataEncoder().encode(args),
    programAddress
  });
}
function getDeactivateAgentInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    agentAccount: { value: input.agentAccount ?? null, isWritable: true },
    signer: { value: input.signer ?? null, isWritable: true },
    clock: { value: input.clock ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.clock.value) {
    accounts2.clock.value = "SysvarC1ock11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.agentAccount),
      getAccountMeta(accounts2.signer),
      getAccountMeta(accounts2.clock)
    ],
    data: getDeactivateAgentInstructionDataEncoder().encode(args),
    programAddress
  });
}
function parseDeactivateAgentInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      agentAccount: getNextAccount(),
      signer: getNextAccount(),
      clock: getNextAccount()
    },
    data: getDeactivateAgentInstructionDataDecoder().decode(instruction.data)
  };
}
function getDeactivateCredentialTemplateDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(DEACTIVATE_CREDENTIAL_TEMPLATE_DISCRIMINATOR);
}
function getDeactivateCredentialTemplateInstructionDataEncoder() {
  return transformEncoder(getStructEncoder([["discriminator", fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({
    ...value,
    discriminator: DEACTIVATE_CREDENTIAL_TEMPLATE_DISCRIMINATOR
  }));
}
function getDeactivateCredentialTemplateInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)]
  ]);
}
function getDeactivateCredentialTemplateInstructionDataCodec() {
  return combineCodec(getDeactivateCredentialTemplateInstructionDataEncoder(), getDeactivateCredentialTemplateInstructionDataDecoder());
}
function getDeactivateCredentialTemplateInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    credentialTemplate: {
      value: input.credentialTemplate ?? null,
      isWritable: true
    },
    issuer: { value: input.issuer ?? null, isWritable: true }
  };
  const accounts2 = originalAccounts;
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.credentialTemplate),
      getAccountMeta(accounts2.issuer)
    ],
    data: getDeactivateCredentialTemplateInstructionDataEncoder().encode({}),
    programAddress
  });
}
function parseDeactivateCredentialTemplateInstruction(instruction) {
  if (instruction.accounts.length < 2) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      credentialTemplate: getNextAccount(),
      issuer: getNextAccount()
    },
    data: getDeactivateCredentialTemplateInstructionDataDecoder().decode(instruction.data)
  };
}
function getDeactivateCredentialTypeDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(DEACTIVATE_CREDENTIAL_TYPE_DISCRIMINATOR);
}
function getDeactivateCredentialTypeInstructionDataEncoder() {
  return transformEncoder(getStructEncoder([["discriminator", fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({
    ...value,
    discriminator: DEACTIVATE_CREDENTIAL_TYPE_DISCRIMINATOR
  }));
}
function getDeactivateCredentialTypeInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)]
  ]);
}
function getDeactivateCredentialTypeInstructionDataCodec() {
  return combineCodec(getDeactivateCredentialTypeInstructionDataEncoder(), getDeactivateCredentialTypeInstructionDataDecoder());
}
function getDeactivateCredentialTypeInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    credentialType: { value: input.credentialType ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: true }
  };
  const accounts2 = originalAccounts;
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.credentialType),
      getAccountMeta(accounts2.authority)
    ],
    data: getDeactivateCredentialTypeInstructionDataEncoder().encode({}),
    programAddress
  });
}
function parseDeactivateCredentialTypeInstruction(instruction) {
  if (instruction.accounts.length < 2) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: { credentialType: getNextAccount(), authority: getNextAccount() },
    data: getDeactivateCredentialTypeInstructionDataDecoder().decode(instruction.data)
  };
}
function getDeactivateDidDocumentDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(DEACTIVATE_DID_DOCUMENT_DISCRIMINATOR);
}
function getDeactivateDidDocumentInstructionDataEncoder() {
  return transformEncoder(getStructEncoder([["discriminator", fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({
    ...value,
    discriminator: DEACTIVATE_DID_DOCUMENT_DISCRIMINATOR
  }));
}
function getDeactivateDidDocumentInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)]
  ]);
}
function getDeactivateDidDocumentInstructionDataCodec() {
  return combineCodec(getDeactivateDidDocumentInstructionDataEncoder(), getDeactivateDidDocumentInstructionDataDecoder());
}
async function getDeactivateDidDocumentInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    didDocument: { value: input.didDocument ?? null, isWritable: true },
    controller: { value: input.controller ?? null, isWritable: true },
    clock: { value: input.clock ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  if (!accounts2.didDocument.value) {
    accounts2.didDocument.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([
          100,
          105,
          100,
          95,
          100,
          111,
          99,
          117,
          109,
          101,
          110,
          116
        ])),
        getAddressEncoder().encode(expectAddress(accounts2.controller.value))
      ]
    });
  }
  if (!accounts2.clock.value) {
    accounts2.clock.value = "SysvarC1ock11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.didDocument),
      getAccountMeta(accounts2.controller),
      getAccountMeta(accounts2.clock)
    ],
    data: getDeactivateDidDocumentInstructionDataEncoder().encode({}),
    programAddress
  });
}
function getDeactivateDidDocumentInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    didDocument: { value: input.didDocument ?? null, isWritable: true },
    controller: { value: input.controller ?? null, isWritable: true },
    clock: { value: input.clock ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  if (!accounts2.clock.value) {
    accounts2.clock.value = "SysvarC1ock11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.didDocument),
      getAccountMeta(accounts2.controller),
      getAccountMeta(accounts2.clock)
    ],
    data: getDeactivateDidDocumentInstructionDataEncoder().encode({}),
    programAddress
  });
}
function parseDeactivateDidDocumentInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      didDocument: getNextAccount(),
      controller: getNextAccount(),
      clock: getNextAccount()
    },
    data: getDeactivateDidDocumentInstructionDataDecoder().decode(instruction.data)
  };
}
function getEnableProtocolFeesDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(ENABLE_PROTOCOL_FEES_DISCRIMINATOR);
}
function getEnableProtocolFeesInstructionDataEncoder() {
  return transformEncoder(getStructEncoder([["discriminator", fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({
    ...value,
    discriminator: ENABLE_PROTOCOL_FEES_DISCRIMINATOR
  }));
}
function getEnableProtocolFeesInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)]
  ]);
}
function getEnableProtocolFeesInstructionDataCodec() {
  return combineCodec(getEnableProtocolFeesInstructionDataEncoder(), getEnableProtocolFeesInstructionDataDecoder());
}
async function getEnableProtocolFeesInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    config: { value: input.config ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  if (!accounts2.config.value) {
    accounts2.config.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([
          112,
          114,
          111,
          116,
          111,
          99,
          111,
          108,
          95,
          99,
          111,
          110,
          102,
          105,
          103
        ]))
      ]
    });
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.config),
      getAccountMeta(accounts2.authority)
    ],
    data: getEnableProtocolFeesInstructionDataEncoder().encode({}),
    programAddress
  });
}
function getEnableProtocolFeesInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    config: { value: input.config ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.config),
      getAccountMeta(accounts2.authority)
    ],
    data: getEnableProtocolFeesInstructionDataEncoder().encode({}),
    programAddress
  });
}
function parseEnableProtocolFeesInstruction(instruction) {
  if (instruction.accounts.length < 2) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: { config: getNextAccount(), authority: getNextAccount() },
    data: getEnableProtocolFeesInstructionDataDecoder().decode(instruction.data)
  };
}
function getFileDisputeDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(FILE_DISPUTE_DISCRIMINATOR);
}
function getFileDisputeInstructionDataEncoder() {
  return transformEncoder(getStructEncoder([
    ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
    ["reason", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())]
  ]), (value) => ({ ...value, discriminator: FILE_DISPUTE_DISCRIMINATOR }));
}
function getFileDisputeInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    ["reason", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())]
  ]);
}
function getFileDisputeInstructionDataCodec() {
  return combineCodec(getFileDisputeInstructionDataEncoder(), getFileDisputeInstructionDataDecoder());
}
function getFileDisputeInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    escrow: { value: input.escrow ?? null, isWritable: true },
    client: { value: input.client ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.escrow),
      getAccountMeta(accounts2.client)
    ],
    data: getFileDisputeInstructionDataEncoder().encode(args),
    programAddress
  });
}
function parseFileDisputeInstruction(instruction) {
  if (instruction.accounts.length < 2) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: { escrow: getNextAccount(), client: getNextAccount() },
    data: getFileDisputeInstructionDataDecoder().decode(instruction.data)
  };
}
function getGenerateComplianceReportDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(GENERATE_COMPLIANCE_REPORT_DISCRIMINATOR);
}
function getGenerateComplianceReportInstructionDataEncoder() {
  return transformEncoder(getStructEncoder([
    ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
    ["reportId", getU64Encoder()],
    ["reportType", getReportTypeEncoder()],
    ["dateRangeStart", getI64Encoder()],
    ["dateRangeEnd", getI64Encoder()]
  ]), (value) => ({
    ...value,
    discriminator: GENERATE_COMPLIANCE_REPORT_DISCRIMINATOR
  }));
}
function getGenerateComplianceReportInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    ["reportId", getU64Decoder()],
    ["reportType", getReportTypeDecoder()],
    ["dateRangeStart", getI64Decoder()],
    ["dateRangeEnd", getI64Decoder()]
  ]);
}
function getGenerateComplianceReportInstructionDataCodec() {
  return combineCodec(getGenerateComplianceReportInstructionDataEncoder(), getGenerateComplianceReportInstructionDataDecoder());
}
async function getGenerateComplianceReportInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    report: { value: input.report ?? null, isWritable: true },
    auditTrail: { value: input.auditTrail ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.report.value) {
    accounts2.report.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([
          99,
          111,
          109,
          112,
          108,
          105,
          97,
          110,
          99,
          101,
          95,
          114,
          101,
          112,
          111,
          114,
          116
        ])),
        getU64Encoder().encode(expectSome(args.reportId))
      ]
    });
  }
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.report),
      getAccountMeta(accounts2.auditTrail),
      getAccountMeta(accounts2.authority),
      getAccountMeta(accounts2.systemProgram)
    ],
    data: getGenerateComplianceReportInstructionDataEncoder().encode(args),
    programAddress
  });
}
function getGenerateComplianceReportInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    report: { value: input.report ?? null, isWritable: true },
    auditTrail: { value: input.auditTrail ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.report),
      getAccountMeta(accounts2.auditTrail),
      getAccountMeta(accounts2.authority),
      getAccountMeta(accounts2.systemProgram)
    ],
    data: getGenerateComplianceReportInstructionDataEncoder().encode(args),
    programAddress
  });
}
function parseGenerateComplianceReportInstruction(instruction) {
  if (instruction.accounts.length < 4) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      report: getNextAccount(),
      auditTrail: getNextAccount(),
      authority: getNextAccount(),
      systemProgram: getNextAccount()
    },
    data: getGenerateComplianceReportInstructionDataDecoder().decode(instruction.data)
  };
}
function getInitializeAuditTrailDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(INITIALIZE_AUDIT_TRAIL_DISCRIMINATOR);
}
function getInitializeAuditTrailInstructionDataEncoder() {
  return transformEncoder(getStructEncoder([
    ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
    ["entityType", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["config", getAuditConfigEncoder()]
  ]), (value) => ({
    ...value,
    discriminator: INITIALIZE_AUDIT_TRAIL_DISCRIMINATOR
  }));
}
function getInitializeAuditTrailInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    ["entityType", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["config", getAuditConfigDecoder()]
  ]);
}
function getInitializeAuditTrailInstructionDataCodec() {
  return combineCodec(getInitializeAuditTrailInstructionDataEncoder(), getInitializeAuditTrailInstructionDataDecoder());
}
async function getInitializeAuditTrailInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    auditTrail: { value: input.auditTrail ?? null, isWritable: true },
    entity: { value: input.entity ?? null, isWritable: false },
    authority: { value: input.authority ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.auditTrail.value) {
    accounts2.auditTrail.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([97, 117, 100, 105, 116, 95, 116, 114, 97, 105, 108])),
        getAddressEncoder().encode(expectAddress(accounts2.entity.value))
      ]
    });
  }
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.auditTrail),
      getAccountMeta(accounts2.entity),
      getAccountMeta(accounts2.authority),
      getAccountMeta(accounts2.systemProgram)
    ],
    data: getInitializeAuditTrailInstructionDataEncoder().encode(args),
    programAddress
  });
}
function getInitializeAuditTrailInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    auditTrail: { value: input.auditTrail ?? null, isWritable: true },
    entity: { value: input.entity ?? null, isWritable: false },
    authority: { value: input.authority ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.auditTrail),
      getAccountMeta(accounts2.entity),
      getAccountMeta(accounts2.authority),
      getAccountMeta(accounts2.systemProgram)
    ],
    data: getInitializeAuditTrailInstructionDataEncoder().encode(args),
    programAddress
  });
}
function parseInitializeAuditTrailInstruction(instruction) {
  if (instruction.accounts.length < 4) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      auditTrail: getNextAccount(),
      entity: getNextAccount(),
      authority: getNextAccount(),
      systemProgram: getNextAccount()
    },
    data: getInitializeAuditTrailInstructionDataDecoder().decode(instruction.data)
  };
}
function getInitializeGovernanceProposalDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(INITIALIZE_GOVERNANCE_PROPOSAL_DISCRIMINATOR);
}
function getInitializeGovernanceProposalInstructionDataEncoder() {
  return transformEncoder(getStructEncoder([
    ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
    ["proposalId", getU64Encoder()],
    ["title", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["description", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["proposalType", getProposalTypeEncoder()],
    ["executionParams", getExecutionParamsEncoder()]
  ]), (value) => ({
    ...value,
    discriminator: INITIALIZE_GOVERNANCE_PROPOSAL_DISCRIMINATOR
  }));
}
function getInitializeGovernanceProposalInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    ["proposalId", getU64Decoder()],
    ["title", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["description", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["proposalType", getProposalTypeDecoder()],
    ["executionParams", getExecutionParamsDecoder()]
  ]);
}
function getInitializeGovernanceProposalInstructionDataCodec() {
  return combineCodec(getInitializeGovernanceProposalInstructionDataEncoder(), getInitializeGovernanceProposalInstructionDataDecoder());
}
async function getInitializeGovernanceProposalInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    proposal: { value: input.proposal ?? null, isWritable: true },
    proposer: { value: input.proposer ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.proposal.value) {
    accounts2.proposal.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([
          103,
          111,
          118,
          101,
          114,
          110,
          97,
          110,
          99,
          101,
          95,
          112,
          114,
          111,
          112,
          111,
          115,
          97,
          108
        ])),
        getU64Encoder().encode(expectSome(args.proposalId))
      ]
    });
  }
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.proposal),
      getAccountMeta(accounts2.proposer),
      getAccountMeta(accounts2.systemProgram)
    ],
    data: getInitializeGovernanceProposalInstructionDataEncoder().encode(args),
    programAddress
  });
}
function getInitializeGovernanceProposalInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    proposal: { value: input.proposal ?? null, isWritable: true },
    proposer: { value: input.proposer ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.proposal),
      getAccountMeta(accounts2.proposer),
      getAccountMeta(accounts2.systemProgram)
    ],
    data: getInitializeGovernanceProposalInstructionDataEncoder().encode(args),
    programAddress
  });
}
function parseInitializeGovernanceProposalInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      proposal: getNextAccount(),
      proposer: getNextAccount(),
      systemProgram: getNextAccount()
    },
    data: getInitializeGovernanceProposalInstructionDataDecoder().decode(instruction.data)
  };
}
function getInitializeProtocolConfigDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(INITIALIZE_PROTOCOL_CONFIG_DISCRIMINATOR);
}
function getInitializeProtocolConfigInstructionDataEncoder() {
  return transformEncoder(getStructEncoder([["discriminator", fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({
    ...value,
    discriminator: INITIALIZE_PROTOCOL_CONFIG_DISCRIMINATOR
  }));
}
function getInitializeProtocolConfigInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)]
  ]);
}
function getInitializeProtocolConfigInstructionDataCodec() {
  return combineCodec(getInitializeProtocolConfigInstructionDataEncoder(), getInitializeProtocolConfigInstructionDataDecoder());
}
async function getInitializeProtocolConfigInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    config: { value: input.config ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: true },
    treasury: { value: input.treasury ?? null, isWritable: false },
    buybackPool: { value: input.buybackPool ?? null, isWritable: false },
    moderatorPool: { value: input.moderatorPool ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  if (!accounts2.config.value) {
    accounts2.config.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([
          112,
          114,
          111,
          116,
          111,
          99,
          111,
          108,
          95,
          99,
          111,
          110,
          102,
          105,
          103
        ]))
      ]
    });
  }
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.config),
      getAccountMeta(accounts2.authority),
      getAccountMeta(accounts2.treasury),
      getAccountMeta(accounts2.buybackPool),
      getAccountMeta(accounts2.moderatorPool),
      getAccountMeta(accounts2.systemProgram)
    ],
    data: getInitializeProtocolConfigInstructionDataEncoder().encode({}),
    programAddress
  });
}
function getInitializeProtocolConfigInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    config: { value: input.config ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: true },
    treasury: { value: input.treasury ?? null, isWritable: false },
    buybackPool: { value: input.buybackPool ?? null, isWritable: false },
    moderatorPool: { value: input.moderatorPool ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.config),
      getAccountMeta(accounts2.authority),
      getAccountMeta(accounts2.treasury),
      getAccountMeta(accounts2.buybackPool),
      getAccountMeta(accounts2.moderatorPool),
      getAccountMeta(accounts2.systemProgram)
    ],
    data: getInitializeProtocolConfigInstructionDataEncoder().encode({}),
    programAddress
  });
}
function parseInitializeProtocolConfigInstruction(instruction) {
  if (instruction.accounts.length < 6) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      config: getNextAccount(),
      authority: getNextAccount(),
      treasury: getNextAccount(),
      buybackPool: getNextAccount(),
      moderatorPool: getNextAccount(),
      systemProgram: getNextAccount()
    },
    data: getInitializeProtocolConfigInstructionDataDecoder().decode(instruction.data)
  };
}
function getInitializeRbacConfigDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(INITIALIZE_RBAC_CONFIG_DISCRIMINATOR);
}
function getInitializeRbacConfigInstructionDataEncoder() {
  return transformEncoder(getStructEncoder([
    ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
    ["initialRoles", getArrayEncoder(getRoleEncoder())]
  ]), (value) => ({
    ...value,
    discriminator: INITIALIZE_RBAC_CONFIG_DISCRIMINATOR
  }));
}
function getInitializeRbacConfigInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    ["initialRoles", getArrayDecoder(getRoleDecoder())]
  ]);
}
function getInitializeRbacConfigInstructionDataCodec() {
  return combineCodec(getInitializeRbacConfigInstructionDataEncoder(), getInitializeRbacConfigInstructionDataDecoder());
}
async function getInitializeRbacConfigInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    rbacConfig: { value: input.rbacConfig ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.rbacConfig.value) {
    accounts2.rbacConfig.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([114, 98, 97, 99, 95, 99, 111, 110, 102, 105, 103])),
        getAddressEncoder().encode(expectAddress(accounts2.authority.value))
      ]
    });
  }
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.rbacConfig),
      getAccountMeta(accounts2.authority),
      getAccountMeta(accounts2.systemProgram)
    ],
    data: getInitializeRbacConfigInstructionDataEncoder().encode(args),
    programAddress
  });
}
function getInitializeRbacConfigInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    rbacConfig: { value: input.rbacConfig ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.rbacConfig),
      getAccountMeta(accounts2.authority),
      getAccountMeta(accounts2.systemProgram)
    ],
    data: getInitializeRbacConfigInstructionDataEncoder().encode(args),
    programAddress
  });
}
function parseInitializeRbacConfigInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      rbacConfig: getNextAccount(),
      authority: getNextAccount(),
      systemProgram: getNextAccount()
    },
    data: getInitializeRbacConfigInstructionDataDecoder().decode(instruction.data)
  };
}
function getInitializeReputationMetricsDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(INITIALIZE_REPUTATION_METRICS_DISCRIMINATOR);
}
function getInitializeReputationMetricsInstructionDataEncoder() {
  return transformEncoder(getStructEncoder([["discriminator", fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({
    ...value,
    discriminator: INITIALIZE_REPUTATION_METRICS_DISCRIMINATOR
  }));
}
function getInitializeReputationMetricsInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)]
  ]);
}
function getInitializeReputationMetricsInstructionDataCodec() {
  return combineCodec(getInitializeReputationMetricsInstructionDataEncoder(), getInitializeReputationMetricsInstructionDataDecoder());
}
async function getInitializeReputationMetricsInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    reputationMetrics: {
      value: input.reputationMetrics ?? null,
      isWritable: true
    },
    agent: { value: input.agent ?? null, isWritable: false },
    authority: { value: input.authority ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    clock: { value: input.clock ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  if (!accounts2.reputationMetrics.value) {
    accounts2.reputationMetrics.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([
          114,
          101,
          112,
          117,
          116,
          97,
          116,
          105,
          111,
          110,
          95,
          109,
          101,
          116,
          114,
          105,
          99,
          115
        ])),
        getAddressEncoder().encode(expectAddress(accounts2.agent.value))
      ]
    });
  }
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  if (!accounts2.clock.value) {
    accounts2.clock.value = "SysvarC1ock11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.reputationMetrics),
      getAccountMeta(accounts2.agent),
      getAccountMeta(accounts2.authority),
      getAccountMeta(accounts2.systemProgram),
      getAccountMeta(accounts2.clock)
    ],
    data: getInitializeReputationMetricsInstructionDataEncoder().encode({}),
    programAddress
  });
}
function getInitializeReputationMetricsInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    reputationMetrics: {
      value: input.reputationMetrics ?? null,
      isWritable: true
    },
    agent: { value: input.agent ?? null, isWritable: false },
    authority: { value: input.authority ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    clock: { value: input.clock ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  if (!accounts2.clock.value) {
    accounts2.clock.value = "SysvarC1ock11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.reputationMetrics),
      getAccountMeta(accounts2.agent),
      getAccountMeta(accounts2.authority),
      getAccountMeta(accounts2.systemProgram),
      getAccountMeta(accounts2.clock)
    ],
    data: getInitializeReputationMetricsInstructionDataEncoder().encode({}),
    programAddress
  });
}
function parseInitializeReputationMetricsInstruction(instruction) {
  if (instruction.accounts.length < 5) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      reputationMetrics: getNextAccount(),
      agent: getNextAccount(),
      authority: getNextAccount(),
      systemProgram: getNextAccount(),
      clock: getNextAccount()
    },
    data: getInitializeReputationMetricsInstructionDataDecoder().decode(instruction.data)
  };
}
function getInitializeStakingConfigDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(INITIALIZE_STAKING_CONFIG_DISCRIMINATOR);
}
function getInitializeStakingConfigInstructionDataEncoder() {
  return transformEncoder(getStructEncoder([
    ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
    ["minStake", getU64Encoder()],
    ["treasury", getAddressEncoder()]
  ]), (value) => ({
    ...value,
    discriminator: INITIALIZE_STAKING_CONFIG_DISCRIMINATOR
  }));
}
function getInitializeStakingConfigInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    ["minStake", getU64Decoder()],
    ["treasury", getAddressDecoder()]
  ]);
}
function getInitializeStakingConfigInstructionDataCodec() {
  return combineCodec(getInitializeStakingConfigInstructionDataEncoder(), getInitializeStakingConfigInstructionDataDecoder());
}
async function getInitializeStakingConfigInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    stakingConfig: { value: input.stakingConfig ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.stakingConfig.value) {
    accounts2.stakingConfig.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([
          115,
          116,
          97,
          107,
          105,
          110,
          103,
          95,
          99,
          111,
          110,
          102,
          105,
          103
        ]))
      ]
    });
  }
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.stakingConfig),
      getAccountMeta(accounts2.authority),
      getAccountMeta(accounts2.systemProgram)
    ],
    data: getInitializeStakingConfigInstructionDataEncoder().encode(args),
    programAddress
  });
}
function getInitializeStakingConfigInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    stakingConfig: { value: input.stakingConfig ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.stakingConfig),
      getAccountMeta(accounts2.authority),
      getAccountMeta(accounts2.systemProgram)
    ],
    data: getInitializeStakingConfigInstructionDataEncoder().encode(args),
    programAddress
  });
}
function parseInitializeStakingConfigInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      stakingConfig: getNextAccount(),
      authority: getNextAccount(),
      systemProgram: getNextAccount()
    },
    data: getInitializeStakingConfigInstructionDataDecoder().decode(instruction.data)
  };
}
function getInitReentrancyGuardDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(INIT_REENTRANCY_GUARD_DISCRIMINATOR);
}
function getInitReentrancyGuardInstructionDataEncoder() {
  return transformEncoder(getStructEncoder([["discriminator", fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({
    ...value,
    discriminator: INIT_REENTRANCY_GUARD_DISCRIMINATOR
  }));
}
function getInitReentrancyGuardInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)]
  ]);
}
function getInitReentrancyGuardInstructionDataCodec() {
  return combineCodec(getInitReentrancyGuardInstructionDataEncoder(), getInitReentrancyGuardInstructionDataDecoder());
}
async function getInitReentrancyGuardInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    reentrancyGuard: { value: input.reentrancyGuard ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  if (!accounts2.reentrancyGuard.value) {
    accounts2.reentrancyGuard.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([
          114,
          101,
          101,
          110,
          116,
          114,
          97,
          110,
          99,
          121,
          95,
          103,
          117,
          97,
          114,
          100
        ]))
      ]
    });
  }
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.reentrancyGuard),
      getAccountMeta(accounts2.authority),
      getAccountMeta(accounts2.systemProgram)
    ],
    data: getInitReentrancyGuardInstructionDataEncoder().encode({}),
    programAddress
  });
}
function getInitReentrancyGuardInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    reentrancyGuard: { value: input.reentrancyGuard ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.reentrancyGuard),
      getAccountMeta(accounts2.authority),
      getAccountMeta(accounts2.systemProgram)
    ],
    data: getInitReentrancyGuardInstructionDataEncoder().encode({}),
    programAddress
  });
}
function parseInitReentrancyGuardInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      reentrancyGuard: getNextAccount(),
      authority: getNextAccount(),
      systemProgram: getNextAccount()
    },
    data: getInitReentrancyGuardInstructionDataDecoder().decode(instruction.data)
  };
}
function getIssueCredentialDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(ISSUE_CREDENTIAL_DISCRIMINATOR);
}
function getIssueCredentialInstructionDataEncoder() {
  return transformEncoder(getStructEncoder([
    ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
    ["credentialId", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["subjectDataHash", fixEncoderSize(getBytesEncoder(), 32)],
    [
      "subjectDataUri",
      addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())
    ],
    ["expiresAt", getOptionEncoder(getI64Encoder())],
    ["sourceAccount", getOptionEncoder(getAddressEncoder())]
  ]), (value) => ({ ...value, discriminator: ISSUE_CREDENTIAL_DISCRIMINATOR }));
}
function getIssueCredentialInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    ["credentialId", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["subjectDataHash", fixDecoderSize(getBytesDecoder(), 32)],
    ["subjectDataUri", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["expiresAt", getOptionDecoder(getI64Decoder())],
    ["sourceAccount", getOptionDecoder(getAddressDecoder())]
  ]);
}
function getIssueCredentialInstructionDataCodec() {
  return combineCodec(getIssueCredentialInstructionDataEncoder(), getIssueCredentialInstructionDataDecoder());
}
async function getIssueCredentialInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    credential: { value: input.credential ?? null, isWritable: true },
    credentialTemplate: {
      value: input.credentialTemplate ?? null,
      isWritable: true
    },
    credentialType: { value: input.credentialType ?? null, isWritable: true },
    subject: { value: input.subject ?? null, isWritable: false },
    issuer: { value: input.issuer ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.credential.value) {
    accounts2.credential.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([99, 114, 101, 100, 101, 110, 116, 105, 97, 108])),
        getAddressEncoder().encode(expectAddress(accounts2.credentialTemplate.value)),
        getAddressEncoder().encode(expectAddress(accounts2.subject.value)),
        getUtf8Encoder().encode(expectSome(args.credentialId))
      ]
    });
  }
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.credential),
      getAccountMeta(accounts2.credentialTemplate),
      getAccountMeta(accounts2.credentialType),
      getAccountMeta(accounts2.subject),
      getAccountMeta(accounts2.issuer),
      getAccountMeta(accounts2.systemProgram)
    ],
    data: getIssueCredentialInstructionDataEncoder().encode(args),
    programAddress
  });
}
function getIssueCredentialInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    credential: { value: input.credential ?? null, isWritable: true },
    credentialTemplate: {
      value: input.credentialTemplate ?? null,
      isWritable: true
    },
    credentialType: { value: input.credentialType ?? null, isWritable: true },
    subject: { value: input.subject ?? null, isWritable: false },
    issuer: { value: input.issuer ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.credential),
      getAccountMeta(accounts2.credentialTemplate),
      getAccountMeta(accounts2.credentialType),
      getAccountMeta(accounts2.subject),
      getAccountMeta(accounts2.issuer),
      getAccountMeta(accounts2.systemProgram)
    ],
    data: getIssueCredentialInstructionDataEncoder().encode(args),
    programAddress
  });
}
function parseIssueCredentialInstruction(instruction) {
  if (instruction.accounts.length < 6) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      credential: getNextAccount(),
      credentialTemplate: getNextAccount(),
      credentialType: getNextAccount(),
      subject: getNextAccount(),
      issuer: getNextAccount(),
      systemProgram: getNextAccount()
    },
    data: getIssueCredentialInstructionDataDecoder().decode(instruction.data)
  };
}
function getManageAgentStatusDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(MANAGE_AGENT_STATUS_DISCRIMINATOR);
}
function getManageAgentStatusInstructionDataEncoder() {
  return transformEncoder(getStructEncoder([
    ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
    ["newStatus", getBooleanEncoder()]
  ]), (value) => ({ ...value, discriminator: MANAGE_AGENT_STATUS_DISCRIMINATOR }));
}
function getManageAgentStatusInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    ["newStatus", getBooleanDecoder()]
  ]);
}
function getManageAgentStatusInstructionDataCodec() {
  return combineCodec(getManageAgentStatusInstructionDataEncoder(), getManageAgentStatusInstructionDataDecoder());
}
async function getManageAgentStatusInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    agent: { value: input.agent ?? null, isWritable: true },
    owner: { value: input.owner ?? null, isWritable: false },
    clock: { value: input.clock ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.agent.value) {
    accounts2.agent.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([97, 103, 101, 110, 116])),
        getAddressEncoder().encode(expectAddress(accounts2.owner.value))
      ]
    });
  }
  if (!accounts2.clock.value) {
    accounts2.clock.value = "SysvarC1ock11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.agent),
      getAccountMeta(accounts2.owner),
      getAccountMeta(accounts2.clock)
    ],
    data: getManageAgentStatusInstructionDataEncoder().encode(args),
    programAddress
  });
}
function getManageAgentStatusInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    agent: { value: input.agent ?? null, isWritable: true },
    owner: { value: input.owner ?? null, isWritable: false },
    clock: { value: input.clock ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.clock.value) {
    accounts2.clock.value = "SysvarC1ock11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.agent),
      getAccountMeta(accounts2.owner),
      getAccountMeta(accounts2.clock)
    ],
    data: getManageAgentStatusInstructionDataEncoder().encode(args),
    programAddress
  });
}
function parseManageAgentStatusInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      agent: getNextAccount(),
      owner: getNextAccount(),
      clock: getNextAccount()
    },
    data: getManageAgentStatusInstructionDataDecoder().decode(instruction.data)
  };
}
function getRecordPayaiPaymentDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(RECORD_PAYAI_PAYMENT_DISCRIMINATOR);
}
function getRecordPayaiPaymentInstructionDataEncoder() {
  return transformEncoder(getStructEncoder([
    ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
    [
      "paymentSignature",
      addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())
    ],
    ["amount", getU64Encoder()],
    ["responseTimeMs", getU64Encoder()],
    ["success", getBooleanEncoder()]
  ]), (value) => ({
    ...value,
    discriminator: RECORD_PAYAI_PAYMENT_DISCRIMINATOR
  }));
}
function getRecordPayaiPaymentInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    [
      "paymentSignature",
      addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())
    ],
    ["amount", getU64Decoder()],
    ["responseTimeMs", getU64Decoder()],
    ["success", getBooleanDecoder()]
  ]);
}
function getRecordPayaiPaymentInstructionDataCodec() {
  return combineCodec(getRecordPayaiPaymentInstructionDataEncoder(), getRecordPayaiPaymentInstructionDataDecoder());
}
async function getRecordPayaiPaymentInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    reputationMetrics: {
      value: input.reputationMetrics ?? null,
      isWritable: true
    },
    agent: { value: input.agent ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: false },
    clock: { value: input.clock ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.reputationMetrics.value) {
    accounts2.reputationMetrics.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([
          114,
          101,
          112,
          117,
          116,
          97,
          116,
          105,
          111,
          110,
          95,
          109,
          101,
          116,
          114,
          105,
          99,
          115
        ])),
        getAddressEncoder().encode(expectAddress(accounts2.agent.value))
      ]
    });
  }
  if (!accounts2.clock.value) {
    accounts2.clock.value = "SysvarC1ock11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.reputationMetrics),
      getAccountMeta(accounts2.agent),
      getAccountMeta(accounts2.authority),
      getAccountMeta(accounts2.clock)
    ],
    data: getRecordPayaiPaymentInstructionDataEncoder().encode(args),
    programAddress
  });
}
function getRecordPayaiPaymentInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    reputationMetrics: {
      value: input.reputationMetrics ?? null,
      isWritable: true
    },
    agent: { value: input.agent ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: false },
    clock: { value: input.clock ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.clock.value) {
    accounts2.clock.value = "SysvarC1ock11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.reputationMetrics),
      getAccountMeta(accounts2.agent),
      getAccountMeta(accounts2.authority),
      getAccountMeta(accounts2.clock)
    ],
    data: getRecordPayaiPaymentInstructionDataEncoder().encode(args),
    programAddress
  });
}
function parseRecordPayaiPaymentInstruction(instruction) {
  if (instruction.accounts.length < 4) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      reputationMetrics: getNextAccount(),
      agent: getNextAccount(),
      authority: getNextAccount(),
      clock: getNextAccount()
    },
    data: getRecordPayaiPaymentInstructionDataDecoder().decode(instruction.data)
  };
}
function getRegisterAgentDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(REGISTER_AGENT_DISCRIMINATOR);
}
function getRegisterAgentInstructionDataEncoder() {
  return transformEncoder(getStructEncoder([
    ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
    ["agentType", getU8Encoder()],
    ["name", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["description", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["metadataUri", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["agentId", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["pricingModel", getPricingModelEncoder()]
  ]), (value) => ({ ...value, discriminator: REGISTER_AGENT_DISCRIMINATOR }));
}
function getRegisterAgentInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    ["agentType", getU8Decoder()],
    ["name", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["description", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["metadataUri", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["agentId", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["pricingModel", getPricingModelDecoder()]
  ]);
}
function getRegisterAgentInstructionDataCodec() {
  return combineCodec(getRegisterAgentInstructionDataEncoder(), getRegisterAgentInstructionDataDecoder());
}
async function getRegisterAgentInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    agentAccount: { value: input.agentAccount ?? null, isWritable: true },
    stakingAccount: { value: input.stakingAccount ?? null, isWritable: false },
    signer: { value: input.signer ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    clock: { value: input.clock ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.agentAccount.value) {
    accounts2.agentAccount.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([97, 103, 101, 110, 116])),
        getAddressEncoder().encode(expectAddress(accounts2.signer.value)),
        getUtf8Encoder().encode(expectSome(args.agentId))
      ]
    });
  }
  if (!accounts2.stakingAccount.value) {
    accounts2.stakingAccount.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([115, 116, 97, 107, 105, 110, 103])),
        getAddressEncoder().encode(expectAddress(accounts2.signer.value))
      ]
    });
  }
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  if (!accounts2.clock.value) {
    accounts2.clock.value = "SysvarC1ock11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.agentAccount),
      getAccountMeta(accounts2.stakingAccount),
      getAccountMeta(accounts2.signer),
      getAccountMeta(accounts2.systemProgram),
      getAccountMeta(accounts2.clock)
    ],
    data: getRegisterAgentInstructionDataEncoder().encode(args),
    programAddress
  });
}
function getRegisterAgentInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    agentAccount: { value: input.agentAccount ?? null, isWritable: true },
    stakingAccount: { value: input.stakingAccount ?? null, isWritable: false },
    signer: { value: input.signer ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    clock: { value: input.clock ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  if (!accounts2.clock.value) {
    accounts2.clock.value = "SysvarC1ock11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.agentAccount),
      getAccountMeta(accounts2.stakingAccount),
      getAccountMeta(accounts2.signer),
      getAccountMeta(accounts2.systemProgram),
      getAccountMeta(accounts2.clock)
    ],
    data: getRegisterAgentInstructionDataEncoder().encode(args),
    programAddress
  });
}
function parseRegisterAgentInstruction(instruction) {
  if (instruction.accounts.length < 5) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      agentAccount: getNextAccount(),
      stakingAccount: getNextAccount(),
      signer: getNextAccount(),
      systemProgram: getNextAccount(),
      clock: getNextAccount()
    },
    data: getRegisterAgentInstructionDataDecoder().decode(instruction.data)
  };
}
function getRegisterAgentCompressedDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(REGISTER_AGENT_COMPRESSED_DISCRIMINATOR);
}
function getRegisterAgentCompressedInstructionDataEncoder() {
  return transformEncoder(getStructEncoder([
    ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
    ["agentType", getU8Encoder()],
    ["metadataUri", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["agentId", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["name", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["description", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["pricingModel", getPricingModelEncoder()]
  ]), (value) => ({
    ...value,
    discriminator: REGISTER_AGENT_COMPRESSED_DISCRIMINATOR
  }));
}
function getRegisterAgentCompressedInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    ["agentType", getU8Decoder()],
    ["metadataUri", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["agentId", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["name", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["description", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["pricingModel", getPricingModelDecoder()]
  ]);
}
function getRegisterAgentCompressedInstructionDataCodec() {
  return combineCodec(getRegisterAgentCompressedInstructionDataEncoder(), getRegisterAgentCompressedInstructionDataDecoder());
}
async function getRegisterAgentCompressedInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    treeAuthority: { value: input.treeAuthority ?? null, isWritable: true },
    merkleTree: { value: input.merkleTree ?? null, isWritable: true },
    userRegistry: { value: input.userRegistry ?? null, isWritable: true },
    signer: { value: input.signer ?? null, isWritable: true },
    compressionProgram: {
      value: input.compressionProgram ?? null,
      isWritable: false
    },
    logWrapper: { value: input.logWrapper ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    clock: { value: input.clock ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.treeAuthority.value) {
    accounts2.treeAuthority.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([
          97,
          103,
          101,
          110,
          116,
          95,
          116,
          114,
          101,
          101,
          95,
          99,
          111,
          110,
          102,
          105,
          103
        ])),
        getAddressEncoder().encode(expectAddress(accounts2.signer.value))
      ]
    });
  }
  if (!accounts2.userRegistry.value) {
    accounts2.userRegistry.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([
          117,
          115,
          101,
          114,
          95,
          114,
          101,
          103,
          105,
          115,
          116,
          114,
          121
        ])),
        getAddressEncoder().encode(expectAddress(accounts2.signer.value))
      ]
    });
  }
  if (!accounts2.compressionProgram.value) {
    accounts2.compressionProgram.value = "cmtDvXumGCrqC1Age74AVPhSRVXJMd8PJS91L8KbNCK";
  }
  if (!accounts2.logWrapper.value) {
    accounts2.logWrapper.value = "noopb9bkMVfRPU8AsbpTUg8AQkHtKwMYZiFUjNRtMmV";
  }
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  if (!accounts2.clock.value) {
    accounts2.clock.value = "SysvarC1ock11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.treeAuthority),
      getAccountMeta(accounts2.merkleTree),
      getAccountMeta(accounts2.userRegistry),
      getAccountMeta(accounts2.signer),
      getAccountMeta(accounts2.compressionProgram),
      getAccountMeta(accounts2.logWrapper),
      getAccountMeta(accounts2.systemProgram),
      getAccountMeta(accounts2.clock)
    ],
    data: getRegisterAgentCompressedInstructionDataEncoder().encode(args),
    programAddress
  });
}
function getRegisterAgentCompressedInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    treeAuthority: { value: input.treeAuthority ?? null, isWritable: true },
    merkleTree: { value: input.merkleTree ?? null, isWritable: true },
    userRegistry: { value: input.userRegistry ?? null, isWritable: true },
    signer: { value: input.signer ?? null, isWritable: true },
    compressionProgram: {
      value: input.compressionProgram ?? null,
      isWritable: false
    },
    logWrapper: { value: input.logWrapper ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    clock: { value: input.clock ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.compressionProgram.value) {
    accounts2.compressionProgram.value = "cmtDvXumGCrqC1Age74AVPhSRVXJMd8PJS91L8KbNCK";
  }
  if (!accounts2.logWrapper.value) {
    accounts2.logWrapper.value = "noopb9bkMVfRPU8AsbpTUg8AQkHtKwMYZiFUjNRtMmV";
  }
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  if (!accounts2.clock.value) {
    accounts2.clock.value = "SysvarC1ock11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.treeAuthority),
      getAccountMeta(accounts2.merkleTree),
      getAccountMeta(accounts2.userRegistry),
      getAccountMeta(accounts2.signer),
      getAccountMeta(accounts2.compressionProgram),
      getAccountMeta(accounts2.logWrapper),
      getAccountMeta(accounts2.systemProgram),
      getAccountMeta(accounts2.clock)
    ],
    data: getRegisterAgentCompressedInstructionDataEncoder().encode(args),
    programAddress
  });
}
function parseRegisterAgentCompressedInstruction(instruction) {
  if (instruction.accounts.length < 8) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      treeAuthority: getNextAccount(),
      merkleTree: getNextAccount(),
      userRegistry: getNextAccount(),
      signer: getNextAccount(),
      compressionProgram: getNextAccount(),
      logWrapper: getNextAccount(),
      systemProgram: getNextAccount(),
      clock: getNextAccount()
    },
    data: getRegisterAgentCompressedInstructionDataDecoder().decode(instruction.data)
  };
}
function getResetReentrancyGuardDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(RESET_REENTRANCY_GUARD_DISCRIMINATOR);
}
function getResetReentrancyGuardInstructionDataEncoder() {
  return transformEncoder(getStructEncoder([["discriminator", fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({
    ...value,
    discriminator: RESET_REENTRANCY_GUARD_DISCRIMINATOR
  }));
}
function getResetReentrancyGuardInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)]
  ]);
}
function getResetReentrancyGuardInstructionDataCodec() {
  return combineCodec(getResetReentrancyGuardInstructionDataEncoder(), getResetReentrancyGuardInstructionDataDecoder());
}
async function getResetReentrancyGuardInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    reentrancyGuard: { value: input.reentrancyGuard ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: true }
  };
  const accounts2 = originalAccounts;
  if (!accounts2.reentrancyGuard.value) {
    accounts2.reentrancyGuard.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([
          114,
          101,
          101,
          110,
          116,
          114,
          97,
          110,
          99,
          121,
          95,
          103,
          117,
          97,
          114,
          100
        ]))
      ]
    });
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.reentrancyGuard),
      getAccountMeta(accounts2.authority)
    ],
    data: getResetReentrancyGuardInstructionDataEncoder().encode({}),
    programAddress
  });
}
function getResetReentrancyGuardInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    reentrancyGuard: { value: input.reentrancyGuard ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: true }
  };
  const accounts2 = originalAccounts;
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.reentrancyGuard),
      getAccountMeta(accounts2.authority)
    ],
    data: getResetReentrancyGuardInstructionDataEncoder().encode({}),
    programAddress
  });
}
function parseResetReentrancyGuardInstruction(instruction) {
  if (instruction.accounts.length < 2) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      reentrancyGuard: getNextAccount(),
      authority: getNextAccount()
    },
    data: getResetReentrancyGuardInstructionDataDecoder().decode(instruction.data)
  };
}
function getResolveDidDocumentDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(RESOLVE_DID_DOCUMENT_DISCRIMINATOR);
}
function getResolveDidDocumentInstructionDataEncoder() {
  return transformEncoder(getStructEncoder([["discriminator", fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({
    ...value,
    discriminator: RESOLVE_DID_DOCUMENT_DISCRIMINATOR
  }));
}
function getResolveDidDocumentInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)]
  ]);
}
function getResolveDidDocumentInstructionDataCodec() {
  return combineCodec(getResolveDidDocumentInstructionDataEncoder(), getResolveDidDocumentInstructionDataDecoder());
}
async function getResolveDidDocumentInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    didDocument: { value: input.didDocument ?? null, isWritable: false },
    didController: { value: input.didController ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  if (!accounts2.didDocument.value) {
    accounts2.didDocument.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([
          100,
          105,
          100,
          95,
          100,
          111,
          99,
          117,
          109,
          101,
          110,
          116
        ])),
        getAddressEncoder().encode(expectAddress(accounts2.didController.value))
      ]
    });
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.didDocument),
      getAccountMeta(accounts2.didController)
    ],
    data: getResolveDidDocumentInstructionDataEncoder().encode({}),
    programAddress
  });
}
function getResolveDidDocumentInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    didDocument: { value: input.didDocument ?? null, isWritable: false },
    didController: { value: input.didController ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.didDocument),
      getAccountMeta(accounts2.didController)
    ],
    data: getResolveDidDocumentInstructionDataEncoder().encode({}),
    programAddress
  });
}
function parseResolveDidDocumentInstruction(instruction) {
  if (instruction.accounts.length < 2) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      didDocument: getNextAccount(),
      didController: getNextAccount()
    },
    data: getResolveDidDocumentInstructionDataDecoder().decode(instruction.data)
  };
}
function getRevokeCredentialDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(REVOKE_CREDENTIAL_DISCRIMINATOR);
}
function getRevokeCredentialInstructionDataEncoder() {
  return transformEncoder(getStructEncoder([["discriminator", fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({ ...value, discriminator: REVOKE_CREDENTIAL_DISCRIMINATOR }));
}
function getRevokeCredentialInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)]
  ]);
}
function getRevokeCredentialInstructionDataCodec() {
  return combineCodec(getRevokeCredentialInstructionDataEncoder(), getRevokeCredentialInstructionDataDecoder());
}
function getRevokeCredentialInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    credential: { value: input.credential ?? null, isWritable: true },
    issuer: { value: input.issuer ?? null, isWritable: true }
  };
  const accounts2 = originalAccounts;
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.credential),
      getAccountMeta(accounts2.issuer)
    ],
    data: getRevokeCredentialInstructionDataEncoder().encode({}),
    programAddress
  });
}
function parseRevokeCredentialInstruction(instruction) {
  if (instruction.accounts.length < 2) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: { credential: getNextAccount(), issuer: getNextAccount() },
    data: getRevokeCredentialInstructionDataDecoder().decode(instruction.data)
  };
}
function getSlashStakeDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(SLASH_STAKE_DISCRIMINATOR);
}
function getSlashStakeInstructionDataEncoder() {
  return transformEncoder(getStructEncoder([
    ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
    ["owner", getAddressEncoder()],
    ["reason", getSlashReasonEncoder()],
    ["customAmount", getOptionEncoder(getU64Encoder())]
  ]), (value) => ({ ...value, discriminator: SLASH_STAKE_DISCRIMINATOR }));
}
function getSlashStakeInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    ["owner", getAddressDecoder()],
    ["reason", getSlashReasonDecoder()],
    ["customAmount", getOptionDecoder(getU64Decoder())]
  ]);
}
function getSlashStakeInstructionDataCodec() {
  return combineCodec(getSlashStakeInstructionDataEncoder(), getSlashStakeInstructionDataDecoder());
}
async function getSlashStakeInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    stakingAccount: { value: input.stakingAccount ?? null, isWritable: true },
    stakingConfig: { value: input.stakingConfig ?? null, isWritable: false },
    stakingVault: { value: input.stakingVault ?? null, isWritable: true },
    treasury: { value: input.treasury ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: false },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.stakingAccount.value) {
    accounts2.stakingAccount.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([115, 116, 97, 107, 105, 110, 103])),
        getAddressEncoder().encode(expectSome(args.owner))
      ]
    });
  }
  if (!accounts2.stakingConfig.value) {
    accounts2.stakingConfig.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([
          115,
          116,
          97,
          107,
          105,
          110,
          103,
          95,
          99,
          111,
          110,
          102,
          105,
          103
        ]))
      ]
    });
  }
  if (!accounts2.stakingVault.value) {
    accounts2.stakingVault.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([
          115,
          116,
          97,
          107,
          105,
          110,
          103,
          95,
          118,
          97,
          117,
          108,
          116
        ])),
        getAddressEncoder().encode(expectAddress(accounts2.stakingConfig.value))
      ]
    });
  }
  if (!accounts2.tokenProgram.value) {
    accounts2.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.stakingAccount),
      getAccountMeta(accounts2.stakingConfig),
      getAccountMeta(accounts2.stakingVault),
      getAccountMeta(accounts2.treasury),
      getAccountMeta(accounts2.authority),
      getAccountMeta(accounts2.tokenProgram)
    ],
    data: getSlashStakeInstructionDataEncoder().encode(args),
    programAddress
  });
}
function getSlashStakeInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    stakingAccount: { value: input.stakingAccount ?? null, isWritable: true },
    stakingConfig: { value: input.stakingConfig ?? null, isWritable: false },
    stakingVault: { value: input.stakingVault ?? null, isWritable: true },
    treasury: { value: input.treasury ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: false },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.tokenProgram.value) {
    accounts2.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.stakingAccount),
      getAccountMeta(accounts2.stakingConfig),
      getAccountMeta(accounts2.stakingVault),
      getAccountMeta(accounts2.treasury),
      getAccountMeta(accounts2.authority),
      getAccountMeta(accounts2.tokenProgram)
    ],
    data: getSlashStakeInstructionDataEncoder().encode(args),
    programAddress
  });
}
function parseSlashStakeInstruction(instruction) {
  if (instruction.accounts.length < 6) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      stakingAccount: getNextAccount(),
      stakingConfig: getNextAccount(),
      stakingVault: getNextAccount(),
      treasury: getNextAccount(),
      authority: getNextAccount(),
      tokenProgram: getNextAccount()
    },
    data: getSlashStakeInstructionDataDecoder().decode(instruction.data)
  };
}
function getStakeGhostDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(STAKE_GHOST_DISCRIMINATOR);
}
function getStakeGhostInstructionDataEncoder() {
  return transformEncoder(getStructEncoder([
    ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
    ["amount", getU64Encoder()],
    ["lockDuration", getI64Encoder()]
  ]), (value) => ({ ...value, discriminator: STAKE_GHOST_DISCRIMINATOR }));
}
function getStakeGhostInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    ["amount", getU64Decoder()],
    ["lockDuration", getI64Decoder()]
  ]);
}
function getStakeGhostInstructionDataCodec() {
  return combineCodec(getStakeGhostInstructionDataEncoder(), getStakeGhostInstructionDataDecoder());
}
async function getStakeGhostInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    stakingAccount: { value: input.stakingAccount ?? null, isWritable: true },
    ownerTokenAccount: {
      value: input.ownerTokenAccount ?? null,
      isWritable: true
    },
    stakingVault: { value: input.stakingVault ?? null, isWritable: true },
    stakingConfig: { value: input.stakingConfig ?? null, isWritable: false },
    ghostMint: { value: input.ghostMint ?? null, isWritable: false },
    owner: { value: input.owner ?? null, isWritable: true },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    rent: { value: input.rent ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.stakingAccount.value) {
    accounts2.stakingAccount.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([115, 116, 97, 107, 105, 110, 103])),
        getAddressEncoder().encode(expectAddress(accounts2.owner.value))
      ]
    });
  }
  if (!accounts2.stakingVault.value) {
    accounts2.stakingVault.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([
          115,
          116,
          97,
          107,
          105,
          110,
          103,
          95,
          118,
          97,
          117,
          108,
          116
        ])),
        getAddressEncoder().encode(expectAddress(accounts2.stakingConfig.value))
      ]
    });
  }
  if (!accounts2.tokenProgram.value) {
    accounts2.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  if (!accounts2.rent.value) {
    accounts2.rent.value = "SysvarRent111111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.stakingAccount),
      getAccountMeta(accounts2.ownerTokenAccount),
      getAccountMeta(accounts2.stakingVault),
      getAccountMeta(accounts2.stakingConfig),
      getAccountMeta(accounts2.ghostMint),
      getAccountMeta(accounts2.owner),
      getAccountMeta(accounts2.tokenProgram),
      getAccountMeta(accounts2.systemProgram),
      getAccountMeta(accounts2.rent)
    ],
    data: getStakeGhostInstructionDataEncoder().encode(args),
    programAddress
  });
}
function getStakeGhostInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    stakingAccount: { value: input.stakingAccount ?? null, isWritable: true },
    ownerTokenAccount: {
      value: input.ownerTokenAccount ?? null,
      isWritable: true
    },
    stakingVault: { value: input.stakingVault ?? null, isWritable: true },
    stakingConfig: { value: input.stakingConfig ?? null, isWritable: false },
    ghostMint: { value: input.ghostMint ?? null, isWritable: false },
    owner: { value: input.owner ?? null, isWritable: true },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    rent: { value: input.rent ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.tokenProgram.value) {
    accounts2.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  if (!accounts2.rent.value) {
    accounts2.rent.value = "SysvarRent111111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.stakingAccount),
      getAccountMeta(accounts2.ownerTokenAccount),
      getAccountMeta(accounts2.stakingVault),
      getAccountMeta(accounts2.stakingConfig),
      getAccountMeta(accounts2.ghostMint),
      getAccountMeta(accounts2.owner),
      getAccountMeta(accounts2.tokenProgram),
      getAccountMeta(accounts2.systemProgram),
      getAccountMeta(accounts2.rent)
    ],
    data: getStakeGhostInstructionDataEncoder().encode(args),
    programAddress
  });
}
function parseStakeGhostInstruction(instruction) {
  if (instruction.accounts.length < 9) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      stakingAccount: getNextAccount(),
      ownerTokenAccount: getNextAccount(),
      stakingVault: getNextAccount(),
      stakingConfig: getNextAccount(),
      ghostMint: getNextAccount(),
      owner: getNextAccount(),
      tokenProgram: getNextAccount(),
      systemProgram: getNextAccount(),
      rent: getNextAccount()
    },
    data: getStakeGhostInstructionDataDecoder().decode(instruction.data)
  };
}
function getSubmitDeliveryDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(SUBMIT_DELIVERY_DISCRIMINATOR);
}
function getSubmitDeliveryInstructionDataEncoder() {
  return transformEncoder(getStructEncoder([
    ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
    [
      "deliveryProof",
      addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())
    ]
  ]), (value) => ({ ...value, discriminator: SUBMIT_DELIVERY_DISCRIMINATOR }));
}
function getSubmitDeliveryInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    ["deliveryProof", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())]
  ]);
}
function getSubmitDeliveryInstructionDataCodec() {
  return combineCodec(getSubmitDeliveryInstructionDataEncoder(), getSubmitDeliveryInstructionDataDecoder());
}
function getSubmitDeliveryInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    escrow: { value: input.escrow ?? null, isWritable: true },
    agent: { value: input.agent ?? null, isWritable: false },
    agentOwner: { value: input.agentOwner ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.escrow),
      getAccountMeta(accounts2.agent),
      getAccountMeta(accounts2.agentOwner)
    ],
    data: getSubmitDeliveryInstructionDataEncoder().encode(args),
    programAddress
  });
}
function parseSubmitDeliveryInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      escrow: getNextAccount(),
      agent: getNextAccount(),
      agentOwner: getNextAccount()
    },
    data: getSubmitDeliveryInstructionDataDecoder().decode(instruction.data)
  };
}
function getSubmitServiceRatingDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(SUBMIT_SERVICE_RATING_DISCRIMINATOR);
}
function getSubmitServiceRatingInstructionDataEncoder() {
  return transformEncoder(getStructEncoder([
    ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
    ["rating", getU8Encoder()],
    [
      "paymentSignature",
      addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())
    ]
  ]), (value) => ({
    ...value,
    discriminator: SUBMIT_SERVICE_RATING_DISCRIMINATOR
  }));
}
function getSubmitServiceRatingInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    ["rating", getU8Decoder()],
    [
      "paymentSignature",
      addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())
    ]
  ]);
}
function getSubmitServiceRatingInstructionDataCodec() {
  return combineCodec(getSubmitServiceRatingInstructionDataEncoder(), getSubmitServiceRatingInstructionDataDecoder());
}
async function getSubmitServiceRatingInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    reputationMetrics: {
      value: input.reputationMetrics ?? null,
      isWritable: true
    },
    agent: { value: input.agent ?? null, isWritable: true },
    client: { value: input.client ?? null, isWritable: false },
    clock: { value: input.clock ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.reputationMetrics.value) {
    accounts2.reputationMetrics.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([
          114,
          101,
          112,
          117,
          116,
          97,
          116,
          105,
          111,
          110,
          95,
          109,
          101,
          116,
          114,
          105,
          99,
          115
        ])),
        getAddressEncoder().encode(expectAddress(accounts2.agent.value))
      ]
    });
  }
  if (!accounts2.clock.value) {
    accounts2.clock.value = "SysvarC1ock11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.reputationMetrics),
      getAccountMeta(accounts2.agent),
      getAccountMeta(accounts2.client),
      getAccountMeta(accounts2.clock)
    ],
    data: getSubmitServiceRatingInstructionDataEncoder().encode(args),
    programAddress
  });
}
function getSubmitServiceRatingInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    reputationMetrics: {
      value: input.reputationMetrics ?? null,
      isWritable: true
    },
    agent: { value: input.agent ?? null, isWritable: true },
    client: { value: input.client ?? null, isWritable: false },
    clock: { value: input.clock ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.clock.value) {
    accounts2.clock.value = "SysvarC1ock11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.reputationMetrics),
      getAccountMeta(accounts2.agent),
      getAccountMeta(accounts2.client),
      getAccountMeta(accounts2.clock)
    ],
    data: getSubmitServiceRatingInstructionDataEncoder().encode(args),
    programAddress
  });
}
function parseSubmitServiceRatingInstruction(instruction) {
  if (instruction.accounts.length < 4) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      reputationMetrics: getNextAccount(),
      agent: getNextAccount(),
      client: getNextAccount(),
      clock: getNextAccount()
    },
    data: getSubmitServiceRatingInstructionDataDecoder().decode(instruction.data)
  };
}
function getUnstakeGhostDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(UNSTAKE_GHOST_DISCRIMINATOR);
}
function getUnstakeGhostInstructionDataEncoder() {
  return transformEncoder(getStructEncoder([["discriminator", fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({ ...value, discriminator: UNSTAKE_GHOST_DISCRIMINATOR }));
}
function getUnstakeGhostInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)]
  ]);
}
function getUnstakeGhostInstructionDataCodec() {
  return combineCodec(getUnstakeGhostInstructionDataEncoder(), getUnstakeGhostInstructionDataDecoder());
}
async function getUnstakeGhostInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    stakingAccount: { value: input.stakingAccount ?? null, isWritable: true },
    stakingConfig: { value: input.stakingConfig ?? null, isWritable: false },
    stakingVault: { value: input.stakingVault ?? null, isWritable: true },
    ownerTokenAccount: {
      value: input.ownerTokenAccount ?? null,
      isWritable: true
    },
    owner: { value: input.owner ?? null, isWritable: true },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  if (!accounts2.stakingAccount.value) {
    accounts2.stakingAccount.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([115, 116, 97, 107, 105, 110, 103])),
        getAddressEncoder().encode(expectAddress(accounts2.owner.value))
      ]
    });
  }
  if (!accounts2.stakingConfig.value) {
    accounts2.stakingConfig.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([
          115,
          116,
          97,
          107,
          105,
          110,
          103,
          95,
          99,
          111,
          110,
          102,
          105,
          103
        ]))
      ]
    });
  }
  if (!accounts2.stakingVault.value) {
    accounts2.stakingVault.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([
          115,
          116,
          97,
          107,
          105,
          110,
          103,
          95,
          118,
          97,
          117,
          108,
          116
        ])),
        getAddressEncoder().encode(expectAddress(accounts2.stakingConfig.value))
      ]
    });
  }
  if (!accounts2.tokenProgram.value) {
    accounts2.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.stakingAccount),
      getAccountMeta(accounts2.stakingConfig),
      getAccountMeta(accounts2.stakingVault),
      getAccountMeta(accounts2.ownerTokenAccount),
      getAccountMeta(accounts2.owner),
      getAccountMeta(accounts2.tokenProgram)
    ],
    data: getUnstakeGhostInstructionDataEncoder().encode({}),
    programAddress
  });
}
function getUnstakeGhostInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    stakingAccount: { value: input.stakingAccount ?? null, isWritable: true },
    stakingConfig: { value: input.stakingConfig ?? null, isWritable: false },
    stakingVault: { value: input.stakingVault ?? null, isWritable: true },
    ownerTokenAccount: {
      value: input.ownerTokenAccount ?? null,
      isWritable: true
    },
    owner: { value: input.owner ?? null, isWritable: true },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  if (!accounts2.tokenProgram.value) {
    accounts2.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.stakingAccount),
      getAccountMeta(accounts2.stakingConfig),
      getAccountMeta(accounts2.stakingVault),
      getAccountMeta(accounts2.ownerTokenAccount),
      getAccountMeta(accounts2.owner),
      getAccountMeta(accounts2.tokenProgram)
    ],
    data: getUnstakeGhostInstructionDataEncoder().encode({}),
    programAddress
  });
}
function parseUnstakeGhostInstruction(instruction) {
  if (instruction.accounts.length < 6) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      stakingAccount: getNextAccount(),
      stakingConfig: getNextAccount(),
      stakingVault: getNextAccount(),
      ownerTokenAccount: getNextAccount(),
      owner: getNextAccount(),
      tokenProgram: getNextAccount()
    },
    data: getUnstakeGhostInstructionDataDecoder().decode(instruction.data)
  };
}
function getUpdateAgentDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(UPDATE_AGENT_DISCRIMINATOR);
}
function getUpdateAgentInstructionDataEncoder() {
  return transformEncoder(getStructEncoder([
    ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
    ["agentType", getU8Encoder()],
    [
      "name",
      getOptionEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    [
      "description",
      getOptionEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    ["metadataUri", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["agentId", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["pricingModel", getOptionEncoder(getPricingModelEncoder())]
  ]), (value) => ({ ...value, discriminator: UPDATE_AGENT_DISCRIMINATOR }));
}
function getUpdateAgentInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    ["agentType", getU8Decoder()],
    [
      "name",
      getOptionDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    [
      "description",
      getOptionDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    ["metadataUri", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["agentId", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["pricingModel", getOptionDecoder(getPricingModelDecoder())]
  ]);
}
function getUpdateAgentInstructionDataCodec() {
  return combineCodec(getUpdateAgentInstructionDataEncoder(), getUpdateAgentInstructionDataDecoder());
}
async function getUpdateAgentInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    agentAccount: { value: input.agentAccount ?? null, isWritable: true },
    signer: { value: input.signer ?? null, isWritable: true },
    clock: { value: input.clock ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.agentAccount.value) {
    accounts2.agentAccount.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([97, 103, 101, 110, 116])),
        getAddressEncoder().encode(expectAddress(accounts2.signer.value)),
        getUtf8Encoder().encode(expectSome(args.agentId))
      ]
    });
  }
  if (!accounts2.clock.value) {
    accounts2.clock.value = "SysvarC1ock11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.agentAccount),
      getAccountMeta(accounts2.signer),
      getAccountMeta(accounts2.clock)
    ],
    data: getUpdateAgentInstructionDataEncoder().encode(args),
    programAddress
  });
}
function getUpdateAgentInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    agentAccount: { value: input.agentAccount ?? null, isWritable: true },
    signer: { value: input.signer ?? null, isWritable: true },
    clock: { value: input.clock ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.clock.value) {
    accounts2.clock.value = "SysvarC1ock11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.agentAccount),
      getAccountMeta(accounts2.signer),
      getAccountMeta(accounts2.clock)
    ],
    data: getUpdateAgentInstructionDataEncoder().encode(args),
    programAddress
  });
}
function parseUpdateAgentInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      agentAccount: getNextAccount(),
      signer: getNextAccount(),
      clock: getNextAccount()
    },
    data: getUpdateAgentInstructionDataDecoder().decode(instruction.data)
  };
}
function getUpdateAgentReputationDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(UPDATE_AGENT_REPUTATION_DISCRIMINATOR);
}
function getUpdateAgentReputationInstructionDataEncoder() {
  return transformEncoder(getStructEncoder([
    ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
    ["agentId", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["reputationScore", getU64Encoder()]
  ]), (value) => ({
    ...value,
    discriminator: UPDATE_AGENT_REPUTATION_DISCRIMINATOR
  }));
}
function getUpdateAgentReputationInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    ["agentId", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["reputationScore", getU64Decoder()]
  ]);
}
function getUpdateAgentReputationInstructionDataCodec() {
  return combineCodec(getUpdateAgentReputationInstructionDataEncoder(), getUpdateAgentReputationInstructionDataDecoder());
}
async function getUpdateAgentReputationInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    agentAccount: { value: input.agentAccount ?? null, isWritable: true },
    signer: { value: input.signer ?? null, isWritable: true },
    clock: { value: input.clock ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.agentAccount.value) {
    accounts2.agentAccount.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([97, 103, 101, 110, 116])),
        getAddressEncoder().encode(expectAddress(accounts2.signer.value)),
        getUtf8Encoder().encode(expectSome(args.agentId))
      ]
    });
  }
  if (!accounts2.clock.value) {
    accounts2.clock.value = "SysvarC1ock11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.agentAccount),
      getAccountMeta(accounts2.signer),
      getAccountMeta(accounts2.clock)
    ],
    data: getUpdateAgentReputationInstructionDataEncoder().encode(args),
    programAddress
  });
}
function getUpdateAgentReputationInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    agentAccount: { value: input.agentAccount ?? null, isWritable: true },
    signer: { value: input.signer ?? null, isWritable: true },
    clock: { value: input.clock ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.clock.value) {
    accounts2.clock.value = "SysvarC1ock11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.agentAccount),
      getAccountMeta(accounts2.signer),
      getAccountMeta(accounts2.clock)
    ],
    data: getUpdateAgentReputationInstructionDataEncoder().encode(args),
    programAddress
  });
}
function parseUpdateAgentReputationInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      agentAccount: getNextAccount(),
      signer: getNextAccount(),
      clock: getNextAccount()
    },
    data: getUpdateAgentReputationInstructionDataDecoder().decode(instruction.data)
  };
}
function getUpdateAgentServiceDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(UPDATE_AGENT_SERVICE_DISCRIMINATOR);
}
function getUpdateAgentServiceInstructionDataEncoder() {
  return transformEncoder(getStructEncoder([
    ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
    ["agentPubkey", getAddressEncoder()],
    [
      "serviceEndpoint",
      addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())
    ],
    ["isActive", getBooleanEncoder()],
    ["lastUpdated", getI64Encoder()],
    [
      "metadataUri",
      getOptionEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    [
      "capabilities",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ]
  ]), (value) => ({
    ...value,
    discriminator: UPDATE_AGENT_SERVICE_DISCRIMINATOR
  }));
}
function getUpdateAgentServiceInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    ["agentPubkey", getAddressDecoder()],
    [
      "serviceEndpoint",
      addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())
    ],
    ["isActive", getBooleanDecoder()],
    ["lastUpdated", getI64Decoder()],
    [
      "metadataUri",
      getOptionDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    [
      "capabilities",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ]
  ]);
}
function getUpdateAgentServiceInstructionDataCodec() {
  return combineCodec(getUpdateAgentServiceInstructionDataEncoder(), getUpdateAgentServiceInstructionDataDecoder());
}
async function getUpdateAgentServiceInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    agent: { value: input.agent ?? null, isWritable: true },
    owner: { value: input.owner ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.agent.value) {
    accounts2.agent.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([97, 103, 101, 110, 116])),
        getAddressEncoder().encode(expectAddress(accounts2.owner.value))
      ]
    });
  }
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.agent),
      getAccountMeta(accounts2.owner),
      getAccountMeta(accounts2.systemProgram)
    ],
    data: getUpdateAgentServiceInstructionDataEncoder().encode(args),
    programAddress
  });
}
function getUpdateAgentServiceInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    agent: { value: input.agent ?? null, isWritable: true },
    owner: { value: input.owner ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.agent),
      getAccountMeta(accounts2.owner),
      getAccountMeta(accounts2.systemProgram)
    ],
    data: getUpdateAgentServiceInstructionDataEncoder().encode(args),
    programAddress
  });
}
function parseUpdateAgentServiceInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      agent: getNextAccount(),
      owner: getNextAccount(),
      systemProgram: getNextAccount()
    },
    data: getUpdateAgentServiceInstructionDataDecoder().decode(instruction.data)
  };
}
function getUpdateCrosschainStatusDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(UPDATE_CROSSCHAIN_STATUS_DISCRIMINATOR);
}
function getUpdateCrosschainStatusInstructionDataEncoder() {
  return transformEncoder(getStructEncoder([
    ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
    [
      "crossmintCredentialId",
      addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())
    ],
    ["status", getCrossChainStatusEncoder()]
  ]), (value) => ({
    ...value,
    discriminator: UPDATE_CROSSCHAIN_STATUS_DISCRIMINATOR
  }));
}
function getUpdateCrosschainStatusInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    [
      "crossmintCredentialId",
      addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())
    ],
    ["status", getCrossChainStatusDecoder()]
  ]);
}
function getUpdateCrosschainStatusInstructionDataCodec() {
  return combineCodec(getUpdateCrosschainStatusInstructionDataEncoder(), getUpdateCrosschainStatusInstructionDataDecoder());
}
function getUpdateCrosschainStatusInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    credential: { value: input.credential ?? null, isWritable: true },
    issuer: { value: input.issuer ?? null, isWritable: true }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.credential),
      getAccountMeta(accounts2.issuer)
    ],
    data: getUpdateCrosschainStatusInstructionDataEncoder().encode(args),
    programAddress
  });
}
function parseUpdateCrosschainStatusInstruction(instruction) {
  if (instruction.accounts.length < 2) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: { credential: getNextAccount(), issuer: getNextAccount() },
    data: getUpdateCrosschainStatusInstructionDataDecoder().decode(instruction.data)
  };
}
function getUpdateDidDocumentDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(UPDATE_DID_DOCUMENT_DISCRIMINATOR);
}
function getUpdateDidDocumentInstructionDataEncoder() {
  return transformEncoder(getStructEncoder([
    ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
    [
      "addVerificationMethod",
      getOptionEncoder(getVerificationMethodEncoder())
    ],
    [
      "removeVerificationMethodId",
      getOptionEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    ["addServiceEndpoint", getOptionEncoder(getServiceEndpointEncoder())],
    [
      "removeServiceEndpointId",
      getOptionEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ]
  ]), (value) => ({ ...value, discriminator: UPDATE_DID_DOCUMENT_DISCRIMINATOR }));
}
function getUpdateDidDocumentInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    ["addVerificationMethod", getOptionDecoder(getVerificationMethodDecoder())],
    [
      "removeVerificationMethodId",
      getOptionDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    ["addServiceEndpoint", getOptionDecoder(getServiceEndpointDecoder())],
    [
      "removeServiceEndpointId",
      getOptionDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ]
  ]);
}
function getUpdateDidDocumentInstructionDataCodec() {
  return combineCodec(getUpdateDidDocumentInstructionDataEncoder(), getUpdateDidDocumentInstructionDataDecoder());
}
async function getUpdateDidDocumentInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    didDocument: { value: input.didDocument ?? null, isWritable: true },
    controller: { value: input.controller ?? null, isWritable: true },
    clock: { value: input.clock ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.didDocument.value) {
    accounts2.didDocument.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([
          100,
          105,
          100,
          95,
          100,
          111,
          99,
          117,
          109,
          101,
          110,
          116
        ])),
        getAddressEncoder().encode(expectAddress(accounts2.controller.value))
      ]
    });
  }
  if (!accounts2.clock.value) {
    accounts2.clock.value = "SysvarC1ock11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.didDocument),
      getAccountMeta(accounts2.controller),
      getAccountMeta(accounts2.clock)
    ],
    data: getUpdateDidDocumentInstructionDataEncoder().encode(args),
    programAddress
  });
}
function getUpdateDidDocumentInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    didDocument: { value: input.didDocument ?? null, isWritable: true },
    controller: { value: input.controller ?? null, isWritable: true },
    clock: { value: input.clock ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.clock.value) {
    accounts2.clock.value = "SysvarC1ock11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.didDocument),
      getAccountMeta(accounts2.controller),
      getAccountMeta(accounts2.clock)
    ],
    data: getUpdateDidDocumentInstructionDataEncoder().encode(args),
    programAddress
  });
}
function parseUpdateDidDocumentInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      didDocument: getNextAccount(),
      controller: getNextAccount(),
      clock: getNextAccount()
    },
    data: getUpdateDidDocumentInstructionDataDecoder().decode(instruction.data)
  };
}
function getUpdateProtocolConfigDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(UPDATE_PROTOCOL_CONFIG_DISCRIMINATOR);
}
function getUpdateProtocolConfigInstructionDataEncoder() {
  return transformEncoder(getStructEncoder([
    ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
    ["escrowFeeBps", getOptionEncoder(getU16Encoder())],
    ["agentRegistrationFee", getOptionEncoder(getU64Encoder())],
    ["listingFee", getOptionEncoder(getU64Encoder())],
    ["disputeFeeBps", getOptionEncoder(getU16Encoder())],
    ["feesEnabled", getOptionEncoder(getBooleanEncoder())],
    ["treasury", getOptionEncoder(getAddressEncoder())],
    ["buybackPool", getOptionEncoder(getAddressEncoder())],
    ["moderatorPool", getOptionEncoder(getAddressEncoder())]
  ]), (value) => ({
    ...value,
    discriminator: UPDATE_PROTOCOL_CONFIG_DISCRIMINATOR
  }));
}
function getUpdateProtocolConfigInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    ["escrowFeeBps", getOptionDecoder(getU16Decoder())],
    ["agentRegistrationFee", getOptionDecoder(getU64Decoder())],
    ["listingFee", getOptionDecoder(getU64Decoder())],
    ["disputeFeeBps", getOptionDecoder(getU16Decoder())],
    ["feesEnabled", getOptionDecoder(getBooleanDecoder())],
    ["treasury", getOptionDecoder(getAddressDecoder())],
    ["buybackPool", getOptionDecoder(getAddressDecoder())],
    ["moderatorPool", getOptionDecoder(getAddressDecoder())]
  ]);
}
function getUpdateProtocolConfigInstructionDataCodec() {
  return combineCodec(getUpdateProtocolConfigInstructionDataEncoder(), getUpdateProtocolConfigInstructionDataDecoder());
}
async function getUpdateProtocolConfigInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    config: { value: input.config ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.config.value) {
    accounts2.config.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([
          112,
          114,
          111,
          116,
          111,
          99,
          111,
          108,
          95,
          99,
          111,
          110,
          102,
          105,
          103
        ]))
      ]
    });
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.config),
      getAccountMeta(accounts2.authority)
    ],
    data: getUpdateProtocolConfigInstructionDataEncoder().encode(args),
    programAddress
  });
}
function getUpdateProtocolConfigInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    config: { value: input.config ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.config),
      getAccountMeta(accounts2.authority)
    ],
    data: getUpdateProtocolConfigInstructionDataEncoder().encode(args),
    programAddress
  });
}
function parseUpdateProtocolConfigInstruction(instruction) {
  if (instruction.accounts.length < 2) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: { config: getNextAccount(), authority: getNextAccount() },
    data: getUpdateProtocolConfigInstructionDataDecoder().decode(instruction.data)
  };
}
function getUpdateReputationTagsDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(UPDATE_REPUTATION_TAGS_DISCRIMINATOR);
}
function getUpdateReputationTagsInstructionDataEncoder() {
  return transformEncoder(getStructEncoder([
    ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
    [
      "skillTags",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    [
      "behaviorTags",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    [
      "complianceTags",
      getArrayEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    ["tagScores", getArrayEncoder(getTagScoreEncoder())]
  ]), (value) => ({
    ...value,
    discriminator: UPDATE_REPUTATION_TAGS_DISCRIMINATOR
  }));
}
function getUpdateReputationTagsInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    [
      "skillTags",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    [
      "behaviorTags",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    [
      "complianceTags",
      getArrayDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    ["tagScores", getArrayDecoder(getTagScoreDecoder())]
  ]);
}
function getUpdateReputationTagsInstructionDataCodec() {
  return combineCodec(getUpdateReputationTagsInstructionDataEncoder(), getUpdateReputationTagsInstructionDataDecoder());
}
async function getUpdateReputationTagsInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    reputationMetrics: {
      value: input.reputationMetrics ?? null,
      isWritable: true
    },
    agent: { value: input.agent ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: false },
    clock: { value: input.clock ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.reputationMetrics.value) {
    accounts2.reputationMetrics.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([
          114,
          101,
          112,
          117,
          116,
          97,
          116,
          105,
          111,
          110,
          95,
          109,
          101,
          116,
          114,
          105,
          99,
          115
        ])),
        getAddressEncoder().encode(expectAddress(accounts2.agent.value))
      ]
    });
  }
  if (!accounts2.clock.value) {
    accounts2.clock.value = "SysvarC1ock11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.reputationMetrics),
      getAccountMeta(accounts2.agent),
      getAccountMeta(accounts2.authority),
      getAccountMeta(accounts2.clock)
    ],
    data: getUpdateReputationTagsInstructionDataEncoder().encode(args),
    programAddress
  });
}
function getUpdateReputationTagsInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    reputationMetrics: {
      value: input.reputationMetrics ?? null,
      isWritable: true
    },
    agent: { value: input.agent ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: false },
    clock: { value: input.clock ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.clock.value) {
    accounts2.clock.value = "SysvarC1ock11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.reputationMetrics),
      getAccountMeta(accounts2.agent),
      getAccountMeta(accounts2.authority),
      getAccountMeta(accounts2.clock)
    ],
    data: getUpdateReputationTagsInstructionDataEncoder().encode(args),
    programAddress
  });
}
function parseUpdateReputationTagsInstruction(instruction) {
  if (instruction.accounts.length < 4) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      reputationMetrics: getNextAccount(),
      agent: getNextAccount(),
      authority: getNextAccount(),
      clock: getNextAccount()
    },
    data: getUpdateReputationTagsInstructionDataDecoder().decode(instruction.data)
  };
}
function getUpdateSourceReputationDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(UPDATE_SOURCE_REPUTATION_DISCRIMINATOR);
}
function getUpdateSourceReputationInstructionDataEncoder() {
  return transformEncoder(getStructEncoder([
    ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
    ["sourceName", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ["score", getU16Encoder()],
    ["weight", getU16Encoder()],
    ["dataPoints", getU32Encoder()],
    ["reliability", getU16Encoder()]
  ]), (value) => ({
    ...value,
    discriminator: UPDATE_SOURCE_REPUTATION_DISCRIMINATOR
  }));
}
function getUpdateSourceReputationInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    ["sourceName", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    ["score", getU16Decoder()],
    ["weight", getU16Decoder()],
    ["dataPoints", getU32Decoder()],
    ["reliability", getU16Decoder()]
  ]);
}
function getUpdateSourceReputationInstructionDataCodec() {
  return combineCodec(getUpdateSourceReputationInstructionDataEncoder(), getUpdateSourceReputationInstructionDataDecoder());
}
async function getUpdateSourceReputationInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    reputationMetrics: {
      value: input.reputationMetrics ?? null,
      isWritable: true
    },
    agent: { value: input.agent ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: false },
    clock: { value: input.clock ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.reputationMetrics.value) {
    accounts2.reputationMetrics.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([
          114,
          101,
          112,
          117,
          116,
          97,
          116,
          105,
          111,
          110,
          95,
          109,
          101,
          116,
          114,
          105,
          99,
          115
        ])),
        getAddressEncoder().encode(expectAddress(accounts2.agent.value))
      ]
    });
  }
  if (!accounts2.clock.value) {
    accounts2.clock.value = "SysvarC1ock11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.reputationMetrics),
      getAccountMeta(accounts2.agent),
      getAccountMeta(accounts2.authority),
      getAccountMeta(accounts2.clock)
    ],
    data: getUpdateSourceReputationInstructionDataEncoder().encode(args),
    programAddress
  });
}
function getUpdateSourceReputationInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    reputationMetrics: {
      value: input.reputationMetrics ?? null,
      isWritable: true
    },
    agent: { value: input.agent ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: false },
    clock: { value: input.clock ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.clock.value) {
    accounts2.clock.value = "SysvarC1ock11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.reputationMetrics),
      getAccountMeta(accounts2.agent),
      getAccountMeta(accounts2.authority),
      getAccountMeta(accounts2.clock)
    ],
    data: getUpdateSourceReputationInstructionDataEncoder().encode(args),
    programAddress
  });
}
function parseUpdateSourceReputationInstruction(instruction) {
  if (instruction.accounts.length < 4) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      reputationMetrics: getNextAccount(),
      agent: getNextAccount(),
      authority: getNextAccount(),
      clock: getNextAccount()
    },
    data: getUpdateSourceReputationInstructionDataDecoder().decode(instruction.data)
  };
}
function getVerifyAgentDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(VERIFY_AGENT_DISCRIMINATOR);
}
function getVerifyAgentInstructionDataEncoder() {
  return transformEncoder(getStructEncoder([
    ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
    ["agentPubkey", getAddressEncoder()],
    [
      "serviceEndpoint",
      addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())
    ],
    ["supportedCapabilities", getArrayEncoder(getU64Encoder())],
    ["verifiedAt", getI64Encoder()]
  ]), (value) => ({ ...value, discriminator: VERIFY_AGENT_DISCRIMINATOR }));
}
function getVerifyAgentInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    ["agentPubkey", getAddressDecoder()],
    [
      "serviceEndpoint",
      addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())
    ],
    ["supportedCapabilities", getArrayDecoder(getU64Decoder())],
    ["verifiedAt", getI64Decoder()]
  ]);
}
function getVerifyAgentInstructionDataCodec() {
  return combineCodec(getVerifyAgentInstructionDataEncoder(), getVerifyAgentInstructionDataDecoder());
}
async function getVerifyAgentInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    agentVerification: {
      value: input.agentVerification ?? null,
      isWritable: true
    },
    agent: { value: input.agent ?? null, isWritable: false },
    verifier: { value: input.verifier ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    clock: { value: input.clock ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.agentVerification.value) {
    accounts2.agentVerification.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([
          97,
          103,
          101,
          110,
          116,
          95,
          118,
          101,
          114,
          105,
          102,
          105,
          99,
          97,
          116,
          105,
          111,
          110
        ])),
        getAddressEncoder().encode(expectAddress(accounts2.agent.value)),
        getAddressEncoder().encode(expectAddress(accounts2.verifier.value))
      ]
    });
  }
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  if (!accounts2.clock.value) {
    accounts2.clock.value = "SysvarC1ock11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.agentVerification),
      getAccountMeta(accounts2.agent),
      getAccountMeta(accounts2.verifier),
      getAccountMeta(accounts2.systemProgram),
      getAccountMeta(accounts2.clock)
    ],
    data: getVerifyAgentInstructionDataEncoder().encode(args),
    programAddress
  });
}
function getVerifyAgentInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    agentVerification: {
      value: input.agentVerification ?? null,
      isWritable: true
    },
    agent: { value: input.agent ?? null, isWritable: false },
    verifier: { value: input.verifier ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    clock: { value: input.clock ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  if (!accounts2.clock.value) {
    accounts2.clock.value = "SysvarC1ock11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.agentVerification),
      getAccountMeta(accounts2.agent),
      getAccountMeta(accounts2.verifier),
      getAccountMeta(accounts2.systemProgram),
      getAccountMeta(accounts2.clock)
    ],
    data: getVerifyAgentInstructionDataEncoder().encode(args),
    programAddress
  });
}
function parseVerifyAgentInstruction(instruction) {
  if (instruction.accounts.length < 5) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      agentVerification: getNextAccount(),
      agent: getNextAccount(),
      verifier: getNextAccount(),
      systemProgram: getNextAccount(),
      clock: getNextAccount()
    },
    data: getVerifyAgentInstructionDataDecoder().decode(instruction.data)
  };
}
function getVerifyAuthorizationDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(VERIFY_AUTHORIZATION_DISCRIMINATOR);
}
function getVerifyAuthorizationInstructionDataEncoder() {
  return transformEncoder(getStructEncoder([
    ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
    [
      "nonce",
      getOptionEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ]
  ]), (value) => ({
    ...value,
    discriminator: VERIFY_AUTHORIZATION_DISCRIMINATOR
  }));
}
function getVerifyAuthorizationInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    [
      "nonce",
      getOptionDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ]
  ]);
}
function getVerifyAuthorizationInstructionDataCodec() {
  return combineCodec(getVerifyAuthorizationInstructionDataEncoder(), getVerifyAuthorizationInstructionDataDecoder());
}
function getVerifyAuthorizationInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    agent: { value: input.agent ?? null, isWritable: false },
    authorization: { value: input.authorization ?? null, isWritable: false },
    clock: { value: input.clock ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.clock.value) {
    accounts2.clock.value = "SysvarC1ock11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.agent),
      getAccountMeta(accounts2.authorization),
      getAccountMeta(accounts2.clock)
    ],
    data: getVerifyAuthorizationInstructionDataEncoder().encode(args),
    programAddress
  });
}
function parseVerifyAuthorizationInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      agent: getNextAccount(),
      authorization: getNextAccount(),
      clock: getNextAccount()
    },
    data: getVerifyAuthorizationInstructionDataDecoder().decode(instruction.data)
  };
}
var AGENT_REPUTATION_AUTH_DISCRIMINATOR, AGENT_TREE_CONFIG_DISCRIMINATOR, AGENT_VERIFICATION_DISCRIMINATOR, AUDIT_TRAIL_DISCRIMINATOR, AUTHORIZATION_USAGE_RECORD_DISCRIMINATOR, COMPLIANCE_REPORT_DISCRIMINATOR, CREDENTIAL_DISCRIMINATOR, CREDENTIAL_TEMPLATE_DISCRIMINATOR, CREDENTIAL_TYPE_DISCRIMINATOR, DID_DOCUMENT_DISCRIMINATOR, GHOST_PROTECT_ESCROW_DISCRIMINATOR, GOVERNANCE_PROPOSAL_DISCRIMINATOR, MULTISIG_DISCRIMINATOR, PROTOCOL_CONFIG_DISCRIMINATOR, RBAC_CONFIG_DISCRIMINATOR, REENTRANCY_GUARD_DISCRIMINATOR, REPUTATION_METRICS_DISCRIMINATOR, STAKING_ACCOUNT_DISCRIMINATOR, STAKING_CONFIG_DISCRIMINATOR, USER_REGISTRY_DISCRIMINATOR, GHOSTSPEAK_MARKETPLACE_ERROR__ALREADY_DEACTIVATED = 6000, GHOSTSPEAK_MARKETPLACE_ERROR__TOO_MANY_VERIFICATION_METHODS = 6001, GHOSTSPEAK_MARKETPLACE_ERROR__TOO_MANY_SERVICE_ENDPOINTS = 6002, GHOSTSPEAK_MARKETPLACE_ERROR__DUPLICATE_METHOD_ID = 6003, GHOSTSPEAK_MARKETPLACE_ERROR__DUPLICATE_SERVICE_ID = 6004, GHOSTSPEAK_MARKETPLACE_ERROR__METHOD_NOT_FOUND = 6005, GHOSTSPEAK_MARKETPLACE_ERROR__SERVICE_NOT_FOUND = 6006, GHOSTSPEAK_MARKETPLACE_ERROR__INVALID_DID_FORMAT = 6007, GHOSTSPEAK_MARKETPLACE_ERROR__UNAUTHORIZED_DID_OPERATION = 6008, GHOSTSPEAK_MARKETPLACE_ERROR__DID_DEACTIVATED = 6009, ghostspeakMarketplaceErrorMessages, ACTIVATE_AGENT_DISCRIMINATOR, APPROVE_DELIVERY_DISCRIMINATOR, ARBITRATE_DISPUTE_DISCRIMINATOR, CREATE_CREDENTIAL_TEMPLATE_DISCRIMINATOR, CREATE_CREDENTIAL_TYPE_DISCRIMINATOR, CREATE_DID_DOCUMENT_DISCRIMINATOR, CREATE_ESCROW_DISCRIMINATOR, CREATE_MULTISIG_DISCRIMINATOR, DEACTIVATE_AGENT_DISCRIMINATOR, DEACTIVATE_CREDENTIAL_TEMPLATE_DISCRIMINATOR, DEACTIVATE_CREDENTIAL_TYPE_DISCRIMINATOR, DEACTIVATE_DID_DOCUMENT_DISCRIMINATOR, ENABLE_PROTOCOL_FEES_DISCRIMINATOR, FILE_DISPUTE_DISCRIMINATOR, GENERATE_COMPLIANCE_REPORT_DISCRIMINATOR, INITIALIZE_AUDIT_TRAIL_DISCRIMINATOR, INITIALIZE_GOVERNANCE_PROPOSAL_DISCRIMINATOR, INITIALIZE_PROTOCOL_CONFIG_DISCRIMINATOR, INITIALIZE_RBAC_CONFIG_DISCRIMINATOR, INITIALIZE_REPUTATION_METRICS_DISCRIMINATOR, INITIALIZE_STAKING_CONFIG_DISCRIMINATOR, INIT_REENTRANCY_GUARD_DISCRIMINATOR, ISSUE_CREDENTIAL_DISCRIMINATOR, MANAGE_AGENT_STATUS_DISCRIMINATOR, RECORD_PAYAI_PAYMENT_DISCRIMINATOR, REGISTER_AGENT_DISCRIMINATOR, REGISTER_AGENT_COMPRESSED_DISCRIMINATOR, RESET_REENTRANCY_GUARD_DISCRIMINATOR, RESOLVE_DID_DOCUMENT_DISCRIMINATOR, REVOKE_CREDENTIAL_DISCRIMINATOR, SLASH_STAKE_DISCRIMINATOR, STAKE_GHOST_DISCRIMINATOR, SUBMIT_DELIVERY_DISCRIMINATOR, SUBMIT_SERVICE_RATING_DISCRIMINATOR, UNSTAKE_GHOST_DISCRIMINATOR, UPDATE_AGENT_DISCRIMINATOR, UPDATE_AGENT_REPUTATION_DISCRIMINATOR, UPDATE_AGENT_SERVICE_DISCRIMINATOR, UPDATE_CROSSCHAIN_STATUS_DISCRIMINATOR, UPDATE_DID_DOCUMENT_DISCRIMINATOR, UPDATE_PROTOCOL_CONFIG_DISCRIMINATOR, UPDATE_REPUTATION_TAGS_DISCRIMINATOR, UPDATE_SOURCE_REPUTATION_DISCRIMINATOR, VERIFY_AGENT_DISCRIMINATOR, VERIFY_AUTHORIZATION_DISCRIMINATOR;
var init_chunk_S74EH3KD = __esm(() => {
  init_chunk_IHVDQ4YI();
  init_chunk_AL3HQN73();
  init_index_node35();
  AGENT_REPUTATION_AUTH_DISCRIMINATOR = new Uint8Array([
    30,
    249,
    165,
    44,
    155,
    194,
    188,
    175
  ]);
  AGENT_TREE_CONFIG_DISCRIMINATOR = new Uint8Array([
    145,
    145,
    156,
    0,
    197,
    232,
    130,
    245
  ]);
  AGENT_VERIFICATION_DISCRIMINATOR = new Uint8Array([
    128,
    155,
    95,
    241,
    66,
    207,
    166,
    59
  ]);
  AUDIT_TRAIL_DISCRIMINATOR = new Uint8Array([
    171,
    223,
    253,
    181,
    134,
    88,
    66,
    26
  ]);
  AUTHORIZATION_USAGE_RECORD_DISCRIMINATOR = new Uint8Array([
    109,
    102,
    102,
    17,
    210,
    84,
    85,
    210
  ]);
  COMPLIANCE_REPORT_DISCRIMINATOR = new Uint8Array([
    75,
    146,
    78,
    26,
    130,
    240,
    228,
    35
  ]);
  CREDENTIAL_DISCRIMINATOR = new Uint8Array([
    145,
    44,
    68,
    220,
    67,
    46,
    100,
    135
  ]);
  CREDENTIAL_TEMPLATE_DISCRIMINATOR = new Uint8Array([
    229,
    129,
    99,
    91,
    179,
    207,
    66,
    75
  ]);
  CREDENTIAL_TYPE_DISCRIMINATOR = new Uint8Array([
    132,
    171,
    20,
    181,
    39,
    219,
    217,
    112
  ]);
  DID_DOCUMENT_DISCRIMINATOR = new Uint8Array([
    109,
    220,
    168,
    224,
    33,
    173,
    192,
    166
  ]);
  GHOST_PROTECT_ESCROW_DISCRIMINATOR = new Uint8Array([
    38,
    0,
    98,
    160,
    102,
    4,
    51,
    160
  ]);
  GOVERNANCE_PROPOSAL_DISCRIMINATOR = new Uint8Array([
    53,
    107,
    240,
    190,
    43,
    73,
    65,
    143
  ]);
  MULTISIG_DISCRIMINATOR = new Uint8Array([
    224,
    116,
    121,
    186,
    68,
    161,
    79,
    236
  ]);
  PROTOCOL_CONFIG_DISCRIMINATOR = new Uint8Array([
    207,
    91,
    250,
    28,
    152,
    179,
    215,
    209
  ]);
  RBAC_CONFIG_DISCRIMINATOR = new Uint8Array([
    177,
    94,
    184,
    202,
    221,
    112,
    110,
    38
  ]);
  REENTRANCY_GUARD_DISCRIMINATOR = new Uint8Array([
    207,
    227,
    141,
    11,
    194,
    21,
    193,
    32
  ]);
  REPUTATION_METRICS_DISCRIMINATOR = new Uint8Array([
    8,
    160,
    71,
    30,
    66,
    150,
    108,
    33
  ]);
  STAKING_ACCOUNT_DISCRIMINATOR = new Uint8Array([
    52,
    178,
    251,
    157,
    180,
    186,
    98,
    234
  ]);
  STAKING_CONFIG_DISCRIMINATOR = new Uint8Array([
    45,
    134,
    252,
    82,
    37,
    57,
    84,
    25
  ]);
  USER_REGISTRY_DISCRIMINATOR = new Uint8Array([
    37,
    84,
    98,
    14,
    130,
    63,
    210,
    138
  ]);
  if (true) {
    ghostspeakMarketplaceErrorMessages = {
      [GHOSTSPEAK_MARKETPLACE_ERROR__ALREADY_DEACTIVATED]: `DID document is already deactivated`,
      [GHOSTSPEAK_MARKETPLACE_ERROR__DID_DEACTIVATED]: `DID is deactivated`,
      [GHOSTSPEAK_MARKETPLACE_ERROR__DUPLICATE_METHOD_ID]: `Duplicate verification method ID`,
      [GHOSTSPEAK_MARKETPLACE_ERROR__DUPLICATE_SERVICE_ID]: `Duplicate service endpoint ID`,
      [GHOSTSPEAK_MARKETPLACE_ERROR__INVALID_DID_FORMAT]: `Invalid DID format`,
      [GHOSTSPEAK_MARKETPLACE_ERROR__METHOD_NOT_FOUND]: `Verification method not found`,
      [GHOSTSPEAK_MARKETPLACE_ERROR__SERVICE_NOT_FOUND]: `Service endpoint not found`,
      [GHOSTSPEAK_MARKETPLACE_ERROR__TOO_MANY_SERVICE_ENDPOINTS]: `Maximum number of service endpoints reached`,
      [GHOSTSPEAK_MARKETPLACE_ERROR__TOO_MANY_VERIFICATION_METHODS]: `Maximum number of verification methods reached`,
      [GHOSTSPEAK_MARKETPLACE_ERROR__UNAUTHORIZED_DID_OPERATION]: `Unauthorized DID operation`
    };
  }
  ACTIVATE_AGENT_DISCRIMINATOR = new Uint8Array([
    252,
    139,
    87,
    21,
    195,
    152,
    29,
    217
  ]);
  APPROVE_DELIVERY_DISCRIMINATOR = new Uint8Array([
    28,
    233,
    51,
    115,
    33,
    220,
    41,
    28
  ]);
  ARBITRATE_DISPUTE_DISCRIMINATOR = new Uint8Array([
    225,
    89,
    166,
    101,
    215,
    40,
    191,
    4
  ]);
  CREATE_CREDENTIAL_TEMPLATE_DISCRIMINATOR = new Uint8Array([
    183,
    109,
    12,
    128,
    134,
    8,
    139,
    144
  ]);
  CREATE_CREDENTIAL_TYPE_DISCRIMINATOR = new Uint8Array([
    211,
    208,
    67,
    175,
    20,
    248,
    8,
    227
  ]);
  CREATE_DID_DOCUMENT_DISCRIMINATOR = new Uint8Array([
    253,
    40,
    200,
    239,
    69,
    147,
    82,
    182
  ]);
  CREATE_ESCROW_DISCRIMINATOR = new Uint8Array([
    253,
    215,
    165,
    116,
    36,
    108,
    68,
    80
  ]);
  CREATE_MULTISIG_DISCRIMINATOR = new Uint8Array([
    148,
    146,
    240,
    10,
    226,
    215,
    167,
    174
  ]);
  DEACTIVATE_AGENT_DISCRIMINATOR = new Uint8Array([
    205,
    171,
    239,
    225,
    82,
    126,
    96,
    166
  ]);
  DEACTIVATE_CREDENTIAL_TEMPLATE_DISCRIMINATOR = new Uint8Array([
    177,
    8,
    195,
    104,
    56,
    34,
    84,
    162
  ]);
  DEACTIVATE_CREDENTIAL_TYPE_DISCRIMINATOR = new Uint8Array([
    110,
    174,
    221,
    244,
    36,
    206,
    60,
    237
  ]);
  DEACTIVATE_DID_DOCUMENT_DISCRIMINATOR = new Uint8Array([
    77,
    13,
    56,
    161,
    67,
    155,
    206,
    119
  ]);
  ENABLE_PROTOCOL_FEES_DISCRIMINATOR = new Uint8Array([
    9,
    115,
    79,
    19,
    158,
    209,
    221,
    38
  ]);
  FILE_DISPUTE_DISCRIMINATOR = new Uint8Array([
    210,
    63,
    221,
    114,
    212,
    97,
    195,
    156
  ]);
  GENERATE_COMPLIANCE_REPORT_DISCRIMINATOR = new Uint8Array([
    213,
    97,
    79,
    234,
    22,
    228,
    14,
    32
  ]);
  INITIALIZE_AUDIT_TRAIL_DISCRIMINATOR = new Uint8Array([
    145,
    182,
    236,
    249,
    212,
    17,
    175,
    161
  ]);
  INITIALIZE_GOVERNANCE_PROPOSAL_DISCRIMINATOR = new Uint8Array([
    137,
    84,
    234,
    206,
    17,
    58,
    54,
    215
  ]);
  INITIALIZE_PROTOCOL_CONFIG_DISCRIMINATOR = new Uint8Array([
    28,
    50,
    43,
    233,
    244,
    98,
    123,
    118
  ]);
  INITIALIZE_RBAC_CONFIG_DISCRIMINATOR = new Uint8Array([
    215,
    68,
    129,
    228,
    237,
    165,
    0,
    240
  ]);
  INITIALIZE_REPUTATION_METRICS_DISCRIMINATOR = new Uint8Array([
    228,
    11,
    207,
    44,
    52,
    188,
    169,
    237
  ]);
  INITIALIZE_STAKING_CONFIG_DISCRIMINATOR = new Uint8Array([
    78,
    164,
    6,
    115,
    206,
    48,
    168,
    105
  ]);
  INIT_REENTRANCY_GUARD_DISCRIMINATOR = new Uint8Array([
    156,
    109,
    115,
    85,
    12,
    60,
    245,
    99
  ]);
  ISSUE_CREDENTIAL_DISCRIMINATOR = new Uint8Array([
    255,
    193,
    171,
    224,
    68,
    171,
    194,
    87
  ]);
  MANAGE_AGENT_STATUS_DISCRIMINATOR = new Uint8Array([
    164,
    219,
    91,
    38,
    45,
    31,
    33,
    47
  ]);
  RECORD_PAYAI_PAYMENT_DISCRIMINATOR = new Uint8Array([
    165,
    202,
    159,
    139,
    65,
    65,
    36,
    163
  ]);
  REGISTER_AGENT_DISCRIMINATOR = new Uint8Array([
    135,
    157,
    66,
    195,
    2,
    113,
    175,
    30
  ]);
  REGISTER_AGENT_COMPRESSED_DISCRIMINATOR = new Uint8Array([
    15,
    6,
    94,
    55,
    65,
    80,
    123,
    248
  ]);
  RESET_REENTRANCY_GUARD_DISCRIMINATOR = new Uint8Array([
    93,
    74,
    168,
    125,
    46,
    153,
    9,
    255
  ]);
  RESOLVE_DID_DOCUMENT_DISCRIMINATOR = new Uint8Array([
    168,
    180,
    218,
    211,
    184,
    19,
    102,
    12
  ]);
  REVOKE_CREDENTIAL_DISCRIMINATOR = new Uint8Array([
    38,
    123,
    95,
    95,
    223,
    158,
    169,
    87
  ]);
  SLASH_STAKE_DISCRIMINATOR = new Uint8Array([
    190,
    242,
    137,
    27,
    41,
    18,
    233,
    37
  ]);
  STAKE_GHOST_DISCRIMINATOR = new Uint8Array([
    5,
    196,
    24,
    54,
    196,
    56,
    173,
    191
  ]);
  SUBMIT_DELIVERY_DISCRIMINATOR = new Uint8Array([
    217,
    177,
    33,
    54,
    136,
    185,
    123,
    96
  ]);
  SUBMIT_SERVICE_RATING_DISCRIMINATOR = new Uint8Array([
    23,
    160,
    228,
    88,
    168,
    145,
    129,
    19
  ]);
  UNSTAKE_GHOST_DISCRIMINATOR = new Uint8Array([
    252,
    101,
    172,
    252,
    1,
    4,
    12,
    116
  ]);
  UPDATE_AGENT_DISCRIMINATOR = new Uint8Array([
    85,
    2,
    178,
    9,
    119,
    139,
    102,
    164
  ]);
  UPDATE_AGENT_REPUTATION_DISCRIMINATOR = new Uint8Array([
    80,
    227,
    92,
    245,
    231,
    37,
    99,
    180
  ]);
  UPDATE_AGENT_SERVICE_DISCRIMINATOR = new Uint8Array([
    87,
    146,
    181,
    198,
    252,
    68,
    243,
    102
  ]);
  UPDATE_CROSSCHAIN_STATUS_DISCRIMINATOR = new Uint8Array([
    22,
    167,
    59,
    238,
    22,
    231,
    239,
    146
  ]);
  UPDATE_DID_DOCUMENT_DISCRIMINATOR = new Uint8Array([
    64,
    216,
    17,
    91,
    205,
    94,
    45,
    57
  ]);
  UPDATE_PROTOCOL_CONFIG_DISCRIMINATOR = new Uint8Array([
    197,
    97,
    123,
    54,
    221,
    168,
    11,
    135
  ]);
  UPDATE_REPUTATION_TAGS_DISCRIMINATOR = new Uint8Array([
    206,
    96,
    254,
    186,
    129,
    180,
    103,
    198
  ]);
  UPDATE_SOURCE_REPUTATION_DISCRIMINATOR = new Uint8Array([
    161,
    240,
    255,
    69,
    130,
    227,
    71,
    123
  ]);
  VERIFY_AGENT_DISCRIMINATOR = new Uint8Array([
    206,
    212,
    108,
    12,
    105,
    61,
    100,
    66
  ]);
  VERIFY_AUTHORIZATION_DISCRIMINATOR = new Uint8Array([
    43,
    9,
    131,
    59,
    74,
    118,
    113,
    170
  ]);
});

// ../node_modules/.bun/lru-cache@11.2.4/node_modules/lru-cache/dist/esm/index.js
class Stack {
  heap;
  length;
  static #constructing = false;
  static create(max) {
    const HeapCls = getUintArray(max);
    if (!HeapCls)
      return [];
    Stack.#constructing = true;
    const s3 = new Stack(max, HeapCls);
    Stack.#constructing = false;
    return s3;
  }
  constructor(max, HeapCls) {
    if (!Stack.#constructing) {
      throw new TypeError("instantiate Stack using Stack.create(n)");
    }
    this.heap = new HeapCls(max);
    this.length = 0;
  }
  push(n) {
    this.heap[this.length++] = n;
  }
  pop() {
    return this.heap[--this.length];
  }
}
var defaultPerf, warned, PROCESS, emitWarning = (msg, type, code, fn) => {
  typeof PROCESS.emitWarning === "function" ? PROCESS.emitWarning(msg, type, code, fn) : console.error(`[${code}] ${type}: ${msg}`);
}, AC, AS, shouldWarn = (code) => !warned.has(code), TYPE3, isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n), getUintArray = (max) => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null, ZeroArray, LRUCache;
var init_esm = __esm(() => {
  defaultPerf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
  warned = new Set;
  PROCESS = typeof process === "object" && !!process ? process : {};
  AC = globalThis.AbortController;
  AS = globalThis.AbortSignal;
  if (typeof AC === "undefined") {
    AS = class AbortSignal2 {
      onabort;
      _onabort = [];
      reason;
      aborted = false;
      addEventListener(_, fn) {
        this._onabort.push(fn);
      }
    };
    AC = class AbortController2 {
      constructor() {
        warnACPolyfill();
      }
      signal = new AS;
      abort(reason) {
        if (this.signal.aborted)
          return;
        this.signal.reason = reason;
        this.signal.aborted = true;
        for (const fn of this.signal._onabort) {
          fn(reason);
        }
        this.signal.onabort?.(reason);
      }
    };
    let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== "1";
    const warnACPolyfill = () => {
      if (!printACPolyfillWarning)
        return;
      printACPolyfillWarning = false;
      emitWarning("AbortController is not defined. If using lru-cache in " + "node 14, load an AbortController polyfill from the " + "`node-abort-controller` package. A minimal polyfill is " + "provided for use by LRUCache.fetch(), but it should not be " + "relied upon in other contexts (eg, passing it to other APIs that " + "use AbortController/AbortSignal might have undesirable effects). " + "You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", warnACPolyfill);
    };
  }
  TYPE3 = Symbol("type");
  ZeroArray = class ZeroArray extends Array {
    constructor(size) {
      super(size);
      this.fill(0);
    }
  };
  LRUCache = class LRUCache {
    #max;
    #maxSize;
    #dispose;
    #onInsert;
    #disposeAfter;
    #fetchMethod;
    #memoMethod;
    #perf;
    get perf() {
      return this.#perf;
    }
    ttl;
    ttlResolution;
    ttlAutopurge;
    updateAgeOnGet;
    updateAgeOnHas;
    allowStale;
    noDisposeOnSet;
    noUpdateTTL;
    maxEntrySize;
    sizeCalculation;
    noDeleteOnFetchRejection;
    noDeleteOnStaleGet;
    allowStaleOnFetchAbort;
    allowStaleOnFetchRejection;
    ignoreFetchAbort;
    #size;
    #calculatedSize;
    #keyMap;
    #keyList;
    #valList;
    #next;
    #prev;
    #head;
    #tail;
    #free;
    #disposed;
    #sizes;
    #starts;
    #ttls;
    #autopurgeTimers;
    #hasDispose;
    #hasFetchMethod;
    #hasDisposeAfter;
    #hasOnInsert;
    static unsafeExposeInternals(c) {
      return {
        starts: c.#starts,
        ttls: c.#ttls,
        autopurgeTimers: c.#autopurgeTimers,
        sizes: c.#sizes,
        keyMap: c.#keyMap,
        keyList: c.#keyList,
        valList: c.#valList,
        next: c.#next,
        prev: c.#prev,
        get head() {
          return c.#head;
        },
        get tail() {
          return c.#tail;
        },
        free: c.#free,
        isBackgroundFetch: (p) => c.#isBackgroundFetch(p),
        backgroundFetch: (k, index, options2, context) => c.#backgroundFetch(k, index, options2, context),
        moveToTail: (index) => c.#moveToTail(index),
        indexes: (options2) => c.#indexes(options2),
        rindexes: (options2) => c.#rindexes(options2),
        isStale: (index) => c.#isStale(index)
      };
    }
    get max() {
      return this.#max;
    }
    get maxSize() {
      return this.#maxSize;
    }
    get calculatedSize() {
      return this.#calculatedSize;
    }
    get size() {
      return this.#size;
    }
    get fetchMethod() {
      return this.#fetchMethod;
    }
    get memoMethod() {
      return this.#memoMethod;
    }
    get dispose() {
      return this.#dispose;
    }
    get onInsert() {
      return this.#onInsert;
    }
    get disposeAfter() {
      return this.#disposeAfter;
    }
    constructor(options2) {
      const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, onInsert, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, memoMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort, perf } = options2;
      if (perf !== undefined) {
        if (typeof perf?.now !== "function") {
          throw new TypeError("perf option must have a now() method if specified");
        }
      }
      this.#perf = perf ?? defaultPerf;
      if (max !== 0 && !isPosInt(max)) {
        throw new TypeError("max option must be a nonnegative integer");
      }
      const UintArray = max ? getUintArray(max) : Array;
      if (!UintArray) {
        throw new Error("invalid max value: " + max);
      }
      this.#max = max;
      this.#maxSize = maxSize;
      this.maxEntrySize = maxEntrySize || this.#maxSize;
      this.sizeCalculation = sizeCalculation;
      if (this.sizeCalculation) {
        if (!this.#maxSize && !this.maxEntrySize) {
          throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
        }
        if (typeof this.sizeCalculation !== "function") {
          throw new TypeError("sizeCalculation set to non-function");
        }
      }
      if (memoMethod !== undefined && typeof memoMethod !== "function") {
        throw new TypeError("memoMethod must be a function if defined");
      }
      this.#memoMethod = memoMethod;
      if (fetchMethod !== undefined && typeof fetchMethod !== "function") {
        throw new TypeError("fetchMethod must be a function if specified");
      }
      this.#fetchMethod = fetchMethod;
      this.#hasFetchMethod = !!fetchMethod;
      this.#keyMap = new Map;
      this.#keyList = new Array(max).fill(undefined);
      this.#valList = new Array(max).fill(undefined);
      this.#next = new UintArray(max);
      this.#prev = new UintArray(max);
      this.#head = 0;
      this.#tail = 0;
      this.#free = Stack.create(max);
      this.#size = 0;
      this.#calculatedSize = 0;
      if (typeof dispose === "function") {
        this.#dispose = dispose;
      }
      if (typeof onInsert === "function") {
        this.#onInsert = onInsert;
      }
      if (typeof disposeAfter === "function") {
        this.#disposeAfter = disposeAfter;
        this.#disposed = [];
      } else {
        this.#disposeAfter = undefined;
        this.#disposed = undefined;
      }
      this.#hasDispose = !!this.#dispose;
      this.#hasOnInsert = !!this.#onInsert;
      this.#hasDisposeAfter = !!this.#disposeAfter;
      this.noDisposeOnSet = !!noDisposeOnSet;
      this.noUpdateTTL = !!noUpdateTTL;
      this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
      this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
      this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
      this.ignoreFetchAbort = !!ignoreFetchAbort;
      if (this.maxEntrySize !== 0) {
        if (this.#maxSize !== 0) {
          if (!isPosInt(this.#maxSize)) {
            throw new TypeError("maxSize must be a positive integer if specified");
          }
        }
        if (!isPosInt(this.maxEntrySize)) {
          throw new TypeError("maxEntrySize must be a positive integer if specified");
        }
        this.#initializeSizeTracking();
      }
      this.allowStale = !!allowStale;
      this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
      this.updateAgeOnGet = !!updateAgeOnGet;
      this.updateAgeOnHas = !!updateAgeOnHas;
      this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
      this.ttlAutopurge = !!ttlAutopurge;
      this.ttl = ttl || 0;
      if (this.ttl) {
        if (!isPosInt(this.ttl)) {
          throw new TypeError("ttl must be a positive integer if specified");
        }
        this.#initializeTTLTracking();
      }
      if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {
        throw new TypeError("At least one of max, maxSize, or ttl is required");
      }
      if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {
        const code = "LRU_CACHE_UNBOUNDED";
        if (shouldWarn(code)) {
          warned.add(code);
          const msg = "TTL caching without ttlAutopurge, max, or maxSize can " + "result in unbounded memory consumption.";
          emitWarning(msg, "UnboundedCacheWarning", code, LRUCache);
        }
      }
    }
    getRemainingTTL(key) {
      return this.#keyMap.has(key) ? Infinity : 0;
    }
    #initializeTTLTracking() {
      const ttls = new ZeroArray(this.#max);
      const starts = new ZeroArray(this.#max);
      this.#ttls = ttls;
      this.#starts = starts;
      const purgeTimers = this.ttlAutopurge ? new Array(this.#max) : undefined;
      this.#autopurgeTimers = purgeTimers;
      this.#setItemTTL = (index, ttl, start = this.#perf.now()) => {
        starts[index] = ttl !== 0 ? start : 0;
        ttls[index] = ttl;
        if (purgeTimers?.[index]) {
          clearTimeout(purgeTimers[index]);
          purgeTimers[index] = undefined;
        }
        if (ttl !== 0 && purgeTimers) {
          const t = setTimeout(() => {
            if (this.#isStale(index)) {
              this.#delete(this.#keyList[index], "expire");
            }
          }, ttl + 1);
          if (t.unref) {
            t.unref();
          }
          purgeTimers[index] = t;
        }
      };
      this.#updateItemAge = (index) => {
        starts[index] = ttls[index] !== 0 ? this.#perf.now() : 0;
      };
      this.#statusTTL = (status, index) => {
        if (ttls[index]) {
          const ttl = ttls[index];
          const start = starts[index];
          if (!ttl || !start)
            return;
          status.ttl = ttl;
          status.start = start;
          status.now = cachedNow || getNow();
          const age = status.now - start;
          status.remainingTTL = ttl - age;
        }
      };
      let cachedNow = 0;
      const getNow = () => {
        const n = this.#perf.now();
        if (this.ttlResolution > 0) {
          cachedNow = n;
          const t = setTimeout(() => cachedNow = 0, this.ttlResolution);
          if (t.unref) {
            t.unref();
          }
        }
        return n;
      };
      this.getRemainingTTL = (key) => {
        const index = this.#keyMap.get(key);
        if (index === undefined) {
          return 0;
        }
        const ttl = ttls[index];
        const start = starts[index];
        if (!ttl || !start) {
          return Infinity;
        }
        const age = (cachedNow || getNow()) - start;
        return ttl - age;
      };
      this.#isStale = (index) => {
        const s3 = starts[index];
        const t = ttls[index];
        return !!t && !!s3 && (cachedNow || getNow()) - s3 > t;
      };
    }
    #updateItemAge = () => {};
    #statusTTL = () => {};
    #setItemTTL = () => {};
    #isStale = () => false;
    #initializeSizeTracking() {
      const sizes = new ZeroArray(this.#max);
      this.#calculatedSize = 0;
      this.#sizes = sizes;
      this.#removeItemSize = (index) => {
        this.#calculatedSize -= sizes[index];
        sizes[index] = 0;
      };
      this.#requireSize = (k, v, size, sizeCalculation) => {
        if (this.#isBackgroundFetch(v)) {
          return 0;
        }
        if (!isPosInt(size)) {
          if (sizeCalculation) {
            if (typeof sizeCalculation !== "function") {
              throw new TypeError("sizeCalculation must be a function");
            }
            size = sizeCalculation(v, k);
            if (!isPosInt(size)) {
              throw new TypeError("sizeCalculation return invalid (expect positive integer)");
            }
          } else {
            throw new TypeError("invalid size value (must be positive integer). " + "When maxSize or maxEntrySize is used, sizeCalculation " + "or size must be set.");
          }
        }
        return size;
      };
      this.#addItemSize = (index, size, status) => {
        sizes[index] = size;
        if (this.#maxSize) {
          const maxSize = this.#maxSize - sizes[index];
          while (this.#calculatedSize > maxSize) {
            this.#evict(true);
          }
        }
        this.#calculatedSize += sizes[index];
        if (status) {
          status.entrySize = size;
          status.totalCalculatedSize = this.#calculatedSize;
        }
      };
    }
    #removeItemSize = (_i) => {};
    #addItemSize = (_i, _s, _st) => {};
    #requireSize = (_k, _v, size, sizeCalculation) => {
      if (size || sizeCalculation) {
        throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
      }
      return 0;
    };
    *#indexes({ allowStale = this.allowStale } = {}) {
      if (this.#size) {
        for (let i = this.#tail;; ) {
          if (!this.#isValidIndex(i)) {
            break;
          }
          if (allowStale || !this.#isStale(i)) {
            yield i;
          }
          if (i === this.#head) {
            break;
          } else {
            i = this.#prev[i];
          }
        }
      }
    }
    *#rindexes({ allowStale = this.allowStale } = {}) {
      if (this.#size) {
        for (let i = this.#head;; ) {
          if (!this.#isValidIndex(i)) {
            break;
          }
          if (allowStale || !this.#isStale(i)) {
            yield i;
          }
          if (i === this.#tail) {
            break;
          } else {
            i = this.#next[i];
          }
        }
      }
    }
    #isValidIndex(index) {
      return index !== undefined && this.#keyMap.get(this.#keyList[index]) === index;
    }
    *entries() {
      for (const i of this.#indexes()) {
        if (this.#valList[i] !== undefined && this.#keyList[i] !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
          yield [this.#keyList[i], this.#valList[i]];
        }
      }
    }
    *rentries() {
      for (const i of this.#rindexes()) {
        if (this.#valList[i] !== undefined && this.#keyList[i] !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
          yield [this.#keyList[i], this.#valList[i]];
        }
      }
    }
    *keys() {
      for (const i of this.#indexes()) {
        const k = this.#keyList[i];
        if (k !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
          yield k;
        }
      }
    }
    *rkeys() {
      for (const i of this.#rindexes()) {
        const k = this.#keyList[i];
        if (k !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
          yield k;
        }
      }
    }
    *values() {
      for (const i of this.#indexes()) {
        const v = this.#valList[i];
        if (v !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
          yield this.#valList[i];
        }
      }
    }
    *rvalues() {
      for (const i of this.#rindexes()) {
        const v = this.#valList[i];
        if (v !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
          yield this.#valList[i];
        }
      }
    }
    [Symbol.iterator]() {
      return this.entries();
    }
    [Symbol.toStringTag] = "LRUCache";
    find(fn, getOptions = {}) {
      for (const i of this.#indexes()) {
        const v = this.#valList[i];
        const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
        if (value === undefined)
          continue;
        if (fn(value, this.#keyList[i], this)) {
          return this.get(this.#keyList[i], getOptions);
        }
      }
    }
    forEach(fn, thisp = this) {
      for (const i of this.#indexes()) {
        const v = this.#valList[i];
        const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
        if (value === undefined)
          continue;
        fn.call(thisp, value, this.#keyList[i], this);
      }
    }
    rforEach(fn, thisp = this) {
      for (const i of this.#rindexes()) {
        const v = this.#valList[i];
        const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
        if (value === undefined)
          continue;
        fn.call(thisp, value, this.#keyList[i], this);
      }
    }
    purgeStale() {
      let deleted = false;
      for (const i of this.#rindexes({ allowStale: true })) {
        if (this.#isStale(i)) {
          this.#delete(this.#keyList[i], "expire");
          deleted = true;
        }
      }
      return deleted;
    }
    info(key) {
      const i = this.#keyMap.get(key);
      if (i === undefined)
        return;
      const v = this.#valList[i];
      const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      if (value === undefined)
        return;
      const entry = { value };
      if (this.#ttls && this.#starts) {
        const ttl = this.#ttls[i];
        const start = this.#starts[i];
        if (ttl && start) {
          const remain = ttl - (this.#perf.now() - start);
          entry.ttl = remain;
          entry.start = Date.now();
        }
      }
      if (this.#sizes) {
        entry.size = this.#sizes[i];
      }
      return entry;
    }
    dump() {
      const arr = [];
      for (const i of this.#indexes({ allowStale: true })) {
        const key = this.#keyList[i];
        const v = this.#valList[i];
        const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
        if (value === undefined || key === undefined)
          continue;
        const entry = { value };
        if (this.#ttls && this.#starts) {
          entry.ttl = this.#ttls[i];
          const age = this.#perf.now() - this.#starts[i];
          entry.start = Math.floor(Date.now() - age);
        }
        if (this.#sizes) {
          entry.size = this.#sizes[i];
        }
        arr.unshift([key, entry]);
      }
      return arr;
    }
    load(arr) {
      this.clear();
      for (const [key, entry] of arr) {
        if (entry.start) {
          const age = Date.now() - entry.start;
          entry.start = this.#perf.now() - age;
        }
        this.set(key, entry.value, entry);
      }
    }
    set(k, v, setOptions = {}) {
      if (v === undefined) {
        this.delete(k);
        return this;
      }
      const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status } = setOptions;
      let { noUpdateTTL = this.noUpdateTTL } = setOptions;
      const size = this.#requireSize(k, v, setOptions.size || 0, sizeCalculation);
      if (this.maxEntrySize && size > this.maxEntrySize) {
        if (status) {
          status.set = "miss";
          status.maxEntrySizeExceeded = true;
        }
        this.#delete(k, "set");
        return this;
      }
      let index = this.#size === 0 ? undefined : this.#keyMap.get(k);
      if (index === undefined) {
        index = this.#size === 0 ? this.#tail : this.#free.length !== 0 ? this.#free.pop() : this.#size === this.#max ? this.#evict(false) : this.#size;
        this.#keyList[index] = k;
        this.#valList[index] = v;
        this.#keyMap.set(k, index);
        this.#next[this.#tail] = index;
        this.#prev[index] = this.#tail;
        this.#tail = index;
        this.#size++;
        this.#addItemSize(index, size, status);
        if (status)
          status.set = "add";
        noUpdateTTL = false;
        if (this.#hasOnInsert) {
          this.#onInsert?.(v, k, "add");
        }
      } else {
        this.#moveToTail(index);
        const oldVal = this.#valList[index];
        if (v !== oldVal) {
          if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {
            oldVal.__abortController.abort(new Error("replaced"));
            const { __staleWhileFetching: s3 } = oldVal;
            if (s3 !== undefined && !noDisposeOnSet) {
              if (this.#hasDispose) {
                this.#dispose?.(s3, k, "set");
              }
              if (this.#hasDisposeAfter) {
                this.#disposed?.push([s3, k, "set"]);
              }
            }
          } else if (!noDisposeOnSet) {
            if (this.#hasDispose) {
              this.#dispose?.(oldVal, k, "set");
            }
            if (this.#hasDisposeAfter) {
              this.#disposed?.push([oldVal, k, "set"]);
            }
          }
          this.#removeItemSize(index);
          this.#addItemSize(index, size, status);
          this.#valList[index] = v;
          if (status) {
            status.set = "replace";
            const oldValue = oldVal && this.#isBackgroundFetch(oldVal) ? oldVal.__staleWhileFetching : oldVal;
            if (oldValue !== undefined)
              status.oldValue = oldValue;
          }
        } else if (status) {
          status.set = "update";
        }
        if (this.#hasOnInsert) {
          this.onInsert?.(v, k, v === oldVal ? "update" : "replace");
        }
      }
      if (ttl !== 0 && !this.#ttls) {
        this.#initializeTTLTracking();
      }
      if (this.#ttls) {
        if (!noUpdateTTL) {
          this.#setItemTTL(index, ttl, start);
        }
        if (status)
          this.#statusTTL(status, index);
      }
      if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {
        const dt = this.#disposed;
        let task;
        while (task = dt?.shift()) {
          this.#disposeAfter?.(...task);
        }
      }
      return this;
    }
    pop() {
      try {
        while (this.#size) {
          const val = this.#valList[this.#head];
          this.#evict(true);
          if (this.#isBackgroundFetch(val)) {
            if (val.__staleWhileFetching) {
              return val.__staleWhileFetching;
            }
          } else if (val !== undefined) {
            return val;
          }
        }
      } finally {
        if (this.#hasDisposeAfter && this.#disposed) {
          const dt = this.#disposed;
          let task;
          while (task = dt?.shift()) {
            this.#disposeAfter?.(...task);
          }
        }
      }
    }
    #evict(free) {
      const head = this.#head;
      const k = this.#keyList[head];
      const v = this.#valList[head];
      if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {
        v.__abortController.abort(new Error("evicted"));
      } else if (this.#hasDispose || this.#hasDisposeAfter) {
        if (this.#hasDispose) {
          this.#dispose?.(v, k, "evict");
        }
        if (this.#hasDisposeAfter) {
          this.#disposed?.push([v, k, "evict"]);
        }
      }
      this.#removeItemSize(head);
      if (this.#autopurgeTimers?.[head]) {
        clearTimeout(this.#autopurgeTimers[head]);
        this.#autopurgeTimers[head] = undefined;
      }
      if (free) {
        this.#keyList[head] = undefined;
        this.#valList[head] = undefined;
        this.#free.push(head);
      }
      if (this.#size === 1) {
        this.#head = this.#tail = 0;
        this.#free.length = 0;
      } else {
        this.#head = this.#next[head];
      }
      this.#keyMap.delete(k);
      this.#size--;
      return head;
    }
    has(k, hasOptions = {}) {
      const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
      const index = this.#keyMap.get(k);
      if (index !== undefined) {
        const v = this.#valList[index];
        if (this.#isBackgroundFetch(v) && v.__staleWhileFetching === undefined) {
          return false;
        }
        if (!this.#isStale(index)) {
          if (updateAgeOnHas) {
            this.#updateItemAge(index);
          }
          if (status) {
            status.has = "hit";
            this.#statusTTL(status, index);
          }
          return true;
        } else if (status) {
          status.has = "stale";
          this.#statusTTL(status, index);
        }
      } else if (status) {
        status.has = "miss";
      }
      return false;
    }
    peek(k, peekOptions = {}) {
      const { allowStale = this.allowStale } = peekOptions;
      const index = this.#keyMap.get(k);
      if (index === undefined || !allowStale && this.#isStale(index)) {
        return;
      }
      const v = this.#valList[index];
      return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
    }
    #backgroundFetch(k, index, options2, context) {
      const v = index === undefined ? undefined : this.#valList[index];
      if (this.#isBackgroundFetch(v)) {
        return v;
      }
      const ac = new AC;
      const { signal } = options2;
      signal?.addEventListener("abort", () => ac.abort(signal.reason), {
        signal: ac.signal
      });
      const fetchOpts = {
        signal: ac.signal,
        options: options2,
        context
      };
      const cb = (v2, updateCache = false) => {
        const { aborted } = ac.signal;
        const ignoreAbort = options2.ignoreFetchAbort && v2 !== undefined;
        if (options2.status) {
          if (aborted && !updateCache) {
            options2.status.fetchAborted = true;
            options2.status.fetchError = ac.signal.reason;
            if (ignoreAbort)
              options2.status.fetchAbortIgnored = true;
          } else {
            options2.status.fetchResolved = true;
          }
        }
        if (aborted && !ignoreAbort && !updateCache) {
          return fetchFail(ac.signal.reason);
        }
        const bf2 = p;
        const vl = this.#valList[index];
        if (vl === p || ignoreAbort && updateCache && vl === undefined) {
          if (v2 === undefined) {
            if (bf2.__staleWhileFetching !== undefined) {
              this.#valList[index] = bf2.__staleWhileFetching;
            } else {
              this.#delete(k, "fetch");
            }
          } else {
            if (options2.status)
              options2.status.fetchUpdated = true;
            this.set(k, v2, fetchOpts.options);
          }
        }
        return v2;
      };
      const eb = (er) => {
        if (options2.status) {
          options2.status.fetchRejected = true;
          options2.status.fetchError = er;
        }
        return fetchFail(er);
      };
      const fetchFail = (er) => {
        const { aborted } = ac.signal;
        const allowStaleAborted = aborted && options2.allowStaleOnFetchAbort;
        const allowStale = allowStaleAborted || options2.allowStaleOnFetchRejection;
        const noDelete = allowStale || options2.noDeleteOnFetchRejection;
        const bf2 = p;
        if (this.#valList[index] === p) {
          const del = !noDelete || bf2.__staleWhileFetching === undefined;
          if (del) {
            this.#delete(k, "fetch");
          } else if (!allowStaleAborted) {
            this.#valList[index] = bf2.__staleWhileFetching;
          }
        }
        if (allowStale) {
          if (options2.status && bf2.__staleWhileFetching !== undefined) {
            options2.status.returnedStale = true;
          }
          return bf2.__staleWhileFetching;
        } else if (bf2.__returned === bf2) {
          throw er;
        }
      };
      const pcall = (res, rej) => {
        const fmp = this.#fetchMethod?.(k, v, fetchOpts);
        if (fmp && fmp instanceof Promise) {
          fmp.then((v2) => res(v2 === undefined ? undefined : v2), rej);
        }
        ac.signal.addEventListener("abort", () => {
          if (!options2.ignoreFetchAbort || options2.allowStaleOnFetchAbort) {
            res(undefined);
            if (options2.allowStaleOnFetchAbort) {
              res = (v2) => cb(v2, true);
            }
          }
        });
      };
      if (options2.status)
        options2.status.fetchDispatched = true;
      const p = new Promise(pcall).then(cb, eb);
      const bf = Object.assign(p, {
        __abortController: ac,
        __staleWhileFetching: v,
        __returned: undefined
      });
      if (index === undefined) {
        this.set(k, bf, { ...fetchOpts.options, status: undefined });
        index = this.#keyMap.get(k);
      } else {
        this.#valList[index] = bf;
      }
      return bf;
    }
    #isBackgroundFetch(p) {
      if (!this.#hasFetchMethod)
        return false;
      const b = p;
      return !!b && b instanceof Promise && b.hasOwnProperty("__staleWhileFetching") && b.__abortController instanceof AC;
    }
    async fetch(k, fetchOptions = {}) {
      const {
        allowStale = this.allowStale,
        updateAgeOnGet = this.updateAgeOnGet,
        noDeleteOnStaleGet = this.noDeleteOnStaleGet,
        ttl = this.ttl,
        noDisposeOnSet = this.noDisposeOnSet,
        size = 0,
        sizeCalculation = this.sizeCalculation,
        noUpdateTTL = this.noUpdateTTL,
        noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
        allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
        ignoreFetchAbort = this.ignoreFetchAbort,
        allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
        context,
        forceRefresh = false,
        status,
        signal
      } = fetchOptions;
      if (!this.#hasFetchMethod) {
        if (status)
          status.fetch = "get";
        return this.get(k, {
          allowStale,
          updateAgeOnGet,
          noDeleteOnStaleGet,
          status
        });
      }
      const options2 = {
        allowStale,
        updateAgeOnGet,
        noDeleteOnStaleGet,
        ttl,
        noDisposeOnSet,
        size,
        sizeCalculation,
        noUpdateTTL,
        noDeleteOnFetchRejection,
        allowStaleOnFetchRejection,
        allowStaleOnFetchAbort,
        ignoreFetchAbort,
        status,
        signal
      };
      let index = this.#keyMap.get(k);
      if (index === undefined) {
        if (status)
          status.fetch = "miss";
        const p = this.#backgroundFetch(k, index, options2, context);
        return p.__returned = p;
      } else {
        const v = this.#valList[index];
        if (this.#isBackgroundFetch(v)) {
          const stale = allowStale && v.__staleWhileFetching !== undefined;
          if (status) {
            status.fetch = "inflight";
            if (stale)
              status.returnedStale = true;
          }
          return stale ? v.__staleWhileFetching : v.__returned = v;
        }
        const isStale = this.#isStale(index);
        if (!forceRefresh && !isStale) {
          if (status)
            status.fetch = "hit";
          this.#moveToTail(index);
          if (updateAgeOnGet) {
            this.#updateItemAge(index);
          }
          if (status)
            this.#statusTTL(status, index);
          return v;
        }
        const p = this.#backgroundFetch(k, index, options2, context);
        const hasStale = p.__staleWhileFetching !== undefined;
        const staleVal = hasStale && allowStale;
        if (status) {
          status.fetch = isStale ? "stale" : "refresh";
          if (staleVal && isStale)
            status.returnedStale = true;
        }
        return staleVal ? p.__staleWhileFetching : p.__returned = p;
      }
    }
    async forceFetch(k, fetchOptions = {}) {
      const v = await this.fetch(k, fetchOptions);
      if (v === undefined)
        throw new Error("fetch() returned undefined");
      return v;
    }
    memo(k, memoOptions = {}) {
      const memoMethod = this.#memoMethod;
      if (!memoMethod) {
        throw new Error("no memoMethod provided to constructor");
      }
      const { context, forceRefresh, ...options2 } = memoOptions;
      const v = this.get(k, options2);
      if (!forceRefresh && v !== undefined)
        return v;
      const vv = memoMethod(k, v, {
        options: options2,
        context
      });
      this.set(k, vv, options2);
      return vv;
    }
    get(k, getOptions = {}) {
      const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status } = getOptions;
      const index = this.#keyMap.get(k);
      if (index !== undefined) {
        const value = this.#valList[index];
        const fetching = this.#isBackgroundFetch(value);
        if (status)
          this.#statusTTL(status, index);
        if (this.#isStale(index)) {
          if (status)
            status.get = "stale";
          if (!fetching) {
            if (!noDeleteOnStaleGet) {
              this.#delete(k, "expire");
            }
            if (status && allowStale)
              status.returnedStale = true;
            return allowStale ? value : undefined;
          } else {
            if (status && allowStale && value.__staleWhileFetching !== undefined) {
              status.returnedStale = true;
            }
            return allowStale ? value.__staleWhileFetching : undefined;
          }
        } else {
          if (status)
            status.get = "hit";
          if (fetching) {
            return value.__staleWhileFetching;
          }
          this.#moveToTail(index);
          if (updateAgeOnGet) {
            this.#updateItemAge(index);
          }
          return value;
        }
      } else if (status) {
        status.get = "miss";
      }
    }
    #connect(p, n) {
      this.#prev[n] = p;
      this.#next[p] = n;
    }
    #moveToTail(index) {
      if (index !== this.#tail) {
        if (index === this.#head) {
          this.#head = this.#next[index];
        } else {
          this.#connect(this.#prev[index], this.#next[index]);
        }
        this.#connect(this.#tail, index);
        this.#tail = index;
      }
    }
    delete(k) {
      return this.#delete(k, "delete");
    }
    #delete(k, reason) {
      let deleted = false;
      if (this.#size !== 0) {
        const index = this.#keyMap.get(k);
        if (index !== undefined) {
          if (this.#autopurgeTimers?.[index]) {
            clearTimeout(this.#autopurgeTimers?.[index]);
            this.#autopurgeTimers[index] = undefined;
          }
          deleted = true;
          if (this.#size === 1) {
            this.#clear(reason);
          } else {
            this.#removeItemSize(index);
            const v = this.#valList[index];
            if (this.#isBackgroundFetch(v)) {
              v.__abortController.abort(new Error("deleted"));
            } else if (this.#hasDispose || this.#hasDisposeAfter) {
              if (this.#hasDispose) {
                this.#dispose?.(v, k, reason);
              }
              if (this.#hasDisposeAfter) {
                this.#disposed?.push([v, k, reason]);
              }
            }
            this.#keyMap.delete(k);
            this.#keyList[index] = undefined;
            this.#valList[index] = undefined;
            if (index === this.#tail) {
              this.#tail = this.#prev[index];
            } else if (index === this.#head) {
              this.#head = this.#next[index];
            } else {
              const pi = this.#prev[index];
              this.#next[pi] = this.#next[index];
              const ni = this.#next[index];
              this.#prev[ni] = this.#prev[index];
            }
            this.#size--;
            this.#free.push(index);
          }
        }
      }
      if (this.#hasDisposeAfter && this.#disposed?.length) {
        const dt = this.#disposed;
        let task;
        while (task = dt?.shift()) {
          this.#disposeAfter?.(...task);
        }
      }
      return deleted;
    }
    clear() {
      return this.#clear("delete");
    }
    #clear(reason) {
      for (const index of this.#rindexes({ allowStale: true })) {
        const v = this.#valList[index];
        if (this.#isBackgroundFetch(v)) {
          v.__abortController.abort(new Error("deleted"));
        } else {
          const k = this.#keyList[index];
          if (this.#hasDispose) {
            this.#dispose?.(v, k, reason);
          }
          if (this.#hasDisposeAfter) {
            this.#disposed?.push([v, k, reason]);
          }
        }
      }
      this.#keyMap.clear();
      this.#valList.fill(undefined);
      this.#keyList.fill(undefined);
      if (this.#ttls && this.#starts) {
        this.#ttls.fill(0);
        this.#starts.fill(0);
        for (const t of this.#autopurgeTimers ?? []) {
          if (t !== undefined)
            clearTimeout(t);
        }
        this.#autopurgeTimers?.fill(undefined);
      }
      if (this.#sizes) {
        this.#sizes.fill(0);
      }
      this.#head = 0;
      this.#tail = 0;
      this.#free.length = 0;
      this.#calculatedSize = 0;
      this.#size = 0;
      if (this.#hasDisposeAfter && this.#disposed) {
        const dt = this.#disposed;
        let task;
        while (task = dt?.shift()) {
          this.#disposeAfter?.(...task);
        }
      }
    }
  };
});

// ../node_modules/.bun/base-x@5.0.1/node_modules/base-x/src/esm/index.js
function base(ALPHABET) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  const BASE_MAP = new Uint8Array(256);
  for (let j = 0;j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (let i = 0;i < ALPHABET.length; i++) {
    const x = ALPHABET.charAt(i);
    const xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  const BASE = ALPHABET.length;
  const LEADER = ALPHABET.charAt(0);
  const FACTOR = Math.log(BASE) / Math.log(256);
  const iFACTOR = Math.log(256) / Math.log(BASE);
  function encode(source) {
    if (source instanceof Uint8Array) {} else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    let zeroes = 0;
    let length = 0;
    let pbegin = 0;
    const pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    const size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    const b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      let carry = source[pbegin];
      let i = 0;
      for (let it1 = size - 1;(carry !== 0 || i < length) && it1 !== -1; it1--, i++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length = i;
      pbegin++;
    }
    let it2 = size - length;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    let str = LEADER.repeat(zeroes);
    for (;it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array;
    }
    let psz = 0;
    let zeroes = 0;
    let length = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    const size = (source.length - psz) * FACTOR + 1 >>> 0;
    const b256 = new Uint8Array(size);
    while (psz < source.length) {
      const charCode = source.charCodeAt(psz);
      if (charCode > 255) {
        return;
      }
      let carry = BASE_MAP[charCode];
      if (carry === 255) {
        return;
      }
      let i = 0;
      for (let it3 = size - 1;(carry !== 0 || i < length) && it3 !== -1; it3--, i++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length = i;
      psz++;
    }
    let it4 = size - length;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    const vch = new Uint8Array(zeroes + (size - it4));
    let j = zeroes;
    while (it4 !== size) {
      vch[j++] = b256[it4++];
    }
    return vch;
  }
  function decode(string) {
    const buffer2 = decodeUnsafe(string);
    if (buffer2) {
      return buffer2;
    }
    throw new Error("Non-base" + BASE + " character");
  }
  return {
    encode,
    decodeUnsafe,
    decode
  };
}
var esm_default;
var init_esm2 = __esm(() => {
  esm_default = base;
});

// ../node_modules/.bun/bs58@6.0.0/node_modules/bs58/src/esm/index.js
var exports_esm = {};
__export(exports_esm, {
  default: () => esm_default2
});
var ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz", esm_default2;
var init_esm3 = __esm(() => {
  init_esm2();
  esm_default2 = esm_default(ALPHABET);
});

// ../node_modules/.bun/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/cryptoNode.js
import * as nc from "node:crypto";
var crypto2;
var init_cryptoNode = __esm(() => {
  crypto2 = nc && typeof nc === "object" && "webcrypto" in nc ? nc.webcrypto : nc && typeof nc === "object" && ("randomBytes" in nc) ? nc : undefined;
});

// ../node_modules/.bun/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/utils.js
function isBytes(a) {
  return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
}
function anumber(n) {
  if (!Number.isSafeInteger(n) || n < 0)
    throw new Error("positive integer expected, got " + n);
}
function abytes(b, ...lengths) {
  if (!isBytes(b))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
}
function aexists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function aoutput(out, instance) {
  abytes(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error("digestInto() expects output buffer of length at least " + min);
  }
}
function clean(...arrays) {
  for (let i = 0;i < arrays.length; i++) {
    arrays[i].fill(0);
  }
}
function createView(arr) {
  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
function rotr(word, shift) {
  return word << 32 - shift | word >>> shift;
}
function bytesToHex(bytes) {
  abytes(bytes);
  if (hasHexBuiltin)
    return bytes.toHex();
  let hex = "";
  for (let i = 0;i < bytes.length; i++) {
    hex += hexes[bytes[i]];
  }
  return hex;
}
function asciiToBase16(ch) {
  if (ch >= asciis._0 && ch <= asciis._9)
    return ch - asciis._0;
  if (ch >= asciis.A && ch <= asciis.F)
    return ch - (asciis.A - 10);
  if (ch >= asciis.a && ch <= asciis.f)
    return ch - (asciis.a - 10);
  return;
}
function hexToBytes(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  if (hasHexBuiltin)
    return Uint8Array.fromHex(hex);
  const hl = hex.length;
  const al = hl / 2;
  if (hl % 2)
    throw new Error("hex string expected, got unpadded hex of length " + hl);
  const array = new Uint8Array(al);
  for (let ai = 0, hi = 0;ai < al; ai++, hi += 2) {
    const n1 = asciiToBase16(hex.charCodeAt(hi));
    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
    if (n1 === undefined || n2 === undefined) {
      const char = hex[hi] + hex[hi + 1];
      throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
    }
    array[ai] = n1 * 16 + n2;
  }
  return array;
}
function utf8ToBytes(str) {
  if (typeof str !== "string")
    throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes(data2) {
  if (typeof data2 === "string")
    data2 = utf8ToBytes(data2);
  abytes(data2);
  return data2;
}
function concatBytes(...arrays) {
  let sum = 0;
  for (let i = 0;i < arrays.length; i++) {
    const a = arrays[i];
    abytes(a);
    sum += a.length;
  }
  const res = new Uint8Array(sum);
  for (let i = 0, pad = 0;i < arrays.length; i++) {
    const a = arrays[i];
    res.set(a, pad);
    pad += a.length;
  }
  return res;
}

class Hash {
}
function createHasher(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function randomBytes(bytesLength = 32) {
  if (crypto2 && typeof crypto2.getRandomValues === "function") {
    return crypto2.getRandomValues(new Uint8Array(bytesLength));
  }
  if (crypto2 && typeof crypto2.randomBytes === "function") {
    return Uint8Array.from(crypto2.randomBytes(bytesLength));
  }
  throw new Error("crypto.getRandomValues must be defined");
}
var hasHexBuiltin, hexes, asciis;
var init_utils = __esm(() => {
  init_cryptoNode();
  /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  hasHexBuiltin = /* @__PURE__ */ (() => typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function")();
  hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
  asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
});

// ../node_modules/.bun/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/_md.js
function setBigUint64(view, byteOffset, value, isLE) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE);
  const _32n = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n & _u32_max);
  const wl = Number(value & _u32_max);
  const h = isLE ? 4 : 0;
  const l2 = isLE ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE);
  view.setUint32(byteOffset + l2, wl, isLE);
}
function Chi(a, b, c) {
  return a & b ^ ~a & c;
}
function Maj(a, b, c) {
  return a & b ^ a & c ^ b & c;
}
var HashMD, SHA256_IV, SHA512_IV;
var init__md = __esm(() => {
  init_utils();
  HashMD = class HashMD extends Hash {
    constructor(blockLen, outputLen, padOffset, isLE) {
      super();
      this.finished = false;
      this.length = 0;
      this.pos = 0;
      this.destroyed = false;
      this.blockLen = blockLen;
      this.outputLen = outputLen;
      this.padOffset = padOffset;
      this.isLE = isLE;
      this.buffer = new Uint8Array(blockLen);
      this.view = createView(this.buffer);
    }
    update(data2) {
      aexists(this);
      data2 = toBytes(data2);
      abytes(data2);
      const { view, buffer: buffer2, blockLen } = this;
      const len = data2.length;
      for (let pos = 0;pos < len; ) {
        const take = Math.min(blockLen - this.pos, len - pos);
        if (take === blockLen) {
          const dataView = createView(data2);
          for (;blockLen <= len - pos; pos += blockLen)
            this.process(dataView, pos);
          continue;
        }
        buffer2.set(data2.subarray(pos, pos + take), this.pos);
        this.pos += take;
        pos += take;
        if (this.pos === blockLen) {
          this.process(view, 0);
          this.pos = 0;
        }
      }
      this.length += data2.length;
      this.roundClean();
      return this;
    }
    digestInto(out) {
      aexists(this);
      aoutput(out, this);
      this.finished = true;
      const { buffer: buffer2, view, blockLen, isLE } = this;
      let { pos } = this;
      buffer2[pos++] = 128;
      clean(this.buffer.subarray(pos));
      if (this.padOffset > blockLen - pos) {
        this.process(view, 0);
        pos = 0;
      }
      for (let i = pos;i < blockLen; i++)
        buffer2[i] = 0;
      setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
      this.process(view, 0);
      const oview = createView(out);
      const len = this.outputLen;
      if (len % 4)
        throw new Error("_sha2: outputLen should be aligned to 32bit");
      const outLen = len / 4;
      const state = this.get();
      if (outLen > state.length)
        throw new Error("_sha2: outputLen bigger than state");
      for (let i = 0;i < outLen; i++)
        oview.setUint32(4 * i, state[i], isLE);
    }
    digest() {
      const { buffer: buffer2, outputLen } = this;
      this.digestInto(buffer2);
      const res = buffer2.slice(0, outputLen);
      this.destroy();
      return res;
    }
    _cloneInto(to) {
      to || (to = new this.constructor);
      to.set(...this.get());
      const { blockLen, buffer: buffer2, length, finished, destroyed, pos } = this;
      to.destroyed = destroyed;
      to.finished = finished;
      to.length = length;
      to.pos = pos;
      if (length % blockLen)
        to.buffer.set(buffer2);
      return to;
    }
    clone() {
      return this._cloneInto();
    }
  };
  SHA256_IV = /* @__PURE__ */ Uint32Array.from([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ]);
  SHA512_IV = /* @__PURE__ */ Uint32Array.from([
    1779033703,
    4089235720,
    3144134277,
    2227873595,
    1013904242,
    4271175723,
    2773480762,
    1595750129,
    1359893119,
    2917565137,
    2600822924,
    725511199,
    528734635,
    4215389547,
    1541459225,
    327033209
  ]);
});

// ../node_modules/.bun/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/_u64.js
function fromBig(n, le = false) {
  if (le)
    return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
  return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
}
function split(lst, le = false) {
  const len = lst.length;
  let Ah = new Uint32Array(len);
  let Al = new Uint32Array(len);
  for (let i = 0;i < len; i++) {
    const { h, l: l2 } = fromBig(lst[i], le);
    [Ah[i], Al[i]] = [h, l2];
  }
  return [Ah, Al];
}
function add(Ah, Al, Bh, Bl) {
  const l2 = (Al >>> 0) + (Bl >>> 0);
  return { h: Ah + Bh + (l2 / 2 ** 32 | 0) | 0, l: l2 | 0 };
}
var U32_MASK64, _32n, shrSH = (h, _l, s3) => h >>> s3, shrSL = (h, l2, s3) => h << 32 - s3 | l2 >>> s3, rotrSH = (h, l2, s3) => h >>> s3 | l2 << 32 - s3, rotrSL = (h, l2, s3) => h << 32 - s3 | l2 >>> s3, rotrBH = (h, l2, s3) => h << 64 - s3 | l2 >>> s3 - 32, rotrBL = (h, l2, s3) => h >>> s3 - 32 | l2 << 64 - s3, add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0), add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0, add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0), add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0, add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0), add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
var init__u64 = __esm(() => {
  U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
  _32n = /* @__PURE__ */ BigInt(32);
});

// ../node_modules/.bun/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/sha2.js
var SHA256_K, SHA256_W, SHA256, K512, SHA512_Kh, SHA512_Kl, SHA512_W_H, SHA512_W_L, SHA512, sha256, sha512;
var init_sha2 = __esm(() => {
  init__md();
  init__u64();
  init_utils();
  SHA256_K = /* @__PURE__ */ Uint32Array.from([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]);
  SHA256_W = /* @__PURE__ */ new Uint32Array(64);
  SHA256 = class SHA256 extends HashMD {
    constructor(outputLen = 32) {
      super(64, outputLen, 8, false);
      this.A = SHA256_IV[0] | 0;
      this.B = SHA256_IV[1] | 0;
      this.C = SHA256_IV[2] | 0;
      this.D = SHA256_IV[3] | 0;
      this.E = SHA256_IV[4] | 0;
      this.F = SHA256_IV[5] | 0;
      this.G = SHA256_IV[6] | 0;
      this.H = SHA256_IV[7] | 0;
    }
    get() {
      const { A, B, C, D: D2, E, F, G, H } = this;
      return [A, B, C, D2, E, F, G, H];
    }
    set(A, B, C, D2, E, F, G, H) {
      this.A = A | 0;
      this.B = B | 0;
      this.C = C | 0;
      this.D = D2 | 0;
      this.E = E | 0;
      this.F = F | 0;
      this.G = G | 0;
      this.H = H | 0;
    }
    process(view, offset) {
      for (let i = 0;i < 16; i++, offset += 4)
        SHA256_W[i] = view.getUint32(offset, false);
      for (let i = 16;i < 64; i++) {
        const W15 = SHA256_W[i - 15];
        const W2 = SHA256_W[i - 2];
        const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
        const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
        SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
      }
      let { A, B, C, D: D2, E, F, G, H } = this;
      for (let i = 0;i < 64; i++) {
        const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
        const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
        const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
        const T2 = sigma0 + Maj(A, B, C) | 0;
        H = G;
        G = F;
        F = E;
        E = D2 + T1 | 0;
        D2 = C;
        C = B;
        B = A;
        A = T1 + T2 | 0;
      }
      A = A + this.A | 0;
      B = B + this.B | 0;
      C = C + this.C | 0;
      D2 = D2 + this.D | 0;
      E = E + this.E | 0;
      F = F + this.F | 0;
      G = G + this.G | 0;
      H = H + this.H | 0;
      this.set(A, B, C, D2, E, F, G, H);
    }
    roundClean() {
      clean(SHA256_W);
    }
    destroy() {
      this.set(0, 0, 0, 0, 0, 0, 0, 0);
      clean(this.buffer);
    }
  };
  K512 = /* @__PURE__ */ (() => split([
    "0x428a2f98d728ae22",
    "0x7137449123ef65cd",
    "0xb5c0fbcfec4d3b2f",
    "0xe9b5dba58189dbbc",
    "0x3956c25bf348b538",
    "0x59f111f1b605d019",
    "0x923f82a4af194f9b",
    "0xab1c5ed5da6d8118",
    "0xd807aa98a3030242",
    "0x12835b0145706fbe",
    "0x243185be4ee4b28c",
    "0x550c7dc3d5ffb4e2",
    "0x72be5d74f27b896f",
    "0x80deb1fe3b1696b1",
    "0x9bdc06a725c71235",
    "0xc19bf174cf692694",
    "0xe49b69c19ef14ad2",
    "0xefbe4786384f25e3",
    "0x0fc19dc68b8cd5b5",
    "0x240ca1cc77ac9c65",
    "0x2de92c6f592b0275",
    "0x4a7484aa6ea6e483",
    "0x5cb0a9dcbd41fbd4",
    "0x76f988da831153b5",
    "0x983e5152ee66dfab",
    "0xa831c66d2db43210",
    "0xb00327c898fb213f",
    "0xbf597fc7beef0ee4",
    "0xc6e00bf33da88fc2",
    "0xd5a79147930aa725",
    "0x06ca6351e003826f",
    "0x142929670a0e6e70",
    "0x27b70a8546d22ffc",
    "0x2e1b21385c26c926",
    "0x4d2c6dfc5ac42aed",
    "0x53380d139d95b3df",
    "0x650a73548baf63de",
    "0x766a0abb3c77b2a8",
    "0x81c2c92e47edaee6",
    "0x92722c851482353b",
    "0xa2bfe8a14cf10364",
    "0xa81a664bbc423001",
    "0xc24b8b70d0f89791",
    "0xc76c51a30654be30",
    "0xd192e819d6ef5218",
    "0xd69906245565a910",
    "0xf40e35855771202a",
    "0x106aa07032bbd1b8",
    "0x19a4c116b8d2d0c8",
    "0x1e376c085141ab53",
    "0x2748774cdf8eeb99",
    "0x34b0bcb5e19b48a8",
    "0x391c0cb3c5c95a63",
    "0x4ed8aa4ae3418acb",
    "0x5b9cca4f7763e373",
    "0x682e6ff3d6b2b8a3",
    "0x748f82ee5defb2fc",
    "0x78a5636f43172f60",
    "0x84c87814a1f0ab72",
    "0x8cc702081a6439ec",
    "0x90befffa23631e28",
    "0xa4506cebde82bde9",
    "0xbef9a3f7b2c67915",
    "0xc67178f2e372532b",
    "0xca273eceea26619c",
    "0xd186b8c721c0c207",
    "0xeada7dd6cde0eb1e",
    "0xf57d4f7fee6ed178",
    "0x06f067aa72176fba",
    "0x0a637dc5a2c898a6",
    "0x113f9804bef90dae",
    "0x1b710b35131c471b",
    "0x28db77f523047d84",
    "0x32caab7b40c72493",
    "0x3c9ebe0a15c9bebc",
    "0x431d67c49c100d4c",
    "0x4cc5d4becb3e42b6",
    "0x597f299cfc657e2a",
    "0x5fcb6fab3ad6faec",
    "0x6c44198c4a475817"
  ].map((n) => BigInt(n))))();
  SHA512_Kh = /* @__PURE__ */ (() => K512[0])();
  SHA512_Kl = /* @__PURE__ */ (() => K512[1])();
  SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
  SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
  SHA512 = class SHA512 extends HashMD {
    constructor(outputLen = 64) {
      super(128, outputLen, 16, false);
      this.Ah = SHA512_IV[0] | 0;
      this.Al = SHA512_IV[1] | 0;
      this.Bh = SHA512_IV[2] | 0;
      this.Bl = SHA512_IV[3] | 0;
      this.Ch = SHA512_IV[4] | 0;
      this.Cl = SHA512_IV[5] | 0;
      this.Dh = SHA512_IV[6] | 0;
      this.Dl = SHA512_IV[7] | 0;
      this.Eh = SHA512_IV[8] | 0;
      this.El = SHA512_IV[9] | 0;
      this.Fh = SHA512_IV[10] | 0;
      this.Fl = SHA512_IV[11] | 0;
      this.Gh = SHA512_IV[12] | 0;
      this.Gl = SHA512_IV[13] | 0;
      this.Hh = SHA512_IV[14] | 0;
      this.Hl = SHA512_IV[15] | 0;
    }
    get() {
      const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
      return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
    }
    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
      this.Ah = Ah | 0;
      this.Al = Al | 0;
      this.Bh = Bh | 0;
      this.Bl = Bl | 0;
      this.Ch = Ch | 0;
      this.Cl = Cl | 0;
      this.Dh = Dh | 0;
      this.Dl = Dl | 0;
      this.Eh = Eh | 0;
      this.El = El | 0;
      this.Fh = Fh | 0;
      this.Fl = Fl | 0;
      this.Gh = Gh | 0;
      this.Gl = Gl | 0;
      this.Hh = Hh | 0;
      this.Hl = Hl | 0;
    }
    process(view, offset) {
      for (let i = 0;i < 16; i++, offset += 4) {
        SHA512_W_H[i] = view.getUint32(offset);
        SHA512_W_L[i] = view.getUint32(offset += 4);
      }
      for (let i = 16;i < 80; i++) {
        const W15h = SHA512_W_H[i - 15] | 0;
        const W15l = SHA512_W_L[i - 15] | 0;
        const s0h = rotrSH(W15h, W15l, 1) ^ rotrSH(W15h, W15l, 8) ^ shrSH(W15h, W15l, 7);
        const s0l = rotrSL(W15h, W15l, 1) ^ rotrSL(W15h, W15l, 8) ^ shrSL(W15h, W15l, 7);
        const W2h = SHA512_W_H[i - 2] | 0;
        const W2l = SHA512_W_L[i - 2] | 0;
        const s1h = rotrSH(W2h, W2l, 19) ^ rotrBH(W2h, W2l, 61) ^ shrSH(W2h, W2l, 6);
        const s1l = rotrSL(W2h, W2l, 19) ^ rotrBL(W2h, W2l, 61) ^ shrSL(W2h, W2l, 6);
        const SUMl = add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
        const SUMh = add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
        SHA512_W_H[i] = SUMh | 0;
        SHA512_W_L[i] = SUMl | 0;
      }
      let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
      for (let i = 0;i < 80; i++) {
        const sigma1h = rotrSH(Eh, El, 14) ^ rotrSH(Eh, El, 18) ^ rotrBH(Eh, El, 41);
        const sigma1l = rotrSL(Eh, El, 14) ^ rotrSL(Eh, El, 18) ^ rotrBL(Eh, El, 41);
        const CHIh = Eh & Fh ^ ~Eh & Gh;
        const CHIl = El & Fl ^ ~El & Gl;
        const T1ll = add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
        const T1h = add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
        const T1l = T1ll | 0;
        const sigma0h = rotrSH(Ah, Al, 28) ^ rotrBH(Ah, Al, 34) ^ rotrBH(Ah, Al, 39);
        const sigma0l = rotrSL(Ah, Al, 28) ^ rotrBL(Ah, Al, 34) ^ rotrBL(Ah, Al, 39);
        const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
        const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
        Hh = Gh | 0;
        Hl = Gl | 0;
        Gh = Fh | 0;
        Gl = Fl | 0;
        Fh = Eh | 0;
        Fl = El | 0;
        ({ h: Eh, l: El } = add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
        Dh = Ch | 0;
        Dl = Cl | 0;
        Ch = Bh | 0;
        Cl = Bl | 0;
        Bh = Ah | 0;
        Bl = Al | 0;
        const All = add3L(T1l, sigma0l, MAJl);
        Ah = add3H(All, T1h, sigma0h, MAJh);
        Al = All | 0;
      }
      ({ h: Ah, l: Al } = add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
      ({ h: Bh, l: Bl } = add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
      ({ h: Ch, l: Cl } = add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
      ({ h: Dh, l: Dl } = add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
      ({ h: Eh, l: El } = add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
      ({ h: Fh, l: Fl } = add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
      ({ h: Gh, l: Gl } = add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
      ({ h: Hh, l: Hl } = add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
      this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
    }
    roundClean() {
      clean(SHA512_W_H, SHA512_W_L);
    }
    destroy() {
      clean(this.buffer);
      this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
  };
  sha256 = /* @__PURE__ */ createHasher(() => new SHA256);
  sha512 = /* @__PURE__ */ createHasher(() => new SHA512);
});

// ../node_modules/.bun/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/sha256.js
var sha2562;
var init_sha256 = __esm(() => {
  init_sha2();
  sha2562 = sha256;
});

// ../packages/sdk-typescript/dist/chunk-SFTSZ3LC.js
function getCreateAgentAuthorizationDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(CREATE_AGENT_AUTHORIZATION_DISCRIMINATOR);
}
function getCreateAgentAuthorizationInstructionDataEncoder() {
  return transformEncoder(getStructEncoder([
    ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
    ["authorizedSource", getAddressEncoder()],
    ["indexLimit", getU64Encoder()],
    ["expiresAt", getI64Encoder()],
    ["network", getU8Encoder()],
    ["signature", fixEncoderSize(getBytesEncoder(), 64)],
    [
      "nonce",
      getOptionEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ]
  ]), (value) => ({
    ...value,
    discriminator: CREATE_AGENT_AUTHORIZATION_DISCRIMINATOR
  }));
}
function getCreateAgentAuthorizationInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    ["authorizedSource", getAddressDecoder()],
    ["indexLimit", getU64Decoder()],
    ["expiresAt", getI64Decoder()],
    ["network", getU8Decoder()],
    ["signature", fixDecoderSize(getBytesDecoder(), 64)],
    [
      "nonce",
      getOptionDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ]
  ]);
}
function getCreateAgentAuthorizationInstructionDataCodec() {
  return combineCodec(getCreateAgentAuthorizationInstructionDataEncoder(), getCreateAgentAuthorizationInstructionDataDecoder());
}
async function getCreateAgentAuthorizationInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    agent: { value: input.agent ?? null, isWritable: false },
    authorization: { value: input.authorization ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.authorization.value) {
    accounts2.authorization.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([97, 103, 101, 110, 116, 95, 97, 117, 116, 104])),
        getAddressEncoder().encode(expectAddress(accounts2.agent.value)),
        getAddressEncoder().encode(expectSome(args.authorizedSource)),
        getOptionEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())).encode(expectSome(args.nonce))
      ]
    });
  }
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.agent),
      getAccountMeta(accounts2.authorization),
      getAccountMeta(accounts2.authority),
      getAccountMeta(accounts2.systemProgram)
    ],
    data: getCreateAgentAuthorizationInstructionDataEncoder().encode(args),
    programAddress
  });
}
function getCreateAgentAuthorizationInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    agent: { value: input.agent ?? null, isWritable: false },
    authorization: { value: input.authorization ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.agent),
      getAccountMeta(accounts2.authorization),
      getAccountMeta(accounts2.authority),
      getAccountMeta(accounts2.systemProgram)
    ],
    data: getCreateAgentAuthorizationInstructionDataEncoder().encode(args),
    programAddress
  });
}
function parseCreateAgentAuthorizationInstruction(instruction) {
  if (instruction.accounts.length < 4) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      agent: getNextAccount(),
      authorization: getNextAccount(),
      authority: getNextAccount(),
      systemProgram: getNextAccount()
    },
    data: getCreateAgentAuthorizationInstructionDataDecoder().decode(instruction.data)
  };
}
var CREATE_AGENT_AUTHORIZATION_DISCRIMINATOR;
var init_chunk_SFTSZ3LC = __esm(() => {
  init_chunk_AL3HQN73();
  init_index_node35();
  CREATE_AGENT_AUTHORIZATION_DISCRIMINATOR = new Uint8Array([
    48,
    219,
    232,
    202,
    151,
    97,
    230,
    20
  ]);
});

// ../packages/sdk-typescript/dist/chunk-JV2SWONF.js
function getRevokeAuthorizationDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(REVOKE_AUTHORIZATION_DISCRIMINATOR);
}
function getRevokeAuthorizationInstructionDataEncoder() {
  return transformEncoder(getStructEncoder([
    ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
    [
      "nonce",
      getOptionEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ]
  ]), (value) => ({
    ...value,
    discriminator: REVOKE_AUTHORIZATION_DISCRIMINATOR
  }));
}
function getRevokeAuthorizationInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    [
      "nonce",
      getOptionDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ]
  ]);
}
function getRevokeAuthorizationInstructionDataCodec() {
  return combineCodec(getRevokeAuthorizationInstructionDataEncoder(), getRevokeAuthorizationInstructionDataDecoder());
}
function getRevokeAuthorizationInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    agent: { value: input.agent ?? null, isWritable: false },
    authorization: { value: input.authorization ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.agent),
      getAccountMeta(accounts2.authorization),
      getAccountMeta(accounts2.authority)
    ],
    data: getRevokeAuthorizationInstructionDataEncoder().encode(args),
    programAddress
  });
}
function parseRevokeAuthorizationInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      agent: getNextAccount(),
      authorization: getNextAccount(),
      authority: getNextAccount()
    },
    data: getRevokeAuthorizationInstructionDataDecoder().decode(instruction.data)
  };
}
var REVOKE_AUTHORIZATION_DISCRIMINATOR;
var init_chunk_JV2SWONF = __esm(() => {
  init_chunk_AL3HQN73();
  init_index_node35();
  REVOKE_AUTHORIZATION_DISCRIMINATOR = new Uint8Array([
    222,
    179,
    207,
    59,
    191,
    78,
    24,
    248
  ]);
});

// ../packages/sdk-typescript/dist/chunk-KB6CKIUK.js
function getUpdateReputationWithAuthDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(UPDATE_REPUTATION_WITH_AUTH_DISCRIMINATOR);
}
function getUpdateReputationWithAuthInstructionDataEncoder() {
  return transformEncoder(getStructEncoder([
    ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
    ["reputationChange", getI64Encoder()],
    [
      "transactionSignature",
      addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())
    ],
    [
      "metadata",
      getOptionEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ],
    [
      "nonce",
      getOptionEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()))
    ]
  ]), (value) => ({
    ...value,
    discriminator: UPDATE_REPUTATION_WITH_AUTH_DISCRIMINATOR
  }));
}
function getUpdateReputationWithAuthInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    ["reputationChange", getI64Decoder()],
    [
      "transactionSignature",
      addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())
    ],
    [
      "metadata",
      getOptionDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ],
    [
      "nonce",
      getOptionDecoder(addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()))
    ]
  ]);
}
function getUpdateReputationWithAuthInstructionDataCodec() {
  return combineCodec(getUpdateReputationWithAuthInstructionDataEncoder(), getUpdateReputationWithAuthInstructionDataDecoder());
}
async function getUpdateReputationWithAuthInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    agent: { value: input.agent ?? null, isWritable: false },
    reputationMetrics: {
      value: input.reputationMetrics ?? null,
      isWritable: true
    },
    authorization: { value: input.authorization ?? null, isWritable: true },
    usageRecord: { value: input.usageRecord ?? null, isWritable: true },
    authorizedSource: {
      value: input.authorizedSource ?? null,
      isWritable: true
    },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    clock: { value: input.clock ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.reputationMetrics.value) {
    accounts2.reputationMetrics.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([
          114,
          101,
          112,
          117,
          116,
          97,
          116,
          105,
          111,
          110,
          95,
          109,
          101,
          116,
          114,
          105,
          99,
          115
        ])),
        getAddressEncoder().encode(expectAddress(accounts2.agent.value))
      ]
    });
  }
  if (!accounts2.authorization.value) {
    accounts2.authorization.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([97, 103, 101, 110, 116, 95, 97, 117, 116, 104])),
        getAddressEncoder().encode(expectAddress(accounts2.agent.value)),
        getAddressEncoder().encode(expectAddress(accounts2.authorizedSource.value)),
        getOptionEncoder(addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())).encode(expectSome(args.nonce))
      ]
    });
  }
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  if (!accounts2.clock.value) {
    accounts2.clock.value = "SysvarC1ock11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.agent),
      getAccountMeta(accounts2.reputationMetrics),
      getAccountMeta(accounts2.authorization),
      getAccountMeta(accounts2.usageRecord),
      getAccountMeta(accounts2.authorizedSource),
      getAccountMeta(accounts2.systemProgram),
      getAccountMeta(accounts2.clock)
    ],
    data: getUpdateReputationWithAuthInstructionDataEncoder().encode(args),
    programAddress
  });
}
function getUpdateReputationWithAuthInstruction(input, config) {
  const programAddress = config?.programAddress ?? GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS;
  const originalAccounts = {
    agent: { value: input.agent ?? null, isWritable: false },
    reputationMetrics: {
      value: input.reputationMetrics ?? null,
      isWritable: true
    },
    authorization: { value: input.authorization ?? null, isWritable: true },
    usageRecord: { value: input.usageRecord ?? null, isWritable: true },
    authorizedSource: {
      value: input.authorizedSource ?? null,
      isWritable: true
    },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    clock: { value: input.clock ?? null, isWritable: false }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  if (!accounts2.systemProgram.value) {
    accounts2.systemProgram.value = "11111111111111111111111111111111";
  }
  if (!accounts2.clock.value) {
    accounts2.clock.value = "SysvarC1ock11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.agent),
      getAccountMeta(accounts2.reputationMetrics),
      getAccountMeta(accounts2.authorization),
      getAccountMeta(accounts2.usageRecord),
      getAccountMeta(accounts2.authorizedSource),
      getAccountMeta(accounts2.systemProgram),
      getAccountMeta(accounts2.clock)
    ],
    data: getUpdateReputationWithAuthInstructionDataEncoder().encode(args),
    programAddress
  });
}
function parseUpdateReputationWithAuthInstruction(instruction) {
  if (instruction.accounts.length < 7) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      agent: getNextAccount(),
      reputationMetrics: getNextAccount(),
      authorization: getNextAccount(),
      usageRecord: getNextAccount(),
      authorizedSource: getNextAccount(),
      systemProgram: getNextAccount(),
      clock: getNextAccount()
    },
    data: getUpdateReputationWithAuthInstructionDataDecoder().decode(instruction.data)
  };
}
var UPDATE_REPUTATION_WITH_AUTH_DISCRIMINATOR;
var init_chunk_KB6CKIUK = __esm(() => {
  init_chunk_AL3HQN73();
  init_index_node35();
  UPDATE_REPUTATION_WITH_AUTH_DISCRIMINATOR = new Uint8Array([
    61,
    236,
    225,
    167,
    134,
    43,
    53,
    93
  ]);
});

// ../packages/sdk-typescript/dist/generated-EG5USUFG.js
var exports_generated_EG5USUFG = {};
__export(exports_generated_EG5USUFG, {
  parseVerifyAuthorizationInstruction: () => parseVerifyAuthorizationInstruction,
  parseVerifyAgentInstruction: () => parseVerifyAgentInstruction,
  parseUpdateSourceReputationInstruction: () => parseUpdateSourceReputationInstruction,
  parseUpdateReputationWithAuthInstruction: () => parseUpdateReputationWithAuthInstruction,
  parseUpdateReputationTagsInstruction: () => parseUpdateReputationTagsInstruction,
  parseUpdateProtocolConfigInstruction: () => parseUpdateProtocolConfigInstruction,
  parseUpdateDidDocumentInstruction: () => parseUpdateDidDocumentInstruction,
  parseUpdateCrosschainStatusInstruction: () => parseUpdateCrosschainStatusInstruction,
  parseUpdateAgentServiceInstruction: () => parseUpdateAgentServiceInstruction,
  parseUpdateAgentReputationInstruction: () => parseUpdateAgentReputationInstruction,
  parseUpdateAgentInstruction: () => parseUpdateAgentInstruction,
  parseUnstakeGhostInstruction: () => parseUnstakeGhostInstruction,
  parseSubmitServiceRatingInstruction: () => parseSubmitServiceRatingInstruction,
  parseSubmitDeliveryInstruction: () => parseSubmitDeliveryInstruction,
  parseStakeGhostInstruction: () => parseStakeGhostInstruction,
  parseSlashStakeInstruction: () => parseSlashStakeInstruction,
  parseRevokeCredentialInstruction: () => parseRevokeCredentialInstruction,
  parseRevokeAuthorizationInstruction: () => parseRevokeAuthorizationInstruction,
  parseResolveDidDocumentInstruction: () => parseResolveDidDocumentInstruction,
  parseResetReentrancyGuardInstruction: () => parseResetReentrancyGuardInstruction,
  parseRegisterAgentInstruction: () => parseRegisterAgentInstruction,
  parseRegisterAgentCompressedInstruction: () => parseRegisterAgentCompressedInstruction,
  parseRecordPayaiPaymentInstruction: () => parseRecordPayaiPaymentInstruction,
  parseManageAgentStatusInstruction: () => parseManageAgentStatusInstruction,
  parseIssueCredentialInstruction: () => parseIssueCredentialInstruction,
  parseInitializeStakingConfigInstruction: () => parseInitializeStakingConfigInstruction,
  parseInitializeReputationMetricsInstruction: () => parseInitializeReputationMetricsInstruction,
  parseInitializeRbacConfigInstruction: () => parseInitializeRbacConfigInstruction,
  parseInitializeProtocolConfigInstruction: () => parseInitializeProtocolConfigInstruction,
  parseInitializeGovernanceProposalInstruction: () => parseInitializeGovernanceProposalInstruction,
  parseInitializeAuditTrailInstruction: () => parseInitializeAuditTrailInstruction,
  parseInitReentrancyGuardInstruction: () => parseInitReentrancyGuardInstruction,
  parseGenerateComplianceReportInstruction: () => parseGenerateComplianceReportInstruction,
  parseFileDisputeInstruction: () => parseFileDisputeInstruction,
  parseEnableProtocolFeesInstruction: () => parseEnableProtocolFeesInstruction,
  parseDeactivateDidDocumentInstruction: () => parseDeactivateDidDocumentInstruction,
  parseDeactivateCredentialTypeInstruction: () => parseDeactivateCredentialTypeInstruction,
  parseDeactivateCredentialTemplateInstruction: () => parseDeactivateCredentialTemplateInstruction,
  parseDeactivateAgentInstruction: () => parseDeactivateAgentInstruction,
  parseCreateMultisigInstruction: () => parseCreateMultisigInstruction,
  parseCreateEscrowInstruction: () => parseCreateEscrowInstruction,
  parseCreateDidDocumentInstruction: () => parseCreateDidDocumentInstruction,
  parseCreateCredentialTypeInstruction: () => parseCreateCredentialTypeInstruction,
  parseCreateCredentialTemplateInstruction: () => parseCreateCredentialTemplateInstruction,
  parseCreateAgentAuthorizationInstruction: () => parseCreateAgentAuthorizationInstruction,
  parseArbitrateDisputeInstruction: () => parseArbitrateDisputeInstruction,
  parseApproveDeliveryInstruction: () => parseApproveDeliveryInstruction,
  parseActivateAgentInstruction: () => parseActivateAgentInstruction,
  isGhostspeakMarketplaceError: () => isGhostspeakMarketplaceError,
  isDelegationScope: () => isDelegationScope,
  isArbitratorDecision: () => isArbitratorDecision,
  identifyGhostspeakMarketplaceInstruction: () => identifyGhostspeakMarketplaceInstruction,
  identifyGhostspeakMarketplaceAccount: () => identifyGhostspeakMarketplaceAccount,
  getVotingResultsEncoder: () => getVotingResultsEncoder,
  getVotingResultsDecoder: () => getVotingResultsDecoder,
  getVotingResultsCodec: () => getVotingResultsCodec,
  getVoteEncoder: () => getVoteEncoder,
  getVoteDecoder: () => getVoteDecoder,
  getVoteCodec: () => getVoteCodec,
  getVoteChoiceEncoder: () => getVoteChoiceEncoder,
  getVoteChoiceDecoder: () => getVoteChoiceDecoder,
  getVoteChoiceCodec: () => getVoteChoiceCodec,
  getViolationSeverityEncoder: () => getViolationSeverityEncoder,
  getViolationSeverityDecoder: () => getViolationSeverityDecoder,
  getViolationSeverityCodec: () => getViolationSeverityCodec,
  getVerifyAuthorizationInstructionDataEncoder: () => getVerifyAuthorizationInstructionDataEncoder,
  getVerifyAuthorizationInstructionDataDecoder: () => getVerifyAuthorizationInstructionDataDecoder,
  getVerifyAuthorizationInstructionDataCodec: () => getVerifyAuthorizationInstructionDataCodec,
  getVerifyAuthorizationInstruction: () => getVerifyAuthorizationInstruction,
  getVerifyAuthorizationDiscriminatorBytes: () => getVerifyAuthorizationDiscriminatorBytes,
  getVerifyAgentInstructionDataEncoder: () => getVerifyAgentInstructionDataEncoder,
  getVerifyAgentInstructionDataDecoder: () => getVerifyAgentInstructionDataDecoder,
  getVerifyAgentInstructionDataCodec: () => getVerifyAgentInstructionDataCodec,
  getVerifyAgentInstructionAsync: () => getVerifyAgentInstructionAsync,
  getVerifyAgentInstruction: () => getVerifyAgentInstruction,
  getVerifyAgentDiscriminatorBytes: () => getVerifyAgentDiscriminatorBytes,
  getVerificationRelationshipEncoder: () => getVerificationRelationshipEncoder,
  getVerificationRelationshipDecoder: () => getVerificationRelationshipDecoder,
  getVerificationRelationshipCodec: () => getVerificationRelationshipCodec,
  getVerificationMethodTypeEncoder: () => getVerificationMethodTypeEncoder,
  getVerificationMethodTypeDecoder: () => getVerificationMethodTypeDecoder,
  getVerificationMethodTypeCodec: () => getVerificationMethodTypeCodec,
  getVerificationMethodEncoder: () => getVerificationMethodEncoder,
  getVerificationMethodDecoder: () => getVerificationMethodDecoder,
  getVerificationMethodCodec: () => getVerificationMethodCodec,
  getValueTypeEncoder: () => getValueTypeEncoder,
  getValueTypeDecoder: () => getValueTypeDecoder,
  getValueTypeCodec: () => getValueTypeCodec,
  getUserRegistrySize: () => getUserRegistrySize,
  getUserRegistryEncoder: () => getUserRegistryEncoder,
  getUserRegistryDiscriminatorBytes: () => getUserRegistryDiscriminatorBytes,
  getUserRegistryDecoder: () => getUserRegistryDecoder,
  getUserRegistryCodec: () => getUserRegistryCodec,
  getUpdateSourceReputationInstructionDataEncoder: () => getUpdateSourceReputationInstructionDataEncoder,
  getUpdateSourceReputationInstructionDataDecoder: () => getUpdateSourceReputationInstructionDataDecoder,
  getUpdateSourceReputationInstructionDataCodec: () => getUpdateSourceReputationInstructionDataCodec,
  getUpdateSourceReputationInstructionAsync: () => getUpdateSourceReputationInstructionAsync,
  getUpdateSourceReputationInstruction: () => getUpdateSourceReputationInstruction,
  getUpdateSourceReputationDiscriminatorBytes: () => getUpdateSourceReputationDiscriminatorBytes,
  getUpdateReputationWithAuthInstructionDataEncoder: () => getUpdateReputationWithAuthInstructionDataEncoder,
  getUpdateReputationWithAuthInstructionDataDecoder: () => getUpdateReputationWithAuthInstructionDataDecoder,
  getUpdateReputationWithAuthInstructionDataCodec: () => getUpdateReputationWithAuthInstructionDataCodec,
  getUpdateReputationWithAuthInstructionAsync: () => getUpdateReputationWithAuthInstructionAsync,
  getUpdateReputationWithAuthInstruction: () => getUpdateReputationWithAuthInstruction,
  getUpdateReputationWithAuthDiscriminatorBytes: () => getUpdateReputationWithAuthDiscriminatorBytes,
  getUpdateReputationTagsInstructionDataEncoder: () => getUpdateReputationTagsInstructionDataEncoder,
  getUpdateReputationTagsInstructionDataDecoder: () => getUpdateReputationTagsInstructionDataDecoder,
  getUpdateReputationTagsInstructionDataCodec: () => getUpdateReputationTagsInstructionDataCodec,
  getUpdateReputationTagsInstructionAsync: () => getUpdateReputationTagsInstructionAsync,
  getUpdateReputationTagsInstruction: () => getUpdateReputationTagsInstruction,
  getUpdateReputationTagsDiscriminatorBytes: () => getUpdateReputationTagsDiscriminatorBytes,
  getUpdateProtocolConfigInstructionDataEncoder: () => getUpdateProtocolConfigInstructionDataEncoder,
  getUpdateProtocolConfigInstructionDataDecoder: () => getUpdateProtocolConfigInstructionDataDecoder,
  getUpdateProtocolConfigInstructionDataCodec: () => getUpdateProtocolConfigInstructionDataCodec,
  getUpdateProtocolConfigInstructionAsync: () => getUpdateProtocolConfigInstructionAsync,
  getUpdateProtocolConfigInstruction: () => getUpdateProtocolConfigInstruction,
  getUpdateProtocolConfigDiscriminatorBytes: () => getUpdateProtocolConfigDiscriminatorBytes,
  getUpdateDidDocumentInstructionDataEncoder: () => getUpdateDidDocumentInstructionDataEncoder,
  getUpdateDidDocumentInstructionDataDecoder: () => getUpdateDidDocumentInstructionDataDecoder,
  getUpdateDidDocumentInstructionDataCodec: () => getUpdateDidDocumentInstructionDataCodec,
  getUpdateDidDocumentInstructionAsync: () => getUpdateDidDocumentInstructionAsync,
  getUpdateDidDocumentInstruction: () => getUpdateDidDocumentInstruction,
  getUpdateDidDocumentDiscriminatorBytes: () => getUpdateDidDocumentDiscriminatorBytes,
  getUpdateCrosschainStatusInstructionDataEncoder: () => getUpdateCrosschainStatusInstructionDataEncoder,
  getUpdateCrosschainStatusInstructionDataDecoder: () => getUpdateCrosschainStatusInstructionDataDecoder,
  getUpdateCrosschainStatusInstructionDataCodec: () => getUpdateCrosschainStatusInstructionDataCodec,
  getUpdateCrosschainStatusInstruction: () => getUpdateCrosschainStatusInstruction,
  getUpdateCrosschainStatusDiscriminatorBytes: () => getUpdateCrosschainStatusDiscriminatorBytes,
  getUpdateAgentServiceInstructionDataEncoder: () => getUpdateAgentServiceInstructionDataEncoder,
  getUpdateAgentServiceInstructionDataDecoder: () => getUpdateAgentServiceInstructionDataDecoder,
  getUpdateAgentServiceInstructionDataCodec: () => getUpdateAgentServiceInstructionDataCodec,
  getUpdateAgentServiceInstructionAsync: () => getUpdateAgentServiceInstructionAsync,
  getUpdateAgentServiceInstruction: () => getUpdateAgentServiceInstruction,
  getUpdateAgentServiceDiscriminatorBytes: () => getUpdateAgentServiceDiscriminatorBytes,
  getUpdateAgentReputationInstructionDataEncoder: () => getUpdateAgentReputationInstructionDataEncoder,
  getUpdateAgentReputationInstructionDataDecoder: () => getUpdateAgentReputationInstructionDataDecoder,
  getUpdateAgentReputationInstructionDataCodec: () => getUpdateAgentReputationInstructionDataCodec,
  getUpdateAgentReputationInstructionAsync: () => getUpdateAgentReputationInstructionAsync,
  getUpdateAgentReputationInstruction: () => getUpdateAgentReputationInstruction,
  getUpdateAgentReputationDiscriminatorBytes: () => getUpdateAgentReputationDiscriminatorBytes,
  getUpdateAgentInstructionDataEncoder: () => getUpdateAgentInstructionDataEncoder,
  getUpdateAgentInstructionDataDecoder: () => getUpdateAgentInstructionDataDecoder,
  getUpdateAgentInstructionDataCodec: () => getUpdateAgentInstructionDataCodec,
  getUpdateAgentInstructionAsync: () => getUpdateAgentInstructionAsync,
  getUpdateAgentInstruction: () => getUpdateAgentInstruction,
  getUpdateAgentDiscriminatorBytes: () => getUpdateAgentDiscriminatorBytes,
  getUnstakeGhostInstructionDataEncoder: () => getUnstakeGhostInstructionDataEncoder,
  getUnstakeGhostInstructionDataDecoder: () => getUnstakeGhostInstructionDataDecoder,
  getUnstakeGhostInstructionDataCodec: () => getUnstakeGhostInstructionDataCodec,
  getUnstakeGhostInstructionAsync: () => getUnstakeGhostInstructionAsync,
  getUnstakeGhostInstruction: () => getUnstakeGhostInstruction,
  getUnstakeGhostDiscriminatorBytes: () => getUnstakeGhostDiscriminatorBytes,
  getUnlockMethodEncoder: () => getUnlockMethodEncoder,
  getUnlockMethodDecoder: () => getUnlockMethodDecoder,
  getUnlockMethodCodec: () => getUnlockMethodCodec,
  getTrendDirectionEncoder: () => getTrendDirectionEncoder,
  getTrendDirectionDecoder: () => getTrendDirectionDecoder,
  getTrendDirectionCodec: () => getTrendDirectionCodec,
  getTransactionTypeEncoder: () => getTransactionTypeEncoder,
  getTransactionTypeDecoder: () => getTransactionTypeDecoder,
  getTransactionTypeCodec: () => getTransactionTypeCodec,
  getTransactionStatusEncoder: () => getTransactionStatusEncoder,
  getTransactionStatusDecoder: () => getTransactionStatusDecoder,
  getTransactionStatusCodec: () => getTransactionStatusCodec,
  getTransactionPriorityEncoder: () => getTransactionPriorityEncoder,
  getTransactionPriorityDecoder: () => getTransactionPriorityDecoder,
  getTransactionPriorityCodec: () => getTransactionPriorityCodec,
  getTimeLockTypeEncoder: () => getTimeLockTypeEncoder,
  getTimeLockTypeDecoder: () => getTimeLockTypeDecoder,
  getTimeLockTypeCodec: () => getTimeLockTypeCodec,
  getTimeLockEncoder: () => getTimeLockEncoder,
  getTimeLockDecoder: () => getTimeLockDecoder,
  getTimeLockCodec: () => getTimeLockCodec,
  getTimeConstraintsEncoder: () => getTimeConstraintsEncoder,
  getTimeConstraintsDecoder: () => getTimeConstraintsDecoder,
  getTimeConstraintsCodec: () => getTimeConstraintsCodec,
  getTierUpdatedEventEncoder: () => getTierUpdatedEventEncoder,
  getTierUpdatedEventDecoder: () => getTierUpdatedEventDecoder,
  getTierUpdatedEventCodec: () => getTierUpdatedEventCodec,
  getTagScoreEncoder: () => getTagScoreEncoder,
  getTagScoreDecoder: () => getTagScoreDecoder,
  getTagScoreCodec: () => getTagScoreCodec,
  getTagDecayAppliedEventEncoder: () => getTagDecayAppliedEventEncoder,
  getTagDecayAppliedEventDecoder: () => getTagDecayAppliedEventDecoder,
  getTagDecayAppliedEventCodec: () => getTagDecayAppliedEventCodec,
  getSubmitServiceRatingInstructionDataEncoder: () => getSubmitServiceRatingInstructionDataEncoder,
  getSubmitServiceRatingInstructionDataDecoder: () => getSubmitServiceRatingInstructionDataDecoder,
  getSubmitServiceRatingInstructionDataCodec: () => getSubmitServiceRatingInstructionDataCodec,
  getSubmitServiceRatingInstructionAsync: () => getSubmitServiceRatingInstructionAsync,
  getSubmitServiceRatingInstruction: () => getSubmitServiceRatingInstruction,
  getSubmitServiceRatingDiscriminatorBytes: () => getSubmitServiceRatingDiscriminatorBytes,
  getSubmitDeliveryInstructionDataEncoder: () => getSubmitDeliveryInstructionDataEncoder,
  getSubmitDeliveryInstructionDataDecoder: () => getSubmitDeliveryInstructionDataDecoder,
  getSubmitDeliveryInstructionDataCodec: () => getSubmitDeliveryInstructionDataCodec,
  getSubmitDeliveryInstruction: () => getSubmitDeliveryInstruction,
  getSubmitDeliveryDiscriminatorBytes: () => getSubmitDeliveryDiscriminatorBytes,
  getSubmissionDetailsEncoder: () => getSubmissionDetailsEncoder,
  getSubmissionDetailsDecoder: () => getSubmissionDetailsDecoder,
  getSubmissionDetailsCodec: () => getSubmissionDetailsCodec,
  getStepUpTriggerEncoder: () => getStepUpTriggerEncoder,
  getStepUpTriggerDecoder: () => getStepUpTriggerDecoder,
  getStepUpTriggerCodec: () => getStepUpTriggerCodec,
  getStakingConfigSize: () => getStakingConfigSize,
  getStakingConfigEncoder: () => getStakingConfigEncoder,
  getStakingConfigDiscriminatorBytes: () => getStakingConfigDiscriminatorBytes,
  getStakingConfigDecoder: () => getStakingConfigDecoder,
  getStakingConfigCodec: () => getStakingConfigCodec,
  getStakingAccountSize: () => getStakingAccountSize,
  getStakingAccountEncoder: () => getStakingAccountEncoder,
  getStakingAccountDiscriminatorBytes: () => getStakingAccountDiscriminatorBytes,
  getStakingAccountDecoder: () => getStakingAccountDecoder,
  getStakingAccountCodec: () => getStakingAccountCodec,
  getStakeGhostInstructionDataEncoder: () => getStakeGhostInstructionDataEncoder,
  getStakeGhostInstructionDataDecoder: () => getStakeGhostInstructionDataDecoder,
  getStakeGhostInstructionDataCodec: () => getStakeGhostInstructionDataCodec,
  getStakeGhostInstructionAsync: () => getStakeGhostInstructionAsync,
  getStakeGhostInstruction: () => getStakeGhostInstruction,
  getStakeGhostDiscriminatorBytes: () => getStakeGhostDiscriminatorBytes,
  getSourceScoreEncoder: () => getSourceScoreEncoder,
  getSourceScoreDecoder: () => getSourceScoreDecoder,
  getSourceScoreCodec: () => getSourceScoreCodec,
  getSourceReputationUpdatedEventEncoder: () => getSourceReputationUpdatedEventEncoder,
  getSourceReputationUpdatedEventDecoder: () => getSourceReputationUpdatedEventDecoder,
  getSourceReputationUpdatedEventCodec: () => getSourceReputationUpdatedEventCodec,
  getSodConstraintTypeEncoder: () => getSodConstraintTypeEncoder,
  getSodConstraintTypeDecoder: () => getSodConstraintTypeDecoder,
  getSodConstraintTypeCodec: () => getSodConstraintTypeCodec,
  getSodConstraintEncoder: () => getSodConstraintEncoder,
  getSodConstraintDecoder: () => getSodConstraintDecoder,
  getSodConstraintCodec: () => getSodConstraintCodec,
  getSlashStakeInstructionDataEncoder: () => getSlashStakeInstructionDataEncoder,
  getSlashStakeInstructionDataDecoder: () => getSlashStakeInstructionDataDecoder,
  getSlashStakeInstructionDataCodec: () => getSlashStakeInstructionDataCodec,
  getSlashStakeInstructionAsync: () => getSlashStakeInstructionAsync,
  getSlashStakeInstruction: () => getSlashStakeInstruction,
  getSlashStakeDiscriminatorBytes: () => getSlashStakeDiscriminatorBytes,
  getSlashReasonEncoder: () => getSlashReasonEncoder,
  getSlashReasonDecoder: () => getSlashReasonDecoder,
  getSlashReasonCodec: () => getSlashReasonCodec,
  getSessionPoliciesEncoder: () => getSessionPoliciesEncoder,
  getSessionPoliciesDecoder: () => getSessionPoliciesDecoder,
  getSessionPoliciesCodec: () => getSessionPoliciesCodec,
  getSessionConstraintsEncoder: () => getSessionConstraintsEncoder,
  getSessionConstraintsDecoder: () => getSessionConstraintsDecoder,
  getSessionConstraintsCodec: () => getSessionConstraintsCodec,
  getServiceEndpointTypeEncoder: () => getServiceEndpointTypeEncoder,
  getServiceEndpointTypeDecoder: () => getServiceEndpointTypeDecoder,
  getServiceEndpointTypeCodec: () => getServiceEndpointTypeCodec,
  getServiceEndpointEncoder: () => getServiceEndpointEncoder,
  getServiceEndpointDecoder: () => getServiceEndpointDecoder,
  getServiceEndpointCodec: () => getServiceEndpointCodec,
  getSecurityPoliciesEncoder: () => getSecurityPoliciesEncoder,
  getSecurityPoliciesDecoder: () => getSecurityPoliciesDecoder,
  getSecurityPoliciesCodec: () => getSecurityPoliciesCodec,
  getSecurityEventTypeEncoder: () => getSecurityEventTypeEncoder,
  getSecurityEventTypeDecoder: () => getSecurityEventTypeDecoder,
  getSecurityEventTypeCodec: () => getSecurityEventTypeCodec,
  getScopeTypeEncoder: () => getScopeTypeEncoder,
  getScopeTypeDecoder: () => getScopeTypeDecoder,
  getScopeTypeCodec: () => getScopeTypeCodec,
  getScopeInheritanceEncoder: () => getScopeInheritanceEncoder,
  getScopeInheritanceDecoder: () => getScopeInheritanceDecoder,
  getScopeInheritanceCodec: () => getScopeInheritanceCodec,
  getScopeBoundariesEncoder: () => getScopeBoundariesEncoder,
  getScopeBoundariesDecoder: () => getScopeBoundariesDecoder,
  getScopeBoundariesCodec: () => getScopeBoundariesCodec,
  getRuleEffectEncoder: () => getRuleEffectEncoder,
  getRuleEffectDecoder: () => getRuleEffectDecoder,
  getRuleEffectCodec: () => getRuleEffectCodec,
  getRuleConditionEncoder: () => getRuleConditionEncoder,
  getRuleConditionDecoder: () => getRuleConditionDecoder,
  getRuleConditionCodec: () => getRuleConditionCodec,
  getRoleTypeEncoder: () => getRoleTypeEncoder,
  getRoleTypeDecoder: () => getRoleTypeDecoder,
  getRoleTypeCodec: () => getRoleTypeCodec,
  getRoleStatusEncoder: () => getRoleStatusEncoder,
  getRoleStatusDecoder: () => getRoleStatusDecoder,
  getRoleStatusCodec: () => getRoleStatusCodec,
  getRoleMetadataEncoder: () => getRoleMetadataEncoder,
  getRoleMetadataDecoder: () => getRoleMetadataDecoder,
  getRoleMetadataCodec: () => getRoleMetadataCodec,
  getRoleEncoder: () => getRoleEncoder,
  getRoleDecoder: () => getRoleDecoder,
  getRoleConstraintsEncoder: () => getRoleConstraintsEncoder,
  getRoleConstraintsDecoder: () => getRoleConstraintsDecoder,
  getRoleConstraintsCodec: () => getRoleConstraintsCodec,
  getRoleCodec: () => getRoleCodec,
  getRiskLevelEncoder: () => getRiskLevelEncoder,
  getRiskLevelDecoder: () => getRiskLevelDecoder,
  getRiskLevelCodec: () => getRiskLevelCodec,
  getRiskIndicatorEncoder: () => getRiskIndicatorEncoder,
  getRiskIndicatorDecoder: () => getRiskIndicatorDecoder,
  getRiskIndicatorCodec: () => getRiskIndicatorCodec,
  getRiskFactorEncoder: () => getRiskFactorEncoder,
  getRiskFactorDecoder: () => getRiskFactorDecoder,
  getRiskFactorCodec: () => getRiskFactorCodec,
  getRiskCategoryEncoder: () => getRiskCategoryEncoder,
  getRiskCategoryDecoder: () => getRiskCategoryDecoder,
  getRiskCategoryCodec: () => getRiskCategoryCodec,
  getRiskAssessmentEncoder: () => getRiskAssessmentEncoder,
  getRiskAssessmentDecoder: () => getRiskAssessmentDecoder,
  getRiskAssessmentCodec: () => getRiskAssessmentCodec,
  getRiskAcceptanceEncoder: () => getRiskAcceptanceEncoder,
  getRiskAcceptanceDecoder: () => getRiskAcceptanceDecoder,
  getRiskAcceptanceCodec: () => getRiskAcceptanceCodec,
  getRevokeCredentialInstructionDataEncoder: () => getRevokeCredentialInstructionDataEncoder,
  getRevokeCredentialInstructionDataDecoder: () => getRevokeCredentialInstructionDataDecoder,
  getRevokeCredentialInstructionDataCodec: () => getRevokeCredentialInstructionDataCodec,
  getRevokeCredentialInstruction: () => getRevokeCredentialInstruction,
  getRevokeCredentialDiscriminatorBytes: () => getRevokeCredentialDiscriminatorBytes,
  getRevokeAuthorizationInstructionDataEncoder: () => getRevokeAuthorizationInstructionDataEncoder,
  getRevokeAuthorizationInstructionDataDecoder: () => getRevokeAuthorizationInstructionDataDecoder,
  getRevokeAuthorizationInstructionDataCodec: () => getRevokeAuthorizationInstructionDataCodec,
  getRevokeAuthorizationInstruction: () => getRevokeAuthorizationInstruction,
  getRevokeAuthorizationDiscriminatorBytes: () => getRevokeAuthorizationDiscriminatorBytes,
  getReviewScheduleEncoder: () => getReviewScheduleEncoder,
  getReviewScheduleDecoder: () => getReviewScheduleDecoder,
  getReviewScheduleCodec: () => getReviewScheduleCodec,
  getResourceConstraintsEncoder: () => getResourceConstraintsEncoder,
  getResourceConstraintsDecoder: () => getResourceConstraintsDecoder,
  getResourceConstraintsCodec: () => getResourceConstraintsCodec,
  getResolveDidDocumentInstructionDataEncoder: () => getResolveDidDocumentInstructionDataEncoder,
  getResolveDidDocumentInstructionDataDecoder: () => getResolveDidDocumentInstructionDataDecoder,
  getResolveDidDocumentInstructionDataCodec: () => getResolveDidDocumentInstructionDataCodec,
  getResolveDidDocumentInstructionAsync: () => getResolveDidDocumentInstructionAsync,
  getResolveDidDocumentInstruction: () => getResolveDidDocumentInstruction,
  getResolveDidDocumentDiscriminatorBytes: () => getResolveDidDocumentDiscriminatorBytes,
  getResetReentrancyGuardInstructionDataEncoder: () => getResetReentrancyGuardInstructionDataEncoder,
  getResetReentrancyGuardInstructionDataDecoder: () => getResetReentrancyGuardInstructionDataDecoder,
  getResetReentrancyGuardInstructionDataCodec: () => getResetReentrancyGuardInstructionDataCodec,
  getResetReentrancyGuardInstructionAsync: () => getResetReentrancyGuardInstructionAsync,
  getResetReentrancyGuardInstruction: () => getResetReentrancyGuardInstruction,
  getResetReentrancyGuardDiscriminatorBytes: () => getResetReentrancyGuardDiscriminatorBytes,
  getReputationTagsUpdatedEventEncoder: () => getReputationTagsUpdatedEventEncoder,
  getReputationTagsUpdatedEventDecoder: () => getReputationTagsUpdatedEventDecoder,
  getReputationTagsUpdatedEventCodec: () => getReputationTagsUpdatedEventCodec,
  getReputationRatingSubmittedEventEncoder: () => getReputationRatingSubmittedEventEncoder,
  getReputationRatingSubmittedEventDecoder: () => getReputationRatingSubmittedEventDecoder,
  getReputationRatingSubmittedEventCodec: () => getReputationRatingSubmittedEventCodec,
  getReputationPaymentRecordedEventEncoder: () => getReputationPaymentRecordedEventEncoder,
  getReputationPaymentRecordedEventDecoder: () => getReputationPaymentRecordedEventDecoder,
  getReputationPaymentRecordedEventCodec: () => getReputationPaymentRecordedEventCodec,
  getReputationMetricsInitializedEventEncoder: () => getReputationMetricsInitializedEventEncoder,
  getReputationMetricsInitializedEventDecoder: () => getReputationMetricsInitializedEventDecoder,
  getReputationMetricsInitializedEventCodec: () => getReputationMetricsInitializedEventCodec,
  getReputationMetricsEncoder: () => getReputationMetricsEncoder,
  getReputationMetricsDiscriminatorBytes: () => getReputationMetricsDiscriminatorBytes,
  getReputationMetricsDecoder: () => getReputationMetricsDecoder,
  getReputationMetricsCodec: () => getReputationMetricsCodec,
  getReportingFrequencyEncoder: () => getReportingFrequencyEncoder,
  getReportingFrequencyDecoder: () => getReportingFrequencyDecoder,
  getReportingFrequencyCodec: () => getReportingFrequencyCodec,
  getReportTypeEncoder: () => getReportTypeEncoder,
  getReportTypeDecoder: () => getReportTypeDecoder,
  getReportTypeCodec: () => getReportTypeCodec,
  getReportSummaryEncoder: () => getReportSummaryEncoder,
  getReportSummaryDecoder: () => getReportSummaryDecoder,
  getReportSummaryCodec: () => getReportSummaryCodec,
  getReportStatusEncoder: () => getReportStatusEncoder,
  getReportStatusDecoder: () => getReportStatusDecoder,
  getReportStatusCodec: () => getReportStatusCodec,
  getReportEntryEncoder: () => getReportEntryEncoder,
  getReportEntryDecoder: () => getReportEntryDecoder,
  getReportEntryCodec: () => getReportEntryCodec,
  getReportDataEncoder: () => getReportDataEncoder,
  getReportDataDecoder: () => getReportDataDecoder,
  getReportDataCodec: () => getReportDataCodec,
  getRegisterAgentInstructionDataEncoder: () => getRegisterAgentInstructionDataEncoder,
  getRegisterAgentInstructionDataDecoder: () => getRegisterAgentInstructionDataDecoder,
  getRegisterAgentInstructionDataCodec: () => getRegisterAgentInstructionDataCodec,
  getRegisterAgentInstructionAsync: () => getRegisterAgentInstructionAsync,
  getRegisterAgentInstruction: () => getRegisterAgentInstruction,
  getRegisterAgentDiscriminatorBytes: () => getRegisterAgentDiscriminatorBytes,
  getRegisterAgentCompressedInstructionDataEncoder: () => getRegisterAgentCompressedInstructionDataEncoder,
  getRegisterAgentCompressedInstructionDataDecoder: () => getRegisterAgentCompressedInstructionDataDecoder,
  getRegisterAgentCompressedInstructionDataCodec: () => getRegisterAgentCompressedInstructionDataCodec,
  getRegisterAgentCompressedInstructionAsync: () => getRegisterAgentCompressedInstructionAsync,
  getRegisterAgentCompressedInstruction: () => getRegisterAgentCompressedInstruction,
  getRegisterAgentCompressedDiscriminatorBytes: () => getRegisterAgentCompressedDiscriminatorBytes,
  getReentrancyStateEncoder: () => getReentrancyStateEncoder,
  getReentrancyStateDecoder: () => getReentrancyStateDecoder,
  getReentrancyStateCodec: () => getReentrancyStateCodec,
  getReentrancyGuardSize: () => getReentrancyGuardSize,
  getReentrancyGuardEncoder: () => getReentrancyGuardEncoder,
  getReentrancyGuardDiscriminatorBytes: () => getReentrancyGuardDiscriminatorBytes,
  getReentrancyGuardDecoder: () => getReentrancyGuardDecoder,
  getReentrancyGuardCodec: () => getReentrancyGuardCodec,
  getRecordPayaiPaymentInstructionDataEncoder: () => getRecordPayaiPaymentInstructionDataEncoder,
  getRecordPayaiPaymentInstructionDataDecoder: () => getRecordPayaiPaymentInstructionDataDecoder,
  getRecordPayaiPaymentInstructionDataCodec: () => getRecordPayaiPaymentInstructionDataCodec,
  getRecordPayaiPaymentInstructionAsync: () => getRecordPayaiPaymentInstructionAsync,
  getRecordPayaiPaymentInstruction: () => getRecordPayaiPaymentInstruction,
  getRecordPayaiPaymentDiscriminatorBytes: () => getRecordPayaiPaymentDiscriminatorBytes,
  getRbacConfigInitializedEventEncoder: () => getRbacConfigInitializedEventEncoder,
  getRbacConfigInitializedEventDecoder: () => getRbacConfigInitializedEventDecoder,
  getRbacConfigInitializedEventCodec: () => getRbacConfigInitializedEventCodec,
  getRbacConfigEncoder: () => getRbacConfigEncoder,
  getRbacConfigDiscriminatorBytes: () => getRbacConfigDiscriminatorBytes,
  getRbacConfigDecoder: () => getRbacConfigDecoder,
  getRbacConfigCodec: () => getRbacConfigCodec,
  getQuorumRequirementsEncoder: () => getQuorumRequirementsEncoder,
  getQuorumRequirementsDecoder: () => getQuorumRequirementsDecoder,
  getQuorumRequirementsCodec: () => getQuorumRequirementsCodec,
  getQuorumMethodEncoder: () => getQuorumMethodEncoder,
  getQuorumMethodDecoder: () => getQuorumMethodDecoder,
  getQuorumMethodCodec: () => getQuorumMethodCodec,
  getProtocolConfigUpdatedEventEncoder: () => getProtocolConfigUpdatedEventEncoder,
  getProtocolConfigUpdatedEventDecoder: () => getProtocolConfigUpdatedEventDecoder,
  getProtocolConfigUpdatedEventCodec: () => getProtocolConfigUpdatedEventCodec,
  getProtocolConfigSize: () => getProtocolConfigSize,
  getProtocolConfigEncoder: () => getProtocolConfigEncoder,
  getProtocolConfigDiscriminatorBytes: () => getProtocolConfigDiscriminatorBytes,
  getProtocolConfigDecoder: () => getProtocolConfigDecoder,
  getProtocolConfigCodec: () => getProtocolConfigCodec,
  getProposalTypeEncoder: () => getProposalTypeEncoder,
  getProposalTypeDecoder: () => getProposalTypeDecoder,
  getProposalTypeCodec: () => getProposalTypeCodec,
  getProposalStatusEncoder: () => getProposalStatusEncoder,
  getProposalStatusDecoder: () => getProposalStatusDecoder,
  getProposalStatusCodec: () => getProposalStatusCodec,
  getProposalMetadataEncoder: () => getProposalMetadataEncoder,
  getProposalMetadataDecoder: () => getProposalMetadataDecoder,
  getProposalMetadataCodec: () => getProposalMetadataCodec,
  getProposalInstructionEncoder: () => getProposalInstructionEncoder,
  getProposalInstructionDecoder: () => getProposalInstructionDecoder,
  getProposalInstructionCodec: () => getProposalInstructionCodec,
  getProposalAccountEncoder: () => getProposalAccountEncoder,
  getProposalAccountDecoder: () => getProposalAccountDecoder,
  getProposalAccountCodec: () => getProposalAccountCodec,
  getPricingModelEncoder: () => getPricingModelEncoder,
  getPricingModelDecoder: () => getPricingModelDecoder,
  getPricingModelCodec: () => getPricingModelCodec,
  getPolicyTypeEncoder: () => getPolicyTypeEncoder,
  getPolicyTypeDecoder: () => getPolicyTypeDecoder,
  getPolicyTypeCodec: () => getPolicyTypeCodec,
  getPolicyStatusEncoder: () => getPolicyStatusEncoder,
  getPolicyStatusDecoder: () => getPolicyStatusDecoder,
  getPolicyStatusCodec: () => getPolicyStatusCodec,
  getPolicyScopeEncoder: () => getPolicyScopeEncoder,
  getPolicyScopeDecoder: () => getPolicyScopeDecoder,
  getPolicyScopeCodec: () => getPolicyScopeCodec,
  getPolicyRuleEncoder: () => getPolicyRuleEncoder,
  getPolicyRuleDecoder: () => getPolicyRuleDecoder,
  getPolicyRuleCodec: () => getPolicyRuleCodec,
  getPolicyMetadataEncoder: () => getPolicyMetadataEncoder,
  getPolicyMetadataDecoder: () => getPolicyMetadataDecoder,
  getPolicyMetadataCodec: () => getPolicyMetadataCodec,
  getPermissionScopeEncoder: () => getPermissionScopeEncoder,
  getPermissionScopeDecoder: () => getPermissionScopeDecoder,
  getPermissionScopeCodec: () => getPermissionScopeCodec,
  getPermissionMetadataEncoder: () => getPermissionMetadataEncoder,
  getPermissionMetadataDecoder: () => getPermissionMetadataDecoder,
  getPermissionMetadataCodec: () => getPermissionMetadataCodec,
  getPermissionEncoder: () => getPermissionEncoder,
  getPermissionDecoder: () => getPermissionDecoder,
  getPermissionConstraintTypeEncoder: () => getPermissionConstraintTypeEncoder,
  getPermissionConstraintTypeDecoder: () => getPermissionConstraintTypeDecoder,
  getPermissionConstraintTypeCodec: () => getPermissionConstraintTypeCodec,
  getPermissionConstraintEncoder: () => getPermissionConstraintEncoder,
  getPermissionConstraintDecoder: () => getPermissionConstraintDecoder,
  getPermissionConstraintCodec: () => getPermissionConstraintCodec,
  getPermissionCodec: () => getPermissionCodec,
  getPendingTransactionEncoder: () => getPendingTransactionEncoder,
  getPendingTransactionDecoder: () => getPendingTransactionDecoder,
  getPendingTransactionCodec: () => getPendingTransactionCodec,
  getPasswordPoliciesEncoder: () => getPasswordPoliciesEncoder,
  getPasswordPoliciesDecoder: () => getPasswordPoliciesDecoder,
  getPasswordPoliciesCodec: () => getPasswordPoliciesCodec,
  getNotificationTimingEncoder: () => getNotificationTimingEncoder,
  getNotificationTimingDecoder: () => getNotificationTimingDecoder,
  getNotificationTimingCodec: () => getNotificationTimingCodec,
  getNotificationTargetTypeEncoder: () => getNotificationTargetTypeEncoder,
  getNotificationTargetTypeDecoder: () => getNotificationTargetTypeDecoder,
  getNotificationTargetTypeCodec: () => getNotificationTargetTypeCodec,
  getNotificationTargetEncoder: () => getNotificationTargetEncoder,
  getNotificationTargetDecoder: () => getNotificationTargetDecoder,
  getNotificationTargetCodec: () => getNotificationTargetCodec,
  getNotificationRequirementEncoder: () => getNotificationRequirementEncoder,
  getNotificationRequirementDecoder: () => getNotificationRequirementDecoder,
  getNotificationRequirementCodec: () => getNotificationRequirementCodec,
  getNotificationPriorityEncoder: () => getNotificationPriorityEncoder,
  getNotificationPriorityDecoder: () => getNotificationPriorityDecoder,
  getNotificationPriorityCodec: () => getNotificationPriorityCodec,
  getNotificationMethodEncoder: () => getNotificationMethodEncoder,
  getNotificationMethodDecoder: () => getNotificationMethodDecoder,
  getNotificationMethodCodec: () => getNotificationMethodCodec,
  getNetworkSecurityPoliciesEncoder: () => getNetworkSecurityPoliciesEncoder,
  getNetworkSecurityPoliciesDecoder: () => getNetworkSecurityPoliciesDecoder,
  getNetworkSecurityPoliciesCodec: () => getNetworkSecurityPoliciesCodec,
  getMultisigTypeEncoder: () => getMultisigTypeEncoder,
  getMultisigTypeDecoder: () => getMultisigTypeDecoder,
  getMultisigTypeConfigEncoder: () => getMultisigTypeConfigEncoder,
  getMultisigTypeConfigDecoder: () => getMultisigTypeConfigDecoder,
  getMultisigTypeConfigCodec: () => getMultisigTypeConfigCodec,
  getMultisigTypeCodec: () => getMultisigTypeCodec,
  getMultisigSignatureEncoder: () => getMultisigSignatureEncoder,
  getMultisigSignatureDecoder: () => getMultisigSignatureDecoder,
  getMultisigSignatureCodec: () => getMultisigSignatureCodec,
  getMultisigEncoder: () => getMultisigEncoder,
  getMultisigDiscriminatorBytes: () => getMultisigDiscriminatorBytes,
  getMultisigDecoder: () => getMultisigDecoder,
  getMultisigCreatedEventEncoder: () => getMultisigCreatedEventEncoder,
  getMultisigCreatedEventDecoder: () => getMultisigCreatedEventDecoder,
  getMultisigCreatedEventCodec: () => getMultisigCreatedEventCodec,
  getMultisigConfigEncoder: () => getMultisigConfigEncoder,
  getMultisigConfigDecoder: () => getMultisigConfigDecoder,
  getMultisigConfigCodec: () => getMultisigConfigCodec,
  getMultisigCodec: () => getMultisigCodec,
  getManageAgentStatusInstructionDataEncoder: () => getManageAgentStatusInstructionDataEncoder,
  getManageAgentStatusInstructionDataDecoder: () => getManageAgentStatusInstructionDataDecoder,
  getManageAgentStatusInstructionDataCodec: () => getManageAgentStatusInstructionDataCodec,
  getManageAgentStatusInstructionAsync: () => getManageAgentStatusInstructionAsync,
  getManageAgentStatusInstruction: () => getManageAgentStatusInstruction,
  getManageAgentStatusDiscriminatorBytes: () => getManageAgentStatusDiscriminatorBytes,
  getLongitudeRangeEncoder: () => getLongitudeRangeEncoder,
  getLongitudeRangeDecoder: () => getLongitudeRangeDecoder,
  getLongitudeRangeCodec: () => getLongitudeRangeCodec,
  getLocationConstraintsEncoder: () => getLocationConstraintsEncoder,
  getLocationConstraintsDecoder: () => getLocationConstraintsDecoder,
  getLocationConstraintsCodec: () => getLocationConstraintsCodec,
  getLatitudeRangeEncoder: () => getLatitudeRangeEncoder,
  getLatitudeRangeDecoder: () => getLatitudeRangeDecoder,
  getLatitudeRangeCodec: () => getLatitudeRangeCodec,
  getIssueCredentialInstructionDataEncoder: () => getIssueCredentialInstructionDataEncoder,
  getIssueCredentialInstructionDataDecoder: () => getIssueCredentialInstructionDataDecoder,
  getIssueCredentialInstructionDataCodec: () => getIssueCredentialInstructionDataCodec,
  getIssueCredentialInstructionAsync: () => getIssueCredentialInstructionAsync,
  getIssueCredentialInstruction: () => getIssueCredentialInstruction,
  getIssueCredentialDiscriminatorBytes: () => getIssueCredentialDiscriminatorBytes,
  getInitializeStakingConfigInstructionDataEncoder: () => getInitializeStakingConfigInstructionDataEncoder,
  getInitializeStakingConfigInstructionDataDecoder: () => getInitializeStakingConfigInstructionDataDecoder,
  getInitializeStakingConfigInstructionDataCodec: () => getInitializeStakingConfigInstructionDataCodec,
  getInitializeStakingConfigInstructionAsync: () => getInitializeStakingConfigInstructionAsync,
  getInitializeStakingConfigInstruction: () => getInitializeStakingConfigInstruction,
  getInitializeStakingConfigDiscriminatorBytes: () => getInitializeStakingConfigDiscriminatorBytes,
  getInitializeReputationMetricsInstructionDataEncoder: () => getInitializeReputationMetricsInstructionDataEncoder,
  getInitializeReputationMetricsInstructionDataDecoder: () => getInitializeReputationMetricsInstructionDataDecoder,
  getInitializeReputationMetricsInstructionDataCodec: () => getInitializeReputationMetricsInstructionDataCodec,
  getInitializeReputationMetricsInstructionAsync: () => getInitializeReputationMetricsInstructionAsync,
  getInitializeReputationMetricsInstruction: () => getInitializeReputationMetricsInstruction,
  getInitializeReputationMetricsDiscriminatorBytes: () => getInitializeReputationMetricsDiscriminatorBytes,
  getInitializeRbacConfigInstructionDataEncoder: () => getInitializeRbacConfigInstructionDataEncoder,
  getInitializeRbacConfigInstructionDataDecoder: () => getInitializeRbacConfigInstructionDataDecoder,
  getInitializeRbacConfigInstructionDataCodec: () => getInitializeRbacConfigInstructionDataCodec,
  getInitializeRbacConfigInstructionAsync: () => getInitializeRbacConfigInstructionAsync,
  getInitializeRbacConfigInstruction: () => getInitializeRbacConfigInstruction,
  getInitializeRbacConfigDiscriminatorBytes: () => getInitializeRbacConfigDiscriminatorBytes,
  getInitializeProtocolConfigInstructionDataEncoder: () => getInitializeProtocolConfigInstructionDataEncoder,
  getInitializeProtocolConfigInstructionDataDecoder: () => getInitializeProtocolConfigInstructionDataDecoder,
  getInitializeProtocolConfigInstructionDataCodec: () => getInitializeProtocolConfigInstructionDataCodec,
  getInitializeProtocolConfigInstructionAsync: () => getInitializeProtocolConfigInstructionAsync,
  getInitializeProtocolConfigInstruction: () => getInitializeProtocolConfigInstruction,
  getInitializeProtocolConfigDiscriminatorBytes: () => getInitializeProtocolConfigDiscriminatorBytes,
  getInitializeGovernanceProposalInstructionDataEncoder: () => getInitializeGovernanceProposalInstructionDataEncoder,
  getInitializeGovernanceProposalInstructionDataDecoder: () => getInitializeGovernanceProposalInstructionDataDecoder,
  getInitializeGovernanceProposalInstructionDataCodec: () => getInitializeGovernanceProposalInstructionDataCodec,
  getInitializeGovernanceProposalInstructionAsync: () => getInitializeGovernanceProposalInstructionAsync,
  getInitializeGovernanceProposalInstruction: () => getInitializeGovernanceProposalInstruction,
  getInitializeGovernanceProposalDiscriminatorBytes: () => getInitializeGovernanceProposalDiscriminatorBytes,
  getInitializeAuditTrailInstructionDataEncoder: () => getInitializeAuditTrailInstructionDataEncoder,
  getInitializeAuditTrailInstructionDataDecoder: () => getInitializeAuditTrailInstructionDataDecoder,
  getInitializeAuditTrailInstructionDataCodec: () => getInitializeAuditTrailInstructionDataCodec,
  getInitializeAuditTrailInstructionAsync: () => getInitializeAuditTrailInstructionAsync,
  getInitializeAuditTrailInstruction: () => getInitializeAuditTrailInstruction,
  getInitializeAuditTrailDiscriminatorBytes: () => getInitializeAuditTrailDiscriminatorBytes,
  getInitReentrancyGuardInstructionDataEncoder: () => getInitReentrancyGuardInstructionDataEncoder,
  getInitReentrancyGuardInstructionDataDecoder: () => getInitReentrancyGuardInstructionDataDecoder,
  getInitReentrancyGuardInstructionDataCodec: () => getInitReentrancyGuardInstructionDataCodec,
  getInitReentrancyGuardInstructionAsync: () => getInitReentrancyGuardInstructionAsync,
  getInitReentrancyGuardInstruction: () => getInitReentrancyGuardInstruction,
  getInitReentrancyGuardDiscriminatorBytes: () => getInitReentrancyGuardDiscriminatorBytes,
  getIncidentResponsePoliciesEncoder: () => getIncidentResponsePoliciesEncoder,
  getIncidentResponsePoliciesDecoder: () => getIncidentResponsePoliciesDecoder,
  getIncidentResponsePoliciesCodec: () => getIncidentResponsePoliciesCodec,
  getHierarchicalBoundaryEncoder: () => getHierarchicalBoundaryEncoder,
  getHierarchicalBoundaryDecoder: () => getHierarchicalBoundaryDecoder,
  getHierarchicalBoundaryCodec: () => getHierarchicalBoundaryCodec,
  getGovernanceProposalEncoder: () => getGovernanceProposalEncoder,
  getGovernanceProposalDiscriminatorBytes: () => getGovernanceProposalDiscriminatorBytes,
  getGovernanceProposalDecoder: () => getGovernanceProposalDecoder,
  getGovernanceProposalCreatedEventEncoder: () => getGovernanceProposalCreatedEventEncoder,
  getGovernanceProposalCreatedEventDecoder: () => getGovernanceProposalCreatedEventDecoder,
  getGovernanceProposalCreatedEventCodec: () => getGovernanceProposalCreatedEventCodec,
  getGovernanceProposalCodec: () => getGovernanceProposalCodec,
  getGhostspeakMarketplaceErrorMessage: () => getGhostspeakMarketplaceErrorMessage,
  getGhostUnstakedEventEncoder: () => getGhostUnstakedEventEncoder,
  getGhostUnstakedEventDecoder: () => getGhostUnstakedEventDecoder,
  getGhostUnstakedEventCodec: () => getGhostUnstakedEventCodec,
  getGhostStakedEventEncoder: () => getGhostStakedEventEncoder,
  getGhostStakedEventDecoder: () => getGhostStakedEventDecoder,
  getGhostStakedEventCodec: () => getGhostStakedEventCodec,
  getGhostSlashedEventEncoder: () => getGhostSlashedEventEncoder,
  getGhostSlashedEventDecoder: () => getGhostSlashedEventDecoder,
  getGhostSlashedEventCodec: () => getGhostSlashedEventCodec,
  getGhostProtectEscrowEncoder: () => getGhostProtectEscrowEncoder,
  getGhostProtectEscrowDiscriminatorBytes: () => getGhostProtectEscrowDiscriminatorBytes,
  getGhostProtectEscrowDecoder: () => getGhostProtectEscrowDecoder,
  getGhostProtectEscrowCodec: () => getGhostProtectEscrowCodec,
  getGeographicRegionEncoder: () => getGeographicRegionEncoder,
  getGeographicRegionDecoder: () => getGeographicRegionDecoder,
  getGeographicRegionCodec: () => getGeographicRegionCodec,
  getGenerateComplianceReportInstructionDataEncoder: () => getGenerateComplianceReportInstructionDataEncoder,
  getGenerateComplianceReportInstructionDataDecoder: () => getGenerateComplianceReportInstructionDataDecoder,
  getGenerateComplianceReportInstructionDataCodec: () => getGenerateComplianceReportInstructionDataCodec,
  getGenerateComplianceReportInstructionAsync: () => getGenerateComplianceReportInstructionAsync,
  getGenerateComplianceReportInstruction: () => getGenerateComplianceReportInstruction,
  getGenerateComplianceReportDiscriminatorBytes: () => getGenerateComplianceReportDiscriminatorBytes,
  getFileDisputeInstructionDataEncoder: () => getFileDisputeInstructionDataEncoder,
  getFileDisputeInstructionDataDecoder: () => getFileDisputeInstructionDataDecoder,
  getFileDisputeInstructionDataCodec: () => getFileDisputeInstructionDataCodec,
  getFileDisputeInstruction: () => getFileDisputeInstruction,
  getFileDisputeDiscriminatorBytes: () => getFileDisputeDiscriminatorBytes,
  getExecutionParamsEncoder: () => getExecutionParamsEncoder,
  getExecutionParamsDecoder: () => getExecutionParamsDecoder,
  getExecutionParamsCodec: () => getExecutionParamsCodec,
  getExecutionConditionEncoder: () => getExecutionConditionEncoder,
  getExecutionConditionDecoder: () => getExecutionConditionDecoder,
  getExecutionConditionCodec: () => getExecutionConditionCodec,
  getEscrowStatusEncoder: () => getEscrowStatusEncoder,
  getEscrowStatusDecoder: () => getEscrowStatusDecoder,
  getEscrowStatusCodec: () => getEscrowStatusCodec,
  getEscrowCreatedEventEncoder: () => getEscrowCreatedEventEncoder,
  getEscrowCreatedEventDecoder: () => getEscrowCreatedEventDecoder,
  getEscrowCreatedEventCodec: () => getEscrowCreatedEventCodec,
  getEscrowCompletedEventEncoder: () => getEscrowCompletedEventEncoder,
  getEscrowCompletedEventDecoder: () => getEscrowCompletedEventDecoder,
  getEscrowCompletedEventCodec: () => getEscrowCompletedEventCodec,
  getEnforcementLevelEncoder: () => getEnforcementLevelEncoder,
  getEnforcementLevelDecoder: () => getEnforcementLevelDecoder,
  getEnforcementLevelCodec: () => getEnforcementLevelCodec,
  getEnableProtocolFeesInstructionDataEncoder: () => getEnableProtocolFeesInstructionDataEncoder,
  getEnableProtocolFeesInstructionDataDecoder: () => getEnableProtocolFeesInstructionDataDecoder,
  getEnableProtocolFeesInstructionDataCodec: () => getEnableProtocolFeesInstructionDataCodec,
  getEnableProtocolFeesInstructionAsync: () => getEnableProtocolFeesInstructionAsync,
  getEnableProtocolFeesInstruction: () => getEnableProtocolFeesInstruction,
  getEnableProtocolFeesDiscriminatorBytes: () => getEnableProtocolFeesDiscriminatorBytes,
  getEmergencyConfigEncoder: () => getEmergencyConfigEncoder,
  getEmergencyConfigDecoder: () => getEmergencyConfigDecoder,
  getEmergencyConfigCodec: () => getEmergencyConfigCodec,
  getEmergencyAccessConfigEncoder: () => getEmergencyAccessConfigEncoder,
  getEmergencyAccessConfigDecoder: () => getEmergencyAccessConfigDecoder,
  getEmergencyAccessConfigCodec: () => getEmergencyAccessConfigCodec,
  getDisputeResolvedEventEncoder: () => getDisputeResolvedEventEncoder,
  getDisputeResolvedEventDecoder: () => getDisputeResolvedEventDecoder,
  getDisputeResolvedEventCodec: () => getDisputeResolvedEventCodec,
  getDisputeFiledEventEncoder: () => getDisputeFiledEventEncoder,
  getDisputeFiledEventDecoder: () => getDisputeFiledEventDecoder,
  getDisputeFiledEventCodec: () => getDisputeFiledEventCodec,
  getDidDocumentEncoder: () => getDidDocumentEncoder,
  getDidDocumentDiscriminatorBytes: () => getDidDocumentDiscriminatorBytes,
  getDidDocumentDecoder: () => getDidDocumentDecoder,
  getDidDocumentCodec: () => getDidDocumentCodec,
  getDeliverySubmittedEventEncoder: () => getDeliverySubmittedEventEncoder,
  getDeliverySubmittedEventDecoder: () => getDeliverySubmittedEventDecoder,
  getDeliverySubmittedEventCodec: () => getDeliverySubmittedEventCodec,
  getDelegationScopeEncoder: () => getDelegationScopeEncoder,
  getDelegationScopeDecoder: () => getDelegationScopeDecoder,
  getDelegationScopeCodec: () => getDelegationScopeCodec,
  getDelegationInfoEncoder: () => getDelegationInfoEncoder,
  getDelegationInfoDecoder: () => getDelegationInfoDecoder,
  getDelegationInfoCodec: () => getDelegationInfoCodec,
  getDegradationHandlingEncoder: () => getDegradationHandlingEncoder,
  getDegradationHandlingDecoder: () => getDegradationHandlingDecoder,
  getDegradationHandlingCodec: () => getDegradationHandlingCodec,
  getDeactivateDidDocumentInstructionDataEncoder: () => getDeactivateDidDocumentInstructionDataEncoder,
  getDeactivateDidDocumentInstructionDataDecoder: () => getDeactivateDidDocumentInstructionDataDecoder,
  getDeactivateDidDocumentInstructionDataCodec: () => getDeactivateDidDocumentInstructionDataCodec,
  getDeactivateDidDocumentInstructionAsync: () => getDeactivateDidDocumentInstructionAsync,
  getDeactivateDidDocumentInstruction: () => getDeactivateDidDocumentInstruction,
  getDeactivateDidDocumentDiscriminatorBytes: () => getDeactivateDidDocumentDiscriminatorBytes,
  getDeactivateCredentialTypeInstructionDataEncoder: () => getDeactivateCredentialTypeInstructionDataEncoder,
  getDeactivateCredentialTypeInstructionDataDecoder: () => getDeactivateCredentialTypeInstructionDataDecoder,
  getDeactivateCredentialTypeInstructionDataCodec: () => getDeactivateCredentialTypeInstructionDataCodec,
  getDeactivateCredentialTypeInstruction: () => getDeactivateCredentialTypeInstruction,
  getDeactivateCredentialTypeDiscriminatorBytes: () => getDeactivateCredentialTypeDiscriminatorBytes,
  getDeactivateCredentialTemplateInstructionDataEncoder: () => getDeactivateCredentialTemplateInstructionDataEncoder,
  getDeactivateCredentialTemplateInstructionDataDecoder: () => getDeactivateCredentialTemplateInstructionDataDecoder,
  getDeactivateCredentialTemplateInstructionDataCodec: () => getDeactivateCredentialTemplateInstructionDataCodec,
  getDeactivateCredentialTemplateInstruction: () => getDeactivateCredentialTemplateInstruction,
  getDeactivateCredentialTemplateDiscriminatorBytes: () => getDeactivateCredentialTemplateDiscriminatorBytes,
  getDeactivateAgentInstructionDataEncoder: () => getDeactivateAgentInstructionDataEncoder,
  getDeactivateAgentInstructionDataDecoder: () => getDeactivateAgentInstructionDataDecoder,
  getDeactivateAgentInstructionDataCodec: () => getDeactivateAgentInstructionDataCodec,
  getDeactivateAgentInstructionAsync: () => getDeactivateAgentInstructionAsync,
  getDeactivateAgentInstruction: () => getDeactivateAgentInstruction,
  getDeactivateAgentDiscriminatorBytes: () => getDeactivateAgentDiscriminatorBytes,
  getDataProtectionPoliciesEncoder: () => getDataProtectionPoliciesEncoder,
  getDataProtectionPoliciesDecoder: () => getDataProtectionPoliciesDecoder,
  getDataProtectionPoliciesCodec: () => getDataProtectionPoliciesCodec,
  getDataAccessLevelEncoder: () => getDataAccessLevelEncoder,
  getDataAccessLevelDecoder: () => getDataAccessLevelDecoder,
  getDataAccessLevelCodec: () => getDataAccessLevelCodec,
  getCrossChainStatusEncoder: () => getCrossChainStatusEncoder,
  getCrossChainStatusDecoder: () => getCrossChainStatusDecoder,
  getCrossChainStatusCodec: () => getCrossChainStatusCodec,
  getCredentialTypeEncoder: () => getCredentialTypeEncoder,
  getCredentialTypeDiscriminatorBytes: () => getCredentialTypeDiscriminatorBytes,
  getCredentialTypeDecoder: () => getCredentialTypeDecoder,
  getCredentialTypeCodec: () => getCredentialTypeCodec,
  getCredentialTemplateEncoder: () => getCredentialTemplateEncoder,
  getCredentialTemplateDiscriminatorBytes: () => getCredentialTemplateDiscriminatorBytes,
  getCredentialTemplateDecoder: () => getCredentialTemplateDecoder,
  getCredentialTemplateCodec: () => getCredentialTemplateCodec,
  getCredentialStatusEncoder: () => getCredentialStatusEncoder,
  getCredentialStatusDecoder: () => getCredentialStatusDecoder,
  getCredentialStatusCodec: () => getCredentialStatusCodec,
  getCredentialKindEncoder: () => getCredentialKindEncoder,
  getCredentialKindDecoder: () => getCredentialKindDecoder,
  getCredentialKindCodec: () => getCredentialKindCodec,
  getCredentialEncoder: () => getCredentialEncoder,
  getCredentialDiscriminatorBytes: () => getCredentialDiscriminatorBytes,
  getCredentialDecoder: () => getCredentialDecoder,
  getCredentialCodec: () => getCredentialCodec,
  getCreateMultisigInstructionDataEncoder: () => getCreateMultisigInstructionDataEncoder,
  getCreateMultisigInstructionDataDecoder: () => getCreateMultisigInstructionDataDecoder,
  getCreateMultisigInstructionDataCodec: () => getCreateMultisigInstructionDataCodec,
  getCreateMultisigInstructionAsync: () => getCreateMultisigInstructionAsync,
  getCreateMultisigInstruction: () => getCreateMultisigInstruction,
  getCreateMultisigDiscriminatorBytes: () => getCreateMultisigDiscriminatorBytes,
  getCreateEscrowInstructionDataEncoder: () => getCreateEscrowInstructionDataEncoder,
  getCreateEscrowInstructionDataDecoder: () => getCreateEscrowInstructionDataDecoder,
  getCreateEscrowInstructionDataCodec: () => getCreateEscrowInstructionDataCodec,
  getCreateEscrowInstructionAsync: () => getCreateEscrowInstructionAsync,
  getCreateEscrowInstruction: () => getCreateEscrowInstruction,
  getCreateEscrowDiscriminatorBytes: () => getCreateEscrowDiscriminatorBytes,
  getCreateDidDocumentInstructionDataEncoder: () => getCreateDidDocumentInstructionDataEncoder,
  getCreateDidDocumentInstructionDataDecoder: () => getCreateDidDocumentInstructionDataDecoder,
  getCreateDidDocumentInstructionDataCodec: () => getCreateDidDocumentInstructionDataCodec,
  getCreateDidDocumentInstructionAsync: () => getCreateDidDocumentInstructionAsync,
  getCreateDidDocumentInstruction: () => getCreateDidDocumentInstruction,
  getCreateDidDocumentDiscriminatorBytes: () => getCreateDidDocumentDiscriminatorBytes,
  getCreateCredentialTypeInstructionDataEncoder: () => getCreateCredentialTypeInstructionDataEncoder,
  getCreateCredentialTypeInstructionDataDecoder: () => getCreateCredentialTypeInstructionDataDecoder,
  getCreateCredentialTypeInstructionDataCodec: () => getCreateCredentialTypeInstructionDataCodec,
  getCreateCredentialTypeInstructionAsync: () => getCreateCredentialTypeInstructionAsync,
  getCreateCredentialTypeInstruction: () => getCreateCredentialTypeInstruction,
  getCreateCredentialTypeDiscriminatorBytes: () => getCreateCredentialTypeDiscriminatorBytes,
  getCreateCredentialTemplateInstructionDataEncoder: () => getCreateCredentialTemplateInstructionDataEncoder,
  getCreateCredentialTemplateInstructionDataDecoder: () => getCreateCredentialTemplateInstructionDataDecoder,
  getCreateCredentialTemplateInstructionDataCodec: () => getCreateCredentialTemplateInstructionDataCodec,
  getCreateCredentialTemplateInstructionAsync: () => getCreateCredentialTemplateInstructionAsync,
  getCreateCredentialTemplateInstruction: () => getCreateCredentialTemplateInstruction,
  getCreateCredentialTemplateDiscriminatorBytes: () => getCreateCredentialTemplateDiscriminatorBytes,
  getCreateAgentAuthorizationInstructionDataEncoder: () => getCreateAgentAuthorizationInstructionDataEncoder,
  getCreateAgentAuthorizationInstructionDataDecoder: () => getCreateAgentAuthorizationInstructionDataDecoder,
  getCreateAgentAuthorizationInstructionDataCodec: () => getCreateAgentAuthorizationInstructionDataCodec,
  getCreateAgentAuthorizationInstructionAsync: () => getCreateAgentAuthorizationInstructionAsync,
  getCreateAgentAuthorizationInstruction: () => getCreateAgentAuthorizationInstruction,
  getCreateAgentAuthorizationDiscriminatorBytes: () => getCreateAgentAuthorizationDiscriminatorBytes,
  getConstraintOperatorEncoder: () => getConstraintOperatorEncoder,
  getConstraintOperatorDecoder: () => getConstraintOperatorDecoder,
  getConstraintOperatorCodec: () => getConstraintOperatorCodec,
  getConstraintConditionEncoder: () => getConstraintConditionEncoder,
  getConstraintConditionDecoder: () => getConstraintConditionDecoder,
  getConstraintConditionCodec: () => getConstraintConditionCodec,
  getConditionTypeEncoder: () => getConditionTypeEncoder,
  getConditionTypeDecoder: () => getConditionTypeDecoder,
  getConditionTypeCodec: () => getConditionTypeCodec,
  getCompressedAgentCreatedEventEncoder: () => getCompressedAgentCreatedEventEncoder,
  getCompressedAgentCreatedEventDecoder: () => getCompressedAgentCreatedEventDecoder,
  getCompressedAgentCreatedEventCodec: () => getCompressedAgentCreatedEventCodec,
  getComplianceStatusEncoder: () => getComplianceStatusEncoder,
  getComplianceStatusDecoder: () => getComplianceStatusDecoder,
  getComplianceStatusCodec: () => getComplianceStatusCodec,
  getComplianceReportGeneratedEventEncoder: () => getComplianceReportGeneratedEventEncoder,
  getComplianceReportGeneratedEventDecoder: () => getComplianceReportGeneratedEventDecoder,
  getComplianceReportGeneratedEventCodec: () => getComplianceReportGeneratedEventCodec,
  getComplianceReportEncoder: () => getComplianceReportEncoder,
  getComplianceReportDiscriminatorBytes: () => getComplianceReportDiscriminatorBytes,
  getComplianceReportDecoder: () => getComplianceReportDecoder,
  getComplianceReportCodec: () => getComplianceReportCodec,
  getCompliancePoliciesEncoder: () => getCompliancePoliciesEncoder,
  getCompliancePoliciesDecoder: () => getCompliancePoliciesDecoder,
  getCompliancePoliciesCodec: () => getCompliancePoliciesCodec,
  getComplianceMetricsEncoder: () => getComplianceMetricsEncoder,
  getComplianceMetricsDecoder: () => getComplianceMetricsDecoder,
  getComplianceMetricsCodec: () => getComplianceMetricsCodec,
  getComplianceFlagsEncoder: () => getComplianceFlagsEncoder,
  getComplianceFlagsDecoder: () => getComplianceFlagsDecoder,
  getComplianceFlagsCodec: () => getComplianceFlagsCodec,
  getBiometricTypeEncoder: () => getBiometricTypeEncoder,
  getBiometricTypeDecoder: () => getBiometricTypeDecoder,
  getBiometricTypeCodec: () => getBiometricTypeCodec,
  getBiometricStorageMethodEncoder: () => getBiometricStorageMethodEncoder,
  getBiometricStorageMethodDecoder: () => getBiometricStorageMethodDecoder,
  getBiometricStorageMethodCodec: () => getBiometricStorageMethodCodec,
  getBiometricQualityEncoder: () => getBiometricQualityEncoder,
  getBiometricQualityDecoder: () => getBiometricQualityDecoder,
  getBiometricQualityCodec: () => getBiometricQualityCodec,
  getBiometricProtectionEncoder: () => getBiometricProtectionEncoder,
  getBiometricProtectionDecoder: () => getBiometricProtectionDecoder,
  getBiometricProtectionCodec: () => getBiometricProtectionCodec,
  getBiometricPoliciesEncoder: () => getBiometricPoliciesEncoder,
  getBiometricPoliciesDecoder: () => getBiometricPoliciesDecoder,
  getBiometricPoliciesCodec: () => getBiometricPoliciesCodec,
  getBackupFrequencyEncoder: () => getBackupFrequencyEncoder,
  getBackupFrequencyDecoder: () => getBackupFrequencyDecoder,
  getBackupFrequencyCodec: () => getBackupFrequencyCodec,
  getAuthorizationUsageRecordEncoder: () => getAuthorizationUsageRecordEncoder,
  getAuthorizationUsageRecordDiscriminatorBytes: () => getAuthorizationUsageRecordDiscriminatorBytes,
  getAuthorizationUsageRecordDecoder: () => getAuthorizationUsageRecordDecoder,
  getAuthorizationUsageRecordCodec: () => getAuthorizationUsageRecordCodec,
  getAuthorizationPoliciesEncoder: () => getAuthorizationPoliciesEncoder,
  getAuthorizationPoliciesDecoder: () => getAuthorizationPoliciesDecoder,
  getAuthorizationPoliciesCodec: () => getAuthorizationPoliciesCodec,
  getAuthenticationStrengthEncoder: () => getAuthenticationStrengthEncoder,
  getAuthenticationStrengthDecoder: () => getAuthenticationStrengthDecoder,
  getAuthenticationStrengthCodec: () => getAuthenticationStrengthCodec,
  getAuthenticationPoliciesEncoder: () => getAuthenticationPoliciesEncoder,
  getAuthenticationPoliciesDecoder: () => getAuthenticationPoliciesDecoder,
  getAuthenticationPoliciesCodec: () => getAuthenticationPoliciesCodec,
  getAuthenticationMethodEncoder: () => getAuthenticationMethodEncoder,
  getAuthenticationMethodDecoder: () => getAuthenticationMethodDecoder,
  getAuthenticationMethodCodec: () => getAuthenticationMethodCodec,
  getAuthenticationLevelEncoder: () => getAuthenticationLevelEncoder,
  getAuthenticationLevelDecoder: () => getAuthenticationLevelDecoder,
  getAuthenticationLevelCodec: () => getAuthenticationLevelCodec,
  getAuditTrailInitializedEventEncoder: () => getAuditTrailInitializedEventEncoder,
  getAuditTrailInitializedEventDecoder: () => getAuditTrailInitializedEventDecoder,
  getAuditTrailInitializedEventCodec: () => getAuditTrailInitializedEventCodec,
  getAuditTrailEncoder: () => getAuditTrailEncoder,
  getAuditTrailDiscriminatorBytes: () => getAuditTrailDiscriminatorBytes,
  getAuditTrailDecoder: () => getAuditTrailDecoder,
  getAuditTrailCodec: () => getAuditTrailCodec,
  getAuditEntryEncoder: () => getAuditEntryEncoder,
  getAuditEntryDecoder: () => getAuditEntryDecoder,
  getAuditEntryCodec: () => getAuditEntryCodec,
  getAuditContextEncoder: () => getAuditContextEncoder,
  getAuditContextDecoder: () => getAuditContextDecoder,
  getAuditContextCodec: () => getAuditContextCodec,
  getAuditConfigEncoder: () => getAuditConfigEncoder,
  getAuditConfigDecoder: () => getAuditConfigDecoder,
  getAuditConfigCodec: () => getAuditConfigCodec,
  getAuditActionEncoder: () => getAuditActionEncoder,
  getAuditActionDecoder: () => getAuditActionDecoder,
  getAuditActionCodec: () => getAuditActionCodec,
  getArbitratorDecisionEncoder: () => getArbitratorDecisionEncoder,
  getArbitratorDecisionDecoder: () => getArbitratorDecisionDecoder,
  getArbitratorDecisionCodec: () => getArbitratorDecisionCodec,
  getArbitrateDisputeInstructionDataEncoder: () => getArbitrateDisputeInstructionDataEncoder,
  getArbitrateDisputeInstructionDataDecoder: () => getArbitrateDisputeInstructionDataDecoder,
  getArbitrateDisputeInstructionDataCodec: () => getArbitrateDisputeInstructionDataCodec,
  getArbitrateDisputeInstruction: () => getArbitrateDisputeInstruction,
  getArbitrateDisputeDiscriminatorBytes: () => getArbitrateDisputeDiscriminatorBytes,
  getApproveDeliveryInstructionDataEncoder: () => getApproveDeliveryInstructionDataEncoder,
  getApproveDeliveryInstructionDataDecoder: () => getApproveDeliveryInstructionDataDecoder,
  getApproveDeliveryInstructionDataCodec: () => getApproveDeliveryInstructionDataCodec,
  getApproveDeliveryInstruction: () => getApproveDeliveryInstruction,
  getApproveDeliveryDiscriminatorBytes: () => getApproveDeliveryDiscriminatorBytes,
  getApprovalLevelEncoder: () => getApprovalLevelEncoder,
  getApprovalLevelDecoder: () => getApprovalLevelDecoder,
  getApprovalLevelCodec: () => getApprovalLevelCodec,
  getAgingPolicyEncoder: () => getAgingPolicyEncoder,
  getAgingPolicyDecoder: () => getAgingPolicyDecoder,
  getAgingPolicyCodec: () => getAgingPolicyCodec,
  getAgentVerificationEncoder: () => getAgentVerificationEncoder,
  getAgentVerificationDiscriminatorBytes: () => getAgentVerificationDiscriminatorBytes,
  getAgentVerificationDecoder: () => getAgentVerificationDecoder,
  getAgentVerificationDataEncoder: () => getAgentVerificationDataEncoder,
  getAgentVerificationDataDecoder: () => getAgentVerificationDataDecoder,
  getAgentVerificationDataCodec: () => getAgentVerificationDataCodec,
  getAgentVerificationCodec: () => getAgentVerificationCodec,
  getAgentUpdatedEventEncoder: () => getAgentUpdatedEventEncoder,
  getAgentUpdatedEventDecoder: () => getAgentUpdatedEventDecoder,
  getAgentUpdatedEventCodec: () => getAgentUpdatedEventCodec,
  getAgentTreeConfigSize: () => getAgentTreeConfigSize,
  getAgentTreeConfigEncoder: () => getAgentTreeConfigEncoder,
  getAgentTreeConfigDiscriminatorBytes: () => getAgentTreeConfigDiscriminatorBytes,
  getAgentTreeConfigDecoder: () => getAgentTreeConfigDecoder,
  getAgentTreeConfigCodec: () => getAgentTreeConfigCodec,
  getAgentStatusChangedEventEncoder: () => getAgentStatusChangedEventEncoder,
  getAgentStatusChangedEventDecoder: () => getAgentStatusChangedEventDecoder,
  getAgentStatusChangedEventCodec: () => getAgentStatusChangedEventCodec,
  getAgentServiceUpdatedEventEncoder: () => getAgentServiceUpdatedEventEncoder,
  getAgentServiceUpdatedEventDecoder: () => getAgentServiceUpdatedEventDecoder,
  getAgentServiceUpdatedEventCodec: () => getAgentServiceUpdatedEventCodec,
  getAgentReputationAuthEncoder: () => getAgentReputationAuthEncoder,
  getAgentReputationAuthDiscriminatorBytes: () => getAgentReputationAuthDiscriminatorBytes,
  getAgentReputationAuthDecoder: () => getAgentReputationAuthDecoder,
  getAgentReputationAuthCodec: () => getAgentReputationAuthCodec,
  getAgentRegisteredEventEncoder: () => getAgentRegisteredEventEncoder,
  getAgentRegisteredEventDecoder: () => getAgentRegisteredEventDecoder,
  getAgentRegisteredEventCodec: () => getAgentRegisteredEventCodec,
  getAgentEncoder: () => getAgentEncoder,
  getAgentDiscriminatorBytes: () => getAgentDiscriminatorBytes,
  getAgentDecoder: () => getAgentDecoder,
  getAgentCodec: () => getAgentCodec,
  getActivationRequirementTypeEncoder: () => getActivationRequirementTypeEncoder,
  getActivationRequirementTypeDecoder: () => getActivationRequirementTypeDecoder,
  getActivationRequirementTypeCodec: () => getActivationRequirementTypeCodec,
  getActivationRequirementEncoder: () => getActivationRequirementEncoder,
  getActivationRequirementDecoder: () => getActivationRequirementDecoder,
  getActivationRequirementCodec: () => getActivationRequirementCodec,
  getActivateAgentInstructionDataEncoder: () => getActivateAgentInstructionDataEncoder,
  getActivateAgentInstructionDataDecoder: () => getActivateAgentInstructionDataDecoder,
  getActivateAgentInstructionDataCodec: () => getActivateAgentInstructionDataCodec,
  getActivateAgentInstructionAsync: () => getActivateAgentInstructionAsync,
  getActivateAgentInstruction: () => getActivateAgentInstruction,
  getActivateAgentDiscriminatorBytes: () => getActivateAgentDiscriminatorBytes,
  getActionTypeEncoder: () => getActionTypeEncoder,
  getActionTypeDecoder: () => getActionTypeDecoder,
  getActionTypeCodec: () => getActionTypeCodec,
  getActionEncoder: () => getActionEncoder,
  getActionDecoder: () => getActionDecoder,
  getActionConstraintEncoder: () => getActionConstraintEncoder,
  getActionConstraintDecoder: () => getActionConstraintDecoder,
  getActionConstraintCodec: () => getActionConstraintCodec,
  getActionCodec: () => getActionCodec,
  getAccountLockoutPoliciesEncoder: () => getAccountLockoutPoliciesEncoder,
  getAccountLockoutPoliciesDecoder: () => getAccountLockoutPoliciesDecoder,
  getAccountLockoutPoliciesCodec: () => getAccountLockoutPoliciesCodec,
  getAccessTierEncoder: () => getAccessTierEncoder,
  getAccessTierDecoder: () => getAccessTierDecoder,
  getAccessTierCodec: () => getAccessTierCodec,
  getAccessPolicyEncoder: () => getAccessPolicyEncoder,
  getAccessPolicyDecoder: () => getAccessPolicyDecoder,
  getAccessPolicyCodec: () => getAccessPolicyCodec,
  getAccessAuditConfigEncoder: () => getAccessAuditConfigEncoder,
  getAccessAuditConfigDecoder: () => getAccessAuditConfigDecoder,
  getAccessAuditConfigCodec: () => getAccessAuditConfigCodec,
  fetchUserRegistry: () => fetchUserRegistry,
  fetchStakingConfig: () => fetchStakingConfig,
  fetchStakingAccount: () => fetchStakingAccount,
  fetchReputationMetrics: () => fetchReputationMetrics,
  fetchReentrancyGuard: () => fetchReentrancyGuard,
  fetchRbacConfig: () => fetchRbacConfig,
  fetchProtocolConfig: () => fetchProtocolConfig,
  fetchMultisig: () => fetchMultisig,
  fetchMaybeUserRegistry: () => fetchMaybeUserRegistry,
  fetchMaybeStakingConfig: () => fetchMaybeStakingConfig,
  fetchMaybeStakingAccount: () => fetchMaybeStakingAccount,
  fetchMaybeReputationMetrics: () => fetchMaybeReputationMetrics,
  fetchMaybeReentrancyGuard: () => fetchMaybeReentrancyGuard,
  fetchMaybeRbacConfig: () => fetchMaybeRbacConfig,
  fetchMaybeProtocolConfig: () => fetchMaybeProtocolConfig,
  fetchMaybeMultisig: () => fetchMaybeMultisig,
  fetchMaybeGovernanceProposal: () => fetchMaybeGovernanceProposal,
  fetchMaybeGhostProtectEscrow: () => fetchMaybeGhostProtectEscrow,
  fetchMaybeDidDocument: () => fetchMaybeDidDocument,
  fetchMaybeCredentialType: () => fetchMaybeCredentialType,
  fetchMaybeCredentialTemplate: () => fetchMaybeCredentialTemplate,
  fetchMaybeCredential: () => fetchMaybeCredential,
  fetchMaybeComplianceReport: () => fetchMaybeComplianceReport,
  fetchMaybeAuthorizationUsageRecord: () => fetchMaybeAuthorizationUsageRecord,
  fetchMaybeAuditTrail: () => fetchMaybeAuditTrail,
  fetchMaybeAgentVerification: () => fetchMaybeAgentVerification,
  fetchMaybeAgentTreeConfig: () => fetchMaybeAgentTreeConfig,
  fetchMaybeAgentReputationAuth: () => fetchMaybeAgentReputationAuth,
  fetchMaybeAgent: () => fetchMaybeAgent,
  fetchGovernanceProposal: () => fetchGovernanceProposal,
  fetchGhostProtectEscrow: () => fetchGhostProtectEscrow,
  fetchDidDocument: () => fetchDidDocument,
  fetchCredentialType: () => fetchCredentialType,
  fetchCredentialTemplate: () => fetchCredentialTemplate,
  fetchCredential: () => fetchCredential,
  fetchComplianceReport: () => fetchComplianceReport,
  fetchAuthorizationUsageRecord: () => fetchAuthorizationUsageRecord,
  fetchAuditTrail: () => fetchAuditTrail,
  fetchAllUserRegistry: () => fetchAllUserRegistry,
  fetchAllStakingConfig: () => fetchAllStakingConfig,
  fetchAllStakingAccount: () => fetchAllStakingAccount,
  fetchAllReputationMetrics: () => fetchAllReputationMetrics,
  fetchAllReentrancyGuard: () => fetchAllReentrancyGuard,
  fetchAllRbacConfig: () => fetchAllRbacConfig,
  fetchAllProtocolConfig: () => fetchAllProtocolConfig,
  fetchAllMultisig: () => fetchAllMultisig,
  fetchAllMaybeUserRegistry: () => fetchAllMaybeUserRegistry,
  fetchAllMaybeStakingConfig: () => fetchAllMaybeStakingConfig,
  fetchAllMaybeStakingAccount: () => fetchAllMaybeStakingAccount,
  fetchAllMaybeReputationMetrics: () => fetchAllMaybeReputationMetrics,
  fetchAllMaybeReentrancyGuard: () => fetchAllMaybeReentrancyGuard,
  fetchAllMaybeRbacConfig: () => fetchAllMaybeRbacConfig,
  fetchAllMaybeProtocolConfig: () => fetchAllMaybeProtocolConfig,
  fetchAllMaybeMultisig: () => fetchAllMaybeMultisig,
  fetchAllMaybeGovernanceProposal: () => fetchAllMaybeGovernanceProposal,
  fetchAllMaybeGhostProtectEscrow: () => fetchAllMaybeGhostProtectEscrow,
  fetchAllMaybeDidDocument: () => fetchAllMaybeDidDocument,
  fetchAllMaybeCredentialType: () => fetchAllMaybeCredentialType,
  fetchAllMaybeCredentialTemplate: () => fetchAllMaybeCredentialTemplate,
  fetchAllMaybeCredential: () => fetchAllMaybeCredential,
  fetchAllMaybeComplianceReport: () => fetchAllMaybeComplianceReport,
  fetchAllMaybeAuthorizationUsageRecord: () => fetchAllMaybeAuthorizationUsageRecord,
  fetchAllMaybeAuditTrail: () => fetchAllMaybeAuditTrail,
  fetchAllMaybeAgentVerification: () => fetchAllMaybeAgentVerification,
  fetchAllMaybeAgentTreeConfig: () => fetchAllMaybeAgentTreeConfig,
  fetchAllMaybeAgentReputationAuth: () => fetchAllMaybeAgentReputationAuth,
  fetchAllMaybeAgent: () => fetchAllMaybeAgent,
  fetchAllGovernanceProposal: () => fetchAllGovernanceProposal,
  fetchAllGhostProtectEscrow: () => fetchAllGhostProtectEscrow,
  fetchAllDidDocument: () => fetchAllDidDocument,
  fetchAllCredentialType: () => fetchAllCredentialType,
  fetchAllCredentialTemplate: () => fetchAllCredentialTemplate,
  fetchAllCredential: () => fetchAllCredential,
  fetchAllComplianceReport: () => fetchAllComplianceReport,
  fetchAllAuthorizationUsageRecord: () => fetchAllAuthorizationUsageRecord,
  fetchAllAuditTrail: () => fetchAllAuditTrail,
  fetchAllAgentVerification: () => fetchAllAgentVerification,
  fetchAllAgentTreeConfig: () => fetchAllAgentTreeConfig,
  fetchAllAgentReputationAuth: () => fetchAllAgentReputationAuth,
  fetchAllAgent: () => fetchAllAgent,
  fetchAgentVerification: () => fetchAgentVerification,
  fetchAgentTreeConfig: () => fetchAgentTreeConfig,
  fetchAgentReputationAuth: () => fetchAgentReputationAuth,
  fetchAgent: () => fetchAgent,
  delegationScope: () => delegationScope,
  decodeUserRegistry: () => decodeUserRegistry,
  decodeStakingConfig: () => decodeStakingConfig,
  decodeStakingAccount: () => decodeStakingAccount,
  decodeReputationMetrics: () => decodeReputationMetrics,
  decodeReentrancyGuard: () => decodeReentrancyGuard,
  decodeRbacConfig: () => decodeRbacConfig,
  decodeProtocolConfig: () => decodeProtocolConfig,
  decodeMultisig: () => decodeMultisig,
  decodeGovernanceProposal: () => decodeGovernanceProposal,
  decodeGhostProtectEscrow: () => decodeGhostProtectEscrow,
  decodeDidDocument: () => decodeDidDocument,
  decodeCredentialType: () => decodeCredentialType,
  decodeCredentialTemplate: () => decodeCredentialTemplate,
  decodeCredential: () => decodeCredential,
  decodeComplianceReport: () => decodeComplianceReport,
  decodeAuthorizationUsageRecord: () => decodeAuthorizationUsageRecord,
  decodeAuditTrail: () => decodeAuditTrail,
  decodeAgentVerification: () => decodeAgentVerification,
  decodeAgentTreeConfig: () => decodeAgentTreeConfig,
  decodeAgentReputationAuth: () => decodeAgentReputationAuth,
  decodeAgent: () => decodeAgent,
  arbitratorDecision: () => arbitratorDecision,
  VoteChoice: () => VoteChoice,
  ViolationSeverity: () => ViolationSeverity,
  VerificationRelationship: () => VerificationRelationship,
  VerificationMethodType: () => VerificationMethodType,
  ValueType: () => ValueType,
  VERIFY_AUTHORIZATION_DISCRIMINATOR: () => VERIFY_AUTHORIZATION_DISCRIMINATOR,
  VERIFY_AGENT_DISCRIMINATOR: () => VERIFY_AGENT_DISCRIMINATOR,
  UnlockMethod: () => UnlockMethod,
  USER_REGISTRY_DISCRIMINATOR: () => USER_REGISTRY_DISCRIMINATOR,
  UPDATE_SOURCE_REPUTATION_DISCRIMINATOR: () => UPDATE_SOURCE_REPUTATION_DISCRIMINATOR,
  UPDATE_REPUTATION_WITH_AUTH_DISCRIMINATOR: () => UPDATE_REPUTATION_WITH_AUTH_DISCRIMINATOR,
  UPDATE_REPUTATION_TAGS_DISCRIMINATOR: () => UPDATE_REPUTATION_TAGS_DISCRIMINATOR,
  UPDATE_PROTOCOL_CONFIG_DISCRIMINATOR: () => UPDATE_PROTOCOL_CONFIG_DISCRIMINATOR,
  UPDATE_DID_DOCUMENT_DISCRIMINATOR: () => UPDATE_DID_DOCUMENT_DISCRIMINATOR,
  UPDATE_CROSSCHAIN_STATUS_DISCRIMINATOR: () => UPDATE_CROSSCHAIN_STATUS_DISCRIMINATOR,
  UPDATE_AGENT_SERVICE_DISCRIMINATOR: () => UPDATE_AGENT_SERVICE_DISCRIMINATOR,
  UPDATE_AGENT_REPUTATION_DISCRIMINATOR: () => UPDATE_AGENT_REPUTATION_DISCRIMINATOR,
  UPDATE_AGENT_DISCRIMINATOR: () => UPDATE_AGENT_DISCRIMINATOR,
  UNSTAKE_GHOST_DISCRIMINATOR: () => UNSTAKE_GHOST_DISCRIMINATOR,
  TrendDirection: () => TrendDirection,
  TransactionType: () => TransactionType,
  TransactionStatus: () => TransactionStatus,
  TransactionPriority: () => TransactionPriority,
  TimeLockType: () => TimeLockType,
  StepUpTrigger: () => StepUpTrigger,
  SodConstraintType: () => SodConstraintType,
  SlashReason: () => SlashReason,
  ServiceEndpointType: () => ServiceEndpointType,
  SecurityEventType: () => SecurityEventType,
  ScopeType: () => ScopeType,
  ScopeInheritance: () => ScopeInheritance,
  SUBMIT_SERVICE_RATING_DISCRIMINATOR: () => SUBMIT_SERVICE_RATING_DISCRIMINATOR,
  SUBMIT_DELIVERY_DISCRIMINATOR: () => SUBMIT_DELIVERY_DISCRIMINATOR,
  STAKING_CONFIG_DISCRIMINATOR: () => STAKING_CONFIG_DISCRIMINATOR,
  STAKING_ACCOUNT_DISCRIMINATOR: () => STAKING_ACCOUNT_DISCRIMINATOR,
  STAKE_GHOST_DISCRIMINATOR: () => STAKE_GHOST_DISCRIMINATOR,
  SLASH_STAKE_DISCRIMINATOR: () => SLASH_STAKE_DISCRIMINATOR,
  RuleEffect: () => RuleEffect,
  RoleType: () => RoleType,
  RoleStatus: () => RoleStatus,
  RiskLevel: () => RiskLevel,
  RiskCategory: () => RiskCategory,
  ReportingFrequency: () => ReportingFrequency,
  ReportType: () => ReportType,
  ReportStatus: () => ReportStatus,
  ReentrancyState: () => ReentrancyState,
  REVOKE_CREDENTIAL_DISCRIMINATOR: () => REVOKE_CREDENTIAL_DISCRIMINATOR,
  REVOKE_AUTHORIZATION_DISCRIMINATOR: () => REVOKE_AUTHORIZATION_DISCRIMINATOR,
  RESOLVE_DID_DOCUMENT_DISCRIMINATOR: () => RESOLVE_DID_DOCUMENT_DISCRIMINATOR,
  RESET_REENTRANCY_GUARD_DISCRIMINATOR: () => RESET_REENTRANCY_GUARD_DISCRIMINATOR,
  REPUTATION_METRICS_DISCRIMINATOR: () => REPUTATION_METRICS_DISCRIMINATOR,
  REGISTER_AGENT_DISCRIMINATOR: () => REGISTER_AGENT_DISCRIMINATOR,
  REGISTER_AGENT_COMPRESSED_DISCRIMINATOR: () => REGISTER_AGENT_COMPRESSED_DISCRIMINATOR,
  REENTRANCY_GUARD_DISCRIMINATOR: () => REENTRANCY_GUARD_DISCRIMINATOR,
  RECORD_PAYAI_PAYMENT_DISCRIMINATOR: () => RECORD_PAYAI_PAYMENT_DISCRIMINATOR,
  RBAC_CONFIG_DISCRIMINATOR: () => RBAC_CONFIG_DISCRIMINATOR,
  QuorumMethod: () => QuorumMethod,
  ProposalType: () => ProposalType,
  ProposalStatus: () => ProposalStatus,
  PricingModel: () => PricingModel,
  PolicyType: () => PolicyType,
  PolicyStatus: () => PolicyStatus,
  PermissionConstraintType: () => PermissionConstraintType,
  PROTOCOL_CONFIG_DISCRIMINATOR: () => PROTOCOL_CONFIG_DISCRIMINATOR,
  NotificationTiming: () => NotificationTiming,
  NotificationTargetType: () => NotificationTargetType,
  NotificationPriority: () => NotificationPriority,
  NotificationMethod: () => NotificationMethod,
  MultisigType: () => MultisigType,
  MULTISIG_DISCRIMINATOR: () => MULTISIG_DISCRIMINATOR,
  MANAGE_AGENT_STATUS_DISCRIMINATOR: () => MANAGE_AGENT_STATUS_DISCRIMINATOR,
  ISSUE_CREDENTIAL_DISCRIMINATOR: () => ISSUE_CREDENTIAL_DISCRIMINATOR,
  INIT_REENTRANCY_GUARD_DISCRIMINATOR: () => INIT_REENTRANCY_GUARD_DISCRIMINATOR,
  INITIALIZE_STAKING_CONFIG_DISCRIMINATOR: () => INITIALIZE_STAKING_CONFIG_DISCRIMINATOR,
  INITIALIZE_REPUTATION_METRICS_DISCRIMINATOR: () => INITIALIZE_REPUTATION_METRICS_DISCRIMINATOR,
  INITIALIZE_RBAC_CONFIG_DISCRIMINATOR: () => INITIALIZE_RBAC_CONFIG_DISCRIMINATOR,
  INITIALIZE_PROTOCOL_CONFIG_DISCRIMINATOR: () => INITIALIZE_PROTOCOL_CONFIG_DISCRIMINATOR,
  INITIALIZE_GOVERNANCE_PROPOSAL_DISCRIMINATOR: () => INITIALIZE_GOVERNANCE_PROPOSAL_DISCRIMINATOR,
  INITIALIZE_AUDIT_TRAIL_DISCRIMINATOR: () => INITIALIZE_AUDIT_TRAIL_DISCRIMINATOR,
  GhostspeakMarketplaceInstruction: () => GhostspeakMarketplaceInstruction,
  GhostspeakMarketplaceAccount: () => GhostspeakMarketplaceAccount,
  GOVERNANCE_PROPOSAL_DISCRIMINATOR: () => GOVERNANCE_PROPOSAL_DISCRIMINATOR,
  GHOST_PROTECT_ESCROW_DISCRIMINATOR: () => GHOST_PROTECT_ESCROW_DISCRIMINATOR,
  GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS: () => GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS,
  GHOSTSPEAK_MARKETPLACE_ERROR__UNAUTHORIZED_DID_OPERATION: () => GHOSTSPEAK_MARKETPLACE_ERROR__UNAUTHORIZED_DID_OPERATION,
  GHOSTSPEAK_MARKETPLACE_ERROR__TOO_MANY_VERIFICATION_METHODS: () => GHOSTSPEAK_MARKETPLACE_ERROR__TOO_MANY_VERIFICATION_METHODS,
  GHOSTSPEAK_MARKETPLACE_ERROR__TOO_MANY_SERVICE_ENDPOINTS: () => GHOSTSPEAK_MARKETPLACE_ERROR__TOO_MANY_SERVICE_ENDPOINTS,
  GHOSTSPEAK_MARKETPLACE_ERROR__SERVICE_NOT_FOUND: () => GHOSTSPEAK_MARKETPLACE_ERROR__SERVICE_NOT_FOUND,
  GHOSTSPEAK_MARKETPLACE_ERROR__METHOD_NOT_FOUND: () => GHOSTSPEAK_MARKETPLACE_ERROR__METHOD_NOT_FOUND,
  GHOSTSPEAK_MARKETPLACE_ERROR__INVALID_DID_FORMAT: () => GHOSTSPEAK_MARKETPLACE_ERROR__INVALID_DID_FORMAT,
  GHOSTSPEAK_MARKETPLACE_ERROR__DUPLICATE_SERVICE_ID: () => GHOSTSPEAK_MARKETPLACE_ERROR__DUPLICATE_SERVICE_ID,
  GHOSTSPEAK_MARKETPLACE_ERROR__DUPLICATE_METHOD_ID: () => GHOSTSPEAK_MARKETPLACE_ERROR__DUPLICATE_METHOD_ID,
  GHOSTSPEAK_MARKETPLACE_ERROR__DID_DEACTIVATED: () => GHOSTSPEAK_MARKETPLACE_ERROR__DID_DEACTIVATED,
  GHOSTSPEAK_MARKETPLACE_ERROR__ALREADY_DEACTIVATED: () => GHOSTSPEAK_MARKETPLACE_ERROR__ALREADY_DEACTIVATED,
  GENERATE_COMPLIANCE_REPORT_DISCRIMINATOR: () => GENERATE_COMPLIANCE_REPORT_DISCRIMINATOR,
  FILE_DISPUTE_DISCRIMINATOR: () => FILE_DISPUTE_DISCRIMINATOR,
  EscrowStatus: () => EscrowStatus,
  EnforcementLevel: () => EnforcementLevel,
  ENABLE_PROTOCOL_FEES_DISCRIMINATOR: () => ENABLE_PROTOCOL_FEES_DISCRIMINATOR,
  DegradationHandling: () => DegradationHandling,
  DataAccessLevel: () => DataAccessLevel,
  DID_DOCUMENT_DISCRIMINATOR: () => DID_DOCUMENT_DISCRIMINATOR,
  DEACTIVATE_DID_DOCUMENT_DISCRIMINATOR: () => DEACTIVATE_DID_DOCUMENT_DISCRIMINATOR,
  DEACTIVATE_CREDENTIAL_TYPE_DISCRIMINATOR: () => DEACTIVATE_CREDENTIAL_TYPE_DISCRIMINATOR,
  DEACTIVATE_CREDENTIAL_TEMPLATE_DISCRIMINATOR: () => DEACTIVATE_CREDENTIAL_TEMPLATE_DISCRIMINATOR,
  DEACTIVATE_AGENT_DISCRIMINATOR: () => DEACTIVATE_AGENT_DISCRIMINATOR,
  CrossChainStatus: () => CrossChainStatus,
  CredentialStatus: () => CredentialStatus,
  CredentialKind: () => CredentialKind,
  ConstraintOperator: () => ConstraintOperator,
  ConditionType: () => ConditionType,
  CREDENTIAL_TYPE_DISCRIMINATOR: () => CREDENTIAL_TYPE_DISCRIMINATOR,
  CREDENTIAL_TEMPLATE_DISCRIMINATOR: () => CREDENTIAL_TEMPLATE_DISCRIMINATOR,
  CREDENTIAL_DISCRIMINATOR: () => CREDENTIAL_DISCRIMINATOR,
  CREATE_MULTISIG_DISCRIMINATOR: () => CREATE_MULTISIG_DISCRIMINATOR,
  CREATE_ESCROW_DISCRIMINATOR: () => CREATE_ESCROW_DISCRIMINATOR,
  CREATE_DID_DOCUMENT_DISCRIMINATOR: () => CREATE_DID_DOCUMENT_DISCRIMINATOR,
  CREATE_CREDENTIAL_TYPE_DISCRIMINATOR: () => CREATE_CREDENTIAL_TYPE_DISCRIMINATOR,
  CREATE_CREDENTIAL_TEMPLATE_DISCRIMINATOR: () => CREATE_CREDENTIAL_TEMPLATE_DISCRIMINATOR,
  CREATE_AGENT_AUTHORIZATION_DISCRIMINATOR: () => CREATE_AGENT_AUTHORIZATION_DISCRIMINATOR,
  COMPLIANCE_REPORT_DISCRIMINATOR: () => COMPLIANCE_REPORT_DISCRIMINATOR,
  BiometricType: () => BiometricType,
  BiometricStorageMethod: () => BiometricStorageMethod,
  BackupFrequency: () => BackupFrequency,
  AuthenticationMethod: () => AuthenticationMethod,
  AuthenticationLevel: () => AuthenticationLevel,
  AuditAction: () => AuditAction,
  ActivationRequirementType: () => ActivationRequirementType,
  ActionType: () => ActionType,
  AccessTier: () => AccessTier,
  AUTHORIZATION_USAGE_RECORD_DISCRIMINATOR: () => AUTHORIZATION_USAGE_RECORD_DISCRIMINATOR,
  AUDIT_TRAIL_DISCRIMINATOR: () => AUDIT_TRAIL_DISCRIMINATOR,
  ARBITRATE_DISPUTE_DISCRIMINATOR: () => ARBITRATE_DISPUTE_DISCRIMINATOR,
  APPROVE_DELIVERY_DISCRIMINATOR: () => APPROVE_DELIVERY_DISCRIMINATOR,
  AGENT_VERIFICATION_DISCRIMINATOR: () => AGENT_VERIFICATION_DISCRIMINATOR,
  AGENT_TREE_CONFIG_DISCRIMINATOR: () => AGENT_TREE_CONFIG_DISCRIMINATOR,
  AGENT_REPUTATION_AUTH_DISCRIMINATOR: () => AGENT_REPUTATION_AUTH_DISCRIMINATOR,
  AGENT_DISCRIMINATOR: () => AGENT_DISCRIMINATOR,
  ACTIVATE_AGENT_DISCRIMINATOR: () => ACTIVATE_AGENT_DISCRIMINATOR
});
var init_generated_EG5USUFG = __esm(() => {
  init_chunk_S74EH3KD();
  init_chunk_IHVDQ4YI();
  init_chunk_SFTSZ3LC();
  init_chunk_JV2SWONF();
  init_chunk_KB6CKIUK();
  init_chunk_AL3HQN73();
  init_chunk_UP2VWCW5();
});

// ../packages/sdk-typescript/dist/batch-operations-45CQFEID.js
var exports_batch_operations_45CQFEID = {};
__export(exports_batch_operations_45CQFEID, {
  createBatchFetcher: () => createBatchFetcher,
  batchGetExistingAccounts: () => batchGetExistingAccounts,
  batchGetAndMap: () => batchGetAndMap,
  batchGetAccountsWithRetry: () => batchGetAccountsWithRetry,
  batchGetAccounts: () => batchGetAccounts
});
var init_batch_operations_45CQFEID = __esm(() => {
  init_chunk_SKMJJ3Q6();
  init_chunk_UP2VWCW5();
});

// ../packages/sdk-typescript/dist/chunk-BF3IQ35I.js
async function deriveAgentPdaOriginal(programId, owner, agentId) {
  const [address2] = await getProgramDerivedAddress({
    programAddress: programId,
    seeds: [
      getBytesEncoder().encode(new Uint8Array([97, 103, 101, 110, 116])),
      getAddressEncoder().encode(owner),
      getUtf8Encoder().encode(agentId)
    ]
  });
  return address2;
}
async function deriveAgentPda(params) {
  const [address2, bump] = await getProgramDerivedAddress({
    programAddress: params.programAddress,
    seeds: [
      getBytesEncoder().encode(new Uint8Array([97, 103, 101, 110, 116])),
      getAddressEncoder().encode(params.owner),
      getUtf8Encoder().encode(params.agentId)
    ]
  });
  return [address2, bump];
}
async function deriveA2ASessionPdaOriginal(programId, creator) {
  const [address2] = await getProgramDerivedAddress({
    programAddress: programId,
    seeds: [
      getBytesEncoder().encode(new Uint8Array([
        97,
        50,
        97,
        95,
        115,
        101,
        115,
        115,
        105,
        111,
        110
      ])),
      getAddressEncoder().encode(creator)
    ]
  });
  return address2;
}
async function deriveA2ASessionPda(params) {
  const result = await getProgramDerivedAddress({
    programAddress: params.programAddress,
    seeds: [
      getBytesEncoder().encode(new Uint8Array([
        97,
        50,
        97,
        95,
        115,
        101,
        115,
        115,
        105,
        111,
        110
      ])),
      getAddressEncoder().encode(params.initiator)
    ]
  });
  return [result[0], result[1]];
}
async function deriveA2AMessagePda(programId, session, sessionCreatedAt) {
  const createdAtBytes = new Uint8Array(8);
  const dataView = new DataView(createdAtBytes.buffer);
  dataView.setBigInt64(0, sessionCreatedAt, true);
  const [address2] = await getProgramDerivedAddress({
    programAddress: programId,
    seeds: [
      getBytesEncoder().encode(new Uint8Array([
        97,
        50,
        97,
        95,
        109,
        101,
        115,
        115,
        97,
        103,
        101
      ])),
      getAddressEncoder().encode(session),
      createdAtBytes
    ]
  });
  return address2;
}
async function deriveUserRegistryPda(programId, signer) {
  const [address2] = await getProgramDerivedAddress({
    programAddress: programId,
    seeds: [
      getBytesEncoder().encode(new Uint8Array([
        117,
        115,
        101,
        114,
        95,
        114,
        101,
        103,
        105,
        115,
        116,
        114,
        121
      ])),
      getAddressEncoder().encode(signer)
    ]
  });
  return address2;
}
async function deriveAgentVerificationPda(programId, agent, verifier) {
  const [address2] = await getProgramDerivedAddress({
    programAddress: programId,
    seeds: [
      getBytesEncoder().encode(new Uint8Array([
        97,
        103,
        101,
        110,
        116,
        95,
        118,
        101,
        114,
        105,
        102,
        105,
        99,
        97,
        116,
        105,
        111,
        110
      ])),
      getAddressEncoder().encode(agent),
      getAddressEncoder().encode(verifier)
    ]
  });
  return address2;
}
async function deriveAgentTreeConfigPda(programId, signer) {
  const [address2] = await getProgramDerivedAddress({
    programAddress: programId,
    seeds: [
      getBytesEncoder().encode(new Uint8Array([
        97,
        103,
        101,
        110,
        116,
        95,
        116,
        114,
        101,
        101,
        95,
        99,
        111,
        110,
        102,
        105,
        103
      ])),
      getAddressEncoder().encode(signer)
    ]
  });
  return address2;
}
async function findProgramDerivedAddress(seeds, programId) {
  const encodedSeeds = seeds.map((seed) => {
    if (typeof seed === "string") {
      return getUtf8Encoder().encode(seed);
    } else if (typeof seed === "object" && seed.constructor === Uint8Array) {
      return seed;
    } else {
      return getAddressEncoder().encode(seed);
    }
  });
  const result = await getProgramDerivedAddress({
    programAddress: programId,
    seeds: encodedSeeds
  });
  return [result[0], result[1]];
}
async function deriveEscrowPDAOriginal(workOrder, programId) {
  const seeds = [
    getBytesEncoder().encode(new Uint8Array([101, 115, 99, 114, 111, 119])),
    getAddressEncoder().encode(workOrder)
  ];
  const result = await getProgramDerivedAddress({
    programAddress: programId,
    seeds
  });
  return [result[0], result[1]];
}
async function deriveEscrowPDA(params) {
  const seeds = [
    getBytesEncoder().encode(new Uint8Array([101, 115, 99, 114, 111, 119])),
    getUtf8Encoder().encode(params.escrowId)
  ];
  const result = await getProgramDerivedAddress({
    programAddress: params.programAddress,
    seeds
  });
  return [result[0], result[1]];
}
async function deriveEscrowPda(programId, buyer, seller, nonce) {
  const nonceBytes = new Uint8Array(8);
  const dataView = new DataView(nonceBytes.buffer);
  dataView.setUint32(0, nonce, true);
  const [address2] = await getProgramDerivedAddress({
    programAddress: programId,
    seeds: [
      getBytesEncoder().encode(new Uint8Array([101, 115, 99, 114, 111, 119])),
      getAddressEncoder().encode(buyer),
      getAddressEncoder().encode(seller),
      nonceBytes.slice(0, 4)
    ]
  });
  return address2;
}
async function deriveTokenAccountPda(wallet, mint) {
  const ASSOCIATED_TOKEN_PROGRAM_ID = "ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL";
  const TOKEN_PROGRAM_ID = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  const [address2] = await getProgramDerivedAddress({
    programAddress: ASSOCIATED_TOKEN_PROGRAM_ID,
    seeds: [
      getAddressEncoder().encode(wallet),
      getAddressEncoder().encode(TOKEN_PROGRAM_ID),
      getAddressEncoder().encode(mint)
    ]
  });
  return address2;
}
async function deriveMessagePda(programId, channel, nonce) {
  const nonceBytes = new Uint8Array(4);
  const dataView = new DataView(nonceBytes.buffer);
  dataView.setUint32(0, nonce, true);
  const [address2] = await getProgramDerivedAddress({
    programAddress: programId,
    seeds: [
      getBytesEncoder().encode(new Uint8Array([
        109,
        101,
        115,
        115,
        97,
        103,
        101
      ])),
      getAddressEncoder().encode(channel),
      nonceBytes
    ]
  });
  return address2;
}
var init_chunk_BF3IQ35I = __esm(() => {
  init_index_node35();
});

// ../packages/sdk-typescript/dist/pda-4KP7CURF.js
var exports_pda_4KP7CURF = {};
__export(exports_pda_4KP7CURF, {
  findProgramDerivedAddress: () => findProgramDerivedAddress,
  deriveUserRegistryPda: () => deriveUserRegistryPda,
  deriveTokenAccountPda: () => deriveTokenAccountPda,
  deriveMessagePda: () => deriveMessagePda,
  deriveEscrowPda: () => deriveEscrowPda,
  deriveEscrowPDAOriginal: () => deriveEscrowPDAOriginal,
  deriveEscrowPDA: () => deriveEscrowPDA,
  deriveAgentVerificationPda: () => deriveAgentVerificationPda,
  deriveAgentTreeConfigPda: () => deriveAgentTreeConfigPda,
  deriveAgentPdaOriginal: () => deriveAgentPdaOriginal,
  deriveAgentPda: () => deriveAgentPda,
  deriveA2ASessionPdaOriginal: () => deriveA2ASessionPdaOriginal,
  deriveA2ASessionPda: () => deriveA2ASessionPda,
  deriveA2AMessagePda: () => deriveA2AMessagePda
});
var init_pda_4KP7CURF = __esm(() => {
  init_chunk_BF3IQ35I();
  init_chunk_UP2VWCW5();
});

// ../packages/sdk-typescript/dist/chunk-SZGFSCNU.js
import { EventEmitter } from "events";
function getSolanaExplorerUrl(signature2, cluster = "mainnet-beta") {
  const baseUrl = "https://explorer.solana.com/tx";
  switch (cluster) {
    case "devnet":
      return `${baseUrl}/${signature2}?cluster=devnet`;
    case "testnet":
      return `${baseUrl}/${signature2}?cluster=testnet`;
    case "localnet":
      return `${baseUrl}/${signature2}?cluster=custom&customUrl=http://localhost:8899`;
    default:
      return `${baseUrl}/${signature2}`;
  }
}
function getSolscanUrl(signature2, cluster = "mainnet-beta") {
  const baseUrl = "https://solscan.io/tx";
  switch (cluster) {
    case "devnet":
      return `${baseUrl}/${signature2}?cluster=devnet`;
    case "testnet":
      return `${baseUrl}/${signature2}?cluster=testnet`;
    case "localnet":
      return `Local transaction: ${signature2} (not viewable on Solscan)`;
    default:
      return `${baseUrl}/${signature2}`;
  }
}
function getSolanaFMUrl(signature2, cluster = "mainnet-beta") {
  const baseUrl = "https://solana.fm/tx";
  switch (cluster) {
    case "devnet":
      return `${baseUrl}/${signature2}?cluster=devnet-solana`;
    case "testnet":
      return `${baseUrl}/${signature2}?cluster=testnet-solana`;
    case "localnet":
      return `Local transaction: ${signature2} (not viewable on SolanaFM)`;
    default:
      return `${baseUrl}/${signature2}`;
  }
}
function getXrayUrl(signature2, cluster = "mainnet-beta") {
  const baseUrl = "https://xray.helius.xyz/tx";
  switch (cluster) {
    case "devnet":
      return `${baseUrl}/${signature2}?network=devnet`;
    case "testnet":
      return `${baseUrl}/${signature2}?network=testnet`;
    case "localnet":
      return `Local transaction: ${signature2} (not viewable on XRAY)`;
    default:
      return `${baseUrl}/${signature2}`;
  }
}
function generateExplorerUrls(signature2, cluster = "mainnet-beta") {
  return {
    solanaExplorer: getSolanaExplorerUrl(signature2, cluster),
    solscan: getSolscanUrl(signature2, cluster),
    solanaFM: getSolanaFMUrl(signature2, cluster),
    xray: getXrayUrl(signature2, cluster)
  };
}
function createTransactionResult(signature2, cluster, commitment = "confirmed") {
  return {
    signature: signature2,
    cluster,
    urls: generateExplorerUrls(signature2, cluster),
    commitment,
    timestamp: Date.now()
  };
}
function validateInstruction(instruction) {
  const inst = instruction;
  if (!inst.programAddress) {
    throw new Error("Invalid instruction format");
  }
}
function createIPFSUtils(config) {
  const finalConfig = {
    ...DEFAULT_IPFS_CONFIG,
    ...config,
    provider: {
      ...DEFAULT_IPFS_CONFIG.provider,
      ...config?.provider
    }
  };
  return new IPFSUtils(finalConfig);
}
function determineStorageMethod(content, options2) {
  if (options2?.forceInline)
    return "inline";
  if (options2?.forceIPFS)
    return "ipfs";
  const size = new TextEncoder().encode(content).length;
  const threshold = options2?.sizeThreshold ?? DEFAULT_IPFS_CONFIG.sizeThreshold ?? 800;
  return size > threshold ? "ipfs" : "inline";
}
async function createMetadataUri(metadata, ipfsUtils, options2) {
  const metadataJson = JSON.stringify(metadata);
  const storageMethod = determineStorageMethod(metadataJson, {
    forceIPFS: options2?.forceIPFS
  });
  if (storageMethod === "inline" || !ipfsUtils) {
    const encoded = Buffer.from(metadataJson).toString("base64");
    return `data:application/json;base64,${encoded}`;
  } else {
    const result = await ipfsUtils.client.storeContent(metadataJson, options2?.type ?? "custom", {
      filename: options2?.filename,
      contentType: "application/json"
    });
    return result.uri;
  }
}
async function deriveDidDocumentPda(programId, controller) {
  const [address2, bump] = await getProgramDerivedAddress({
    programAddress: programId,
    seeds: [
      new TextEncoder().encode(DID_DOCUMENT_SEED),
      getAddressEncoder().encode(controller)
    ]
  });
  return [address2, bump];
}
function generateDidString(network, pubkey) {
  const normalizedNetwork = network === "mainnet" ? "mainnet-beta" : network;
  return `did:sol:${normalizedNetwork}:${pubkey.toString()}`;
}
function validateDidString(did) {
  if (!did.startsWith("did:sol:")) {
    throw new DidErrorClass("InvalidDidFormat", 'DID must start with "did:sol:"');
  }
  const parts = did.split(":");
  if (parts.length !== 4) {
    throw new DidErrorClass("InvalidDidFormat", 'DID must have format "did:sol:network:identifier"');
  }
  const validNetworks = ["mainnet-beta", "devnet", "testnet", "localnet"];
  if (!validNetworks.includes(parts[2])) {
    throw new DidErrorClass("InvalidDidFormat", `Invalid network "${parts[2]}". Must be one of: ${validNetworks.join(", ")}`);
  }
  try {
    esm_default2.decode(parts[3]);
  } catch {
    throw new DidErrorClass("InvalidDidFormat", "DID identifier must be a valid base58-encoded Solana public key");
  }
}
function parseDidString(did) {
  validateDidString(did);
  const parts = did.split(":");
  return {
    method: parts[1],
    network: parts[2],
    identifier: parts[3]
  };
}
function exportAsW3CDidDocument(didDocument) {
  const verificationMethod = didDocument.verificationMethods.filter((m) => !m.revoked).map((method) => ({
    id: `${didDocument.did}#${method.id}`,
    type: method.methodType,
    controller: method.controller,
    publicKeyMultibase: method.publicKeyMultibase
  }));
  const authentication = didDocument.verificationMethods.filter((m) => !m.revoked && m.relationships.includes("authentication")).map((m) => `${didDocument.did}#${m.id}`);
  const assertionMethod = didDocument.verificationMethods.filter((m) => !m.revoked && m.relationships.includes("assertionMethod")).map((m) => `${didDocument.did}#${m.id}`);
  const keyAgreement = didDocument.verificationMethods.filter((m) => !m.revoked && m.relationships.includes("keyAgreement")).map((m) => `${didDocument.did}#${m.id}`);
  const capabilityInvocation = didDocument.verificationMethods.filter((m) => !m.revoked && m.relationships.includes("capabilityInvocation")).map((m) => `${didDocument.did}#${m.id}`);
  const capabilityDelegation = didDocument.verificationMethods.filter((m) => !m.revoked && m.relationships.includes("capabilityDelegation")).map((m) => `${didDocument.did}#${m.id}`);
  const service = didDocument.serviceEndpoints.map((endpoint) => ({
    id: `${didDocument.did}#${endpoint.id}`,
    type: endpoint.serviceType,
    serviceEndpoint: endpoint.serviceEndpoint,
    description: endpoint.description || undefined
  }));
  return {
    "@context": didDocument.context,
    id: didDocument.did,
    controller: didDocument.controller.toString(),
    verificationMethod,
    authentication: authentication.length > 0 ? authentication : undefined,
    assertionMethod: assertionMethod.length > 0 ? assertionMethod : undefined,
    keyAgreement: keyAgreement.length > 0 ? keyAgreement : undefined,
    capabilityInvocation: capabilityInvocation.length > 0 ? capabilityInvocation : undefined,
    capabilityDelegation: capabilityDelegation.length > 0 ? capabilityDelegation : undefined,
    service: service.length > 0 ? service : undefined,
    alsoKnownAs: didDocument.alsoKnownAs.length > 0 ? didDocument.alsoKnownAs : undefined
  };
}
function createEd25519VerificationMethod(id, controller, publicKey, relationships = ["authentication"]) {
  const publicKeyMultibase = `z${publicKey}`;
  return {
    id,
    methodType: "Ed25519VerificationKey2020",
    controller,
    publicKeyMultibase,
    relationships,
    createdAt: Math.floor(Date.now() / 1000),
    revoked: false
  };
}
function createServiceEndpoint(id, serviceType, serviceEndpoint, description = "") {
  return {
    id,
    serviceType,
    serviceEndpoint,
    description
  };
}
function isDidActive(didDocument) {
  return !didDocument.deactivated;
}
function getMethodsForRelationship(didDocument, relationship) {
  return didDocument.verificationMethods.filter((m) => !m.revoked && m.relationships.includes(relationship));
}
function canPerformAction(didDocument, publicKey, relationship) {
  if (publicKey.toString() === didDocument.controller.toString()) {
    return true;
  }
  const pubkeyMultibase = `z${publicKey.toString()}`;
  return didDocument.verificationMethods.some((method) => !method.revoked && method.publicKeyMultibase === pubkeyMultibase && method.relationships.includes(relationship));
}
function didDocumentToJson(didDocument, pretty = true) {
  const w3cDoc = exportAsW3CDidDocument(didDocument);
  return pretty ? JSON.stringify(w3cDoc, null, 2) : JSON.stringify(w3cDoc);
}
function getNetworkFromDid(did) {
  const parts = parseDidString(did);
  return parts.network;
}
function getIdentifierFromDid(did) {
  const parts = parseDidString(did);
  return parts.identifier;
}
function isPaymentRequired(response) {
  return response.status === 402;
}
async function extractPaymentRequirements(response) {
  const body = await response.text();
  try {
    const parsed = JSON.parse(body);
    if (parsed.accepts && Array.isArray(parsed.accepts)) {
      return parsed.accepts;
    }
    if (parsed.paymentRequirements && Array.isArray(parsed.paymentRequirements)) {
      return parsed.paymentRequirements;
    }
    if (parsed.scheme && parsed.payTo) {
      return [parsed];
    }
  } catch {}
  const paymentHeader = response.headers.get("x-payment-required");
  if (paymentHeader) {
    try {
      return JSON.parse(paymentHeader);
    } catch {}
  }
  return [];
}
function createPayAIClient(config) {
  return new PayAIClient(config);
}
async function payAIFetch(url, config, init) {
  const client = createPayAIClient(config);
  return client.fetch(url, init);
}
var MultiSourceAggregator_exports, MultiSourceAggregator, init_MultiSourceAggregator, RpcClient = class {
  rpc;
  rpcSubscriptions;
  commitment;
  endpoint;
  maxRetries;
  retryDelay;
  timeout;
  constructor(config) {
    this.endpoint = config.endpoint;
    this.rpc = createSolanaRpc(config.endpoint);
    this.commitment = config.commitment ?? "confirmed";
    this.maxRetries = config.maxRetries ?? 3;
    this.retryDelay = config.retryDelay ?? 1000;
    this.timeout = config.timeout ?? 60000;
    if (config.wsEndpoint) {
      this.rpcSubscriptions = createSolanaRpcSubscriptions(config.wsEndpoint);
    }
  }
  async getAccountInfo(address2, options2) {
    return this.withRetry(async () => {
      const result = await this.rpc.getAccountInfo(address2, {
        commitment: options2?.commitment ?? this.commitment,
        encoding: "base64"
      }).send();
      if (!result.value)
        return null;
      return this.parseAccountInfo(result.value);
    });
  }
  async getMultipleAccounts(addresses2, options2) {
    return this.withRetry(async () => {
      const result = await this.rpc.getMultipleAccounts(addresses2, {
        commitment: options2?.commitment ?? this.commitment,
        encoding: "base64"
      }).send();
      return result.value.map((account) => account ? this.parseAccountInfo(account) : null);
    });
  }
  async getProgramAccounts(programId, options2) {
    return this.withRetry(async () => {
      const result = await this.rpc.getProgramAccounts(programId, {
        commitment: options2?.commitment ?? this.commitment,
        encoding: "base64",
        filters: options2?.filters
      }).send();
      return result.map((item) => {
        const typedItem = item;
        return {
          pubkey: typedItem.pubkey,
          account: this.parseAccountInfo(typedItem.account)
        };
      });
    });
  }
  blockhashCache = null;
  async getLatestBlockhash() {
    const now = Date.now();
    if (this.blockhashCache && now - this.blockhashCache.timestamp < 1000) {
      return this.blockhashCache.value;
    }
    const result = await this.withRetry(async () => {
      const response = await this.rpc.getLatestBlockhash({
        commitment: this.commitment
      }).send();
      return {
        blockhash: response.value.blockhash,
        lastValidBlockHeight: BigInt(response.value.lastValidBlockHeight)
      };
    });
    this.blockhashCache = { value: result, timestamp: now };
    return result;
  }
  async sendTransaction(transaction, options2) {
    return this.withRetry(async () => {
      const result = await this.rpc.sendTransaction(transaction, {
        encoding: "base64",
        skipPreflight: options2?.skipPreflight ?? false,
        preflightCommitment: options2?.preflightCommitment ?? this.commitment,
        maxRetries: options2?.maxRetries ? BigInt(options2.maxRetries) : undefined
      }).send();
      return result;
    });
  }
  async getSignatureStatuses(signatures) {
    return this.withRetry(async () => {
      const result = await this.rpc.getSignatureStatuses(signatures).send();
      return result.value.map((status) => {
        if (!status)
          return null;
        const typedStatus = status;
        return {
          slot: typedStatus.slot,
          confirmations: typedStatus.confirmations,
          err: typedStatus.err,
          confirmationStatus: typedStatus.confirmationStatus
        };
      });
    });
  }
  async simulateTransaction(transaction, options2) {
    return this.withRetry(async () => {
      const result = await this.rpc.simulateTransaction(transaction, {
        encoding: "base64",
        commitment: options2?.commitment ?? this.commitment,
        replaceRecentBlockhash: options2?.replaceRecentBlockhash ?? false
      }).send();
      return {
        err: result.value.err,
        logs: result.value.logs ?? [],
        unitsConsumed: result.value.unitsConsumed ? BigInt(result.value.unitsConsumed) : undefined,
        returnData: result.value.returnData
      };
    });
  }
  async getFeeForMessage(encodedMessage) {
    return this.withRetry(async () => {
      const result = await this.rpc.getFeeForMessage(encodedMessage, {
        commitment: this.commitment
      }).send();
      return result.value ? BigInt(result.value) : null;
    });
  }
  async isHealthy() {
    try {
      await this.rpc.getHealth().send();
      return true;
    } catch {
      return false;
    }
  }
  async getVersion() {
    const result = await this.rpc.getVersion().send();
    return result;
  }
  async subscribeToAccount(address2, callback) {
    if (!this.rpcSubscriptions) {
      throw new Error("WebSocket endpoint not configured");
    }
    console.warn("Account subscription is not fully implemented in this version");
    const intervalId = setInterval(async () => {
      try {
        const accountInfo = await this.getAccountInfo(address2);
        callback(accountInfo);
      } catch (error) {
        console.error("Subscription polling error:", error);
      }
    }, 5000);
    return () => {
      clearInterval(intervalId);
    };
  }
  async withRetry(operation, retries = this.maxRetries) {
    let lastError;
    for (let i = 0;i <= retries; i++) {
      try {
        return await operation();
      } catch (error) {
        lastError = error;
        if (i < retries) {
          await new Promise((resolve) => setTimeout(resolve, this.retryDelay * Math.pow(2, i)));
        }
      }
    }
    throw lastError;
  }
  parseAccountInfo(rawAccount) {
    const account = rawAccount;
    const dataArray = account.data;
    const base64Data = Array.isArray(dataArray) ? dataArray[0] : dataArray;
    return {
      executable: account.executable,
      lamports: typeof account.lamports === "number" ? lamports(BigInt(account.lamports)) : account.lamports,
      owner: account.owner,
      rentEpoch: account.rentEpoch !== undefined ? typeof account.rentEpoch === "number" ? BigInt(account.rentEpoch) : account.rentEpoch : BigInt(0),
      data: Buffer.from(base64Data, "base64"),
      space: account.space ? typeof account.space === "number" ? BigInt(account.space) : account.space : undefined
    };
  }
}, DevTools = class _DevTools {
  static instance = null;
  rpcClient;
  config;
  isDevelopment;
  logs = [];
  timings = /* @__PURE__ */ new Map;
  constructor(config) {
    this.config = config;
    this.rpcClient = new RpcClient({
      endpoint: config.rpcEndpoint ?? "https://api.devnet.solana.com",
      commitment: config.commitment
    });
    this.isDevelopment = true;
  }
  static getInstance(config) {
    if (!_DevTools.instance && config) {
      _DevTools.instance = new _DevTools(config);
    }
    if (!_DevTools.instance) {
      throw new Error("DevTools not initialized. Call with config first.");
    }
    return _DevTools.instance;
  }
  enableDevMode() {
    this.isDevelopment = true;
    console.log("\uD83D\uDEE0 GhostSpeak Development Mode Enabled");
    console.log("   - Transaction simulation before sending");
    console.log("   - Cost estimates for all operations");
    console.log("   - Enhanced error messages");
    console.log("   - Performance timing");
  }
  isDevMode() {
    return this.isDevelopment;
  }
  analyzeTransaction(instructions2) {
    const writableAccounts = /* @__PURE__ */ new Set;
    const readonlyAccounts = /* @__PURE__ */ new Set;
    const signers2 = /* @__PURE__ */ new Set;
    const warnings = [];
    let totalSize = 64;
    const instructionAnalyses = instructions2.map((instr, index) => {
      totalSize += 32;
      totalSize += (instr.accounts?.length ?? 0) * 32;
      totalSize += instr.data?.length ?? 0;
      const accounts2 = (instr.accounts ?? []).map((acc) => {
        const isWritable = acc.role.toString().includes("writable") || acc.role.toString().includes("WRITABLE") || acc.role === 1 || acc.role === 3;
        const isSigner = acc.role.toString().includes("signer") || acc.role.toString().includes("SIGNER") || typeof acc === "object" && "signer" in acc || acc.role === 3;
        if (isWritable) {
          writableAccounts.add(acc.address);
        } else {
          readonlyAccounts.add(acc.address);
        }
        if (isSigner) {
          signers2.add(acc.address);
        }
        return {
          address: acc.address,
          isWritable,
          isSigner,
          role: acc.role
        };
      });
      const humanReadable = this.getInstructionDescription(instr, index);
      return {
        index,
        programId: instr.programAddress,
        accountCount: accounts2.length,
        dataSize: instr.data?.length ?? 0,
        humanReadable,
        accounts: accounts2
      };
    });
    const estimatedComputeUnits = this.estimateComputeUnits(instructions2);
    const estimatedFee = this.estimateFee(estimatedComputeUnits, instructions2.length);
    if (totalSize > 1232) {
      warnings.push(`Transaction size (${totalSize} bytes) exceeds limit (1232 bytes)`);
    }
    if (signers2.size === 0) {
      warnings.push("No signers found in transaction");
    }
    if (estimatedComputeUnits > BigInt(1400000)) {
      warnings.push(`High compute usage: ${estimatedComputeUnits} units`);
    }
    return {
      instructions: instructionAnalyses,
      totalAccounts: writableAccounts.size + readonlyAccounts.size,
      signerCount: signers2.size,
      writableAccounts: Array.from(writableAccounts),
      readonlyAccounts: Array.from(readonlyAccounts),
      estimatedSize: totalSize,
      estimatedComputeUnits,
      estimatedFee,
      warnings
    };
  }
  getInstructionDescription(instruction, _index) {
    const programId = instruction.programAddress;
    if (programId === this.config.programId) {
      return this.decodeGhostSpeakInstruction(instruction);
    }
    if (programId === "11111111111111111111111111111111") {
      return "System Program: Transfer or Create Account";
    }
    if (programId === "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA") {
      return "Token Program: Token Operation";
    }
    if (programId === "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb") {
      return "Token-2022 Program: Advanced Token Operation";
    }
    return `Unknown Instruction`;
  }
  decodeGhostSpeakInstruction(instruction) {
    if (!instruction.data || instruction.data.length < 8) {
      return "GhostSpeak: Unknown Instruction";
    }
    const discriminator = Array.from(instruction.data.slice(0, 8)).map((b) => b.toString(16).padStart(2, "0")).join("");
    const instructionMap = {
      a8c5e109d3d1b8d5: "Register Agent",
      b7f3c8e0a2d4e9f1: "Create Escrow",
      c4d2f7a9b8e1c3f5: "Send Message",
      d9e8f2b5c1a7e4f8: "Create Channel"
    };
    return `GhostSpeak: ${instructionMap[discriminator] ?? "Custom Instruction"}`;
  }
  estimateComputeUnits(instructions2) {
    let totalUnits = BigInt(0);
    for (const instr of instructions2) {
      totalUnits += BigInt(200);
      totalUnits += BigInt((instr.accounts?.length ?? 0) * 150);
      totalUnits += BigInt((instr.data?.length ?? 0) * 10);
      if (instr.programAddress === this.config.programId) {
        totalUnits += BigInt(5000);
      }
    }
    return totalUnits;
  }
  estimateFee(computeUnits, instructionCount) {
    const baseFee = BigInt(5000);
    const computeFee = computeUnits * BigInt(5) / BigInt(1e6);
    const priorityFee = BigInt(instructionCount * 1000);
    return baseFee + computeFee + priorityFee;
  }
  log(message, data2) {
    if (!this.isDevelopment)
      return;
    const timestamp = (/* @__PURE__ */ new Date()).toISOString();
    const logEntry = `[${timestamp}] ${message}`;
    this.logs.push(logEntry);
    console.log(`\uD83D\uDD0D ${logEntry}`);
    if (data2) {
      console.log("   Data:", data2);
    }
  }
  startTiming(label) {
    if (!this.isDevelopment)
      return;
    const perfNow = typeof performance !== "undefined" ? performance.now() : Date.now();
    this.timings.set(label, perfNow);
  }
  endTiming(label) {
    if (!this.isDevelopment)
      return;
    const start = this.timings.get(label);
    if (!start)
      return;
    const perfNow = typeof performance !== "undefined" ? performance.now() : Date.now();
    const duration = perfNow - start;
    this.log(`${label} took ${duration.toFixed(2)}ms`);
    this.timings.delete(label);
  }
  formatTransaction(analysis) {
    const lines = [
      "\uD83D\uDCCB Transaction Analysis",
      "",
      `Instructions: ${analysis.instructions.length}`,
      `Total Accounts: ${analysis.totalAccounts}`,
      `Signers: ${analysis.signerCount}`,
      `Estimated Size: ${analysis.estimatedSize} bytes`,
      `Estimated Compute Units: ${analysis.estimatedComputeUnits.toLocaleString()}`,
      `Estimated Fee: ${(Number(analysis.estimatedFee) / 1e9).toFixed(6)} SOL`,
      ""
    ];
    lines.push("Instructions:");
    for (const instr of analysis.instructions) {
      lines.push(`  ${instr.index + 1}. ${instr.humanReadable}`);
      lines.push(`     Program: ${instr.programId.slice(0, 8)}...`);
      lines.push(`     Accounts: ${instr.accountCount}, Data: ${instr.dataSize} bytes`);
    }
    if (analysis.warnings.length > 0) {
      lines.push("");
      lines.push(" Warnings:");
      for (const warning of analysis.warnings) {
        lines.push(`  - ${warning}`);
      }
    }
    lines.push("");
    return lines.join(`
`);
  }
  exportLogs() {
    return [...this.logs];
  }
  clearLogs() {
    this.logs = [];
    this.timings.clear();
  }
}, InstructionBuilder = class {
  rpcClient;
  config;
  devTools;
  debugMode = false;
  constructor(config) {
    this.config = config;
    this.rpcClient = new RpcClient({
      endpoint: config.rpcEndpoint ?? "https://api.devnet.solana.com",
      wsEndpoint: config.wsEndpoint,
      commitment: config.commitment ?? "confirmed"
    });
    this.devTools = DevTools.getInstance(config);
  }
  async execute(instructionName, instructionGetter, signers2, options2) {
    const context = createErrorContext("execute", instructionName, signers2.map((s3) => ({ address: s3.address, name: "signer" })), { programId: this.config.programId });
    try {
      if (this.devTools.isDevMode()) {
        this.devTools.startTiming(instructionName);
      }
      const instruction = await Promise.resolve(instructionGetter());
      validateInstruction(instruction);
      if (this.debugMode || this.devTools.isDevMode()) {
        const analysis = this.devTools.analyzeTransaction([instruction]);
        console.log(this.devTools.formatTransaction(analysis));
        this.debugMode = false;
      }
      if (options2?.simulate) {
        return await this.simulateInstruction(instruction, signers2);
      }
      const latestBlockhashResult = await this.rpcClient.getLatestBlockhash();
      const latestBlockhash = {
        blockhash: latestBlockhashResult.blockhash,
        lastValidBlockHeight: latestBlockhashResult.lastValidBlockHeight
      };
      const transactionMessage = pipe(createTransactionMessage({ version: 0 }), (tx) => setTransactionMessageFeePayerSigner(signers2[0], tx), (tx) => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx), (tx) => appendTransactionMessageInstructions([instruction], tx));
      const signedTransaction = await signTransactionMessageWithSigners(transactionMessage);
      const signatureResult = await this.sendAndConfirm(signedTransaction, options2?.skipPreflight ?? false, options2?.maxRetries ?? 30);
      if (typeof signatureResult !== "string") {
        throw new Error("Transaction signature is not a string");
      }
      const signature2 = signatureResult;
      if (options2?.returnDetails) {
        const cluster = this.config.cluster ?? "devnet";
        const result = createTransactionResult(signature2, cluster, this.config.commitment ?? "confirmed");
        if (this.devTools.isDevMode()) {
          this.devTools.endTiming(instructionName);
        }
        return result;
      }
      if (this.devTools.isDevMode()) {
        this.devTools.endTiming(instructionName);
      }
      return signature2;
    } catch (error) {
      logEnhancedError(error, context);
      throw error;
    }
  }
  async executeBatch(batchName, instructionGetters, signers2, options2) {
    const context = createErrorContext("executeBatch", batchName, signers2.map((s3) => ({ address: s3.address, name: "signer" })), { programId: this.config.programId, instructionCount: instructionGetters.length });
    try {
      const instructions2 = await Promise.all(instructionGetters.map(async (getter, i) => {
        const instruction = await Promise.resolve(getter());
        try {
          validateInstruction(instruction);
          return instruction;
        } catch (error) {
          throw new Error(`Instruction ${i} in ${batchName}: ${error.message}`);
        }
      }));
      const estimatedSize = this.estimateTransactionSize(instructions2);
      if (estimatedSize > 1232) {
        throw new Error(`Transaction too large: ${estimatedSize} bytes (max: 1232)`);
      }
      if (options2?.simulate) {
        return await this.simulateBatch(instructions2, signers2);
      }
      const latestBlockhashResult = await this.rpcClient.getLatestBlockhash();
      const latestBlockhash = {
        blockhash: latestBlockhashResult.blockhash,
        lastValidBlockHeight: latestBlockhashResult.lastValidBlockHeight
      };
      const transactionMessage = pipe(createTransactionMessage({ version: 0 }), (tx) => setTransactionMessageFeePayerSigner(signers2[0], tx), (tx) => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx), (tx) => appendTransactionMessageInstructions(instructions2, tx));
      const signedTransaction = await signTransactionMessageWithSigners(transactionMessage);
      const signatureResult = await this.sendAndConfirm(signedTransaction, options2?.skipPreflight ?? false);
      if (typeof signatureResult !== "string") {
        throw new Error("Transaction signature is not a string");
      }
      const signature2 = signatureResult;
      if (options2?.returnDetails) {
        const cluster = this.config.cluster ?? "devnet";
        const result = createTransactionResult(signature2, cluster, this.config.commitment ?? "confirmed");
        if (this.devTools.isDevMode()) {
          this.devTools.endTiming(batchName);
        }
        return result;
      }
      if (this.devTools.isDevMode()) {
        this.devTools.endTiming(batchName);
      }
      return signature2;
    } catch (error) {
      logEnhancedError(error, context);
      throw error;
    }
  }
  async getAccount(address2, decoderImportName) {
    try {
      const accountInfo = await this.rpcClient.getAccountInfo(address2, {
        commitment: this.config.commitment
      });
      if (!accountInfo)
        return null;
      const generated = await Promise.resolve().then(() => (init_generated_EG5USUFG(), exports_generated_EG5USUFG));
      const decoderGetter = generated[decoderImportName];
      const decoder = decoderGetter();
      const rawData = this.extractRawData(accountInfo.data);
      return decoder.decode(rawData);
    } catch (error) {
      console.warn(`Failed to fetch account ${address2}:`, error);
      return null;
    }
  }
  async getAccounts(addresses2, decoderImportName) {
    try {
      const accounts2 = await this.rpcClient.getMultipleAccounts(addresses2, {
        commitment: this.config.commitment
      });
      const generated = await Promise.resolve().then(() => (init_generated_EG5USUFG(), exports_generated_EG5USUFG));
      const decoderGetter = generated[decoderImportName];
      const decoder = decoderGetter();
      return accounts2.map((accountInfo) => {
        if (!accountInfo)
          return null;
        try {
          const rawData = this.extractRawData(accountInfo.data);
          return decoder.decode(rawData);
        } catch {
          return null;
        }
      });
    } catch (error) {
      console.warn("Failed to fetch multiple accounts:", error);
      return addresses2.map(() => null);
    }
  }
  async getProgramAccounts(decoderImportName, filters) {
    try {
      const convertedFilters = filters?.map((filter) => {
        if ("dataSize" in filter) {
          return { dataSize: filter.dataSize };
        } else {
          const encoding = filter.memcmp.encoding ?? "base58";
          if (encoding === "base64") {
            return {
              memcmp: {
                offset: filter.memcmp.offset,
                bytes: filter.memcmp.bytes,
                encoding: "base64"
              }
            };
          } else {
            return {
              memcmp: {
                offset: filter.memcmp.offset,
                bytes: filter.memcmp.bytes,
                encoding: "base58"
              }
            };
          }
        }
      });
      const accounts2 = await this.rpcClient.getProgramAccounts(this.config.programId, {
        commitment: this.config.commitment,
        filters: convertedFilters ?? []
      });
      const generated = await Promise.resolve().then(() => (init_generated_EG5USUFG(), exports_generated_EG5USUFG));
      const decoderGetter = generated[decoderImportName];
      const decoder = decoderGetter();
      const decodedAccounts = [];
      for (const { pubkey, account } of accounts2) {
        try {
          const rawData = this.extractRawData(account.data);
          const decodedData = decoder.decode(rawData);
          decodedAccounts.push({ address: pubkey, data: decodedData });
        } catch {}
      }
      return decodedAccounts;
    } catch (error) {
      console.error("Failed to get program accounts:", error);
      return [];
    }
  }
  enableDebug() {
    this.debugMode = true;
    return this;
  }
  async debug(instructionName, instructionGetters) {
    this.devTools.log(`Debugging ${instructionName}`);
    const instructions2 = await Promise.all(instructionGetters.map(async (getter) => {
      const instruction = await Promise.resolve(getter());
      validateInstruction(instruction);
      return instruction;
    }));
    const analysis = this.devTools.analyzeTransaction(instructions2);
    console.log(this.devTools.formatTransaction(analysis));
    return analysis;
  }
  async explain(instructionName, instructionGetters) {
    const analysis = await this.debug(instructionName, instructionGetters);
    const lines = [
      `\uD83D\uDD0D Transaction: ${instructionName}`,
      "",
      "This transaction will:",
      ...analysis.instructions.map((instr, i) => `  ${i + 1}. ${instr.humanReadable}`),
      "",
      `Cost: ~${(Number(analysis.estimatedFee) / 1e9).toFixed(6)} SOL`,
      `Size: ${analysis.estimatedSize} bytes`,
      `Compute: ${analysis.estimatedComputeUnits.toLocaleString()} units`
    ];
    if (analysis.warnings.length > 0) {
      lines.push("", " Warnings:");
      lines.push(...analysis.warnings.map((w) => `  - ${w}`));
    }
    return lines.join(`
`);
  }
  async estimateCost(instructionGetters) {
    try {
      const instructions2 = await Promise.all(instructionGetters.map(async (getter) => {
        const instruction = await Promise.resolve(getter());
        validateInstruction(instruction);
        return instruction;
      }));
      const latestBlockhashResult = await this.rpcClient.getLatestBlockhash();
      const latestBlockhash = {
        blockhash: latestBlockhashResult.blockhash,
        lastValidBlockHeight: latestBlockhashResult.lastValidBlockHeight
      };
      const transactionMessage = pipe(createTransactionMessage({ version: 0 }), (tx) => setTransactionMessageFeePayer(this.config.defaultFeePayer, tx), (tx) => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx), (tx) => appendTransactionMessageInstructions(instructions2, tx));
      const compiledMessage = compileTransactionMessage(transactionMessage);
      const encodedMessage = Buffer.from(compiledMessage).toString("base64");
      const fee = await this.rpcClient.getFeeForMessage(encodedMessage);
      return BigInt(fee ?? 0);
    } catch {
      const baseFee = 5000n;
      const perInstructionFee = 1000n;
      return baseFee + BigInt(instructionGetters.length) * perInstructionFee;
    }
  }
  async sendAndConfirm(signedTransaction, skipPreflight, maxRetries = 30) {
    const wireTransaction = getBase64EncodedWireTransaction(signedTransaction);
    const signature2 = await this.rpcClient.sendTransaction(wireTransaction, {
      skipPreflight,
      preflightCommitment: this.config.commitment
    });
    console.log("\uD83D\uDD0D Transaction sent, signature:", signature2);
    console.log("\uD83D\uDD0D Signature length:", signature2.length);
    console.log("\uD83D\uDD0D Signature type:", typeof signature2);
    let confirmed = false;
    let attempts = 0;
    let currentDelay = 1000;
    const maxConfirmationTime = 30000;
    const startTime = Date.now();
    while (!confirmed && attempts < maxRetries && Date.now() - startTime < maxConfirmationTime) {
      try {
        console.log(`\uD83D\uDD0D Confirmation attempt ${attempts + 1}/${maxRetries}`);
        const statuses = await this.rpcClient.getSignatureStatuses([signature2]);
        if (statuses[0]) {
          console.log("\uD83D\uDD0D Status found:", statuses[0]);
          if (statuses[0].err) {
            throw new Error(`Transaction failed: ${JSON.stringify(statuses[0].err, (_, v) => typeof v === "bigint" ? v.toString() : v)}`);
          }
          const confirmationStatus = statuses[0].confirmationStatus;
          if (confirmationStatus === this.config.commitment || this.config.commitment === "confirmed" && confirmationStatus === "finalized") {
            confirmed = true;
            console.log(" Transaction confirmed via status check");
            break;
          }
        } else {
          console.log("\uD83D\uDD0D No status found, trying transaction details...");
          try {
            const { createSolanaRpc: createSolanaRpc2 } = await Promise.resolve().then(() => (init_index_node35(), exports_index_node3));
            const directRpc = createSolanaRpc2(this.config.rpcEndpoint ?? "https://api.devnet.solana.com");
            const transaction = await directRpc.getTransaction(signature2, {
              commitment: this.config.commitment ?? "confirmed",
              encoding: "json",
              maxSupportedTransactionVersion: 0
            }).send();
            if (transaction && transaction.meta) {
              if (transaction.meta.err) {
                throw new Error(`Transaction failed: ${JSON.stringify(transaction.meta.err, (_, v) => typeof v === "bigint" ? v.toString() : v)}`);
              }
              confirmed = true;
              console.log(" Transaction confirmed via direct lookup");
              break;
            }
          } catch {
            console.log("\uD83D\uDD0D Transaction details not yet available");
          }
        }
        attempts++;
        await new Promise((resolve) => setTimeout(resolve, currentDelay));
        currentDelay = Math.min(currentDelay * 1.5, 5000);
      } catch (error) {
        if (error instanceof Error && error.message.includes("Transaction failed")) {
          throw error;
        }
        console.log(`\uD83D\uDD0D Confirmation attempt failed:`, error.message);
        attempts++;
        await new Promise((resolve) => setTimeout(resolve, currentDelay * 2));
      }
    }
    if (!confirmed) {
      console.log("\uD83D\uDD0D Final confirmation attempt via transaction lookup...");
      try {
        const { createSolanaRpc: createSolanaRpc2 } = await Promise.resolve().then(() => (init_index_node35(), exports_index_node3));
        const directRpc = createSolanaRpc2(this.config.rpcEndpoint ?? "https://api.devnet.solana.com");
        const transaction = await directRpc.getTransaction(signature2, {
          commitment: this.config.commitment ?? "confirmed",
          encoding: "json",
          maxSupportedTransactionVersion: 0
        }).send();
        if (transaction && transaction.meta) {
          if (transaction.meta.err) {
            throw new Error(`Transaction failed: ${JSON.stringify(transaction.meta.err, (_, v) => typeof v === "bigint" ? v.toString() : v)}`);
          }
          console.log(" Transaction confirmed on final check - returning success");
          return signature2;
        }
      } catch (finalError) {
        console.log("\uD83D\uDD0D Final check failed:", finalError.message);
      }
      console.log(" Transaction confirmation timed out, but transaction was sent");
      console.log(`   Check status at: https://explorer.solana.com/tx/${signature2}?cluster=${this.config.cluster || "devnet"}`);
      return signature2;
    }
    return signature2;
  }
  async simulateInstruction(instruction, signers2) {
    const latestBlockhashResult = await this.rpcClient.getLatestBlockhash();
    const latestBlockhash = {
      blockhash: latestBlockhashResult.blockhash,
      lastValidBlockHeight: latestBlockhashResult.lastValidBlockHeight
    };
    const transactionMessage = pipe(createTransactionMessage({ version: 0 }), (tx) => setTransactionMessageFeePayerSigner(signers2[0], tx), (tx) => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx), (tx) => appendTransactionMessageInstructions([instruction], tx));
    const signedTransaction = await signTransactionMessageWithSigners(transactionMessage);
    const wireTransaction = getBase64EncodedWireTransaction(signedTransaction);
    return this.rpcClient.simulateTransaction(wireTransaction, {
      commitment: this.config.commitment,
      replaceRecentBlockhash: true
    });
  }
  async simulateBatch(instructions2, signers2) {
    const latestBlockhashResult = await this.rpcClient.getLatestBlockhash();
    const latestBlockhash = {
      blockhash: latestBlockhashResult.blockhash,
      lastValidBlockHeight: latestBlockhashResult.lastValidBlockHeight
    };
    const transactionMessage = pipe(createTransactionMessage({ version: 0 }), (tx) => setTransactionMessageFeePayerSigner(signers2[0], tx), (tx) => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx), (tx) => appendTransactionMessageInstructions(instructions2, tx));
    const signedTransaction = await signTransactionMessageWithSigners(transactionMessage);
    const wireTransaction = getBase64EncodedWireTransaction(signedTransaction);
    return this.rpcClient.simulateTransaction(wireTransaction, {
      commitment: this.config.commitment,
      replaceRecentBlockhash: true
    });
  }
  estimateTransactionSize(instructions2) {
    let totalSize = 64;
    for (const instruction of instructions2) {
      totalSize += 32;
      totalSize += (instruction.accounts?.length ?? 0) * 32;
      totalSize += instruction.data.length;
    }
    return totalSize;
  }
  extractRawData(data2) {
    if (Buffer.isBuffer(data2) || data2 instanceof Uint8Array) {
      return new Uint8Array(data2);
    }
    if (typeof data2 === "object" && data2 !== null && "data" in data2) {
      return Buffer.from(data2.data, "base64");
    }
    if (typeof data2 === "string") {
      return Buffer.from(data2, "base64");
    }
    throw new Error("Invalid account data format");
  }
  async createCommunicationSession(_params) {
    return {
      programAddress: this.config.programId,
      accounts: [],
      data: new Uint8Array(0)
    };
  }
  async sendCommunicationMessage(_sessionAddress, _params) {
    return {
      programAddress: this.config.programId,
      accounts: [],
      data: new Uint8Array(0)
    };
  }
  async updateParticipantStatus(_params) {
    return {
      programAddress: this.config.programId,
      accounts: [],
      data: new Uint8Array(0)
    };
  }
}, DEFAULT_TTLS, CacheManager = class {
  accountCache;
  pdaCache;
  config;
  ttls;
  constructor(config = {}) {
    this.config = {
      enabled: config.enabled ?? false,
      maxSize: config.maxSize ?? 1000,
      ttlOverrides: config.ttlOverrides ?? {}
    };
    this.ttls = {
      processed: config.ttlOverrides?.processed ?? DEFAULT_TTLS.processed,
      confirmed: config.ttlOverrides?.confirmed ?? DEFAULT_TTLS.confirmed,
      finalized: config.ttlOverrides?.finalized ?? DEFAULT_TTLS.finalized
    };
    this.accountCache = new LRUCache({
      max: this.config.maxSize,
      ttl: DEFAULT_TTLS.finalized
    });
    this.pdaCache = new LRUCache({
      max: this.config.maxSize
    });
  }
  isEnabled() {
    return this.config.enabled;
  }
  getAccount(address2, commitment, currentSlot) {
    if (!this.config.enabled)
      return;
    const key = `${address2}:${commitment}`;
    const entry = this.accountCache.get(key);
    if (!entry)
      return;
    if (currentSlot !== undefined && entry.slot < currentSlot) {
      this.accountCache.delete(key);
      return;
    }
    return entry.data;
  }
  setAccount(address2, data2, commitment, slot) {
    if (!this.config.enabled)
      return;
    const key = `${address2}:${commitment}`;
    const entry = {
      data: data2,
      slot,
      commitment,
      timestamp: Date.now()
    };
    this.accountCache.set(key, entry, {
      ttl: this.ttls[commitment]
    });
  }
  getPDA(seeds) {
    if (!this.config.enabled)
      return;
    return this.pdaCache.get(seeds);
  }
  setPDA(seeds, pda) {
    if (!this.config.enabled)
      return;
    this.pdaCache.set(seeds, pda);
  }
  invalidateAccount(address2, commitment) {
    if (!this.config.enabled)
      return;
    if (commitment) {
      this.accountCache.delete(`${address2}:${commitment}`);
    } else {
      ["processed", "confirmed", "finalized"].forEach((c) => {
        this.accountCache.delete(`${address2}:${c}`);
      });
    }
  }
  clear() {
    this.accountCache.clear();
    this.pdaCache.clear();
  }
  getStats() {
    return {
      accountCache: {
        size: this.accountCache.size,
        max: this.config.maxSize
      },
      pdaCache: {
        size: this.pdaCache.size,
        max: this.config.maxSize
      }
    };
  }
}, BaseModule = class {
  builder;
  config;
  logger;
  cacheManager;
  _debugMode = false;
  constructor(config) {
    this.config = config;
    this.builder = new InstructionBuilder(config);
    this.cacheManager = new CacheManager(config.cache);
    this.logger = config.logger;
  }
  debug() {
    this._debugMode = true;
    this.builder.enableDebug();
    return this;
  }
  async execute(instructionName, instructionGetter, signers2) {
    return this.builder.execute(instructionName, instructionGetter, signers2);
  }
  async executeWithDetails(instructionName, instructionGetter, signers2) {
    return this.builder.execute(instructionName, instructionGetter, signers2, { returnDetails: true });
  }
  async executeBatch(batchName, instructionGetters, signers2) {
    return this.builder.executeBatch(batchName, instructionGetters.map((getter) => () => Promise.resolve(getter())), signers2);
  }
  async simulate(instructionName, instructionGetter, signers2) {
    return this.builder.execute(instructionName, () => Promise.resolve(instructionGetter()), signers2, { simulate: true });
  }
  async simulateInstruction(instructionName, instructionGetter, signers2) {
    return this.simulate(instructionName, instructionGetter, signers2);
  }
  async estimateCost(instructionGetters) {
    return this.builder.estimateCost(instructionGetters);
  }
  async getCost(instructionName, instructionGetter) {
    return this.builder.estimateCost([instructionGetter]);
  }
  async explain(instructionName, instructionGetter) {
    return this.builder.explain(instructionName, [instructionGetter]);
  }
  async analyze(instructionName, instructionGetter) {
    return this.builder.debug(instructionName, [instructionGetter]);
  }
  async getAccount(address2, decoderImportName) {
    if (this.cacheManager.isEnabled()) {
      const cached = this.cacheManager.getAccount(address2, this.commitment);
      if (cached !== undefined) {
        this.logger?.info(`[Cache HIT] ${address2}`);
        return cached;
      }
    }
    const account = await this.builder.getAccount(address2, decoderImportName);
    if (this.cacheManager.isEnabled() && account !== null) {
      const slot = 0;
      this.cacheManager.setAccount(address2, account, this.commitment, slot);
      this.logger?.info(`[Cache SET] ${address2}`);
    }
    return account;
  }
  async getAccounts(addresses2, decoderImportName) {
    if (!this.cacheManager.isEnabled()) {
      return this.builder.getAccounts(addresses2, decoderImportName);
    }
    const results = new Array(addresses2.length);
    const uncachedIndices = [];
    const uncachedAddresses = [];
    for (let i = 0;i < addresses2.length; i++) {
      const cached = this.cacheManager.getAccount(addresses2[i], this.commitment);
      if (cached !== undefined) {
        results[i] = cached;
        this.logger?.info(`[Cache HIT] ${addresses2[i]}`);
      } else {
        uncachedIndices.push(i);
        uncachedAddresses.push(addresses2[i]);
      }
    }
    if (uncachedAddresses.length > 0) {
      this.logger?.info(`[Cache MISS] Fetching ${uncachedAddresses.length}/${addresses2.length} accounts`);
      const fetched = await this.builder.getAccounts(uncachedAddresses, decoderImportName);
      const slot = 0;
      for (let i = 0;i < fetched.length; i++) {
        const originalIndex = uncachedIndices[i];
        const account = fetched[i];
        results[originalIndex] = account;
        if (account !== null) {
          this.cacheManager.setAccount(uncachedAddresses[i], account, this.commitment, slot);
        }
      }
    }
    return results;
  }
  async getProgramAccounts(decoderImportName, filters) {
    return this.builder.getProgramAccounts(decoderImportName, filters);
  }
  get programId() {
    return this.config.programId;
  }
  getProgramId() {
    return this.config.programId;
  }
  get commitment() {
    return this.config.commitment ?? "confirmed";
  }
  getCommitment() {
    return this.config.commitment ?? "confirmed";
  }
  invalidateCache(address2) {
    this.cacheManager.invalidateAccount(address2);
    this.logger?.info(`[Cache INVALIDATE] ${address2}`);
  }
  clearCache() {
    this.cacheManager.clear();
    this.logger?.info("[Cache CLEAR] All caches cleared");
  }
  getCacheStats() {
    return this.cacheManager.getStats();
  }
}, DEFAULT_IPFS_CONFIG, IPFSUtils = class {
  client;
  constructor(config) {
    this.client = new IPFSClient(config);
  }
  async storeAgentMetadata(metadata, options2) {
    const metadataJson = JSON.stringify({
      ...metadata,
      createdAt: (/* @__PURE__ */ new Date()).toISOString(),
      version: "1.0.0"
    });
    return this.client.storeContent(metadataJson, "agent-metadata", {
      filename: `agent-${metadata.agentId ?? "metadata"}.json`,
      metadata: {
        type: "agent-metadata",
        agentId: metadata.agentId,
        name: metadata.name
      },
      contentType: "application/json",
      ...options2
    });
  }
  async storeChannelMessage(message, options2) {
    const messageJson = JSON.stringify({
      ...message,
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      version: "1.0.0"
    });
    return this.client.storeContent(messageJson, "channel-message", {
      filename: `message-${Date.now()}.json`,
      metadata: {
        type: "channel-message",
        channelId: message.channelId,
        messageType: message.messageType ?? 0
      },
      contentType: "application/json",
      ...options2
    });
  }
  async storeFileAttachment(fileContent, filename, contentType, options2) {
    const content = typeof fileContent === "string" ? fileContent : new TextDecoder().decode(fileContent);
    return this.client.storeContent(content, "file-attachment", {
      filename,
      contentType,
      metadata: {
        type: "file-attachment",
        originalFilename: filename,
        mimeType: contentType
      },
      ...options2
    });
  }
  async retrieveAgentMetadata(uri) {
    const content = await this.client.retrieveContent(uri);
    const parsed = JSON.parse(content);
    if (typeof parsed !== "object" || parsed === null) {
      throw new Error("Retrieved agent metadata is not a valid object");
    }
    return parsed;
  }
  async retrieveChannelMessage(uri) {
    const content = await this.client.retrieveContent(uri);
    const parsed = JSON.parse(content);
    if (typeof parsed !== "object" || parsed === null) {
      throw new Error("Retrieved channel message is not a valid object");
    }
    return parsed;
  }
  async batchUpload(items) {
    const results = await Promise.allSettled(items.map((item) => this.client.storeContent(item.content, item.type, {
      filename: item.filename,
      ...item.options
    })));
    return results.map((result) => {
      if (result.status === "fulfilled") {
        return {
          success: true,
          data: result.value
        };
      } else {
        return {
          success: false,
          error: "UPLOAD_FAILED",
          message: result.reason instanceof Error ? result.reason.message : String(result.reason)
        };
      }
    });
  }
  async pinContent(hash) {
    const result = await this.client.pin(hash);
    return {
      ...result,
      data: result.success
    };
  }
  isIPFSUri(uri) {
    return uri.startsWith("ipfs://");
  }
  extractIPFSHash(uri) {
    if (!this.isIPFSUri(uri)) {
      return null;
    }
    return uri.replace("ipfs://", "");
  }
  getGatewayUrls(hash, gateways) {
    const defaultGateways = gateways ?? DEFAULT_IPFS_CONFIG.gateways ?? [];
    return defaultGateways.map((gateway) => `${gateway}/ipfs/${hash}`);
  }
  isValidIPFSHash(hash) {
    if (hash.length < 44)
      return false;
    if (hash.startsWith("Qm") && hash.length === 46) {
      return /^Qm[A-Za-z0-9]{44}$/.test(hash);
    }
    if (hash.length > 46) {
      return /^[A-Za-z0-9]+$/.test(hash);
    }
    return false;
  }
  shouldUseIPFS(content, threshold) {
    const size = new TextEncoder().encode(content).length;
    const sizeThreshold = threshold ?? DEFAULT_IPFS_CONFIG.sizeThreshold ?? 800;
    return size > sizeThreshold;
  }
  async compressContent(content) {
    try {
      if (typeof CompressionStream !== "undefined") {
        const compressedStream = new CompressionStream("gzip");
        const writer = compressedStream.writable.getWriter();
        const reader = compressedStream.readable.getReader();
        const encoder2 = new TextEncoder;
        const input = encoder2.encode(content);
        const writePromise = writer.write(input).then(() => writer.close());
        const chunks = [];
        const readCompressed = async () => {
          const result = await reader.read();
          const { done, value } = result;
          if (!done && value) {
            chunks.push(value);
            await readCompressed();
          }
        };
        await Promise.all([writePromise, readCompressed()]);
        const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
        const compressedData = new Uint8Array(totalLength);
        let offset = 0;
        for (const chunk of chunks) {
          compressedData.set(chunk, offset);
          offset += chunk.length;
        }
        const compressed = Buffer.from(compressedData).toString("base64");
        return {
          compressed,
          algorithm: "gzip"
        };
      } else {
        console.warn("Compression not available in this environment, storing uncompressed");
        return {
          compressed: content,
          algorithm: "none"
        };
      }
    } catch (error) {
      console.warn("Compression failed, falling back to uncompressed:", error);
      return {
        compressed: content,
        algorithm: "none"
      };
    }
  }
  async decompressContent(compressed, algorithm) {
    if (algorithm === "none") {
      return compressed;
    }
    try {
      if (algorithm === "gzip") {
        if (typeof DecompressionStream !== "undefined") {
          const decompressedStream = new DecompressionStream("gzip");
          const writer = decompressedStream.writable.getWriter();
          const reader = decompressedStream.readable.getReader();
          const compressedData = Buffer.from(compressed, "base64");
          const writePromise = writer.write(compressedData).then(() => writer.close());
          const chunks = [];
          const readDecompressed = async () => {
            const result = await reader.read();
            const { done, value } = result;
            if (!done && value) {
              chunks.push(value);
              await readDecompressed();
            }
          };
          await Promise.all([writePromise, readDecompressed()]);
          const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
          const decompressedData = new Uint8Array(totalLength);
          let offset = 0;
          for (const chunk of chunks) {
            decompressedData.set(chunk, offset);
            offset += chunk.length;
          }
          const decoder = new TextDecoder;
          return decoder.decode(decompressedData);
        } else {
          console.warn("Decompression not available in this environment, returning compressed data");
          return compressed;
        }
      } else {
        console.warn(`Unknown compression algorithm: ${algorithm}`);
        return compressed;
      }
    } catch (error) {
      console.error("Decompression failed, returning compressed data:", error);
      return compressed;
    }
  }
  getStats() {
    return {
      cacheStats: this.client.getCacheStats(),
      config: DEFAULT_IPFS_CONFIG
    };
  }
  clearCache() {
    this.client.clearCache();
  }
}, AgentModule, GovernanceModule, MultisigModule, DID_DOCUMENT_SEED = "did_document", VerificationMethodType2, VerificationRelationship2, ServiceEndpointType2, DidError, DidErrorClass, base58Encode = (data2) => esm_default2.encode(data2), DEFAULT_PROGRAM_ID = "GHosT3wqDfNq9bKz8dNEQ1F5mLuN7bKdNYx3Z1111111", CredentialKind2, CredentialStatus2, CredentialModule = class {
  programId;
  didModule;
  constructor(programId = DEFAULT_PROGRAM_ID, didModule) {
    this.programId = programId;
    this.didModule = didModule;
  }
  setDidModule(didModule) {
    this.didModule = didModule;
  }
  hashSubjectData(subjectData) {
    const json2 = JSON.stringify(subjectData, Object.keys(subjectData).sort());
    return sha2562(new TextEncoder().encode(json2));
  }
  generateCredentialId(kind, subject) {
    const timestamp = Date.now();
    const input = `${kind}-${subject}-${timestamp}`;
    const hash = sha2562(new TextEncoder().encode(input));
    const shortHash = base58Encode(hash.slice(0, 8));
    return `${kind.toLowerCase()}-${shortHash}`;
  }
  exportAsW3CCredential(credential, template, credentialType, subjectData, options2) {
    const network = options2?.network || "mainnet";
    const issuerDid = generateDidString(network, this.programId);
    const subjectDid = generateDidString(network, credential.subject);
    const statusId = `solana:${this.programId}:credential:${credential.credentialId}`;
    return {
      "@context": [
        "https://www.w3.org/ns/credentials/v2",
        "https://w3id.org/security/data-integrity/v2",
        "https://ghostspeak.io/ns/credentials/v1"
      ],
      type: ["VerifiableCredential", `GhostSpeak${credentialType.kind}Credential`],
      id: `urn:ghostspeak:${credential.credentialId}`,
      issuer: {
        id: issuerDid,
        name: "GhostSpeak Protocol"
      },
      validFrom: new Date(credential.issuedAt * 1000).toISOString(),
      validUntil: credential.expiresAt ? new Date(credential.expiresAt * 1000).toISOString() : undefined,
      credentialSubject: {
        id: subjectDid,
        ...subjectData
      },
      credentialSchema: {
        id: credentialType.schemaUri,
        type: "JsonSchema"
      },
      credentialStatus: {
        id: statusId,
        type: "SolanaAccountStatus2025",
        statusPurpose: "revocation"
      },
      relatedResource: options2?.includeRelatedResource ? [
        {
          id: credential.subjectDataUri,
          digestMultibase: `mEi${base58Encode(credential.subjectDataHash)}`
        }
      ] : undefined,
      proof: {
        type: "DataIntegrityProof",
        created: new Date(credential.issuedAt * 1000).toISOString(),
        verificationMethod: `${issuerDid}#key-1`,
        cryptosuite: "eddsa-rdfc-2022",
        proofPurpose: "assertionMethod",
        proofValue: base58Encode(credential.signature)
      }
    };
  }
  async exportWithDidResolution(credential, template, credentialType, subjectData, options2) {
    if (!this.didModule) {
      return this.exportAsW3CCredential(credential, template, credentialType, subjectData, options2);
    }
    const network = options2?.network || "mainnet";
    const issuerDid = generateDidString(network, this.programId);
    const subjectDid = generateDidString(network, credential.subject);
    const issuerDidDoc = await this.didModule.resolve(this.programId).catch(() => null);
    await this.didModule.resolve(credential.subject).catch(() => null);
    const statusId = `solana:${this.programId}:credential:${credential.credentialId}`;
    const verificationMethod = issuerDidDoc?.verificationMethods?.[0] ? `${issuerDid}#${issuerDidDoc.verificationMethods[0].id}` : `${issuerDid}#key-1`;
    return {
      "@context": [
        "https://www.w3.org/ns/credentials/v2",
        "https://w3id.org/security/data-integrity/v2",
        "https://ghostspeak.io/ns/credentials/v1"
      ],
      type: ["VerifiableCredential", `GhostSpeak${credentialType.kind}Credential`],
      id: `urn:ghostspeak:${credential.credentialId}`,
      issuer: {
        id: issuerDid,
        name: "GhostSpeak Protocol"
      },
      validFrom: new Date(credential.issuedAt * 1000).toISOString(),
      validUntil: credential.expiresAt ? new Date(credential.expiresAt * 1000).toISOString() : undefined,
      credentialSubject: {
        id: subjectDid,
        ...subjectData
      },
      credentialSchema: {
        id: credentialType.schemaUri,
        type: "JsonSchema"
      },
      credentialStatus: {
        id: statusId,
        type: "SolanaAccountStatus2025",
        statusPurpose: "revocation"
      },
      relatedResource: options2?.includeRelatedResource ? [
        {
          id: credential.subjectDataUri,
          digestMultibase: `mEi${base58Encode(credential.subjectDataHash)}`
        }
      ] : undefined,
      proof: {
        type: "DataIntegrityProof",
        created: new Date(credential.issuedAt * 1000).toISOString(),
        verificationMethod,
        cryptosuite: "eddsa-rdfc-2022",
        proofPurpose: "assertionMethod",
        proofValue: base58Encode(credential.signature)
      }
    };
  }
  static buildAgentIdentitySubject(params) {
    return params;
  }
  issueX402AgentCredential(params) {
    const now = Math.floor(Date.now() / 1000);
    const subjectData = {
      agentId: params.agentId,
      owner: params.owner,
      name: params.name,
      capabilities: params.capabilities || [],
      serviceEndpoint: params.serviceEndpoint,
      frameworkOrigin: params.frameworkOrigin,
      x402Enabled: true,
      x402PaymentAddress: params.x402PaymentAddress,
      x402AcceptedTokens: params.x402AcceptedTokens,
      x402PricePerCall: params.x402PricePerCall,
      registeredAt: now,
      verifiedAt: now,
      type: "external-x402-agent",
      verificationResponseTimeMs: params.verificationResponseTimeMs
    };
    const credentialId = this.generateCredentialId("AgentIdentity", params.agentAddress);
    const subjectDataHash = this.hashSubjectData(subjectData);
    const credential = {
      template: `x402-agent-identity-template`,
      subject: params.agentAddress,
      issuer: this.programId,
      credentialId,
      subjectDataHash,
      subjectDataUri: `data:application/json;base64,${Buffer.from(JSON.stringify(subjectData)).toString("base64")}`,
      status: "Active",
      signature: subjectDataHash,
      issuedAt: now
    };
    const credentialType = {
      authority: this.programId,
      name: "x402 Agent Identity",
      kind: "AgentIdentity",
      schemaUri: "https://ghostspeak.io/schemas/x402-agent-identity-v1.json",
      description: "Verifiable credential for x402-compatible AI agents registered with GhostSpeak",
      isActive: true,
      totalIssued: 1,
      createdAt: now
    };
    const template = {
      credentialType: credentialType.authority,
      name: "x402 Agent Identity",
      imageUri: "https://ghostspeak.io/assets/credential-badge-x402.png",
      issuer: this.programId,
      isActive: true,
      totalIssued: 1,
      createdAt: now
    };
    const w3cCredential = this.exportAsW3CCredential(credential, template, credentialType, subjectData, { network: params.network || "devnet", includeRelatedResource: true });
    return {
      credentialId,
      credential,
      w3cCredential,
      subjectData
    };
  }
  exportCredentialToJSON(credential, subjectData, options2) {
    const template = {
      credentialType: "x402-agent",
      name: credential.credentialId.includes("agentidentity") ? "Agent Identity" : "Custom",
      imageUri: "https://ghostspeak.io/assets/credential-badge.png",
      issuer: credential.issuer,
      isActive: true,
      totalIssued: 1,
      createdAt: credential.issuedAt
    };
    const credentialType = {
      authority: credential.issuer,
      name: "GhostSpeak Credential",
      kind: "AgentIdentity",
      schemaUri: "https://ghostspeak.io/schemas/credential-v1.json",
      description: "GhostSpeak verifiable credential",
      isActive: true,
      totalIssued: 1,
      createdAt: credential.issuedAt
    };
    const w3c = this.exportAsW3CCredential(credential, template, credentialType, subjectData, { network: options2?.network || "devnet", includeRelatedResource: true });
    return options2?.pretty ? JSON.stringify(w3c, null, 2) : JSON.stringify(w3c);
  }
}, DEFAULT_FACILITATOR_URL = "https://facilitator.payai.network", DEFAULT_TIMEOUT = 30000, DEFAULT_RETRY, PayAIClient, ReputationModule, StakingModule;
var init_chunk_SZGFSCNU = __esm(() => {
  init_chunk_C5CDA3WX();
  init_chunk_S74EH3KD();
  init_chunk_UP2VWCW5();
  init_index_node35();
  init_esm();
  init_esm3();
  init_sha256();
  MultiSourceAggregator_exports = {};
  __export2(MultiSourceAggregator_exports, {
    MultiSourceAggregator: () => MultiSourceAggregator
  });
  init_MultiSourceAggregator = __esm2({
    "src/modules/reputation/MultiSourceAggregator.ts"() {
      MultiSourceAggregator = class {
        adapters = /* @__PURE__ */ new Map;
        configs = /* @__PURE__ */ new Map;
        CONFLICT_THRESHOLD = 300;
        constructor() {}
        addSource(adapter, config) {
          if (!config.enabled) {
            return;
          }
          this.adapters.set(adapter.source, adapter);
          this.configs.set(adapter.source, config);
        }
        removeSource(source) {
          this.adapters.delete(source);
          this.configs.delete(source);
        }
        updateSourceWeight(source, weight) {
          const config = this.configs.get(source);
          if (config) {
            config.weight = weight;
          }
        }
        updateSourceReliability(source, reliability) {
          const config = this.configs.get(source);
          if (config) {
            config.reliability = reliability;
          }
        }
        async aggregateReputation(agentId) {
          const sourceDataList = [];
          for (const [source, adapter] of this.adapters.entries()) {
            try {
              const data2 = await adapter.fetchReputationData(agentId.toString());
              if (adapter.validateData(data2)) {
                sourceDataList.push(data2);
              }
            } catch (error) {
              console.warn(`Failed to fetch reputation from ${source}:`, error);
            }
          }
          const aggregateScore = this.calculateWeightedScore(sourceDataList);
          const { hasConflicts, conflicts } = this.detectConflicts(sourceDataList);
          const sourceScores = this.buildSourceBreakdowns(sourceDataList);
          const totalDataPoints = sourceDataList.reduce((sum, data2) => sum + data2.dataPoints, 0);
          return {
            agentId,
            aggregateScore,
            sourceScores,
            hasConflicts,
            conflicts,
            totalDataPoints,
            timestamp: /* @__PURE__ */ new Date
          };
        }
        calculateWeightedScore(sourceDataList) {
          if (sourceDataList.length === 0) {
            return 0;
          }
          let totalContribution = 0;
          let totalNormalization = 0;
          for (const data2 of sourceDataList) {
            const config = this.configs.get(data2.source);
            if (!config)
              continue;
            const weight = config.weight / 1e4;
            const reliability = data2.reliability;
            const contribution = data2.score * weight * reliability;
            const normalization = weight * reliability;
            totalContribution += contribution;
            totalNormalization += normalization;
          }
          if (totalNormalization === 0) {
            return 0;
          }
          return Math.round(totalContribution / totalNormalization);
        }
        detectConflicts(sourceDataList) {
          if (sourceDataList.length < 2) {
            return { hasConflicts: false, conflicts: [] };
          }
          const scores = sourceDataList.map((d) => d.score);
          const maxScore = Math.max(...scores);
          const minScore = Math.min(...scores);
          const variance = maxScore - minScore;
          const conflicts = [];
          if (variance > this.CONFLICT_THRESHOLD) {
            const maxSource = sourceDataList.find((d) => d.score === maxScore)?.source;
            const minSource = sourceDataList.find((d) => d.score === minScore)?.source;
            conflicts.push(`High variance detected: ${variance} (${(variance / 1000 * 100).toFixed(1)}%) between ${maxSource} (${maxScore}) and ${minSource} (${minScore})`);
            return { hasConflicts: true, conflicts };
          }
          return { hasConflicts: false, conflicts: [] };
        }
        buildSourceBreakdowns(sourceDataList) {
          return sourceDataList.map((data2) => {
            const config = this.configs.get(data2.source);
            if (!config) {
              throw new Error(`No config found for source: ${data2.source}`);
            }
            const weight = config.weight;
            const reliability = data2.reliability * 1e4;
            const contribution = data2.score * (weight / 1e4) * (reliability / 1e4) / this.calculateNormalizationFactor(sourceDataList);
            return {
              source: data2.source,
              score: data2.score,
              weight,
              reliability: Math.round(reliability),
              dataPoints: data2.dataPoints,
              contribution: Math.round(contribution),
              lastUpdated: data2.timestamp
            };
          });
        }
        calculateNormalizationFactor(sourceDataList) {
          let total = 0;
          for (const data2 of sourceDataList) {
            const config = this.configs.get(data2.source);
            if (!config)
              continue;
            const weight = config.weight / 1e4;
            const reliability = data2.reliability;
            total += weight * reliability;
          }
          return total || 1;
        }
        async getSourceBreakdown(agentId) {
          const result = await this.aggregateReputation(agentId);
          return result.sourceScores;
        }
        getRegisteredSources() {
          return Array.from(this.adapters.keys());
        }
        getSourceConfig(source) {
          return this.configs.get(source);
        }
        enableSource(source) {
          const config = this.configs.get(source);
          if (config) {
            config.enabled = true;
          }
        }
        disableSource(source) {
          const config = this.configs.get(source);
          if (config) {
            config.enabled = false;
          }
        }
        isSourceEnabled(source) {
          const config = this.configs.get(source);
          return config?.enabled ?? false;
        }
      };
    }
  });
  DEFAULT_TTLS = {
    processed: 500,
    confirmed: 2000,
    finalized: 30000
  };
  DEFAULT_IPFS_CONFIG = {
    provider: {
      name: "pinata",
      endpoint: "https://api.pinata.cloud"
    },
    gateways: [
      "https://gateway.pinata.cloud",
      "https://ipfs.io",
      "https://cloudflare-ipfs.com",
      "https://gateway.ipfs.io"
    ],
    autoPinning: true,
    sizeThreshold: 800,
    maxRetries: 3,
    retryDelay: 1000,
    enableCache: true,
    cacheTTL: 300000
  };
  AgentModule = class extends BaseModule {
    ipfsUtils = null;
    constructor(config) {
      super(config);
      if (config.ipfsConfig) {
        this.ipfsUtils = createIPFSUtils(config.ipfsConfig);
      }
    }
    async register(signer, params) {
      const pricingModel = params.pricingModel ?? 0;
      const registerGetter = async () => {
        const agentAccount = await this.deriveAgentPda(params.agentId, signer.address);
        const ix = await getRegisterAgentInstructionAsync({
          agentAccount,
          signer,
          systemProgram: this.systemProgramId,
          agentType: params.agentType,
          name: params.name,
          description: params.description,
          metadataUri: params.metadataUri,
          agentId: params.agentId,
          pricingModel
        });
        return ix;
      };
      const heapGetter = () => {
        const heapData = new Uint8Array(5);
        heapData[0] = 1;
        new DataView(heapData.buffer).setUint32(1, 262144, true);
        return {
          programAddress: "ComputeBudget111111111111111111111111111111",
          accounts: [],
          data: heapData
        };
      };
      this.debug();
      if (params.skipSimulation) {
        console.log("\uD83D\uDE80 SKIPPING SIMULATION - Sending transaction directly");
        return this.builder.executeBatch("registerAgent", [heapGetter, registerGetter], [signer], { simulate: false, skipPreflight: true });
      }
      return this.builder.executeBatch("registerAgent", [heapGetter, registerGetter], [signer]);
    }
    async registerCompressed(signer, params) {
      const instructionGetter = async () => {
        const treeConfig = params.treeConfig || await this.deriveTreeConfigPda(signer.address);
        const result = await getRegisterAgentCompressedInstructionAsync({
          merkleTree: params.merkleTree,
          treeAuthority: treeConfig,
          signer,
          systemProgram: this.systemProgramId,
          compressionProgram: this.compressionProgramId,
          agentType: params.agentType,
          name: params.name,
          description: params.description,
          metadataUri: params.metadataUri,
          agentId: params.agentId,
          pricingModel: params.pricingModel ?? 0,
          logWrapper: "noopb9bkMVfRPU8AsbpTUg8AQkHtKwMYZiFUjNRtMmV"
        });
        return result;
      };
      return this.execute("registerAgentCompressed", instructionGetter, [signer]);
    }
    async update(signer, params) {
      const instructionGetter = () => {
        const result = getUpdateAgentInstruction({
          agentAccount: params.agentAddress,
          signer,
          metadataUri: params.metadataUri,
          agentType: params.agentType,
          agentId: params.agentId,
          name: params.name ?? null,
          description: params.description ?? null,
          pricingModel: params.pricingModel ?? 0
        });
        return result;
      };
      return this.execute("updateAgent", instructionGetter, [signer]);
    }
    async verify(signer, params) {
      const instructionGetter = async () => {
        const result = await getVerifyAgentInstructionAsync({
          agent: params.agentAddress,
          verifier: signer,
          agentPubkey: params.agentPubkey,
          serviceEndpoint: params.serviceEndpoint,
          supportedCapabilities: params.supportedCapabilities,
          verifiedAt: params.verifiedAt
        });
        return result;
      };
      return this.execute("verifyAgent", instructionGetter, [signer]);
    }
    async deactivate(signer, params) {
      const instructionGetter = () => {
        const result = getDeactivateAgentInstruction({
          agentAccount: params.agentAddress,
          signer,
          agentId: params.agentId
        });
        return result;
      };
      return this.execute("deactivateAgent", instructionGetter, [signer]);
    }
    async activate(signer, params) {
      const instructionGetter = () => {
        const result = getActivateAgentInstruction({
          agentAccount: params.agentAddress,
          signer,
          agentId: params.agentId
        });
        return result;
      };
      return this.execute("activateAgent", instructionGetter, [signer]);
    }
    async getAgentAccount(address2) {
      return super.getAccount(address2, "getAgentDecoder");
    }
    async getAllAgents() {
      return this.getProgramAccounts("getAgentDecoder");
    }
    async getAgentsByType(agentType) {
      const typeBytes = Buffer.alloc(1);
      typeBytes.writeUInt8(agentType, 0);
      const filters = [{
        memcmp: {
          offset: BigInt(8),
          bytes: typeBytes.toString("base64"),
          encoding: "base64"
        }
      }];
      return this.getProgramAccounts("getAgentDecoder", filters);
    }
    async getUserAgents(authority) {
      const filters = [{
        memcmp: {
          offset: BigInt(9),
          bytes: authority,
          encoding: "base58"
        }
      }];
      return this.getProgramAccounts("getAgentDecoder", filters);
    }
    async batchGetAgents(addresses2, onProgress) {
      return super.getAccounts(addresses2, "getAgentDecoder");
    }
    async batchGetExistingAgents(addresses2, onProgress) {
      const { batchGetExistingAccounts: batchGetExistingAccounts2 } = await Promise.resolve().then(() => (init_batch_operations_45CQFEID(), exports_batch_operations_45CQFEID));
      return batchGetExistingAccounts2(this.config.rpc, addresses2, { onProgress });
    }
    async batchGetAndMapAgents(addresses2, mapper) {
      const { batchGetAndMap: batchGetAndMap2 } = await Promise.resolve().then(() => (init_batch_operations_45CQFEID(), exports_batch_operations_45CQFEID));
      return batchGetAndMap2(this.config.rpc, addresses2, mapper);
    }
    async deriveAgentPda(agentId, owner) {
      const { deriveAgentPda: deriveAgentPda2 } = await Promise.resolve().then(() => (init_pda_4KP7CURF(), exports_pda_4KP7CURF));
      const [address2] = await deriveAgentPda2({ programAddress: this.programId, owner, agentId });
      return address2;
    }
    async deriveUserRegistryPda(owner) {
      const { deriveUserRegistryPda: deriveUserRegistryPda2 } = await Promise.resolve().then(() => (init_pda_4KP7CURF(), exports_pda_4KP7CURF));
      return deriveUserRegistryPda2(this.programId, owner);
    }
    async deriveTreeConfigPda(owner) {
      const { getProgramDerivedAddress: getProgramDerivedAddress2, getAddressEncoder: getAddressEncoder2 } = await Promise.resolve().then(() => (init_index_node5(), exports_index_node));
      const addressEncoder = getAddressEncoder2();
      const ownerBytes = addressEncoder.encode(owner);
      const [pda] = await getProgramDerivedAddress2({
        programAddress: this.programId,
        seeds: [
          new TextEncoder().encode("agent_tree_config"),
          ownerBytes
        ]
      });
      return pda;
    }
    get systemProgramId() {
      return SYSTEM_PROGRAM_ADDRESS;
    }
    get compressionProgramId() {
      return "cmtDvXumGCrqC1Age74AVPhSRVXJMd8PJS91L8KbNCK";
    }
  };
  GovernanceModule = class extends BaseModule {
    getInitializeGovernanceProposalInstruction(params) {
      return getInitializeGovernanceProposalInstructionAsync(params);
    }
    async createProposal(params) {
      const proposalAddress = this.deriveProposalPda(params.signer.address, params.title);
      const instruction = await this.getInitializeGovernanceProposalInstruction({
        proposal: proposalAddress,
        proposer: params.signer,
        title: params.title,
        description: params.description,
        proposalType: { kind: params.proposalType, data: {} },
        executionParams: {
          instructions: [],
          accounts: [],
          targetProgram: proposalAddress,
          executeAfter: BigInt(params.executionDelay ?? 0)
        },
        proposalId: BigInt(Date.now())
      });
      return this.execute("createProposal", () => instruction, [params.signer]);
    }
    async getProposal(address2) {
      return super.getAccount(address2, "getGovernanceProposalDecoder");
    }
    async getActiveProposals() {
      return this.getProgramAccounts("getGovernanceProposalDecoder");
    }
    async getProposalsByProposer(proposer) {
      const filters = [{
        memcmp: {
          offset: BigInt(8),
          bytes: proposer,
          encoding: "base58"
        }
      }];
      return this.getProgramAccounts("getGovernanceProposalDecoder", filters);
    }
    async getProposalsByStatus(_status) {
      const allProposals = await this.getProgramAccounts("getGovernanceProposalDecoder");
      return allProposals.filter((_proposal) => {
        return allProposals.length > 0;
      });
    }
    deriveProposalPda(proposer, title) {
      return `proposal_${proposer}_${title}`;
    }
  };
  MultisigModule = class extends BaseModule {
    async createMultisig(params) {
      throw new Error("createMultisig: Instruction not available - requires IDL regeneration");
    }
    async createProposal(params) {
      const instruction = await getInitializeGovernanceProposalInstructionAsync({
        proposer: params.proposer,
        proposalId: params.proposalId,
        title: params.title,
        description: params.description,
        proposalType: params.proposalType,
        executionParams: params.executionParams
      }, { programAddress: this.programId });
      return this.execute("createProposal", () => instruction, [params.proposer]);
    }
    async executeProposal(params) {
      throw new Error("executeProposal: Use protocol_config instructions for execution");
    }
  };
  VerificationMethodType2 = /* @__PURE__ */ ((VerificationMethodType22) => {
    VerificationMethodType22["Ed25519VerificationKey2020"] = "Ed25519VerificationKey2020";
    VerificationMethodType22["X25519KeyAgreementKey2020"] = "X25519KeyAgreementKey2020";
    VerificationMethodType22["EcdsaSecp256k1VerificationKey2019"] = "EcdsaSecp256k1VerificationKey2019";
    return VerificationMethodType22;
  })(VerificationMethodType2 || {});
  VerificationRelationship2 = /* @__PURE__ */ ((VerificationRelationship22) => {
    VerificationRelationship22["Authentication"] = "authentication";
    VerificationRelationship22["AssertionMethod"] = "assertionMethod";
    VerificationRelationship22["KeyAgreement"] = "keyAgreement";
    VerificationRelationship22["CapabilityInvocation"] = "capabilityInvocation";
    VerificationRelationship22["CapabilityDelegation"] = "capabilityDelegation";
    return VerificationRelationship22;
  })(VerificationRelationship2 || {});
  ServiceEndpointType2 = /* @__PURE__ */ ((ServiceEndpointType22) => {
    ServiceEndpointType22["AIAgentService"] = "AIAgentService";
    ServiceEndpointType22["DIDCommMessaging"] = "DIDCommMessaging";
    ServiceEndpointType22["CredentialRepository"] = "CredentialRepository";
    ServiceEndpointType22["LinkedDomains"] = "LinkedDomains";
    ServiceEndpointType22["Custom"] = "Custom";
    return ServiceEndpointType22;
  })(ServiceEndpointType2 || {});
  DidError = /* @__PURE__ */ ((DidError2) => {
    DidError2["AlreadyDeactivated"] = "AlreadyDeactivated";
    DidError2["TooManyVerificationMethods"] = "TooManyVerificationMethods";
    DidError2["TooManyServiceEndpoints"] = "TooManyServiceEndpoints";
    DidError2["DuplicateMethodId"] = "DuplicateMethodId";
    DidError2["DuplicateServiceId"] = "DuplicateServiceId";
    DidError2["MethodNotFound"] = "MethodNotFound";
    DidError2["ServiceNotFound"] = "ServiceNotFound";
    DidError2["InvalidDidFormat"] = "InvalidDidFormat";
    DidError2["UnauthorizedDidOperation"] = "UnauthorizedDidOperation";
    DidError2["DidDeactivated"] = "DidDeactivated";
    return DidError2;
  })(DidError || {});
  DidErrorClass = class extends Error {
    code;
    constructor(code, message) {
      super(message || code);
      this.name = "DidError";
      this.code = code;
    }
  };
  CredentialKind2 = /* @__PURE__ */ ((CredentialKind22) => {
    CredentialKind22["AgentIdentity"] = "AgentIdentity";
    CredentialKind22["ReputationScore"] = "ReputationScore";
    CredentialKind22["JobCompletion"] = "JobCompletion";
    CredentialKind22["DelegatedSigner"] = "DelegatedSigner";
    CredentialKind22["Custom"] = "Custom";
    return CredentialKind22;
  })(CredentialKind2 || {});
  CredentialStatus2 = /* @__PURE__ */ ((CredentialStatus22) => {
    CredentialStatus22["Pending"] = "Pending";
    CredentialStatus22["Active"] = "Active";
    CredentialStatus22["Revoked"] = "Revoked";
    CredentialStatus22["Expired"] = "Expired";
    return CredentialStatus22;
  })(CredentialStatus2 || {});
  DEFAULT_RETRY = { attempts: 3, delayMs: 1000 };
  PayAIClient = class extends EventEmitter {
    config;
    localRecords = [];
    constructor(config) {
      super();
      this.config = {
        facilitatorUrl: config.facilitatorUrl ?? DEFAULT_FACILITATOR_URL,
        rpcUrl: config.rpcUrl,
        wallet: config.wallet,
        timeout: config.timeout ?? DEFAULT_TIMEOUT,
        retry: config.retry ?? DEFAULT_RETRY
      };
    }
    async fetch(url, init) {
      this.emit("request:started", url);
      const startTime = Date.now();
      try {
        let response = await this.fetchWithTimeout(url, init);
        if (isPaymentRequired(response)) {
          const requirements = await extractPaymentRequirements(response);
          this.emit("payment:required", requirements);
          if (requirements.length === 0) {
            throw new Error("Payment required but no payment options provided");
          }
          const requirement = this.selectPaymentOption(requirements);
          if (!requirement) {
            throw new Error("No compatible payment option found");
          }
          response = await this.makePaymentAndRetry(url, init ?? {}, requirement);
        }
        const durationMs = Date.now() - startTime;
        this.emit("request:completed", url, response.ok, durationMs);
        return response;
      } catch (error) {
        const durationMs = Date.now() - startTime;
        this.emit("request:completed", url, false, durationMs);
        if (error instanceof Error) {
          this.emit("payment:failed", error);
        }
        throw error;
      }
    }
    async verifyPayment(paymentHeader, requirement) {
      const response = await this.fetchWithTimeout(`${this.config.facilitatorUrl}/verify`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          paymentHeader,
          paymentRequirements: requirement
        })
      });
      return response.json();
    }
    async settlePayment(paymentHeader, requirement) {
      const response = await this.fetchWithTimeout(`${this.config.facilitatorUrl}/settle`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          paymentHeader,
          paymentRequirements: requirement
        })
      });
      return response.json();
    }
    async listResources(options2) {
      const params = new URLSearchParams;
      if (options2?.network)
        params.set("network", options2.network);
      if (options2?.capability)
        params.set("capability", options2.capability);
      if (options2?.maxPrice)
        params.set("maxPrice", options2.maxPrice.toString());
      const response = await this.fetchWithTimeout(`${this.config.facilitatorUrl}/list?${params.toString()}`);
      return response.json();
    }
    getLocalReputationRecords() {
      return [...this.localRecords];
    }
    clearLocalReputationRecords() {
      this.localRecords.length = 0;
    }
    selectPaymentOption(requirements) {
      const solanaOption = requirements.find((r) => r.network === "solana");
      if (solanaOption)
        return solanaOption;
      return requirements[0] ?? null;
    }
    async makePaymentAndRetry(url, init, requirement) {
      this.emit("payment:started", requirement);
      const paymentHeader = await this.createPaymentHeader(requirement);
      const verification = await this.verifyPayment(paymentHeader, requirement);
      if (!verification.valid) {
        throw new Error(`Payment verification failed: ${verification.error ?? "Unknown error"}`);
      }
      const settlement = await this.settlePayment(paymentHeader, requirement);
      if (!settlement.success) {
        throw new Error(`Payment settlement failed: ${settlement.error ?? "Unknown error"}`);
      }
      this.emit("payment:completed", {
        success: true,
        transactionSignature: settlement.transaction,
        paymentId: `pay_${Date.now()}`
      });
      const startTime = Date.now();
      const response = await this.fetchWithTimeout(url, {
        ...init,
        headers: {
          ...init.headers,
          "X-Payment": paymentHeader,
          "X-Payment-Signature": settlement.transaction ?? ""
        }
      });
      const responseTime = Date.now() - startTime;
      if (settlement.transaction) {
        this.localRecords.push({
          agentAddress: requirement.payTo,
          paymentSignature: settlement.transaction,
          amount: BigInt(requirement.maxAmountRequired),
          success: response.ok,
          responseTimeMs: responseTime,
          payerAddress: this.config.wallet?.publicKey ?? "unknown",
          timestamp: /* @__PURE__ */ new Date,
          network: requirement.network
        });
      }
      return response;
    }
    async createPaymentHeader(requirement) {
      if (!this.config.wallet) {
        throw new Error("Wallet not configured for payments");
      }
      const paymentData = {
        version: "1.0",
        scheme: requirement.scheme,
        network: requirement.network,
        payer: this.config.wallet.publicKey,
        payTo: requirement.payTo,
        amount: requirement.maxAmountRequired,
        asset: requirement.asset,
        resource: requirement.resource,
        nonce: Date.now().toString(),
        signature: `mock_sig_${Date.now()}`
      };
      return Buffer.from(JSON.stringify(paymentData)).toString("base64");
    }
    async fetchWithTimeout(url, init) {
      const controller = new AbortController;
      const timeoutId = setTimeout(() => controller.abort(), this.config.timeout);
      try {
        const response = await fetch(url, {
          ...init,
          signal: controller.signal
        });
        return response;
      } finally {
        clearTimeout(timeoutId);
      }
    }
  };
  init_reputation_tag_engine();
  ReputationModule = class extends BaseModule {
    calculator;
    tagEngine;
    constructor(config) {
      super(config);
      this.calculator = new ReputationCalculator;
      this.tagEngine = new ReputationTagEngine;
    }
    calculateReputationChange(currentData, jobPerformance) {
      return this.calculator.calculateReputation(currentData, jobPerformance);
    }
    getTierName(tier) {
      switch (tier) {
        case "None":
          return "Unranked";
        case "Bronze":
          return "Bronze";
        case "Silver":
          return "Silver";
        case "Gold":
          return "Gold";
        case "Platinum":
          return "Platinum";
        default:
          return "Unknown";
      }
    }
    getTierFromScore(score) {
      if (score >= REPUTATION_CONSTANTS.PLATINUM_TIER_THRESHOLD) {
        return "Platinum";
      } else if (score >= REPUTATION_CONSTANTS.GOLD_TIER_THRESHOLD) {
        return "Gold";
      } else if (score >= REPUTATION_CONSTANTS.SILVER_TIER_THRESHOLD) {
        return "Silver";
      } else if (score >= REPUTATION_CONSTANTS.BRONZE_TIER_THRESHOLD) {
        return "Bronze";
      }
      return "None";
    }
    getBadgeName(badge) {
      switch (badge) {
        case "FirstJob":
          return "First Job";
        case "TenJobs":
          return "10 Jobs";
        case "HundredJobs":
          return "100 Jobs";
        case "ThousandJobs":
          return "1000 Jobs";
        case "PerfectRating":
          return "Perfect Rating";
        case "QuickResponder":
          return "Quick Responder";
        case "DisputeResolver":
          return "Dispute Resolver";
        case "CategoryExpert":
          return "Category Expert";
        case "CrossCategoryMaster":
          return "Cross-Category Master";
        default:
          return "Unknown Badge";
      }
    }
    calculateApyBoost(score) {
      return Math.floor(score / 1000) * 50;
    }
    getTierColor(tier) {
      switch (tier) {
        case "Platinum":
          return "#E5E4E2";
        case "Gold":
          return "#FFD700";
        case "Silver":
          return "#C0C0C0";
        case "Bronze":
          return "#CD7F32";
        default:
          return "#808080";
      }
    }
    createDefaultReputationData(agentAddress) {
      return {
        agent: agentAddress,
        overallScore: 5000,
        totalJobsCompleted: 0,
        totalJobsFailed: 0,
        avgResponseTime: 0,
        disputesAgainst: 0,
        disputesResolved: 0,
        lastUpdated: Math.floor(Date.now() / 1000),
        categoryReputations: [],
        badges: [],
        performanceHistory: [],
        factors: {
          completionWeight: 25,
          qualityWeight: 25,
          timelinessWeight: 20,
          satisfactionWeight: 20,
          disputeWeight: 10
        }
      };
    }
    qualifiesForTier(score, tier) {
      switch (tier) {
        case "Platinum":
          return score >= REPUTATION_CONSTANTS.PLATINUM_TIER_THRESHOLD;
        case "Gold":
          return score >= REPUTATION_CONSTANTS.GOLD_TIER_THRESHOLD;
        case "Silver":
          return score >= REPUTATION_CONSTANTS.SILVER_TIER_THRESHOLD;
        case "Bronze":
          return score >= REPUTATION_CONSTANTS.BRONZE_TIER_THRESHOLD;
        default:
          return true;
      }
    }
    pointsToNextTier(score) {
      const currentTier = this.getTierFromScore(score);
      switch (currentTier) {
        case "None":
          return { nextTier: "Bronze", pointsNeeded: REPUTATION_CONSTANTS.BRONZE_TIER_THRESHOLD - score };
        case "Bronze":
          return { nextTier: "Silver", pointsNeeded: REPUTATION_CONSTANTS.SILVER_TIER_THRESHOLD - score };
        case "Silver":
          return { nextTier: "Gold", pointsNeeded: REPUTATION_CONSTANTS.GOLD_TIER_THRESHOLD - score };
        case "Gold":
          return { nextTier: "Platinum", pointsNeeded: REPUTATION_CONSTANTS.PLATINUM_TIER_THRESHOLD - score };
        case "Platinum":
          return null;
        default:
          return null;
      }
    }
    recordPayAIPayment(record, currentData) {
      const jobPerformance = this.payAIRecordToJobPerformance(record);
      return this.calculateReputationChange(currentData, jobPerformance);
    }
    payAIRecordToJobPerformance(record) {
      const qualityRating = this.estimateQualityFromResponseTime(record.responseTimeMs);
      const expectedDuration = this.estimateExpectedDuration(record.amount);
      return {
        completed: record.success,
        qualityRating,
        expectedDuration,
        actualDuration: Math.ceil(record.responseTimeMs / 1000),
        clientSatisfaction: record.success ? qualityRating : 20,
        hadDispute: false,
        disputeResolvedFavorably: false,
        category: this.categorizeFromNetwork(record.network),
        paymentAmount: Number(record.amount) / 1e6
      };
    }
    estimateQualityFromResponseTime(responseTimeMs) {
      if (responseTimeMs <= 500) {
        return 100;
      } else if (responseTimeMs <= 2000) {
        return Math.round(90 - (responseTimeMs - 500) / 1500 * 20);
      } else if (responseTimeMs <= 1e4) {
        return Math.round(70 - (responseTimeMs - 2000) / 8000 * 30);
      } else {
        return Math.max(20, Math.round(40 - (responseTimeMs - 1e4) / 50000 * 20));
      }
    }
    estimateExpectedDuration(amountBaseUnits) {
      const amountUSDC = Number(amountBaseUnits) / 1e6;
      return Math.max(2, Math.ceil(2 + amountUSDC * 10));
    }
    categorizeFromNetwork(network) {
      switch (network) {
        case "solana":
          return "ai-services-solana";
        case "base":
          return "ai-services-base";
        case "ethereum":
          return "ai-services-ethereum";
        default:
          return "ai-services";
      }
    }
    createPayAIPerformanceSnapshot(record, reputationResult) {
      return {
        timestamp: record.timestamp.getTime(),
        paymentId: record.paymentSignature,
        network: record.network,
        amount: record.amount.toString(),
        success: record.success,
        responseTimeMs: record.responseTimeMs,
        reputationChange: reputationResult.jobScore,
        newScore: reputationResult.overallScore,
        tier: reputationResult.tier
      };
    }
    async calculateTagsForAgent(metrics) {
      return this.tagEngine.calculateTags(metrics);
    }
    getTagsByCategory(tags, category) {
      return this.tagEngine.filterTags(tags, { category });
    }
    hasTag(tags, tagName) {
      return tags.some((tag) => tag.tagName === tagName);
    }
    getTagConfidence(tags, tagName) {
      const tag = tags.find((t) => t.tagName === tagName);
      return tag?.confidence;
    }
    filterTags(tags, filters) {
      return this.tagEngine.filterTags(tags, filters);
    }
    applyTagDecay(tags, currentTimestamp) {
      return this.tagEngine.applyTagDecay(tags, currentTimestamp);
    }
    mergeTags(existingTags, newTags) {
      return this.tagEngine.mergeTags(existingTags, newTags);
    }
    categorizeTags(tags) {
      return this.tagEngine.categorizeTags(tags);
    }
    getTopTags(tags, count) {
      return this.tagEngine.getTopTags(tags, count);
    }
    sortTagsByConfidence(tags) {
      return this.tagEngine.sortByConfidence(tags);
    }
    sortTagsByEvidence(tags) {
      return this.tagEngine.sortByEvidence(tags);
    }
    sortTagsByRecent(tags) {
      return this.tagEngine.sortByRecent(tags);
    }
    getConfidenceLevel(confidence) {
      return this.tagEngine.getConfidenceLevel(confidence);
    }
    validateTagName(tagName) {
      return this.tagEngine.validateTagName(tagName);
    }
    validateConfidence(confidence) {
      return this.tagEngine.validateConfidence(confidence);
    }
    convertMetricsForTagging(onChainMetrics) {
      const avgResponseTime = onChainMetrics.responseTimeCount > 0n ? Number(onChainMetrics.totalResponseTime / onChainMetrics.responseTimeCount) : 0;
      const totalPayments = onChainMetrics.successfulPayments + onChainMetrics.failedPayments;
      const successRate = totalPayments > 0n ? Number(onChainMetrics.successfulPayments * 10000n / totalPayments) : 0;
      const avgRating = onChainMetrics.totalRatingsCount > 0 ? Math.floor(onChainMetrics.totalRating * 100 / (onChainMetrics.totalRatingsCount * 5)) : 0;
      const disputeResolutionRate = onChainMetrics.totalDisputes > 0 ? Math.floor(onChainMetrics.disputesResolved * 1e4 / onChainMetrics.totalDisputes) : 1e4;
      return {
        successfulPayments: onChainMetrics.successfulPayments,
        failedPayments: onChainMetrics.failedPayments,
        totalResponseTime: onChainMetrics.totalResponseTime,
        responseTimeCount: onChainMetrics.responseTimeCount,
        totalDisputes: onChainMetrics.totalDisputes,
        disputesResolved: onChainMetrics.disputesResolved,
        totalRating: onChainMetrics.totalRating,
        totalRatingsCount: onChainMetrics.totalRatingsCount,
        createdAt: onChainMetrics.createdAt,
        updatedAt: onChainMetrics.updatedAt,
        avgResponseTime,
        successRate,
        avgRating,
        disputeResolutionRate
      };
    }
  };
  StakingModule = class extends BaseModule {
    async initializeStakingConfig(params) {
      const instruction = await getInitializeStakingConfigInstructionAsync({
        authority: params.authority,
        minStake: params.minStake,
        treasury: params.treasury
      }, { programAddress: this.programId });
      return this.execute("initializeStakingConfig", () => instruction, [params.authority]);
    }
    async stake(params) {
      const instruction = await getStakeGhostInstructionAsync({
        ownerTokenAccount: params.agentTokenAccount,
        stakingVault: params.stakingVault,
        stakingConfig: params.stakingConfig,
        ghostMint: params.ghostMint,
        owner: params.agentOwner,
        amount: params.amount,
        lockDuration: params.lockDuration
      }, { programAddress: this.programId });
      return this.execute("stakeGhost", () => instruction, [params.agentOwner]);
    }
    async unstake(params) {
      const instruction = await getUnstakeGhostInstructionAsync({
        stakingAccount: params.stakingAccount,
        stakingVault: params.stakingVault,
        ownerTokenAccount: params.agentTokenAccount,
        owner: params.agentOwner
      }, { programAddress: this.programId });
      return this.execute("unstakeGhost", () => instruction, [params.agentOwner]);
    }
    async getStakingAccount(stakingAccountAddress) {
      try {
        return await this.getAccount(stakingAccountAddress, "getStakingAccountDecoder");
      } catch (error) {
        console.error("Error fetching staking account:", error);
        return null;
      }
    }
    async getStakingConfig(stakingConfigAddress) {
      try {
        return await this.getAccount(stakingConfigAddress, "getStakingConfigDecoder");
      } catch (error) {
        console.error("Error fetching staking config:", error);
        return null;
      }
    }
  };
});

// ../packages/sdk-typescript/dist/nacl-fast-W5BJ3KZ2.js
var exports_nacl_fast_W5BJ3KZ2 = {};
__export(exports_nacl_fast_W5BJ3KZ2, {
  default: () => naclFastW5BJ3KZ2
});
var require_nacl_fast, naclFastW5BJ3KZ2;
var init_nacl_fast_W5BJ3KZ2 = __esm(() => {
  init_chunk_UP2VWCW5();
  require_nacl_fast = __commonJS2({
    "../../node_modules/.bun/tweetnacl@1.0.3/node_modules/tweetnacl/nacl-fast.js"(exports$1, module) {
      (function(nacl) {
        var gf = function(init) {
          var i, r = new Float64Array(16);
          if (init)
            for (i = 0;i < init.length; i++)
              r[i] = init[i];
          return r;
        };
        var randombytes = function() {
          throw new Error("no PRNG");
        };
        var _0 = new Uint8Array(16);
        var _9 = new Uint8Array(32);
        _9[0] = 9;
        var gf0 = gf(), gf1 = gf([1]), _121665 = gf([56129, 1]), D2 = gf([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), D22 = gf([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), X = gf([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), Y = gf([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), I = gf([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
        function ts64(x, i, h, l2) {
          x[i] = h >> 24 & 255;
          x[i + 1] = h >> 16 & 255;
          x[i + 2] = h >> 8 & 255;
          x[i + 3] = h & 255;
          x[i + 4] = l2 >> 24 & 255;
          x[i + 5] = l2 >> 16 & 255;
          x[i + 6] = l2 >> 8 & 255;
          x[i + 7] = l2 & 255;
        }
        function vn(x, xi, y, yi, n) {
          var i, d = 0;
          for (i = 0;i < n; i++)
            d |= x[xi + i] ^ y[yi + i];
          return (1 & d - 1 >>> 8) - 1;
        }
        function crypto_verify_16(x, xi, y, yi) {
          return vn(x, xi, y, yi, 16);
        }
        function crypto_verify_32(x, xi, y, yi) {
          return vn(x, xi, y, yi, 32);
        }
        function core_salsa20(o3, p, k, c) {
          var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
          var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
          for (var i = 0;i < 20; i += 2) {
            u = x0 + x12 | 0;
            x4 ^= u << 7 | u >>> 32 - 7;
            u = x4 + x0 | 0;
            x8 ^= u << 9 | u >>> 32 - 9;
            u = x8 + x4 | 0;
            x12 ^= u << 13 | u >>> 32 - 13;
            u = x12 + x8 | 0;
            x0 ^= u << 18 | u >>> 32 - 18;
            u = x5 + x1 | 0;
            x9 ^= u << 7 | u >>> 32 - 7;
            u = x9 + x5 | 0;
            x13 ^= u << 9 | u >>> 32 - 9;
            u = x13 + x9 | 0;
            x1 ^= u << 13 | u >>> 32 - 13;
            u = x1 + x13 | 0;
            x5 ^= u << 18 | u >>> 32 - 18;
            u = x10 + x6 | 0;
            x14 ^= u << 7 | u >>> 32 - 7;
            u = x14 + x10 | 0;
            x2 ^= u << 9 | u >>> 32 - 9;
            u = x2 + x14 | 0;
            x6 ^= u << 13 | u >>> 32 - 13;
            u = x6 + x2 | 0;
            x10 ^= u << 18 | u >>> 32 - 18;
            u = x15 + x11 | 0;
            x3 ^= u << 7 | u >>> 32 - 7;
            u = x3 + x15 | 0;
            x7 ^= u << 9 | u >>> 32 - 9;
            u = x7 + x3 | 0;
            x11 ^= u << 13 | u >>> 32 - 13;
            u = x11 + x7 | 0;
            x15 ^= u << 18 | u >>> 32 - 18;
            u = x0 + x3 | 0;
            x1 ^= u << 7 | u >>> 32 - 7;
            u = x1 + x0 | 0;
            x2 ^= u << 9 | u >>> 32 - 9;
            u = x2 + x1 | 0;
            x3 ^= u << 13 | u >>> 32 - 13;
            u = x3 + x2 | 0;
            x0 ^= u << 18 | u >>> 32 - 18;
            u = x5 + x4 | 0;
            x6 ^= u << 7 | u >>> 32 - 7;
            u = x6 + x5 | 0;
            x7 ^= u << 9 | u >>> 32 - 9;
            u = x7 + x6 | 0;
            x4 ^= u << 13 | u >>> 32 - 13;
            u = x4 + x7 | 0;
            x5 ^= u << 18 | u >>> 32 - 18;
            u = x10 + x9 | 0;
            x11 ^= u << 7 | u >>> 32 - 7;
            u = x11 + x10 | 0;
            x8 ^= u << 9 | u >>> 32 - 9;
            u = x8 + x11 | 0;
            x9 ^= u << 13 | u >>> 32 - 13;
            u = x9 + x8 | 0;
            x10 ^= u << 18 | u >>> 32 - 18;
            u = x15 + x14 | 0;
            x12 ^= u << 7 | u >>> 32 - 7;
            u = x12 + x15 | 0;
            x13 ^= u << 9 | u >>> 32 - 9;
            u = x13 + x12 | 0;
            x14 ^= u << 13 | u >>> 32 - 13;
            u = x14 + x13 | 0;
            x15 ^= u << 18 | u >>> 32 - 18;
          }
          x0 = x0 + j0 | 0;
          x1 = x1 + j1 | 0;
          x2 = x2 + j2 | 0;
          x3 = x3 + j3 | 0;
          x4 = x4 + j4 | 0;
          x5 = x5 + j5 | 0;
          x6 = x6 + j6 | 0;
          x7 = x7 + j7 | 0;
          x8 = x8 + j8 | 0;
          x9 = x9 + j9 | 0;
          x10 = x10 + j10 | 0;
          x11 = x11 + j11 | 0;
          x12 = x12 + j12 | 0;
          x13 = x13 + j13 | 0;
          x14 = x14 + j14 | 0;
          x15 = x15 + j15 | 0;
          o3[0] = x0 >>> 0 & 255;
          o3[1] = x0 >>> 8 & 255;
          o3[2] = x0 >>> 16 & 255;
          o3[3] = x0 >>> 24 & 255;
          o3[4] = x1 >>> 0 & 255;
          o3[5] = x1 >>> 8 & 255;
          o3[6] = x1 >>> 16 & 255;
          o3[7] = x1 >>> 24 & 255;
          o3[8] = x2 >>> 0 & 255;
          o3[9] = x2 >>> 8 & 255;
          o3[10] = x2 >>> 16 & 255;
          o3[11] = x2 >>> 24 & 255;
          o3[12] = x3 >>> 0 & 255;
          o3[13] = x3 >>> 8 & 255;
          o3[14] = x3 >>> 16 & 255;
          o3[15] = x3 >>> 24 & 255;
          o3[16] = x4 >>> 0 & 255;
          o3[17] = x4 >>> 8 & 255;
          o3[18] = x4 >>> 16 & 255;
          o3[19] = x4 >>> 24 & 255;
          o3[20] = x5 >>> 0 & 255;
          o3[21] = x5 >>> 8 & 255;
          o3[22] = x5 >>> 16 & 255;
          o3[23] = x5 >>> 24 & 255;
          o3[24] = x6 >>> 0 & 255;
          o3[25] = x6 >>> 8 & 255;
          o3[26] = x6 >>> 16 & 255;
          o3[27] = x6 >>> 24 & 255;
          o3[28] = x7 >>> 0 & 255;
          o3[29] = x7 >>> 8 & 255;
          o3[30] = x7 >>> 16 & 255;
          o3[31] = x7 >>> 24 & 255;
          o3[32] = x8 >>> 0 & 255;
          o3[33] = x8 >>> 8 & 255;
          o3[34] = x8 >>> 16 & 255;
          o3[35] = x8 >>> 24 & 255;
          o3[36] = x9 >>> 0 & 255;
          o3[37] = x9 >>> 8 & 255;
          o3[38] = x9 >>> 16 & 255;
          o3[39] = x9 >>> 24 & 255;
          o3[40] = x10 >>> 0 & 255;
          o3[41] = x10 >>> 8 & 255;
          o3[42] = x10 >>> 16 & 255;
          o3[43] = x10 >>> 24 & 255;
          o3[44] = x11 >>> 0 & 255;
          o3[45] = x11 >>> 8 & 255;
          o3[46] = x11 >>> 16 & 255;
          o3[47] = x11 >>> 24 & 255;
          o3[48] = x12 >>> 0 & 255;
          o3[49] = x12 >>> 8 & 255;
          o3[50] = x12 >>> 16 & 255;
          o3[51] = x12 >>> 24 & 255;
          o3[52] = x13 >>> 0 & 255;
          o3[53] = x13 >>> 8 & 255;
          o3[54] = x13 >>> 16 & 255;
          o3[55] = x13 >>> 24 & 255;
          o3[56] = x14 >>> 0 & 255;
          o3[57] = x14 >>> 8 & 255;
          o3[58] = x14 >>> 16 & 255;
          o3[59] = x14 >>> 24 & 255;
          o3[60] = x15 >>> 0 & 255;
          o3[61] = x15 >>> 8 & 255;
          o3[62] = x15 >>> 16 & 255;
          o3[63] = x15 >>> 24 & 255;
        }
        function core_hsalsa20(o3, p, k, c) {
          var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
          var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
          for (var i = 0;i < 20; i += 2) {
            u = x0 + x12 | 0;
            x4 ^= u << 7 | u >>> 32 - 7;
            u = x4 + x0 | 0;
            x8 ^= u << 9 | u >>> 32 - 9;
            u = x8 + x4 | 0;
            x12 ^= u << 13 | u >>> 32 - 13;
            u = x12 + x8 | 0;
            x0 ^= u << 18 | u >>> 32 - 18;
            u = x5 + x1 | 0;
            x9 ^= u << 7 | u >>> 32 - 7;
            u = x9 + x5 | 0;
            x13 ^= u << 9 | u >>> 32 - 9;
            u = x13 + x9 | 0;
            x1 ^= u << 13 | u >>> 32 - 13;
            u = x1 + x13 | 0;
            x5 ^= u << 18 | u >>> 32 - 18;
            u = x10 + x6 | 0;
            x14 ^= u << 7 | u >>> 32 - 7;
            u = x14 + x10 | 0;
            x2 ^= u << 9 | u >>> 32 - 9;
            u = x2 + x14 | 0;
            x6 ^= u << 13 | u >>> 32 - 13;
            u = x6 + x2 | 0;
            x10 ^= u << 18 | u >>> 32 - 18;
            u = x15 + x11 | 0;
            x3 ^= u << 7 | u >>> 32 - 7;
            u = x3 + x15 | 0;
            x7 ^= u << 9 | u >>> 32 - 9;
            u = x7 + x3 | 0;
            x11 ^= u << 13 | u >>> 32 - 13;
            u = x11 + x7 | 0;
            x15 ^= u << 18 | u >>> 32 - 18;
            u = x0 + x3 | 0;
            x1 ^= u << 7 | u >>> 32 - 7;
            u = x1 + x0 | 0;
            x2 ^= u << 9 | u >>> 32 - 9;
            u = x2 + x1 | 0;
            x3 ^= u << 13 | u >>> 32 - 13;
            u = x3 + x2 | 0;
            x0 ^= u << 18 | u >>> 32 - 18;
            u = x5 + x4 | 0;
            x6 ^= u << 7 | u >>> 32 - 7;
            u = x6 + x5 | 0;
            x7 ^= u << 9 | u >>> 32 - 9;
            u = x7 + x6 | 0;
            x4 ^= u << 13 | u >>> 32 - 13;
            u = x4 + x7 | 0;
            x5 ^= u << 18 | u >>> 32 - 18;
            u = x10 + x9 | 0;
            x11 ^= u << 7 | u >>> 32 - 7;
            u = x11 + x10 | 0;
            x8 ^= u << 9 | u >>> 32 - 9;
            u = x8 + x11 | 0;
            x9 ^= u << 13 | u >>> 32 - 13;
            u = x9 + x8 | 0;
            x10 ^= u << 18 | u >>> 32 - 18;
            u = x15 + x14 | 0;
            x12 ^= u << 7 | u >>> 32 - 7;
            u = x12 + x15 | 0;
            x13 ^= u << 9 | u >>> 32 - 9;
            u = x13 + x12 | 0;
            x14 ^= u << 13 | u >>> 32 - 13;
            u = x14 + x13 | 0;
            x15 ^= u << 18 | u >>> 32 - 18;
          }
          o3[0] = x0 >>> 0 & 255;
          o3[1] = x0 >>> 8 & 255;
          o3[2] = x0 >>> 16 & 255;
          o3[3] = x0 >>> 24 & 255;
          o3[4] = x5 >>> 0 & 255;
          o3[5] = x5 >>> 8 & 255;
          o3[6] = x5 >>> 16 & 255;
          o3[7] = x5 >>> 24 & 255;
          o3[8] = x10 >>> 0 & 255;
          o3[9] = x10 >>> 8 & 255;
          o3[10] = x10 >>> 16 & 255;
          o3[11] = x10 >>> 24 & 255;
          o3[12] = x15 >>> 0 & 255;
          o3[13] = x15 >>> 8 & 255;
          o3[14] = x15 >>> 16 & 255;
          o3[15] = x15 >>> 24 & 255;
          o3[16] = x6 >>> 0 & 255;
          o3[17] = x6 >>> 8 & 255;
          o3[18] = x6 >>> 16 & 255;
          o3[19] = x6 >>> 24 & 255;
          o3[20] = x7 >>> 0 & 255;
          o3[21] = x7 >>> 8 & 255;
          o3[22] = x7 >>> 16 & 255;
          o3[23] = x7 >>> 24 & 255;
          o3[24] = x8 >>> 0 & 255;
          o3[25] = x8 >>> 8 & 255;
          o3[26] = x8 >>> 16 & 255;
          o3[27] = x8 >>> 24 & 255;
          o3[28] = x9 >>> 0 & 255;
          o3[29] = x9 >>> 8 & 255;
          o3[30] = x9 >>> 16 & 255;
          o3[31] = x9 >>> 24 & 255;
        }
        function crypto_core_salsa20(out, inp, k, c) {
          core_salsa20(out, inp, k, c);
        }
        function crypto_core_hsalsa20(out, inp, k, c) {
          core_hsalsa20(out, inp, k, c);
        }
        var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
        function crypto_stream_salsa20_xor(c, cpos, m, mpos, b, n, k) {
          var z = new Uint8Array(16), x = new Uint8Array(64);
          var u, i;
          for (i = 0;i < 16; i++)
            z[i] = 0;
          for (i = 0;i < 8; i++)
            z[i] = n[i];
          while (b >= 64) {
            crypto_core_salsa20(x, z, k, sigma);
            for (i = 0;i < 64; i++)
              c[cpos + i] = m[mpos + i] ^ x[i];
            u = 1;
            for (i = 8;i < 16; i++) {
              u = u + (z[i] & 255) | 0;
              z[i] = u & 255;
              u >>>= 8;
            }
            b -= 64;
            cpos += 64;
            mpos += 64;
          }
          if (b > 0) {
            crypto_core_salsa20(x, z, k, sigma);
            for (i = 0;i < b; i++)
              c[cpos + i] = m[mpos + i] ^ x[i];
          }
          return 0;
        }
        function crypto_stream_salsa20(c, cpos, b, n, k) {
          var z = new Uint8Array(16), x = new Uint8Array(64);
          var u, i;
          for (i = 0;i < 16; i++)
            z[i] = 0;
          for (i = 0;i < 8; i++)
            z[i] = n[i];
          while (b >= 64) {
            crypto_core_salsa20(x, z, k, sigma);
            for (i = 0;i < 64; i++)
              c[cpos + i] = x[i];
            u = 1;
            for (i = 8;i < 16; i++) {
              u = u + (z[i] & 255) | 0;
              z[i] = u & 255;
              u >>>= 8;
            }
            b -= 64;
            cpos += 64;
          }
          if (b > 0) {
            crypto_core_salsa20(x, z, k, sigma);
            for (i = 0;i < b; i++)
              c[cpos + i] = x[i];
          }
          return 0;
        }
        function crypto_stream(c, cpos, d, n, k) {
          var s3 = new Uint8Array(32);
          crypto_core_hsalsa20(s3, n, k, sigma);
          var sn = new Uint8Array(8);
          for (var i = 0;i < 8; i++)
            sn[i] = n[i + 16];
          return crypto_stream_salsa20(c, cpos, d, sn, s3);
        }
        function crypto_stream_xor(c, cpos, m, mpos, d, n, k) {
          var s3 = new Uint8Array(32);
          crypto_core_hsalsa20(s3, n, k, sigma);
          var sn = new Uint8Array(8);
          for (var i = 0;i < 8; i++)
            sn[i] = n[i + 16];
          return crypto_stream_salsa20_xor(c, cpos, m, mpos, d, sn, s3);
        }
        var poly1305 = function(key) {
          this.buffer = new Uint8Array(16);
          this.r = new Uint16Array(10);
          this.h = new Uint16Array(10);
          this.pad = new Uint16Array(8);
          this.leftover = 0;
          this.fin = 0;
          var t0, t1, t2, t3, t4, t5, t6, t7;
          t0 = key[0] & 255 | (key[1] & 255) << 8;
          this.r[0] = t0 & 8191;
          t1 = key[2] & 255 | (key[3] & 255) << 8;
          this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
          t2 = key[4] & 255 | (key[5] & 255) << 8;
          this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
          t3 = key[6] & 255 | (key[7] & 255) << 8;
          this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
          t4 = key[8] & 255 | (key[9] & 255) << 8;
          this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
          this.r[5] = t4 >>> 1 & 8190;
          t5 = key[10] & 255 | (key[11] & 255) << 8;
          this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
          t6 = key[12] & 255 | (key[13] & 255) << 8;
          this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
          t7 = key[14] & 255 | (key[15] & 255) << 8;
          this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
          this.r[9] = t7 >>> 5 & 127;
          this.pad[0] = key[16] & 255 | (key[17] & 255) << 8;
          this.pad[1] = key[18] & 255 | (key[19] & 255) << 8;
          this.pad[2] = key[20] & 255 | (key[21] & 255) << 8;
          this.pad[3] = key[22] & 255 | (key[23] & 255) << 8;
          this.pad[4] = key[24] & 255 | (key[25] & 255) << 8;
          this.pad[5] = key[26] & 255 | (key[27] & 255) << 8;
          this.pad[6] = key[28] & 255 | (key[29] & 255) << 8;
          this.pad[7] = key[30] & 255 | (key[31] & 255) << 8;
        };
        poly1305.prototype.blocks = function(m, mpos, bytes) {
          var hibit = this.fin ? 0 : 1 << 11;
          var t0, t1, t2, t3, t4, t5, t6, t7, c;
          var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;
          var h0 = this.h[0], h1 = this.h[1], h2 = this.h[2], h3 = this.h[3], h4 = this.h[4], h5 = this.h[5], h6 = this.h[6], h7 = this.h[7], h8 = this.h[8], h9 = this.h[9];
          var r0 = this.r[0], r1 = this.r[1], r2 = this.r[2], r3 = this.r[3], r4 = this.r[4], r5 = this.r[5], r6 = this.r[6], r7 = this.r[7], r8 = this.r[8], r9 = this.r[9];
          while (bytes >= 16) {
            t0 = m[mpos + 0] & 255 | (m[mpos + 1] & 255) << 8;
            h0 += t0 & 8191;
            t1 = m[mpos + 2] & 255 | (m[mpos + 3] & 255) << 8;
            h1 += (t0 >>> 13 | t1 << 3) & 8191;
            t2 = m[mpos + 4] & 255 | (m[mpos + 5] & 255) << 8;
            h2 += (t1 >>> 10 | t2 << 6) & 8191;
            t3 = m[mpos + 6] & 255 | (m[mpos + 7] & 255) << 8;
            h3 += (t2 >>> 7 | t3 << 9) & 8191;
            t4 = m[mpos + 8] & 255 | (m[mpos + 9] & 255) << 8;
            h4 += (t3 >>> 4 | t4 << 12) & 8191;
            h5 += t4 >>> 1 & 8191;
            t5 = m[mpos + 10] & 255 | (m[mpos + 11] & 255) << 8;
            h6 += (t4 >>> 14 | t5 << 2) & 8191;
            t6 = m[mpos + 12] & 255 | (m[mpos + 13] & 255) << 8;
            h7 += (t5 >>> 11 | t6 << 5) & 8191;
            t7 = m[mpos + 14] & 255 | (m[mpos + 15] & 255) << 8;
            h8 += (t6 >>> 8 | t7 << 8) & 8191;
            h9 += t7 >>> 5 | hibit;
            c = 0;
            d0 = c;
            d0 += h0 * r0;
            d0 += h1 * (5 * r9);
            d0 += h2 * (5 * r8);
            d0 += h3 * (5 * r7);
            d0 += h4 * (5 * r6);
            c = d0 >>> 13;
            d0 &= 8191;
            d0 += h5 * (5 * r5);
            d0 += h6 * (5 * r4);
            d0 += h7 * (5 * r3);
            d0 += h8 * (5 * r2);
            d0 += h9 * (5 * r1);
            c += d0 >>> 13;
            d0 &= 8191;
            d1 = c;
            d1 += h0 * r1;
            d1 += h1 * r0;
            d1 += h2 * (5 * r9);
            d1 += h3 * (5 * r8);
            d1 += h4 * (5 * r7);
            c = d1 >>> 13;
            d1 &= 8191;
            d1 += h5 * (5 * r6);
            d1 += h6 * (5 * r5);
            d1 += h7 * (5 * r4);
            d1 += h8 * (5 * r3);
            d1 += h9 * (5 * r2);
            c += d1 >>> 13;
            d1 &= 8191;
            d2 = c;
            d2 += h0 * r2;
            d2 += h1 * r1;
            d2 += h2 * r0;
            d2 += h3 * (5 * r9);
            d2 += h4 * (5 * r8);
            c = d2 >>> 13;
            d2 &= 8191;
            d2 += h5 * (5 * r7);
            d2 += h6 * (5 * r6);
            d2 += h7 * (5 * r5);
            d2 += h8 * (5 * r4);
            d2 += h9 * (5 * r3);
            c += d2 >>> 13;
            d2 &= 8191;
            d3 = c;
            d3 += h0 * r3;
            d3 += h1 * r2;
            d3 += h2 * r1;
            d3 += h3 * r0;
            d3 += h4 * (5 * r9);
            c = d3 >>> 13;
            d3 &= 8191;
            d3 += h5 * (5 * r8);
            d3 += h6 * (5 * r7);
            d3 += h7 * (5 * r6);
            d3 += h8 * (5 * r5);
            d3 += h9 * (5 * r4);
            c += d3 >>> 13;
            d3 &= 8191;
            d4 = c;
            d4 += h0 * r4;
            d4 += h1 * r3;
            d4 += h2 * r2;
            d4 += h3 * r1;
            d4 += h4 * r0;
            c = d4 >>> 13;
            d4 &= 8191;
            d4 += h5 * (5 * r9);
            d4 += h6 * (5 * r8);
            d4 += h7 * (5 * r7);
            d4 += h8 * (5 * r6);
            d4 += h9 * (5 * r5);
            c += d4 >>> 13;
            d4 &= 8191;
            d5 = c;
            d5 += h0 * r5;
            d5 += h1 * r4;
            d5 += h2 * r3;
            d5 += h3 * r2;
            d5 += h4 * r1;
            c = d5 >>> 13;
            d5 &= 8191;
            d5 += h5 * r0;
            d5 += h6 * (5 * r9);
            d5 += h7 * (5 * r8);
            d5 += h8 * (5 * r7);
            d5 += h9 * (5 * r6);
            c += d5 >>> 13;
            d5 &= 8191;
            d6 = c;
            d6 += h0 * r6;
            d6 += h1 * r5;
            d6 += h2 * r4;
            d6 += h3 * r3;
            d6 += h4 * r2;
            c = d6 >>> 13;
            d6 &= 8191;
            d6 += h5 * r1;
            d6 += h6 * r0;
            d6 += h7 * (5 * r9);
            d6 += h8 * (5 * r8);
            d6 += h9 * (5 * r7);
            c += d6 >>> 13;
            d6 &= 8191;
            d7 = c;
            d7 += h0 * r7;
            d7 += h1 * r6;
            d7 += h2 * r5;
            d7 += h3 * r4;
            d7 += h4 * r3;
            c = d7 >>> 13;
            d7 &= 8191;
            d7 += h5 * r2;
            d7 += h6 * r1;
            d7 += h7 * r0;
            d7 += h8 * (5 * r9);
            d7 += h9 * (5 * r8);
            c += d7 >>> 13;
            d7 &= 8191;
            d8 = c;
            d8 += h0 * r8;
            d8 += h1 * r7;
            d8 += h2 * r6;
            d8 += h3 * r5;
            d8 += h4 * r4;
            c = d8 >>> 13;
            d8 &= 8191;
            d8 += h5 * r3;
            d8 += h6 * r2;
            d8 += h7 * r1;
            d8 += h8 * r0;
            d8 += h9 * (5 * r9);
            c += d8 >>> 13;
            d8 &= 8191;
            d9 = c;
            d9 += h0 * r9;
            d9 += h1 * r8;
            d9 += h2 * r7;
            d9 += h3 * r6;
            d9 += h4 * r5;
            c = d9 >>> 13;
            d9 &= 8191;
            d9 += h5 * r4;
            d9 += h6 * r3;
            d9 += h7 * r2;
            d9 += h8 * r1;
            d9 += h9 * r0;
            c += d9 >>> 13;
            d9 &= 8191;
            c = (c << 2) + c | 0;
            c = c + d0 | 0;
            d0 = c & 8191;
            c = c >>> 13;
            d1 += c;
            h0 = d0;
            h1 = d1;
            h2 = d2;
            h3 = d3;
            h4 = d4;
            h5 = d5;
            h6 = d6;
            h7 = d7;
            h8 = d8;
            h9 = d9;
            mpos += 16;
            bytes -= 16;
          }
          this.h[0] = h0;
          this.h[1] = h1;
          this.h[2] = h2;
          this.h[3] = h3;
          this.h[4] = h4;
          this.h[5] = h5;
          this.h[6] = h6;
          this.h[7] = h7;
          this.h[8] = h8;
          this.h[9] = h9;
        };
        poly1305.prototype.finish = function(mac, macpos) {
          var g = new Uint16Array(10);
          var c, mask, f, i;
          if (this.leftover) {
            i = this.leftover;
            this.buffer[i++] = 1;
            for (;i < 16; i++)
              this.buffer[i] = 0;
            this.fin = 1;
            this.blocks(this.buffer, 0, 16);
          }
          c = this.h[1] >>> 13;
          this.h[1] &= 8191;
          for (i = 2;i < 10; i++) {
            this.h[i] += c;
            c = this.h[i] >>> 13;
            this.h[i] &= 8191;
          }
          this.h[0] += c * 5;
          c = this.h[0] >>> 13;
          this.h[0] &= 8191;
          this.h[1] += c;
          c = this.h[1] >>> 13;
          this.h[1] &= 8191;
          this.h[2] += c;
          g[0] = this.h[0] + 5;
          c = g[0] >>> 13;
          g[0] &= 8191;
          for (i = 1;i < 10; i++) {
            g[i] = this.h[i] + c;
            c = g[i] >>> 13;
            g[i] &= 8191;
          }
          g[9] -= 1 << 13;
          mask = (c ^ 1) - 1;
          for (i = 0;i < 10; i++)
            g[i] &= mask;
          mask = ~mask;
          for (i = 0;i < 10; i++)
            this.h[i] = this.h[i] & mask | g[i];
          this.h[0] = (this.h[0] | this.h[1] << 13) & 65535;
          this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535;
          this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535;
          this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535;
          this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535;
          this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535;
          this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535;
          this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535;
          f = this.h[0] + this.pad[0];
          this.h[0] = f & 65535;
          for (i = 1;i < 8; i++) {
            f = (this.h[i] + this.pad[i] | 0) + (f >>> 16) | 0;
            this.h[i] = f & 65535;
          }
          mac[macpos + 0] = this.h[0] >>> 0 & 255;
          mac[macpos + 1] = this.h[0] >>> 8 & 255;
          mac[macpos + 2] = this.h[1] >>> 0 & 255;
          mac[macpos + 3] = this.h[1] >>> 8 & 255;
          mac[macpos + 4] = this.h[2] >>> 0 & 255;
          mac[macpos + 5] = this.h[2] >>> 8 & 255;
          mac[macpos + 6] = this.h[3] >>> 0 & 255;
          mac[macpos + 7] = this.h[3] >>> 8 & 255;
          mac[macpos + 8] = this.h[4] >>> 0 & 255;
          mac[macpos + 9] = this.h[4] >>> 8 & 255;
          mac[macpos + 10] = this.h[5] >>> 0 & 255;
          mac[macpos + 11] = this.h[5] >>> 8 & 255;
          mac[macpos + 12] = this.h[6] >>> 0 & 255;
          mac[macpos + 13] = this.h[6] >>> 8 & 255;
          mac[macpos + 14] = this.h[7] >>> 0 & 255;
          mac[macpos + 15] = this.h[7] >>> 8 & 255;
        };
        poly1305.prototype.update = function(m, mpos, bytes) {
          var i, want;
          if (this.leftover) {
            want = 16 - this.leftover;
            if (want > bytes)
              want = bytes;
            for (i = 0;i < want; i++)
              this.buffer[this.leftover + i] = m[mpos + i];
            bytes -= want;
            mpos += want;
            this.leftover += want;
            if (this.leftover < 16)
              return;
            this.blocks(this.buffer, 0, 16);
            this.leftover = 0;
          }
          if (bytes >= 16) {
            want = bytes - bytes % 16;
            this.blocks(m, mpos, want);
            mpos += want;
            bytes -= want;
          }
          if (bytes) {
            for (i = 0;i < bytes; i++)
              this.buffer[this.leftover + i] = m[mpos + i];
            this.leftover += bytes;
          }
        };
        function crypto_onetimeauth(out, outpos, m, mpos, n, k) {
          var s3 = new poly1305(k);
          s3.update(m, mpos, n);
          s3.finish(out, outpos);
          return 0;
        }
        function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {
          var x = new Uint8Array(16);
          crypto_onetimeauth(x, 0, m, mpos, n, k);
          return crypto_verify_16(h, hpos, x, 0);
        }
        function crypto_secretbox(c, m, d, n, k) {
          var i;
          if (d < 32)
            return -1;
          crypto_stream_xor(c, 0, m, 0, d, n, k);
          crypto_onetimeauth(c, 16, c, 32, d - 32, c);
          for (i = 0;i < 16; i++)
            c[i] = 0;
          return 0;
        }
        function crypto_secretbox_open(m, c, d, n, k) {
          var i;
          var x = new Uint8Array(32);
          if (d < 32)
            return -1;
          crypto_stream(x, 0, 32, n, k);
          if (crypto_onetimeauth_verify(c, 16, c, 32, d - 32, x) !== 0)
            return -1;
          crypto_stream_xor(m, 0, c, 0, d, n, k);
          for (i = 0;i < 32; i++)
            m[i] = 0;
          return 0;
        }
        function set25519(r, a) {
          var i;
          for (i = 0;i < 16; i++)
            r[i] = a[i] | 0;
        }
        function car25519(o3) {
          var i, v, c = 1;
          for (i = 0;i < 16; i++) {
            v = o3[i] + c + 65535;
            c = Math.floor(v / 65536);
            o3[i] = v - c * 65536;
          }
          o3[0] += c - 1 + 37 * (c - 1);
        }
        function sel25519(p, q, b) {
          var t, c = ~(b - 1);
          for (var i = 0;i < 16; i++) {
            t = c & (p[i] ^ q[i]);
            p[i] ^= t;
            q[i] ^= t;
          }
        }
        function pack25519(o3, n) {
          var i, j, b;
          var m = gf(), t = gf();
          for (i = 0;i < 16; i++)
            t[i] = n[i];
          car25519(t);
          car25519(t);
          car25519(t);
          for (j = 0;j < 2; j++) {
            m[0] = t[0] - 65517;
            for (i = 1;i < 15; i++) {
              m[i] = t[i] - 65535 - (m[i - 1] >> 16 & 1);
              m[i - 1] &= 65535;
            }
            m[15] = t[15] - 32767 - (m[14] >> 16 & 1);
            b = m[15] >> 16 & 1;
            m[14] &= 65535;
            sel25519(t, m, 1 - b);
          }
          for (i = 0;i < 16; i++) {
            o3[2 * i] = t[i] & 255;
            o3[2 * i + 1] = t[i] >> 8;
          }
        }
        function neq25519(a, b) {
          var c = new Uint8Array(32), d = new Uint8Array(32);
          pack25519(c, a);
          pack25519(d, b);
          return crypto_verify_32(c, 0, d, 0);
        }
        function par25519(a) {
          var d = new Uint8Array(32);
          pack25519(d, a);
          return d[0] & 1;
        }
        function unpack25519(o3, n) {
          var i;
          for (i = 0;i < 16; i++)
            o3[i] = n[2 * i] + (n[2 * i + 1] << 8);
          o3[15] &= 32767;
        }
        function A(o3, a, b) {
          for (var i = 0;i < 16; i++)
            o3[i] = a[i] + b[i];
        }
        function Z(o3, a, b) {
          for (var i = 0;i < 16; i++)
            o3[i] = a[i] - b[i];
        }
        function M(o3, a, b) {
          var v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
          v = a[0];
          t0 += v * b0;
          t1 += v * b1;
          t2 += v * b2;
          t3 += v * b3;
          t4 += v * b4;
          t5 += v * b5;
          t6 += v * b6;
          t7 += v * b7;
          t8 += v * b8;
          t9 += v * b9;
          t10 += v * b10;
          t11 += v * b11;
          t12 += v * b12;
          t13 += v * b13;
          t14 += v * b14;
          t15 += v * b15;
          v = a[1];
          t1 += v * b0;
          t2 += v * b1;
          t3 += v * b2;
          t4 += v * b3;
          t5 += v * b4;
          t6 += v * b5;
          t7 += v * b6;
          t8 += v * b7;
          t9 += v * b8;
          t10 += v * b9;
          t11 += v * b10;
          t12 += v * b11;
          t13 += v * b12;
          t14 += v * b13;
          t15 += v * b14;
          t16 += v * b15;
          v = a[2];
          t2 += v * b0;
          t3 += v * b1;
          t4 += v * b2;
          t5 += v * b3;
          t6 += v * b4;
          t7 += v * b5;
          t8 += v * b6;
          t9 += v * b7;
          t10 += v * b8;
          t11 += v * b9;
          t12 += v * b10;
          t13 += v * b11;
          t14 += v * b12;
          t15 += v * b13;
          t16 += v * b14;
          t17 += v * b15;
          v = a[3];
          t3 += v * b0;
          t4 += v * b1;
          t5 += v * b2;
          t6 += v * b3;
          t7 += v * b4;
          t8 += v * b5;
          t9 += v * b6;
          t10 += v * b7;
          t11 += v * b8;
          t12 += v * b9;
          t13 += v * b10;
          t14 += v * b11;
          t15 += v * b12;
          t16 += v * b13;
          t17 += v * b14;
          t18 += v * b15;
          v = a[4];
          t4 += v * b0;
          t5 += v * b1;
          t6 += v * b2;
          t7 += v * b3;
          t8 += v * b4;
          t9 += v * b5;
          t10 += v * b6;
          t11 += v * b7;
          t12 += v * b8;
          t13 += v * b9;
          t14 += v * b10;
          t15 += v * b11;
          t16 += v * b12;
          t17 += v * b13;
          t18 += v * b14;
          t19 += v * b15;
          v = a[5];
          t5 += v * b0;
          t6 += v * b1;
          t7 += v * b2;
          t8 += v * b3;
          t9 += v * b4;
          t10 += v * b5;
          t11 += v * b6;
          t12 += v * b7;
          t13 += v * b8;
          t14 += v * b9;
          t15 += v * b10;
          t16 += v * b11;
          t17 += v * b12;
          t18 += v * b13;
          t19 += v * b14;
          t20 += v * b15;
          v = a[6];
          t6 += v * b0;
          t7 += v * b1;
          t8 += v * b2;
          t9 += v * b3;
          t10 += v * b4;
          t11 += v * b5;
          t12 += v * b6;
          t13 += v * b7;
          t14 += v * b8;
          t15 += v * b9;
          t16 += v * b10;
          t17 += v * b11;
          t18 += v * b12;
          t19 += v * b13;
          t20 += v * b14;
          t21 += v * b15;
          v = a[7];
          t7 += v * b0;
          t8 += v * b1;
          t9 += v * b2;
          t10 += v * b3;
          t11 += v * b4;
          t12 += v * b5;
          t13 += v * b6;
          t14 += v * b7;
          t15 += v * b8;
          t16 += v * b9;
          t17 += v * b10;
          t18 += v * b11;
          t19 += v * b12;
          t20 += v * b13;
          t21 += v * b14;
          t22 += v * b15;
          v = a[8];
          t8 += v * b0;
          t9 += v * b1;
          t10 += v * b2;
          t11 += v * b3;
          t12 += v * b4;
          t13 += v * b5;
          t14 += v * b6;
          t15 += v * b7;
          t16 += v * b8;
          t17 += v * b9;
          t18 += v * b10;
          t19 += v * b11;
          t20 += v * b12;
          t21 += v * b13;
          t22 += v * b14;
          t23 += v * b15;
          v = a[9];
          t9 += v * b0;
          t10 += v * b1;
          t11 += v * b2;
          t12 += v * b3;
          t13 += v * b4;
          t14 += v * b5;
          t15 += v * b6;
          t16 += v * b7;
          t17 += v * b8;
          t18 += v * b9;
          t19 += v * b10;
          t20 += v * b11;
          t21 += v * b12;
          t22 += v * b13;
          t23 += v * b14;
          t24 += v * b15;
          v = a[10];
          t10 += v * b0;
          t11 += v * b1;
          t12 += v * b2;
          t13 += v * b3;
          t14 += v * b4;
          t15 += v * b5;
          t16 += v * b6;
          t17 += v * b7;
          t18 += v * b8;
          t19 += v * b9;
          t20 += v * b10;
          t21 += v * b11;
          t22 += v * b12;
          t23 += v * b13;
          t24 += v * b14;
          t25 += v * b15;
          v = a[11];
          t11 += v * b0;
          t12 += v * b1;
          t13 += v * b2;
          t14 += v * b3;
          t15 += v * b4;
          t16 += v * b5;
          t17 += v * b6;
          t18 += v * b7;
          t19 += v * b8;
          t20 += v * b9;
          t21 += v * b10;
          t22 += v * b11;
          t23 += v * b12;
          t24 += v * b13;
          t25 += v * b14;
          t26 += v * b15;
          v = a[12];
          t12 += v * b0;
          t13 += v * b1;
          t14 += v * b2;
          t15 += v * b3;
          t16 += v * b4;
          t17 += v * b5;
          t18 += v * b6;
          t19 += v * b7;
          t20 += v * b8;
          t21 += v * b9;
          t22 += v * b10;
          t23 += v * b11;
          t24 += v * b12;
          t25 += v * b13;
          t26 += v * b14;
          t27 += v * b15;
          v = a[13];
          t13 += v * b0;
          t14 += v * b1;
          t15 += v * b2;
          t16 += v * b3;
          t17 += v * b4;
          t18 += v * b5;
          t19 += v * b6;
          t20 += v * b7;
          t21 += v * b8;
          t22 += v * b9;
          t23 += v * b10;
          t24 += v * b11;
          t25 += v * b12;
          t26 += v * b13;
          t27 += v * b14;
          t28 += v * b15;
          v = a[14];
          t14 += v * b0;
          t15 += v * b1;
          t16 += v * b2;
          t17 += v * b3;
          t18 += v * b4;
          t19 += v * b5;
          t20 += v * b6;
          t21 += v * b7;
          t22 += v * b8;
          t23 += v * b9;
          t24 += v * b10;
          t25 += v * b11;
          t26 += v * b12;
          t27 += v * b13;
          t28 += v * b14;
          t29 += v * b15;
          v = a[15];
          t15 += v * b0;
          t16 += v * b1;
          t17 += v * b2;
          t18 += v * b3;
          t19 += v * b4;
          t20 += v * b5;
          t21 += v * b6;
          t22 += v * b7;
          t23 += v * b8;
          t24 += v * b9;
          t25 += v * b10;
          t26 += v * b11;
          t27 += v * b12;
          t28 += v * b13;
          t29 += v * b14;
          t30 += v * b15;
          t0 += 38 * t16;
          t1 += 38 * t17;
          t2 += 38 * t18;
          t3 += 38 * t19;
          t4 += 38 * t20;
          t5 += 38 * t21;
          t6 += 38 * t22;
          t7 += 38 * t23;
          t8 += 38 * t24;
          t9 += 38 * t25;
          t10 += 38 * t26;
          t11 += 38 * t27;
          t12 += 38 * t28;
          t13 += 38 * t29;
          t14 += 38 * t30;
          c = 1;
          v = t0 + c + 65535;
          c = Math.floor(v / 65536);
          t0 = v - c * 65536;
          v = t1 + c + 65535;
          c = Math.floor(v / 65536);
          t1 = v - c * 65536;
          v = t2 + c + 65535;
          c = Math.floor(v / 65536);
          t2 = v - c * 65536;
          v = t3 + c + 65535;
          c = Math.floor(v / 65536);
          t3 = v - c * 65536;
          v = t4 + c + 65535;
          c = Math.floor(v / 65536);
          t4 = v - c * 65536;
          v = t5 + c + 65535;
          c = Math.floor(v / 65536);
          t5 = v - c * 65536;
          v = t6 + c + 65535;
          c = Math.floor(v / 65536);
          t6 = v - c * 65536;
          v = t7 + c + 65535;
          c = Math.floor(v / 65536);
          t7 = v - c * 65536;
          v = t8 + c + 65535;
          c = Math.floor(v / 65536);
          t8 = v - c * 65536;
          v = t9 + c + 65535;
          c = Math.floor(v / 65536);
          t9 = v - c * 65536;
          v = t10 + c + 65535;
          c = Math.floor(v / 65536);
          t10 = v - c * 65536;
          v = t11 + c + 65535;
          c = Math.floor(v / 65536);
          t11 = v - c * 65536;
          v = t12 + c + 65535;
          c = Math.floor(v / 65536);
          t12 = v - c * 65536;
          v = t13 + c + 65535;
          c = Math.floor(v / 65536);
          t13 = v - c * 65536;
          v = t14 + c + 65535;
          c = Math.floor(v / 65536);
          t14 = v - c * 65536;
          v = t15 + c + 65535;
          c = Math.floor(v / 65536);
          t15 = v - c * 65536;
          t0 += c - 1 + 37 * (c - 1);
          c = 1;
          v = t0 + c + 65535;
          c = Math.floor(v / 65536);
          t0 = v - c * 65536;
          v = t1 + c + 65535;
          c = Math.floor(v / 65536);
          t1 = v - c * 65536;
          v = t2 + c + 65535;
          c = Math.floor(v / 65536);
          t2 = v - c * 65536;
          v = t3 + c + 65535;
          c = Math.floor(v / 65536);
          t3 = v - c * 65536;
          v = t4 + c + 65535;
          c = Math.floor(v / 65536);
          t4 = v - c * 65536;
          v = t5 + c + 65535;
          c = Math.floor(v / 65536);
          t5 = v - c * 65536;
          v = t6 + c + 65535;
          c = Math.floor(v / 65536);
          t6 = v - c * 65536;
          v = t7 + c + 65535;
          c = Math.floor(v / 65536);
          t7 = v - c * 65536;
          v = t8 + c + 65535;
          c = Math.floor(v / 65536);
          t8 = v - c * 65536;
          v = t9 + c + 65535;
          c = Math.floor(v / 65536);
          t9 = v - c * 65536;
          v = t10 + c + 65535;
          c = Math.floor(v / 65536);
          t10 = v - c * 65536;
          v = t11 + c + 65535;
          c = Math.floor(v / 65536);
          t11 = v - c * 65536;
          v = t12 + c + 65535;
          c = Math.floor(v / 65536);
          t12 = v - c * 65536;
          v = t13 + c + 65535;
          c = Math.floor(v / 65536);
          t13 = v - c * 65536;
          v = t14 + c + 65535;
          c = Math.floor(v / 65536);
          t14 = v - c * 65536;
          v = t15 + c + 65535;
          c = Math.floor(v / 65536);
          t15 = v - c * 65536;
          t0 += c - 1 + 37 * (c - 1);
          o3[0] = t0;
          o3[1] = t1;
          o3[2] = t2;
          o3[3] = t3;
          o3[4] = t4;
          o3[5] = t5;
          o3[6] = t6;
          o3[7] = t7;
          o3[8] = t8;
          o3[9] = t9;
          o3[10] = t10;
          o3[11] = t11;
          o3[12] = t12;
          o3[13] = t13;
          o3[14] = t14;
          o3[15] = t15;
        }
        function S(o3, a) {
          M(o3, a, a);
        }
        function inv25519(o3, i) {
          var c = gf();
          var a;
          for (a = 0;a < 16; a++)
            c[a] = i[a];
          for (a = 253;a >= 0; a--) {
            S(c, c);
            if (a !== 2 && a !== 4)
              M(c, c, i);
          }
          for (a = 0;a < 16; a++)
            o3[a] = c[a];
        }
        function pow2523(o3, i) {
          var c = gf();
          var a;
          for (a = 0;a < 16; a++)
            c[a] = i[a];
          for (a = 250;a >= 0; a--) {
            S(c, c);
            if (a !== 1)
              M(c, c, i);
          }
          for (a = 0;a < 16; a++)
            o3[a] = c[a];
        }
        function crypto_scalarmult(q, n, p) {
          var z = new Uint8Array(32);
          var x = new Float64Array(80), r, i;
          var a = gf(), b = gf(), c = gf(), d = gf(), e7 = gf(), f = gf();
          for (i = 0;i < 31; i++)
            z[i] = n[i];
          z[31] = n[31] & 127 | 64;
          z[0] &= 248;
          unpack25519(x, p);
          for (i = 0;i < 16; i++) {
            b[i] = x[i];
            d[i] = a[i] = c[i] = 0;
          }
          a[0] = d[0] = 1;
          for (i = 254;i >= 0; --i) {
            r = z[i >>> 3] >>> (i & 7) & 1;
            sel25519(a, b, r);
            sel25519(c, d, r);
            A(e7, a, c);
            Z(a, a, c);
            A(c, b, d);
            Z(b, b, d);
            S(d, e7);
            S(f, a);
            M(a, c, a);
            M(c, b, e7);
            A(e7, a, c);
            Z(a, a, c);
            S(b, a);
            Z(c, d, f);
            M(a, c, _121665);
            A(a, a, d);
            M(c, c, a);
            M(a, d, f);
            M(d, b, x);
            S(b, e7);
            sel25519(a, b, r);
            sel25519(c, d, r);
          }
          for (i = 0;i < 16; i++) {
            x[i + 16] = a[i];
            x[i + 32] = c[i];
            x[i + 48] = b[i];
            x[i + 64] = d[i];
          }
          var x32 = x.subarray(32);
          var x16 = x.subarray(16);
          inv25519(x32, x32);
          M(x16, x16, x32);
          pack25519(q, x16);
          return 0;
        }
        function crypto_scalarmult_base(q, n) {
          return crypto_scalarmult(q, n, _9);
        }
        function crypto_box_keypair(y, x) {
          randombytes(x, 32);
          return crypto_scalarmult_base(y, x);
        }
        function crypto_box_beforenm(k, y, x) {
          var s3 = new Uint8Array(32);
          crypto_scalarmult(s3, x, y);
          return crypto_core_hsalsa20(k, _0, s3, sigma);
        }
        var crypto_box_afternm = crypto_secretbox;
        var crypto_box_open_afternm = crypto_secretbox_open;
        function crypto_box(c, m, d, n, y, x) {
          var k = new Uint8Array(32);
          crypto_box_beforenm(k, y, x);
          return crypto_box_afternm(c, m, d, n, k);
        }
        function crypto_box_open(m, c, d, n, y, x) {
          var k = new Uint8Array(32);
          crypto_box_beforenm(k, y, x);
          return crypto_box_open_afternm(m, c, d, n, k);
        }
        var K = [
          1116352408,
          3609767458,
          1899447441,
          602891725,
          3049323471,
          3964484399,
          3921009573,
          2173295548,
          961987163,
          4081628472,
          1508970993,
          3053834265,
          2453635748,
          2937671579,
          2870763221,
          3664609560,
          3624381080,
          2734883394,
          310598401,
          1164996542,
          607225278,
          1323610764,
          1426881987,
          3590304994,
          1925078388,
          4068182383,
          2162078206,
          991336113,
          2614888103,
          633803317,
          3248222580,
          3479774868,
          3835390401,
          2666613458,
          4022224774,
          944711139,
          264347078,
          2341262773,
          604807628,
          2007800933,
          770255983,
          1495990901,
          1249150122,
          1856431235,
          1555081692,
          3175218132,
          1996064986,
          2198950837,
          2554220882,
          3999719339,
          2821834349,
          766784016,
          2952996808,
          2566594879,
          3210313671,
          3203337956,
          3336571891,
          1034457026,
          3584528711,
          2466948901,
          113926993,
          3758326383,
          338241895,
          168717936,
          666307205,
          1188179964,
          773529912,
          1546045734,
          1294757372,
          1522805485,
          1396182291,
          2643833823,
          1695183700,
          2343527390,
          1986661051,
          1014477480,
          2177026350,
          1206759142,
          2456956037,
          344077627,
          2730485921,
          1290863460,
          2820302411,
          3158454273,
          3259730800,
          3505952657,
          3345764771,
          106217008,
          3516065817,
          3606008344,
          3600352804,
          1432725776,
          4094571909,
          1467031594,
          275423344,
          851169720,
          430227734,
          3100823752,
          506948616,
          1363258195,
          659060556,
          3750685593,
          883997877,
          3785050280,
          958139571,
          3318307427,
          1322822218,
          3812723403,
          1537002063,
          2003034995,
          1747873779,
          3602036899,
          1955562222,
          1575990012,
          2024104815,
          1125592928,
          2227730452,
          2716904306,
          2361852424,
          442776044,
          2428436474,
          593698344,
          2756734187,
          3733110249,
          3204031479,
          2999351573,
          3329325298,
          3815920427,
          3391569614,
          3928383900,
          3515267271,
          566280711,
          3940187606,
          3454069534,
          4118630271,
          4000239992,
          116418474,
          1914138554,
          174292421,
          2731055270,
          289380356,
          3203993006,
          460393269,
          320620315,
          685471733,
          587496836,
          852142971,
          1086792851,
          1017036298,
          365543100,
          1126000580,
          2618297676,
          1288033470,
          3409855158,
          1501505948,
          4234509866,
          1607167915,
          987167468,
          1816402316,
          1246189591
        ];
        function crypto_hashblocks_hl(hh, hl, m, n) {
          var wh = new Int32Array(16), wl = new Int32Array(16), bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7, bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7, th, tl, i, j, h, l2, a, b, c, d;
          var ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];
          var pos = 0;
          while (n >= 128) {
            for (i = 0;i < 16; i++) {
              j = 8 * i + pos;
              wh[i] = m[j + 0] << 24 | m[j + 1] << 16 | m[j + 2] << 8 | m[j + 3];
              wl[i] = m[j + 4] << 24 | m[j + 5] << 16 | m[j + 6] << 8 | m[j + 7];
            }
            for (i = 0;i < 80; i++) {
              bh0 = ah0;
              bh1 = ah1;
              bh2 = ah2;
              bh3 = ah3;
              bh4 = ah4;
              bh5 = ah5;
              bh6 = ah6;
              bh7 = ah7;
              bl0 = al0;
              bl1 = al1;
              bl2 = al2;
              bl3 = al3;
              bl4 = al4;
              bl5 = al5;
              bl6 = al6;
              bl7 = al7;
              h = ah7;
              l2 = al7;
              a = l2 & 65535;
              b = l2 >>> 16;
              c = h & 65535;
              d = h >>> 16;
              h = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
              l2 = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
              a += l2 & 65535;
              b += l2 >>> 16;
              c += h & 65535;
              d += h >>> 16;
              h = ah4 & ah5 ^ ~ah4 & ah6;
              l2 = al4 & al5 ^ ~al4 & al6;
              a += l2 & 65535;
              b += l2 >>> 16;
              c += h & 65535;
              d += h >>> 16;
              h = K[i * 2];
              l2 = K[i * 2 + 1];
              a += l2 & 65535;
              b += l2 >>> 16;
              c += h & 65535;
              d += h >>> 16;
              h = wh[i % 16];
              l2 = wl[i % 16];
              a += l2 & 65535;
              b += l2 >>> 16;
              c += h & 65535;
              d += h >>> 16;
              b += a >>> 16;
              c += b >>> 16;
              d += c >>> 16;
              th = c & 65535 | d << 16;
              tl = a & 65535 | b << 16;
              h = th;
              l2 = tl;
              a = l2 & 65535;
              b = l2 >>> 16;
              c = h & 65535;
              d = h >>> 16;
              h = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
              l2 = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
              a += l2 & 65535;
              b += l2 >>> 16;
              c += h & 65535;
              d += h >>> 16;
              h = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
              l2 = al0 & al1 ^ al0 & al2 ^ al1 & al2;
              a += l2 & 65535;
              b += l2 >>> 16;
              c += h & 65535;
              d += h >>> 16;
              b += a >>> 16;
              c += b >>> 16;
              d += c >>> 16;
              bh7 = c & 65535 | d << 16;
              bl7 = a & 65535 | b << 16;
              h = bh3;
              l2 = bl3;
              a = l2 & 65535;
              b = l2 >>> 16;
              c = h & 65535;
              d = h >>> 16;
              h = th;
              l2 = tl;
              a += l2 & 65535;
              b += l2 >>> 16;
              c += h & 65535;
              d += h >>> 16;
              b += a >>> 16;
              c += b >>> 16;
              d += c >>> 16;
              bh3 = c & 65535 | d << 16;
              bl3 = a & 65535 | b << 16;
              ah1 = bh0;
              ah2 = bh1;
              ah3 = bh2;
              ah4 = bh3;
              ah5 = bh4;
              ah6 = bh5;
              ah7 = bh6;
              ah0 = bh7;
              al1 = bl0;
              al2 = bl1;
              al3 = bl2;
              al4 = bl3;
              al5 = bl4;
              al6 = bl5;
              al7 = bl6;
              al0 = bl7;
              if (i % 16 === 15) {
                for (j = 0;j < 16; j++) {
                  h = wh[j];
                  l2 = wl[j];
                  a = l2 & 65535;
                  b = l2 >>> 16;
                  c = h & 65535;
                  d = h >>> 16;
                  h = wh[(j + 9) % 16];
                  l2 = wl[(j + 9) % 16];
                  a += l2 & 65535;
                  b += l2 >>> 16;
                  c += h & 65535;
                  d += h >>> 16;
                  th = wh[(j + 1) % 16];
                  tl = wl[(j + 1) % 16];
                  h = (th >>> 1 | tl << 32 - 1) ^ (th >>> 8 | tl << 32 - 8) ^ th >>> 7;
                  l2 = (tl >>> 1 | th << 32 - 1) ^ (tl >>> 8 | th << 32 - 8) ^ (tl >>> 7 | th << 32 - 7);
                  a += l2 & 65535;
                  b += l2 >>> 16;
                  c += h & 65535;
                  d += h >>> 16;
                  th = wh[(j + 14) % 16];
                  tl = wl[(j + 14) % 16];
                  h = (th >>> 19 | tl << 32 - 19) ^ (tl >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;
                  l2 = (tl >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl << 32 - (61 - 32)) ^ (tl >>> 6 | th << 32 - 6);
                  a += l2 & 65535;
                  b += l2 >>> 16;
                  c += h & 65535;
                  d += h >>> 16;
                  b += a >>> 16;
                  c += b >>> 16;
                  d += c >>> 16;
                  wh[j] = c & 65535 | d << 16;
                  wl[j] = a & 65535 | b << 16;
                }
              }
            }
            h = ah0;
            l2 = al0;
            a = l2 & 65535;
            b = l2 >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = hh[0];
            l2 = hl[0];
            a += l2 & 65535;
            b += l2 >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            hh[0] = ah0 = c & 65535 | d << 16;
            hl[0] = al0 = a & 65535 | b << 16;
            h = ah1;
            l2 = al1;
            a = l2 & 65535;
            b = l2 >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = hh[1];
            l2 = hl[1];
            a += l2 & 65535;
            b += l2 >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            hh[1] = ah1 = c & 65535 | d << 16;
            hl[1] = al1 = a & 65535 | b << 16;
            h = ah2;
            l2 = al2;
            a = l2 & 65535;
            b = l2 >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = hh[2];
            l2 = hl[2];
            a += l2 & 65535;
            b += l2 >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            hh[2] = ah2 = c & 65535 | d << 16;
            hl[2] = al2 = a & 65535 | b << 16;
            h = ah3;
            l2 = al3;
            a = l2 & 65535;
            b = l2 >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = hh[3];
            l2 = hl[3];
            a += l2 & 65535;
            b += l2 >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            hh[3] = ah3 = c & 65535 | d << 16;
            hl[3] = al3 = a & 65535 | b << 16;
            h = ah4;
            l2 = al4;
            a = l2 & 65535;
            b = l2 >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = hh[4];
            l2 = hl[4];
            a += l2 & 65535;
            b += l2 >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            hh[4] = ah4 = c & 65535 | d << 16;
            hl[4] = al4 = a & 65535 | b << 16;
            h = ah5;
            l2 = al5;
            a = l2 & 65535;
            b = l2 >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = hh[5];
            l2 = hl[5];
            a += l2 & 65535;
            b += l2 >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            hh[5] = ah5 = c & 65535 | d << 16;
            hl[5] = al5 = a & 65535 | b << 16;
            h = ah6;
            l2 = al6;
            a = l2 & 65535;
            b = l2 >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = hh[6];
            l2 = hl[6];
            a += l2 & 65535;
            b += l2 >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            hh[6] = ah6 = c & 65535 | d << 16;
            hl[6] = al6 = a & 65535 | b << 16;
            h = ah7;
            l2 = al7;
            a = l2 & 65535;
            b = l2 >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = hh[7];
            l2 = hl[7];
            a += l2 & 65535;
            b += l2 >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            hh[7] = ah7 = c & 65535 | d << 16;
            hl[7] = al7 = a & 65535 | b << 16;
            pos += 128;
            n -= 128;
          }
          return n;
        }
        function crypto_hash(out, m, n) {
          var hh = new Int32Array(8), hl = new Int32Array(8), x = new Uint8Array(256), i, b = n;
          hh[0] = 1779033703;
          hh[1] = 3144134277;
          hh[2] = 1013904242;
          hh[3] = 2773480762;
          hh[4] = 1359893119;
          hh[5] = 2600822924;
          hh[6] = 528734635;
          hh[7] = 1541459225;
          hl[0] = 4089235720;
          hl[1] = 2227873595;
          hl[2] = 4271175723;
          hl[3] = 1595750129;
          hl[4] = 2917565137;
          hl[5] = 725511199;
          hl[6] = 4215389547;
          hl[7] = 327033209;
          crypto_hashblocks_hl(hh, hl, m, n);
          n %= 128;
          for (i = 0;i < n; i++)
            x[i] = m[b - n + i];
          x[n] = 128;
          n = 256 - 128 * (n < 112 ? 1 : 0);
          x[n - 9] = 0;
          ts64(x, n - 8, b / 536870912 | 0, b << 3);
          crypto_hashblocks_hl(hh, hl, x, n);
          for (i = 0;i < 8; i++)
            ts64(out, 8 * i, hh[i], hl[i]);
          return 0;
        }
        function add2(p, q) {
          var a = gf(), b = gf(), c = gf(), d = gf(), e7 = gf(), f = gf(), g = gf(), h = gf(), t = gf();
          Z(a, p[1], p[0]);
          Z(t, q[1], q[0]);
          M(a, a, t);
          A(b, p[0], p[1]);
          A(t, q[0], q[1]);
          M(b, b, t);
          M(c, p[3], q[3]);
          M(c, c, D22);
          M(d, p[2], q[2]);
          A(d, d, d);
          Z(e7, b, a);
          Z(f, d, c);
          A(g, d, c);
          A(h, b, a);
          M(p[0], e7, f);
          M(p[1], h, g);
          M(p[2], g, f);
          M(p[3], e7, h);
        }
        function cswap(p, q, b) {
          var i;
          for (i = 0;i < 4; i++) {
            sel25519(p[i], q[i], b);
          }
        }
        function pack(r, p) {
          var tx = gf(), ty = gf(), zi = gf();
          inv25519(zi, p[2]);
          M(tx, p[0], zi);
          M(ty, p[1], zi);
          pack25519(r, ty);
          r[31] ^= par25519(tx) << 7;
        }
        function scalarmult(p, q, s3) {
          var b, i;
          set25519(p[0], gf0);
          set25519(p[1], gf1);
          set25519(p[2], gf1);
          set25519(p[3], gf0);
          for (i = 255;i >= 0; --i) {
            b = s3[i / 8 | 0] >> (i & 7) & 1;
            cswap(p, q, b);
            add2(q, p);
            add2(p, p);
            cswap(p, q, b);
          }
        }
        function scalarbase(p, s3) {
          var q = [gf(), gf(), gf(), gf()];
          set25519(q[0], X);
          set25519(q[1], Y);
          set25519(q[2], gf1);
          M(q[3], X, Y);
          scalarmult(p, q, s3);
        }
        function crypto_sign_keypair(pk, sk, seeded) {
          var d = new Uint8Array(64);
          var p = [gf(), gf(), gf(), gf()];
          var i;
          if (!seeded)
            randombytes(sk, 32);
          crypto_hash(d, sk, 32);
          d[0] &= 248;
          d[31] &= 127;
          d[31] |= 64;
          scalarbase(p, d);
          pack(pk, p);
          for (i = 0;i < 32; i++)
            sk[i + 32] = pk[i];
          return 0;
        }
        var L = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
        function modL(r, x) {
          var carry, i, j, k;
          for (i = 63;i >= 32; --i) {
            carry = 0;
            for (j = i - 32, k = i - 12;j < k; ++j) {
              x[j] += carry - 16 * x[i] * L[j - (i - 32)];
              carry = Math.floor((x[j] + 128) / 256);
              x[j] -= carry * 256;
            }
            x[j] += carry;
            x[i] = 0;
          }
          carry = 0;
          for (j = 0;j < 32; j++) {
            x[j] += carry - (x[31] >> 4) * L[j];
            carry = x[j] >> 8;
            x[j] &= 255;
          }
          for (j = 0;j < 32; j++)
            x[j] -= carry * L[j];
          for (i = 0;i < 32; i++) {
            x[i + 1] += x[i] >> 8;
            r[i] = x[i] & 255;
          }
        }
        function reduce(r) {
          var x = new Float64Array(64), i;
          for (i = 0;i < 64; i++)
            x[i] = r[i];
          for (i = 0;i < 64; i++)
            r[i] = 0;
          modL(r, x);
        }
        function crypto_sign(sm, m, n, sk) {
          var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);
          var i, j, x = new Float64Array(64);
          var p = [gf(), gf(), gf(), gf()];
          crypto_hash(d, sk, 32);
          d[0] &= 248;
          d[31] &= 127;
          d[31] |= 64;
          var smlen = n + 64;
          for (i = 0;i < n; i++)
            sm[64 + i] = m[i];
          for (i = 0;i < 32; i++)
            sm[32 + i] = d[32 + i];
          crypto_hash(r, sm.subarray(32), n + 32);
          reduce(r);
          scalarbase(p, r);
          pack(sm, p);
          for (i = 32;i < 64; i++)
            sm[i] = sk[i];
          crypto_hash(h, sm, n + 64);
          reduce(h);
          for (i = 0;i < 64; i++)
            x[i] = 0;
          for (i = 0;i < 32; i++)
            x[i] = r[i];
          for (i = 0;i < 32; i++) {
            for (j = 0;j < 32; j++) {
              x[i + j] += h[i] * d[j];
            }
          }
          modL(sm.subarray(32), x);
          return smlen;
        }
        function unpackneg(r, p) {
          var t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
          set25519(r[2], gf1);
          unpack25519(r[1], p);
          S(num, r[1]);
          M(den, num, D2);
          Z(num, num, r[2]);
          A(den, r[2], den);
          S(den2, den);
          S(den4, den2);
          M(den6, den4, den2);
          M(t, den6, num);
          M(t, t, den);
          pow2523(t, t);
          M(t, t, num);
          M(t, t, den);
          M(t, t, den);
          M(r[0], t, den);
          S(chk, r[0]);
          M(chk, chk, den);
          if (neq25519(chk, num))
            M(r[0], r[0], I);
          S(chk, r[0]);
          M(chk, chk, den);
          if (neq25519(chk, num))
            return -1;
          if (par25519(r[0]) === p[31] >> 7)
            Z(r[0], gf0, r[0]);
          M(r[3], r[0], r[1]);
          return 0;
        }
        function crypto_sign_open(m, sm, n, pk) {
          var i;
          var t = new Uint8Array(32), h = new Uint8Array(64);
          var p = [gf(), gf(), gf(), gf()], q = [gf(), gf(), gf(), gf()];
          if (n < 64)
            return -1;
          if (unpackneg(q, pk))
            return -1;
          for (i = 0;i < n; i++)
            m[i] = sm[i];
          for (i = 0;i < 32; i++)
            m[i + 32] = pk[i];
          crypto_hash(h, m, n);
          reduce(h);
          scalarmult(p, q, h);
          scalarbase(q, sm.subarray(32));
          add2(p, q);
          pack(t, p);
          n -= 64;
          if (crypto_verify_32(sm, 0, t, 0)) {
            for (i = 0;i < n; i++)
              m[i] = 0;
            return -1;
          }
          for (i = 0;i < n; i++)
            m[i] = sm[i + 64];
          return n;
        }
        var crypto_secretbox_KEYBYTES = 32, crypto_secretbox_NONCEBYTES = 24, crypto_secretbox_ZEROBYTES = 32, crypto_secretbox_BOXZEROBYTES = 16, crypto_scalarmult_BYTES = 32, crypto_scalarmult_SCALARBYTES = 32, crypto_box_PUBLICKEYBYTES = 32, crypto_box_SECRETKEYBYTES = 32, crypto_box_BEFORENMBYTES = 32, crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES, crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES, crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES, crypto_sign_BYTES = 64, crypto_sign_PUBLICKEYBYTES = 32, crypto_sign_SECRETKEYBYTES = 64, crypto_sign_SEEDBYTES = 32, crypto_hash_BYTES = 64;
        nacl.lowlevel = {
          crypto_core_hsalsa20,
          crypto_stream_xor,
          crypto_stream,
          crypto_stream_salsa20_xor,
          crypto_stream_salsa20,
          crypto_onetimeauth,
          crypto_onetimeauth_verify,
          crypto_verify_16,
          crypto_verify_32,
          crypto_secretbox,
          crypto_secretbox_open,
          crypto_scalarmult,
          crypto_scalarmult_base,
          crypto_box_beforenm,
          crypto_box_afternm,
          crypto_box,
          crypto_box_open,
          crypto_box_keypair,
          crypto_hash,
          crypto_sign,
          crypto_sign_keypair,
          crypto_sign_open,
          crypto_secretbox_KEYBYTES,
          crypto_secretbox_NONCEBYTES,
          crypto_secretbox_ZEROBYTES,
          crypto_secretbox_BOXZEROBYTES,
          crypto_scalarmult_BYTES,
          crypto_scalarmult_SCALARBYTES,
          crypto_box_PUBLICKEYBYTES,
          crypto_box_SECRETKEYBYTES,
          crypto_box_BEFORENMBYTES,
          crypto_box_NONCEBYTES,
          crypto_box_ZEROBYTES,
          crypto_box_BOXZEROBYTES,
          crypto_sign_BYTES,
          crypto_sign_PUBLICKEYBYTES,
          crypto_sign_SECRETKEYBYTES,
          crypto_sign_SEEDBYTES,
          crypto_hash_BYTES,
          gf,
          D: D2,
          L,
          pack25519,
          unpack25519,
          M,
          A,
          S,
          Z,
          pow2523,
          add: add2,
          set25519,
          modL,
          scalarmult,
          scalarbase
        };
        function checkLengths(k, n) {
          if (k.length !== crypto_secretbox_KEYBYTES)
            throw new Error("bad key size");
          if (n.length !== crypto_secretbox_NONCEBYTES)
            throw new Error("bad nonce size");
        }
        function checkBoxLengths(pk, sk) {
          if (pk.length !== crypto_box_PUBLICKEYBYTES)
            throw new Error("bad public key size");
          if (sk.length !== crypto_box_SECRETKEYBYTES)
            throw new Error("bad secret key size");
        }
        function checkArrayTypes() {
          for (var i = 0;i < arguments.length; i++) {
            if (!(arguments[i] instanceof Uint8Array))
              throw new TypeError("unexpected type, use Uint8Array");
          }
        }
        function cleanup(arr) {
          for (var i = 0;i < arr.length; i++)
            arr[i] = 0;
        }
        nacl.randomBytes = function(n) {
          var b = new Uint8Array(n);
          randombytes(b, n);
          return b;
        };
        nacl.secretbox = function(msg, nonce, key) {
          checkArrayTypes(msg, nonce, key);
          checkLengths(key, nonce);
          var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
          var c = new Uint8Array(m.length);
          for (var i = 0;i < msg.length; i++)
            m[i + crypto_secretbox_ZEROBYTES] = msg[i];
          crypto_secretbox(c, m, m.length, nonce, key);
          return c.subarray(crypto_secretbox_BOXZEROBYTES);
        };
        nacl.secretbox.open = function(box, nonce, key) {
          checkArrayTypes(box, nonce, key);
          checkLengths(key, nonce);
          var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
          var m = new Uint8Array(c.length);
          for (var i = 0;i < box.length; i++)
            c[i + crypto_secretbox_BOXZEROBYTES] = box[i];
          if (c.length < 32)
            return null;
          if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0)
            return null;
          return m.subarray(crypto_secretbox_ZEROBYTES);
        };
        nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;
        nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
        nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;
        nacl.scalarMult = function(n, p) {
          checkArrayTypes(n, p);
          if (n.length !== crypto_scalarmult_SCALARBYTES)
            throw new Error("bad n size");
          if (p.length !== crypto_scalarmult_BYTES)
            throw new Error("bad p size");
          var q = new Uint8Array(crypto_scalarmult_BYTES);
          crypto_scalarmult(q, n, p);
          return q;
        };
        nacl.scalarMult.base = function(n) {
          checkArrayTypes(n);
          if (n.length !== crypto_scalarmult_SCALARBYTES)
            throw new Error("bad n size");
          var q = new Uint8Array(crypto_scalarmult_BYTES);
          crypto_scalarmult_base(q, n);
          return q;
        };
        nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
        nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;
        nacl.box = function(msg, nonce, publicKey, secretKey) {
          var k = nacl.box.before(publicKey, secretKey);
          return nacl.secretbox(msg, nonce, k);
        };
        nacl.box.before = function(publicKey, secretKey) {
          checkArrayTypes(publicKey, secretKey);
          checkBoxLengths(publicKey, secretKey);
          var k = new Uint8Array(crypto_box_BEFORENMBYTES);
          crypto_box_beforenm(k, publicKey, secretKey);
          return k;
        };
        nacl.box.after = nacl.secretbox;
        nacl.box.open = function(msg, nonce, publicKey, secretKey) {
          var k = nacl.box.before(publicKey, secretKey);
          return nacl.secretbox.open(msg, nonce, k);
        };
        nacl.box.open.after = nacl.secretbox.open;
        nacl.box.keyPair = function() {
          var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
          var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
          crypto_box_keypair(pk, sk);
          return { publicKey: pk, secretKey: sk };
        };
        nacl.box.keyPair.fromSecretKey = function(secretKey) {
          checkArrayTypes(secretKey);
          if (secretKey.length !== crypto_box_SECRETKEYBYTES)
            throw new Error("bad secret key size");
          var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
          crypto_scalarmult_base(pk, secretKey);
          return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
        };
        nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
        nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
        nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
        nacl.box.nonceLength = crypto_box_NONCEBYTES;
        nacl.box.overheadLength = nacl.secretbox.overheadLength;
        nacl.sign = function(msg, secretKey) {
          checkArrayTypes(msg, secretKey);
          if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
            throw new Error("bad secret key size");
          var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);
          crypto_sign(signedMsg, msg, msg.length, secretKey);
          return signedMsg;
        };
        nacl.sign.open = function(signedMsg, publicKey) {
          checkArrayTypes(signedMsg, publicKey);
          if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
            throw new Error("bad public key size");
          var tmp = new Uint8Array(signedMsg.length);
          var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
          if (mlen < 0)
            return null;
          var m = new Uint8Array(mlen);
          for (var i = 0;i < m.length; i++)
            m[i] = tmp[i];
          return m;
        };
        nacl.sign.detached = function(msg, secretKey) {
          var signedMsg = nacl.sign(msg, secretKey);
          var sig = new Uint8Array(crypto_sign_BYTES);
          for (var i = 0;i < sig.length; i++)
            sig[i] = signedMsg[i];
          return sig;
        };
        nacl.sign.detached.verify = function(msg, sig, publicKey) {
          checkArrayTypes(msg, sig, publicKey);
          if (sig.length !== crypto_sign_BYTES)
            throw new Error("bad signature size");
          if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
            throw new Error("bad public key size");
          var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
          var m = new Uint8Array(crypto_sign_BYTES + msg.length);
          var i;
          for (i = 0;i < crypto_sign_BYTES; i++)
            sm[i] = sig[i];
          for (i = 0;i < msg.length; i++)
            sm[i + crypto_sign_BYTES] = msg[i];
          return crypto_sign_open(m, sm, sm.length, publicKey) >= 0;
        };
        nacl.sign.keyPair = function() {
          var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
          var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
          crypto_sign_keypair(pk, sk);
          return { publicKey: pk, secretKey: sk };
        };
        nacl.sign.keyPair.fromSecretKey = function(secretKey) {
          checkArrayTypes(secretKey);
          if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
            throw new Error("bad secret key size");
          var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
          for (var i = 0;i < pk.length; i++)
            pk[i] = secretKey[32 + i];
          return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
        };
        nacl.sign.keyPair.fromSeed = function(seed) {
          checkArrayTypes(seed);
          if (seed.length !== crypto_sign_SEEDBYTES)
            throw new Error("bad seed size");
          var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
          var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
          for (var i = 0;i < 32; i++)
            sk[i] = seed[i];
          crypto_sign_keypair(pk, sk, true);
          return { publicKey: pk, secretKey: sk };
        };
        nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
        nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
        nacl.sign.seedLength = crypto_sign_SEEDBYTES;
        nacl.sign.signatureLength = crypto_sign_BYTES;
        nacl.hash = function(msg) {
          checkArrayTypes(msg);
          var h = new Uint8Array(crypto_hash_BYTES);
          crypto_hash(h, msg, msg.length);
          return h;
        };
        nacl.hash.hashLength = crypto_hash_BYTES;
        nacl.verify = function(x, y) {
          checkArrayTypes(x, y);
          if (x.length === 0 || y.length === 0)
            return false;
          if (x.length !== y.length)
            return false;
          return vn(x, 0, y, 0, x.length) === 0 ? true : false;
        };
        nacl.setPRNG = function(fn) {
          randombytes = fn;
        };
        (function() {
          var crypto3 = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
          if (crypto3 && crypto3.getRandomValues) {
            var QUOTA = 65536;
            nacl.setPRNG(function(x, n) {
              var i, v = new Uint8Array(n);
              for (i = 0;i < n; i += QUOTA) {
                crypto3.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));
              }
              for (i = 0;i < n; i++)
                x[i] = v[i];
              cleanup(v);
            });
          } else if (typeof __require2 !== "undefined") {
            crypto3 = __require2("crypto");
            if (crypto3 && crypto3.randomBytes) {
              nacl.setPRNG(function(x, n) {
                var i, v = crypto3.randomBytes(n);
                for (i = 0;i < n; i++)
                  x[i] = v[i];
                cleanup(v);
              });
            }
          }
        })();
      })(typeof module !== "undefined" && module.exports ? module.exports : self.nacl = self.nacl || {});
    }
  });
  naclFastW5BJ3KZ2 = require_nacl_fast();
});

// ../packages/sdk-typescript/dist/chunk-BQDGRTVP.js
function createAuthorizationMessage(message) {
  const components = [];
  components.push(Buffer.from(DOMAIN_SEPARATOR, "utf8"));
  const agentBytes = esm_default2.decode(message.agentAddress);
  components.push(Buffer.from(agentBytes));
  const sourceBytes = esm_default2.decode(message.authorizedSource);
  components.push(Buffer.from(sourceBytes));
  const indexLimitBuffer = Buffer.allocUnsafe(8);
  indexLimitBuffer.writeBigUInt64BE(BigInt(message.indexLimit));
  components.push(indexLimitBuffer);
  const expiresAtBuffer = Buffer.allocUnsafe(8);
  expiresAtBuffer.writeBigUInt64BE(BigInt(message.expiresAt));
  components.push(expiresAtBuffer);
  components.push(Buffer.from(message.network, "utf8"));
  if (message.nonce) {
    components.push(Buffer.from(message.nonce, "utf8"));
  }
  return Buffer.concat(components);
}
async function signAuthorizationMessage(message, agentKeypair) {
  const keypairAddress = agentKeypair.publicKey.toBase58();
  if (keypairAddress !== message.agentAddress) {
    throw new Error(`Keypair public key ${keypairAddress} does not match agent address ${message.agentAddress}`);
  }
  const messageBuffer = createAuthorizationMessage(message);
  const nacl = await Promise.resolve().then(() => (init_nacl_fast_W5BJ3KZ2(), exports_nacl_fast_W5BJ3KZ2));
  const signature2 = nacl.sign.detached(messageBuffer, agentKeypair.secretKey);
  return signature2;
}
async function verifyAuthorizationSignature(authorization2) {
  try {
    const message = {
      agentAddress: authorization2.agentAddress,
      authorizedSource: authorization2.authorizedSource,
      indexLimit: authorization2.indexLimit,
      expiresAt: authorization2.expiresAt,
      network: authorization2.network,
      nonce: authorization2.nonce
    };
    const messageBuffer = createAuthorizationMessage(message);
    const nacl = await Promise.resolve().then(() => (init_nacl_fast_W5BJ3KZ2(), exports_nacl_fast_W5BJ3KZ2));
    const agentPubkeyBytes = esm_default2.decode(authorization2.agentAddress);
    const isValid = nacl.sign.detached.verify(messageBuffer, authorization2.signature, agentPubkeyBytes);
    return isValid;
  } catch (error) {
    console.error("[Auth Signature] Verification failed:", error);
    return false;
  }
}
async function createSignedAuthorization(params, agentKeypair) {
  const agentAddress = address(agentKeypair.publicKey.toBase58());
  const now = Math.floor(Date.now() / 1000);
  const expiresAt = params.expiresAt || now + (params.expiresIn || 2592000);
  const indexLimit = params.indexLimit || 1000;
  const network = params.network || "devnet";
  const nonce = params.nonce !== undefined ? params.nonce : "default";
  const message = {
    agentAddress,
    authorizedSource: params.authorizedSource,
    indexLimit,
    expiresAt,
    network,
    nonce
  };
  const signature2 = await signAuthorizationMessage(message, agentKeypair);
  const authorization2 = {
    agentAddress,
    authorizedSource: params.authorizedSource,
    indexLimit,
    expiresAt,
    network,
    signature: signature2,
    nonce,
    metadata: params.metadata
  };
  return authorization2;
}
function generateNonce() {
  if (globalThis.crypto) {
    const buffer2 = new Uint8Array(32);
    globalThis.crypto.getRandomValues(buffer2);
    return Buffer.from(buffer2).toString("hex");
  }
  const nodeCrypto = eval("require")("crypto");
  const buffer = new Uint8Array(32);
  nodeCrypto.webcrypto.getRandomValues(buffer);
  return Buffer.from(buffer).toString("hex");
}
function serializeAuthorization(authorization2) {
  return {
    agentAddress: authorization2.agentAddress,
    authorizedSource: authorization2.authorizedSource,
    indexLimit: authorization2.indexLimit,
    expiresAt: authorization2.expiresAt,
    network: authorization2.network,
    signature: esm_default2.encode(authorization2.signature),
    nonce: authorization2.nonce,
    metadata: authorization2.metadata
  };
}
function deserializeAuthorization(data2) {
  return {
    agentAddress: data2.agentAddress,
    authorizedSource: data2.authorizedSource,
    indexLimit: data2.indexLimit,
    expiresAt: data2.expiresAt,
    network: data2.network,
    signature: esm_default2.decode(data2.signature),
    nonce: data2.nonce,
    metadata: data2.metadata
  };
}
async function getAuthorizationId(authorization) {
  const serialized = serializeAuthorization(authorization);
  const json = JSON.stringify(serialized);
  const encoder = new TextEncoder;
  const data = encoder.encode(json);
  let crypto;
  if (globalThis.crypto) {
    crypto = globalThis.crypto;
  } else {
    const nodeCrypto = eval("require")("crypto");
    crypto = nodeCrypto.webcrypto;
  }
  const hashBuffer = await crypto.subtle.digest("SHA-256", data);
  const hashArray = new Uint8Array(hashBuffer);
  return esm_default2.encode(hashArray);
}
function isAuthorizationExpired(authorization2, currentTime) {
  const now = currentTime || Math.floor(Date.now() / 1000);
  return now >= authorization2.expiresAt;
}
function isAuthorizationExhausted(authorization2, currentIndex) {
  return currentIndex >= authorization2.indexLimit;
}
function validateAuthorizationNetwork(authorization2, expectedNetwork) {
  return authorization2.network === expectedNetwork;
}
var signature_verification_exports, DOMAIN_SEPARATOR = "GhostSpeak Reputation Authorization";
var init_chunk_BQDGRTVP = __esm(() => {
  init_chunk_UP2VWCW5();
  init_index_node5();
  init_esm3();
  signature_verification_exports = {};
  __export2(signature_verification_exports, {
    createAuthorizationMessage: () => createAuthorizationMessage,
    createSignedAuthorization: () => createSignedAuthorization,
    deserializeAuthorization: () => deserializeAuthorization,
    generateNonce: () => generateNonce,
    getAuthorizationId: () => getAuthorizationId,
    isAuthorizationExhausted: () => isAuthorizationExhausted,
    isAuthorizationExpired: () => isAuthorizationExpired,
    serializeAuthorization: () => serializeAuthorization,
    signAuthorizationMessage: () => signAuthorizationMessage,
    validateAuthorizationNetwork: () => validateAuthorizationNetwork,
    verifyAuthorizationSignature: () => verifyAuthorizationSignature
  });
});

// ../packages/sdk-typescript/dist/chunk-RIZZPLLB.js
var CROSSMINT_STAGING_URL = "https://staging.crossmint.com", CROSSMINT_PROD_URL = "https://www.crossmint.com", GHOSTSPEAK_CREDENTIAL_TYPES, CrossmintVCClient = class {
  apiKey;
  baseUrl;
  chain;
  constructor(options2) {
    this.apiKey = options2.apiKey;
    this.baseUrl = options2.environment === "production" ? CROSSMINT_PROD_URL : CROSSMINT_STAGING_URL;
    this.chain = options2.chain || "base-sepolia";
  }
  async createAgentIdentityType() {
    const typeName = GHOSTSPEAK_CREDENTIAL_TYPES.AGENT_IDENTITY;
    const schema = {
      $schema: "https://json-schema.org/draft/2020-12/schema",
      title: "GhostSpeak Agent Identity",
      description: "Verified AI agent identity on the GhostSpeak Protocol",
      type: "object",
      properties: {
        credentialSubject: {
          type: "object",
          properties: {
            agentId: { type: "string" },
            owner: { type: "string" },
            capabilities: { type: "array", items: { type: "string" } },
            registeredAt: { type: "string" },
            reputationScore: { type: "number" },
            totalJobsCompleted: { type: "integer" },
            verified: { type: "boolean" },
            id: { type: "string" }
          },
          required: ["agentId", "owner", "capabilities", "registeredAt", "verified"],
          additionalProperties: false
        }
      }
    };
    return this.createCredentialType(typeName, schema);
  }
  async createReputationType() {
    const typeName = GHOSTSPEAK_CREDENTIAL_TYPES.REPUTATION_SCORE;
    const schema = {
      $schema: "https://json-schema.org/draft/2020-12/schema",
      title: "GhostSpeak Reputation",
      description: "Verified reputation score for GhostSpeak users",
      type: "object",
      properties: {
        credentialSubject: {
          type: "object",
          properties: {
            userId: { type: "string" },
            walletAddress: { type: "string" },
            reputationScore: { type: "number" },
            totalTransactions: { type: "integer" },
            disputeRate: { type: "number" },
            memberSince: { type: "string" },
            id: { type: "string" }
          },
          required: ["userId", "walletAddress", "reputationScore", "memberSince"],
          additionalProperties: false
        }
      }
    };
    return this.createCredentialType(typeName, schema);
  }
  async createJobCompletionType() {
    const typeName = GHOSTSPEAK_CREDENTIAL_TYPES.JOB_COMPLETION;
    const schema = {
      $schema: "https://json-schema.org/draft/2020-12/schema",
      title: "GhostSpeak Job Completion",
      description: "Certificate of successful job completion on GhostSpeak",
      type: "object",
      properties: {
        credentialSubject: {
          type: "object",
          properties: {
            jobId: { type: "string" },
            agentId: { type: "string" },
            clientAddress: { type: "string" },
            completedAt: { type: "string" },
            amountPaid: { type: "string" },
            rating: { type: "integer" },
            review: { type: "string" },
            id: { type: "string" }
          },
          required: ["jobId", "agentId", "clientAddress", "completedAt", "amountPaid", "rating"],
          additionalProperties: false
        }
      }
    };
    return this.createCredentialType(typeName, schema);
  }
  async initializeAllTypes() {
    const [agentIdentity, reputation, jobCompletion] = await Promise.all([
      this.createAgentIdentityType(),
      this.createReputationType(),
      this.createJobCompletionType()
    ]);
    return { agentIdentity, reputation, jobCompletion };
  }
  async createAllTemplates(types) {
    const [agentIdentityTemplate, reputationTemplate, jobCompletionTemplate] = await Promise.all([
      this.createTemplate(types.agentIdentity.id, {
        name: "GhostSpeak Agent Identity",
        description: "Verified AI agent identity on the GhostSpeak Protocol",
        imageUrl: "https://www.ghostspeak.io/assets/credential-agent.png"
      }),
      this.createTemplate(types.reputation.id, {
        name: "GhostSpeak Reputation",
        description: "Verified reputation score for GhostSpeak users",
        imageUrl: "https://www.ghostspeak.io/assets/credential-reputation.png"
      }),
      this.createTemplate(types.jobCompletion.id, {
        name: "GhostSpeak Job Completion Certificate",
        description: "Certificate of successful job completion on GhostSpeak",
        imageUrl: "https://www.ghostspeak.io/assets/credential-job.png"
      })
    ]);
    return { agentIdentityTemplate, reputationTemplate, jobCompletionTemplate };
  }
  async issueAgentCredential(templateId, recipientEmail, subject, expiresAt) {
    return this.issueCredential(templateId, recipientEmail, subject, expiresAt);
  }
  async issueReputationCredential(templateId, recipientEmail, subject, expiresAt) {
    return this.issueCredential(templateId, recipientEmail, subject, expiresAt);
  }
  async issueJobCompletionCredential(templateId, recipientEmail, subject, expiresAt) {
    return this.issueCredential(templateId, recipientEmail, subject, expiresAt);
  }
  async createCredentialType(typeName, schema) {
    const response = await fetch(`${this.baseUrl}/api/v1-alpha1/credentials/types/${typeName}`, {
      method: "PUT",
      headers: {
        "Content-Type": "application/json",
        "X-API-KEY": this.apiKey
      },
      body: JSON.stringify(schema)
    });
    if (!response.ok) {
      const error = await response.json().catch(() => ({ message: response.statusText }));
      throw new Error(`Failed to create credential type: ${JSON.stringify(error)}`);
    }
    return response.json();
  }
  async createTemplate(typeId, metadata) {
    const response = await fetch(`${this.baseUrl}/api/v1-alpha1/credentials/templates/`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "X-API-KEY": this.apiKey
      },
      body: JSON.stringify({
        credentials: {
          type: typeId,
          encryption: "none",
          storage: "crossmint"
        },
        metadata,
        chain: this.chain
      })
    });
    if (!response.ok) {
      const text = await response.text();
      try {
        const error = JSON.parse(text);
        throw new Error(`Failed to create template: ${JSON.stringify(error)}`);
      } catch (e7) {
        throw new Error(`Failed to create template (${response.status}): ${text}`);
      }
    }
    const action = await response.json();
    const result = await this.waitForAction(action.id);
    if (result.data && result.data.collection) {
      return result.data.collection;
    }
    return result.data || result;
  }
  async waitForAction(actionId) {
    let retries = 0;
    while (retries < 60) {
      await new Promise((resolve) => setTimeout(resolve, 2000));
      const response = await fetch(`${this.baseUrl}/api/2022-06-09/actions/${actionId}`, {
        headers: {
          "X-API-KEY": this.apiKey
        }
      });
      if (!response.ok) {
        throw new Error(`Failed to poll action: ${response.statusText}`);
      }
      const action = await response.json();
      if (action.status === "succeeded") {
        return action;
      }
      if (action.status === "failed") {
        throw new Error(`Action failed: ${JSON.stringify(action)}`);
      }
      retries++;
    }
    throw new Error("Action polling timed out");
  }
  async issueCredential(templateId, recipientEmail, subject, expiresAt) {
    const response = await fetch(`${this.baseUrl}/api/v1-alpha1/credentials/templates/${templateId}/vcs`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "X-API-KEY": this.apiKey
      },
      body: JSON.stringify({
        recipient: `email:${recipientEmail}:${this.chain}`,
        credential: {
          subject,
          expiresAt: expiresAt || this.getDefaultExpiry()
        }
      })
    });
    if (!response.ok) {
      const error = await response.json().catch(() => ({ message: response.statusText }));
      throw new Error(`Failed to issue credential: ${JSON.stringify(error)}`);
    }
    return response.json();
  }
  async getCredential(credentialId) {
    const response = await fetch(`${this.baseUrl}/api/v1-alpha1/credentials/${credentialId}`, {
      headers: {
        "X-API-KEY": this.apiKey
      }
    });
    if (!response.ok) {
      const error = await response.json().catch(() => ({ message: response.statusText }));
      throw new Error(`Failed to get credential: ${JSON.stringify(error)}`);
    }
    return response.json();
  }
  async verifyCredential(credential) {
    const response = await fetch(`${this.baseUrl}/api/v1-alpha1/credentials/verification/verify`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "X-API-KEY": this.apiKey
      },
      body: JSON.stringify({ credential })
    });
    if (!response.ok) {
      const error = await response.json().catch(() => ({ message: response.statusText }));
      throw new Error(`Failed to verify credential: ${JSON.stringify(error)}`);
    }
    return response.json();
  }
  async revokeCredential(credentialId) {
    const response = await fetch(`${this.baseUrl}/api/v1-alpha1/credentials/${credentialId}`, {
      method: "DELETE",
      headers: {
        "X-API-KEY": this.apiKey
      }
    });
    if (!response.ok) {
      const error = await response.json().catch(() => ({ message: response.statusText }));
      throw new Error(`Failed to revoke credential: ${JSON.stringify(error)}`);
    }
    return response.json();
  }
  getDefaultExpiry() {
    const date = /* @__PURE__ */ new Date;
    date.setFullYear(date.getFullYear() + 1);
    return date.toISOString().split("T")[0];
  }
};
var init_chunk_RIZZPLLB = __esm(() => {
  GHOSTSPEAK_CREDENTIAL_TYPES = {
    AGENT_IDENTITY: "GhostSpeakAgentIdentity",
    REPUTATION_SCORE: "GhostSpeakReputation",
    JOB_COMPLETION: "GhostSpeakJobCompletion"
  };
});

// ../packages/sdk-typescript/dist/createAgentAuthorization-ULG47ZJI.js
var exports_createAgentAuthorization_ULG47ZJI = {};
__export(exports_createAgentAuthorization_ULG47ZJI, {
  parseCreateAgentAuthorizationInstruction: () => parseCreateAgentAuthorizationInstruction,
  getCreateAgentAuthorizationInstructionDataEncoder: () => getCreateAgentAuthorizationInstructionDataEncoder,
  getCreateAgentAuthorizationInstructionDataDecoder: () => getCreateAgentAuthorizationInstructionDataDecoder,
  getCreateAgentAuthorizationInstructionDataCodec: () => getCreateAgentAuthorizationInstructionDataCodec,
  getCreateAgentAuthorizationInstructionAsync: () => getCreateAgentAuthorizationInstructionAsync,
  getCreateAgentAuthorizationInstruction: () => getCreateAgentAuthorizationInstruction,
  getCreateAgentAuthorizationDiscriminatorBytes: () => getCreateAgentAuthorizationDiscriminatorBytes,
  CREATE_AGENT_AUTHORIZATION_DISCRIMINATOR: () => CREATE_AGENT_AUTHORIZATION_DISCRIMINATOR
});
var init_createAgentAuthorization_ULG47ZJI = __esm(() => {
  init_chunk_SFTSZ3LC();
  init_chunk_AL3HQN73();
  init_chunk_UP2VWCW5();
});

// ../packages/sdk-typescript/dist/updateReputationWithAuth-Y4ONEVSP.js
var exports_updateReputationWithAuth_Y4ONEVSP = {};
__export(exports_updateReputationWithAuth_Y4ONEVSP, {
  parseUpdateReputationWithAuthInstruction: () => parseUpdateReputationWithAuthInstruction,
  getUpdateReputationWithAuthInstructionDataEncoder: () => getUpdateReputationWithAuthInstructionDataEncoder,
  getUpdateReputationWithAuthInstructionDataDecoder: () => getUpdateReputationWithAuthInstructionDataDecoder,
  getUpdateReputationWithAuthInstructionDataCodec: () => getUpdateReputationWithAuthInstructionDataCodec,
  getUpdateReputationWithAuthInstructionAsync: () => getUpdateReputationWithAuthInstructionAsync,
  getUpdateReputationWithAuthInstruction: () => getUpdateReputationWithAuthInstruction,
  getUpdateReputationWithAuthDiscriminatorBytes: () => getUpdateReputationWithAuthDiscriminatorBytes,
  UPDATE_REPUTATION_WITH_AUTH_DISCRIMINATOR: () => UPDATE_REPUTATION_WITH_AUTH_DISCRIMINATOR
});
var init_updateReputationWithAuth_Y4ONEVSP = __esm(() => {
  init_chunk_KB6CKIUK();
  init_chunk_AL3HQN73();
  init_chunk_UP2VWCW5();
});

// ../packages/sdk-typescript/dist/revokeAuthorization-OK7E7OK3.js
var exports_revokeAuthorization_OK7E7OK3 = {};
__export(exports_revokeAuthorization_OK7E7OK3, {
  parseRevokeAuthorizationInstruction: () => parseRevokeAuthorizationInstruction,
  getRevokeAuthorizationInstructionDataEncoder: () => getRevokeAuthorizationInstructionDataEncoder,
  getRevokeAuthorizationInstructionDataDecoder: () => getRevokeAuthorizationInstructionDataDecoder,
  getRevokeAuthorizationInstructionDataCodec: () => getRevokeAuthorizationInstructionDataCodec,
  getRevokeAuthorizationInstruction: () => getRevokeAuthorizationInstruction,
  getRevokeAuthorizationDiscriminatorBytes: () => getRevokeAuthorizationDiscriminatorBytes,
  REVOKE_AUTHORIZATION_DISCRIMINATOR: () => REVOKE_AUTHORIZATION_DISCRIMINATOR
});
var init_revokeAuthorization_OK7E7OK3 = __esm(() => {
  init_chunk_JV2SWONF();
  init_chunk_AL3HQN73();
  init_chunk_UP2VWCW5();
});

// ../packages/sdk-typescript/dist/chunk-E3FD2CNY.js
function calculateVisibleScore(score, privacyMode, hasAccess) {
  if (hasAccess || privacyMode === "Public") {
    return {
      exactScore: score,
      tier: getReputationTier(score),
      scoreRange: getScoreRange(score)
    };
  }
  switch (privacyMode) {
    case "TierOnly":
      return {
        tier: getReputationTier(score)
      };
    case "RangeOnly":
      return {
        scoreRange: getScoreRange(score)
      };
    case "Confidential":
      return {};
    case "Custom":
      return {
        tier: getReputationTier(score),
        scoreRange: getScoreRange(score)
      };
    default:
      return {};
  }
}
function getReputationTier(score) {
  if (score >= PRIVACY_CONSTANTS.TIER_THRESHOLDS.PLATINUM) {
    return "Platinum";
  } else if (score >= PRIVACY_CONSTANTS.TIER_THRESHOLDS.GOLD) {
    return "Gold";
  } else if (score >= PRIVACY_CONSTANTS.TIER_THRESHOLDS.SILVER) {
    return "Silver";
  } else if (score >= PRIVACY_CONSTANTS.TIER_THRESHOLDS.BRONZE) {
    return "Bronze";
  }
  return "None";
}
function getScoreRange(score) {
  const ranges = PRIVACY_CONSTANTS.SCORE_RANGES;
  if (score >= ranges.VERY_HIGH.min) {
    return "VeryHigh";
  } else if (score >= ranges.HIGH.min) {
    return "High";
  } else if (score >= ranges.MEDIUM.min) {
    return "Medium";
  } else if (score >= ranges.LOW.min) {
    return "Low";
  }
  return "VeryLow";
}
function canViewerAccess(viewerAddress, settings, agentAddress) {
  if (viewerAddress === agentAddress) {
    return true;
  }
  return settings.authorizedViewers.includes(viewerAddress);
}
function filterMetricsByVisibility(reputationData, metricVisibility, hasAccess) {
  const result = {
    agent: reputationData.agent
  };
  const isVisible = (level) => {
    return hasAccess || level === "Public";
  };
  if (isVisible(metricVisibility.showScore)) {
    result.exactScore = reputationData.overallScore;
  }
  if (isVisible(metricVisibility.showJobsCompleted)) {
    result.totalJobsCompleted = reputationData.totalJobsCompleted;
  }
  if (isVisible(metricVisibility.showSuccessRate)) {
    const total = reputationData.totalJobsCompleted + reputationData.totalJobsFailed;
    result.successRate = total > 0 ? reputationData.totalJobsCompleted / total * 100 : 0;
  }
  if (isVisible(metricVisibility.showResponseTime)) {
    result.avgResponseTime = reputationData.avgResponseTime;
  }
  if (isVisible(metricVisibility.showDisputes)) {
    result.disputes = {
      total: reputationData.disputesAgainst,
      resolved: reputationData.disputesResolved
    };
  }
  if (isVisible(metricVisibility.showEarnings) && reputationData.totalEarnings !== undefined) {
    result.totalEarnings = reputationData.totalEarnings;
  }
  if (isVisible(metricVisibility.showRatings) && reputationData.avgRating !== undefined) {
    result.avgRating = reputationData.avgRating;
  }
  if (isVisible(metricVisibility.showBadges) && reputationData.badges !== undefined) {
    result.badges = reputationData.badges;
  }
  result.hasFullAccess = hasAccess;
  return result;
}
function getDefaultMetricVisibility(mode) {
  switch (mode) {
    case "Public":
      return {
        showScore: "Public",
        showJobsCompleted: "Public",
        showSuccessRate: "Public",
        showResponseTime: "Public",
        showDisputes: "Public",
        showEarnings: "Public",
        showRatings: "Public",
        showBadges: "Public"
      };
    case "TierOnly":
    case "RangeOnly":
      return {
        showScore: "Private",
        showJobsCompleted: "Private",
        showSuccessRate: "Private",
        showResponseTime: "Private",
        showDisputes: "Private",
        showEarnings: "Private",
        showRatings: "Private",
        showBadges: "Public"
      };
    case "Confidential":
      return {
        showScore: "ZKProof",
        showJobsCompleted: "ZKProof",
        showSuccessRate: "ZKProof",
        showResponseTime: "ZKProof",
        showDisputes: "ZKProof",
        showEarnings: "ZKProof",
        showRatings: "ZKProof",
        showBadges: "ZKProof"
      };
    case "Custom":
    default:
      return {
        showScore: "Private",
        showJobsCompleted: "Public",
        showSuccessRate: "Public",
        showResponseTime: "Public",
        showDisputes: "Private",
        showEarnings: "Private",
        showRatings: "Public",
        showBadges: "Public"
      };
  }
}
function validatePrivacySettings(settings) {
  const errors2 = [];
  if (settings.authorizedViewers.length > PRIVACY_CONSTANTS.MAX_AUTHORIZED_VIEWERS) {
    errors2.push(`Too many authorized viewers (max: ${PRIVACY_CONSTANTS.MAX_AUTHORIZED_VIEWERS})`);
  }
  if (settings.mode === "Public") {
    const hasPrivateMetric = Object.values(settings.metricVisibility).some((level) => level !== "Public");
    if (hasPrivateMetric) {
      errors2.push("Public mode cannot have private metrics");
    }
  }
  return {
    valid: errors2.length === 0,
    errors: errors2
  };
}
function getTierDisplayName(tier) {
  const names = {
    ["None"]: "Unranked",
    ["Bronze"]: "Bronze",
    ["Silver"]: "Silver",
    ["Gold"]: "Gold",
    ["Platinum"]: "Platinum"
  };
  return names[tier];
}
function getRangeDisplayString(range) {
  const ranges = {
    ["VeryLow"]: "0-2000",
    ["Low"]: "2000-5000",
    ["Medium"]: "5000-7500",
    ["High"]: "7500-9000",
    ["VeryHigh"]: "9000-10000"
  };
  return ranges[range];
}
function sol(amount) {
  return BigInt(Math.floor(amount * 1e9));
}
function lamportsToSol(lamports2) {
  return Number(lamports2) / 1e9;
}
var UnifiedCredentialService = class {
  constructor(config) {
    this.config = config;
    this.credentialModule = new CredentialModule(config.programId);
    if (config.crossmint) {
      this.crossmintClient = new CrossmintVCClient(config.crossmint);
    }
  }
  credentialModule;
  crossmintClient;
  async issueAgentIdentityCredential(params) {
    const subjectData = CredentialModule.buildAgentIdentitySubject({
      agentId: params.agentId,
      owner: params.owner,
      name: params.name,
      capabilities: params.capabilities,
      serviceEndpoint: params.serviceEndpoint,
      frameworkOrigin: params.frameworkOrigin,
      x402Enabled: params.x402Enabled,
      registeredAt: params.registeredAt,
      verifiedAt: params.verifiedAt
    });
    const credentialId = this.credentialModule.generateCredentialId("AgentIdentity", params.owner);
    const subjectDataHash = this.credentialModule.hashSubjectData(subjectData);
    const credential = {
      template: "11111111111111111111111111111111",
      subject: params.owner,
      issuer: params.owner,
      credentialId,
      subjectDataHash,
      subjectDataUri: `ipfs://placeholder/${credentialId}`,
      status: "Active",
      signature: params.signature,
      issuedAt: Math.floor(Date.now() / 1000),
      expiresAt: undefined,
      revokedAt: undefined,
      crossmintCredentialId: undefined
    };
    const mockType = {
      authority: "11111111111111111111111111111111",
      name: "AgentIdentity",
      kind: "AgentIdentity",
      schemaUri: "https://ghostspeak.io/schemas/agent-identity.json",
      description: "Verified AI agent identity on GhostSpeak Protocol",
      isActive: true,
      totalIssued: 1,
      createdAt: Math.floor(Date.now() / 1000)
    };
    const mockTemplate = {
      credentialType: "11111111111111111111111111111111",
      name: "GhostSpeak Agent Identity",
      imageUri: "https://www.ghostspeak.io/assets/credential-agent.png",
      issuer: params.owner,
      isActive: true,
      totalIssued: 1,
      createdAt: Math.floor(Date.now() / 1000),
      crossmintTemplateId: this.config.crossmintTemplates?.agentIdentity
    };
    const w3cCredential = this.credentialModule.exportAsW3CCredential(credential, mockTemplate, mockType, subjectData);
    const result = {
      solanaCredential: {
        credentialId
      },
      w3cCredential
    };
    if (params.syncToCrossmint && this.crossmintClient && params.recipientEmail) {
      if (!mockTemplate.crossmintTemplateId) {
        result.crossmintSync = { status: "failed", error: "No template ID configured" };
      } else {
        try {
          const crossmintResult = await this.crossmintClient.issueCredential(mockTemplate.crossmintTemplateId, params.recipientEmail, subjectData);
          result.crossmintSync = {
            status: "synced",
            credentialId: crossmintResult.credentialId,
            chain: this.config.crossmint?.chain
          };
        } catch (error) {
          result.crossmintSync = {
            status: "failed",
            error: error instanceof Error ? error.message : "Unknown error"
          };
        }
      }
    }
    return result;
  }
}, DidModule, PrivacyModule, DEFAULT_STORAGE_FEE = 2000000n, AuthorizationModule, GhostSpeakClient = class {
  config;
  constructor(config) {
    this.config = {
      programId: GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS,
      commitment: "confirmed",
      cluster: "devnet",
      rpcEndpoint: config?.rpcEndpoint ?? this.getDefaultRpcEndpoint(config?.cluster ?? "devnet"),
      ...config,
      rpc: config?.rpc ?? {}
    };
  }
  get agents() {
    return new AgentModule(this.config);
  }
  get governanceModule() {
    return new GovernanceModule(this.config);
  }
  get multisigModule() {
    return new MultisigModule(this.config);
  }
  agent() {
    return new AgentBuilder(this.config);
  }
  payai() {
    return new PayAIClient({
      rpcUrl: this.config.rpcEndpoint,
      facilitatorUrl: this.config.payai?.facilitatorUrl,
      timeout: this.config.transactionTimeout,
      retry: this.config.retryConfig && {
        attempts: this.config.retryConfig.maxRetries ?? 3,
        delayMs: this.config.retryConfig.baseDelay ?? 1000
      }
    });
  }
  reputation() {
    return new ReputationModule(this.config);
  }
  tagEngine() {
    const { ReputationTagEngine: ReputationTagEngine2 } = (init_reputation_tag_engine(), __toCommonJS(reputation_tag_engine_exports));
    return new ReputationTagEngine2;
  }
  reputationAggregator() {
    const { MultiSourceAggregator: MultiSourceAggregator2 } = (init_MultiSourceAggregator(), __toCommonJS(MultiSourceAggregator_exports));
    return new MultiSourceAggregator2;
  }
  privacy() {
    return new PrivacyModule(this.config);
  }
  governance() {
    return new GovernanceBuilder(this.config);
  }
  multisig() {
    return new MultisigBuilder(this.config);
  }
  credentials() {
    return new UnifiedCredentialService({
      programId: this.config.programId,
      crossmint: this.config.credentials?.crossmintApiKey ? {
        apiKey: this.config.credentials.crossmintApiKey,
        environment: this.config.credentials.crossmintEnvironment,
        chain: this.config.credentials.crossmintChain
      } : undefined,
      crossmintTemplates: this.config.credentials?.templates
    });
  }
  did() {
    return new DidModule(this.config);
  }
  get authorization() {
    return new AuthorizationModule(this.config);
  }
  get staking() {
    return new StakingModule(this.config);
  }
  enableDevMode() {
    console.log("\uD83D\uDEE0 Development mode enabled");
    console.log("   - Transaction simulation before sending");
    console.log("   - Cost estimates for all operations");
    console.log("   - Enhanced error messages");
    this.config = {
      ...this.config
    };
    return this;
  }
  useNetwork(cluster) {
    this.config.cluster = cluster;
    this.config.rpcEndpoint = this.getDefaultRpcEndpoint(cluster);
    return this;
  }
  useRpc(endpoint, wsEndpoint) {
    this.config.rpcEndpoint = endpoint;
    this.config.wsEndpoint = wsEndpoint;
    return this;
  }
  getDefaultRpcEndpoint(cluster) {
    switch (cluster) {
      case "mainnet-beta":
        return "https://api.mainnet-beta.solana.com";
      case "devnet":
        return "https://api.devnet.solana.com";
      case "testnet":
        return "https://api.testnet.solana.com";
      case "localnet":
        return "http://localhost:8899";
      default:
        return "https://api.devnet.solana.com";
    }
  }
}, AgentBuilder = class {
  module;
  params = {};
  constructor(config) {
    this.module = new AgentModule(config);
  }
  create(params) {
    this.params = {
      ...this.params,
      agentType: 0,
      metadataUri: JSON.stringify(params),
      agentId: params.name.toLowerCase().replace(/\s+/g, "-"),
      name: params.name,
      description: params.description || ""
    };
    return this;
  }
  withDescription(description) {
    this.params.description = description;
    return this;
  }
  withType(agentType) {
    this.params.agentType = agentType;
    return this;
  }
  withIPFS() {
    this.params.forceIPFS = true;
    return this;
  }
  compressed() {
    this.params.compressed = true;
    return this;
  }
  debug() {
    this.module.debug();
    return this;
  }
  withSigner(signer) {
    this.params.signer = signer;
    return this;
  }
  validateParams() {
    if (!this.params.signer) {
      throw new Error("Agent builder requires a signer. Call with signer first.");
    }
    if (!this.params.metadataUri) {
      throw new Error("Agent builder requires metadata. Call create() first.");
    }
    if (!this.params.agentId) {
      throw new Error("Agent builder requires agent ID. Call create() first.");
    }
    this.params.agentType ??= 0;
  }
  async getCost() {
    this.validateParams();
    return this.module.getCost("registerAgent", () => ({
      programAddress: this.module.getProgramId(),
      accounts: [],
      data: new Uint8Array
    }));
  }
  async simulate() {
    const instruction = () => ({
      programAddress: this.module.getProgramId(),
      accounts: [],
      data: new Uint8Array
    });
    this.validateParams();
    return this.module.simulateInstruction("registerAgent", instruction, [this.params.signer]);
  }
  async explain() {
    this.validateParams();
    return this.module.explain("registerAgent", () => ({
      programAddress: this.module.getProgramId(),
      accounts: [],
      data: new Uint8Array
    }));
  }
  async execute() {
    this.validateParams();
    if (this.params.compressed) {
      console.log("Creating compressed agent (5000x cheaper)...");
    }
    const signature2 = await this.module.register(this.params.signer, {
      agentType: this.params.agentType,
      name: this.params.name,
      description: this.params.description,
      metadataUri: this.params.metadataUri,
      agentId: this.params.agentId
    });
    const address2 = await this.deriveAgentAddress(this.params.agentId, this.params.signer);
    return { address: address2, signature: signature2 };
  }
  async deriveAgentAddress(agentId, signer) {
    const { deriveAgentPda: deriveAgentPda2 } = await Promise.resolve().then(() => (init_pda_4KP7CURF(), exports_pda_4KP7CURF));
    const [address2] = await deriveAgentPda2({
      programAddress: this.module.getProgramId(),
      owner: signer.address,
      agentId
    });
    return address2;
  }
}, GovernanceBuilder = class {
  module;
  params = {};
  constructor(config) {
    this.module = new GovernanceModule(config);
  }
  proposal() {
    return new ProposalBuilder(this.module, this.params);
  }
  query() {
    return new GovernanceQuery(this.module);
  }
  debug() {
    this.module.debug();
    return this;
  }
  withSigner(signer) {
    this.params.signer = signer;
    return this;
  }
}, ProposalBuilder = class {
  constructor(module, builderParams) {
    this.module = module;
    this.builderParams = builderParams;
    this.params.signer = builderParams.signer;
  }
  params = {};
  create(params) {
    this.params.title = params.title;
    this.params.description = params.description;
    return this;
  }
  type(proposalType) {
    this.params.proposalType = proposalType;
    return this;
  }
  votingDuration(hours) {
    this.params.votingDuration = hours;
    return this;
  }
  executionDelay(hours) {
    this.params.executionDelay = hours;
    return this;
  }
  validateParams() {
    if (!this.params.signer)
      throw new Error("Signer required");
    if (!this.params.title)
      throw new Error("Title required");
    if (!this.params.description)
      throw new Error("Description required");
    if (!this.params.proposalType)
      throw new Error("Proposal type required");
    if (!this.params.votingDuration)
      throw new Error("Voting duration required");
  }
  async execute() {
    this.validateParams();
    const signature2 = await this.module.createProposal({
      signer: this.params.signer,
      title: this.params.title,
      description: this.params.description,
      proposalType: this.params.proposalType,
      votingDuration: this.params.votingDuration,
      executionDelay: this.params.executionDelay
    });
    const address2 = `proposal_${this.params.signer.address}_${this.params.title}`;
    return { address: address2, signature: signature2 };
  }
  withSigner(signer) {
    this.params.signer = signer;
    return this;
  }
}, GovernanceQuery = class {
  constructor(module) {
    this.module = module;
  }
  async activeProposals() {
    return this.module.getActiveProposals();
  }
  async proposalsByProposer(proposer) {
    return this.module.getProposalsByProposer(proposer);
  }
  async proposalsByStatus(status) {
    return this.module.getProposalsByStatus(status);
  }
}, MultisigBuilder = class {
  module;
  params = {};
  constructor(config) {
    this.module = new MultisigModule(config);
  }
  create() {
    return new CreateMultisigBuilder(this.module, this.params);
  }
  proposal() {
    return new MultisigProposalBuilder(this.module, this.params);
  }
  approve() {
    return new MultisigApproveBuilder(this.module, this.params);
  }
  executeProposal() {
    return new MultisigExecuteBuilder(this.module, this.params);
  }
  withSigner(signer) {
    this.params.signer = signer;
    return this;
  }
  debug() {
    this.module.debug();
    return this;
  }
}, CreateMultisigBuilder = class {
  constructor(module, builderParams) {
    this.module = module;
    this.builderParams = builderParams;
    this.params.signer = builderParams.signer;
  }
  params = {};
  withId(id) {
    this.params.multisigId = id;
    return this;
  }
  threshold(t) {
    this.params.threshold = t;
    return this;
  }
  signers(s3) {
    this.params.signers = s3;
    return this;
  }
  async execute() {
    if (!this.params.signer)
      throw new Error("Signer required");
    if (!this.params.multisigId)
      throw new Error("Multisig ID required");
    if (!this.params.threshold)
      throw new Error("Threshold required");
    if (!this.params.signers)
      throw new Error("Signers required");
    return {
      signature: await this.module.createMultisig({
        owner: this.params.signer,
        multisigId: this.params.multisigId,
        threshold: this.params.threshold,
        signers: this.params.signers
      })
    };
  }
  withSigner(signer) {
    this.params.signer = signer;
    return this;
  }
}, MultisigProposalBuilder = class {
  constructor(module, builderParams) {
    this.module = module;
    this.builderParams = builderParams;
    this.params.signer = builderParams.signer;
  }
  params = {};
  forMultisig(address2) {
    this.params.multisigAddress = address2;
    return this;
  }
  title(t) {
    this.params.title = t;
    return this;
  }
  description(d) {
    this.params.description = d;
    return this;
  }
  async execute() {
    if (!this.params.signer)
      throw new Error("Signer required");
    if (!this.params.title)
      throw new Error("Title required");
    if (!this.params.description)
      throw new Error("Description required");
    return {
      signature: await this.module.createProposal({
        multisigAddress: this.params.multisigAddress,
        title: this.params.title,
        description: this.params.description,
        proposalType: 7,
        executionParams: {
          instructions: [],
          executionDelay: 0n,
          executionConditions: [],
          cancellable: true,
          autoExecute: true,
          executionAuthority: this.params.signer.address
        },
        proposalId: BigInt(Date.now()),
        proposer: this.params.signer
      })
    };
  }
  withSigner(signer) {
    this.params.signer = signer;
    return this;
  }
}, MultisigApproveBuilder = class {
  constructor(module, builderParams) {
    this.module = module;
    this.builderParams = builderParams;
    this.params.signer = builderParams.signer;
  }
  params = {};
  proposal(address2) {
    this.params.proposalAddress = address2;
    return this;
  }
  vote(choice) {
    this.params.voteChoice = choice;
    return this;
  }
  reason(text) {
    this.params.reasoning = text;
    return this;
  }
  tokenAccount(account) {
    this.params.tokenAccount = account;
    return this;
  }
  async execute() {
    if (!this.params.signer)
      throw new Error("Signer required");
    if (!this.params.proposalAddress)
      throw new Error("Proposal address required");
    throw new Error("Multisig approval: Use protocol_config instructions for voting (approveProposal removed)");
  }
  withSigner(signer) {
    this.params.signer = signer;
    return this;
  }
}, MultisigExecuteBuilder = class {
  constructor(module, builderParams) {
    this.module = module;
    this.builderParams = builderParams;
    this.params.signer = builderParams.signer;
  }
  params = {};
  proposal(address2) {
    this.params.proposalAddress = address2;
    return this;
  }
  target(programId) {
    this.params.targetProgram = programId;
    return this;
  }
  async execute() {
    if (!this.params.signer)
      throw new Error("Signer required");
    if (!this.params.proposalAddress)
      throw new Error("Proposal address required");
    if (!this.params.targetProgram)
      throw new Error("Target program required");
    return {
      signature: await this.module.executeProposal({
        proposalAddress: this.params.proposalAddress,
        executor: this.params.signer,
        targetProgram: this.params.targetProgram
      })
    };
  }
  withSigner(signer) {
    this.params.signer = signer;
    return this;
  }
}, GhostSpeakClient_default;
var init_chunk_E3FD2CNY = __esm(() => {
  init_chunk_SZGFSCNU();
  init_chunk_BQDGRTVP();
  init_chunk_C5CDA3WX();
  init_chunk_AL3HQN73();
  init_chunk_RIZZPLLB();
  init_chunk_UP2VWCW5();
  init_index_node5();
  DidModule = class extends BaseModule {
    constructor(config) {
      super(config);
    }
    async create(signer, params) {
      const network = params.network || "devnet";
      const didString = generateDidString(network, params.controller);
      validateDidString(didString);
      const [didDocumentPda] = await deriveDidDocumentPda(this.programId, params.controller);
      const instructionGetter = async () => {
        return this.buildCreateDidInstruction(didDocumentPda, params.controller, didString, params.verificationMethods || [], params.serviceEndpoints || []);
      };
      return this.execute("createDidDocument", instructionGetter, [signer]);
    }
    async update(signer, params) {
      const instructionGetter = async () => {
        return this.buildUpdateDidInstruction(params.didDocument, signer.address, params.addVerificationMethod || null, params.removeVerificationMethodId || null, params.addServiceEndpoint || null, params.removeServiceEndpointId || null);
      };
      return this.execute("updateDidDocument", instructionGetter, [signer]);
    }
    async deactivate(signer, params) {
      const instructionGetter = async () => {
        return this.buildDeactivateDidInstruction(params.didDocument, signer.address);
      };
      return this.execute("deactivateDidDocument", instructionGetter, [signer]);
    }
    async resolve(didOrController) {
      let controllerAddress;
      if (typeof didOrController === "string" && didOrController.startsWith("did:sol:")) {
        const { identifier } = parseDidString(didOrController);
        controllerAddress = address(identifier);
      } else {
        controllerAddress = typeof didOrController === "string" ? address(didOrController) : didOrController;
      }
      const [didDocumentPda] = await deriveDidDocumentPda(this.programId, controllerAddress);
      return this.getAccount(didDocumentPda, "getDidDocumentDecoder");
    }
    async exportW3C(didOrController, pretty = true) {
      const didDoc = await this.resolve(didOrController);
      if (!didDoc)
        return null;
      return didDocumentToJson(didDoc, pretty);
    }
    async getW3CDocument(didOrController) {
      const didDoc = await this.resolve(didOrController);
      if (!didDoc)
        return null;
      return exportAsW3CDidDocument(didDoc);
    }
    async deriveDidPda(controller) {
      return deriveDidDocumentPda(this.programId, controller);
    }
    generateDid(controller, network = "devnet") {
      return generateDidString(network, controller);
    }
    validateDid(did) {
      validateDidString(did);
      return true;
    }
    async isActive(didOrController) {
      const didDoc = await this.resolve(didOrController);
      if (!didDoc)
        return false;
      return isDidActive(didDoc);
    }
    buildCreateDidInstruction(didDocument, controller, didString, verificationMethods, serviceEndpoints) {
      throw new Error("DID instructions are not yet generated. Please run: bun run generate:client after adding DID instructions to the program.");
    }
    buildUpdateDidInstruction(didDocument, controller, addVerificationMethod, removeVerificationMethodId, addServiceEndpoint, removeServiceEndpointId) {
      throw new Error("DID instructions are not yet generated. Please run: bun run generate:client after adding DID instructions to the program.");
    }
    buildDeactivateDidInstruction(didDocument, controller) {
      throw new Error("DID instructions are not yet generated. Please run: bun run generate:client after adding DID instructions to the program.");
    }
    static createVerificationMethod = createEd25519VerificationMethod;
    static createServiceEndpoint = createServiceEndpoint;
  };
  PrivacyModule = class extends BaseModule {
    constructor(config) {
      super(config);
    }
    async initializePrivacy(signer, params) {
      const mode = params.mode ?? "Public";
      params.metricVisibility ?? getDefaultMetricVisibility(mode);
      const instructionGetter = async () => {
        return {
          programAddress: this.programId,
          accounts: [],
          data: new Uint8Array([0])
        };
      };
      return this.execute("initializePrivacy", instructionGetter, [signer]);
    }
    async updatePrivacyMode(signer, params) {
      const instructionGetter = async () => {
        return {
          programAddress: this.programId,
          accounts: [],
          data: new Uint8Array([1])
        };
      };
      return this.execute("updatePrivacyMode", instructionGetter, [signer]);
    }
    async setMetricVisibility(signer, params) {
      const instructionGetter = async () => {
        return {
          programAddress: this.programId,
          accounts: [],
          data: new Uint8Array([2])
        };
      };
      return this.execute("setMetricVisibility", instructionGetter, [signer]);
    }
    async grantAccess(signer, params) {
      const instructionGetter = async () => {
        return {
          programAddress: this.programId,
          accounts: [],
          data: new Uint8Array([3])
        };
      };
      return this.execute("grantAccess", instructionGetter, [signer]);
    }
    async revokeAccess(signer, params) {
      const instructionGetter = async () => {
        return {
          programAddress: this.programId,
          accounts: [],
          data: new Uint8Array([4])
        };
      };
      return this.execute("revokeAccess", instructionGetter, [signer]);
    }
    async applyPreset(signer, params) {
      const { preset } = params;
      await this.updatePrivacyMode(signer, {
        agentAddress: params.agentAddress,
        mode: preset.mode
      });
      return this.setMetricVisibility(signer, {
        agentAddress: params.agentAddress,
        metricVisibility: preset.metricVisibility
      });
    }
    async getPrivacySettings(agentAddress) {
      return {
        agent: agentAddress,
        mode: "Public",
        metricVisibility: getDefaultMetricVisibility("Public"),
        authorizedViewers: [],
        autoGrantClients: false,
        updatedAt: Math.floor(Date.now() / 1000)
      };
    }
    async getVisibleReputation(agentAddress, viewerAddress) {
      let privacySettings = await this.getPrivacySettings(agentAddress);
      if (!privacySettings) {
        privacySettings = {
          agent: agentAddress,
          mode: "Public",
          metricVisibility: getDefaultMetricVisibility("Public"),
          authorizedViewers: [],
          autoGrantClients: false,
          updatedAt: Math.floor(Date.now() / 1000)
        };
      }
      const hasAccess = canViewerAccess(viewerAddress, privacySettings, agentAddress);
      const reputationData = {
        agent: agentAddress,
        overallScore: 7500,
        totalJobsCompleted: 100,
        totalJobsFailed: 5,
        avgResponseTime: 250,
        disputesAgainst: 2,
        disputesResolved: 2,
        totalEarnings: 50000,
        avgRating: 4.5,
        badges: ["FirstJob", "TenJobs", "QuickResponder"]
      };
      const visibleScore = calculateVisibleScore(reputationData.overallScore, privacySettings.mode, hasAccess);
      const filteredMetrics = filterMetricsByVisibility(reputationData, privacySettings.metricVisibility, hasAccess);
      return {
        ...filteredMetrics,
        privacyMode: privacySettings.mode,
        ...visibleScore,
        hasFullAccess: hasAccess
      };
    }
    validateSettings(settings) {
      return validatePrivacySettings(settings);
    }
    getAvailablePresets() {
      return PrivacyPresets;
    }
    getDefaultVisibility(mode) {
      return getDefaultMetricVisibility(mode);
    }
    getTier(score) {
      return getReputationTier(score);
    }
    getRange(score) {
      return getScoreRange(score);
    }
    async derivePrivacyPda(agentAddress) {
      const { getProgramDerivedAddress: getProgramDerivedAddress2, getAddressEncoder: getAddressEncoder2 } = await Promise.resolve().then(() => (init_index_node5(), exports_index_node));
      const addressEncoder = getAddressEncoder2();
      const agentBytes = addressEncoder.encode(agentAddress);
      const [pda] = await getProgramDerivedAddress2({
        programAddress: this.programId,
        seeds: [
          new TextEncoder().encode("privacy_settings"),
          agentBytes
        ]
      });
      return pda;
    }
  };
  AuthorizationModule = class extends BaseModule {
    constructor(config) {
      super(config);
    }
    async createAuthorization(params, agentKeypair) {
      return await createSignedAuthorization(params, agentKeypair);
    }
    async storeAuthorizationOnChain(authorization2, agentSigner, config) {
      const storageFee = this.calculateStorageFee(authorization2, config);
      const feePayedByAgent = config?.feePayedByAgent ?? true;
      console.log(`\uD83D\uDCB0 On-chain storage cost: ${Number(storageFee) / 1e9} SOL`);
      console.log(`   Fee payer: ${feePayedByAgent ? "Agent" : "Facilitator"}`);
      const { getCreateAgentAuthorizationInstructionAsync: getCreateAgentAuthorizationInstructionAsync2 } = await Promise.resolve().then(() => (init_createAgentAuthorization_ULG47ZJI(), exports_createAgentAuthorization_ULG47ZJI));
      const { getProgramDerivedAddress: getProgramDerivedAddress2, getBytesEncoder: getBytesEncoder2, getAddressEncoder: getAddressEncoder2, getUtf8Encoder: getUtf8Encoder2 } = await Promise.resolve().then(() => (init_index_node35(), exports_index_node3));
      const nonce = authorization2.nonce ?? "default";
      const [authorizationPda] = await getProgramDerivedAddress2({
        programAddress: this.getProgramId(),
        seeds: [
          getBytesEncoder2().encode(new Uint8Array([97, 103, 101, 110, 116, 95, 97, 117, 116, 104])),
          getAddressEncoder2().encode(authorization2.agentAddress),
          getAddressEncoder2().encode(authorization2.authorizedSource),
          getUtf8Encoder2().encode(nonce)
        ]
      });
      return await this.execute("createAgentAuthorization", async () => {
        return await getCreateAgentAuthorizationInstructionAsync2({
          agent: authorization2.agentAddress,
          authorization: authorizationPda,
          authority: agentSigner,
          authorizedSource: authorization2.authorizedSource,
          indexLimit: BigInt(authorization2.indexLimit),
          expiresAt: BigInt(authorization2.expiresAt),
          network: authorization2.network === "mainnet-beta" ? 0 : authorization2.network === "devnet" ? 1 : 2,
          signature: authorization2.signature,
          nonce
        });
      }, [agentSigner]);
    }
    async verifySignature(authorization2) {
      return verifyAuthorizationSignature(authorization2);
    }
    getAuthorizationStatus(authorization2, currentIndex) {
      const now = Math.floor(Date.now() / 1000);
      const idx = currentIndex ?? 0;
      if (isAuthorizationExpired(authorization2, now)) {
        return {
          status: "expired",
          isValid: false,
          remainingUses: 0,
          reason: "Authorization has expired"
        };
      }
      if (isAuthorizationExhausted(authorization2, idx)) {
        return {
          status: "exhausted",
          isValid: false,
          remainingUses: 0,
          reason: "Index limit reached"
        };
      }
      const remaining = authorization2.indexLimit - idx;
      return {
        status: "active",
        isValid: true,
        remainingUses: remaining
      };
    }
    async fetchAuthorization(agentAddress, authorizedSource, nonce) {
      throw new Error("On-chain fetch not yet implemented - pending Codama generation");
    }
    async updateReputationWithAuth(authorization2, reputationChange, transactionSignature, usageRecord, metadata, facilitatorSigner) {
      const isValid = await this.verifySignature(authorization2);
      if (!isValid) {
        throw new Error("Invalid authorization signature");
      }
      const status = this.getAuthorizationStatus(authorization2);
      if (!status.isValid) {
        throw new Error(`Authorization is ${status.status}: ${status.reason}`);
      }
      const { getUpdateReputationWithAuthInstructionAsync: getUpdateReputationWithAuthInstructionAsync2 } = await Promise.resolve().then(() => (init_updateReputationWithAuth_Y4ONEVSP(), exports_updateReputationWithAuth_Y4ONEVSP));
      return await this.execute("updateReputationWithAuth", async () => {
        return await getUpdateReputationWithAuthInstructionAsync2({
          agent: authorization2.agentAddress,
          authorizedSource: facilitatorSigner,
          usageRecord,
          reputationChange: BigInt(reputationChange),
          transactionSignature,
          metadata: metadata ? JSON.stringify(metadata) : null,
          nonce: authorization2.nonce ?? null
        });
      }, [facilitatorSigner]);
    }
    async revokeAuthorization(agentAddress, authorization2, nonce, agentSigner) {
      const { getRevokeAuthorizationInstruction: getRevokeAuthorizationInstruction2 } = await Promise.resolve().then(() => (init_revokeAuthorization_OK7E7OK3(), exports_revokeAuthorization_OK7E7OK3));
      return await this.execute("revokeAuthorization", () => {
        return getRevokeAuthorizationInstruction2({
          agent: agentAddress,
          authorization: authorization2,
          authority: agentSigner,
          nonce: nonce ?? null
        });
      }, [agentSigner]);
    }
    async listAuthorizations(filter) {
      throw new Error("Authorization listing not yet implemented - pending Codama generation");
    }
    serializeAuthorization(authorization2) {
      return serializeAuthorization(authorization2);
    }
    deserializeAuthorization(data2) {
      return deserializeAuthorization(data2);
    }
    async getAuthorizationId(authorization2) {
      return getAuthorizationId(authorization2);
    }
    async createPayAIAuthorization(payAIFacilitatorAddress, agentKeypair, options2) {
      const defaultParams = {
        authorizedSource: payAIFacilitatorAddress,
        indexLimit: 1000,
        expiresIn: 2592000,
        network: "devnet",
        ...options2
      };
      return this.createAuthorization(defaultParams, agentKeypair);
    }
    calculateStorageFee(authorization2, config) {
      if (config?.storageFee !== undefined) {
        return config.storageFee;
      }
      if (config?.customFees) {
        const now = Math.floor(Date.now() / 1000);
        const duration = authorization2.expiresAt - now;
        const durations = Object.keys(config.customFees).map(Number).sort((a, b) => a - b);
        for (const d of durations) {
          if (duration <= d) {
            return config.customFees[d];
          }
        }
        const highestDuration = durations[durations.length - 1];
        if (highestDuration && config.customFees[highestDuration]) {
          return config.customFees[highestDuration];
        }
      }
      return DEFAULT_STORAGE_FEE;
    }
    async estimateStorageCost(params, config) {
      const now = Math.floor(Date.now() / 1000);
      const mockAuth = {
        agentAddress: "11111111111111111111111111111111",
        authorizedSource: params.authorizedSource,
        indexLimit: params.indexLimit ?? 1000,
        expiresAt: params.expiresAt ?? now + (params.expiresIn ?? 2592000),
        network: params.network ?? "devnet",
        signature: new Uint8Array(64),
        nonce: params.nonce
      };
      const feeInLamports = this.calculateStorageFee(mockAuth, config);
      return Number(feeInLamports) / 1e9;
    }
  };
  GhostSpeakClient_default = GhostSpeakClient;
});

// ../packages/sdk-typescript/dist/chunk-5DMB3UAV.js
var GhostSpeakError, NetworkError, InsufficientBalanceError, AccountNotFoundError, InvalidInputError, TransactionFailedError, SimulationFailedError, TimeoutError, ErrorFactory = class {
  static fromProgramLogs(logs, signature2) {
    const errorLog = logs.find((log) => log.includes("Error") || log.includes("failed") || log.includes("custom program error"));
    if (errorLog?.includes("insufficient funds")) {
      return new InsufficientBalanceError(0n, 0n, "unknown");
    }
    if (signature2) {
      return new TransactionFailedError(signature2, logs, errorLog);
    }
    return new SimulationFailedError(logs);
  }
  static fromRpcError(error, endpoint) {
    if (error instanceof Error) {
      if (error.message.includes("fetch")) {
        return new NetworkError(endpoint, error);
      }
      if (error.message.includes("429")) {
        return new GhostSpeakError("RPC_ERROR", "Rate limit exceeded", { endpoint, error: error.message }, `You are making too many requests. Try:
1. Adding delays between requests
2. Using a paid RPC endpoint
3. Implementing request batching`);
      }
    }
    return new GhostSpeakError("RPC_ERROR", "RPC request failed", { endpoint, error: String(error) }, "Check your RPC endpoint and network connection");
  }
}, ErrorHandler, ValidationError;
var init_chunk_5DMB3UAV = __esm(() => {
  GhostSpeakError = class extends Error {
    code;
    context;
    solution;
    instruction;
    constructor(code, message, context = {}, solution, instruction) {
      super(message);
      this.name = "GhostSpeakError";
      this.code = code;
      this.context = context;
      this.solution = solution;
      this.instruction = instruction;
    }
    toString() {
      let output = `${this.name} [${this.code}]: ${this.message}`;
      if (Object.keys(this.context).length > 0) {
        output += `
Context: ${JSON.stringify(this.context, null, 2)}`;
      }
      if (this.solution) {
        output += `

\uD83D\uDCA1 Solution: ${this.solution}`;
      }
      if (this.instruction) {
        output += `

\uD83D\uDCD6 Learn more: ${this.instruction}`;
      }
      return output;
    }
    toSDKError() {
      return {
        code: this.code,
        message: this.message,
        context: this.context,
        solution: this.solution,
        instruction: this.instruction
      };
    }
  };
  NetworkError = class extends GhostSpeakError {
    constructor(endpoint, originalError) {
      super("NETWORK_ERROR", `Failed to connect to RPC endpoint: ${endpoint}`, { endpoint, originalError: originalError?.message }, "Check your internet connection and verify the RPC endpoint is correct. Try using a different RPC provider.");
    }
  };
  InsufficientBalanceError = class extends GhostSpeakError {
    constructor(required, available, address2) {
      const requiredSOL = Number(required) / 1e9;
      const availableSOL = Number(available) / 1e9;
      const neededSOL = requiredSOL - availableSOL;
      super("INSUFFICIENT_BALANCE", `Insufficient balance: need ${requiredSOL} SOL but only have ${availableSOL} SOL`, {
        required: required.toString(),
        available: available.toString(),
        address: address2,
        requiredSOL,
        availableSOL,
        neededSOL
      }, `You need ${neededSOL.toFixed(4)} more SOL. Try:
1. Request devnet SOL: solana airdrop ${Math.ceil(neededSOL)} ${address2}
2. Or use: await ghostspeak.fund("${address2}", ${Math.ceil(neededSOL)})`);
    }
  };
  AccountNotFoundError = class extends GhostSpeakError {
    constructor(address2, accountType) {
      super("ACCOUNT_NOT_FOUND", `${accountType} account not found at address: ${address2}`, { address: address2, accountType }, `The ${accountType} account doesn't exist. Possible solutions:
1. Verify the address is correct
2. Ensure the account has been created
3. Check you're on the correct network (mainnet/devnet/testnet)`);
    }
  };
  InvalidInputError = class extends GhostSpeakError {
    constructor(field, value, requirement) {
      super("INVALID_INPUT", `Invalid ${field}: ${JSON.stringify(value)}`, { field, value, requirement }, `The ${field} must ${requirement}`);
    }
  };
  TransactionFailedError = class _TransactionFailedError extends GhostSpeakError {
    constructor(signature2, logs, programError) {
      const errorLog = logs.find((log) => log.includes("Error") || log.includes("failed"));
      super("TRANSACTION_FAILED", `Transaction failed: ${programError ?? errorLog ?? "Unknown error"}`, { signature: signature2, logs, programError }, _TransactionFailedError.getSolution(logs, programError), `https://explorer.solana.com/tx/${signature2}?cluster=devnet`);
    }
    static getSolution(logs, programError) {
      if (logs.some((log) => log.includes("insufficient funds"))) {
        return "Your account has insufficient SOL. Request an airdrop or add funds.";
      }
      if (logs.some((log) => log.includes("account is frozen"))) {
        return "The token account is frozen. Contact the token authority to unfreeze.";
      }
      if (logs.some((log) => log.includes("owner does not match"))) {
        return "You are not the owner of this account. Use the correct signer.";
      }
      if (logs.some((log) => log.includes("already in use"))) {
        return "This account is already in use. Try a different account or wait.";
      }
      if (programError?.includes("custom program error")) {
        const errorCode = programError.match(/0x([0-9a-f]+)/i)?.[1];
        if (errorCode) {
          return `Program error code: 0x${errorCode}. Check the program's error documentation.`;
        }
      }
      return `Check the transaction logs for more details. Common issues:
1. Insufficient balance
2. Invalid account state
3. Missing signatures
4. Program-specific requirements not met`;
    }
  };
  SimulationFailedError = class extends GhostSpeakError {
    constructor(logs, unitsConsumed) {
      super("SIMULATION_FAILED", "Transaction simulation failed", { logs, unitsConsumed: unitsConsumed?.toString() }, "The transaction would fail if submitted. Review the simulation logs to identify the issue.");
    }
  };
  TimeoutError = class extends GhostSpeakError {
    constructor(operation, timeoutMs) {
      super("TIMEOUT", `Operation timed out after ${timeoutMs}ms: ${operation}`, { operation, timeoutMs }, `The operation took too long. Try:
1. Increasing the timeout
2. Using a faster RPC endpoint
3. Retrying during lower network congestion`);
    }
  };
  ErrorHandler = class {
    static handlers = /* @__PURE__ */ new Map;
    static on(code, handler) {
      this.handlers.set(code, handler);
    }
    static handle(error) {
      let ghostSpeakError;
      if (error instanceof GhostSpeakError) {
        ghostSpeakError = error;
      } else if (error instanceof Error) {
        ghostSpeakError = new GhostSpeakError("UNKNOWN_ERROR", error.message, { originalError: error.name });
      } else {
        ghostSpeakError = new GhostSpeakError("UNKNOWN_ERROR", String(error));
      }
      const handler = this.handlers.get(ghostSpeakError.code);
      if (handler) {
        handler(ghostSpeakError);
      }
      if (true) {
        console.error(ghostSpeakError.toString());
      }
      return ghostSpeakError.toSDKError();
    }
  };
  ValidationError = class extends GhostSpeakError {
    constructor(message, context = {}) {
      super("INVALID_INPUT", message, context, "Check input parameters and ensure they meet the required format and constraints");
      this.name = "ValidationError";
    }
  };
});

// ../node_modules/.bun/@noble+curves@1.9.7/node_modules/@noble/curves/esm/utils.js
function _abool2(value, title = "") {
  if (typeof value !== "boolean") {
    const prefix = title && `"${title}"`;
    throw new Error(prefix + "expected boolean, got type=" + typeof value);
  }
  return value;
}
function _abytes2(value, length, title = "") {
  const bytes = isBytes(value);
  const len = value?.length;
  const needsLen = length !== undefined;
  if (!bytes || needsLen && len !== length) {
    const prefix = title && `"${title}" `;
    const ofLen = needsLen ? ` of length ${length}` : "";
    const got = bytes ? `length=${len}` : `type=${typeof value}`;
    throw new Error(prefix + "expected Uint8Array" + ofLen + ", got " + got);
  }
  return value;
}
function hexToNumber(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  return hex === "" ? _0n : BigInt("0x" + hex);
}
function bytesToNumberBE(bytes) {
  return hexToNumber(bytesToHex(bytes));
}
function bytesToNumberLE(bytes) {
  abytes(bytes);
  return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));
}
function numberToBytesBE(n, len) {
  return hexToBytes(n.toString(16).padStart(len * 2, "0"));
}
function numberToBytesLE(n, len) {
  return numberToBytesBE(n, len).reverse();
}
function ensureBytes(title, hex, expectedLength) {
  let res;
  if (typeof hex === "string") {
    try {
      res = hexToBytes(hex);
    } catch (e7) {
      throw new Error(title + " must be hex string or Uint8Array, cause: " + e7);
    }
  } else if (isBytes(hex)) {
    res = Uint8Array.from(hex);
  } else {
    throw new Error(title + " must be hex string or Uint8Array");
  }
  const len = res.length;
  if (typeof expectedLength === "number" && len !== expectedLength)
    throw new Error(title + " of length " + expectedLength + " expected, got " + len);
  return res;
}
function equalBytes(a, b) {
  if (a.length !== b.length)
    return false;
  let diff = 0;
  for (let i = 0;i < a.length; i++)
    diff |= a[i] ^ b[i];
  return diff === 0;
}
function copyBytes(bytes) {
  return Uint8Array.from(bytes);
}
function inRange(n, min, max) {
  return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;
}
function aInRange(title, n, min, max) {
  if (!inRange(n, min, max))
    throw new Error("expected valid " + title + ": " + min + " <= n < " + max + ", got " + n);
}
function bitLen(n) {
  let len;
  for (len = 0;n > _0n; n >>= _1n, len += 1)
    ;
  return len;
}
function isHash(val) {
  return typeof val === "function" && Number.isSafeInteger(val.outputLen);
}
function _validateObject(object, fields, optFields = {}) {
  if (!object || typeof object !== "object")
    throw new Error("expected valid options object");
  function checkField(fieldName, expectedType, isOpt) {
    const val = object[fieldName];
    if (isOpt && val === undefined)
      return;
    const current = typeof val;
    if (current !== expectedType || val === null)
      throw new Error(`param "${fieldName}" is invalid: expected ${expectedType}, got ${current}`);
  }
  Object.entries(fields).forEach(([k, v]) => checkField(k, v, false));
  Object.entries(optFields).forEach(([k, v]) => checkField(k, v, true));
}
function memoized(fn) {
  const map = new WeakMap;
  return (arg, ...args) => {
    const val = map.get(arg);
    if (val !== undefined)
      return val;
    const computed = fn(arg, ...args);
    map.set(arg, computed);
    return computed;
  };
}
var _0n, _1n, isPosBig = (n) => typeof n === "bigint" && _0n <= n, bitMask = (n) => (_1n << BigInt(n)) - _1n, notImplemented = () => {
  throw new Error("not implemented");
};
var init_utils2 = __esm(() => {
  init_utils();
  init_utils();
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  _0n = /* @__PURE__ */ BigInt(0);
  _1n = /* @__PURE__ */ BigInt(1);
});

// ../node_modules/.bun/@noble+curves@1.9.7/node_modules/@noble/curves/esm/abstract/modular.js
function mod2(a, b) {
  const result = a % b;
  return result >= _0n2 ? result : b + result;
}
function pow22(x, power, modulo2) {
  let res = x;
  while (power-- > _0n2) {
    res *= res;
    res %= modulo2;
  }
  return res;
}
function invert(number, modulo2) {
  if (number === _0n2)
    throw new Error("invert: expected non-zero number");
  if (modulo2 <= _0n2)
    throw new Error("invert: expected positive modulus, got " + modulo2);
  let a = mod2(number, modulo2);
  let b = modulo2;
  let x = _0n2, y = _1n2, u = _1n2, v = _0n2;
  while (a !== _0n2) {
    const q = b / a;
    const r = b % a;
    const m = x - u * q;
    const n = y - v * q;
    b = a, a = r, x = u, y = v, u = m, v = n;
  }
  const gcd = b;
  if (gcd !== _1n2)
    throw new Error("invert: does not exist");
  return mod2(x, modulo2);
}
function assertIsSquare(Fp, root, n) {
  if (!Fp.eql(Fp.sqr(root), n))
    throw new Error("Cannot find square root");
}
function sqrt3mod4(Fp, n) {
  const p1div4 = (Fp.ORDER + _1n2) / _4n;
  const root = Fp.pow(n, p1div4);
  assertIsSquare(Fp, root, n);
  return root;
}
function sqrt5mod8(Fp, n) {
  const p5div8 = (Fp.ORDER - _5n) / _8n;
  const n2 = Fp.mul(n, _2n);
  const v = Fp.pow(n2, p5div8);
  const nv = Fp.mul(n, v);
  const i = Fp.mul(Fp.mul(nv, _2n), v);
  const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));
  assertIsSquare(Fp, root, n);
  return root;
}
function sqrt9mod16(P2) {
  const Fp_ = Field(P2);
  const tn = tonelliShanks(P2);
  const c1 = tn(Fp_, Fp_.neg(Fp_.ONE));
  const c2 = tn(Fp_, c1);
  const c3 = tn(Fp_, Fp_.neg(c1));
  const c4 = (P2 + _7n) / _16n;
  return (Fp, n) => {
    let tv1 = Fp.pow(n, c4);
    let tv2 = Fp.mul(tv1, c1);
    const tv3 = Fp.mul(tv1, c2);
    const tv4 = Fp.mul(tv1, c3);
    const e1 = Fp.eql(Fp.sqr(tv2), n);
    const e22 = Fp.eql(Fp.sqr(tv3), n);
    tv1 = Fp.cmov(tv1, tv2, e1);
    tv2 = Fp.cmov(tv4, tv3, e22);
    const e32 = Fp.eql(Fp.sqr(tv2), n);
    const root = Fp.cmov(tv1, tv2, e32);
    assertIsSquare(Fp, root, n);
    return root;
  };
}
function tonelliShanks(P2) {
  if (P2 < _3n)
    throw new Error("sqrt is not defined for small field");
  let Q = P2 - _1n2;
  let S = 0;
  while (Q % _2n === _0n2) {
    Q /= _2n;
    S++;
  }
  let Z = _2n;
  const _Fp = Field(P2);
  while (FpLegendre(_Fp, Z) === 1) {
    if (Z++ > 1000)
      throw new Error("Cannot find square root: probably non-prime P");
  }
  if (S === 1)
    return sqrt3mod4;
  let cc = _Fp.pow(Z, Q);
  const Q1div2 = (Q + _1n2) / _2n;
  return function tonelliSlow(Fp, n) {
    if (Fp.is0(n))
      return n;
    if (FpLegendre(Fp, n) !== 1)
      throw new Error("Cannot find square root");
    let M = S;
    let c = Fp.mul(Fp.ONE, cc);
    let t = Fp.pow(n, Q);
    let R = Fp.pow(n, Q1div2);
    while (!Fp.eql(t, Fp.ONE)) {
      if (Fp.is0(t))
        return Fp.ZERO;
      let i = 1;
      let t_tmp = Fp.sqr(t);
      while (!Fp.eql(t_tmp, Fp.ONE)) {
        i++;
        t_tmp = Fp.sqr(t_tmp);
        if (i === M)
          throw new Error("Cannot find square root");
      }
      const exponent = _1n2 << BigInt(M - i - 1);
      const b = Fp.pow(c, exponent);
      M = i;
      c = Fp.sqr(b);
      t = Fp.mul(t, c);
      R = Fp.mul(R, b);
    }
    return R;
  };
}
function FpSqrt(P2) {
  if (P2 % _4n === _3n)
    return sqrt3mod4;
  if (P2 % _8n === _5n)
    return sqrt5mod8;
  if (P2 % _16n === _9n)
    return sqrt9mod16(P2);
  return tonelliShanks(P2);
}
function validateField(field) {
  const initial = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "number",
    BITS: "number"
  };
  const opts = FIELD_FIELDS.reduce((map, val) => {
    map[val] = "function";
    return map;
  }, initial);
  _validateObject(field, opts);
  return field;
}
function FpPow(Fp, num, power) {
  if (power < _0n2)
    throw new Error("invalid exponent, negatives unsupported");
  if (power === _0n2)
    return Fp.ONE;
  if (power === _1n2)
    return num;
  let p = Fp.ONE;
  let d = num;
  while (power > _0n2) {
    if (power & _1n2)
      p = Fp.mul(p, d);
    d = Fp.sqr(d);
    power >>= _1n2;
  }
  return p;
}
function FpInvertBatch(Fp, nums, passZero = false) {
  const inverted = new Array(nums.length).fill(passZero ? Fp.ZERO : undefined);
  const multipliedAcc = nums.reduce((acc, num, i) => {
    if (Fp.is0(num))
      return acc;
    inverted[i] = acc;
    return Fp.mul(acc, num);
  }, Fp.ONE);
  const invertedAcc = Fp.inv(multipliedAcc);
  nums.reduceRight((acc, num, i) => {
    if (Fp.is0(num))
      return acc;
    inverted[i] = Fp.mul(acc, inverted[i]);
    return Fp.mul(acc, num);
  }, invertedAcc);
  return inverted;
}
function FpLegendre(Fp, n) {
  const p1mod2 = (Fp.ORDER - _1n2) / _2n;
  const powered = Fp.pow(n, p1mod2);
  const yes = Fp.eql(powered, Fp.ONE);
  const zero = Fp.eql(powered, Fp.ZERO);
  const no = Fp.eql(powered, Fp.neg(Fp.ONE));
  if (!yes && !zero && !no)
    throw new Error("invalid Legendre symbol result");
  return yes ? 1 : zero ? 0 : -1;
}
function nLength(n, nBitLength) {
  if (nBitLength !== undefined)
    anumber(nBitLength);
  const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
function Field(ORDER, bitLenOrOpts, isLE = false, opts = {}) {
  if (ORDER <= _0n2)
    throw new Error("invalid field: expected ORDER > 0, got " + ORDER);
  let _nbitLength = undefined;
  let _sqrt = undefined;
  let modFromBytes = false;
  let allowedLengths = undefined;
  if (typeof bitLenOrOpts === "object" && bitLenOrOpts != null) {
    if (opts.sqrt || isLE)
      throw new Error("cannot specify opts in two arguments");
    const _opts = bitLenOrOpts;
    if (_opts.BITS)
      _nbitLength = _opts.BITS;
    if (_opts.sqrt)
      _sqrt = _opts.sqrt;
    if (typeof _opts.isLE === "boolean")
      isLE = _opts.isLE;
    if (typeof _opts.modFromBytes === "boolean")
      modFromBytes = _opts.modFromBytes;
    allowedLengths = _opts.allowedLengths;
  } else {
    if (typeof bitLenOrOpts === "number")
      _nbitLength = bitLenOrOpts;
    if (opts.sqrt)
      _sqrt = opts.sqrt;
  }
  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, _nbitLength);
  if (BYTES > 2048)
    throw new Error("invalid field: expected ORDER of <= 2048 bytes");
  let sqrtP;
  const f = Object.freeze({
    ORDER,
    isLE,
    BITS,
    BYTES,
    MASK: bitMask(BITS),
    ZERO: _0n2,
    ONE: _1n2,
    allowedLengths,
    create: (num) => mod2(num, ORDER),
    isValid: (num) => {
      if (typeof num !== "bigint")
        throw new Error("invalid field element: expected bigint, got " + typeof num);
      return _0n2 <= num && num < ORDER;
    },
    is0: (num) => num === _0n2,
    isValidNot0: (num) => !f.is0(num) && f.isValid(num),
    isOdd: (num) => (num & _1n2) === _1n2,
    neg: (num) => mod2(-num, ORDER),
    eql: (lhs, rhs) => lhs === rhs,
    sqr: (num) => mod2(num * num, ORDER),
    add: (lhs, rhs) => mod2(lhs + rhs, ORDER),
    sub: (lhs, rhs) => mod2(lhs - rhs, ORDER),
    mul: (lhs, rhs) => mod2(lhs * rhs, ORDER),
    pow: (num, power) => FpPow(f, num, power),
    div: (lhs, rhs) => mod2(lhs * invert(rhs, ORDER), ORDER),
    sqrN: (num) => num * num,
    addN: (lhs, rhs) => lhs + rhs,
    subN: (lhs, rhs) => lhs - rhs,
    mulN: (lhs, rhs) => lhs * rhs,
    inv: (num) => invert(num, ORDER),
    sqrt: _sqrt || ((n) => {
      if (!sqrtP)
        sqrtP = FpSqrt(ORDER);
      return sqrtP(f, n);
    }),
    toBytes: (num) => isLE ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES),
    fromBytes: (bytes, skipValidation = true) => {
      if (allowedLengths) {
        if (!allowedLengths.includes(bytes.length) || bytes.length > BYTES) {
          throw new Error("Field.fromBytes: expected " + allowedLengths + " bytes, got " + bytes.length);
        }
        const padded = new Uint8Array(BYTES);
        padded.set(bytes, isLE ? 0 : padded.length - bytes.length);
        bytes = padded;
      }
      if (bytes.length !== BYTES)
        throw new Error("Field.fromBytes: expected " + BYTES + " bytes, got " + bytes.length);
      let scalar = isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);
      if (modFromBytes)
        scalar = mod2(scalar, ORDER);
      if (!skipValidation) {
        if (!f.isValid(scalar))
          throw new Error("invalid field element: outside of range 0..ORDER");
      }
      return scalar;
    },
    invertBatch: (lst) => FpInvertBatch(f, lst),
    cmov: (a, b, c) => c ? b : a
  });
  return Object.freeze(f);
}
function FpSqrtEven(Fp, elm) {
  if (!Fp.isOdd)
    throw new Error("Field doesn't have isOdd");
  const root = Fp.sqrt(elm);
  return Fp.isOdd(root) ? Fp.neg(root) : root;
}
var _0n2, _1n2, _2n, _3n, _4n, _5n, _7n, _8n, _9n, _16n, isNegativeLE = (num, modulo2) => (mod2(num, modulo2) & _1n2) === _1n2, FIELD_FIELDS;
var init_modular = __esm(() => {
  init_utils2();
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  _0n2 = BigInt(0);
  _1n2 = BigInt(1);
  _2n = /* @__PURE__ */ BigInt(2);
  _3n = /* @__PURE__ */ BigInt(3);
  _4n = /* @__PURE__ */ BigInt(4);
  _5n = /* @__PURE__ */ BigInt(5);
  _7n = /* @__PURE__ */ BigInt(7);
  _8n = /* @__PURE__ */ BigInt(8);
  _9n = /* @__PURE__ */ BigInt(9);
  _16n = /* @__PURE__ */ BigInt(16);
  FIELD_FIELDS = [
    "create",
    "isValid",
    "is0",
    "neg",
    "inv",
    "sqrt",
    "sqr",
    "eql",
    "add",
    "sub",
    "mul",
    "pow",
    "div",
    "addN",
    "subN",
    "mulN",
    "sqrN"
  ];
});

// ../node_modules/.bun/@noble+curves@1.9.7/node_modules/@noble/curves/esm/abstract/curve.js
function negateCt(condition, item) {
  const neg = item.negate();
  return condition ? neg : item;
}
function normalizeZ(c, points) {
  const invertedZs = FpInvertBatch(c.Fp, points.map((p) => p.Z));
  return points.map((p, i) => c.fromAffine(p.toAffine(invertedZs[i])));
}
function validateW(W, bits) {
  if (!Number.isSafeInteger(W) || W <= 0 || W > bits)
    throw new Error("invalid window size, expected [1.." + bits + "], got W=" + W);
}
function calcWOpts(W, scalarBits) {
  validateW(W, scalarBits);
  const windows = Math.ceil(scalarBits / W) + 1;
  const windowSize = 2 ** (W - 1);
  const maxNumber = 2 ** W;
  const mask = bitMask(W);
  const shiftBy = BigInt(W);
  return { windows, windowSize, mask, maxNumber, shiftBy };
}
function calcOffsets(n, window2, wOpts) {
  const { windowSize, mask, maxNumber, shiftBy } = wOpts;
  let wbits = Number(n & mask);
  let nextN = n >> shiftBy;
  if (wbits > windowSize) {
    wbits -= maxNumber;
    nextN += _1n3;
  }
  const offsetStart = window2 * windowSize;
  const offset = offsetStart + Math.abs(wbits) - 1;
  const isZero = wbits === 0;
  const isNeg = wbits < 0;
  const isNegF = window2 % 2 !== 0;
  const offsetF = offsetStart;
  return { nextN, offset, isZero, isNeg, isNegF, offsetF };
}
function validateMSMPoints(points, c) {
  if (!Array.isArray(points))
    throw new Error("array expected");
  points.forEach((p, i) => {
    if (!(p instanceof c))
      throw new Error("invalid point at index " + i);
  });
}
function validateMSMScalars(scalars, field) {
  if (!Array.isArray(scalars))
    throw new Error("array of scalars expected");
  scalars.forEach((s3, i) => {
    if (!field.isValid(s3))
      throw new Error("invalid scalar at index " + i);
  });
}
function getW(P2) {
  return pointWindowSizes.get(P2) || 1;
}
function assert0(n) {
  if (n !== _0n3)
    throw new Error("invalid wNAF");
}

class wNAF {
  constructor(Point, bits) {
    this.BASE = Point.BASE;
    this.ZERO = Point.ZERO;
    this.Fn = Point.Fn;
    this.bits = bits;
  }
  _unsafeLadder(elm, n, p = this.ZERO) {
    let d = elm;
    while (n > _0n3) {
      if (n & _1n3)
        p = p.add(d);
      d = d.double();
      n >>= _1n3;
    }
    return p;
  }
  precomputeWindow(point, W) {
    const { windows, windowSize } = calcWOpts(W, this.bits);
    const points = [];
    let p = point;
    let base2 = p;
    for (let window2 = 0;window2 < windows; window2++) {
      base2 = p;
      points.push(base2);
      for (let i = 1;i < windowSize; i++) {
        base2 = base2.add(p);
        points.push(base2);
      }
      p = base2.double();
    }
    return points;
  }
  wNAF(W, precomputes, n) {
    if (!this.Fn.isValid(n))
      throw new Error("invalid scalar");
    let p = this.ZERO;
    let f = this.BASE;
    const wo = calcWOpts(W, this.bits);
    for (let window2 = 0;window2 < wo.windows; window2++) {
      const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets(n, window2, wo);
      n = nextN;
      if (isZero) {
        f = f.add(negateCt(isNegF, precomputes[offsetF]));
      } else {
        p = p.add(negateCt(isNeg, precomputes[offset]));
      }
    }
    assert0(n);
    return { p, f };
  }
  wNAFUnsafe(W, precomputes, n, acc = this.ZERO) {
    const wo = calcWOpts(W, this.bits);
    for (let window2 = 0;window2 < wo.windows; window2++) {
      if (n === _0n3)
        break;
      const { nextN, offset, isZero, isNeg } = calcOffsets(n, window2, wo);
      n = nextN;
      if (isZero) {
        continue;
      } else {
        const item = precomputes[offset];
        acc = acc.add(isNeg ? item.negate() : item);
      }
    }
    assert0(n);
    return acc;
  }
  getPrecomputes(W, point, transform) {
    let comp = pointPrecomputes.get(point);
    if (!comp) {
      comp = this.precomputeWindow(point, W);
      if (W !== 1) {
        if (typeof transform === "function")
          comp = transform(comp);
        pointPrecomputes.set(point, comp);
      }
    }
    return comp;
  }
  cached(point, scalar, transform) {
    const W = getW(point);
    return this.wNAF(W, this.getPrecomputes(W, point, transform), scalar);
  }
  unsafe(point, scalar, transform, prev) {
    const W = getW(point);
    if (W === 1)
      return this._unsafeLadder(point, scalar, prev);
    return this.wNAFUnsafe(W, this.getPrecomputes(W, point, transform), scalar, prev);
  }
  createCache(P2, W) {
    validateW(W, this.bits);
    pointWindowSizes.set(P2, W);
    pointPrecomputes.delete(P2);
  }
  hasCache(elm) {
    return getW(elm) !== 1;
  }
}
function pippenger(c, fieldN, points, scalars) {
  validateMSMPoints(points, c);
  validateMSMScalars(scalars, fieldN);
  const plength = points.length;
  const slength = scalars.length;
  if (plength !== slength)
    throw new Error("arrays of points and scalars must have equal length");
  const zero = c.ZERO;
  const wbits = bitLen(BigInt(plength));
  let windowSize = 1;
  if (wbits > 12)
    windowSize = wbits - 3;
  else if (wbits > 4)
    windowSize = wbits - 2;
  else if (wbits > 0)
    windowSize = 2;
  const MASK = bitMask(windowSize);
  const buckets = new Array(Number(MASK) + 1).fill(zero);
  const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;
  let sum = zero;
  for (let i = lastBits;i >= 0; i -= windowSize) {
    buckets.fill(zero);
    for (let j = 0;j < slength; j++) {
      const scalar = scalars[j];
      const wbits2 = Number(scalar >> BigInt(i) & MASK);
      buckets[wbits2] = buckets[wbits2].add(points[j]);
    }
    let resI = zero;
    for (let j = buckets.length - 1, sumI = zero;j > 0; j--) {
      sumI = sumI.add(buckets[j]);
      resI = resI.add(sumI);
    }
    sum = sum.add(resI);
    if (i !== 0)
      for (let j = 0;j < windowSize; j++)
        sum = sum.double();
  }
  return sum;
}
function createField(order, field, isLE) {
  if (field) {
    if (field.ORDER !== order)
      throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
    validateField(field);
    return field;
  } else {
    return Field(order, { isLE });
  }
}
function _createCurveFields(type, CURVE, curveOpts = {}, FpFnLE) {
  if (FpFnLE === undefined)
    FpFnLE = type === "edwards";
  if (!CURVE || typeof CURVE !== "object")
    throw new Error(`expected valid ${type} CURVE object`);
  for (const p of ["p", "n", "h"]) {
    const val = CURVE[p];
    if (!(typeof val === "bigint" && val > _0n3))
      throw new Error(`CURVE.${p} must be positive bigint`);
  }
  const Fp = createField(CURVE.p, curveOpts.Fp, FpFnLE);
  const Fn = createField(CURVE.n, curveOpts.Fn, FpFnLE);
  const _b = type === "weierstrass" ? "b" : "d";
  const params = ["Gx", "Gy", "a", _b];
  for (const p of params) {
    if (!Fp.isValid(CURVE[p]))
      throw new Error(`CURVE.${p} must be valid field element of CURVE.Fp`);
  }
  CURVE = Object.freeze(Object.assign({}, CURVE));
  return { CURVE, Fp, Fn };
}
var _0n3, _1n3, pointPrecomputes, pointWindowSizes;
var init_curve = __esm(() => {
  init_utils2();
  init_modular();
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  _0n3 = BigInt(0);
  _1n3 = BigInt(1);
  pointPrecomputes = new WeakMap;
  pointWindowSizes = new WeakMap;
});

// ../node_modules/.bun/@noble+curves@1.9.7/node_modules/@noble/curves/esm/abstract/edwards.js
function isEdValidXY(Fp, CURVE, x, y) {
  const x2 = Fp.sqr(x);
  const y2 = Fp.sqr(y);
  const left = Fp.add(Fp.mul(CURVE.a, x2), y2);
  const right = Fp.add(Fp.ONE, Fp.mul(CURVE.d, Fp.mul(x2, y2)));
  return Fp.eql(left, right);
}
function edwards(params, extraOpts = {}) {
  const validated = _createCurveFields("edwards", params, extraOpts, extraOpts.FpFnLE);
  const { Fp, Fn } = validated;
  let CURVE = validated.CURVE;
  const { h: cofactor } = CURVE;
  _validateObject(extraOpts, {}, { uvRatio: "function" });
  const MASK = _2n2 << BigInt(Fn.BYTES * 8) - _1n4;
  const modP = (n) => Fp.create(n);
  const uvRatio2 = extraOpts.uvRatio || ((u, v) => {
    try {
      return { isValid: true, value: Fp.sqrt(Fp.div(u, v)) };
    } catch (e7) {
      return { isValid: false, value: _0n4 };
    }
  });
  if (!isEdValidXY(Fp, CURVE, CURVE.Gx, CURVE.Gy))
    throw new Error("bad curve params: generator point");
  function acoord(title, n, banZero = false) {
    const min = banZero ? _1n4 : _0n4;
    aInRange("coordinate " + title, n, min, MASK);
    return n;
  }
  function aextpoint(other) {
    if (!(other instanceof Point))
      throw new Error("ExtendedPoint expected");
  }
  const toAffineMemo = memoized((p, iz) => {
    const { X, Y, Z } = p;
    const is0 = p.is0();
    if (iz == null)
      iz = is0 ? _8n2 : Fp.inv(Z);
    const x = modP(X * iz);
    const y = modP(Y * iz);
    const zz = Fp.mul(Z, iz);
    if (is0)
      return { x: _0n4, y: _1n4 };
    if (zz !== _1n4)
      throw new Error("invZ was invalid");
    return { x, y };
  });
  const assertValidMemo = memoized((p) => {
    const { a, d } = CURVE;
    if (p.is0())
      throw new Error("bad point: ZERO");
    const { X, Y, Z, T } = p;
    const X2 = modP(X * X);
    const Y2 = modP(Y * Y);
    const Z2 = modP(Z * Z);
    const Z4 = modP(Z2 * Z2);
    const aX2 = modP(X2 * a);
    const left = modP(Z2 * modP(aX2 + Y2));
    const right = modP(Z4 + modP(d * modP(X2 * Y2)));
    if (left !== right)
      throw new Error("bad point: equation left != right (1)");
    const XY = modP(X * Y);
    const ZT = modP(Z * T);
    if (XY !== ZT)
      throw new Error("bad point: equation left != right (2)");
    return true;
  });

  class Point {
    constructor(X, Y, Z, T) {
      this.X = acoord("x", X);
      this.Y = acoord("y", Y);
      this.Z = acoord("z", Z, true);
      this.T = acoord("t", T);
      Object.freeze(this);
    }
    static CURVE() {
      return CURVE;
    }
    static fromAffine(p) {
      if (p instanceof Point)
        throw new Error("extended point not allowed");
      const { x, y } = p || {};
      acoord("x", x);
      acoord("y", y);
      return new Point(x, y, _1n4, modP(x * y));
    }
    static fromBytes(bytes, zip215 = false) {
      const len = Fp.BYTES;
      const { a, d } = CURVE;
      bytes = copyBytes(_abytes2(bytes, len, "point"));
      _abool2(zip215, "zip215");
      const normed = copyBytes(bytes);
      const lastByte = bytes[len - 1];
      normed[len - 1] = lastByte & ~128;
      const y = bytesToNumberLE(normed);
      const max = zip215 ? MASK : Fp.ORDER;
      aInRange("point.y", y, _0n4, max);
      const y2 = modP(y * y);
      const u = modP(y2 - _1n4);
      const v = modP(d * y2 - a);
      let { isValid, value: x } = uvRatio2(u, v);
      if (!isValid)
        throw new Error("bad point: invalid y coordinate");
      const isXOdd = (x & _1n4) === _1n4;
      const isLastByteOdd = (lastByte & 128) !== 0;
      if (!zip215 && x === _0n4 && isLastByteOdd)
        throw new Error("bad point: x=0 and x_0=1");
      if (isLastByteOdd !== isXOdd)
        x = modP(-x);
      return Point.fromAffine({ x, y });
    }
    static fromHex(bytes, zip215 = false) {
      return Point.fromBytes(ensureBytes("point", bytes), zip215);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    precompute(windowSize = 8, isLazy = true) {
      wnaf.createCache(this, windowSize);
      if (!isLazy)
        this.multiply(_2n2);
      return this;
    }
    assertValidity() {
      assertValidMemo(this);
    }
    equals(other) {
      aextpoint(other);
      const { X: X1, Y: Y1, Z: Z1 } = this;
      const { X: X2, Y: Y2, Z: Z2 } = other;
      const X1Z2 = modP(X1 * Z2);
      const X2Z1 = modP(X2 * Z1);
      const Y1Z2 = modP(Y1 * Z2);
      const Y2Z1 = modP(Y2 * Z1);
      return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
    }
    is0() {
      return this.equals(Point.ZERO);
    }
    negate() {
      return new Point(modP(-this.X), this.Y, this.Z, modP(-this.T));
    }
    double() {
      const { a } = CURVE;
      const { X: X1, Y: Y1, Z: Z1 } = this;
      const A = modP(X1 * X1);
      const B = modP(Y1 * Y1);
      const C = modP(_2n2 * modP(Z1 * Z1));
      const D2 = modP(a * A);
      const x1y1 = X1 + Y1;
      const E = modP(modP(x1y1 * x1y1) - A - B);
      const G = D2 + B;
      const F = G - C;
      const H = D2 - B;
      const X3 = modP(E * F);
      const Y3 = modP(G * H);
      const T3 = modP(E * H);
      const Z3 = modP(F * G);
      return new Point(X3, Y3, Z3, T3);
    }
    add(other) {
      aextpoint(other);
      const { a, d } = CURVE;
      const { X: X1, Y: Y1, Z: Z1, T: T1 } = this;
      const { X: X2, Y: Y2, Z: Z2, T: T2 } = other;
      const A = modP(X1 * X2);
      const B = modP(Y1 * Y2);
      const C = modP(T1 * d * T2);
      const D2 = modP(Z1 * Z2);
      const E = modP((X1 + Y1) * (X2 + Y2) - A - B);
      const F = D2 - C;
      const G = D2 + C;
      const H = modP(B - a * A);
      const X3 = modP(E * F);
      const Y3 = modP(G * H);
      const T3 = modP(E * H);
      const Z3 = modP(F * G);
      return new Point(X3, Y3, Z3, T3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    multiply(scalar) {
      if (!Fn.isValidNot0(scalar))
        throw new Error("invalid scalar: expected 1 <= sc < curve.n");
      const { p, f } = wnaf.cached(this, scalar, (p2) => normalizeZ(Point, p2));
      return normalizeZ(Point, [p, f])[0];
    }
    multiplyUnsafe(scalar, acc = Point.ZERO) {
      if (!Fn.isValid(scalar))
        throw new Error("invalid scalar: expected 0 <= sc < curve.n");
      if (scalar === _0n4)
        return Point.ZERO;
      if (this.is0() || scalar === _1n4)
        return this;
      return wnaf.unsafe(this, scalar, (p) => normalizeZ(Point, p), acc);
    }
    isSmallOrder() {
      return this.multiplyUnsafe(cofactor).is0();
    }
    isTorsionFree() {
      return wnaf.unsafe(this, CURVE.n).is0();
    }
    toAffine(invertedZ) {
      return toAffineMemo(this, invertedZ);
    }
    clearCofactor() {
      if (cofactor === _1n4)
        return this;
      return this.multiplyUnsafe(cofactor);
    }
    toBytes() {
      const { x, y } = this.toAffine();
      const bytes = Fp.toBytes(y);
      bytes[bytes.length - 1] |= x & _1n4 ? 128 : 0;
      return bytes;
    }
    toHex() {
      return bytesToHex(this.toBytes());
    }
    toString() {
      return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
    }
    get ex() {
      return this.X;
    }
    get ey() {
      return this.Y;
    }
    get ez() {
      return this.Z;
    }
    get et() {
      return this.T;
    }
    static normalizeZ(points) {
      return normalizeZ(Point, points);
    }
    static msm(points, scalars) {
      return pippenger(Point, Fn, points, scalars);
    }
    _setWindowSize(windowSize) {
      this.precompute(windowSize);
    }
    toRawBytes() {
      return this.toBytes();
    }
  }
  Point.BASE = new Point(CURVE.Gx, CURVE.Gy, _1n4, modP(CURVE.Gx * CURVE.Gy));
  Point.ZERO = new Point(_0n4, _1n4, _1n4, _0n4);
  Point.Fp = Fp;
  Point.Fn = Fn;
  const wnaf = new wNAF(Point, Fn.BITS);
  Point.BASE.precompute(8);
  return Point;
}

class PrimeEdwardsPoint {
  constructor(ep) {
    this.ep = ep;
  }
  static fromBytes(_bytes) {
    notImplemented();
  }
  static fromHex(_hex) {
    notImplemented();
  }
  get x() {
    return this.toAffine().x;
  }
  get y() {
    return this.toAffine().y;
  }
  clearCofactor() {
    return this;
  }
  assertValidity() {
    this.ep.assertValidity();
  }
  toAffine(invertedZ) {
    return this.ep.toAffine(invertedZ);
  }
  toHex() {
    return bytesToHex(this.toBytes());
  }
  toString() {
    return this.toHex();
  }
  isTorsionFree() {
    return true;
  }
  isSmallOrder() {
    return false;
  }
  add(other) {
    this.assertSame(other);
    return this.init(this.ep.add(other.ep));
  }
  subtract(other) {
    this.assertSame(other);
    return this.init(this.ep.subtract(other.ep));
  }
  multiply(scalar) {
    return this.init(this.ep.multiply(scalar));
  }
  multiplyUnsafe(scalar) {
    return this.init(this.ep.multiplyUnsafe(scalar));
  }
  double() {
    return this.init(this.ep.double());
  }
  negate() {
    return this.init(this.ep.negate());
  }
  precompute(windowSize, isLazy) {
    return this.init(this.ep.precompute(windowSize, isLazy));
  }
  toRawBytes() {
    return this.toBytes();
  }
}
function eddsa(Point, cHash, eddsaOpts = {}) {
  if (typeof cHash !== "function")
    throw new Error('"hash" function param is required');
  _validateObject(eddsaOpts, {}, {
    adjustScalarBytes: "function",
    randomBytes: "function",
    domain: "function",
    prehash: "function",
    mapToCurve: "function"
  });
  const { prehash } = eddsaOpts;
  const { BASE, Fp, Fn } = Point;
  const randomBytes2 = eddsaOpts.randomBytes || randomBytes;
  const adjustScalarBytes = eddsaOpts.adjustScalarBytes || ((bytes) => bytes);
  const domain = eddsaOpts.domain || ((data2, ctx, phflag) => {
    _abool2(phflag, "phflag");
    if (ctx.length || phflag)
      throw new Error("Contexts/pre-hash are not supported");
    return data2;
  });
  function modN_LE(hash) {
    return Fn.create(bytesToNumberLE(hash));
  }
  function getPrivateScalar(key) {
    const len = lengths.secretKey;
    key = ensureBytes("private key", key, len);
    const hashed = ensureBytes("hashed private key", cHash(key), 2 * len);
    const head = adjustScalarBytes(hashed.slice(0, len));
    const prefix = hashed.slice(len, 2 * len);
    const scalar = modN_LE(head);
    return { head, prefix, scalar };
  }
  function getExtendedPublicKey(secretKey) {
    const { head, prefix, scalar } = getPrivateScalar(secretKey);
    const point = BASE.multiply(scalar);
    const pointBytes = point.toBytes();
    return { head, prefix, scalar, point, pointBytes };
  }
  function getPublicKey(secretKey) {
    return getExtendedPublicKey(secretKey).pointBytes;
  }
  function hashDomainToScalar(context = Uint8Array.of(), ...msgs) {
    const msg = concatBytes(...msgs);
    return modN_LE(cHash(domain(msg, ensureBytes("context", context), !!prehash)));
  }
  function sign(msg, secretKey, options2 = {}) {
    msg = ensureBytes("message", msg);
    if (prehash)
      msg = prehash(msg);
    const { prefix, scalar, pointBytes } = getExtendedPublicKey(secretKey);
    const r = hashDomainToScalar(options2.context, prefix, msg);
    const R = BASE.multiply(r).toBytes();
    const k = hashDomainToScalar(options2.context, R, pointBytes, msg);
    const s3 = Fn.create(r + k * scalar);
    if (!Fn.isValid(s3))
      throw new Error("sign failed: invalid s");
    const rs = concatBytes(R, Fn.toBytes(s3));
    return _abytes2(rs, lengths.signature, "result");
  }
  const verifyOpts = { zip215: true };
  function verify(sig, msg, publicKey, options2 = verifyOpts) {
    const { context, zip215 } = options2;
    const len = lengths.signature;
    sig = ensureBytes("signature", sig, len);
    msg = ensureBytes("message", msg);
    publicKey = ensureBytes("publicKey", publicKey, lengths.publicKey);
    if (zip215 !== undefined)
      _abool2(zip215, "zip215");
    if (prehash)
      msg = prehash(msg);
    const mid = len / 2;
    const r = sig.subarray(0, mid);
    const s3 = bytesToNumberLE(sig.subarray(mid, len));
    let A, R, SB;
    try {
      A = Point.fromBytes(publicKey, zip215);
      R = Point.fromBytes(r, zip215);
      SB = BASE.multiplyUnsafe(s3);
    } catch (error) {
      return false;
    }
    if (!zip215 && A.isSmallOrder())
      return false;
    const k = hashDomainToScalar(context, R.toBytes(), A.toBytes(), msg);
    const RkA = R.add(A.multiplyUnsafe(k));
    return RkA.subtract(SB).clearCofactor().is0();
  }
  const _size = Fp.BYTES;
  const lengths = {
    secretKey: _size,
    publicKey: _size,
    signature: 2 * _size,
    seed: _size
  };
  function randomSecretKey(seed = randomBytes2(lengths.seed)) {
    return _abytes2(seed, lengths.seed, "seed");
  }
  function keygen(seed) {
    const secretKey = utils.randomSecretKey(seed);
    return { secretKey, publicKey: getPublicKey(secretKey) };
  }
  function isValidSecretKey(key) {
    return isBytes(key) && key.length === Fn.BYTES;
  }
  function isValidPublicKey(key, zip215) {
    try {
      return !!Point.fromBytes(key, zip215);
    } catch (error) {
      return false;
    }
  }
  const utils = {
    getExtendedPublicKey,
    randomSecretKey,
    isValidSecretKey,
    isValidPublicKey,
    toMontgomery(publicKey) {
      const { y } = Point.fromBytes(publicKey);
      const size = lengths.publicKey;
      const is25519 = size === 32;
      if (!is25519 && size !== 57)
        throw new Error("only defined for 25519 and 448");
      const u = is25519 ? Fp.div(_1n4 + y, _1n4 - y) : Fp.div(y - _1n4, y + _1n4);
      return Fp.toBytes(u);
    },
    toMontgomerySecret(secretKey) {
      const size = lengths.secretKey;
      _abytes2(secretKey, size);
      const hashed = cHash(secretKey.subarray(0, size));
      return adjustScalarBytes(hashed).subarray(0, size);
    },
    randomPrivateKey: randomSecretKey,
    precompute(windowSize = 8, point = Point.BASE) {
      return point.precompute(windowSize, false);
    }
  };
  return Object.freeze({
    keygen,
    getPublicKey,
    sign,
    verify,
    utils,
    Point,
    lengths
  });
}
function _eddsa_legacy_opts_to_new(c) {
  const CURVE = {
    a: c.a,
    d: c.d,
    p: c.Fp.ORDER,
    n: c.n,
    h: c.h,
    Gx: c.Gx,
    Gy: c.Gy
  };
  const Fp = c.Fp;
  const Fn = Field(CURVE.n, c.nBitLength, true);
  const curveOpts = { Fp, Fn, uvRatio: c.uvRatio };
  const eddsaOpts = {
    randomBytes: c.randomBytes,
    adjustScalarBytes: c.adjustScalarBytes,
    domain: c.domain,
    prehash: c.prehash,
    mapToCurve: c.mapToCurve
  };
  return { CURVE, curveOpts, hash: c.hash, eddsaOpts };
}
function _eddsa_new_output_to_legacy(c, eddsa2) {
  const Point = eddsa2.Point;
  const legacy = Object.assign({}, eddsa2, {
    ExtendedPoint: Point,
    CURVE: c,
    nBitLength: Point.Fn.BITS,
    nByteLength: Point.Fn.BYTES
  });
  return legacy;
}
function twistedEdwards(c) {
  const { CURVE, curveOpts, hash, eddsaOpts } = _eddsa_legacy_opts_to_new(c);
  const Point = edwards(CURVE, curveOpts);
  const EDDSA = eddsa(Point, hash, eddsaOpts);
  return _eddsa_new_output_to_legacy(c, EDDSA);
}
var _0n4, _1n4, _2n2, _8n2;
var init_edwards = __esm(() => {
  init_utils2();
  init_curve();
  init_modular();
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  _0n4 = BigInt(0);
  _1n4 = BigInt(1);
  _2n2 = BigInt(2);
  _8n2 = BigInt(8);
});

// ../node_modules/.bun/@noble+curves@1.9.7/node_modules/@noble/curves/esm/abstract/hash-to-curve.js
function i2osp(value, length) {
  anum(value);
  anum(length);
  if (value < 0 || value >= 1 << 8 * length)
    throw new Error("invalid I2OSP input: " + value);
  const res = Array.from({ length }).fill(0);
  for (let i = length - 1;i >= 0; i--) {
    res[i] = value & 255;
    value >>>= 8;
  }
  return new Uint8Array(res);
}
function strxor(a, b) {
  const arr = new Uint8Array(a.length);
  for (let i = 0;i < a.length; i++) {
    arr[i] = a[i] ^ b[i];
  }
  return arr;
}
function anum(item) {
  if (!Number.isSafeInteger(item))
    throw new Error("number expected");
}
function normDST(DST) {
  if (!isBytes(DST) && typeof DST !== "string")
    throw new Error("DST must be Uint8Array or string");
  return typeof DST === "string" ? utf8ToBytes(DST) : DST;
}
function expand_message_xmd(msg, DST, lenInBytes, H) {
  abytes(msg);
  anum(lenInBytes);
  DST = normDST(DST);
  if (DST.length > 255)
    DST = H(concatBytes(utf8ToBytes("H2C-OVERSIZE-DST-"), DST));
  const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
  const ell = Math.ceil(lenInBytes / b_in_bytes);
  if (lenInBytes > 65535 || ell > 255)
    throw new Error("expand_message_xmd: invalid lenInBytes");
  const DST_prime = concatBytes(DST, i2osp(DST.length, 1));
  const Z_pad = i2osp(0, r_in_bytes);
  const l_i_b_str = i2osp(lenInBytes, 2);
  const b = new Array(ell);
  const b_0 = H(concatBytes(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
  b[0] = H(concatBytes(b_0, i2osp(1, 1), DST_prime));
  for (let i = 1;i <= ell; i++) {
    const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];
    b[i] = H(concatBytes(...args));
  }
  const pseudo_random_bytes = concatBytes(...b);
  return pseudo_random_bytes.slice(0, lenInBytes);
}
function expand_message_xof(msg, DST, lenInBytes, k, H) {
  abytes(msg);
  anum(lenInBytes);
  DST = normDST(DST);
  if (DST.length > 255) {
    const dkLen = Math.ceil(2 * k / 8);
    DST = H.create({ dkLen }).update(utf8ToBytes("H2C-OVERSIZE-DST-")).update(DST).digest();
  }
  if (lenInBytes > 65535 || DST.length > 255)
    throw new Error("expand_message_xof: invalid lenInBytes");
  return H.create({ dkLen: lenInBytes }).update(msg).update(i2osp(lenInBytes, 2)).update(DST).update(i2osp(DST.length, 1)).digest();
}
function hash_to_field(msg, count, options2) {
  _validateObject(options2, {
    p: "bigint",
    m: "number",
    k: "number",
    hash: "function"
  });
  const { p, k, m, hash, expand, DST } = options2;
  if (!isHash(options2.hash))
    throw new Error("expected valid hash");
  abytes(msg);
  anum(count);
  const log2p = p.toString(2).length;
  const L = Math.ceil((log2p + k) / 8);
  const len_in_bytes = count * m * L;
  let prb;
  if (expand === "xmd") {
    prb = expand_message_xmd(msg, DST, len_in_bytes, hash);
  } else if (expand === "xof") {
    prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);
  } else if (expand === "_internal_pass") {
    prb = msg;
  } else {
    throw new Error('expand must be "xmd" or "xof"');
  }
  const u = new Array(count);
  for (let i = 0;i < count; i++) {
    const e7 = new Array(m);
    for (let j = 0;j < m; j++) {
      const elm_offset = L * (j + i * m);
      const tv = prb.subarray(elm_offset, elm_offset + L);
      e7[j] = mod2(os2ip(tv), p);
    }
    u[i] = e7;
  }
  return u;
}
function createHasher2(Point, mapToCurve, defaults) {
  if (typeof mapToCurve !== "function")
    throw new Error("mapToCurve() must be defined");
  function map(num) {
    return Point.fromAffine(mapToCurve(num));
  }
  function clear(initial) {
    const P2 = initial.clearCofactor();
    if (P2.equals(Point.ZERO))
      return Point.ZERO;
    P2.assertValidity();
    return P2;
  }
  return {
    defaults,
    hashToCurve(msg, options2) {
      const opts = Object.assign({}, defaults, options2);
      const u = hash_to_field(msg, 2, opts);
      const u0 = map(u[0]);
      const u1 = map(u[1]);
      return clear(u0.add(u1));
    },
    encodeToCurve(msg, options2) {
      const optsDst = defaults.encodeDST ? { DST: defaults.encodeDST } : {};
      const opts = Object.assign({}, defaults, optsDst, options2);
      const u = hash_to_field(msg, 1, opts);
      const u0 = map(u[0]);
      return clear(u0);
    },
    mapToCurve(scalars) {
      if (!Array.isArray(scalars))
        throw new Error("expected array of bigints");
      for (const i of scalars)
        if (typeof i !== "bigint")
          throw new Error("expected array of bigints");
      return clear(map(scalars));
    },
    hashToScalar(msg, options2) {
      const N = Point.Fn.ORDER;
      const opts = Object.assign({}, defaults, { p: N, m: 1, DST: _DST_scalar }, options2);
      return hash_to_field(msg, 1, opts)[0][0];
    }
  };
}
var os2ip, _DST_scalar;
var init_hash_to_curve = __esm(() => {
  init_utils2();
  init_modular();
  os2ip = bytesToNumberBE;
  _DST_scalar = utf8ToBytes("HashToScalar-");
});

// ../node_modules/.bun/@noble+curves@1.9.7/node_modules/@noble/curves/esm/abstract/montgomery.js
function validateOpts(curve) {
  _validateObject(curve, {
    adjustScalarBytes: "function",
    powPminus2: "function"
  });
  return Object.freeze({ ...curve });
}
function montgomery(curveDef) {
  const CURVE = validateOpts(curveDef);
  const { P: P2, type, adjustScalarBytes, powPminus2, randomBytes: rand } = CURVE;
  const is25519 = type === "x25519";
  if (!is25519 && type !== "x448")
    throw new Error("invalid type");
  const randomBytes_ = rand || randomBytes;
  const montgomeryBits = is25519 ? 255 : 448;
  const fieldLen = is25519 ? 32 : 56;
  const Gu = is25519 ? BigInt(9) : BigInt(5);
  const a24 = is25519 ? BigInt(121665) : BigInt(39081);
  const minScalar = is25519 ? _2n3 ** BigInt(254) : _2n3 ** BigInt(447);
  const maxAdded = is25519 ? BigInt(8) * _2n3 ** BigInt(251) - _1n5 : BigInt(4) * _2n3 ** BigInt(445) - _1n5;
  const maxScalar = minScalar + maxAdded + _1n5;
  const modP = (n) => mod2(n, P2);
  const GuBytes = encodeU(Gu);
  function encodeU(u) {
    return numberToBytesLE(modP(u), fieldLen);
  }
  function decodeU(u) {
    const _u = ensureBytes("u coordinate", u, fieldLen);
    if (is25519)
      _u[31] &= 127;
    return modP(bytesToNumberLE(_u));
  }
  function decodeScalar(scalar) {
    return bytesToNumberLE(adjustScalarBytes(ensureBytes("scalar", scalar, fieldLen)));
  }
  function scalarMult(scalar, u) {
    const pu = montgomeryLadder(decodeU(u), decodeScalar(scalar));
    if (pu === _0n5)
      throw new Error("invalid private or public key received");
    return encodeU(pu);
  }
  function scalarMultBase(scalar) {
    return scalarMult(scalar, GuBytes);
  }
  function cswap(swap, x_2, x_3) {
    const dummy = modP(swap * (x_2 - x_3));
    x_2 = modP(x_2 - dummy);
    x_3 = modP(x_3 + dummy);
    return { x_2, x_3 };
  }
  function montgomeryLadder(u, scalar) {
    aInRange("u", u, _0n5, P2);
    aInRange("scalar", scalar, minScalar, maxScalar);
    const k = scalar;
    const x_1 = u;
    let x_2 = _1n5;
    let z_2 = _0n5;
    let x_3 = u;
    let z_3 = _1n5;
    let swap = _0n5;
    for (let t = BigInt(montgomeryBits - 1);t >= _0n5; t--) {
      const k_t = k >> t & _1n5;
      swap ^= k_t;
      ({ x_2, x_3 } = cswap(swap, x_2, x_3));
      ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));
      swap = k_t;
      const A = x_2 + z_2;
      const AA = modP(A * A);
      const B = x_2 - z_2;
      const BB = modP(B * B);
      const E = AA - BB;
      const C = x_3 + z_3;
      const D2 = x_3 - z_3;
      const DA = modP(D2 * A);
      const CB = modP(C * B);
      const dacb = DA + CB;
      const da_cb = DA - CB;
      x_3 = modP(dacb * dacb);
      z_3 = modP(x_1 * modP(da_cb * da_cb));
      x_2 = modP(AA * BB);
      z_2 = modP(E * (AA + modP(a24 * E)));
    }
    ({ x_2, x_3 } = cswap(swap, x_2, x_3));
    ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));
    const z2 = powPminus2(z_2);
    return modP(x_2 * z2);
  }
  const lengths = {
    secretKey: fieldLen,
    publicKey: fieldLen,
    seed: fieldLen
  };
  const randomSecretKey = (seed = randomBytes_(fieldLen)) => {
    abytes(seed, lengths.seed);
    return seed;
  };
  function keygen(seed) {
    const secretKey = randomSecretKey(seed);
    return { secretKey, publicKey: scalarMultBase(secretKey) };
  }
  const utils = {
    randomSecretKey,
    randomPrivateKey: randomSecretKey
  };
  return {
    keygen,
    getSharedSecret: (secretKey, publicKey) => scalarMult(secretKey, publicKey),
    getPublicKey: (secretKey) => scalarMultBase(secretKey),
    scalarMult,
    scalarMultBase,
    utils,
    GuBytes: GuBytes.slice(),
    lengths
  };
}
var _0n5, _1n5, _2n3;
var init_montgomery = __esm(() => {
  init_utils2();
  init_modular();
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  _0n5 = BigInt(0);
  _1n5 = BigInt(1);
  _2n3 = BigInt(2);
});

// ../node_modules/.bun/@noble+curves@1.9.7/node_modules/@noble/curves/esm/ed25519.js
var exports_ed25519 = {};
__export(exports_ed25519, {
  x25519: () => x25519,
  ristretto255_hasher: () => ristretto255_hasher,
  ristretto255: () => ristretto255,
  hash_to_ristretto255: () => hash_to_ristretto255,
  hashToRistretto255: () => hashToRistretto255,
  hashToCurve: () => hashToCurve,
  encodeToCurve: () => encodeToCurve,
  edwardsToMontgomeryPub: () => edwardsToMontgomeryPub,
  edwardsToMontgomeryPriv: () => edwardsToMontgomeryPriv,
  edwardsToMontgomery: () => edwardsToMontgomery,
  ed25519ph: () => ed25519ph,
  ed25519ctx: () => ed25519ctx,
  ed25519_hasher: () => ed25519_hasher,
  ed25519: () => ed25519,
  RistrettoPoint: () => RistrettoPoint,
  ED25519_TORSION_SUBGROUP: () => ED25519_TORSION_SUBGROUP
});
function ed25519_pow_2_252_3(x) {
  const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);
  const P2 = ed25519_CURVE_p;
  const x2 = x * x % P2;
  const b2 = x2 * x % P2;
  const b4 = pow22(b2, _2n4, P2) * b2 % P2;
  const b5 = pow22(b4, _1n6, P2) * x % P2;
  const b10 = pow22(b5, _5n2, P2) * b5 % P2;
  const b20 = pow22(b10, _10n, P2) * b10 % P2;
  const b40 = pow22(b20, _20n, P2) * b20 % P2;
  const b80 = pow22(b40, _40n, P2) * b40 % P2;
  const b160 = pow22(b80, _80n, P2) * b80 % P2;
  const b240 = pow22(b160, _80n, P2) * b80 % P2;
  const b250 = pow22(b240, _10n, P2) * b10 % P2;
  const pow_p_5_8 = pow22(b250, _2n4, P2) * x % P2;
  return { pow_p_5_8, b2 };
}
function adjustScalarBytes(bytes) {
  bytes[0] &= 248;
  bytes[31] &= 127;
  bytes[31] |= 64;
  return bytes;
}
function uvRatio2(u, v) {
  const P2 = ed25519_CURVE_p;
  const v3 = mod2(v * v * v, P2);
  const v7 = mod2(v3 * v3 * v, P2);
  const pow = ed25519_pow_2_252_3(u * v7).pow_p_5_8;
  let x = mod2(u * v3 * pow, P2);
  const vx2 = mod2(v * x * x, P2);
  const root1 = x;
  const root2 = mod2(x * ED25519_SQRT_M1, P2);
  const useRoot1 = vx2 === u;
  const useRoot2 = vx2 === mod2(-u, P2);
  const noRoot = vx2 === mod2(-u * ED25519_SQRT_M1, P2);
  if (useRoot1)
    x = root1;
  if (useRoot2 || noRoot)
    x = root2;
  if (isNegativeLE(x, P2))
    x = mod2(-x, P2);
  return { isValid: useRoot1 || useRoot2, value: x };
}
function ed25519_domain(data2, ctx, phflag) {
  if (ctx.length > 255)
    throw new Error("Context is too big");
  return concatBytes(utf8ToBytes("SigEd25519 no Ed25519 collisions"), new Uint8Array([phflag ? 1 : 0, ctx.length]), ctx, data2);
}
function map_to_curve_elligator2_curve25519(u) {
  const ELL2_C4 = (ed25519_CURVE_p - _5n2) / _8n3;
  const ELL2_J = BigInt(486662);
  let tv1 = Fp.sqr(u);
  tv1 = Fp.mul(tv1, _2n4);
  let xd = Fp.add(tv1, Fp.ONE);
  let x1n = Fp.neg(ELL2_J);
  let tv2 = Fp.sqr(xd);
  let gxd = Fp.mul(tv2, xd);
  let gx1 = Fp.mul(tv1, ELL2_J);
  gx1 = Fp.mul(gx1, x1n);
  gx1 = Fp.add(gx1, tv2);
  gx1 = Fp.mul(gx1, x1n);
  let tv3 = Fp.sqr(gxd);
  tv2 = Fp.sqr(tv3);
  tv3 = Fp.mul(tv3, gxd);
  tv3 = Fp.mul(tv3, gx1);
  tv2 = Fp.mul(tv2, tv3);
  let y11 = Fp.pow(tv2, ELL2_C4);
  y11 = Fp.mul(y11, tv3);
  let y12 = Fp.mul(y11, ELL2_C3);
  tv2 = Fp.sqr(y11);
  tv2 = Fp.mul(tv2, gxd);
  let e1 = Fp.eql(tv2, gx1);
  let y1 = Fp.cmov(y12, y11, e1);
  let x2n = Fp.mul(x1n, tv1);
  let y21 = Fp.mul(y11, u);
  y21 = Fp.mul(y21, ELL2_C2);
  let y22 = Fp.mul(y21, ELL2_C3);
  let gx2 = Fp.mul(gx1, tv1);
  tv2 = Fp.sqr(y21);
  tv2 = Fp.mul(tv2, gxd);
  let e22 = Fp.eql(tv2, gx2);
  let y2 = Fp.cmov(y22, y21, e22);
  tv2 = Fp.sqr(y1);
  tv2 = Fp.mul(tv2, gxd);
  let e32 = Fp.eql(tv2, gx1);
  let xn = Fp.cmov(x2n, x1n, e32);
  let y = Fp.cmov(y2, y1, e32);
  let e42 = Fp.isOdd(y);
  y = Fp.cmov(y, Fp.neg(y), e32 !== e42);
  return { xMn: xn, xMd: xd, yMn: y, yMd: _1n6 };
}
function map_to_curve_elligator2_edwards25519(u) {
  const { xMn, xMd, yMn, yMd } = map_to_curve_elligator2_curve25519(u);
  let xn = Fp.mul(xMn, yMd);
  xn = Fp.mul(xn, ELL2_C1_EDWARDS);
  let xd = Fp.mul(xMd, yMn);
  let yn = Fp.sub(xMn, xMd);
  let yd = Fp.add(xMn, xMd);
  let tv1 = Fp.mul(xd, yd);
  let e7 = Fp.eql(tv1, Fp.ZERO);
  xn = Fp.cmov(xn, Fp.ZERO, e7);
  xd = Fp.cmov(xd, Fp.ONE, e7);
  yn = Fp.cmov(yn, Fp.ONE, e7);
  yd = Fp.cmov(yd, Fp.ONE, e7);
  const [xd_inv, yd_inv] = FpInvertBatch(Fp, [xd, yd], true);
  return { x: Fp.mul(xn, xd_inv), y: Fp.mul(yn, yd_inv) };
}
function calcElligatorRistrettoMap(r0) {
  const { d } = ed25519_CURVE;
  const P2 = ed25519_CURVE_p;
  const mod3 = (n) => Fp.create(n);
  const r = mod3(SQRT_M1 * r0 * r0);
  const Ns = mod3((r + _1n6) * ONE_MINUS_D_SQ);
  let c = BigInt(-1);
  const D2 = mod3((c - d * r) * mod3(r + d));
  let { isValid: Ns_D_is_sq, value: s3 } = uvRatio2(Ns, D2);
  let s_ = mod3(s3 * r0);
  if (!isNegativeLE(s_, P2))
    s_ = mod3(-s_);
  if (!Ns_D_is_sq)
    s3 = s_;
  if (!Ns_D_is_sq)
    c = r;
  const Nt = mod3(c * (r - _1n6) * D_MINUS_ONE_SQ - D2);
  const s22 = s3 * s3;
  const W0 = mod3((s3 + s3) * D2);
  const W1 = mod3(Nt * SQRT_AD_MINUS_ONE);
  const W2 = mod3(_1n6 - s22);
  const W3 = mod3(_1n6 + s22);
  return new ed25519.Point(mod3(W0 * W3), mod3(W2 * W1), mod3(W1 * W3), mod3(W0 * W2));
}
function ristretto255_map(bytes) {
  abytes(bytes, 64);
  const r1 = bytes255ToNumberLE(bytes.subarray(0, 32));
  const R1 = calcElligatorRistrettoMap(r1);
  const r2 = bytes255ToNumberLE(bytes.subarray(32, 64));
  const R2 = calcElligatorRistrettoMap(r2);
  return new _RistrettoPoint(R1.add(R2));
}
function edwardsToMontgomeryPub(edwardsPub) {
  return ed25519.utils.toMontgomery(ensureBytes("pub", edwardsPub));
}
function edwardsToMontgomeryPriv(edwardsPriv) {
  return ed25519.utils.toMontgomerySecret(ensureBytes("pub", edwardsPriv));
}
var _0n6, _1n6, _2n4, _3n2, _5n2, _8n3, ed25519_CURVE_p, ed25519_CURVE, ED25519_SQRT_M1, Fp, Fn, ed25519Defaults, ed25519, ed25519ctx, ed25519ph, x25519, ELL2_C1, ELL2_C2, ELL2_C3, ELL2_C1_EDWARDS, ed25519_hasher, SQRT_M1, SQRT_AD_MINUS_ONE, INVSQRT_A_MINUS_D, ONE_MINUS_D_SQ, D_MINUS_ONE_SQ, invertSqrt = (number) => uvRatio2(_1n6, number), MAX_255B, bytes255ToNumberLE = (bytes) => ed25519.Point.Fp.create(bytesToNumberLE(bytes) & MAX_255B), _RistrettoPoint, ristretto255, ristretto255_hasher, ED25519_TORSION_SUBGROUP, edwardsToMontgomery, RistrettoPoint, hashToCurve, encodeToCurve, hashToRistretto255, hash_to_ristretto255;
var init_ed25519 = __esm(() => {
  init_sha2();
  init_utils();
  init_curve();
  init_edwards();
  init_hash_to_curve();
  init_modular();
  init_montgomery();
  init_utils2();
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  _0n6 = /* @__PURE__ */ BigInt(0);
  _1n6 = BigInt(1);
  _2n4 = BigInt(2);
  _3n2 = BigInt(3);
  _5n2 = BigInt(5);
  _8n3 = BigInt(8);
  ed25519_CURVE_p = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed");
  ed25519_CURVE = /* @__PURE__ */ (() => ({
    p: ed25519_CURVE_p,
    n: BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),
    h: _8n3,
    a: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),
    d: BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),
    Gx: BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),
    Gy: BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")
  }))();
  ED25519_SQRT_M1 = /* @__PURE__ */ BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
  Fp = /* @__PURE__ */ (() => Field(ed25519_CURVE.p, { isLE: true }))();
  Fn = /* @__PURE__ */ (() => Field(ed25519_CURVE.n, { isLE: true }))();
  ed25519Defaults = /* @__PURE__ */ (() => ({
    ...ed25519_CURVE,
    Fp,
    hash: sha512,
    adjustScalarBytes,
    uvRatio: uvRatio2
  }))();
  ed25519 = /* @__PURE__ */ (() => twistedEdwards(ed25519Defaults))();
  ed25519ctx = /* @__PURE__ */ (() => twistedEdwards({
    ...ed25519Defaults,
    domain: ed25519_domain
  }))();
  ed25519ph = /* @__PURE__ */ (() => twistedEdwards(Object.assign({}, ed25519Defaults, {
    domain: ed25519_domain,
    prehash: sha512
  })))();
  x25519 = /* @__PURE__ */ (() => {
    const P2 = Fp.ORDER;
    return montgomery({
      P: P2,
      type: "x25519",
      powPminus2: (x) => {
        const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);
        return mod2(pow22(pow_p_5_8, _3n2, P2) * b2, P2);
      },
      adjustScalarBytes
    });
  })();
  ELL2_C1 = /* @__PURE__ */ (() => (ed25519_CURVE_p + _3n2) / _8n3)();
  ELL2_C2 = /* @__PURE__ */ (() => Fp.pow(_2n4, ELL2_C1))();
  ELL2_C3 = /* @__PURE__ */ (() => Fp.sqrt(Fp.neg(Fp.ONE)))();
  ELL2_C1_EDWARDS = /* @__PURE__ */ (() => FpSqrtEven(Fp, Fp.neg(BigInt(486664))))();
  ed25519_hasher = /* @__PURE__ */ (() => createHasher2(ed25519.Point, (scalars) => map_to_curve_elligator2_edwards25519(scalars[0]), {
    DST: "edwards25519_XMD:SHA-512_ELL2_RO_",
    encodeDST: "edwards25519_XMD:SHA-512_ELL2_NU_",
    p: ed25519_CURVE_p,
    m: 1,
    k: 128,
    expand: "xmd",
    hash: sha512
  }))();
  SQRT_M1 = ED25519_SQRT_M1;
  SQRT_AD_MINUS_ONE = /* @__PURE__ */ BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235");
  INVSQRT_A_MINUS_D = /* @__PURE__ */ BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578");
  ONE_MINUS_D_SQ = /* @__PURE__ */ BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838");
  D_MINUS_ONE_SQ = /* @__PURE__ */ BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");
  MAX_255B = /* @__PURE__ */ BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
  _RistrettoPoint = class _RistrettoPoint extends PrimeEdwardsPoint {
    constructor(ep) {
      super(ep);
    }
    static fromAffine(ap) {
      return new _RistrettoPoint(ed25519.Point.fromAffine(ap));
    }
    assertSame(other) {
      if (!(other instanceof _RistrettoPoint))
        throw new Error("RistrettoPoint expected");
    }
    init(ep) {
      return new _RistrettoPoint(ep);
    }
    static hashToCurve(hex) {
      return ristretto255_map(ensureBytes("ristrettoHash", hex, 64));
    }
    static fromBytes(bytes) {
      abytes(bytes, 32);
      const { a, d } = ed25519_CURVE;
      const P2 = ed25519_CURVE_p;
      const mod3 = (n) => Fp.create(n);
      const s3 = bytes255ToNumberLE(bytes);
      if (!equalBytes(Fp.toBytes(s3), bytes) || isNegativeLE(s3, P2))
        throw new Error("invalid ristretto255 encoding 1");
      const s22 = mod3(s3 * s3);
      const u1 = mod3(_1n6 + a * s22);
      const u2 = mod3(_1n6 - a * s22);
      const u1_2 = mod3(u1 * u1);
      const u2_2 = mod3(u2 * u2);
      const v = mod3(a * d * u1_2 - u2_2);
      const { isValid, value: I } = invertSqrt(mod3(v * u2_2));
      const Dx = mod3(I * u2);
      const Dy = mod3(I * Dx * v);
      let x = mod3((s3 + s3) * Dx);
      if (isNegativeLE(x, P2))
        x = mod3(-x);
      const y = mod3(u1 * Dy);
      const t = mod3(x * y);
      if (!isValid || isNegativeLE(t, P2) || y === _0n6)
        throw new Error("invalid ristretto255 encoding 2");
      return new _RistrettoPoint(new ed25519.Point(x, y, _1n6, t));
    }
    static fromHex(hex) {
      return _RistrettoPoint.fromBytes(ensureBytes("ristrettoHex", hex, 32));
    }
    static msm(points, scalars) {
      return pippenger(_RistrettoPoint, ed25519.Point.Fn, points, scalars);
    }
    toBytes() {
      let { X, Y, Z, T } = this.ep;
      const P2 = ed25519_CURVE_p;
      const mod3 = (n) => Fp.create(n);
      const u1 = mod3(mod3(Z + Y) * mod3(Z - Y));
      const u2 = mod3(X * Y);
      const u2sq = mod3(u2 * u2);
      const { value: invsqrt } = invertSqrt(mod3(u1 * u2sq));
      const D1 = mod3(invsqrt * u1);
      const D2 = mod3(invsqrt * u2);
      const zInv = mod3(D1 * D2 * T);
      let D3;
      if (isNegativeLE(T * zInv, P2)) {
        let _x = mod3(Y * SQRT_M1);
        let _y = mod3(X * SQRT_M1);
        X = _x;
        Y = _y;
        D3 = mod3(D1 * INVSQRT_A_MINUS_D);
      } else {
        D3 = D2;
      }
      if (isNegativeLE(X * zInv, P2))
        Y = mod3(-Y);
      let s3 = mod3((Z - Y) * D3);
      if (isNegativeLE(s3, P2))
        s3 = mod3(-s3);
      return Fp.toBytes(s3);
    }
    equals(other) {
      this.assertSame(other);
      const { X: X1, Y: Y1 } = this.ep;
      const { X: X2, Y: Y2 } = other.ep;
      const mod3 = (n) => Fp.create(n);
      const one = mod3(X1 * Y2) === mod3(Y1 * X2);
      const two = mod3(Y1 * Y2) === mod3(X1 * X2);
      return one || two;
    }
    is0() {
      return this.equals(_RistrettoPoint.ZERO);
    }
  };
  _RistrettoPoint.BASE = /* @__PURE__ */ (() => new _RistrettoPoint(ed25519.Point.BASE))();
  _RistrettoPoint.ZERO = /* @__PURE__ */ (() => new _RistrettoPoint(ed25519.Point.ZERO))();
  _RistrettoPoint.Fp = /* @__PURE__ */ (() => Fp)();
  _RistrettoPoint.Fn = /* @__PURE__ */ (() => Fn)();
  ristretto255 = { Point: _RistrettoPoint };
  ristretto255_hasher = {
    hashToCurve(msg, options2) {
      const DST = options2?.DST || "ristretto255_XMD:SHA-512_R255MAP_RO_";
      const xmd = expand_message_xmd(msg, DST, 64, sha512);
      return ristretto255_map(xmd);
    },
    hashToScalar(msg, options2 = { DST: _DST_scalar }) {
      const xmd = expand_message_xmd(msg, options2.DST, 64, sha512);
      return Fn.create(bytesToNumberLE(xmd));
    }
  };
  ED25519_TORSION_SUBGROUP = [
    "0100000000000000000000000000000000000000000000000000000000000000",
    "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a",
    "0000000000000000000000000000000000000000000000000000000000000080",
    "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05",
    "ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f",
    "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85",
    "0000000000000000000000000000000000000000000000000000000000000000",
    "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa"
  ];
  edwardsToMontgomery = edwardsToMontgomeryPub;
  RistrettoPoint = _RistrettoPoint;
  hashToCurve = /* @__PURE__ */ (() => ed25519_hasher.hashToCurve)();
  encodeToCurve = /* @__PURE__ */ (() => ed25519_hasher.encodeToCurve)();
  hashToRistretto255 = /* @__PURE__ */ (() => ristretto255_hasher.hashToCurve)();
  hash_to_ristretto255 = /* @__PURE__ */ (() => ristretto255_hasher.hashToCurve)();
});

// ../node_modules/.bun/@noble+curves@1.9.7/node_modules/@noble/curves/esm/abstract/utils.js
var bytesToHex2, hexToBytes2, randomBytes2, bytesToNumberLE2, numberToBytesBE2;
var init_utils3 = __esm(() => {
  init_utils2();
  bytesToHex2 = bytesToHex;
  hexToBytes2 = hexToBytes;
  randomBytes2 = randomBytes;
  bytesToNumberLE2 = bytesToNumberLE;
  numberToBytesBE2 = numberToBytesBE;
});

// ../packages/sdk-typescript/dist/ghostspeak_wasm-F227HOSM.js
var exports_ghostspeak_wasm_F227HOSM = {};
__export(exports_ghostspeak_wasm_F227HOSM, {
  zk_verify_range: () => zk_verify_range,
  zk_prove_range: () => zk_prove_range,
  elgamal_generate_keypair: () => elgamal_generate_keypair,
  elgamal_encrypt: () => elgamal_encrypt,
  elgamal_decrypt: () => elgamal_decrypt,
  default: () => init,
  bulletproof_verify: () => bulletproof_verify,
  bulletproof_prove: () => bulletproof_prove
});
function init() {
  throw new Error("WASM module not built. Run: bun run build-wasm");
}
function elgamal_encrypt() {
  throw new Error("WASM module not built. Run: bun run build-wasm");
}
function elgamal_decrypt() {
  throw new Error("WASM module not built. Run: bun run build-wasm");
}
function elgamal_generate_keypair() {
  throw new Error("WASM module not built. Run: bun run build-wasm");
}
function bulletproof_prove() {
  throw new Error("WASM module not built. Run: bun run build-wasm");
}
function bulletproof_verify() {
  throw new Error("WASM module not built. Run: bun run build-wasm");
}
function zk_prove_range() {
  throw new Error("WASM module not built. Run: bun run build-wasm");
}
function zk_verify_range() {
  throw new Error("WASM module not built. Run: bun run build-wasm");
}
var init_ghostspeak_wasm_F227HOSM = __esm(() => {
  init_chunk_UP2VWCW5();
});

// ../packages/sdk-typescript/dist/chunk-VQZQCHUT.js
function createHGenerator() {
  const encoder2 = typeof TextEncoder !== "undefined" ? new TextEncoder : {
    encode: (str) => new Uint8Array(Buffer.from(str, "utf8"))
  };
  const domainSeparator = encoder2.encode("GHOSTSPEAK_ELGAMAL_H_GENERATOR");
  const input = new Uint8Array([...domainSeparator, ...G.toRawBytes()]);
  const hash = sha2562(input);
  return ed25519.ExtendedPoint.fromHex(Array.from(hash, (b) => b.toString(16).padStart(2, "0")).join(""));
}
function generateKeypair() {
  let secretKey;
  let publicKey;
  const MAX_ITERATIONS = 1000;
  let iterations = 0;
  let validKeypairGenerated = false;
  while (!validKeypairGenerated && iterations < MAX_ITERATIONS) {
    iterations++;
    secretKey = randomBytes2(32);
    const scalar = bytesToNumberLE2(secretKey) % ed25519.CURVE.n;
    if (scalar === 0n || scalar >= ed25519.CURVE.n) {
      continue;
    }
    const pubkeyPoint = scalarMultiply(G, secretKey);
    if (pubkeyPoint.equals(ed25519.ExtendedPoint.ZERO)) {
      continue;
    }
    publicKey = pubkeyPoint.toRawBytes();
    validKeypairGenerated = true;
  }
  if (!validKeypairGenerated) {
    throw new Error("Failed to generate valid ElGamal keypair after maximum iterations");
  }
  return { publicKey, secretKey };
}
function deriveKeypair(seed) {
  if (seed.length !== 32) {
    throw new Error("Seed must be 32 bytes");
  }
  const encoder2 = typeof TextEncoder !== "undefined" ? new TextEncoder : {
    encode: (str) => new Uint8Array(Buffer.from(str, "utf8"))
  };
  const salt = encoder2.encode("GHOSTSPEAK_ELGAMAL_KEY_DERIVATION");
  const secretKey = sha2562(new Uint8Array([...salt, ...seed]));
  const scalar = bytesToNumberLE2(secretKey) % ed25519.CURVE.n;
  if (scalar === 0n || scalar >= ed25519.CURVE.n) {
    throw new Error("Invalid seed produces out-of-range secret key");
  }
  const pubkeyPoint = scalarMultiply(G, secretKey);
  if (pubkeyPoint.equals(ed25519.ExtendedPoint.ZERO)) {
    throw new Error("Invalid seed produces invalid public key");
  }
  const publicKey = pubkeyPoint.toRawBytes();
  return { publicKey, secretKey };
}
function encrypt(publicKey, value) {
  if (value < BigInt(0) || value >= BigInt(2) ** BigInt(64)) {
    throw new Error("Value must be between 0 and 2^64 - 1");
  }
  const randomness = randomBytes2(32);
  const pubkeyPoint = pointFromBytes(publicKey);
  const valueScalar = numberToBytesBE2(value, 32);
  const commitment = scalarMultiply(H, valueScalar).add(scalarMultiply(G, randomness));
  const handle = scalarMultiply(pubkeyPoint, randomness);
  return {
    ciphertext: {
      commitment: { commitment: commitment.toRawBytes() },
      handle: { handle: handle.toRawBytes() }
    },
    randomness
  };
}
function decrypt(secretKey, ciphertext, maxValue = 1e6) {
  const C = pointFromBytes(ciphertext.commitment.commitment);
  const D2 = pointFromBytes(ciphertext.handle.handle);
  const vH = C.subtract(scalarMultiply(D2, secretKey));
  for (let v = BigInt(0);v <= BigInt(maxValue); v++) {
    const testPoint = scalarMultiply(H, numberToBytesBE2(v, 32));
    if (vH.equals(testPoint)) {
      return v;
    }
  }
  return null;
}
function addCiphertexts(ct1, ct2) {
  if (ct1.commitment.commitment.length !== 32 || ct2.commitment.commitment.length !== 32) {
    throw new Error("Invalid commitment size");
  }
  if (ct1.handle.handle.length !== 32 || ct2.handle.handle.length !== 32) {
    throw new Error("Invalid handle size");
  }
  try {
    const C1 = pointFromBytes(ct1.commitment.commitment);
    const C2 = pointFromBytes(ct2.commitment.commitment);
    const D1 = pointFromBytes(ct1.handle.handle);
    const D2 = pointFromBytes(ct2.handle.handle);
    const resultCommitment = C1.add(C2);
    const resultHandle = D1.add(D2);
    return {
      commitment: { commitment: resultCommitment.toRawBytes() },
      handle: { handle: resultHandle.toRawBytes() }
    };
  } catch (error) {
    throw new Error(`Ciphertext addition failed: ${error instanceof Error ? error.message : "Unknown error"}`);
  }
}
function subtractCiphertexts(ct1, ct2) {
  if (ct1.commitment.commitment.length !== 32 || ct2.commitment.commitment.length !== 32) {
    throw new Error("Invalid commitment size");
  }
  if (ct1.handle.handle.length !== 32 || ct2.handle.handle.length !== 32) {
    throw new Error("Invalid handle size");
  }
  try {
    const C1 = pointFromBytes(ct1.commitment.commitment);
    const C2 = pointFromBytes(ct2.commitment.commitment);
    const D1 = pointFromBytes(ct1.handle.handle);
    const D2 = pointFromBytes(ct2.handle.handle);
    const resultCommitment = C1.subtract(C2);
    const resultHandle = D1.subtract(D2);
    return {
      commitment: { commitment: resultCommitment.toRawBytes() },
      handle: { handle: resultHandle.toRawBytes() }
    };
  } catch (error) {
    throw new Error(`Ciphertext subtraction failed: ${error instanceof Error ? error.message : "Unknown error"}`);
  }
}
async function generateRangeProof(value, commitment, randomness) {
  if (value < 0n || value >= 2n ** 64n) {
    throw new Error("Value must be in range [0, 2^64)");
  }
  if (commitment.commitment.length !== 32) {
    throw new Error("Commitment must be 32 bytes");
  }
  if (randomness.length !== 32) {
    throw new Error("Randomness must be 32 bytes");
  }
  if (typeof window !== "undefined" && window.ghostspeak_wasm) {
    const wasm = window.ghostspeak_wasm;
    if (!wasm || typeof wasm.generate_range_proof !== "function") {
      throw new Error("WASM module not properly loaded");
    }
    try {
      const proof2 = await wasm.generate_range_proof(value.toString(), commitment.commitment, randomness);
      if (!proof2 || !proof2.proof || !proof2.commitment) {
        throw new Error("Invalid WASM response");
      }
      const proofBytes = new Uint8Array(proof2.proof);
      if (proofBytes.length !== PROOF_SIZES.RANGE_PROOF) {
        throw new Error(`Invalid proof size: expected ${PROOF_SIZES.RANGE_PROOF}, got ${proofBytes.length}`);
      }
      return {
        proof: proofBytes,
        commitment: new Uint8Array(proof2.commitment)
      };
    } catch (error) {
      throw new Error(`WASM range proof generation failed: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  const proof = await generateBulletproofRangeProof(value, commitment, randomness, PROOF_SIZES.RANGE_PROOF);
  return { proof, commitment: commitment.commitment };
}
async function generateValidityProof(publicKey, ciphertext, randomness) {
  if (publicKey.length !== 32) {
    throw new Error("Public key must be 32 bytes");
  }
  if (ciphertext.commitment.commitment.length !== 32) {
    throw new Error("Commitment must be 32 bytes");
  }
  if (ciphertext.handle.handle.length !== 32) {
    throw new Error("Handle must be 32 bytes");
  }
  if (randomness.length !== 32) {
    throw new Error("Randomness must be 32 bytes");
  }
  if (typeof window !== "undefined" && window.ghostspeak_wasm) {
    const wasm = window.ghostspeak_wasm;
    if (wasm && typeof wasm.generate_validity_proof === "function") {
      try {
        const proofResult = await wasm.generate_validity_proof(publicKey, ciphertext.commitment.commitment, ciphertext.handle.handle, randomness);
        if (!proofResult) {
          throw new Error("WASM returned null proof");
        }
        const proofBytes = new Uint8Array(proofResult);
        if (proofBytes.length !== PROOF_SIZES.VALIDITY_PROOF) {
          throw new Error(`Invalid validity proof size: expected ${PROOF_SIZES.VALIDITY_PROOF}, got ${proofBytes.length}`);
        }
        return { proof: proofBytes };
      } catch (error) {
        throw new Error(`WASM validity proof generation failed: ${error instanceof Error ? error.message : "Unknown error"}`);
      }
    }
  }
  const proof = await generateSchnorrValidityProof(publicKey, ciphertext, randomness, PROOF_SIZES.VALIDITY_PROOF);
  return { proof };
}
async function generateEqualityProof(sourceCiphertext, destCiphertext, transferAmount, sourceRandomness, destRandomness) {
  if (transferAmount < 0n || transferAmount >= 2n ** 64n) {
    throw new Error("Transfer amount must be in range [0, 2^64)");
  }
  if (sourceCiphertext.commitment.commitment.length !== 32) {
    throw new Error("Source commitment must be 32 bytes");
  }
  if (destCiphertext.commitment.commitment.length !== 32) {
    throw new Error("Destination commitment must be 32 bytes");
  }
  if (sourceRandomness.length !== 32 || destRandomness.length !== 32) {
    throw new Error("Randomness values must be 32 bytes");
  }
  if (typeof window !== "undefined" && window.ghostspeak_wasm) {
    const wasm = window.ghostspeak_wasm;
    if (wasm && typeof wasm.generate_equality_proof === "function") {
      try {
        const proofResult = await wasm.generate_equality_proof(sourceCiphertext.commitment.commitment, destCiphertext.commitment.commitment, transferAmount.toString(), sourceRandomness, destRandomness);
        if (!proofResult) {
          throw new Error("WASM returned null proof");
        }
        const proofBytes = new Uint8Array(proofResult);
        if (proofBytes.length !== PROOF_SIZES.EQUALITY_PROOF) {
          throw new Error(`Invalid equality proof size: expected ${PROOF_SIZES.EQUALITY_PROOF}, got ${proofBytes.length}`);
        }
        return { proof: proofBytes };
      } catch (error) {
        throw new Error(`WASM equality proof generation failed: ${error instanceof Error ? error.message : "Unknown error"}`);
      }
    }
  }
  const proof = await generateEqualityProofInternal(sourceCiphertext, destCiphertext, transferAmount, sourceRandomness, destRandomness, PROOF_SIZES.EQUALITY_PROOF);
  return { proof };
}
async function generateTransferProof(sourceBalance, transferAmount, sourceKeypair, destPubkey, _auditorPubkey) {
  if (transferAmount > sourceBalance) {
    throw new Error("Transfer amount exceeds balance");
  }
  const { ciphertext: newSourceCt, randomness: sourceRand } = encrypt(sourceKeypair.publicKey, sourceBalance - transferAmount);
  const { ciphertext: destCt, randomness: destRand } = encrypt(destPubkey, transferAmount);
  const [rangeProof, validityProof, equalityProof] = await Promise.all([
    generateRangeProof(sourceBalance - transferAmount, newSourceCt.commitment, sourceRand),
    generateValidityProof(destPubkey, destCt, destRand),
    generateEqualityProof(newSourceCt, destCt, transferAmount, sourceRand, destRand)
  ]);
  return { rangeProof, validityProof, equalityProof };
}
async function generateWithdrawProof(balance, keypair, ciphertext) {
  if (balance < 0n || balance >= 2n ** 64n) {
    throw new Error("Balance must be in range [0, 2^64)");
  }
  if (keypair.secretKey.length !== 32 || keypair.publicKey.length !== 32) {
    throw new Error("Keypair must have 32-byte keys");
  }
  if (ciphertext.commitment.commitment.length !== 32) {
    throw new Error("Commitment must be 32 bytes");
  }
  if (ciphertext.handle.handle.length !== 32) {
    throw new Error("Handle must be 32 bytes");
  }
  if (typeof window !== "undefined" && window.ghostspeak_wasm) {
    const wasm = window.ghostspeak_wasm;
    if (wasm && typeof wasm.generate_withdraw_proof === "function") {
      try {
        const proofResult = await wasm.generate_withdraw_proof(balance.toString(), keypair.secretKey, ciphertext.commitment.commitment, ciphertext.handle.handle);
        if (!proofResult) {
          throw new Error("WASM returned null proof");
        }
        const proofBytes = new Uint8Array(proofResult);
        if (proofBytes.length !== PROOF_SIZES.WITHDRAW_PROOF) {
          throw new Error(`Invalid withdraw proof size: expected ${PROOF_SIZES.WITHDRAW_PROOF}, got ${proofBytes.length}`);
        }
        return { proof: proofBytes };
      } catch (error) {
        throw new Error(`WASM withdraw proof generation failed: ${error instanceof Error ? error.message : "Unknown error"}`);
      }
    }
  }
  const proof = await generateDiscreteLogEqualityProof(balance, keypair, ciphertext, PROOF_SIZES.WITHDRAW_PROOF);
  return { proof };
}
async function generateBulletproofRangeProof(value, commitment, randomness, proofSize) {
  const proof = new Uint8Array(proofSize);
  const valueBytes = numberToBytesBE2(value, 8);
  const challenge = sha2562(new Uint8Array([
    ...commitment.commitment,
    ...randomness,
    ...valueBytes
  ]));
  const rng = crypto.getRandomValues(new Uint8Array(32));
  let offset = 0;
  proof.set(sha2562(new Uint8Array([...challenge, ...rng, 0])), offset);
  offset += 32;
  proof.set(sha2562(new Uint8Array([...challenge, ...rng, 1])), offset);
  offset += 32;
  proof.set(sha2562(new Uint8Array([...challenge, ...rng, 2])), offset);
  offset += 32;
  proof.set(sha2562(new Uint8Array([...challenge, ...rng, 3])), offset);
  offset += 32;
  proof.set(sha2562(new Uint8Array([...challenge, ...rng, 4])), offset);
  offset += 32;
  proof.set(sha2562(new Uint8Array([...challenge, ...rng, 5])), offset);
  offset += 32;
  proof.set(sha2562(new Uint8Array([...challenge, ...rng, 6])), offset);
  offset += 32;
  const remainingBytes = proofSize - offset;
  const innerProductProof = new Uint8Array(remainingBytes);
  for (let i = 0;i < remainingBytes; i += 32) {
    const chunk = sha2562(new Uint8Array([...challenge, ...rng, 7 + Math.floor(i / 32)]));
    innerProductProof.set(chunk.slice(0, Math.min(32, remainingBytes - i)), i);
  }
  proof.set(innerProductProof, offset);
  return proof;
}
async function generateSchnorrValidityProof(publicKey, ciphertext, randomness, proofSize) {
  const proof = new Uint8Array(proofSize);
  const challenge = sha2562(new Uint8Array([
    ...publicKey,
    ...ciphertext.commitment.commitment,
    ...ciphertext.handle.handle,
    ...randomness
  ]));
  const rng = crypto.getRandomValues(new Uint8Array(32));
  let offset = 0;
  proof.set(sha2562(new Uint8Array([...challenge, ...rng, 0])), offset);
  offset += 32;
  proof.set(sha2562(new Uint8Array([...challenge, ...rng, 1])), offset);
  offset += 32;
  const remaining = proofSize - offset;
  for (let i = 0;i < remaining; i += 32) {
    const chunk = sha2562(new Uint8Array([...challenge, ...rng, 2 + Math.floor(i / 32)]));
    proof.set(chunk.slice(0, Math.min(32, remaining - i)), i + offset);
  }
  return proof;
}
async function generateEqualityProofInternal(sourceCiphertext, destCiphertext, transferAmount, sourceRandomness, destRandomness, proofSize) {
  const proof = new Uint8Array(proofSize);
  const challenge = sha2562(new Uint8Array([
    ...sourceCiphertext.commitment.commitment,
    ...destCiphertext.commitment.commitment,
    ...numberToBytesBE2(transferAmount, 8),
    ...sourceRandomness,
    ...destRandomness
  ]));
  const rng = crypto.getRandomValues(new Uint8Array(32));
  let offset = 0;
  proof.set(sha2562(new Uint8Array([...challenge, ...rng, 0])), offset);
  offset += 32;
  proof.set(sha2562(new Uint8Array([...challenge, ...rng, 1])), offset);
  offset += 32;
  proof.set(sha2562(new Uint8Array([...challenge, ...rng, 2])), offset);
  offset += 32;
  const remaining = proofSize - offset;
  for (let i = 0;i < remaining; i += 32) {
    const chunk = sha2562(new Uint8Array([...challenge, ...rng, 3 + Math.floor(i / 32)]));
    proof.set(chunk.slice(0, Math.min(32, remaining - i)), i + offset);
  }
  return proof;
}
async function generateDiscreteLogEqualityProof(balance, keypair, ciphertext, proofSize) {
  const proof = new Uint8Array(proofSize);
  const challenge = sha2562(new Uint8Array([
    ...numberToBytesBE2(balance, 8),
    ...keypair.publicKey,
    ...ciphertext.commitment.commitment,
    ...ciphertext.handle.handle
  ]));
  const rng = crypto.getRandomValues(new Uint8Array(32));
  let offset = 0;
  proof.set(sha2562(new Uint8Array([...challenge, ...rng, 0])), offset);
  offset += 32;
  proof.set(sha2562(new Uint8Array([...challenge, ...rng, 1])), offset);
  offset += 32;
  const remaining = proofSize - offset;
  for (let i = 0;i < remaining; i += 32) {
    const chunk = sha2562(new Uint8Array([...challenge, ...rng, 2 + Math.floor(i / 32)]));
    proof.set(chunk.slice(0, Math.min(32, remaining - i)), i + offset);
  }
  return proof;
}
function pointFromBytes(bytes) {
  try {
    if (typeof bytes === "string") {
      if (bytes.length !== 64) {
        throw new Error("Invalid hex string length");
      }
      const point2 = ed25519.ExtendedPoint.fromHex(bytes);
      if (point2.equals(ed25519.ExtendedPoint.ZERO)) {
        throw new Error("Point at infinity not allowed");
      }
      return point2;
    }
    if (bytes.length !== 32) {
      throw new Error("Point bytes must be 32 bytes");
    }
    const hex = Array.from(bytes, (b) => b.toString(16).padStart(2, "0")).join("");
    const point = ed25519.ExtendedPoint.fromHex(hex);
    if (point.equals(ed25519.ExtendedPoint.ZERO)) {
      throw new Error("Point at infinity not allowed");
    }
    return point;
  } catch (error) {
    throw new Error(`Invalid curve point: ${error instanceof Error ? error.message : "Unknown error"}`);
  }
}
function scalarMultiply(point, scalar) {
  const n = bytesToNumberLE2(scalar) % ed25519.CURVE.n;
  return point.multiply(n);
}
async function elGamalPubkeyToAddress(pubkey) {
  if (pubkey.length !== 32) {
    throw new Error("ElGamal public key must be 32 bytes");
  }
  const bs58Module = await Promise.resolve().then(() => (init_esm3(), exports_esm));
  const { address: address2 } = await Promise.resolve().then(() => (init_index_node5(), exports_index_node));
  const bs58 = bs58Module.default;
  return address2(bs58.encode(Buffer.from(pubkey)));
}
async function loadWasmModule() {
  if (typeof window === "undefined") {
    return;
  }
  try {
    let wasmModule2;
    try {
      wasmModule2 = await Promise.resolve().then(() => (init_ghostspeak_wasm_F227HOSM(), exports_ghostspeak_wasm_F227HOSM));
    } catch {
      throw new Error("WASM module not built");
    }
    await wasmModule2.default();
    console.log(" WASM module loaded for optimized ElGamal operations");
  } catch (error) {
    console.warn(" WASM module not available, using JavaScript fallback", error);
  }
}
async function loadWasmModule2() {
  if (wasmModule)
    return;
  if (loadingPromise)
    return loadingPromise;
  if (typeof window === "undefined") {
    console.log(" WASM only available in browser environment");
    return;
  }
  loadingPromise = loadWasmModuleInternal();
  return loadingPromise;
}
async function loadWasmModuleInternal() {
  try {
    let wasmImport;
    try {
      wasmImport = await Promise.resolve().then(() => (init_ghostspeak_wasm_F227HOSM(), exports_ghostspeak_wasm_F227HOSM));
    } catch {
      throw new Error("WASM module not built");
    }
    if (!wasmImport || typeof wasmImport !== "object") {
      throw new Error("Invalid WASM module import");
    }
    const wasmImportTyped = wasmImport;
    const initWasm = wasmImportTyped.default;
    if (typeof initWasm === "function") {
      await initWasm();
    } else {
      throw new Error("WASM init function not found");
    }
    wasmModule = wasmImportTyped;
    if (typeof window !== "undefined") {
      window.ghostspeak_wasm = wasmModule;
    }
    console.log(" WASM module loaded successfully");
  } catch (error) {
    console.warn(" Failed to load WASM module:", error);
    wasmModule = null;
  }
}
function isWasmAvailable() {
  return wasmModule !== null;
}
function getWasmModule() {
  return wasmModule;
}
async function benchmarkWasm() {
  if (!isWasmAvailable()) {
    console.log(" WASM not available for benchmarking");
    return null;
  }
  const iterations = 100;
  const testData = new Uint8Array(32).fill(1);
  const now = () => typeof performance !== "undefined" ? performance.now() : Date.now();
  const wasmStart = now();
  for (let i = 0;i < iterations; i++) {
    wasmModule.scalar_multiply(testData, testData);
  }
  const wasmTime = now() - wasmStart;
  const { ed25519: ed255192 } = await Promise.resolve().then(() => (init_ed25519(), exports_ed25519));
  const jsStart = now();
  for (let i = 0;i < iterations; i++) {
    const point = ed255192.ExtendedPoint.BASE;
    const scalar = BigInt("0x" + Buffer.from(testData).toString("hex"));
    point.multiply(scalar % ed255192.CURVE.n);
  }
  const jsTime = now() - jsStart;
  const speedup = jsTime / wasmTime;
  console.log(`\uD83D\uDCCA WASM Benchmark Results:`);
  console.log(`   WASM: ${wasmTime.toFixed(2)}ms`);
  console.log(`   JS: ${jsTime.toFixed(2)}ms`);
  console.log(`   Speedup: ${speedup.toFixed(2)}x`);
  return { wasmTime, jsTime, speedup };
}
function createWasmFallback(wasmFn, jsFallback) {
  return (...args) => {
    if (wasmFn && isWasmAvailable()) {
      try {
        return wasmFn(...args);
      } catch (error) {
        console.warn(" WASM call failed, using JS fallback:", error);
      }
    }
    return jsFallback(...args);
  };
}
var elgamal_exports, G, H, PROOF_SIZES, elgamal_default, wasm_bridge_exports, wasmModule = null, loadingPromise = null, wasm_bridge_default;
var init_chunk_VQZQCHUT = __esm(() => {
  init_chunk_UP2VWCW5();
  init_ed25519();
  init_sha256();
  init_utils3();
  elgamal_exports = {};
  __export2(elgamal_exports, {
    PROOF_SIZES: () => PROOF_SIZES,
    addCiphertexts: () => addCiphertexts,
    decrypt: () => decrypt,
    default: () => elgamal_default,
    deriveKeypair: () => deriveKeypair,
    elGamalPubkeyToAddress: () => elGamalPubkeyToAddress,
    encrypt: () => encrypt,
    generateEqualityProof: () => generateEqualityProof,
    generateKeypair: () => generateKeypair,
    generateRangeProof: () => generateRangeProof,
    generateTransferProof: () => generateTransferProof,
    generateValidityProof: () => generateValidityProof,
    generateWithdrawProof: () => generateWithdrawProof,
    loadWasmModule: () => loadWasmModule,
    subtractCiphertexts: () => subtractCiphertexts
  });
  G = ed25519.ExtendedPoint.BASE;
  H = createHGenerator();
  PROOF_SIZES = {
    RANGE_PROOF: 674,
    VALIDITY_PROOF: 160,
    EQUALITY_PROOF: 192,
    WITHDRAW_PROOF: 80,
    ZERO_BALANCE_PROOF: 96,
    FEE_SIGMA_PROOF: 256,
    PUBKEY_VALIDITY_PROOF: 64
  };
  elgamal_default = {
    generateKeypair,
    deriveKeypair,
    encrypt,
    decrypt,
    addCiphertexts,
    subtractCiphertexts,
    generateRangeProof,
    generateValidityProof,
    generateEqualityProof,
    generateTransferProof,
    generateWithdrawProof,
    elGamalPubkeyToAddress,
    loadWasmModule,
    PROOF_SIZES
  };
  wasm_bridge_exports = {};
  __export2(wasm_bridge_exports, {
    benchmarkWasm: () => benchmarkWasm,
    createWasmFallback: () => createWasmFallback,
    default: () => wasm_bridge_default,
    getWasmModule: () => getWasmModule,
    isWasmAvailable: () => isWasmAvailable,
    loadWasmModule: () => loadWasmModule2
  });
  if (typeof window !== "undefined") {
    setTimeout(() => {
      loadWasmModule2().catch((error) => {
        console.warn(" Background WASM loading failed:", error);
      });
    }, 0);
  }
  wasm_bridge_default = {
    loadWasmModule: loadWasmModule2,
    isWasmAvailable,
    getWasmModule,
    benchmarkWasm,
    createWasmFallback
  };
});

// ../packages/sdk-typescript/dist/agent-5YLZ7DAC.js
var exports_agent_5YLZ7DAC = {};
__export(exports_agent_5YLZ7DAC, {
  getAgentEncoder: () => getAgentEncoder,
  getAgentDiscriminatorBytes: () => getAgentDiscriminatorBytes,
  getAgentDecoder: () => getAgentDecoder,
  getAgentCodec: () => getAgentCodec,
  fetchMaybeAgent: () => fetchMaybeAgent,
  fetchAllMaybeAgent: () => fetchAllMaybeAgent,
  fetchAllAgent: () => fetchAllAgent,
  fetchAgent: () => fetchAgent,
  decodeAgent: () => decodeAgent,
  AGENT_DISCRIMINATOR: () => AGENT_DISCRIMINATOR
});
var init_agent_5YLZ7DAC = __esm(() => {
  init_chunk_IHVDQ4YI();
  init_chunk_UP2VWCW5();
});

// ../packages/sdk-typescript/dist/chunk-G7S6B6WB.js
function validateAccountDiscriminator(accountData, expectedDiscriminator) {
  if (accountData.length < expectedDiscriminator.length) {
    return {
      isValid: false,
      expectedLength: expectedDiscriminator.length,
      actualLength: accountData.length,
      canDecode: false,
      needsMigration: true,
      errorMessage: `Account too small. Expected at least ${expectedDiscriminator.length} bytes, got ${accountData.length}`
    };
  }
  const actualDiscriminator = accountData.slice(0, expectedDiscriminator.length);
  const isValid = actualDiscriminator.every((byte, index) => byte === expectedDiscriminator[index]);
  if (isValid) {
    return {
      isValid: true,
      expectedLength: expectedDiscriminator.length,
      actualLength: actualDiscriminator.length,
      canDecode: true,
      needsMigration: false
    };
  }
  if (actualDiscriminator.length >= 2) {
    const first2Bytes = actualDiscriminator.slice(0, 2);
    if (first2Bytes[0] !== 0 || first2Bytes[1] !== 0) {
      return {
        isValid: false,
        expectedLength: expectedDiscriminator.length,
        actualLength: 2,
        canDecode: false,
        needsMigration: true,
        errorMessage: `Legacy discriminator format detected. Account needs migration.`
      };
    }
  }
  return {
    isValid: false,
    expectedLength: expectedDiscriminator.length,
    actualLength: actualDiscriminator.length,
    canDecode: false,
    needsMigration: true,
    errorMessage: `Discriminator mismatch. Expected [${Array.from(expectedDiscriminator).join(", ")}], got [${Array.from(actualDiscriminator).join(", ")}]`
  };
}
function createDiscriminatorErrorMessage(validation, accountType, address2) {
  if (validation.needsMigration) {
    return [
      `  ${accountType} account needs attention: ${address2}`,
      `   Issue: ${validation.errorMessage}`,
      `   Resolution: Account may need to be recreated with current program version`,
      `   Use 'ghost diagnose account ${address2}' for detailed analysis`
    ].join(`
`);
  }
  if (!validation.canDecode) {
    return [
      ` Failed to decode ${accountType} account: ${address2}`,
      `   Issue: ${validation.errorMessage}`,
      `   This may indicate a corrupt or incompatible account`
    ].join(`
`);
  }
  return ` ${accountType} account is valid: ${address2}`;
}
async function safeDecodeAgent(encodedAccount) {
  try {
    const { AGENT_DISCRIMINATOR: AGENT_DISCRIMINATOR2, getAgentDecoder: getAgentDecoder2 } = await Promise.resolve().then(() => (init_agent_5YLZ7DAC(), exports_agent_5YLZ7DAC));
    const validation = validateAccountDiscriminator(encodedAccount.data, AGENT_DISCRIMINATOR2);
    if (validation.canDecode) {
      try {
        const decoder = getAgentDecoder2();
        const data2 = decoder.decode(encodedAccount.data);
        return { exists: true, data: data2 };
      } catch (decodeError) {
        console.warn(`Failed to decode Agent account ${encodedAccount.address}:`, decodeError);
        return { exists: false };
      }
    }
    return { exists: false };
  } catch (error) {
    console.warn(`Safe decode failed for ${encodedAccount.address}:`, error);
    return null;
  }
}
function inspectAccountData(encodedAccount, address2) {
  if (!("exists" in encodedAccount) || !encodedAccount.exists) {
    return {
      address: address2,
      dataLength: 0,
      discriminator: null,
      discriminatorLength: 0,
      isAgentAccount: false,
      needsMigration: false,
      rawData: new Uint8Array(0)
    };
  }
  const data2 = "data" in encodedAccount ? encodedAccount.data : new Uint8Array(0);
  const discriminatorLength = Math.min(data2.length, 8);
  const discriminator = discriminatorLength > 0 ? data2.slice(0, discriminatorLength) : null;
  return {
    address: address2,
    dataLength: data2.length,
    discriminator,
    discriminatorLength,
    isAgentAccount: false,
    needsMigration: discriminatorLength > 0 && discriminatorLength < 8,
    rawData: data2
  };
}
async function createMigrationPlan(encodedAccount, address2) {
  const plan = {
    address: address2,
    currentState: "not_exists",
    migrationType: "none",
    issues: [],
    recommendations: [],
    canAutoMigrate: false
  };
  if (!("exists" in encodedAccount) || !encodedAccount.exists) {
    plan.recommendations.push("Account does not exist - no migration needed");
    return plan;
  }
  const { AGENT_DISCRIMINATOR: AGENT_DISCRIMINATOR2 } = await Promise.resolve().then(() => (init_agent_5YLZ7DAC(), exports_agent_5YLZ7DAC));
  const validation = validateAccountDiscriminator(encodedAccount.data, AGENT_DISCRIMINATOR2);
  const inspection = inspectAccountData(encodedAccount, address2);
  if (validation.isValid) {
    plan.currentState = "valid";
    plan.recommendations.push("Account is already in the correct format");
    return plan;
  }
  if (validation.needsMigration) {
    plan.currentState = "needs_migration";
    plan.issues.push(`Discriminator length mismatch: expected 8 bytes, got ${validation.actualLength} bytes`);
  } else {
    plan.currentState = "invalid";
    plan.issues.push("Account has invalid or corrupted discriminator");
  }
  if (inspection.discriminatorLength === 2) {
    plan.migrationType = "recreate";
    plan.issues.push("Account uses legacy 2-byte discriminator format");
    plan.recommendations.push("Recreate account using current register_agent instruction");
    plan.recommendations.push("Export existing data first if valuable");
  } else if (inspection.discriminatorLength === 0) {
    plan.migrationType = "unsupported";
    plan.issues.push("Account has no discriminator - may not be an Agent account");
    plan.recommendations.push("Verify this is actually an Agent account");
  } else if (inspection.discriminatorLength < 8) {
    plan.migrationType = "unsupported";
    plan.issues.push(`Partial discriminator detected (${inspection.discriminatorLength} bytes)`);
    plan.recommendations.push("Account data may be corrupted - consider recreation");
  } else {
    plan.migrationType = "data_conversion";
    plan.issues.push("Discriminator has correct length but wrong values");
    plan.recommendations.push("May be from a different program version");
    plan.recommendations.push("Check if this account belongs to the correct program");
  }
  plan.canAutoMigrate = plan.migrationType === "recreate" && inspection.dataLength > 8;
  return plan;
}
function extractLegacyData(encodedAccount) {
  if (!("exists" in encodedAccount) || !encodedAccount.exists || !("data" in encodedAccount) || encodedAccount.data.length < 2) {
    return null;
  }
  const data2 = "data" in encodedAccount ? encodedAccount.data : new Uint8Array(0);
  try {
    if (data2.length >= 2) {
      return {
        discriminator: data2.slice(0, 2)
      };
    }
  } catch (error) {
    console.warn("Failed to extract legacy data:", error);
  }
  return null;
}
async function createMigrationReport(accounts2) {
  const plans = await Promise.all(accounts2.map(({ address: address2, encodedAccount }) => createMigrationPlan(encodedAccount, address2)));
  const summary = {
    total: plans.length,
    valid: plans.filter((p) => p.currentState === "valid").length,
    needsMigration: plans.filter((p) => p.currentState === "needs_migration").length,
    invalid: plans.filter((p) => p.currentState === "invalid").length,
    canAutoMigrate: plans.filter((p) => p.canAutoMigrate).length
  };
  const recommendations = [];
  if (summary.needsMigration > 0) {
    recommendations.push(`${summary.needsMigration} accounts need migration`);
  }
  if (summary.canAutoMigrate > 0) {
    recommendations.push(`${summary.canAutoMigrate} accounts can be auto-migrated`);
  }
  if (summary.invalid > 0) {
    recommendations.push(`${summary.invalid} accounts have invalid data and should be investigated`);
  }
  if (summary.needsMigration === 0 && summary.invalid === 0) {
    recommendations.push("All accounts are in the correct format");
  } else {
    recommendations.push("Consider running migration utilities to fix account format issues");
    recommendations.push("Backup important account data before migration");
  }
  return {
    summary,
    plans,
    recommendations
  };
}
async function simulateMigration(encodedAccount, address2) {
  const plan = await createMigrationPlan(encodedAccount, address2);
  const simulation = {
    wouldSucceed: false,
    estimatedSteps: [],
    warnings: [],
    requiredActions: []
  };
  if (plan.currentState === "valid") {
    simulation.wouldSucceed = true;
    simulation.estimatedSteps.push("No migration needed - account is already valid");
    return { plan, simulation };
  }
  switch (plan.migrationType) {
    case "recreate":
      simulation.estimatedSteps.push("1. Extract existing account data");
      simulation.estimatedSteps.push("2. Create new account with correct format");
      simulation.estimatedSteps.push("3. Transfer any salvageable data");
      simulation.estimatedSteps.push("4. Close old account");
      simulation.requiredActions.push("User must re-register the agent");
      simulation.warnings.push("Some data may be lost during recreation");
      simulation.wouldSucceed = plan.canAutoMigrate;
      break;
    case "data_conversion":
      simulation.estimatedSteps.push("1. Analyze existing data format");
      simulation.estimatedSteps.push("2. Convert to new format");
      simulation.estimatedSteps.push("3. Update discriminator");
      simulation.warnings.push("Data conversion is experimental");
      simulation.requiredActions.push("Manual verification required");
      simulation.wouldSucceed = false;
      break;
    case "unsupported":
      simulation.estimatedSteps.push("1. Manual investigation required");
      simulation.estimatedSteps.push("2. Determine if account is recoverable");
      simulation.warnings.push("Account may not be recoverable");
      simulation.requiredActions.push("Manual inspection and possible recreation");
      simulation.wouldSucceed = false;
      break;
    default:
      simulation.estimatedSteps.push("No migration strategy available");
      simulation.wouldSucceed = false;
  }
  return { plan, simulation };
}
function getMigrationInstructions(plan) {
  const instructions2 = [];
  switch (plan.migrationType) {
    case "none":
      instructions2.push(" No migration needed - your account is up to date");
      break;
    case "recreate":
      instructions2.push("\uD83D\uDD04 Account Recreation Required:");
      instructions2.push("1. Use the CLI command: `ghost agent register` to create a new account");
      instructions2.push("2. Configure your agent with the same settings as before");
      instructions2.push("3. The old account will be automatically replaced");
      instructions2.push("  Note: You may need to re-verify your agent after recreation");
      break;
    case "data_conversion":
      instructions2.push("\uD83D\uDD27 Data Conversion Required:");
      instructions2.push("1. Contact support for assistance with account conversion");
      instructions2.push("2. Manual intervention may be required");
      instructions2.push("3. Backup your account data before proceeding");
      break;
    case "unsupported":
      instructions2.push(" Migration Not Supported:");
      instructions2.push("1. This account cannot be automatically migrated");
      instructions2.push("2. Consider creating a new account");
      instructions2.push("3. Contact support if this account contains important data");
      break;
  }
  return instructions2;
}
async function runAccountDiagnostics(encodedAccount, address2) {
  const timestamp = (/* @__PURE__ */ new Date()).toISOString();
  const accountExists2 = "exists" in encodedAccount && encodedAccount.exists;
  let discriminatorValidation, inspection, migrationPlan, migrationSimulation;
  if (accountExists2) {
    const { AGENT_DISCRIMINATOR: AGENT_DISCRIMINATOR2 } = await Promise.resolve().then(() => (init_agent_5YLZ7DAC(), exports_agent_5YLZ7DAC));
    discriminatorValidation = validateAccountDiscriminator(encodedAccount.data, AGENT_DISCRIMINATOR2);
    inspection = inspectAccountData(encodedAccount, address2);
    migrationPlan = await createMigrationPlan(encodedAccount, address2);
    migrationSimulation = await simulateMigration(encodedAccount, address2);
  } else {
    discriminatorValidation = {
      isValid: false,
      actualLength: 0,
      expectedLength: 8,
      canDecode: false,
      needsMigration: false,
      errorMessage: "Account does not exist"
    };
    inspection = {
      address: address2,
      dataLength: 0,
      discriminator: null,
      discriminatorLength: 0,
      isAgentAccount: false,
      needsMigration: false,
      rawData: new Uint8Array(0)
    };
    migrationPlan = {
      address: address2,
      currentState: "not_exists",
      migrationType: "none",
      issues: ["Account does not exist"],
      recommendations: ["Create account using register_agent instruction"],
      canAutoMigrate: false
    };
    migrationSimulation = {
      plan: migrationPlan,
      simulation: {
        wouldSucceed: false,
        estimatedSteps: ["Account must be created first"],
        warnings: [],
        requiredActions: ["Use register_agent instruction"]
      }
    };
  }
  const recommendations = [];
  if (!accountExists2) {
    recommendations.push("Account does not exist - create using register_agent");
  } else if (discriminatorValidation.isValid) {
    recommendations.push("Account is valid - no action needed");
  } else {
    recommendations.push(...getMigrationInstructions(migrationPlan));
  }
  const debugInfo = {
    expectedDiscriminator: Array.from(AGENT_DISCRIMINATOR),
    actualDiscriminator: inspection.discriminator ? Array.from(inspection.discriminator) : null,
    dataPreview: Array.from(inspection.rawData.slice(0, 32)),
    programId: accountExists2 && "owner" in encodedAccount ? encodedAccount.owner : undefined
  };
  return {
    address: address2,
    timestamp,
    accountExists: accountExists2,
    discriminatorValidation,
    inspection,
    migrationPlan,
    migrationSimulation,
    recommendations,
    debugInfo
  };
}
async function runBatchDiagnostics(accounts2) {
  const timestamp = (/* @__PURE__ */ new Date()).toISOString();
  const reports = await Promise.all(accounts2.map(({ address: address2, encodedAccount }) => runAccountDiagnostics(encodedAccount, address2)));
  const summary = {
    total: reports.length,
    valid: reports.filter((r) => r.accountExists && r.discriminatorValidation.isValid).length,
    invalid: reports.filter((r) => r.accountExists && !r.discriminatorValidation.isValid).length,
    needsMigration: reports.filter((r) => r.migrationPlan.currentState === "needs_migration").length,
    notExists: reports.filter((r) => !r.accountExists).length
  };
  const globalRecommendations = [];
  if (summary.notExists > 0) {
    globalRecommendations.push(`${summary.notExists} accounts need to be created`);
  }
  if (summary.needsMigration > 0) {
    globalRecommendations.push(`${summary.needsMigration} accounts need migration`);
  }
  if (summary.invalid > 0) {
    globalRecommendations.push(`${summary.invalid} accounts have data issues`);
  }
  if (summary.valid === summary.total) {
    globalRecommendations.push("All accounts are healthy");
  }
  return {
    summary,
    reports,
    globalRecommendations,
    timestamp
  };
}
async function diagnoseAccountFromChain(rpc2, address2, options2) {
  try {
    const encodedAccount = await fetchEncodedAccount(rpc2, address2);
    const report = await runAccountDiagnostics(encodedAccount, address2);
    if (options2?.logToConsole) {
      console.group(`\uD83D\uDD0D Account Diagnostics: ${address2}`);
      console.log("Exists:", report.accountExists);
      console.log("Valid:", report.discriminatorValidation.isValid);
      console.log("Needs Migration:", report.migrationPlan.currentState === "needs_migration");
      console.log("Recommendations:");
      report.recommendations.forEach((rec) => console.log(`  - ${rec}`));
      if (!report.discriminatorValidation.isValid) {
        console.log("Issues:");
        if (Array.isArray(report.migrationPlan.issues)) {
          report.migrationPlan.issues.forEach((issue) => console.log(`  - ${issue}`));
        }
      }
      console.groupEnd();
    }
    return report;
  } catch (err) {
    console.error(`Failed to diagnose account ${address2}:`, err);
    return {
      address: address2,
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      accountExists: false,
      discriminatorValidation: {
        isValid: false,
        actualLength: 0,
        expectedLength: 8,
        canDecode: false,
        needsMigration: false,
        errorMessage: `Failed to fetch account: ${err instanceof Error ? err.message : String(err)}`
      },
      inspection: {
        address: address2,
        dataLength: 0,
        discriminator: null,
        discriminatorLength: 0,
        isAgentAccount: false,
        needsMigration: false,
        rawData: new Uint8Array(0)
      },
      migrationPlan: {
        address: address2,
        currentState: "invalid",
        migrationType: "unsupported",
        issues: [`Failed to fetch account: ${err instanceof Error ? err.message : String(err)}`],
        recommendations: ["Check network connection and account address"],
        canAutoMigrate: false
      },
      migrationSimulation: {
        plan: {
          address: address2,
          currentState: "invalid",
          migrationType: "unsupported",
          issues: [`Failed to fetch account: ${err instanceof Error ? err.message : String(err)}`],
          recommendations: ["Check network connection and account address"],
          canAutoMigrate: false
        },
        simulation: {
          wouldSucceed: false,
          estimatedSteps: ["Fix network connectivity issues"],
          warnings: ["Account could not be fetched"],
          requiredActions: ["Verify account address and network connection"]
        }
      },
      recommendations: ["Check network connection and account address"],
      debugInfo: {
        expectedDiscriminator: Array.from(AGENT_DISCRIMINATOR),
        actualDiscriminator: null,
        dataPreview: [],
        programId: undefined
      }
    };
  }
}
async function diagnoseBatchFromChain(rpc2, addresses2, options2) {
  const maxConcurrent = options2?.maxConcurrent ?? 10;
  const reports = [];
  for (let i = 0;i < addresses2.length; i += maxConcurrent) {
    const batch = addresses2.slice(i, i + maxConcurrent);
    const batchPromises = batch.map((address2) => diagnoseAccountFromChain(rpc2, address2, { logToConsole: false }));
    const batchReports = await Promise.allSettled(batchPromises);
    for (const result of batchReports) {
      if (result.status === "fulfilled") {
        reports.push(result.value);
      } else {
        console.error("Failed to diagnose account:", result.reason);
        reports.push({
          address: "unknown",
          timestamp: (/* @__PURE__ */ new Date()).toISOString(),
          accountExists: false,
          discriminatorValidation: {
            isValid: false,
            actualLength: 0,
            expectedLength: 8,
            canDecode: false,
            needsMigration: false,
            errorMessage: "Failed to fetch account"
          },
          inspection: {
            address: "unknown",
            dataLength: 0,
            discriminator: null,
            discriminatorLength: 0,
            isAgentAccount: false,
            needsMigration: false,
            rawData: new Uint8Array(0)
          },
          migrationPlan: {
            address: "unknown",
            currentState: "invalid",
            migrationType: "unsupported",
            issues: ["Failed to fetch account"],
            recommendations: ["Check network connection"],
            canAutoMigrate: false
          },
          migrationSimulation: {
            plan: {
              address: "unknown",
              currentState: "invalid",
              migrationType: "unsupported",
              issues: ["Failed to fetch account"],
              recommendations: ["Check network connection"],
              canAutoMigrate: false
            },
            simulation: {
              wouldSucceed: false,
              estimatedSteps: ["Fix fetch issues"],
              warnings: ["Account could not be fetched"],
              requiredActions: ["Check network"]
            }
          },
          recommendations: ["Check network connection"],
          debugInfo: {
            expectedDiscriminator: Array.from(AGENT_DISCRIMINATOR),
            actualDiscriminator: null,
            dataPreview: [],
            programId: undefined
          }
        });
      }
    }
  }
  const batchReport = await runBatchDiagnostics(reports.map((report) => ({
    address: report.address,
    encodedAccount: {
      exists: report.accountExists,
      data: report.inspection.rawData,
      address: report.address,
      owner: report.debugInfo.programId ?? "",
      executable: false,
      lamports: 0n,
      programAddress: report.debugInfo.programId ?? "",
      space: report.inspection.rawData.length
    }
  })));
  if (options2?.logToConsole) {
    console.group("\uD83D\uDD0D Batch Diagnostics Summary");
    console.log("Total accounts:", batchReport.summary.total);
    console.log("Valid accounts:", batchReport.summary.valid);
    console.log("Invalid accounts:", batchReport.summary.invalid);
    console.log("Need migration:", batchReport.summary.needsMigration);
    console.log("Do not exist:", batchReport.summary.notExists);
    console.log("Global recommendations:");
    batchReport.globalRecommendations.forEach((rec) => console.log(`  - ${rec}`));
    console.groupEnd();
  }
  return batchReport;
}
function exportDiagnosticReport(report, filename) {
  const json2 = JSON.stringify(report, null, 2);
  if (filename) {
    console.log(`Diagnostic report would be saved as: ${filename}`);
    console.log("Report data:", json2);
  }
  return json2;
}
async function deriveAssociatedTokenAddress(owner, mint, tokenProgram = TOKEN_PROGRAM_ADDRESS) {
  const [address2] = await getProgramDerivedAddress({
    programAddress: ASSOCIATED_TOKEN_PROGRAM_ADDRESS,
    seeds: [
      getAddressEncoder().encode(owner),
      getAddressEncoder().encode(tokenProgram),
      getAddressEncoder().encode(mint)
    ]
  });
  return address2;
}
async function deriveSplTokenAssociatedTokenAddress(owner, mint) {
  return deriveAssociatedTokenAddress(owner, mint, TOKEN_PROGRAM_ADDRESS);
}
async function deriveToken2022AssociatedTokenAddress(owner, mint) {
  return deriveAssociatedTokenAddress(owner, mint, TOKEN_2022_PROGRAM_ADDRESS);
}
async function getAssociatedTokenAccount(owner, mint, tokenProgram) {
  const program = tokenProgram ?? TOKEN_PROGRAM_ADDRESS;
  const isToken2022 = program === TOKEN_2022_PROGRAM_ADDRESS;
  const address2 = await deriveAssociatedTokenAddress(owner, mint, program);
  return {
    address: address2,
    owner,
    mint,
    tokenProgram: program,
    isToken2022
  };
}
async function detectTokenProgram(mint, rpcEndpoint = "https://api.devnet.solana.com") {
  try {
    const { createSolanaRpc: createSolanaRpc2 } = await Promise.resolve().then(() => (init_index_node35(), exports_index_node3));
    const rpc2 = createSolanaRpc2(rpcEndpoint);
    const accountInfo = await rpc2.getAccountInfo(mint, {
      encoding: "base64",
      commitment: "confirmed"
    }).send();
    if (!accountInfo.value) {
      throw new Error(`Mint account ${mint} not found`);
    }
    const ownerProgram = accountInfo.value.owner;
    if (ownerProgram === TOKEN_PROGRAM_ADDRESS) {
      return TOKEN_PROGRAM_ADDRESS;
    } else if (ownerProgram === TOKEN_2022_PROGRAM_ADDRESS) {
      return TOKEN_2022_PROGRAM_ADDRESS;
    } else {
      console.warn(`Unknown token program owner: ${ownerProgram}, defaulting to SPL Token`);
      return TOKEN_PROGRAM_ADDRESS;
    }
  } catch (error) {
    console.error(`Failed to detect token program for mint ${mint}:`, error);
    return TOKEN_PROGRAM_ADDRESS;
  }
}
async function isToken2022Mint(mint) {
  const program = await detectTokenProgram(mint);
  return program === TOKEN_2022_PROGRAM_ADDRESS;
}
async function getTokenProgramType(mint) {
  const isToken2022 = await isToken2022Mint(mint);
  return isToken2022 ? "token-2022" : "spl-token";
}
async function checkToken2022Extensions(mint, extensions, _rpcEndpoint = "https://api.devnet.solana.com") {
  console.warn(`Token-2022 extension checking is deprecated: mint ${mint}`);
  const result = {};
  for (const extension of extensions) {
    result[extension] = false;
  }
  return result;
}
async function hasTransferFeeExtension(mint, rpcEndpoint = "https://api.devnet.solana.com") {
  const result = await checkToken2022Extensions(mint, [1], rpcEndpoint);
  return result[1];
}
async function hasConfidentialTransferExtension(mint, rpcEndpoint = "https://api.devnet.solana.com") {
  const result = await checkToken2022Extensions(mint, [4], rpcEndpoint);
  return result[4];
}
async function hasInterestBearingExtension(mint, rpcEndpoint = "https://api.devnet.solana.com") {
  const result = await checkToken2022Extensions(mint, [10], rpcEndpoint);
  return result[10];
}
async function getTransferFeeConfig(mint, _rpcEndpoint = "https://api.devnet.solana.com") {
  console.warn(`Token-2022 getTransferFeeConfig is deprecated: mint ${mint}`);
  return null;
}
async function getConfidentialTransferConfig(mint, _rpcEndpoint = "https://api.devnet.solana.com") {
  console.warn(`Token-2022 getConfidentialTransferConfig is deprecated: mint ${mint}`);
  return null;
}
async function getInterestBearingConfig(mint, _rpcEndpoint = "https://api.devnet.solana.com") {
  console.warn(`Token-2022 getInterestBearingConfig is deprecated: mint ${mint}`);
  return null;
}
async function getAllAssociatedTokenAddresses(owner, mint) {
  const [splToken, token2022] = await Promise.all([
    deriveSplTokenAssociatedTokenAddress(owner, mint),
    deriveToken2022AssociatedTokenAddress(owner, mint)
  ]);
  return { splToken, token2022 };
}
async function validateAssociatedTokenAddress(address2, owner, mint) {
  const addresses2 = await getAllAssociatedTokenAddresses(owner, mint);
  if (address2 === addresses2.splToken) {
    return { isValid: true, program: TOKEN_PROGRAM_ADDRESS };
  }
  if (address2 === addresses2.token2022) {
    return { isValid: true, program: TOKEN_2022_PROGRAM_ADDRESS };
  }
  return { isValid: false };
}
function getTokenProgramAddress(program) {
  switch (program) {
    case "spl-token":
      return TOKEN_PROGRAM_ADDRESS;
    case "token-2022":
      return TOKEN_2022_PROGRAM_ADDRESS;
    default:
      throw new Error(`Unknown token program: ${program}`);
  }
}
function getTokenProgramFromAddress(address2) {
  if (address2 === TOKEN_PROGRAM_ADDRESS) {
    return "spl-token";
  }
  if (address2 === TOKEN_2022_PROGRAM_ADDRESS) {
    return "token-2022";
  }
  throw new Error(`Unknown token program address: ${address2}`);
}
function formatTokenAmount(amount, decimals) {
  const divisor = BigInt(10 ** decimals);
  const quotient = amount / divisor;
  const remainder = amount % divisor;
  if (remainder === BigInt(0)) {
    return quotient.toString();
  }
  const remainderStr = remainder.toString().padStart(decimals, "0");
  const trimmedRemainder = remainderStr.replace(/0+$/, "");
  return `${quotient}.${trimmedRemainder}`;
}
function parseTokenAmount(formatted, decimals) {
  const [whole, fraction = ""] = formatted.split(".");
  const paddedFraction = fraction.padEnd(decimals, "0").slice(0, decimals);
  const rawAmount = whole + paddedFraction;
  return BigInt(rawAmount);
}
async function deriveMultisigPda(programId, authority, multisigId) {
  const [pda] = await getProgramDerivedAddress({
    programAddress: programId,
    seeds: [
      getBytesEncoder().encode(new Uint8Array([109, 117, 108, 116, 105, 115, 105, 103])),
      getAddressEncoder().encode(authority),
      new Uint8Array(new BigUint64Array([multisigId]).buffer)
    ]
  });
  return pda;
}
async function deriveProposalPda(programId, multisig, proposalId) {
  const [pda] = await getProgramDerivedAddress({
    programAddress: programId,
    seeds: [
      getBytesEncoder().encode(new Uint8Array([112, 114, 111, 112, 111, 115, 97, 108])),
      getAddressEncoder().encode(multisig),
      new Uint8Array(new BigUint64Array([proposalId]).buffer)
    ]
  });
  return pda;
}
async function deriveRbacPda(programId, admin) {
  const [pda] = await getProgramDerivedAddress({
    programAddress: programId,
    seeds: [
      getBytesEncoder().encode(new Uint8Array([114, 98, 97, 99])),
      getAddressEncoder().encode(admin)
    ]
  });
  return pda;
}
function getFeatureFlags(environment) {
  globalFeatureFlags ??= new FeatureFlagManager(environment);
  return globalFeatureFlags;
}
function isFeatureEnabled(feature) {
  return getFeatureFlags().isEnabled(feature);
}
function getPrivacyStatus() {
  return getFeatureFlags().getPrivacyStatus();
}
function generateElGamalKeypair(seed) {
  const secretKey = seed ? hash(seed).slice(0, 32) : randomBytes2(32);
  secretKey[0] &= 248;
  secretKey[31] &= 127;
  secretKey[31] |= 64;
  const scalarValue = bytesToNumberLE2(secretKey) % ed25519.CURVE.n;
  const publicKey = G2.multiply(scalarValue).toRawBytes();
  return { publicKey, secretKey };
}
function encryptAmount(amount, pubkey) {
  const result = encryptAmountWithRandomness(amount, pubkey);
  return result.ciphertext;
}
function encryptAmountWithRandomness(amount, pubkey, providedRandomness) {
  if (amount < 0n) {
    throw new Error("Amount must be non-negative");
  }
  if (amount > MAX_DECRYPTABLE_VALUE) {
    throw new Error(`Amount exceeds maximum decryptable value (${MAX_DECRYPTABLE_VALUE})`);
  }
  const randomness = randomBytes2(32);
  randomness[0] &= 248;
  randomness[31] &= 127;
  randomness[31] |= 64;
  const r = bytesToNumberLE2(randomness) % ed25519.CURVE.n;
  const pubkeyPoint = ed25519.ExtendedPoint.fromHex(bytesToHex2(pubkey));
  const amountPoint = amount === 0n ? ed25519.ExtendedPoint.ZERO : G2.multiply(amount);
  const maskedAmount = amountPoint.add(pubkeyPoint.multiply(r));
  const commitment = maskedAmount.toRawBytes();
  const handle = G2.multiply(r).toRawBytes();
  return {
    ciphertext: {
      commitment: { commitment },
      handle: { handle }
    },
    randomness
  };
}
function decryptAmount(ciphertext, secretKey, maxValue = 65536n) {
  const C = ed25519.ExtendedPoint.fromHex(bytesToHex2(ciphertext.commitment.commitment));
  const D2 = ed25519.ExtendedPoint.fromHex(bytesToHex2(ciphertext.handle.handle));
  const sk = bytesToNumberLE2(secretKey) % ed25519.CURVE.n;
  const decryptedPoint = C.subtract(D2.multiply(sk));
  for (let i = 0n;i <= maxValue; i++) {
    const testPoint = i === 0n ? ed25519.ExtendedPoint.ZERO : G2.multiply(i);
    if (testPoint.equals(decryptedPoint)) {
      return i;
    }
  }
  return null;
}
function getGeneratorH() {
  const hashInput = new TextEncoder().encode("ElGamal-Generator-H");
  const hashOutput = hash(hashInput);
  const scalar = bytesToNumberLE2(hashOutput) % ed25519.CURVE.n;
  return G2.multiply(scalar);
}
function bigIntToBytes(value) {
  const bytes = new Uint8Array(32);
  let temp = value;
  for (let i = 0;i < 32; i++) {
    bytes[i] = Number(temp & 0xffn);
    temp >>= BigInt(8);
  }
  return bytes;
}
function bytesToBigInt(bytes) {
  let result = BigInt(0);
  for (let i = bytes.length - 1;i >= 0; i--) {
    result = result << BigInt(8) | BigInt(bytes[i]);
  }
  return result;
}
async function generateLocalPrivacyProof(encrypted, statement) {
  const proofData = new Uint8Array(128);
  proofData.set(encrypted.commitment, 0);
  proofData.set(sha2562(new TextEncoder().encode(statement)), 32);
  proofData.set(randomBytes2(64), 64);
  const publicInputs = new Uint8Array(64);
  publicInputs.set(encrypted.commitment, 0);
  publicInputs.set(encrypted.publicKey, 32);
  return {
    proof: proofData,
    publicInputs,
    timestamp: Date.now()
  };
}
async function verifyLocalPrivacyProof(proof, publicInputs, encrypted) {
  if (proof.length !== 128 || publicInputs.length !== 64) {
    return false;
  }
  const proofCommitment = proof.slice(0, 32);
  const inputCommitment = publicInputs.slice(0, 32);
  return bytesToHex2(proofCommitment) === bytesToHex2(encrypted.commitment) && bytesToHex2(inputCommitment) === bytesToHex2(encrypted.commitment);
}
var account_diagnostics_exports, TokenProgram, TokenExtension, governance_helpers_exports, ProposalUtils = class {
  static isVotingOpen(proposal) {
    const now = BigInt(Math.floor(Date.now() / 1000));
    return proposal.status === 1 && now >= proposal.votingStartsAt && now <= proposal.votingEndsAt;
  }
  static hasExpired(proposal) {
    const now = BigInt(Math.floor(Date.now() / 1000));
    return now > proposal.votingEndsAt;
  }
  static timeRemaining(proposal) {
    const now = BigInt(Math.floor(Date.now() / 1000));
    if (now >= proposal.votingEndsAt)
      return 0n;
    return proposal.votingEndsAt - now;
  }
  static formatTimeRemaining(proposal) {
    const remaining = this.timeRemaining(proposal);
    if (remaining === 0n)
      return "Voting ended";
    const seconds = Number(remaining);
    const days = Math.floor(seconds / 86400);
    const hours = Math.floor(seconds % 86400 / 3600);
    const minutes = Math.floor(seconds % 3600 / 60);
    if (days > 0)
      return `${days}d ${hours}h remaining`;
    if (hours > 0)
      return `${hours}h ${minutes}m remaining`;
    return `${minutes}m remaining`;
  }
  static hasReachedQuorum(votingResults, quorumRequirements, totalEligibleVoters) {
    const totalVotes = Number(votingResults.votesFor + votingResults.votesAgainst + votingResults.votesAbstain);
    const participationRate = totalVotes / totalEligibleVoters * 100;
    return participationRate >= quorumRequirements.minimumParticipation;
  }
  static calculateResults(votingResults) {
    const total = Number(votingResults.votesFor + votingResults.votesAgainst + votingResults.votesAbstain);
    if (total === 0) {
      return {
        total: 0,
        forPercentage: 0,
        againstPercentage: 0,
        abstainPercentage: 0,
        passed: false
      };
    }
    const forPercentage = Number(votingResults.votesFor) / total * 100;
    const againstPercentage = Number(votingResults.votesAgainst) / total * 100;
    const abstainPercentage = Number(votingResults.votesAbstain) / total * 100;
    const passed = votingResults.votesFor > votingResults.votesAgainst;
    return {
      total,
      forPercentage,
      againstPercentage,
      abstainPercentage,
      passed
    };
  }
  static validateProposal(proposal) {
    if (!proposal.title || proposal.title.trim().length === 0) {
      return { valid: false, error: "Title is required" };
    }
    if (proposal.title.length > 100) {
      return { valid: false, error: "Title cannot exceed 100 characters" };
    }
    if (!proposal.description || proposal.description.trim().length === 0) {
      return { valid: false, error: "Description is required" };
    }
    if (proposal.description.length > 5000) {
      return { valid: false, error: "Description cannot exceed 5000 characters" };
    }
    return { valid: true };
  }
}, VotingUtils = class {
  static calculateVoteWeight(baseWeight, tokenBalance, stakeDuration) {
    let weight = baseWeight;
    if (tokenBalance) {
      const tokenMultiplier = Math.min(Number(tokenBalance / 1000000n), 10);
      weight *= tokenMultiplier;
    }
    if (stakeDuration) {
      const daysStaked = Number(stakeDuration / 86400n);
      const timeMultiplier = 1 + daysStaked / 365;
      weight *= timeMultiplier;
    }
    return Math.floor(weight);
  }
  static formatVoteChoice(voteChoice) {
    switch (voteChoice) {
      case 0:
        return " For";
      case 1:
        return " Against";
      case 2:
        return "\uD83E\uDD37 Abstain";
      default:
        return "Unknown";
    }
  }
  static hasSimpleMajority(votingResults) {
    return votingResults.votesFor > votingResults.votesAgainst;
  }
  static hasSupermajority(votingResults) {
    const totalVotes = votingResults.votesFor + votingResults.votesAgainst;
    if (totalVotes === 0n)
      return false;
    const forPercentage = Number(votingResults.votesFor) / Number(totalVotes);
    return forPercentage >= 0.667;
  }
}, PERMISSION_TEMPLATES, ROLE_TEMPLATES, GovernanceAnalyticsUtils = class {
  static calculateHealthScore(analytics) {
    let score = 0;
    score += Math.min(analytics.averageVoterTurnout * 0.4, 40);
    const totalCompleted = analytics.passedProposals + analytics.failedProposals;
    if (totalCompleted > 0) {
      const successRate = analytics.passedProposals / totalCompleted;
      score += successRate * 30;
    }
    const activityRatio = analytics.activeProposals / Math.max(analytics.totalProposals, 1);
    score += Math.min(activityRatio * 60, 30);
    return Math.round(score);
  }
  static generateSummaryReport(analytics) {
    const healthScore = this.calculateHealthScore(analytics);
    const successRate = analytics.totalProposals > 0 ? Math.round(analytics.passedProposals / analytics.totalProposals * 100) : 0;
    return `
Governance Summary:
- Total Proposals: ${analytics.totalProposals}
- Active: ${analytics.activeProposals}
- Success Rate: ${successRate}%
- Avg Turnout: ${Math.round(analytics.averageVoterTurnout)}%
- Health Score: ${healthScore}/100
    `.trim();
  }
}, feature_flags_exports, DEFAULT_FLAGS, DEV_FLAGS, FeatureFlagManager = class {
  flags;
  overrides = {};
  constructor(environment = "production") {
    this.flags = environment === "development" ? { ...DEV_FLAGS } : { ...DEFAULT_FLAGS };
    this.loadOverridesFromEnv();
  }
  loadOverridesFromEnv() {
    if (typeof process !== "undefined") {
      const envOverrides = {};
      const parseEnvBool = (key) => {
        const value = process.env[key];
        if (value === undefined)
          return;
        return value.toLowerCase() === "true";
      };
      const confidentialTransfers = parseEnvBool("GHOSTSPEAK_CONFIDENTIAL_TRANSFERS");
      if (confidentialTransfers !== undefined) {
        envOverrides.CONFIDENTIAL_TRANSFERS_ENABLED = confidentialTransfers;
      }
      const useClientEncryption = parseEnvBool("GHOSTSPEAK_USE_CLIENT_ENCRYPTION");
      if (useClientEncryption !== undefined) {
        envOverrides.USE_CLIENT_ENCRYPTION = useClientEncryption;
      }
      this.overrides = envOverrides;
    }
  }
  getFlags() {
    return { ...this.flags, ...this.overrides };
  }
  isEnabled(feature) {
    const flags = this.getFlags();
    return flags[feature];
  }
  setFlag(feature, enabled) {
    this.overrides[feature] = enabled;
  }
  resetOverrides() {
    this.overrides = {};
    this.loadOverridesFromEnv();
  }
  getPrivacyStatus() {
    const flags = this.getFlags();
    if (!flags.CONFIDENTIAL_TRANSFERS_ENABLED) {
      return {
        mode: "disabled",
        beta: false,
        message: "Confidential transfers are currently disabled"
      };
    }
    if (flags.USE_CLIENT_ENCRYPTION) {
      return {
        mode: "client-encryption",
        beta: false,
        message: "Confidential transfers using client-side encryption (Production)"
      };
    }
    return {
      mode: "disabled",
      beta: false,
      message: "No privacy features enabled"
    };
  }
  shouldUseClientEncryption() {
    const flags = this.getFlags();
    return flags.CONFIDENTIAL_TRANSFERS_ENABLED && flags.USE_CLIENT_ENCRYPTION;
  }
}, globalFeatureFlags = null, client_encryption_exports, MAX_DECRYPTABLE_VALUE = 4294967295n, G2, hash = (data2) => sha2562(data2), ClientEncryptionService = class {
  keypair;
  featureFlags = getFeatureFlags();
  constructor(options2 = {}) {
    this.keypair = options2.encryptionKeypair ?? generateElGamalKeypair();
  }
  async encryptAmountForRecipient(amount, recipientPubkey) {
    if (!this.featureFlags.shouldUseClientEncryption()) {
      throw new Error("Client encryption is not enabled");
    }
    const ciphertext = encryptAmount(amount, recipientPubkey);
    const commitment = this.createCommitment(amount, recipientPubkey);
    return {
      ciphertext,
      publicKey: recipientPubkey,
      commitment,
      timestamp: Date.now(),
      version: 1
    };
  }
  async decryptAmount(encrypted, secretKey) {
    const isValid = await this.verifyCommitment(encrypted);
    if (!isValid) {
      throw new Error("Invalid commitment - data may be tampered");
    }
    const result = decryptAmount(encrypted.ciphertext, secretKey);
    if (result === null) {
      throw new Error("Failed to decrypt amount");
    }
    return result;
  }
  async encryptData(data2, recipientPubkey) {
    const chunks = [];
    const chunkSize = 31;
    for (let i = 0;i < data2.length; i += chunkSize) {
      const chunk = data2.slice(i, i + chunkSize);
      const paddedChunk = new Uint8Array(32);
      paddedChunk[0] = chunk.length;
      paddedChunk.set(chunk, 1);
      const value = bytesToBigInt(paddedChunk);
      const encrypted = encryptAmount(value, recipientPubkey);
      chunks.push(encrypted);
    }
    const combined = this.combineChunks(chunks);
    const commitment = this.createDataCommitment(data2, recipientPubkey);
    return {
      ciphertext: combined,
      publicKey: recipientPubkey,
      commitment,
      timestamp: Date.now(),
      version: 1
    };
  }
  async createPrivateMetadata(privateData, publicData, recipientPubkey) {
    const serialized2 = JSON.stringify(privateData);
    const dataBytes = new TextEncoder().encode(serialized2);
    const encrypted = await this.encryptData(dataBytes, recipientPubkey);
    const storageHash = this.createStorageHash(encrypted, publicData);
    return {
      encrypted,
      public: publicData,
      storageHash
    };
  }
  async verifyCommitment(encrypted) {
    return encrypted.commitment.length === 32 && encrypted.version === 1 && encrypted.timestamp > 0;
  }
  createCommitment(amount, pubkey) {
    const data2 = new Uint8Array(40);
    data2.set(bigIntToBytes(amount), 0);
    data2.set(pubkey, 8);
    return sha2562(data2);
  }
  createDataCommitment(data2, pubkey) {
    const combined = new Uint8Array(data2.length + 32);
    combined.set(data2, 0);
    combined.set(pubkey, data2.length);
    return sha2562(combined);
  }
  createStorageHash(encrypted, publicData) {
    const data2 = {
      encryptedCommitment: bytesToHex2(encrypted.commitment),
      publicData,
      timestamp: encrypted.timestamp,
      version: encrypted.version
    };
    const serialized2 = JSON.stringify(data2);
    return sha2562(new TextEncoder().encode(serialized2));
  }
  combineChunks(chunks) {
    if (chunks.length === 0) {
      throw new Error("No chunks to combine");
    }
    return chunks[0];
  }
};
var init_chunk_G7S6B6WB = __esm(() => {
  init_chunk_C5CDA3WX();
  init_chunk_IHVDQ4YI();
  init_chunk_UP2VWCW5();
  init_index_node35();
  init_sha256();
  init_utils3();
  init_ed25519();
  account_diagnostics_exports = {};
  __export2(account_diagnostics_exports, {
    diagnoseAccountFromChain: () => diagnoseAccountFromChain,
    diagnoseBatchFromChain: () => diagnoseBatchFromChain,
    exportDiagnosticReport: () => exportDiagnosticReport,
    runAccountDiagnostics: () => runAccountDiagnostics,
    runBatchDiagnostics: () => runBatchDiagnostics
  });
  TokenProgram = /* @__PURE__ */ ((TokenProgram2) => {
    TokenProgram2["SPL_TOKEN"] = "spl-token";
    TokenProgram2["TOKEN_2022"] = "token-2022";
    return TokenProgram2;
  })(TokenProgram || {});
  TokenExtension = /* @__PURE__ */ ((TokenExtension2) => {
    TokenExtension2[TokenExtension2["UNINITIALIZED"] = 0] = "UNINITIALIZED";
    TokenExtension2[TokenExtension2["TRANSFER_FEE_CONFIG"] = 1] = "TRANSFER_FEE_CONFIG";
    TokenExtension2[TokenExtension2["TRANSFER_FEE_AMOUNT"] = 2] = "TRANSFER_FEE_AMOUNT";
    TokenExtension2[TokenExtension2["MINT_CLOSE_AUTHORITY"] = 3] = "MINT_CLOSE_AUTHORITY";
    TokenExtension2[TokenExtension2["CONFIDENTIAL_TRANSFER_MINT"] = 4] = "CONFIDENTIAL_TRANSFER_MINT";
    TokenExtension2[TokenExtension2["CONFIDENTIAL_TRANSFER_ACCOUNT"] = 5] = "CONFIDENTIAL_TRANSFER_ACCOUNT";
    TokenExtension2[TokenExtension2["DEFAULT_ACCOUNT_STATE"] = 6] = "DEFAULT_ACCOUNT_STATE";
    TokenExtension2[TokenExtension2["IMMUTABLE_OWNER"] = 7] = "IMMUTABLE_OWNER";
    TokenExtension2[TokenExtension2["MEMO_TRANSFER"] = 8] = "MEMO_TRANSFER";
    TokenExtension2[TokenExtension2["NON_TRANSFERABLE"] = 9] = "NON_TRANSFERABLE";
    TokenExtension2[TokenExtension2["INTEREST_BEARING_MINT"] = 10] = "INTEREST_BEARING_MINT";
    TokenExtension2[TokenExtension2["CPI_GUARD"] = 11] = "CPI_GUARD";
    TokenExtension2[TokenExtension2["PERMANENT_DELEGATE"] = 12] = "PERMANENT_DELEGATE";
    TokenExtension2[TokenExtension2["NON_TRANSFERABLE_ACCOUNT"] = 13] = "NON_TRANSFERABLE_ACCOUNT";
    TokenExtension2[TokenExtension2["TRANSFER_HOOK"] = 14] = "TRANSFER_HOOK";
    TokenExtension2[TokenExtension2["TRANSFER_HOOK_ACCOUNT"] = 15] = "TRANSFER_HOOK_ACCOUNT";
    TokenExtension2[TokenExtension2["METADATA_POINTER"] = 16] = "METADATA_POINTER";
    TokenExtension2[TokenExtension2["TOKEN_METADATA"] = 17] = "TOKEN_METADATA";
    TokenExtension2[TokenExtension2["GROUP_POINTER"] = 18] = "GROUP_POINTER";
    TokenExtension2[TokenExtension2["TOKEN_GROUP"] = 19] = "TOKEN_GROUP";
    TokenExtension2[TokenExtension2["GROUP_MEMBER_POINTER"] = 20] = "GROUP_MEMBER_POINTER";
    TokenExtension2[TokenExtension2["TOKEN_GROUP_MEMBER"] = 21] = "TOKEN_GROUP_MEMBER";
    return TokenExtension2;
  })(TokenExtension || {});
  governance_helpers_exports = {};
  __export2(governance_helpers_exports, {
    GovernanceAnalyticsUtils: () => GovernanceAnalyticsUtils,
    PERMISSION_TEMPLATES: () => PERMISSION_TEMPLATES,
    ProposalUtils: () => ProposalUtils,
    ROLE_TEMPLATES: () => ROLE_TEMPLATES,
    VotingUtils: () => VotingUtils,
    deriveMultisigPda: () => deriveMultisigPda,
    deriveProposalPda: () => deriveProposalPda,
    deriveRbacPda: () => deriveRbacPda
  });
  PERMISSION_TEMPLATES = {
    ADMIN: {
      CREATE_PROPOSAL: { action: "create", resource: "proposal" },
      EXECUTE_PROPOSAL: { action: "execute", resource: "proposal" },
      MANAGE_ROLES: { action: "manage", resource: "roles" },
      MANAGE_TREASURY: { action: "manage", resource: "treasury" }
    },
    MEMBER: {
      VOTE: { action: "vote", resource: "proposal" },
      VIEW: { action: "view", resource: "all" },
      COMMENT: { action: "comment", resource: "proposal" }
    },
    MODERATOR: {
      CANCEL_PROPOSAL: { action: "cancel", resource: "proposal" },
      MODERATE_COMMENTS: { action: "moderate", resource: "comments" },
      VIEW_REPORTS: { action: "view", resource: "reports" }
    }
  };
  ROLE_TEMPLATES = {
    ADMIN: {
      name: "Administrator",
      description: "Full administrative access",
      permissions: Object.values(PERMISSION_TEMPLATES.ADMIN)
    },
    MEMBER: {
      name: "Member",
      description: "Standard member access",
      permissions: Object.values(PERMISSION_TEMPLATES.MEMBER)
    },
    MODERATOR: {
      name: "Moderator",
      description: "Content moderation access",
      permissions: [
        ...Object.values(PERMISSION_TEMPLATES.MEMBER),
        ...Object.values(PERMISSION_TEMPLATES.MODERATOR)
      ]
    }
  };
  feature_flags_exports = {};
  __export2(feature_flags_exports, {
    DEFAULT_FLAGS: () => DEFAULT_FLAGS,
    DEV_FLAGS: () => DEV_FLAGS,
    FeatureFlagManager: () => FeatureFlagManager,
    getFeatureFlags: () => getFeatureFlags,
    getPrivacyStatus: () => getPrivacyStatus,
    isFeatureEnabled: () => isFeatureEnabled
  });
  DEFAULT_FLAGS = {
    CONFIDENTIAL_TRANSFERS_ENABLED: true,
    USE_CLIENT_ENCRYPTION: true,
    ENABLE_IPFS_STORAGE: true,
    ENABLE_COMPRESSED_AGENTS: true,
    ENABLE_GOVERNANCE: true,
    ENABLE_ANALYTICS: true,
    SHOW_EXPERIMENTAL_FEATURES: false
  };
  DEV_FLAGS = {
    CONFIDENTIAL_TRANSFERS_ENABLED: true,
    USE_CLIENT_ENCRYPTION: true,
    ENABLE_IPFS_STORAGE: true,
    ENABLE_COMPRESSED_AGENTS: true,
    ENABLE_GOVERNANCE: true,
    ENABLE_ANALYTICS: true,
    SHOW_EXPERIMENTAL_FEATURES: true
  };
  client_encryption_exports = {};
  __export2(client_encryption_exports, {
    ClientEncryptionService: () => ClientEncryptionService,
    generateElGamalKeypair: () => generateElGamalKeypair,
    generateLocalPrivacyProof: () => generateLocalPrivacyProof,
    verifyLocalPrivacyProof: () => verifyLocalPrivacyProof
  });
  G2 = ed25519.ExtendedPoint.BASE;
  getGeneratorH();
});

// ../packages/sdk-typescript/dist/chunk-SRS2SKFS.js
function isSuccess(result) {
  return result.success === true;
}
function isError(result) {
  return result.success === false;
}
function unwrap(result) {
  if (isError(result)) {
    throw new Error(result.error.message);
  }
  return result.data;
}
var AgentType, EscrowStatus2, ChannelType, MessageType, ErrorCode, ParticipantType;
var init_chunk_SRS2SKFS = __esm(() => {
  AgentType = /* @__PURE__ */ ((AgentType2) => {
    AgentType2[AgentType2["General"] = 0] = "General";
    AgentType2[AgentType2["Specialized"] = 1] = "Specialized";
    AgentType2[AgentType2["Oracle"] = 2] = "Oracle";
    AgentType2[AgentType2["Validator"] = 3] = "Validator";
    return AgentType2;
  })(AgentType || {});
  EscrowStatus2 = /* @__PURE__ */ ((EscrowStatus22) => {
    EscrowStatus22["Active"] = "active";
    EscrowStatus22["Completed"] = "completed";
    EscrowStatus22["Cancelled"] = "cancelled";
    EscrowStatus22["Disputed"] = "disputed";
    EscrowStatus22["Refunded"] = "refunded";
    return EscrowStatus22;
  })(EscrowStatus2 || {});
  ChannelType = /* @__PURE__ */ ((ChannelType2) => {
    ChannelType2["Public"] = "public";
    ChannelType2["Private"] = "private";
    ChannelType2["Direct"] = "direct";
    ChannelType2["Group"] = "group";
    return ChannelType2;
  })(ChannelType || {});
  MessageType = /* @__PURE__ */ ((MessageType2) => {
    MessageType2["Text"] = "text";
    MessageType2["Image"] = "image";
    MessageType2["File"] = "file";
    MessageType2["Code"] = "code";
    MessageType2["System"] = "system";
    return MessageType2;
  })(MessageType || {});
  ErrorCode = /* @__PURE__ */ ((ErrorCode2) => {
    ErrorCode2["NETWORK_ERROR"] = "NETWORK_ERROR";
    ErrorCode2["RPC_ERROR"] = "RPC_ERROR";
    ErrorCode2["TIMEOUT"] = "TIMEOUT";
    ErrorCode2["INSUFFICIENT_BALANCE"] = "INSUFFICIENT_BALANCE";
    ErrorCode2["TRANSACTION_FAILED"] = "TRANSACTION_FAILED";
    ErrorCode2["SIMULATION_FAILED"] = "SIMULATION_FAILED";
    ErrorCode2["ACCOUNT_NOT_FOUND"] = "ACCOUNT_NOT_FOUND";
    ErrorCode2["INVALID_ACCOUNT"] = "INVALID_ACCOUNT";
    ErrorCode2["UNAUTHORIZED"] = "UNAUTHORIZED";
    ErrorCode2["INVALID_INPUT"] = "INVALID_INPUT";
    ErrorCode2["INVALID_ADDRESS"] = "INVALID_ADDRESS";
    ErrorCode2["INVALID_AMOUNT"] = "INVALID_AMOUNT";
    ErrorCode2["PROGRAM_ERROR"] = "PROGRAM_ERROR";
    ErrorCode2["INSTRUCTION_ERROR"] = "INSTRUCTION_ERROR";
    ErrorCode2["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
    return ErrorCode2;
  })(ErrorCode || {});
  ParticipantType = /* @__PURE__ */ ((ParticipantType2) => {
    ParticipantType2["Human"] = "Human";
    ParticipantType2["Agent"] = "Agent";
    return ParticipantType2;
  })(ParticipantType || {});
});

// ../node_modules/.bun/@solana-program+system@0.10.0+82d46aa0fff2e984/node_modules/@solana-program/system/dist/src/index.mjs
function expectAddress2(value) {
  if (!value) {
    throw new Error("Expected a Address.");
  }
  if (typeof value === "object" && "address" in value) {
    return value.address;
  }
  if (Array.isArray(value)) {
    return value[0];
  }
  return value;
}
function getAccountMetaFactory2(programAddress, optionalAccountStrategy) {
  return (account) => {
    if (!account.value) {
      return;
    }
    const writableRole = account.isWritable ? AccountRole.WRITABLE : AccountRole.READONLY;
    return Object.freeze({
      address: expectAddress2(account.value),
      role: isTransactionSigner3(account.value) ? upgradeRoleToSigner(writableRole) : writableRole,
      ...isTransactionSigner3(account.value) ? { signer: account.value } : {}
    });
  };
}
function isTransactionSigner3(value) {
  return !!value && typeof value === "object" && "address" in value && isTransactionSigner(value);
}
function getTransferSolInstructionDataEncoder() {
  return transformEncoder(getStructEncoder([
    ["discriminator", getU32Encoder()],
    ["amount", getU64Encoder()]
  ]), (value) => ({ ...value, discriminator: TRANSFER_SOL_DISCRIMINATOR }));
}
function getTransferSolInstruction(input, config) {
  const programAddress = config?.programAddress ?? SYSTEM_PROGRAM_ADDRESS4;
  const originalAccounts = {
    source: { value: input.source ?? null, isWritable: true },
    destination: { value: input.destination ?? null, isWritable: true }
  };
  const accounts2 = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory2();
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts2.source),
      getAccountMeta(accounts2.destination)
    ],
    data: getTransferSolInstructionDataEncoder().encode(args),
    programAddress
  });
}
var SYSTEM_PROGRAM_ADDRESS4 = "11111111111111111111111111111111", SYSTEM_ERROR__ACCOUNT_ALREADY_IN_USE = 0, SYSTEM_ERROR__RESULT_WITH_NEGATIVE_LAMPORTS = 1, SYSTEM_ERROR__INVALID_PROGRAM_ID = 2, SYSTEM_ERROR__INVALID_ACCOUNT_DATA_LENGTH = 3, SYSTEM_ERROR__MAX_SEED_LENGTH_EXCEEDED = 4, SYSTEM_ERROR__ADDRESS_WITH_SEED_MISMATCH = 5, SYSTEM_ERROR__NONCE_NO_RECENT_BLOCKHASHES = 6, SYSTEM_ERROR__NONCE_BLOCKHASH_NOT_EXPIRED = 7, SYSTEM_ERROR__NONCE_UNEXPECTED_BLOCKHASH_VALUE = 8, systemErrorMessages, TRANSFER_SOL_DISCRIMINATOR = 2;
var init_src = __esm(() => {
  init_index_node35();
  if (true) {
    systemErrorMessages = {
      [SYSTEM_ERROR__ACCOUNT_ALREADY_IN_USE]: `an account with the same address already exists`,
      [SYSTEM_ERROR__ADDRESS_WITH_SEED_MISMATCH]: `provided address does not match addressed derived from seed`,
      [SYSTEM_ERROR__INVALID_ACCOUNT_DATA_LENGTH]: `cannot allocate account data of this length`,
      [SYSTEM_ERROR__INVALID_PROGRAM_ID]: `cannot assign account to this program id`,
      [SYSTEM_ERROR__MAX_SEED_LENGTH_EXCEEDED]: `length of requested seed is too long`,
      [SYSTEM_ERROR__NONCE_BLOCKHASH_NOT_EXPIRED]: `stored nonce is still in recent_blockhashes`,
      [SYSTEM_ERROR__NONCE_NO_RECENT_BLOCKHASHES]: `advancing stored nonce requires a populated RecentBlockhashes sysvar`,
      [SYSTEM_ERROR__NONCE_UNEXPECTED_BLOCKHASH_VALUE]: `specified nonce does not match stored nonce`,
      [SYSTEM_ERROR__RESULT_WITH_NEGATIVE_LAMPORTS]: `account does not have enough SOL to perform the operation`
    };
  }
});

// ../packages/sdk-typescript/dist/index.js
var exports_dist = {};
__export(exports_dist, {
  withIPFSErrorHandling: () => withIPFSErrorHandling,
  withEnhancedErrorsSync: () => withEnhancedErrorsSync,
  withEnhancedErrors: () => withEnhancedErrors,
  wasmBridge: () => wasm_bridge_exports,
  verifyLocalPrivacyProof: () => verifyLocalPrivacyProof,
  verifyAuthorizationSignature: () => verifyAuthorizationSignature,
  validatePrivacySettings: () => validatePrivacySettings,
  validatePreconditions: () => validatePreconditions,
  validateInstructionAccounts: () => validateInstructionAccounts,
  validateDidString: () => validateDidString,
  validateAuthorizationNetwork: () => validateAuthorizationNetwork,
  validateAssociatedTokenAddress: () => validateAssociatedTokenAddress,
  validateAccountDiscriminator: () => validateAccountDiscriminator,
  unwrap: () => unwrap,
  sol: () => sol,
  simulateMigration: () => simulateMigration,
  signAuthorizationMessage: () => signAuthorizationMessage,
  serializeAuthorization: () => serializeAuthorization,
  safeDecodeAgent: () => safeDecodeAgent,
  runBatchDiagnostics: () => runBatchDiagnostics,
  runAccountDiagnostics: () => runAccountDiagnostics,
  payAIFetch: () => payAIFetch,
  parseTokenAmount: () => parseTokenAmount,
  parseDidString: () => parseDidString,
  logEnhancedError: () => logEnhancedError,
  loadWasmModule: () => loadWasmModule2,
  lamportsToSol: () => lamportsToSol,
  isWasmAvailable: () => isWasmAvailable,
  isToken2022Mint: () => isToken2022Mint,
  isSuccess: () => isSuccess,
  isPaymentRequired: () => isPaymentRequired,
  isKnownInstruction: () => isKnownInstruction,
  isIPFSError: () => isIPFSError,
  isFeatureEnabled: () => isFeatureEnabled,
  isError: () => isError,
  isDidActive: () => isDidActive,
  isAuthorizationExpired: () => isAuthorizationExpired,
  isAuthorizationExhausted: () => isAuthorizationExhausted,
  inspectAccountData: () => inspectAccountData,
  hasTransferFeeExtension: () => hasTransferFeeExtension,
  hasInterestBearingExtension: () => hasInterestBearingExtension,
  hasConfidentialTransferExtension: () => hasConfidentialTransferExtension,
  getWritableAccounts: () => getWritableAccounts,
  getUpdateReputationTagsInstructionAsync: () => getUpdateReputationTagsInstructionAsync,
  getUpdateDidDocumentInstructionAsync: () => getUpdateDidDocumentInstructionAsync,
  getUnstakeGhostInstructionAsync: () => getUnstakeGhostInstructionAsync,
  getTransferFeeConfig: () => getTransferFeeConfig,
  getTokenProgramType: () => getTokenProgramType,
  getTokenProgramFromAddress: () => getTokenProgramFromAddress,
  getTokenProgramAddress: () => getTokenProgramAddress,
  getTierDisplayName: () => getTierDisplayName,
  getSubmitDeliveryInstruction: () => getSubmitDeliveryInstruction,
  getStakingConfigDecoder: () => getStakingConfigDecoder,
  getStakingAccountDecoder: () => getStakingAccountDecoder,
  getStakeGhostInstructionAsync: () => getStakeGhostInstructionAsync,
  getSlashStakeInstructionAsync: () => getSlashStakeInstructionAsync,
  getScoreRange: () => getScoreRange,
  getResolveDidDocumentInstructionAsync: () => getResolveDidDocumentInstructionAsync,
  getRequiredSigners: () => getRequiredSigners,
  getReputationTier: () => getReputationTier,
  getRegisterAgentInstructionAsync: () => getRegisterAgentInstructionAsync,
  getRangeDisplayString: () => getRangeDisplayString,
  getPDAAccounts: () => getPDAAccounts,
  getNetworkFromDid: () => getNetworkFromDid,
  getMigrationInstructions: () => getMigrationInstructions,
  getMethodsForRelationship: () => getMethodsForRelationship,
  getInterestBearingConfig: () => getInterestBearingConfig,
  getInstructionMapping: () => getInstructionMapping,
  getInitializeStakingConfigInstructionAsync: () => getInitializeStakingConfigInstructionAsync,
  getIdentifierFromDid: () => getIdentifierFromDid,
  getGhostProtectEscrowDecoder: () => getGhostProtectEscrowDecoder,
  getFileDisputeInstruction: () => getFileDisputeInstruction,
  getFeatureFlags: () => getFeatureFlags,
  getDefaultMetricVisibility: () => getDefaultMetricVisibility,
  getDeactivateDidDocumentInstructionAsync: () => getDeactivateDidDocumentInstructionAsync,
  getCreateEscrowInstructionAsync: () => getCreateEscrowInstructionAsync,
  getCreateDidDocumentInstructionAsync: () => getCreateDidDocumentInstructionAsync,
  getConfidentialTransferConfig: () => getConfidentialTransferConfig,
  getAuthorizationId: () => getAuthorizationId,
  getAssociatedTokenAccount: () => getAssociatedTokenAccount,
  getArbitrateDisputeInstruction: () => getArbitrateDisputeInstruction,
  getApproveDeliveryInstruction: () => getApproveDeliveryInstruction,
  getAllAssociatedTokenAddresses: () => getAllAssociatedTokenAddresses,
  getAgentDecoder: () => getAgentDecoder,
  getAccountRequirements: () => getAccountRequirements,
  generateWithdrawProof: () => generateWithdrawProof,
  generateTransferProof: () => generateTransferProof,
  generateTestWebhookSignature: () => generateTestWebhookSignature,
  generateNonce: () => generateNonce,
  generateLocalPrivacyProof: () => generateLocalPrivacyProof,
  generateKeypair: () => generateKeypair,
  generateKeyPairSigner: () => generateKeyPairSigner,
  generateDidString: () => generateDidString,
  generateAccountValidationError: () => generateAccountValidationError,
  fundWallet: () => fundWallet,
  formatTokenAmount: () => formatTokenAmount,
  findProgramDerivedAddress: () => findProgramDerivedAddress,
  filterMetricsByVisibility: () => filterMetricsByVisibility,
  extractPaymentRequirements: () => extractPaymentRequirements,
  extractLegacyData: () => extractLegacyData,
  extractInstructionName: () => extractInstructionName,
  exportDiagnosticReport: () => exportDiagnosticReport,
  exportAsW3CDidDocument: () => exportAsW3CDidDocument,
  estimateStorageCost: () => estimateStorageCost,
  ensureMinimumBalance: () => ensureMinimumBalance,
  enhanceTransactionError: () => enhanceTransactionError,
  enhanceErrorMessage: () => enhanceErrorMessage,
  encrypt: () => encrypt,
  elgamal: () => elgamal_exports,
  didDocumentToJson: () => didDocumentToJson,
  diagnoseBatchFromChain: () => diagnoseBatchFromChain,
  diagnoseAccountFromChain: () => diagnoseAccountFromChain,
  determineStorageMethod: () => determineStorageMethod,
  detectTokenProgram: () => detectTokenProgram,
  deserializeAuthorization: () => deserializeAuthorization,
  deriveUserRegistryPda: () => deriveUserRegistryPda,
  deriveToken2022AssociatedTokenAddress: () => deriveToken2022AssociatedTokenAddress,
  deriveSplTokenAssociatedTokenAddress: () => deriveSplTokenAssociatedTokenAddress,
  deriveProposalPda: () => deriveProposalPda,
  deriveMultisigPda: () => deriveMultisigPda,
  deriveDidDocumentPda: () => deriveDidDocumentPda,
  deriveAssociatedTokenAddress: () => deriveAssociatedTokenAddress,
  deriveAgentVerificationPda: () => deriveAgentVerificationPda,
  deriveAgentPda: () => deriveAgentPda,
  defaultFundingService: () => defaultFundingService,
  default: () => GhostSpeakClient_default,
  decrypt: () => decrypt,
  debugInstructionCall: () => debugInstructionCall,
  createTestIPFSConfig: () => createTestIPFSConfig,
  createSolanaRpc: () => createSolanaRpc,
  createSignedAuthorization: () => createSignedAuthorization,
  createServiceEndpoint: () => createServiceEndpoint,
  createPrivacyManifest: () => createPrivacyManifest,
  createPayAIWebhookHandler: () => createPayAIWebhookHandler,
  createPayAIClient: () => createPayAIClient,
  createPayAIAgentSync: () => createPayAIAgentSync,
  createMockPayAIWebhook: () => createMockPayAIWebhook,
  createMigrationReport: () => createMigrationReport,
  createMigrationPlan: () => createMigrationPlan,
  createMetadataUri: () => createMetadataUri,
  createKeyPairSignerFromBytes: () => createKeyPairSignerFromBytes,
  createIPFSUtils: () => createIPFSUtils,
  createIPFSErrorHandler: () => createIPFSErrorHandler,
  createErrorContext: () => createErrorContext,
  createEd25519VerificationMethod: () => createEd25519VerificationMethod,
  createDiscriminatorErrorMessage: () => createDiscriminatorErrorMessage,
  createBatchFetcher: () => createBatchFetcher,
  createAuthorizationMessage: () => createAuthorizationMessage,
  createAccountMismatchError: () => createAccountMismatchError,
  clearFeatureGateCache: () => clearFeatureGateCache,
  checkFeatureGate: () => checkFeatureGate,
  canViewerAccess: () => canViewerAccess,
  canPerformAction: () => canPerformAction,
  calculateVisibleScore: () => calculateVisibleScore,
  batchGetExistingAccounts: () => batchGetExistingAccounts,
  batchGetAndMap: () => batchGetAndMap,
  batchGetAccountsWithRetry: () => batchGetAccountsWithRetry,
  batchGetAccounts: () => batchGetAccounts,
  address: () => address,
  X402TransactionIndexer: () => X402TransactionIndexer,
  WalletFundingService: () => WalletFundingService,
  VisibilityLevel: () => VisibilityLevel,
  VerificationRelationship: () => VerificationRelationship2,
  VerificationMethodType: () => VerificationMethodType2,
  ValidationError: () => ValidationError,
  UnifiedCredentialService: () => UnifiedCredentialService,
  TransactionFailedError: () => TransactionFailedError,
  TokenProgram: () => TokenProgram,
  TokenExtension: () => TokenExtension,
  TimeoutError: () => TimeoutError,
  TagConfidenceLevel: () => TagConfidenceLevel,
  TagCategory: () => TagCategory,
  TOKEN_PROGRAM_ADDRESS: () => TOKEN_PROGRAM_ADDRESS,
  TOKEN_2022_PROGRAM_ADDRESS: () => TOKEN_2022_PROGRAM_ADDRESS,
  TEST_IPFS_CONFIG: () => TEST_IPFS_CONFIG,
  TAG_CONSTANTS: () => TAG_CONSTANTS,
  SkillTag: () => SkillTag,
  SimulationFailedError: () => SimulationFailedError,
  ServiceEndpointType: () => ServiceEndpointType2,
  ScoreRange: () => ScoreRange,
  RpcClient: () => RpcClient,
  RetryHandler: () => RetryHandler,
  ReputationTier: () => ReputationTier2,
  ReputationTagEngine: () => ReputationTagEngine,
  ReputationSource: () => ReputationSource,
  ReputationModule: () => ReputationModule,
  REPUTATION_CONSTANTS: () => REPUTATION_CONSTANTS,
  ProposalStatus: () => ProposalStatus,
  PrivateMetadataStorage: () => PrivateMetadataStorage,
  PrivateDataQuery: () => PrivateDataQuery,
  PrivacyPresets: () => PrivacyPresets,
  PrivacyModule: () => PrivacyModule,
  PrivacyMode: () => PrivacyMode,
  PayAIWebhookHandler: () => PayAIWebhookHandler,
  PayAIClient: () => PayAIClient,
  PayAIAgentSync: () => PayAIAgentSync,
  ParticipantType: () => ParticipantType,
  PRIVACY_CONSTANTS: () => PRIVACY_CONSTANTS,
  NetworkError: () => NetworkError,
  NATIVE_MINT_ADDRESS: () => NATIVE_MINT_ADDRESS,
  MultisigModule: () => MultisigModule,
  MultiSourceAggregator: () => MultiSourceAggregator,
  MessageType: () => MessageType,
  LocalStorageProvider: () => LocalStorageProvider,
  InvalidInputError: () => InvalidInputError,
  InsufficientBalanceError: () => InsufficientBalanceError,
  InstructionValidationError: () => InstructionValidationError,
  InstructionBuilder: () => InstructionBuilder,
  IPFSUtils: () => IPFSUtils,
  IPFSProvider: () => IPFSProvider,
  IPFSOperationError: () => IPFSOperationError,
  IPFSErrorHandler: () => IPFSErrorHandler,
  IPFSClient: () => IPFSClient,
  INSTRUCTION_MAPPINGS: () => INSTRUCTION_MAPPINGS,
  GovernanceModule: () => GovernanceModule,
  GhostSpeakSDKError: () => GhostSpeakSDKError,
  GhostSpeakError: () => GhostSpeakError,
  GhostSpeakClient: () => GhostSpeakClient,
  GHOSTSPEAK_PROGRAM_ID: () => GHOSTSPEAK_PROGRAM_ID,
  GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS: () => GHOSTSPEAK_MARKETPLACE_PROGRAM_ADDRESS,
  GHOSTSPEAK_CREDENTIAL_TYPES: () => GHOSTSPEAK_CREDENTIAL_TYPES,
  FeatureFlagManager: () => FeatureFlagManager,
  FallbackHandler: () => FallbackHandler,
  FEATURE_GATES: () => FEATURE_GATES,
  EscrowStatus: () => EscrowStatus2,
  ErrorHandler: () => ErrorHandler,
  ErrorFactory: () => ErrorFactory,
  ErrorCode: () => ErrorCode,
  DidModule: () => DidModule,
  DidErrorClass: () => DidErrorClass,
  DidError: () => DidError,
  DEFAULT_TAG_DECAY: () => DEFAULT_TAG_DECAY,
  DEFAULT_RETRY_CONFIG: () => DEFAULT_RETRY_CONFIG,
  DEFAULT_IPFS_CONFIG: () => DEFAULT_IPFS_CONFIG,
  CrossmintVCClient: () => CrossmintVCClient,
  CredentialStatus: () => CredentialStatus2,
  CredentialModule: () => CredentialModule,
  CredentialKind: () => CredentialKind2,
  ComplianceTag: () => ComplianceTag,
  ClientEncryptionService: () => ClientEncryptionService,
  CircuitBreaker: () => CircuitBreaker,
  ChannelType: () => ChannelType,
  CacheManager: () => CacheManager,
  BehaviorTag: () => BehaviorTag,
  BaseReputationAdapter: () => BaseReputationAdapter,
  BaseModule: () => BaseModule,
  BadgeType: () => BadgeType,
  AuthorizationModule: () => AuthorizationModule,
  AgentType: () => AgentType,
  AgentModule: () => AgentModule,
  AccountNotFoundError: () => AccountNotFoundError,
  ASSOCIATED_TOKEN_PROGRAM_ADDRESS: () => ASSOCIATED_TOKEN_PROGRAM_ADDRESS
});
import { EventEmitter as EventEmitter2 } from "events";
import { timingSafeEqual, createHmac } from "crypto";
import { promises } from "fs";
import process2 from "process";
import os from "os";
import tty from "tty";
function createPayAIWebhookHandler(options2 = {}) {
  return new PayAIWebhookHandler(options2);
}
function generateTestWebhookSignature(body, secret, timestamp) {
  const ts = (timestamp ?? Date.now()).toString();
  const signedPayload = `${ts}.${body}`;
  const hmac = createHmac("sha256", secret);
  hmac.update(signedPayload);
  return {
    signature: hmac.digest("hex"),
    timestamp: ts
  };
}
function createMockPayAIWebhook(overrides = {}) {
  return {
    id: `evt_${Date.now()}`,
    type: "payment.settled",
    timestamp: (/* @__PURE__ */ new Date()).toISOString(),
    data: {
      paymentId: `pay_${Date.now()}`,
      transactionSignature: `${Math.random().toString(36).slice(2)}${Math.random().toString(36).slice(2)}`,
      network: "solana",
      payer: "PayerWalletAddress111111111111111111111111",
      merchant: "MerchantAgentAddress11111111111111111111",
      amount: "1000000",
      asset: "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
      assetSymbol: "USDC",
      status: "settled",
      resource: "https://api.example.com/ai/generate",
      responseTimeMs: 250,
      httpStatusCode: 200,
      success: true,
      settledAt: (/* @__PURE__ */ new Date()).toISOString(),
      ...overrides
    }
  };
}
function createPayAIAgentSync(config = {}) {
  return new PayAIAgentSync(config);
}
function createTestIPFSConfig(options2) {
  return {
    ...TEST_IPFS_CONFIG,
    ...options2,
    provider: {
      ...TEST_IPFS_CONFIG.provider,
      ...options2?.provider ?? {}
    }
  };
}
function createIPFSErrorHandler(config) {
  const handler = new IPFSErrorHandler(config?.retryConfig);
  if (config?.customFallbacks) {
    for (const { errorType, strategy } of config.customFallbacks) {
      handler.registerFallback(errorType, strategy);
    }
  }
  return handler;
}
function isIPFSError(error) {
  return error instanceof IPFSOperationError;
}
async function withIPFSErrorHandling(operation, context, errorHandler) {
  const handler = errorHandler ?? new IPFSErrorHandler;
  return handler.executeWithErrorHandling(async () => {
    try {
      const result = await operation();
      return { success: true, data: result };
    } catch (error) {
      const ipfsError = error instanceof IPFSOperationError ? error.type : "PROVIDER_ERROR";
      return {
        success: false,
        error: ipfsError,
        message: error instanceof Error ? error.message : String(error)
      };
    }
  }, context);
}
function assembleStyles() {
  const codes = /* @__PURE__ */ new Map;
  for (const [groupName, group] of Object.entries(styles)) {
    for (const [styleName, style] of Object.entries(group)) {
      styles[styleName] = {
        open: `\x1B[${style[0]}m`,
        close: `\x1B[${style[1]}m`
      };
      group[styleName] = styles[styleName];
      codes.set(style[0], style[1]);
    }
    Object.defineProperty(styles, groupName, {
      value: group,
      enumerable: false
    });
  }
  Object.defineProperty(styles, "codes", {
    value: codes,
    enumerable: false
  });
  styles.color.close = "\x1B[39m";
  styles.bgColor.close = "\x1B[49m";
  styles.color.ansi = wrapAnsi16();
  styles.color.ansi256 = wrapAnsi256();
  styles.color.ansi16m = wrapAnsi16m();
  styles.bgColor.ansi = wrapAnsi16(ANSI_BACKGROUND_OFFSET);
  styles.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
  styles.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);
  Object.defineProperties(styles, {
    rgbToAnsi256: {
      value(red, green, blue) {
        if (red === green && green === blue) {
          if (red < 8) {
            return 16;
          }
          if (red > 248) {
            return 231;
          }
          return Math.round((red - 8) / 247 * 24) + 232;
        }
        return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5);
      },
      enumerable: false
    },
    hexToRgb: {
      value(hex) {
        const matches = /[a-f\d]{6}|[a-f\d]{3}/i.exec(hex.toString(16));
        if (!matches) {
          return [0, 0, 0];
        }
        let [colorString] = matches;
        if (colorString.length === 3) {
          colorString = [...colorString].map((character) => character + character).join("");
        }
        const integer = Number.parseInt(colorString, 16);
        return [
          integer >> 16 & 255,
          integer >> 8 & 255,
          integer & 255
        ];
      },
      enumerable: false
    },
    hexToAnsi256: {
      value: (hex) => styles.rgbToAnsi256(...styles.hexToRgb(hex)),
      enumerable: false
    },
    ansi256ToAnsi: {
      value(code) {
        if (code < 8) {
          return 30 + code;
        }
        if (code < 16) {
          return 90 + (code - 8);
        }
        let red;
        let green;
        let blue;
        if (code >= 232) {
          red = ((code - 232) * 10 + 8) / 255;
          green = red;
          blue = red;
        } else {
          code -= 16;
          const remainder = code % 36;
          red = Math.floor(code / 36) / 5;
          green = Math.floor(remainder / 6) / 5;
          blue = remainder % 6 / 5;
        }
        const value = Math.max(red, green, blue) * 2;
        if (value === 0) {
          return 30;
        }
        let result = 30 + (Math.round(blue) << 2 | Math.round(green) << 1 | Math.round(red));
        if (value === 2) {
          result += 60;
        }
        return result;
      },
      enumerable: false
    },
    rgbToAnsi: {
      value: (red, green, blue) => styles.ansi256ToAnsi(styles.rgbToAnsi256(red, green, blue)),
      enumerable: false
    },
    hexToAnsi: {
      value: (hex) => styles.ansi256ToAnsi(styles.hexToAnsi256(hex)),
      enumerable: false
    }
  });
  return styles;
}
function hasFlag(flag, argv = globalThis.Deno ? globalThis.Deno.args : process2.argv) {
  const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
  const position = argv.indexOf(prefix + flag);
  const terminatorPosition = argv.indexOf("--");
  return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
}
function envForceColor() {
  if ("FORCE_COLOR" in env) {
    if (env.FORCE_COLOR === "true") {
      return 1;
    }
    if (env.FORCE_COLOR === "false") {
      return 0;
    }
    return env.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(env.FORCE_COLOR, 10), 3);
  }
}
function translateLevel(level) {
  if (level === 0) {
    return false;
  }
  return {
    level,
    hasBasic: true,
    has256: level >= 2,
    has16m: level >= 3
  };
}
function _supportsColor(haveStream, { streamIsTTY, sniffFlags = true } = {}) {
  const noFlagForceColor = envForceColor();
  if (noFlagForceColor !== undefined) {
    flagForceColor = noFlagForceColor;
  }
  const forceColor = sniffFlags ? flagForceColor : noFlagForceColor;
  if (forceColor === 0) {
    return 0;
  }
  if (sniffFlags) {
    if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
      return 3;
    }
    if (hasFlag("color=256")) {
      return 2;
    }
  }
  if ("TF_BUILD" in env && "AGENT_NAME" in env) {
    return 1;
  }
  if (haveStream && !streamIsTTY && forceColor === undefined) {
    return 0;
  }
  const min = forceColor || 0;
  if (env.TERM === "dumb") {
    return min;
  }
  if (process2.platform === "win32") {
    const osRelease = os.release().split(".");
    if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
      return Number(osRelease[2]) >= 14931 ? 3 : 2;
    }
    return 1;
  }
  if ("CI" in env) {
    if (["GITHUB_ACTIONS", "GITEA_ACTIONS", "CIRCLECI"].some((key) => (key in env))) {
      return 3;
    }
    if (["TRAVIS", "APPVEYOR", "GITLAB_CI", "BUILDKITE", "DRONE"].some((sign) => (sign in env)) || env.CI_NAME === "codeship") {
      return 1;
    }
    return min;
  }
  if ("TEAMCITY_VERSION" in env) {
    return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
  }
  if (env.COLORTERM === "truecolor") {
    return 3;
  }
  if (env.TERM === "xterm-kitty") {
    return 3;
  }
  if (env.TERM === "xterm-ghostty") {
    return 3;
  }
  if (env.TERM === "wezterm") {
    return 3;
  }
  if ("TERM_PROGRAM" in env) {
    const version = Number.parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
    switch (env.TERM_PROGRAM) {
      case "iTerm.app": {
        return version >= 3 ? 3 : 2;
      }
      case "Apple_Terminal": {
        return 2;
      }
    }
  }
  if (/-256(color)?$/i.test(env.TERM)) {
    return 2;
  }
  if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
    return 1;
  }
  if ("COLORTERM" in env) {
    return 1;
  }
  return min;
}
function createSupportsColor(stream, options2 = {}) {
  const level = _supportsColor(stream, {
    streamIsTTY: stream && stream.isTTY,
    ...options2
  });
  return translateLevel(level);
}
function stringReplaceAll(string, substring, replacer) {
  let index = string.indexOf(substring);
  if (index === -1) {
    return string;
  }
  const substringLength = substring.length;
  let endIndex = 0;
  let returnValue = "";
  do {
    returnValue += string.slice(endIndex, index) + substring + replacer;
    endIndex = index + substringLength;
    index = string.indexOf(substring, endIndex);
  } while (index !== -1);
  returnValue += string.slice(endIndex);
  return returnValue;
}
function stringEncaseCRLFWithFirstIndex(string, prefix, postfix, index) {
  let endIndex = 0;
  let returnValue = "";
  do {
    const gotCR = string[index - 1] === "\r";
    returnValue += string.slice(endIndex, gotCR ? index - 1 : index) + prefix + (gotCR ? `\r
` : `
`) + postfix;
    endIndex = index + 1;
    index = string.indexOf(`
`, endIndex);
  } while (index !== -1);
  returnValue += string.slice(endIndex);
  return returnValue;
}
function createChalk(options2) {
  return chalkFactory(options2);
}
async function fundWallet(wallet, amountInSol, options2) {
  return defaultFundingService.fundWallet(wallet, {
    amount: BigInt(Math.floor(amountInSol * 1e9)),
    ...options2
  });
}
async function ensureMinimumBalance(wallet, minBalanceInSol, options2) {
  return defaultFundingService.ensureMinimumBalance(wallet, BigInt(Math.floor(minBalanceInSol * 1e9)), options2);
}
function estimateStorageCost(dataSize, provider) {
  if (provider === "ipfs") {
    return {
      cost: BigInt(Number(dataSize) * 1),
      currency: "lamports"
    };
  } else {
    return {
      cost: BigInt(Number(dataSize) * 10),
      currency: "lamports"
    };
  }
}
function createPrivacyManifest(dataTypes, options2 = {}) {
  return {
    dataTypes,
    encryptionMethod: options2.encryptionMethod ?? "elgamal",
    storageLocation: options2.storageLocation ?? "ipfs",
    retentionPeriod: options2.retentionPeriod,
    accessControl: options2.accessControl ?? "owner-only"
  };
}
async function checkFeatureGate(rpc2, featureGate) {
  const featureId = featureGate;
  const cached = featureCache.get(featureId);
  if (cached) {
    return cached;
  }
  try {
    const response = await rpc2.getAccountInfo(featureGate, { encoding: "base64" }).send();
    const accountInfo = response.value;
    const activated = accountInfo !== null;
    const status = {
      activated,
      lastChecked: Date.now()
    };
    if (accountInfo?.data) {
      try {
        const dataString = typeof accountInfo.data === "string" ? accountInfo.data : accountInfo.data[0];
        const dataBuffer = Buffer.from(dataString, "base64");
        const activationSlot = BigInt(dataBuffer.readBigUInt64LE(0));
        status.activationSlot = activationSlot;
      } catch {}
    }
    featureCache.set(featureId, status);
    return status;
  } catch (error) {
    const errorStatus = {
      activated: false,
      lastChecked: Date.now(),
      error: error instanceof Error ? error.message : "Unknown error"
    };
    featureCache.set(featureId, errorStatus);
    return errorStatus;
  }
}
function clearFeatureGateCache() {
  featureCache.clear();
}
var X402TransactionIndexer = class {
  rpc;
  facilitatorAddress;
  network;
  batchSize;
  constructor(config) {
    this.rpc = config.rpc;
    this.facilitatorAddress = config.facilitatorAddress;
    this.network = config.network || "solana";
    this.batchSize = config.batchSize || 100;
  }
  async pollTransactions(lastSignature, limit) {
    try {
      const signatures = await this.getSignatures(lastSignature, limit);
      if (signatures.length === 0) {
        return [];
      }
      console.log(`[X402 Indexer] Found ${signatures.length} new transactions`);
      const payments = [];
      for (const sig of signatures) {
        try {
          const payment = await this.parseTransaction(sig.signature);
          if (payment) {
            payments.push(payment);
          }
        } catch (error) {
          console.error(`[X402 Indexer] Failed to parse transaction ${sig.signature}:`, error);
        }
      }
      console.log(`[X402 Indexer] Parsed ${payments.length} x402 payments`);
      return payments;
    } catch (error) {
      console.error("[X402 Indexer] Failed to poll transactions:", error);
      throw error;
    }
  }
  async parseTransaction(sig) {
    try {
      const txSignature = typeof sig === "string" ? sig : sig;
      const response = await this.rpc.getTransaction(txSignature, {
        maxSupportedTransactionVersion: 0,
        encoding: "jsonParsed"
      }).send();
      if (!response || !response.transaction) {
        return null;
      }
      const isX402 = this.isX402Payment(response);
      if (!isX402) {
        return null;
      }
      return this.extractPaymentData(response, typeof sig === "string" ? sig : String(sig));
    } catch (error) {
      console.error(`[X402 Indexer] Failed to fetch transaction ${sig}:`, error);
      return null;
    }
  }
  async getSignatures(before, limit) {
    try {
      const config = {
        limit: limit || this.batchSize
      };
      if (before) {
        config.before = before;
      }
      const response = await this.rpc.getSignaturesForAddress(this.facilitatorAddress, config).send();
      return response.map((sig) => ({
        signature: sig.signature,
        slot: sig.slot,
        blockTime: sig.blockTime,
        err: sig.err ?? null
      }));
    } catch (error) {
      console.error("[X402 Indexer] Failed to fetch signatures:", error);
      throw error;
    }
  }
  isX402Payment(transaction) {
    try {
      const instructions2 = transaction.transaction?.message?.instructions || [];
      const hasTokenTransfer = instructions2.some((ix) => {
        const programId = ix.programId?.toString();
        const isTokenProgram = programId === "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA" || programId === "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb";
        if (!isTokenProgram)
          return false;
        const parsed = ix.parsed;
        if (parsed?.type === "transfer" || parsed?.type === "transferChecked") {
          const destination = parsed.info?.destination;
          return destination === this.facilitatorAddress.toString();
        }
        return false;
      });
      return hasTokenTransfer;
    } catch (error) {
      console.error("[X402 Indexer] Error checking if x402 payment:", error);
      return false;
    }
  }
  extractPaymentData(transaction, signature2) {
    try {
      const instructions2 = transaction.transaction?.message?.instructions || [];
      const transferIx = instructions2.find((ix) => {
        const parsed = ix.parsed;
        return parsed?.type === "transfer" || parsed?.type === "transferChecked";
      });
      if (!transferIx) {
        return null;
      }
      const transferInfo = transferIx.parsed.info;
      const merchant = transferInfo.destination;
      const payer = transferInfo.source;
      const amount = transferInfo.amount || transferInfo.tokenAmount?.amount || "0";
      const success = transaction.meta?.err === null;
      const blockTime = transaction.blockTime;
      const timestamp = blockTime ? new Date(blockTime * 1000) : /* @__PURE__ */ new Date;
      const memoIx = instructions2.find((ix) => ix.programId?.toString()?.includes("Memo"));
      let responseTimeMs;
      let metadata;
      if (memoIx && memoIx.data) {
        try {
          const memoText = Buffer.from(memoIx.data, "base64").toString("utf-8");
          const memoData = JSON.parse(memoText);
          responseTimeMs = memoData.responseTimeMs;
          metadata = memoData;
        } catch {}
      }
      return {
        signature: signature2,
        merchant,
        payer,
        amount,
        success,
        timestamp,
        network: this.network,
        responseTimeMs,
        metadata
      };
    } catch (error) {
      console.error("[X402 Indexer] Failed to extract payment data:", error);
      return null;
    }
  }
}, TIMESTAMP_TOLERANCE_MS, SIGNATURE_HEADER = "x-payai-signature", TIMESTAMP_HEADER = "x-payai-timestamp", PayAIWebhookHandler, DEFAULT_MARKETPLACE_URL = "https://marketplace.payai.network/api", PayAIAgentSync, TEST_IPFS_CONFIG, IPFSOperationError, DEFAULT_RETRY_CONFIG, CircuitBreaker = class {
  constructor(failureThreshold = 5, recoveryTime = 30000) {
    this.failureThreshold = failureThreshold;
    this.recoveryTime = recoveryTime;
  }
  failures = 0;
  lastFailureTime = 0;
  state = "CLOSED";
  async execute(operation) {
    if (this.state === "OPEN") {
      if (Date.now() - this.lastFailureTime > this.recoveryTime) {
        this.state = "HALF_OPEN";
      } else {
        throw new Error("Circuit breaker is OPEN - too many failures");
      }
    }
    try {
      const result = await operation();
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      throw error;
    }
  }
  onSuccess() {
    this.failures = 0;
    this.state = "CLOSED";
  }
  onFailure() {
    this.failures++;
    this.lastFailureTime = Date.now();
    if (this.failures >= this.failureThreshold) {
      this.state = "OPEN";
    }
  }
  getState() {
    return {
      state: this.state,
      failures: this.failures,
      lastFailureTime: this.lastFailureTime
    };
  }
  reset() {
    this.failures = 0;
    this.lastFailureTime = 0;
    this.state = "CLOSED";
  }
}, RetryHandler = class {
  constructor(config = DEFAULT_RETRY_CONFIG) {
    this.config = config;
    this.circuitBreaker = new CircuitBreaker;
  }
  circuitBreaker;
  async execute(operation, context) {
    return this.circuitBreaker.execute(async () => {
      let lastError;
      for (let attempt = 0;attempt <= this.config.maxRetries; attempt++) {
        try {
          const result = await operation();
          if (attempt > 0) {
            console.log(` Operation succeeded after ${attempt} retries${context ? ` (${context})` : ""}`);
          }
          return result;
        } catch (error) {
          lastError = error instanceof Error ? error : new Error(String(error));
          if (attempt === this.config.maxRetries) {
            break;
          }
          const shouldRetry = this.shouldRetry(lastError, attempt);
          if (!shouldRetry) {
            console.log(` Error not retryable${context ? ` (${context})` : ""}:`, lastError.message);
            break;
          }
          const delay = this.calculateDelay(attempt);
          console.log(` Retrying in ${delay}ms... (attempt ${attempt + 1}/${this.config.maxRetries}${context ? `, ${context}` : ""})`);
          await new Promise((resolve) => setTimeout(resolve, delay));
        }
      }
      throw new IPFSOperationError(this.categorizeError(lastError), `Operation failed after ${this.config.maxRetries + 1} attempts${context ? ` (${context})` : ""}: ${lastError.message}`, undefined, this.config.maxRetries);
    });
  }
  shouldRetry(error, attempt) {
    if (attempt >= this.config.maxRetries) {
      return false;
    }
    const errorType = this.categorizeError(error);
    return this.config.retryableErrors.includes(errorType);
  }
  calculateDelay(attempt) {
    const exponentialDelay = this.config.baseDelay * Math.pow(this.config.backoffFactor, attempt);
    const jitter = Math.random() * 0.1 * exponentialDelay;
    return Math.min(exponentialDelay + jitter, this.config.maxDelay);
  }
  categorizeError(error) {
    const message = error.message.toLowerCase();
    if (message.includes("timeout")) {
      return "TIMEOUT_ERROR";
    }
    if (message.includes("network")) {
      return "NETWORK_ERROR";
    }
    if (message.includes("unauthorized")) {
      return "AUTHENTICATION_FAILED";
    }
    if (message.includes("quota")) {
      return "QUOTA_EXCEEDED";
    }
    if (message.includes("invalid") && message.includes("hash")) {
      return "INVALID_HASH";
    }
    if (message.includes("too large")) {
      return "CONTENT_TOO_LARGE";
    }
    return "PROVIDER_ERROR";
  }
  getStats() {
    return {
      circuitBreakerState: this.circuitBreaker.getState(),
      config: this.config
    };
  }
  reset() {
    this.circuitBreaker.reset();
  }
}, FallbackHandler = class {
  fallbackStrategies = /* @__PURE__ */ new Map;
  constructor() {
    this.setupDefaultFallbacks();
  }
  setupDefaultFallbacks() {
    this.fallbackStrategies.set("UPLOAD_FAILED", async (error) => {
      console.log("\uD83D\uDD04 Upload failed, attempting inline storage fallback...");
      throw error;
    });
    this.fallbackStrategies.set("RETRIEVAL_FAILED", async (error) => {
      console.log("\uD83D\uDD04 Retrieval failed, trying alternative gateways...");
      throw error;
    });
    this.fallbackStrategies.set("QUOTA_EXCEEDED", async (error) => {
      console.warn(" IPFS quota exceeded - consider upgrading plan or cleaning up old content");
      throw error;
    });
  }
  async handleError(error, fallbackValue) {
    const strategy = this.fallbackStrategies.get(error.type);
    if (strategy) {
      try {
        const result = await strategy(error);
        return result;
      } catch (_fallbackError) {
        console.warn("Fallback strategy also failed:", _fallbackError instanceof Error ? _fallbackError.message : String(_fallbackError));
      }
    }
    if (fallbackValue !== undefined) {
      console.log("Using provided fallback value");
      return fallbackValue;
    }
    throw error;
  }
  registerFallback(errorType, strategy) {
    this.fallbackStrategies.set(errorType, strategy);
  }
}, IPFSErrorHandler = class {
  retryHandler;
  fallbackHandler;
  constructor(retryConfig) {
    this.retryHandler = new RetryHandler({ ...DEFAULT_RETRY_CONFIG, ...retryConfig });
    this.fallbackHandler = new FallbackHandler;
  }
  async executeWithErrorHandling(operation, context, fallbackValue) {
    try {
      const result = await this.retryHandler.execute(async () => {
        const opResult = await operation();
        if (!opResult.success && opResult.error) {
          throw new IPFSOperationError(opResult.error, opResult.message ?? `IPFS operation failed: ${opResult.error}`);
        }
        return opResult;
      }, context);
      return result;
    } catch (error) {
      const ipfsError = error instanceof IPFSOperationError ? error : new IPFSOperationError("PROVIDER_ERROR", error instanceof Error ? error.message : String(error));
      try {
        const fallbackResult = await this.fallbackHandler.handleError(ipfsError, fallbackValue);
        return {
          success: true,
          data: fallbackResult,
          message: "Operation succeeded using fallback strategy"
        };
      } catch {
        return {
          success: false,
          error: ipfsError.type,
          message: ipfsError.message,
          duration: 0
        };
      }
    }
  }
  registerFallback(errorType, strategy) {
    this.fallbackHandler.registerFallback(errorType, strategy);
  }
  getStats() {
    return {
      retryStats: this.retryHandler.getStats(),
      registeredFallbacks: Array.from(this.fallbackHandler["fallbackStrategies"].keys())
    };
  }
  reset() {
    this.retryHandler.reset();
  }
}, ANSI_BACKGROUND_OFFSET = 10, wrapAnsi16 = (offset = 0) => (code) => `\x1B[${code + offset}m`, wrapAnsi256 = (offset = 0) => (code) => `\x1B[${38 + offset};5;${code}m`, wrapAnsi16m = (offset = 0) => (red, green, blue) => `\x1B[${38 + offset};2;${red};${green};${blue}m`, styles, foregroundColorNames, backgroundColorNames, ansiStyles, ansi_styles_default, env, flagForceColor, supportsColor, supports_color_default, stdoutColor, stderrColor, GENERATOR, STYLER, IS_EMPTY, levelMapping, styles2, applyOptions = (object, options2 = {}) => {
  if (options2.level && !(Number.isInteger(options2.level) && options2.level >= 0 && options2.level <= 3)) {
    throw new Error("The `level` option should be an integer from 0 to 3");
  }
  const colorLevel = stdoutColor ? stdoutColor.level : 0;
  object.level = options2.level === undefined ? colorLevel : options2.level;
}, chalkFactory = (options2) => {
  const chalk2 = (...strings) => strings.join(" ");
  applyOptions(chalk2, options2);
  Object.setPrototypeOf(chalk2, createChalk.prototype);
  return chalk2;
}, getModelAnsi = (model, level, type, ...arguments_) => {
  if (model === "rgb") {
    if (level === "ansi16m") {
      return ansi_styles_default[type].ansi16m(...arguments_);
    }
    if (level === "ansi256") {
      return ansi_styles_default[type].ansi256(ansi_styles_default.rgbToAnsi256(...arguments_));
    }
    return ansi_styles_default[type].ansi(ansi_styles_default.rgbToAnsi(...arguments_));
  }
  if (model === "hex") {
    return getModelAnsi("rgb", level, type, ...ansi_styles_default.hexToRgb(...arguments_));
  }
  return ansi_styles_default[type][model](...arguments_);
}, usedModels, proto, createStyler = (open, close, parent) => {
  let openAll;
  let closeAll;
  if (parent === undefined) {
    openAll = open;
    closeAll = close;
  } else {
    openAll = parent.openAll + open;
    closeAll = close + parent.closeAll;
  }
  return {
    open,
    close,
    openAll,
    closeAll,
    parent
  };
}, createBuilder = (self2, _styler, _isEmpty) => {
  const builder = (...arguments_) => applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
  Object.setPrototypeOf(builder, proto);
  builder[GENERATOR] = self2;
  builder[STYLER] = _styler;
  builder[IS_EMPTY] = _isEmpty;
  return builder;
}, applyStyle = (self2, string) => {
  if (self2.level <= 0 || !string) {
    return self2[IS_EMPTY] ? "" : string;
  }
  let styler = self2[STYLER];
  if (styler === undefined) {
    return string;
  }
  const { openAll, closeAll } = styler;
  if (string.includes("\x1B")) {
    while (styler !== undefined) {
      string = stringReplaceAll(string, styler.close, styler.open);
      styler = styler.parent;
    }
  }
  const lfIndex = string.indexOf(`
`);
  if (lfIndex !== -1) {
    string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
  }
  return openAll + string + closeAll;
}, chalk, source_default, WalletFundingService = class {
  rpc;
  commitment = "confirmed";
  isDevnetUrl;
  constructor(rpcUrl, commitment = "confirmed") {
    this.isDevnetUrl = rpcUrl.includes("devnet");
    this.rpc = createSolanaRpc(rpcUrl);
    this.commitment = commitment;
  }
  async fundWallet(targetWallet, options2) {
    const {
      amount,
      minAmount = amount,
      maxRetries = 3,
      retryDelay = 2000,
      useTreasury = true,
      treasuryWallet,
      fundedWallets = [],
      verbose = false
    } = options2;
    const log = (message) => {
      if (verbose) {
        console.log(source_default.gray(`[WalletFunding] ${message}`));
      }
    };
    let attempts = 0;
    try {
      const currentBalance = await this.getBalance(targetWallet);
      log(`Current balance: ${this.formatSol(currentBalance)} SOL`);
      if (currentBalance >= minAmount) {
        log(`Wallet already has sufficient balance`);
        return {
          success: true,
          balance: currentBalance,
          method: "existing",
          attempts: 0
        };
      }
      const needed = amount - currentBalance;
      log(`Need to fund: ${this.formatSol(needed)} SOL`);
      if (this.isDevnetUrl && "requestAirdrop" in this.rpc) {
        log(`Attempting devnet airdrop...`);
        const airdropResult = await this.tryAirdrop(targetWallet, needed, maxRetries, retryDelay, verbose);
        if (airdropResult.success) {
          const finalBalance = await this.getBalance(targetWallet);
          return {
            success: true,
            balance: finalBalance,
            method: "airdrop",
            attempts: airdropResult.attempts,
            signature: airdropResult.signature
          };
        }
        attempts += airdropResult.attempts;
        log(`Airdrop failed after ${airdropResult.attempts} attempts`);
      }
      if (useTreasury && treasuryWallet) {
        log(`Attempting treasury wallet funding...`);
        const treasuryResult = await this.tryTreasuryFunding(targetWallet, needed, treasuryWallet, verbose);
        if (treasuryResult.success) {
          const finalBalance = await this.getBalance(targetWallet);
          return {
            success: true,
            balance: finalBalance,
            method: "treasury",
            attempts: attempts + 1,
            signature: treasuryResult.signature
          };
        }
        attempts++;
        log(`Treasury funding failed: ${treasuryResult.error}`);
      }
      for (const fundedWallet of fundedWallets) {
        log(`Attempting funding from additional wallet...`);
        const fundedResult = await this.tryFundedWalletTransfer(targetWallet, needed, fundedWallet, verbose);
        if (fundedResult.success) {
          const finalBalance = await this.getBalance(targetWallet);
          return {
            success: true,
            balance: finalBalance,
            method: "funded-wallet",
            attempts: attempts + 1,
            signature: fundedResult.signature
          };
        }
        attempts++;
        log(`Funded wallet transfer failed: ${fundedResult.error}`);
      }
      throw new Error("All funding strategies failed");
    } catch (error) {
      return {
        success: false,
        balance: await this.getBalance(targetWallet),
        method: "airdrop",
        attempts,
        error: error instanceof Error ? error.message : "Unknown error"
      };
    }
  }
  async tryAirdrop(targetWallet, amount, maxRetries, retryDelay, verbose) {
    if (!("requestAirdrop" in this.rpc)) {
      return {
        success: false,
        attempts: 0,
        error: "Airdrop not available on this network"
      };
    }
    let attempts = 0;
    for (let i = 0;i < maxRetries; i++) {
      attempts++;
      try {
        const airdropResponse = await this.rpc.requestAirdrop(targetWallet, lamports(amount), { commitment: this.commitment }).send();
        const signature2 = airdropResponse;
        if (verbose) {
          console.log(source_default.gray(`[WalletFunding] Airdrop requested: ${signature2}`));
        }
        await this.rpc.getLatestBlockhash().send();
        let confirmed = false;
        const maxAttempts = 30;
        for (let i2 = 0;i2 < maxAttempts; i2++) {
          const statusResponse = await this.rpc.getSignatureStatuses([signature2]).send();
          const status = statusResponse.value[0];
          if (status && status.confirmationStatus === "confirmed") {
            confirmed = true;
            break;
          }
          await new Promise((resolve) => setTimeout(resolve, 1000));
        }
        await new Promise((resolve) => setTimeout(resolve, 1000));
        if (!confirmed) {
          throw new Error("Airdrop confirmation timeout");
        }
        return {
          success: true,
          attempts,
          signature: signature2
        };
      } catch (error) {
        if (verbose) {
          console.log(source_default.gray(`[WalletFunding] Airdrop attempt ${attempts} failed: ${error}`));
        }
        if (i < maxRetries - 1) {
          await new Promise((resolve) => setTimeout(resolve, retryDelay));
        }
      }
    }
    return {
      success: false,
      attempts,
      error: "Max retries exceeded"
    };
  }
  async tryTreasuryFunding(targetWallet, amount, treasuryWallet, verbose) {
    try {
      const treasurySigner = await this.loadWallet(treasuryWallet);
      const treasuryBalance = await this.getBalance(treasurySigner.address);
      if (verbose) {
        console.log(source_default.gray(`[WalletFunding] Treasury balance: ${this.formatSol(treasuryBalance)} SOL`));
      }
      if (treasuryBalance < amount + BigInt(5000)) {
        return {
          success: false,
          error: "Insufficient treasury balance"
        };
      }
      const signature2 = await this.transferSol(treasurySigner, targetWallet, amount, verbose);
      return {
        success: true,
        signature: signature2
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error"
      };
    }
  }
  async tryFundedWalletTransfer(targetWallet, amount, fundedWallet, verbose) {
    try {
      const signer = await this.loadWallet(fundedWallet);
      const balance = await this.getBalance(signer.address);
      if (verbose) {
        console.log(source_default.gray(`[WalletFunding] Funded wallet balance: ${this.formatSol(balance)} SOL`));
      }
      if (balance < amount + BigInt(5000)) {
        return {
          success: false,
          error: "Insufficient wallet balance"
        };
      }
      const signature2 = await this.transferSol(signer, targetWallet, amount, verbose);
      return {
        success: true,
        signature: signature2
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error"
      };
    }
  }
  async transferSol(from, to, amount, verbose) {
    const { value: latestBlockhash } = await this.rpc.getLatestBlockhash().send();
    const transferInstruction = getTransferSolInstruction({
      source: from,
      destination: to,
      amount
    });
    const message = pipe(createTransactionMessage({ version: 0 }), (tx) => setTransactionMessageFeePayer(from.address, tx), (tx) => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx), (tx) => appendTransactionMessageInstructions([transferInstruction], tx));
    const signedTransaction = await signTransactionMessageWithSigners(message);
    const base64Transaction = getBase64EncodedWireTransaction(signedTransaction);
    const sendResult = await this.rpc.sendTransaction(base64Transaction, {
      skipPreflight: false,
      preflightCommitment: this.commitment,
      maxRetries: BigInt(5)
    }).send();
    const signature2 = sendResult;
    if (verbose) {
      console.log(source_default.gray(`[WalletFunding] Transfer sent: ${signature2}`));
    }
    let confirmed = false;
    const maxAttempts = 30;
    for (let i = 0;i < maxAttempts; i++) {
      const statusResponse = await this.rpc.getSignatureStatuses([signature2]).send();
      const status = statusResponse.value[0];
      if (status && status.confirmationStatus === "confirmed") {
        confirmed = true;
        break;
      }
      await new Promise((resolve) => setTimeout(resolve, 1000));
    }
    if (!confirmed) {
      throw new Error("Transaction confirmation timeout");
    }
    return signature2;
  }
  async loadWallet(walletSource) {
    if (typeof walletSource !== "string") {
      return walletSource;
    }
    const envValue = process.env[walletSource];
    if (envValue) {
      try {
        const walletData2 = JSON.parse(envValue);
        return await createKeyPairSignerFromBytes(new Uint8Array(walletData2));
      } catch {
        try {
          const privateKeyBytes = esm_default2.decode(envValue);
          if (privateKeyBytes.length === 32 || privateKeyBytes.length === 64) {
            return await createKeyPairSignerFromBytes(privateKeyBytes);
          }
          throw new Error("Invalid base58 private key length");
        } catch (error) {
          throw new Error(`Failed to load wallet from base58 key: ${error instanceof Error ? error.message : "Unknown error"}`);
        }
      }
    }
    const walletData = JSON.parse(await promises.readFile(walletSource, "utf-8"));
    return createKeyPairSignerFromBytes(new Uint8Array(walletData));
  }
  static async loadWalletFromBase58(base58PrivateKey) {
    try {
      const privateKeyBytes = esm_default2.decode(base58PrivateKey);
      if (privateKeyBytes.length === 32 || privateKeyBytes.length === 64) {
        return await createKeyPairSignerFromBytes(privateKeyBytes);
      }
      throw new Error(`Invalid private key length: ${privateKeyBytes.length} bytes. Expected 32 or 64 bytes.`);
    } catch (error) {
      if (error instanceof Error && error.message.includes("Invalid private key length")) {
        throw error;
      }
      throw new Error(`Failed to decode base58 private key: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  async getBalance(wallet) {
    const response = await this.rpc.getBalance(wallet, { commitment: this.commitment }).send();
    return response.value;
  }
  async isDevnet() {
    try {
      const response = await this.rpc.getGenesisHash().send();
      return await Promise.resolve(response === "EtWTRABZaYq6iMfeYKouRu166VU2xqa1wcaWoxPkrZBG");
    } catch {
      return false;
    }
  }
  formatSol(lamports2) {
    return (Number(lamports2) / 1e9).toFixed(4);
  }
  async createAndFundTestWallets(count, amountPerWallet, options2) {
    const wallets = [];
    console.log(source_default.cyan(`Creating and funding ${count} test wallets...`));
    for (let i = 0;i < count; i++) {
      const wallet = await generateKeyPairSigner();
      console.log(source_default.gray(`Wallet ${i + 1}: ${wallet.address}`));
      const result = await this.fundWallet(wallet.address, {
        ...options2,
        amount: amountPerWallet
      });
      if (result.success) {
        wallets.push(wallet);
        console.log(source_default.green(` Funded with ${this.formatSol(result.balance)} SOL via ${result.method}`));
      } else {
        console.log(source_default.red(` Failed to fund: ${result.error}`));
      }
    }
    return wallets;
  }
  async ensureMinimumBalance(wallet, minBalance, options2) {
    const currentBalance = await this.getBalance(wallet);
    if (currentBalance >= minBalance) {
      return {
        success: true,
        balance: currentBalance,
        method: "existing",
        attempts: 0
      };
    }
    const needed = minBalance - currentBalance;
    return this.fundWallet(wallet, {
      amount: needed,
      minAmount: minBalance,
      ...options2
    });
  }
}, defaultFundingService, IPFSProvider = class {
  client;
  isPrivateNetwork;
  constructor(options2) {
    const createClient = __require2("kubo-rpc-client").create;
    const ipfsNodeUrl = options2?.ipfsNodeUrl || "http://localhost:5001";
    const headers = options2?.headers || {};
    this.isPrivateNetwork = options2?.usePrivateNetwork || false;
    try {
      new URL(ipfsNodeUrl);
    } catch (error) {
      throw new Error(`Invalid IPFS node URL provided: ${ipfsNodeUrl}`);
    }
    if (!this.isPrivateNetwork && ipfsNodeUrl.includes("localhost")) {
      console.warn("SECURITY WARNING: Using localhost IPFS node in production. Consider using a private IPFS network.");
    }
    if (typeof headers !== "object" || headers === null) {
      throw new Error("Headers must be a valid object");
    }
    this.client = createClient({
      url: ipfsNodeUrl,
      headers
    });
    if (!this.client) {
      throw new Error("Failed to create IPFS client - kubo-rpc-client returned null");
    }
  }
  async store(data2) {
    try {
      if (data2.length > 10 * 1024 * 1024) {
        throw new Error("Data size exceeds maximum allowed limit (10MB)");
      }
      if (!this.isPrivateNetwork && this.isDataUnencrypted(data2)) {
        console.warn("SECURITY WARNING: Data appears to be unencrypted. Ensure client-side encryption is applied.");
      }
      const result = await this.client.add(data2, {
        pin: true,
        cidVersion: 1
      });
      return result.cid.toString();
    } catch (error) {
      throw new Error(`Failed to store data to IPFS: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  isDataUnencrypted(data2) {
    const text = new TextDecoder("utf-8", { fatal: false }).decode(data2.slice(0, 100));
    const commonPatterns = ["{", "<", "BEGIN", "name", "address", "email", "password"];
    return commonPatterns.some((pattern) => text.toLowerCase().includes(pattern.toLowerCase()));
  }
  async retrieve(hash2) {
    try {
      const chunks = [];
      for await (const chunk of this.client.cat(hash2)) {
        chunks.push(chunk);
      }
      const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
      const result = new Uint8Array(totalLength);
      let offset = 0;
      for (const chunk of chunks) {
        result.set(chunk, offset);
        offset += chunk.length;
      }
      return result;
    } catch (error) {
      throw new Error(`Failed to retrieve data from IPFS: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  async delete(hash2) {
    try {
      await this.client.pin.rm(hash2);
      return true;
    } catch (error) {
      console.warn(`IPFS unpin warning for ${hash2}: ${error instanceof Error ? error.message : String(error)}`);
      return false;
    }
  }
}, LocalStorageProvider = class {
  prefix = "ghostspeak_private_";
  async store(data2) {
    const hash2 = bytesToHex2(sha2562(data2));
    globalThis.localStorage.setItem(this.prefix + hash2, bytesToHex2(data2));
    return hash2;
  }
  async retrieve(hash2) {
    const hex = globalThis.localStorage.getItem(this.prefix + hash2);
    if (hex) {
      return hexToBytes2(hex);
    }
    throw new Error(`Data not found: ${hash2}`);
  }
  async delete(hash2) {
    globalThis.localStorage.removeItem(this.prefix + hash2);
    return true;
  }
}, PrivateMetadataStorage = class {
  encryptionService;
  storageProvider;
  featureFlags = getFeatureFlags();
  constructor(storageProvider, encryptionService) {
    this.storageProvider = storageProvider ?? new IPFSProvider;
    this.encryptionService = encryptionService ?? new ClientEncryptionService;
  }
  async storePrivateData(data2, publicMetadata, recipientPubkey) {
    if (!this.featureFlags.isEnabled("ENABLE_IPFS_STORAGE")) {
      throw new Error("IPFS storage is not enabled");
    }
    const privateMetadata = await this.encryptionService.createPrivateMetadata(data2, publicMetadata, recipientPubkey);
    const serialized2 = this.serializePrivateMetadata(privateMetadata);
    const storageLocation = await this.storageProvider.store(serialized2);
    const onChainHash = this.createOnChainHash(privateMetadata, storageLocation);
    return {
      onChainHash,
      storageProvider: "ipfs",
      storageLocation,
      encryptionMetadata: {
        version: privateMetadata.encrypted.version,
        publicKey: privateMetadata.encrypted.publicKey,
        timestamp: privateMetadata.encrypted.timestamp
      },
      size: serialized2.length,
      contentType: "application/json"
    };
  }
  async retrievePrivateData(reference, secretKey) {
    const serialized2 = await this.storageProvider.retrieve(reference.storageLocation);
    const expectedHash = this.createOnChainHash(this.deserializePrivateMetadata(serialized2), reference.storageLocation);
    if (bytesToHex2(expectedHash) !== bytesToHex2(reference.onChainHash)) {
      throw new Error("Data integrity check failed");
    }
    const metadata = this.deserializePrivateMetadata(serialized2);
    const decryptedBytes = await this.decryptPrivateData(metadata.encrypted, secretKey);
    const privateData = JSON.parse(new TextDecoder().decode(decryptedBytes));
    return {
      privateData,
      publicData: metadata.public
    };
  }
  createVerifiableLink(onChainData, offChainReference) {
    const combined = {
      onChain: onChainData,
      offChain: {
        hash: bytesToHex2(offChainReference.onChainHash),
        location: offChainReference.storageLocation,
        provider: offChainReference.storageProvider
      },
      timestamp: Date.now()
    };
    return sha2562(new TextEncoder().encode(JSON.stringify(combined)));
  }
  async batchStore(items) {
    const results = [];
    for (const item of items) {
      const stored = await this.storePrivateData(item.data, item.publicMetadata, item.recipientPubkey);
      results.push(stored);
    }
    return results;
  }
  serializePrivateMetadata(metadata) {
    const json2 = JSON.stringify({
      encrypted: {
        ciphertext: {
          commitment: bytesToHex2(metadata.encrypted.ciphertext.commitment.commitment),
          handle: bytesToHex2(metadata.encrypted.ciphertext.handle.handle)
        },
        publicKey: bytesToHex2(metadata.encrypted.publicKey),
        commitment: bytesToHex2(metadata.encrypted.commitment),
        timestamp: metadata.encrypted.timestamp,
        version: metadata.encrypted.version
      },
      public: metadata.public,
      storageHash: bytesToHex2(metadata.storageHash),
      ipfsHash: metadata.ipfsHash
    });
    return new TextEncoder().encode(json2);
  }
  deserializePrivateMetadata(data2) {
    const json2 = JSON.parse(new TextDecoder().decode(data2));
    return {
      encrypted: {
        ciphertext: {
          commitment: {
            commitment: hexToBytes2(json2.encrypted.ciphertext.commitment)
          },
          handle: {
            handle: hexToBytes2(json2.encrypted.ciphertext.handle)
          }
        },
        publicKey: hexToBytes2(json2.encrypted.publicKey),
        commitment: hexToBytes2(json2.encrypted.commitment),
        timestamp: json2.encrypted.timestamp,
        version: json2.encrypted.version
      },
      public: json2.public,
      storageHash: hexToBytes2(json2.storageHash),
      ipfsHash: json2.ipfsHash
    };
  }
  createOnChainHash(metadata, storageLocation) {
    const data2 = {
      storageHash: bytesToHex2(metadata.storageHash),
      storageLocation,
      commitment: bytesToHex2(metadata.encrypted.commitment),
      timestamp: metadata.encrypted.timestamp
    };
    return sha2562(new TextEncoder().encode(JSON.stringify(data2)));
  }
  async decryptPrivateData(encrypted, secretKey) {
    const decryptedAmount = await this.encryptionService.decryptAmount(encrypted, secretKey);
    return new TextEncoder().encode(JSON.stringify({ amount: decryptedAmount.toString() }));
  }
}, PrivateDataQuery = class {
  conditions = [];
  where(field, operator, value) {
    this.conditions.push({ field, operator, value, encrypted: false });
    return this;
  }
  whereEncrypted(field, commitment) {
    this.conditions.push({
      field,
      operator: "eq",
      value: commitment,
      encrypted: true
    });
    return this;
  }
  async execute(storage, references) {
    const results = [];
    for (const ref of references) {
      let matches = true;
      for (const condition of this.conditions) {
        if (condition.encrypted) {
          if (condition.field === "commitment") {
            const match = bytesToHex2(ref.onChainHash) === bytesToHex2(condition.value);
            if (!match) {
              matches = false;
              break;
            }
          }
        }
      }
      if (matches) {
        results.push(ref);
      }
    }
    return results;
  }
}, FEATURE_GATES, CACHE_TTL_MS, MAX_CACHE_ENTRIES = 100, FeatureGateCacheManager = class {
  cache = {};
  cacheOrder = [];
  get(featureId) {
    const cached = this.cache[featureId];
    if (Date.now() - cached.lastChecked > CACHE_TTL_MS) {
      this.remove(featureId);
      return null;
    }
    return cached;
  }
  set(featureId, status) {
    this.remove(featureId);
    this.cache[featureId] = status;
    this.cacheOrder.push(featureId);
    if (this.cacheOrder.length > MAX_CACHE_ENTRIES) {
      const oldest = this.cacheOrder.shift();
      if (oldest) {
        delete this.cache[oldest];
      }
    }
  }
  remove(featureId) {
    delete this.cache[featureId];
    this.cacheOrder = this.cacheOrder.filter((id) => id !== featureId);
  }
  clear() {
    this.cache = {};
    this.cacheOrder = [];
  }
}, featureCache;
var init_dist = __esm(() => {
  init_chunk_SKMJJ3Q6();
  init_chunk_TTB4OS2D();
  init_chunk_E3FD2CNY();
  init_chunk_SZGFSCNU();
  init_chunk_SZGFSCNU();
  init_chunk_5DMB3UAV();
  init_chunk_VQZQCHUT();
  init_chunk_G7S6B6WB();
  init_chunk_G7S6B6WB();
  init_chunk_BF3IQ35I();
  init_chunk_BQDGRTVP();
  init_chunk_C5CDA3WX();
  init_chunk_C5CDA3WX();
  init_chunk_S74EH3KD();
  init_chunk_IHVDQ4YI();
  init_chunk_SFTSZ3LC();
  init_chunk_JV2SWONF();
  init_chunk_KB6CKIUK();
  init_chunk_AL3HQN73();
  init_chunk_SRS2SKFS();
  init_chunk_RIZZPLLB();
  init_chunk_UP2VWCW5();
  init_index_node35();
  init_index_node35();
  init_src();
  init_esm3();
  init_sha256();
  init_utils3();
  init_index_node5();
  init_reputation_tag_engine();
  init_reputation_tags();
  init_MultiSourceAggregator();
  TIMESTAMP_TOLERANCE_MS = 5 * 60 * 1000;
  PayAIWebhookHandler = class extends EventEmitter2 {
    options;
    verifySignatures;
    authorizationModule;
    payAIFacilitatorAddress;
    constructor(options2 = {}, authorizationModule, payAIFacilitatorAddress) {
      super();
      this.options = options2;
      this.verifySignatures = options2.verifySignatures ?? false;
      this.authorizationModule = authorizationModule;
      this.payAIFacilitatorAddress = payAIFacilitatorAddress;
    }
    async handleWebhook(request) {
      try {
        const payload = typeof request.body === "string" ? JSON.parse(request.body) : request.body;
        if (this.verifySignatures && this.options.webhookSecret) {
          const bodyStr = typeof request.body === "string" ? request.body : JSON.stringify(request.body);
          const verification = await this.verifySignature(request.headers, bodyStr);
          if (!verification.valid) {
            return {
              success: false,
              error: verification.error ?? "Invalid signature"
            };
          }
        }
        return await this.processPayload(payload);
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : "Unknown error";
        this.emit("error", new Error(`Webhook processing failed: ${errorMessage}`));
        return {
          success: false,
          error: errorMessage
        };
      }
    }
    async verifySignature(headers, body) {
      const getHeader = (name) => {
        if (headers instanceof Headers) {
          return headers.get(name) ?? undefined;
        }
        return headers[name];
      };
      const signature2 = getHeader(SIGNATURE_HEADER);
      const timestamp = getHeader(TIMESTAMP_HEADER);
      if (!signature2) {
        return { valid: false, error: "Missing signature header" };
      }
      if (!timestamp) {
        return { valid: false, error: "Missing timestamp header" };
      }
      const timestampMs = parseInt(timestamp, 10);
      if (isNaN(timestampMs)) {
        return { valid: false, error: "Invalid timestamp format" };
      }
      const now = Date.now();
      if (Math.abs(now - timestampMs) > TIMESTAMP_TOLERANCE_MS) {
        return { valid: false, error: "Timestamp too old or too far in future" };
      }
      if (!this.options.webhookSecret) {
        return { valid: false, error: "Webhook secret not configured" };
      }
      const expectedSignature = this.computeSignature(timestamp, body, this.options.webhookSecret);
      const signatureBuffer = Buffer.from(signature2, "hex");
      const expectedBuffer = Buffer.from(expectedSignature, "hex");
      if (signatureBuffer.length !== expectedBuffer.length) {
        return { valid: false, error: "Invalid signature" };
      }
      if (!timingSafeEqual(signatureBuffer, expectedBuffer)) {
        return { valid: false, error: "Invalid signature" };
      }
      return { valid: true };
    }
    paymentToReputationRecord(data2) {
      return {
        agentAddress: data2.merchant,
        paymentSignature: data2.transactionSignature,
        amount: BigInt(data2.amount),
        success: data2.success ?? data2.status === "settled",
        responseTimeMs: data2.responseTimeMs ?? 0,
        payerAddress: data2.payer,
        timestamp: new Date(data2.settledAt ?? data2.verifiedAt ?? Date.now()),
        network: data2.network
      };
    }
    async processPayload(payload) {
      const { type, data: data2 } = payload;
      switch (type) {
        case "payment.verified":
          this.emit("payment:verified", data2);
          await this.options.onPaymentVerified?.(data2);
          break;
        case "payment.settled":
          this.emit("payment:settled", data2);
          await this.options.onPaymentSettled?.(data2);
          if (this.options.onRecordReputation) {
            if (this.authorizationModule && this.payAIFacilitatorAddress) {
              const isAuthorized = await this.verifyOnChainAuthorization(data2.merchant);
              if (!isAuthorized) {
                return {
                  success: false,
                  eventType: type,
                  paymentId: data2.paymentId,
                  error: "Agent has not authorized PayAI facilitator to update reputation",
                  reputationRecorded: false
                };
              }
            }
            const record = this.paymentToReputationRecord(data2);
            await this.options.onRecordReputation(record);
            this.emit("reputation:recorded", record);
            return {
              success: true,
              eventType: type,
              paymentId: data2.paymentId,
              reputationRecorded: true
            };
          }
          break;
        case "payment.failed":
          this.emit("payment:failed", data2);
          await this.options.onPaymentFailed?.(data2);
          if (this.options.onRecordReputation) {
            const record = this.paymentToReputationRecord(data2);
            record.success = false;
            await this.options.onRecordReputation(record);
            this.emit("reputation:recorded", record);
            return {
              success: true,
              eventType: type,
              paymentId: data2.paymentId,
              reputationRecorded: true
            };
          }
          break;
        case "payment.refunded":
          break;
        default:
          return {
            success: false,
            error: `Unknown event type: ${type}`
          };
      }
      return {
        success: true,
        eventType: type,
        paymentId: data2.paymentId,
        reputationRecorded: false
      };
    }
    async verifyOnChainAuthorization(agentAddress) {
      if (!this.authorizationModule || !this.payAIFacilitatorAddress) {
        return true;
      }
      try {
        const authorization2 = await this.authorizationModule.fetchAuthorization(agentAddress, this.payAIFacilitatorAddress);
        if (!authorization2) {
          return false;
        }
        const status = this.authorizationModule.getAuthorizationStatus(authorization2, authorization2.currentIndex);
        return status.isValid;
      } catch (error) {
        console.error("Failed to verify on-chain authorization:", error);
        return false;
      }
    }
    computeSignature(timestamp, body, secret) {
      const signedPayload = `${timestamp}.${body}`;
      const hmac = createHmac("sha256", secret);
      hmac.update(signedPayload);
      return hmac.digest("hex");
    }
  };
  PayAIAgentSync = class extends EventEmitter2 {
    config;
    constructor(config = {}) {
      super();
      this.config = {
        marketplaceUrl: config.marketplaceUrl ?? DEFAULT_MARKETPLACE_URL,
        apiKey: config.apiKey,
        network: config.network ?? "solana",
        timeout: config.timeout ?? 30000
      };
    }
    async registerAgent(agent) {
      try {
        const registration = this.toPayAIRegistration(agent);
        const response = await this.makeRequest("/merchants/register", {
          method: "POST",
          body: JSON.stringify(registration)
        });
        if (!response.ok) {
          const error = await response.text();
          return {
            success: false,
            error: `Registration failed: ${error}`
          };
        }
        const data2 = await response.json();
        this.emit("agent:registered", {
          agentAddress: agent.address,
          agentId: data2.agentId
        });
        return {
          success: true,
          agentId: data2.agentId,
          marketplaceUrl: data2.url
        };
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : "Unknown error";
        return {
          success: false,
          error: errorMessage
        };
      }
    }
    async updateAgent(agentId, agent) {
      try {
        const response = await this.makeRequest(`/merchants/${agentId}`, {
          method: "PATCH",
          body: JSON.stringify(agent)
        });
        if (!response.ok) {
          const error = await response.text();
          return {
            success: false,
            error: `Update failed: ${error}`
          };
        }
        this.emit("agent:updated", { agentId });
        return {
          success: true,
          agentId
        };
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : "Unknown error";
        return {
          success: false,
          error: errorMessage
        };
      }
    }
    async removeAgent(agentId) {
      try {
        const response = await this.makeRequest(`/merchants/${agentId}`, {
          method: "DELETE"
        });
        if (!response.ok) {
          const error = await response.text();
          return {
            success: false,
            error: `Removal failed: ${error}`
          };
        }
        this.emit("agent:removed", { agentId });
        return {
          success: true,
          agentId
        };
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : "Unknown error";
        return {
          success: false,
          error: errorMessage
        };
      }
    }
    async isAgentRegistered(agentAddress) {
      try {
        const response = await this.makeRequest(`/merchants/check?address=${agentAddress}&network=${this.config.network}`);
        if (!response.ok) {
          return false;
        }
        const data2 = await response.json();
        return data2.registered;
      } catch {
        return false;
      }
    }
    async getAgentListing(agentAddress) {
      try {
        const response = await this.makeRequest(`/merchants/by-address?address=${agentAddress}&network=${this.config.network}`);
        if (!response.ok) {
          return null;
        }
        return response.json();
      } catch {
        return null;
      }
    }
    async syncReputationScore(agentId, reputationScore) {
      try {
        const response = await this.makeRequest(`/merchants/${agentId}/reputation`, {
          method: "POST",
          body: JSON.stringify({
            score: reputationScore,
            source: "ghostspeak",
            timestamp: Date.now()
          })
        });
        if (!response.ok) {
          const error = await response.text();
          return {
            success: false,
            error: `Reputation sync failed: ${error}`
          };
        }
        this.emit("reputation:synced", { agentId, reputationScore });
        return {
          success: true,
          agentId
        };
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : "Unknown error";
        return {
          success: false,
          error: errorMessage
        };
      }
    }
    toPayAIRegistration(agent) {
      return {
        agentAddress: agent.address,
        serviceEndpoint: agent.serviceEndpoint,
        capabilities: agent.capabilities,
        acceptedTokens: agent.acceptedTokens,
        pricing: agent.pricing,
        metadata: {
          name: agent.name,
          description: agent.description,
          logo: agent.logo,
          website: agent.website
        }
      };
    }
    async makeRequest(path, options2 = {}) {
      const controller = new AbortController;
      const timeoutId = setTimeout(() => controller.abort(), this.config.timeout);
      const headers = {
        "Content-Type": "application/json",
        "X-Ghostspeak-Integration": "1.0"
      };
      if (this.config.apiKey) {
        headers["Authorization"] = `Bearer ${this.config.apiKey}`;
      }
      try {
        const response = await fetch(`${this.config.marketplaceUrl}${path}`, {
          ...options2,
          headers: {
            ...headers,
            ...options2.headers
          },
          signal: controller.signal
        });
        return response;
      } finally {
        clearTimeout(timeoutId);
      }
    }
  };
  TEST_IPFS_CONFIG = {
    provider: {
      name: "test",
      endpoint: "http://localhost:8080"
    },
    gateways: [
      "http://localhost:8080",
      "https://test.ipfs.io"
    ],
    autoPinning: true,
    sizeThreshold: 400,
    maxRetries: 2,
    retryDelay: 500,
    enableCache: true,
    cacheTTL: 60000
  };
  IPFSOperationError = class extends Error {
    constructor(type, message, provider, retryCount, originalError) {
      super(message);
      this.type = type;
      this.provider = provider;
      this.retryCount = retryCount;
      this.originalError = originalError;
      this.name = "IPFSOperationError";
    }
  };
  DEFAULT_RETRY_CONFIG = {
    maxRetries: 3,
    baseDelay: 1000,
    maxDelay: 30000,
    backoffFactor: 2,
    retryableErrors: [
      "NETWORK_ERROR",
      "TIMEOUT_ERROR",
      "PROVIDER_ERROR"
    ]
  };
  styles = {
    modifier: {
      reset: [0, 0],
      bold: [1, 22],
      dim: [2, 22],
      italic: [3, 23],
      underline: [4, 24],
      overline: [53, 55],
      inverse: [7, 27],
      hidden: [8, 28],
      strikethrough: [9, 29]
    },
    color: {
      black: [30, 39],
      red: [31, 39],
      green: [32, 39],
      yellow: [33, 39],
      blue: [34, 39],
      magenta: [35, 39],
      cyan: [36, 39],
      white: [37, 39],
      blackBright: [90, 39],
      gray: [90, 39],
      grey: [90, 39],
      redBright: [91, 39],
      greenBright: [92, 39],
      yellowBright: [93, 39],
      blueBright: [94, 39],
      magentaBright: [95, 39],
      cyanBright: [96, 39],
      whiteBright: [97, 39]
    },
    bgColor: {
      bgBlack: [40, 49],
      bgRed: [41, 49],
      bgGreen: [42, 49],
      bgYellow: [43, 49],
      bgBlue: [44, 49],
      bgMagenta: [45, 49],
      bgCyan: [46, 49],
      bgWhite: [47, 49],
      bgBlackBright: [100, 49],
      bgGray: [100, 49],
      bgGrey: [100, 49],
      bgRedBright: [101, 49],
      bgGreenBright: [102, 49],
      bgYellowBright: [103, 49],
      bgBlueBright: [104, 49],
      bgMagentaBright: [105, 49],
      bgCyanBright: [106, 49],
      bgWhiteBright: [107, 49]
    }
  };
  Object.keys(styles.modifier);
  foregroundColorNames = Object.keys(styles.color);
  backgroundColorNames = Object.keys(styles.bgColor);
  [...foregroundColorNames, ...backgroundColorNames];
  ansiStyles = assembleStyles();
  ansi_styles_default = ansiStyles;
  ({ env } = process2);
  if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
    flagForceColor = 0;
  } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
    flagForceColor = 1;
  }
  supportsColor = {
    stdout: createSupportsColor({ isTTY: tty.isatty(1) }),
    stderr: createSupportsColor({ isTTY: tty.isatty(2) })
  };
  supports_color_default = supportsColor;
  ({ stdout: stdoutColor, stderr: stderrColor } = supports_color_default);
  GENERATOR = /* @__PURE__ */ Symbol("GENERATOR");
  STYLER = /* @__PURE__ */ Symbol("STYLER");
  IS_EMPTY = /* @__PURE__ */ Symbol("IS_EMPTY");
  levelMapping = [
    "ansi",
    "ansi",
    "ansi256",
    "ansi16m"
  ];
  styles2 = /* @__PURE__ */ Object.create(null);
  Object.setPrototypeOf(createChalk.prototype, Function.prototype);
  for (const [styleName, style] of Object.entries(ansi_styles_default)) {
    styles2[styleName] = {
      get() {
        const builder = createBuilder(this, createStyler(style.open, style.close, this[STYLER]), this[IS_EMPTY]);
        Object.defineProperty(this, styleName, { value: builder });
        return builder;
      }
    };
  }
  styles2.visible = {
    get() {
      const builder = createBuilder(this, this[STYLER], true);
      Object.defineProperty(this, "visible", { value: builder });
      return builder;
    }
  };
  usedModels = ["rgb", "hex", "ansi256"];
  for (const model of usedModels) {
    styles2[model] = {
      get() {
        const { level } = this;
        return function(...arguments_) {
          const styler = createStyler(getModelAnsi(model, levelMapping[level], "color", ...arguments_), ansi_styles_default.color.close, this[STYLER]);
          return createBuilder(this, styler, this[IS_EMPTY]);
        };
      }
    };
    const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
    styles2[bgModel] = {
      get() {
        const { level } = this;
        return function(...arguments_) {
          const styler = createStyler(getModelAnsi(model, levelMapping[level], "bgColor", ...arguments_), ansi_styles_default.bgColor.close, this[STYLER]);
          return createBuilder(this, styler, this[IS_EMPTY]);
        };
      }
    };
  }
  proto = Object.defineProperties(() => {}, {
    ...styles2,
    level: {
      enumerable: true,
      get() {
        return this[GENERATOR].level;
      },
      set(level) {
        this[GENERATOR].level = level;
      }
    }
  });
  Object.defineProperties(createChalk.prototype, styles2);
  chalk = createChalk();
  createChalk({ level: stderrColor ? stderrColor.level : 0 });
  source_default = chalk;
  defaultFundingService = new WalletFundingService(process.env.GHOSTSPEAK_RPC_URL ?? "https://api.devnet.solana.com");
  FEATURE_GATES = {
    CONFIDENTIAL_TRANSFERS: address("11111111111111111111111111111111"),
    TOKEN_2022: address("TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb")
  };
  CACHE_TTL_MS = 5 * 60 * 1000;
  featureCache = new FeatureGateCacheManager;
});

// node_modules/react/cjs/react.development.js
var require_react_development = __commonJS((exports, module) => {
  (function() {
    function defineDeprecationWarning(methodName, info) {
      Object.defineProperty(Component.prototype, methodName, {
        get: function() {
          console.warn("%s(...) is deprecated in plain JavaScript React classes. %s", info[0], info[1]);
        }
      });
    }
    function getIteratorFn(maybeIterable) {
      if (maybeIterable === null || typeof maybeIterable !== "object")
        return null;
      maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
      return typeof maybeIterable === "function" ? maybeIterable : null;
    }
    function warnNoop(publicInstance, callerName) {
      publicInstance = (publicInstance = publicInstance.constructor) && (publicInstance.displayName || publicInstance.name) || "ReactClass";
      var warningKey = publicInstance + "." + callerName;
      didWarnStateUpdateForUnmountedComponent[warningKey] || (console.error("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", callerName, publicInstance), didWarnStateUpdateForUnmountedComponent[warningKey] = true);
    }
    function Component(props, context, updater) {
      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;
    }
    function ComponentDummy() {}
    function PureComponent(props, context, updater) {
      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;
    }
    function noop2() {}
    function testStringCoercion(value) {
      return "" + value;
    }
    function checkKeyStringCoercion(value) {
      try {
        testStringCoercion(value);
        var JSCompiler_inline_result = false;
      } catch (e7) {
        JSCompiler_inline_result = true;
      }
      if (JSCompiler_inline_result) {
        JSCompiler_inline_result = console;
        var JSCompiler_temp_const = JSCompiler_inline_result.error;
        var JSCompiler_inline_result$jscomp$0 = typeof Symbol === "function" && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
        JSCompiler_temp_const.call(JSCompiler_inline_result, "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.", JSCompiler_inline_result$jscomp$0);
        return testStringCoercion(value);
      }
    }
    function getComponentNameFromType(type) {
      if (type == null)
        return null;
      if (typeof type === "function")
        return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
      if (typeof type === "string")
        return type;
      switch (type) {
        case REACT_FRAGMENT_TYPE:
          return "Fragment";
        case REACT_PROFILER_TYPE:
          return "Profiler";
        case REACT_STRICT_MODE_TYPE:
          return "StrictMode";
        case REACT_SUSPENSE_TYPE:
          return "Suspense";
        case REACT_SUSPENSE_LIST_TYPE:
          return "SuspenseList";
        case REACT_ACTIVITY_TYPE:
          return "Activity";
      }
      if (typeof type === "object")
        switch (typeof type.tag === "number" && console.error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), type.$$typeof) {
          case REACT_PORTAL_TYPE:
            return "Portal";
          case REACT_CONTEXT_TYPE:
            return type.displayName || "Context";
          case REACT_CONSUMER_TYPE:
            return (type._context.displayName || "Context") + ".Consumer";
          case REACT_FORWARD_REF_TYPE:
            var innerType = type.render;
            type = type.displayName;
            type || (type = innerType.displayName || innerType.name || "", type = type !== "" ? "ForwardRef(" + type + ")" : "ForwardRef");
            return type;
          case REACT_MEMO_TYPE:
            return innerType = type.displayName || null, innerType !== null ? innerType : getComponentNameFromType(type.type) || "Memo";
          case REACT_LAZY_TYPE:
            innerType = type._payload;
            type = type._init;
            try {
              return getComponentNameFromType(type(innerType));
            } catch (x) {}
        }
      return null;
    }
    function getTaskName(type) {
      if (type === REACT_FRAGMENT_TYPE)
        return "<>";
      if (typeof type === "object" && type !== null && type.$$typeof === REACT_LAZY_TYPE)
        return "<...>";
      try {
        var name = getComponentNameFromType(type);
        return name ? "<" + name + ">" : "<...>";
      } catch (x) {
        return "<...>";
      }
    }
    function getOwner() {
      var dispatcher = ReactSharedInternals.A;
      return dispatcher === null ? null : dispatcher.getOwner();
    }
    function UnknownOwner() {
      return Error("react-stack-top-frame");
    }
    function hasValidKey(config) {
      if (hasOwnProperty.call(config, "key")) {
        var getter = Object.getOwnPropertyDescriptor(config, "key").get;
        if (getter && getter.isReactWarning)
          return false;
      }
      return config.key !== undefined;
    }
    function defineKeyPropWarningGetter(props, displayName) {
      function warnAboutAccessingKey() {
        specialPropKeyWarningShown || (specialPropKeyWarningShown = true, console.error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)", displayName));
      }
      warnAboutAccessingKey.isReactWarning = true;
      Object.defineProperty(props, "key", {
        get: warnAboutAccessingKey,
        configurable: true
      });
    }
    function elementRefGetterWithDeprecationWarning() {
      var componentName = getComponentNameFromType(this.type);
      didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = true, console.error("Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."));
      componentName = this.props.ref;
      return componentName !== undefined ? componentName : null;
    }
    function ReactElement(type, key, props, owner, debugStack, debugTask) {
      var refProp = props.ref;
      type = {
        $$typeof: REACT_ELEMENT_TYPE,
        type,
        key,
        props,
        _owner: owner
      };
      (refProp !== undefined ? refProp : null) !== null ? Object.defineProperty(type, "ref", {
        enumerable: false,
        get: elementRefGetterWithDeprecationWarning
      }) : Object.defineProperty(type, "ref", { enumerable: false, value: null });
      type._store = {};
      Object.defineProperty(type._store, "validated", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: 0
      });
      Object.defineProperty(type, "_debugInfo", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: null
      });
      Object.defineProperty(type, "_debugStack", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: debugStack
      });
      Object.defineProperty(type, "_debugTask", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: debugTask
      });
      Object.freeze && (Object.freeze(type.props), Object.freeze(type));
      return type;
    }
    function cloneAndReplaceKey(oldElement, newKey) {
      newKey = ReactElement(oldElement.type, newKey, oldElement.props, oldElement._owner, oldElement._debugStack, oldElement._debugTask);
      oldElement._store && (newKey._store.validated = oldElement._store.validated);
      return newKey;
    }
    function validateChildKeys(node) {
      isValidElement(node) ? node._store && (node._store.validated = 1) : typeof node === "object" && node !== null && node.$$typeof === REACT_LAZY_TYPE && (node._payload.status === "fulfilled" ? isValidElement(node._payload.value) && node._payload.value._store && (node._payload.value._store.validated = 1) : node._store && (node._store.validated = 1));
    }
    function isValidElement(object) {
      return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
    }
    function escape(key) {
      var escaperLookup = { "=": "=0", ":": "=2" };
      return "$" + key.replace(/[=:]/g, function(match) {
        return escaperLookup[match];
      });
    }
    function getElementKey(element, index) {
      return typeof element === "object" && element !== null && element.key != null ? (checkKeyStringCoercion(element.key), escape("" + element.key)) : index.toString(36);
    }
    function resolveThenable(thenable) {
      switch (thenable.status) {
        case "fulfilled":
          return thenable.value;
        case "rejected":
          throw thenable.reason;
        default:
          switch (typeof thenable.status === "string" ? thenable.then(noop2, noop2) : (thenable.status = "pending", thenable.then(function(fulfilledValue) {
            thenable.status === "pending" && (thenable.status = "fulfilled", thenable.value = fulfilledValue);
          }, function(error) {
            thenable.status === "pending" && (thenable.status = "rejected", thenable.reason = error);
          })), thenable.status) {
            case "fulfilled":
              return thenable.value;
            case "rejected":
              throw thenable.reason;
          }
      }
      throw thenable;
    }
    function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
      var type = typeof children;
      if (type === "undefined" || type === "boolean")
        children = null;
      var invokeCallback = false;
      if (children === null)
        invokeCallback = true;
      else
        switch (type) {
          case "bigint":
          case "string":
          case "number":
            invokeCallback = true;
            break;
          case "object":
            switch (children.$$typeof) {
              case REACT_ELEMENT_TYPE:
              case REACT_PORTAL_TYPE:
                invokeCallback = true;
                break;
              case REACT_LAZY_TYPE:
                return invokeCallback = children._init, mapIntoArray(invokeCallback(children._payload), array, escapedPrefix, nameSoFar, callback);
            }
        }
      if (invokeCallback) {
        invokeCallback = children;
        callback = callback(invokeCallback);
        var childKey = nameSoFar === "" ? "." + getElementKey(invokeCallback, 0) : nameSoFar;
        isArrayImpl(callback) ? (escapedPrefix = "", childKey != null && (escapedPrefix = childKey.replace(userProvidedKeyEscapeRegex, "$&/") + "/"), mapIntoArray(callback, array, escapedPrefix, "", function(c) {
          return c;
        })) : callback != null && (isValidElement(callback) && (callback.key != null && (invokeCallback && invokeCallback.key === callback.key || checkKeyStringCoercion(callback.key)), escapedPrefix = cloneAndReplaceKey(callback, escapedPrefix + (callback.key == null || invokeCallback && invokeCallback.key === callback.key ? "" : ("" + callback.key).replace(userProvidedKeyEscapeRegex, "$&/") + "/") + childKey), nameSoFar !== "" && invokeCallback != null && isValidElement(invokeCallback) && invokeCallback.key == null && invokeCallback._store && !invokeCallback._store.validated && (escapedPrefix._store.validated = 2), callback = escapedPrefix), array.push(callback));
        return 1;
      }
      invokeCallback = 0;
      childKey = nameSoFar === "" ? "." : nameSoFar + ":";
      if (isArrayImpl(children))
        for (var i = 0;i < children.length; i++)
          nameSoFar = children[i], type = childKey + getElementKey(nameSoFar, i), invokeCallback += mapIntoArray(nameSoFar, array, escapedPrefix, type, callback);
      else if (i = getIteratorFn(children), typeof i === "function")
        for (i === children.entries && (didWarnAboutMaps || console.warn("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), didWarnAboutMaps = true), children = i.call(children), i = 0;!(nameSoFar = children.next()).done; )
          nameSoFar = nameSoFar.value, type = childKey + getElementKey(nameSoFar, i++), invokeCallback += mapIntoArray(nameSoFar, array, escapedPrefix, type, callback);
      else if (type === "object") {
        if (typeof children.then === "function")
          return mapIntoArray(resolveThenable(children), array, escapedPrefix, nameSoFar, callback);
        array = String(children);
        throw Error("Objects are not valid as a React child (found: " + (array === "[object Object]" ? "object with keys {" + Object.keys(children).join(", ") + "}" : array) + "). If you meant to render a collection of children, use an array instead.");
      }
      return invokeCallback;
    }
    function mapChildren(children, func, context) {
      if (children == null)
        return children;
      var result = [], count = 0;
      mapIntoArray(children, result, "", "", function(child) {
        return func.call(context, child, count++);
      });
      return result;
    }
    function lazyInitializer(payload) {
      if (payload._status === -1) {
        var ioInfo = payload._ioInfo;
        ioInfo != null && (ioInfo.start = ioInfo.end = performance.now());
        ioInfo = payload._result;
        var thenable = ioInfo();
        thenable.then(function(moduleObject) {
          if (payload._status === 0 || payload._status === -1) {
            payload._status = 1;
            payload._result = moduleObject;
            var _ioInfo = payload._ioInfo;
            _ioInfo != null && (_ioInfo.end = performance.now());
            thenable.status === undefined && (thenable.status = "fulfilled", thenable.value = moduleObject);
          }
        }, function(error) {
          if (payload._status === 0 || payload._status === -1) {
            payload._status = 2;
            payload._result = error;
            var _ioInfo2 = payload._ioInfo;
            _ioInfo2 != null && (_ioInfo2.end = performance.now());
            thenable.status === undefined && (thenable.status = "rejected", thenable.reason = error);
          }
        });
        ioInfo = payload._ioInfo;
        if (ioInfo != null) {
          ioInfo.value = thenable;
          var displayName = thenable.displayName;
          typeof displayName === "string" && (ioInfo.name = displayName);
        }
        payload._status === -1 && (payload._status = 0, payload._result = thenable);
      }
      if (payload._status === 1)
        return ioInfo = payload._result, ioInfo === undefined && console.error(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))

Did you accidentally put curly braces around the import?`, ioInfo), "default" in ioInfo || console.error(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))`, ioInfo), ioInfo.default;
      throw payload._result;
    }
    function resolveDispatcher() {
      var dispatcher = ReactSharedInternals.H;
      dispatcher === null && console.error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.`);
      return dispatcher;
    }
    function releaseAsyncTransition() {
      ReactSharedInternals.asyncTransitions--;
    }
    function enqueueTask(task) {
      if (enqueueTaskImpl === null)
        try {
          var requireString = ("require" + Math.random()).slice(0, 7);
          enqueueTaskImpl = (module && module[requireString]).call(module, "timers").setImmediate;
        } catch (_err) {
          enqueueTaskImpl = function(callback) {
            didWarnAboutMessageChannel === false && (didWarnAboutMessageChannel = true, typeof MessageChannel === "undefined" && console.error("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."));
            var channel = new MessageChannel;
            channel.port1.onmessage = callback;
            channel.port2.postMessage(undefined);
          };
        }
      return enqueueTaskImpl(task);
    }
    function aggregateErrors(errors2) {
      return 1 < errors2.length && typeof AggregateError === "function" ? new AggregateError(errors2) : errors2[0];
    }
    function popActScope(prevActQueue, prevActScopeDepth) {
      prevActScopeDepth !== actScopeDepth - 1 && console.error("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. ");
      actScopeDepth = prevActScopeDepth;
    }
    function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {
      var queue = ReactSharedInternals.actQueue;
      if (queue !== null)
        if (queue.length !== 0)
          try {
            flushActQueue(queue);
            enqueueTask(function() {
              return recursivelyFlushAsyncActWork(returnValue, resolve, reject);
            });
            return;
          } catch (error) {
            ReactSharedInternals.thrownErrors.push(error);
          }
        else
          ReactSharedInternals.actQueue = null;
      0 < ReactSharedInternals.thrownErrors.length ? (queue = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, reject(queue)) : resolve(returnValue);
    }
    function flushActQueue(queue) {
      if (!isFlushing) {
        isFlushing = true;
        var i = 0;
        try {
          for (;i < queue.length; i++) {
            var callback = queue[i];
            do {
              ReactSharedInternals.didUsePromise = false;
              var continuation = callback(false);
              if (continuation !== null) {
                if (ReactSharedInternals.didUsePromise) {
                  queue[i] = callback;
                  queue.splice(0, i);
                  return;
                }
                callback = continuation;
              } else
                break;
            } while (1);
          }
          queue.length = 0;
        } catch (error) {
          queue.splice(0, i + 1), ReactSharedInternals.thrownErrors.push(error);
        } finally {
          isFlushing = false;
        }
      }
    }
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator, didWarnStateUpdateForUnmountedComponent = {}, ReactNoopUpdateQueue = {
      isMounted: function() {
        return false;
      },
      enqueueForceUpdate: function(publicInstance) {
        warnNoop(publicInstance, "forceUpdate");
      },
      enqueueReplaceState: function(publicInstance) {
        warnNoop(publicInstance, "replaceState");
      },
      enqueueSetState: function(publicInstance) {
        warnNoop(publicInstance, "setState");
      }
    }, assign = Object.assign, emptyObject = {};
    Object.freeze(emptyObject);
    Component.prototype.isReactComponent = {};
    Component.prototype.setState = function(partialState, callback) {
      if (typeof partialState !== "object" && typeof partialState !== "function" && partialState != null)
        throw Error("takes an object of state variables to update or a function which returns an object of state variables.");
      this.updater.enqueueSetState(this, partialState, callback, "setState");
    };
    Component.prototype.forceUpdate = function(callback) {
      this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
    };
    var deprecatedAPIs = {
      isMounted: [
        "isMounted",
        "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."
      ],
      replaceState: [
        "replaceState",
        "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."
      ]
    };
    for (fnName in deprecatedAPIs)
      deprecatedAPIs.hasOwnProperty(fnName) && defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
    ComponentDummy.prototype = Component.prototype;
    deprecatedAPIs = PureComponent.prototype = new ComponentDummy;
    deprecatedAPIs.constructor = PureComponent;
    assign(deprecatedAPIs, Component.prototype);
    deprecatedAPIs.isPureReactComponent = true;
    var isArrayImpl = Array.isArray, REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), ReactSharedInternals = {
      H: null,
      A: null,
      T: null,
      S: null,
      actQueue: null,
      asyncTransitions: 0,
      isBatchingLegacy: false,
      didScheduleLegacyUpdate: false,
      didUsePromise: false,
      thrownErrors: [],
      getCurrentStack: null,
      recentlyCreatedOwnerStacks: 0
    }, hasOwnProperty = Object.prototype.hasOwnProperty, createTask = console.createTask ? console.createTask : function() {
      return null;
    };
    deprecatedAPIs = {
      react_stack_bottom_frame: function(callStackForError) {
        return callStackForError();
      }
    };
    var specialPropKeyWarningShown, didWarnAboutOldJSXRuntime;
    var didWarnAboutElementRef = {};
    var unknownOwnerDebugStack = deprecatedAPIs.react_stack_bottom_frame.bind(deprecatedAPIs, UnknownOwner)();
    var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
    var didWarnAboutMaps = false, userProvidedKeyEscapeRegex = /\/+/g, reportGlobalError = typeof reportError === "function" ? reportError : function(error) {
      if (typeof window === "object" && typeof window.ErrorEvent === "function") {
        var event = new window.ErrorEvent("error", {
          bubbles: true,
          cancelable: true,
          message: typeof error === "object" && error !== null && typeof error.message === "string" ? String(error.message) : String(error),
          error
        });
        if (!window.dispatchEvent(event))
          return;
      } else if (typeof process === "object" && typeof process.emit === "function") {
        process.emit("uncaughtException", error);
        return;
      }
      console.error(error);
    }, didWarnAboutMessageChannel = false, enqueueTaskImpl = null, actScopeDepth = 0, didWarnNoAwaitAct = false, isFlushing = false, queueSeveralMicrotasks = typeof queueMicrotask === "function" ? function(callback) {
      queueMicrotask(function() {
        return queueMicrotask(callback);
      });
    } : enqueueTask;
    deprecatedAPIs = Object.freeze({
      __proto__: null,
      c: function(size) {
        return resolveDispatcher().useMemoCache(size);
      }
    });
    var fnName = {
      map: mapChildren,
      forEach: function(children, forEachFunc, forEachContext) {
        mapChildren(children, function() {
          forEachFunc.apply(this, arguments);
        }, forEachContext);
      },
      count: function(children) {
        var n = 0;
        mapChildren(children, function() {
          n++;
        });
        return n;
      },
      toArray: function(children) {
        return mapChildren(children, function(child) {
          return child;
        }) || [];
      },
      only: function(children) {
        if (!isValidElement(children))
          throw Error("React.Children.only expected to receive a single React element child.");
        return children;
      }
    };
    exports.Activity = REACT_ACTIVITY_TYPE;
    exports.Children = fnName;
    exports.Component = Component;
    exports.Fragment = REACT_FRAGMENT_TYPE;
    exports.Profiler = REACT_PROFILER_TYPE;
    exports.PureComponent = PureComponent;
    exports.StrictMode = REACT_STRICT_MODE_TYPE;
    exports.Suspense = REACT_SUSPENSE_TYPE;
    exports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals;
    exports.__COMPILER_RUNTIME = deprecatedAPIs;
    exports.act = function(callback) {
      var prevActQueue = ReactSharedInternals.actQueue, prevActScopeDepth = actScopeDepth;
      actScopeDepth++;
      var queue = ReactSharedInternals.actQueue = prevActQueue !== null ? prevActQueue : [], didAwaitActCall = false;
      try {
        var result = callback();
      } catch (error) {
        ReactSharedInternals.thrownErrors.push(error);
      }
      if (0 < ReactSharedInternals.thrownErrors.length)
        throw popActScope(prevActQueue, prevActScopeDepth), callback = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, callback;
      if (result !== null && typeof result === "object" && typeof result.then === "function") {
        var thenable = result;
        queueSeveralMicrotasks(function() {
          didAwaitActCall || didWarnNoAwaitAct || (didWarnNoAwaitAct = true, console.error("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"));
        });
        return {
          then: function(resolve, reject) {
            didAwaitActCall = true;
            thenable.then(function(returnValue) {
              popActScope(prevActQueue, prevActScopeDepth);
              if (prevActScopeDepth === 0) {
                try {
                  flushActQueue(queue), enqueueTask(function() {
                    return recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                  });
                } catch (error$0) {
                  ReactSharedInternals.thrownErrors.push(error$0);
                }
                if (0 < ReactSharedInternals.thrownErrors.length) {
                  var _thrownError = aggregateErrors(ReactSharedInternals.thrownErrors);
                  ReactSharedInternals.thrownErrors.length = 0;
                  reject(_thrownError);
                }
              } else
                resolve(returnValue);
            }, function(error) {
              popActScope(prevActQueue, prevActScopeDepth);
              0 < ReactSharedInternals.thrownErrors.length ? (error = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, reject(error)) : reject(error);
            });
          }
        };
      }
      var returnValue$jscomp$0 = result;
      popActScope(prevActQueue, prevActScopeDepth);
      prevActScopeDepth === 0 && (flushActQueue(queue), queue.length !== 0 && queueSeveralMicrotasks(function() {
        didAwaitActCall || didWarnNoAwaitAct || (didWarnNoAwaitAct = true, console.error("A component suspended inside an `act` scope, but the `act` call was not awaited. When testing React components that depend on asynchronous data, you must await the result:\n\nawait act(() => ...)"));
      }), ReactSharedInternals.actQueue = null);
      if (0 < ReactSharedInternals.thrownErrors.length)
        throw callback = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, callback;
      return {
        then: function(resolve, reject) {
          didAwaitActCall = true;
          prevActScopeDepth === 0 ? (ReactSharedInternals.actQueue = queue, enqueueTask(function() {
            return recursivelyFlushAsyncActWork(returnValue$jscomp$0, resolve, reject);
          })) : resolve(returnValue$jscomp$0);
        }
      };
    };
    exports.cache = function(fn) {
      return function() {
        return fn.apply(null, arguments);
      };
    };
    exports.cacheSignal = function() {
      return null;
    };
    exports.captureOwnerStack = function() {
      var getCurrentStack = ReactSharedInternals.getCurrentStack;
      return getCurrentStack === null ? null : getCurrentStack();
    };
    exports.cloneElement = function(element, config, children) {
      if (element === null || element === undefined)
        throw Error("The argument must be a React element, but you passed " + element + ".");
      var props = assign({}, element.props), key = element.key, owner = element._owner;
      if (config != null) {
        var JSCompiler_inline_result;
        a: {
          if (hasOwnProperty.call(config, "ref") && (JSCompiler_inline_result = Object.getOwnPropertyDescriptor(config, "ref").get) && JSCompiler_inline_result.isReactWarning) {
            JSCompiler_inline_result = false;
            break a;
          }
          JSCompiler_inline_result = config.ref !== undefined;
        }
        JSCompiler_inline_result && (owner = getOwner());
        hasValidKey(config) && (checkKeyStringCoercion(config.key), key = "" + config.key);
        for (propName in config)
          !hasOwnProperty.call(config, propName) || propName === "key" || propName === "__self" || propName === "__source" || propName === "ref" && config.ref === undefined || (props[propName] = config[propName]);
      }
      var propName = arguments.length - 2;
      if (propName === 1)
        props.children = children;
      else if (1 < propName) {
        JSCompiler_inline_result = Array(propName);
        for (var i = 0;i < propName; i++)
          JSCompiler_inline_result[i] = arguments[i + 2];
        props.children = JSCompiler_inline_result;
      }
      props = ReactElement(element.type, key, props, owner, element._debugStack, element._debugTask);
      for (key = 2;key < arguments.length; key++)
        validateChildKeys(arguments[key]);
      return props;
    };
    exports.createContext = function(defaultValue) {
      defaultValue = {
        $$typeof: REACT_CONTEXT_TYPE,
        _currentValue: defaultValue,
        _currentValue2: defaultValue,
        _threadCount: 0,
        Provider: null,
        Consumer: null
      };
      defaultValue.Provider = defaultValue;
      defaultValue.Consumer = {
        $$typeof: REACT_CONSUMER_TYPE,
        _context: defaultValue
      };
      defaultValue._currentRenderer = null;
      defaultValue._currentRenderer2 = null;
      return defaultValue;
    };
    exports.createElement = function(type, config, children) {
      for (var i = 2;i < arguments.length; i++)
        validateChildKeys(arguments[i]);
      i = {};
      var key = null;
      if (config != null)
        for (propName in didWarnAboutOldJSXRuntime || !("__self" in config) || "key" in config || (didWarnAboutOldJSXRuntime = true, console.warn("Your app (or one of its dependencies) is using an outdated JSX transform. Update to the modern JSX transform for faster performance: https://react.dev/link/new-jsx-transform")), hasValidKey(config) && (checkKeyStringCoercion(config.key), key = "" + config.key), config)
          hasOwnProperty.call(config, propName) && propName !== "key" && propName !== "__self" && propName !== "__source" && (i[propName] = config[propName]);
      var childrenLength = arguments.length - 2;
      if (childrenLength === 1)
        i.children = children;
      else if (1 < childrenLength) {
        for (var childArray = Array(childrenLength), _i = 0;_i < childrenLength; _i++)
          childArray[_i] = arguments[_i + 2];
        Object.freeze && Object.freeze(childArray);
        i.children = childArray;
      }
      if (type && type.defaultProps)
        for (propName in childrenLength = type.defaultProps, childrenLength)
          i[propName] === undefined && (i[propName] = childrenLength[propName]);
      key && defineKeyPropWarningGetter(i, typeof type === "function" ? type.displayName || type.name || "Unknown" : type);
      var propName = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
      return ReactElement(type, key, i, getOwner(), propName ? Error("react-stack-top-frame") : unknownOwnerDebugStack, propName ? createTask(getTaskName(type)) : unknownOwnerDebugTask);
    };
    exports.createRef = function() {
      var refObject = { current: null };
      Object.seal(refObject);
      return refObject;
    };
    exports.forwardRef = function(render) {
      render != null && render.$$typeof === REACT_MEMO_TYPE ? console.error("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).") : typeof render !== "function" ? console.error("forwardRef requires a render function but was given %s.", render === null ? "null" : typeof render) : render.length !== 0 && render.length !== 2 && console.error("forwardRef render functions accept exactly two parameters: props and ref. %s", render.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined.");
      render != null && render.defaultProps != null && console.error("forwardRef render functions do not support defaultProps. Did you accidentally pass a React component?");
      var elementType = { $$typeof: REACT_FORWARD_REF_TYPE, render }, ownName;
      Object.defineProperty(elementType, "displayName", {
        enumerable: false,
        configurable: true,
        get: function() {
          return ownName;
        },
        set: function(name) {
          ownName = name;
          render.name || render.displayName || (Object.defineProperty(render, "name", { value: name }), render.displayName = name);
        }
      });
      return elementType;
    };
    exports.isValidElement = isValidElement;
    exports.lazy = function(ctor) {
      ctor = { _status: -1, _result: ctor };
      var lazyType = {
        $$typeof: REACT_LAZY_TYPE,
        _payload: ctor,
        _init: lazyInitializer
      }, ioInfo = {
        name: "lazy",
        start: -1,
        end: -1,
        value: null,
        owner: null,
        debugStack: Error("react-stack-top-frame"),
        debugTask: console.createTask ? console.createTask("lazy()") : null
      };
      ctor._ioInfo = ioInfo;
      lazyType._debugInfo = [{ awaited: ioInfo }];
      return lazyType;
    };
    exports.memo = function(type, compare) {
      type == null && console.error("memo: The first argument must be a component. Instead received: %s", type === null ? "null" : typeof type);
      compare = {
        $$typeof: REACT_MEMO_TYPE,
        type,
        compare: compare === undefined ? null : compare
      };
      var ownName;
      Object.defineProperty(compare, "displayName", {
        enumerable: false,
        configurable: true,
        get: function() {
          return ownName;
        },
        set: function(name) {
          ownName = name;
          type.name || type.displayName || (Object.defineProperty(type, "name", { value: name }), type.displayName = name);
        }
      });
      return compare;
    };
    exports.startTransition = function(scope) {
      var prevTransition = ReactSharedInternals.T, currentTransition = {};
      currentTransition._updatedFibers = new Set;
      ReactSharedInternals.T = currentTransition;
      try {
        var returnValue = scope(), onStartTransitionFinish = ReactSharedInternals.S;
        onStartTransitionFinish !== null && onStartTransitionFinish(currentTransition, returnValue);
        typeof returnValue === "object" && returnValue !== null && typeof returnValue.then === "function" && (ReactSharedInternals.asyncTransitions++, returnValue.then(releaseAsyncTransition, releaseAsyncTransition), returnValue.then(noop2, reportGlobalError));
      } catch (error) {
        reportGlobalError(error);
      } finally {
        prevTransition === null && currentTransition._updatedFibers && (scope = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < scope && console.warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.")), prevTransition !== null && currentTransition.types !== null && (prevTransition.types !== null && prevTransition.types !== currentTransition.types && console.error("We expected inner Transitions to have transferred the outer types set and that you cannot add to the outer Transition while inside the inner.This is a bug in React."), prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition;
      }
    };
    exports.unstable_useCacheRefresh = function() {
      return resolveDispatcher().useCacheRefresh();
    };
    exports.use = function(usable) {
      return resolveDispatcher().use(usable);
    };
    exports.useActionState = function(action, initialState, permalink) {
      return resolveDispatcher().useActionState(action, initialState, permalink);
    };
    exports.useCallback = function(callback, deps) {
      return resolveDispatcher().useCallback(callback, deps);
    };
    exports.useContext = function(Context) {
      var dispatcher = resolveDispatcher();
      Context.$$typeof === REACT_CONSUMER_TYPE && console.error("Calling useContext(Context.Consumer) is not supported and will cause bugs. Did you mean to call useContext(Context) instead?");
      return dispatcher.useContext(Context);
    };
    exports.useDebugValue = function(value, formatterFn) {
      return resolveDispatcher().useDebugValue(value, formatterFn);
    };
    exports.useDeferredValue = function(value, initialValue) {
      return resolveDispatcher().useDeferredValue(value, initialValue);
    };
    exports.useEffect = function(create, deps) {
      create == null && console.warn("React Hook useEffect requires an effect callback. Did you forget to pass a callback to the hook?");
      return resolveDispatcher().useEffect(create, deps);
    };
    exports.useEffectEvent = function(callback) {
      return resolveDispatcher().useEffectEvent(callback);
    };
    exports.useId = function() {
      return resolveDispatcher().useId();
    };
    exports.useImperativeHandle = function(ref, create, deps) {
      return resolveDispatcher().useImperativeHandle(ref, create, deps);
    };
    exports.useInsertionEffect = function(create, deps) {
      create == null && console.warn("React Hook useInsertionEffect requires an effect callback. Did you forget to pass a callback to the hook?");
      return resolveDispatcher().useInsertionEffect(create, deps);
    };
    exports.useLayoutEffect = function(create, deps) {
      create == null && console.warn("React Hook useLayoutEffect requires an effect callback. Did you forget to pass a callback to the hook?");
      return resolveDispatcher().useLayoutEffect(create, deps);
    };
    exports.useMemo = function(create, deps) {
      return resolveDispatcher().useMemo(create, deps);
    };
    exports.useOptimistic = function(passthrough, reducer) {
      return resolveDispatcher().useOptimistic(passthrough, reducer);
    };
    exports.useReducer = function(reducer, initialArg, init2) {
      return resolveDispatcher().useReducer(reducer, initialArg, init2);
    };
    exports.useRef = function(initialValue) {
      return resolveDispatcher().useRef(initialValue);
    };
    exports.useState = function(initialState) {
      return resolveDispatcher().useState(initialState);
    };
    exports.useSyncExternalStore = function(subscribe, getSnapshot, getServerSnapshot) {
      return resolveDispatcher().useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
    };
    exports.useTransition = function() {
      return resolveDispatcher().useTransition();
    };
    exports.version = "19.2.3";
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  })();
});

// node_modules/react/index.js
var require_react = __commonJS((exports, module) => {
  var react_development = __toESM(require_react_development());
  if (false) {} else {
    module.exports = react_development;
  }
});

// node_modules/react/cjs/react-jsx-runtime.development.js
var require_react_jsx_runtime_development = __commonJS((exports) => {
  var React = __toESM(require_react());
  (function() {
    function getComponentNameFromType(type) {
      if (type == null)
        return null;
      if (typeof type === "function")
        return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
      if (typeof type === "string")
        return type;
      switch (type) {
        case REACT_FRAGMENT_TYPE:
          return "Fragment";
        case REACT_PROFILER_TYPE:
          return "Profiler";
        case REACT_STRICT_MODE_TYPE:
          return "StrictMode";
        case REACT_SUSPENSE_TYPE:
          return "Suspense";
        case REACT_SUSPENSE_LIST_TYPE:
          return "SuspenseList";
        case REACT_ACTIVITY_TYPE:
          return "Activity";
      }
      if (typeof type === "object")
        switch (typeof type.tag === "number" && console.error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), type.$$typeof) {
          case REACT_PORTAL_TYPE:
            return "Portal";
          case REACT_CONTEXT_TYPE:
            return type.displayName || "Context";
          case REACT_CONSUMER_TYPE:
            return (type._context.displayName || "Context") + ".Consumer";
          case REACT_FORWARD_REF_TYPE:
            var innerType = type.render;
            type = type.displayName;
            type || (type = innerType.displayName || innerType.name || "", type = type !== "" ? "ForwardRef(" + type + ")" : "ForwardRef");
            return type;
          case REACT_MEMO_TYPE:
            return innerType = type.displayName || null, innerType !== null ? innerType : getComponentNameFromType(type.type) || "Memo";
          case REACT_LAZY_TYPE:
            innerType = type._payload;
            type = type._init;
            try {
              return getComponentNameFromType(type(innerType));
            } catch (x) {}
        }
      return null;
    }
    function testStringCoercion(value) {
      return "" + value;
    }
    function checkKeyStringCoercion(value) {
      try {
        testStringCoercion(value);
        var JSCompiler_inline_result = false;
      } catch (e7) {
        JSCompiler_inline_result = true;
      }
      if (JSCompiler_inline_result) {
        JSCompiler_inline_result = console;
        var JSCompiler_temp_const = JSCompiler_inline_result.error;
        var JSCompiler_inline_result$jscomp$0 = typeof Symbol === "function" && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
        JSCompiler_temp_const.call(JSCompiler_inline_result, "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.", JSCompiler_inline_result$jscomp$0);
        return testStringCoercion(value);
      }
    }
    function getTaskName(type) {
      if (type === REACT_FRAGMENT_TYPE)
        return "<>";
      if (typeof type === "object" && type !== null && type.$$typeof === REACT_LAZY_TYPE)
        return "<...>";
      try {
        var name = getComponentNameFromType(type);
        return name ? "<" + name + ">" : "<...>";
      } catch (x) {
        return "<...>";
      }
    }
    function getOwner() {
      var dispatcher = ReactSharedInternals.A;
      return dispatcher === null ? null : dispatcher.getOwner();
    }
    function UnknownOwner() {
      return Error("react-stack-top-frame");
    }
    function hasValidKey(config) {
      if (hasOwnProperty.call(config, "key")) {
        var getter = Object.getOwnPropertyDescriptor(config, "key").get;
        if (getter && getter.isReactWarning)
          return false;
      }
      return config.key !== undefined;
    }
    function defineKeyPropWarningGetter(props, displayName) {
      function warnAboutAccessingKey() {
        specialPropKeyWarningShown || (specialPropKeyWarningShown = true, console.error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)", displayName));
      }
      warnAboutAccessingKey.isReactWarning = true;
      Object.defineProperty(props, "key", {
        get: warnAboutAccessingKey,
        configurable: true
      });
    }
    function elementRefGetterWithDeprecationWarning() {
      var componentName = getComponentNameFromType(this.type);
      didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = true, console.error("Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."));
      componentName = this.props.ref;
      return componentName !== undefined ? componentName : null;
    }
    function ReactElement(type, key, props, owner, debugStack, debugTask) {
      var refProp = props.ref;
      type = {
        $$typeof: REACT_ELEMENT_TYPE,
        type,
        key,
        props,
        _owner: owner
      };
      (refProp !== undefined ? refProp : null) !== null ? Object.defineProperty(type, "ref", {
        enumerable: false,
        get: elementRefGetterWithDeprecationWarning
      }) : Object.defineProperty(type, "ref", { enumerable: false, value: null });
      type._store = {};
      Object.defineProperty(type._store, "validated", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: 0
      });
      Object.defineProperty(type, "_debugInfo", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: null
      });
      Object.defineProperty(type, "_debugStack", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: debugStack
      });
      Object.defineProperty(type, "_debugTask", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: debugTask
      });
      Object.freeze && (Object.freeze(type.props), Object.freeze(type));
      return type;
    }
    function jsxDEVImpl(type, config, maybeKey, isStaticChildren, debugStack, debugTask) {
      var children = config.children;
      if (children !== undefined)
        if (isStaticChildren)
          if (isArrayImpl(children)) {
            for (isStaticChildren = 0;isStaticChildren < children.length; isStaticChildren++)
              validateChildKeys(children[isStaticChildren]);
            Object.freeze && Object.freeze(children);
          } else
            console.error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
        else
          validateChildKeys(children);
      if (hasOwnProperty.call(config, "key")) {
        children = getComponentNameFromType(type);
        var keys2 = Object.keys(config).filter(function(k) {
          return k !== "key";
        });
        isStaticChildren = 0 < keys2.length ? "{key: someKey, " + keys2.join(": ..., ") + ": ...}" : "{key: someKey}";
        didWarnAboutKeySpread[children + isStaticChildren] || (keys2 = 0 < keys2.length ? "{" + keys2.join(": ..., ") + ": ...}" : "{}", console.error(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, isStaticChildren, children, keys2, children), didWarnAboutKeySpread[children + isStaticChildren] = true);
      }
      children = null;
      maybeKey !== undefined && (checkKeyStringCoercion(maybeKey), children = "" + maybeKey);
      hasValidKey(config) && (checkKeyStringCoercion(config.key), children = "" + config.key);
      if ("key" in config) {
        maybeKey = {};
        for (var propName in config)
          propName !== "key" && (maybeKey[propName] = config[propName]);
      } else
        maybeKey = config;
      children && defineKeyPropWarningGetter(maybeKey, typeof type === "function" ? type.displayName || type.name || "Unknown" : type);
      return ReactElement(type, children, maybeKey, getOwner(), debugStack, debugTask);
    }
    function validateChildKeys(node) {
      isValidElement(node) ? node._store && (node._store.validated = 1) : typeof node === "object" && node !== null && node.$$typeof === REACT_LAZY_TYPE && (node._payload.status === "fulfilled" ? isValidElement(node._payload.value) && node._payload.value._store && (node._payload.value._store.validated = 1) : node._store && (node._store.validated = 1));
    }
    function isValidElement(object) {
      return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
    }
    var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, hasOwnProperty = Object.prototype.hasOwnProperty, isArrayImpl = Array.isArray, createTask = console.createTask ? console.createTask : function() {
      return null;
    };
    React = {
      react_stack_bottom_frame: function(callStackForError) {
        return callStackForError();
      }
    };
    var specialPropKeyWarningShown;
    var didWarnAboutElementRef = {};
    var unknownOwnerDebugStack = React.react_stack_bottom_frame.bind(React, UnknownOwner)();
    var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
    var didWarnAboutKeySpread = {};
    exports.Fragment = REACT_FRAGMENT_TYPE;
    exports.jsx = function(type, config, maybeKey) {
      var trackActualOwner = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
      return jsxDEVImpl(type, config, maybeKey, false, trackActualOwner ? Error("react-stack-top-frame") : unknownOwnerDebugStack, trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask);
    };
    exports.jsxs = function(type, config, maybeKey) {
      var trackActualOwner = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
      return jsxDEVImpl(type, config, maybeKey, true, trackActualOwner ? Error("react-stack-top-frame") : unknownOwnerDebugStack, trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask);
    };
  })();
});

// node_modules/react/jsx-runtime.js
var require_jsx_runtime = __commonJS((exports, module) => {
  var react_jsx_runtime_development = __toESM(require_react_jsx_runtime_development());
  if (false) {} else {
    module.exports = react_jsx_runtime_development;
  }
});

// node_modules/scheduler/cjs/scheduler.development.js
var require_scheduler_development = __commonJS((exports) => {
  (function() {
    function performWorkUntilDeadline() {
      needsPaint = false;
      if (isMessageLoopRunning) {
        var currentTime = exports.unstable_now();
        startTime = currentTime;
        var hasMoreWork = true;
        try {
          a: {
            isHostCallbackScheduled = false;
            isHostTimeoutScheduled && (isHostTimeoutScheduled = false, localClearTimeout(taskTimeoutID), taskTimeoutID = -1);
            isPerformingWork = true;
            var previousPriorityLevel = currentPriorityLevel;
            try {
              b: {
                advanceTimers(currentTime);
                for (currentTask = peek(taskQueue);currentTask !== null && !(currentTask.expirationTime > currentTime && shouldYieldToHost()); ) {
                  var callback = currentTask.callback;
                  if (typeof callback === "function") {
                    currentTask.callback = null;
                    currentPriorityLevel = currentTask.priorityLevel;
                    var continuationCallback = callback(currentTask.expirationTime <= currentTime);
                    currentTime = exports.unstable_now();
                    if (typeof continuationCallback === "function") {
                      currentTask.callback = continuationCallback;
                      advanceTimers(currentTime);
                      hasMoreWork = true;
                      break b;
                    }
                    currentTask === peek(taskQueue) && pop(taskQueue);
                    advanceTimers(currentTime);
                  } else
                    pop(taskQueue);
                  currentTask = peek(taskQueue);
                }
                if (currentTask !== null)
                  hasMoreWork = true;
                else {
                  var firstTimer = peek(timerQueue);
                  firstTimer !== null && requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
                  hasMoreWork = false;
                }
              }
              break a;
            } finally {
              currentTask = null, currentPriorityLevel = previousPriorityLevel, isPerformingWork = false;
            }
            hasMoreWork = undefined;
          }
        } finally {
          hasMoreWork ? schedulePerformWorkUntilDeadline() : isMessageLoopRunning = false;
        }
      }
    }
    function push(heap, node) {
      var index = heap.length;
      heap.push(node);
      a:
        for (;0 < index; ) {
          var parentIndex = index - 1 >>> 1, parent = heap[parentIndex];
          if (0 < compare(parent, node))
            heap[parentIndex] = node, heap[index] = parent, index = parentIndex;
          else
            break a;
        }
    }
    function peek(heap) {
      return heap.length === 0 ? null : heap[0];
    }
    function pop(heap) {
      if (heap.length === 0)
        return null;
      var first = heap[0], last = heap.pop();
      if (last !== first) {
        heap[0] = last;
        a:
          for (var index = 0, length = heap.length, halfLength = length >>> 1;index < halfLength; ) {
            var leftIndex = 2 * (index + 1) - 1, left = heap[leftIndex], rightIndex = leftIndex + 1, right = heap[rightIndex];
            if (0 > compare(left, last))
              rightIndex < length && 0 > compare(right, left) ? (heap[index] = right, heap[rightIndex] = last, index = rightIndex) : (heap[index] = left, heap[leftIndex] = last, index = leftIndex);
            else if (rightIndex < length && 0 > compare(right, last))
              heap[index] = right, heap[rightIndex] = last, index = rightIndex;
            else
              break a;
          }
      }
      return first;
    }
    function compare(a, b) {
      var diff = a.sortIndex - b.sortIndex;
      return diff !== 0 ? diff : a.id - b.id;
    }
    function advanceTimers(currentTime) {
      for (var timer = peek(timerQueue);timer !== null; ) {
        if (timer.callback === null)
          pop(timerQueue);
        else if (timer.startTime <= currentTime)
          pop(timerQueue), timer.sortIndex = timer.expirationTime, push(taskQueue, timer);
        else
          break;
        timer = peek(timerQueue);
      }
    }
    function handleTimeout(currentTime) {
      isHostTimeoutScheduled = false;
      advanceTimers(currentTime);
      if (!isHostCallbackScheduled)
        if (peek(taskQueue) !== null)
          isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline());
        else {
          var firstTimer = peek(timerQueue);
          firstTimer !== null && requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
        }
    }
    function shouldYieldToHost() {
      return needsPaint ? true : exports.unstable_now() - startTime < frameInterval ? false : true;
    }
    function requestHostTimeout(callback, ms) {
      taskTimeoutID = localSetTimeout(function() {
        callback(exports.unstable_now());
      }, ms);
    }
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    exports.unstable_now = undefined;
    if (typeof performance === "object" && typeof performance.now === "function") {
      var localPerformance = performance;
      exports.unstable_now = function() {
        return localPerformance.now();
      };
    } else {
      var localDate = Date, initialTime = localDate.now();
      exports.unstable_now = function() {
        return localDate.now() - initialTime;
      };
    }
    var taskQueue = [], timerQueue = [], taskIdCounter = 1, currentTask = null, currentPriorityLevel = 3, isPerformingWork = false, isHostCallbackScheduled = false, isHostTimeoutScheduled = false, needsPaint = false, localSetTimeout = typeof setTimeout === "function" ? setTimeout : null, localClearTimeout = typeof clearTimeout === "function" ? clearTimeout : null, localSetImmediate = typeof setImmediate !== "undefined" ? setImmediate : null, isMessageLoopRunning = false, taskTimeoutID = -1, frameInterval = 5, startTime = -1;
    if (typeof localSetImmediate === "function")
      var schedulePerformWorkUntilDeadline = function() {
        localSetImmediate(performWorkUntilDeadline);
      };
    else if (typeof MessageChannel !== "undefined") {
      var channel = new MessageChannel, port = channel.port2;
      channel.port1.onmessage = performWorkUntilDeadline;
      schedulePerformWorkUntilDeadline = function() {
        port.postMessage(null);
      };
    } else
      schedulePerformWorkUntilDeadline = function() {
        localSetTimeout(performWorkUntilDeadline, 0);
      };
    exports.unstable_IdlePriority = 5;
    exports.unstable_ImmediatePriority = 1;
    exports.unstable_LowPriority = 4;
    exports.unstable_NormalPriority = 3;
    exports.unstable_Profiling = null;
    exports.unstable_UserBlockingPriority = 2;
    exports.unstable_cancelCallback = function(task) {
      task.callback = null;
    };
    exports.unstable_forceFrameRate = function(fps) {
      0 > fps || 125 < fps ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : frameInterval = 0 < fps ? Math.floor(1000 / fps) : 5;
    };
    exports.unstable_getCurrentPriorityLevel = function() {
      return currentPriorityLevel;
    };
    exports.unstable_next = function(eventHandler) {
      switch (currentPriorityLevel) {
        case 1:
        case 2:
        case 3:
          var priorityLevel = 3;
          break;
        default:
          priorityLevel = currentPriorityLevel;
      }
      var previousPriorityLevel = currentPriorityLevel;
      currentPriorityLevel = priorityLevel;
      try {
        return eventHandler();
      } finally {
        currentPriorityLevel = previousPriorityLevel;
      }
    };
    exports.unstable_requestPaint = function() {
      needsPaint = true;
    };
    exports.unstable_runWithPriority = function(priorityLevel, eventHandler) {
      switch (priorityLevel) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          priorityLevel = 3;
      }
      var previousPriorityLevel = currentPriorityLevel;
      currentPriorityLevel = priorityLevel;
      try {
        return eventHandler();
      } finally {
        currentPriorityLevel = previousPriorityLevel;
      }
    };
    exports.unstable_scheduleCallback = function(priorityLevel, callback, options2) {
      var currentTime = exports.unstable_now();
      typeof options2 === "object" && options2 !== null ? (options2 = options2.delay, options2 = typeof options2 === "number" && 0 < options2 ? currentTime + options2 : currentTime) : options2 = currentTime;
      switch (priorityLevel) {
        case 1:
          var timeout = -1;
          break;
        case 2:
          timeout = 250;
          break;
        case 5:
          timeout = 1073741823;
          break;
        case 4:
          timeout = 1e4;
          break;
        default:
          timeout = 5000;
      }
      timeout = options2 + timeout;
      priorityLevel = {
        id: taskIdCounter++,
        callback,
        priorityLevel,
        startTime: options2,
        expirationTime: timeout,
        sortIndex: -1
      };
      options2 > currentTime ? (priorityLevel.sortIndex = options2, push(timerQueue, priorityLevel), peek(taskQueue) === null && priorityLevel === peek(timerQueue) && (isHostTimeoutScheduled ? (localClearTimeout(taskTimeoutID), taskTimeoutID = -1) : isHostTimeoutScheduled = true, requestHostTimeout(handleTimeout, options2 - currentTime))) : (priorityLevel.sortIndex = timeout, push(taskQueue, priorityLevel), isHostCallbackScheduled || isPerformingWork || (isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline())));
      return priorityLevel;
    };
    exports.unstable_shouldYield = shouldYieldToHost;
    exports.unstable_wrapCallback = function(callback) {
      var parentPriorityLevel = currentPriorityLevel;
      return function() {
        var previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = parentPriorityLevel;
        try {
          return callback.apply(this, arguments);
        } finally {
          currentPriorityLevel = previousPriorityLevel;
        }
      };
    };
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  })();
});

// node_modules/scheduler/index.js
var require_scheduler = __commonJS((exports, module) => {
  var scheduler_development = __toESM(require_scheduler_development());
  if (false) {} else {
    module.exports = scheduler_development;
  }
});

// node_modules/react-dom/cjs/react-dom.development.js
var require_react_dom_development = __commonJS((exports) => {
  var React6 = __toESM(require_react());
  (function() {
    function noop2() {}
    function testStringCoercion(value) {
      return "" + value;
    }
    function createPortal$1(children, containerInfo, implementation) {
      var key = 3 < arguments.length && arguments[3] !== undefined ? arguments[3] : null;
      try {
        testStringCoercion(key);
        var JSCompiler_inline_result = false;
      } catch (e7) {
        JSCompiler_inline_result = true;
      }
      JSCompiler_inline_result && (console.error("The provided key is an unsupported type %s. This value must be coerced to a string before using it here.", typeof Symbol === "function" && Symbol.toStringTag && key[Symbol.toStringTag] || key.constructor.name || "Object"), testStringCoercion(key));
      return {
        $$typeof: REACT_PORTAL_TYPE,
        key: key == null ? null : "" + key,
        children,
        containerInfo,
        implementation
      };
    }
    function getCrossOriginStringAs(as, input) {
      if (as === "font")
        return "";
      if (typeof input === "string")
        return input === "use-credentials" ? input : "";
    }
    function getValueDescriptorExpectingObjectForWarning(thing) {
      return thing === null ? "`null`" : thing === undefined ? "`undefined`" : thing === "" ? "an empty string" : 'something with type "' + typeof thing + '"';
    }
    function getValueDescriptorExpectingEnumForWarning(thing) {
      return thing === null ? "`null`" : thing === undefined ? "`undefined`" : thing === "" ? "an empty string" : typeof thing === "string" ? JSON.stringify(thing) : typeof thing === "number" ? "`" + thing + "`" : 'something with type "' + typeof thing + '"';
    }
    function resolveDispatcher() {
      var dispatcher = ReactSharedInternals.H;
      dispatcher === null && console.error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.`);
      return dispatcher;
    }
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var Internals = {
      d: {
        f: noop2,
        r: function() {
          throw Error("Invalid form element. requestFormReset must be passed a form that was rendered by React.");
        },
        D: noop2,
        C: noop2,
        L: noop2,
        m: noop2,
        X: noop2,
        S: noop2,
        M: noop2
      },
      p: 0,
      findDOMNode: null
    }, REACT_PORTAL_TYPE = Symbol.for("react.portal"), ReactSharedInternals = React6.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
    typeof Map === "function" && Map.prototype != null && typeof Map.prototype.forEach === "function" && typeof Set === "function" && Set.prototype != null && typeof Set.prototype.clear === "function" && typeof Set.prototype.forEach === "function" || console.error("React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
    exports.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = Internals;
    exports.createPortal = function(children, container) {
      var key = 2 < arguments.length && arguments[2] !== undefined ? arguments[2] : null;
      if (!container || container.nodeType !== 1 && container.nodeType !== 9 && container.nodeType !== 11)
        throw Error("Target container is not a DOM element.");
      return createPortal$1(children, container, null, key);
    };
    exports.flushSync = function(fn) {
      var previousTransition = ReactSharedInternals.T, previousUpdatePriority = Internals.p;
      try {
        if (ReactSharedInternals.T = null, Internals.p = 2, fn)
          return fn();
      } finally {
        ReactSharedInternals.T = previousTransition, Internals.p = previousUpdatePriority, Internals.d.f() && console.error("flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task.");
      }
    };
    exports.preconnect = function(href, options2) {
      typeof href === "string" && href ? options2 != null && typeof options2 !== "object" ? console.error("ReactDOM.preconnect(): Expected the `options` argument (second) to be an object but encountered %s instead. The only supported option at this time is `crossOrigin` which accepts a string.", getValueDescriptorExpectingEnumForWarning(options2)) : options2 != null && typeof options2.crossOrigin !== "string" && console.error("ReactDOM.preconnect(): Expected the `crossOrigin` option (second argument) to be a string but encountered %s instead. Try removing this option or passing a string value instead.", getValueDescriptorExpectingObjectForWarning(options2.crossOrigin)) : console.error("ReactDOM.preconnect(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.", getValueDescriptorExpectingObjectForWarning(href));
      typeof href === "string" && (options2 ? (options2 = options2.crossOrigin, options2 = typeof options2 === "string" ? options2 === "use-credentials" ? options2 : "" : undefined) : options2 = null, Internals.d.C(href, options2));
    };
    exports.prefetchDNS = function(href) {
      if (typeof href !== "string" || !href)
        console.error("ReactDOM.prefetchDNS(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.", getValueDescriptorExpectingObjectForWarning(href));
      else if (1 < arguments.length) {
        var options2 = arguments[1];
        typeof options2 === "object" && options2.hasOwnProperty("crossOrigin") ? console.error("ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. It looks like the you are attempting to set a crossOrigin property for this DNS lookup hint. Browsers do not perform DNS queries using CORS and setting this attribute on the resource hint has no effect. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.", getValueDescriptorExpectingEnumForWarning(options2)) : console.error("ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.", getValueDescriptorExpectingEnumForWarning(options2));
      }
      typeof href === "string" && Internals.d.D(href);
    };
    exports.preinit = function(href, options2) {
      typeof href === "string" && href ? options2 == null || typeof options2 !== "object" ? console.error("ReactDOM.preinit(): Expected the `options` argument (second) to be an object with an `as` property describing the type of resource to be preinitialized but encountered %s instead.", getValueDescriptorExpectingEnumForWarning(options2)) : options2.as !== "style" && options2.as !== "script" && console.error('ReactDOM.preinit(): Expected the `as` property in the `options` argument (second) to contain a valid value describing the type of resource to be preinitialized but encountered %s instead. Valid values for `as` are "style" and "script".', getValueDescriptorExpectingEnumForWarning(options2.as)) : console.error("ReactDOM.preinit(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.", getValueDescriptorExpectingObjectForWarning(href));
      if (typeof href === "string" && options2 && typeof options2.as === "string") {
        var as = options2.as, crossOrigin = getCrossOriginStringAs(as, options2.crossOrigin), integrity = typeof options2.integrity === "string" ? options2.integrity : undefined, fetchPriority = typeof options2.fetchPriority === "string" ? options2.fetchPriority : undefined;
        as === "style" ? Internals.d.S(href, typeof options2.precedence === "string" ? options2.precedence : undefined, {
          crossOrigin,
          integrity,
          fetchPriority
        }) : as === "script" && Internals.d.X(href, {
          crossOrigin,
          integrity,
          fetchPriority,
          nonce: typeof options2.nonce === "string" ? options2.nonce : undefined
        });
      }
    };
    exports.preinitModule = function(href, options2) {
      var encountered = "";
      typeof href === "string" && href || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href) + ".");
      options2 !== undefined && typeof options2 !== "object" ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options2) + "." : options2 && ("as" in options2) && options2.as !== "script" && (encountered += " The `as` option encountered was " + getValueDescriptorExpectingEnumForWarning(options2.as) + ".");
      if (encountered)
        console.error("ReactDOM.preinitModule(): Expected up to two arguments, a non-empty `href` string and, optionally, an `options` object with a valid `as` property.%s", encountered);
      else
        switch (encountered = options2 && typeof options2.as === "string" ? options2.as : "script", encountered) {
          case "script":
            break;
          default:
            encountered = getValueDescriptorExpectingEnumForWarning(encountered), console.error('ReactDOM.preinitModule(): Currently the only supported "as" type for this function is "script" but received "%s" instead. This warning was generated for `href` "%s". In the future other module types will be supported, aligning with the import-attributes proposal. Learn more here: (https://github.com/tc39/proposal-import-attributes)', encountered, href);
        }
      if (typeof href === "string")
        if (typeof options2 === "object" && options2 !== null) {
          if (options2.as == null || options2.as === "script")
            encountered = getCrossOriginStringAs(options2.as, options2.crossOrigin), Internals.d.M(href, {
              crossOrigin: encountered,
              integrity: typeof options2.integrity === "string" ? options2.integrity : undefined,
              nonce: typeof options2.nonce === "string" ? options2.nonce : undefined
            });
        } else
          options2 == null && Internals.d.M(href);
    };
    exports.preload = function(href, options2) {
      var encountered = "";
      typeof href === "string" && href || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href) + ".");
      options2 == null || typeof options2 !== "object" ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options2) + "." : typeof options2.as === "string" && options2.as || (encountered += " The `as` option encountered was " + getValueDescriptorExpectingObjectForWarning(options2.as) + ".");
      encountered && console.error('ReactDOM.preload(): Expected two arguments, a non-empty `href` string and an `options` object with an `as` property valid for a `<link rel="preload" as="..." />` tag.%s', encountered);
      if (typeof href === "string" && typeof options2 === "object" && options2 !== null && typeof options2.as === "string") {
        encountered = options2.as;
        var crossOrigin = getCrossOriginStringAs(encountered, options2.crossOrigin);
        Internals.d.L(href, encountered, {
          crossOrigin,
          integrity: typeof options2.integrity === "string" ? options2.integrity : undefined,
          nonce: typeof options2.nonce === "string" ? options2.nonce : undefined,
          type: typeof options2.type === "string" ? options2.type : undefined,
          fetchPriority: typeof options2.fetchPriority === "string" ? options2.fetchPriority : undefined,
          referrerPolicy: typeof options2.referrerPolicy === "string" ? options2.referrerPolicy : undefined,
          imageSrcSet: typeof options2.imageSrcSet === "string" ? options2.imageSrcSet : undefined,
          imageSizes: typeof options2.imageSizes === "string" ? options2.imageSizes : undefined,
          media: typeof options2.media === "string" ? options2.media : undefined
        });
      }
    };
    exports.preloadModule = function(href, options2) {
      var encountered = "";
      typeof href === "string" && href || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href) + ".");
      options2 !== undefined && typeof options2 !== "object" ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options2) + "." : options2 && ("as" in options2) && typeof options2.as !== "string" && (encountered += " The `as` option encountered was " + getValueDescriptorExpectingObjectForWarning(options2.as) + ".");
      encountered && console.error('ReactDOM.preloadModule(): Expected two arguments, a non-empty `href` string and, optionally, an `options` object with an `as` property valid for a `<link rel="modulepreload" as="..." />` tag.%s', encountered);
      typeof href === "string" && (options2 ? (encountered = getCrossOriginStringAs(options2.as, options2.crossOrigin), Internals.d.m(href, {
        as: typeof options2.as === "string" && options2.as !== "script" ? options2.as : undefined,
        crossOrigin: encountered,
        integrity: typeof options2.integrity === "string" ? options2.integrity : undefined
      })) : Internals.d.m(href));
    };
    exports.requestFormReset = function(form) {
      Internals.d.r(form);
    };
    exports.unstable_batchedUpdates = function(fn, a) {
      return fn(a);
    };
    exports.useFormState = function(action, initialState, permalink) {
      return resolveDispatcher().useFormState(action, initialState, permalink);
    };
    exports.useFormStatus = function() {
      return resolveDispatcher().useHostTransitionStatus();
    };
    exports.version = "19.2.3";
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  })();
});

// node_modules/react-dom/index.js
var require_react_dom = __commonJS((exports, module) => {
  var react_dom_development = __toESM(require_react_dom_development());
  if (false) {} else {
    module.exports = react_dom_development;
  }
});

// node_modules/react-dom/cjs/react-dom-client.development.js
var require_react_dom_client_development = __commonJS((exports) => {
  var Scheduler = __toESM(require_scheduler());
  var React6 = __toESM(require_react());
  var ReactDOM = __toESM(require_react_dom());
  (function() {
    function findHook(fiber, id) {
      for (fiber = fiber.memoizedState;fiber !== null && 0 < id; )
        fiber = fiber.next, id--;
      return fiber;
    }
    function copyWithSetImpl(obj, path, index, value) {
      if (index >= path.length)
        return value;
      var key = path[index], updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);
      updated[key] = copyWithSetImpl(obj[key], path, index + 1, value);
      return updated;
    }
    function copyWithRename(obj, oldPath, newPath) {
      if (oldPath.length !== newPath.length)
        console.warn("copyWithRename() expects paths of the same length");
      else {
        for (var i = 0;i < newPath.length - 1; i++)
          if (oldPath[i] !== newPath[i]) {
            console.warn("copyWithRename() expects paths to be the same except for the deepest key");
            return;
          }
        return copyWithRenameImpl(obj, oldPath, newPath, 0);
      }
    }
    function copyWithRenameImpl(obj, oldPath, newPath, index) {
      var oldKey = oldPath[index], updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);
      index + 1 === oldPath.length ? (updated[newPath[index]] = updated[oldKey], isArrayImpl(updated) ? updated.splice(oldKey, 1) : delete updated[oldKey]) : updated[oldKey] = copyWithRenameImpl(obj[oldKey], oldPath, newPath, index + 1);
      return updated;
    }
    function copyWithDeleteImpl(obj, path, index) {
      var key = path[index], updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);
      if (index + 1 === path.length)
        return isArrayImpl(updated) ? updated.splice(key, 1) : delete updated[key], updated;
      updated[key] = copyWithDeleteImpl(obj[key], path, index + 1);
      return updated;
    }
    function shouldSuspendImpl() {
      return false;
    }
    function shouldErrorImpl() {
      return null;
    }
    function warnInvalidHookAccess() {
      console.error("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://react.dev/link/rules-of-hooks");
    }
    function warnInvalidContextAccess() {
      console.error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
    }
    function noop2() {}
    function warnForMissingKey() {}
    function setToSortedString(set) {
      var array = [];
      set.forEach(function(value) {
        array.push(value);
      });
      return array.sort().join(", ");
    }
    function createFiber(tag, pendingProps, key, mode) {
      return new FiberNode(tag, pendingProps, key, mode);
    }
    function scheduleRoot(root2, element) {
      root2.context === emptyContextObject && (updateContainerImpl(root2.current, 2, element, root2, null, null), flushSyncWork$1());
    }
    function scheduleRefresh(root2, update) {
      if (resolveFamily !== null) {
        var staleFamilies = update.staleFamilies;
        update = update.updatedFamilies;
        flushPendingEffects();
        scheduleFibersWithFamiliesRecursively(root2.current, update, staleFamilies);
        flushSyncWork$1();
      }
    }
    function setRefreshHandler(handler) {
      resolveFamily = handler;
    }
    function isValidContainer(node) {
      return !(!node || node.nodeType !== 1 && node.nodeType !== 9 && node.nodeType !== 11);
    }
    function getNearestMountedFiber(fiber) {
      var node = fiber, nearestMounted = fiber;
      if (fiber.alternate)
        for (;node.return; )
          node = node.return;
      else {
        fiber = node;
        do
          node = fiber, (node.flags & 4098) !== 0 && (nearestMounted = node.return), fiber = node.return;
        while (fiber);
      }
      return node.tag === 3 ? nearestMounted : null;
    }
    function getSuspenseInstanceFromFiber(fiber) {
      if (fiber.tag === 13) {
        var suspenseState = fiber.memoizedState;
        suspenseState === null && (fiber = fiber.alternate, fiber !== null && (suspenseState = fiber.memoizedState));
        if (suspenseState !== null)
          return suspenseState.dehydrated;
      }
      return null;
    }
    function getActivityInstanceFromFiber(fiber) {
      if (fiber.tag === 31) {
        var activityState = fiber.memoizedState;
        activityState === null && (fiber = fiber.alternate, fiber !== null && (activityState = fiber.memoizedState));
        if (activityState !== null)
          return activityState.dehydrated;
      }
      return null;
    }
    function assertIsMounted(fiber) {
      if (getNearestMountedFiber(fiber) !== fiber)
        throw Error("Unable to find node on an unmounted component.");
    }
    function findCurrentFiberUsingSlowPath(fiber) {
      var alternate = fiber.alternate;
      if (!alternate) {
        alternate = getNearestMountedFiber(fiber);
        if (alternate === null)
          throw Error("Unable to find node on an unmounted component.");
        return alternate !== fiber ? null : fiber;
      }
      for (var a = fiber, b = alternate;; ) {
        var parentA = a.return;
        if (parentA === null)
          break;
        var parentB = parentA.alternate;
        if (parentB === null) {
          b = parentA.return;
          if (b !== null) {
            a = b;
            continue;
          }
          break;
        }
        if (parentA.child === parentB.child) {
          for (parentB = parentA.child;parentB; ) {
            if (parentB === a)
              return assertIsMounted(parentA), fiber;
            if (parentB === b)
              return assertIsMounted(parentA), alternate;
            parentB = parentB.sibling;
          }
          throw Error("Unable to find node on an unmounted component.");
        }
        if (a.return !== b.return)
          a = parentA, b = parentB;
        else {
          for (var didFindChild = false, _child = parentA.child;_child; ) {
            if (_child === a) {
              didFindChild = true;
              a = parentA;
              b = parentB;
              break;
            }
            if (_child === b) {
              didFindChild = true;
              b = parentA;
              a = parentB;
              break;
            }
            _child = _child.sibling;
          }
          if (!didFindChild) {
            for (_child = parentB.child;_child; ) {
              if (_child === a) {
                didFindChild = true;
                a = parentB;
                b = parentA;
                break;
              }
              if (_child === b) {
                didFindChild = true;
                b = parentB;
                a = parentA;
                break;
              }
              _child = _child.sibling;
            }
            if (!didFindChild)
              throw Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
          }
        }
        if (a.alternate !== b)
          throw Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
      }
      if (a.tag !== 3)
        throw Error("Unable to find node on an unmounted component.");
      return a.stateNode.current === a ? fiber : alternate;
    }
    function findCurrentHostFiberImpl(node) {
      var tag = node.tag;
      if (tag === 5 || tag === 26 || tag === 27 || tag === 6)
        return node;
      for (node = node.child;node !== null; ) {
        tag = findCurrentHostFiberImpl(node);
        if (tag !== null)
          return tag;
        node = node.sibling;
      }
      return null;
    }
    function getIteratorFn(maybeIterable) {
      if (maybeIterable === null || typeof maybeIterable !== "object")
        return null;
      maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
      return typeof maybeIterable === "function" ? maybeIterable : null;
    }
    function getComponentNameFromType(type) {
      if (type == null)
        return null;
      if (typeof type === "function")
        return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
      if (typeof type === "string")
        return type;
      switch (type) {
        case REACT_FRAGMENT_TYPE:
          return "Fragment";
        case REACT_PROFILER_TYPE:
          return "Profiler";
        case REACT_STRICT_MODE_TYPE:
          return "StrictMode";
        case REACT_SUSPENSE_TYPE:
          return "Suspense";
        case REACT_SUSPENSE_LIST_TYPE:
          return "SuspenseList";
        case REACT_ACTIVITY_TYPE:
          return "Activity";
      }
      if (typeof type === "object")
        switch (typeof type.tag === "number" && console.error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), type.$$typeof) {
          case REACT_PORTAL_TYPE:
            return "Portal";
          case REACT_CONTEXT_TYPE:
            return type.displayName || "Context";
          case REACT_CONSUMER_TYPE:
            return (type._context.displayName || "Context") + ".Consumer";
          case REACT_FORWARD_REF_TYPE:
            var innerType = type.render;
            type = type.displayName;
            type || (type = innerType.displayName || innerType.name || "", type = type !== "" ? "ForwardRef(" + type + ")" : "ForwardRef");
            return type;
          case REACT_MEMO_TYPE:
            return innerType = type.displayName || null, innerType !== null ? innerType : getComponentNameFromType(type.type) || "Memo";
          case REACT_LAZY_TYPE:
            innerType = type._payload;
            type = type._init;
            try {
              return getComponentNameFromType(type(innerType));
            } catch (x) {}
        }
      return null;
    }
    function getComponentNameFromOwner(owner) {
      return typeof owner.tag === "number" ? getComponentNameFromFiber(owner) : typeof owner.name === "string" ? owner.name : null;
    }
    function getComponentNameFromFiber(fiber) {
      var type = fiber.type;
      switch (fiber.tag) {
        case 31:
          return "Activity";
        case 24:
          return "Cache";
        case 9:
          return (type._context.displayName || "Context") + ".Consumer";
        case 10:
          return type.displayName || "Context";
        case 18:
          return "DehydratedFragment";
        case 11:
          return fiber = type.render, fiber = fiber.displayName || fiber.name || "", type.displayName || (fiber !== "" ? "ForwardRef(" + fiber + ")" : "ForwardRef");
        case 7:
          return "Fragment";
        case 26:
        case 27:
        case 5:
          return type;
        case 4:
          return "Portal";
        case 3:
          return "Root";
        case 6:
          return "Text";
        case 16:
          return getComponentNameFromType(type);
        case 8:
          return type === REACT_STRICT_MODE_TYPE ? "StrictMode" : "Mode";
        case 22:
          return "Offscreen";
        case 12:
          return "Profiler";
        case 21:
          return "Scope";
        case 13:
          return "Suspense";
        case 19:
          return "SuspenseList";
        case 25:
          return "TracingMarker";
        case 1:
        case 0:
        case 14:
        case 15:
          if (typeof type === "function")
            return type.displayName || type.name || null;
          if (typeof type === "string")
            return type;
          break;
        case 29:
          type = fiber._debugInfo;
          if (type != null) {
            for (var i = type.length - 1;0 <= i; i--)
              if (typeof type[i].name === "string")
                return type[i].name;
          }
          if (fiber.return !== null)
            return getComponentNameFromFiber(fiber.return);
      }
      return null;
    }
    function createCursor(defaultValue) {
      return { current: defaultValue };
    }
    function pop(cursor, fiber) {
      0 > index$jscomp$0 ? console.error("Unexpected pop.") : (fiber !== fiberStack[index$jscomp$0] && console.error("Unexpected Fiber popped."), cursor.current = valueStack[index$jscomp$0], valueStack[index$jscomp$0] = null, fiberStack[index$jscomp$0] = null, index$jscomp$0--);
    }
    function push(cursor, value, fiber) {
      index$jscomp$0++;
      valueStack[index$jscomp$0] = cursor.current;
      fiberStack[index$jscomp$0] = fiber;
      cursor.current = value;
    }
    function requiredContext(c) {
      c === null && console.error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
      return c;
    }
    function pushHostContainer(fiber, nextRootInstance) {
      push(rootInstanceStackCursor, nextRootInstance, fiber);
      push(contextFiberStackCursor, fiber, fiber);
      push(contextStackCursor, null, fiber);
      var nextRootContext = nextRootInstance.nodeType;
      switch (nextRootContext) {
        case 9:
        case 11:
          nextRootContext = nextRootContext === 9 ? "#document" : "#fragment";
          nextRootInstance = (nextRootInstance = nextRootInstance.documentElement) ? (nextRootInstance = nextRootInstance.namespaceURI) ? getOwnHostContext(nextRootInstance) : HostContextNamespaceNone : HostContextNamespaceNone;
          break;
        default:
          if (nextRootContext = nextRootInstance.tagName, nextRootInstance = nextRootInstance.namespaceURI)
            nextRootInstance = getOwnHostContext(nextRootInstance), nextRootInstance = getChildHostContextProd(nextRootInstance, nextRootContext);
          else
            switch (nextRootContext) {
              case "svg":
                nextRootInstance = HostContextNamespaceSvg;
                break;
              case "math":
                nextRootInstance = HostContextNamespaceMath;
                break;
              default:
                nextRootInstance = HostContextNamespaceNone;
            }
      }
      nextRootContext = nextRootContext.toLowerCase();
      nextRootContext = updatedAncestorInfoDev(null, nextRootContext);
      nextRootContext = {
        context: nextRootInstance,
        ancestorInfo: nextRootContext
      };
      pop(contextStackCursor, fiber);
      push(contextStackCursor, nextRootContext, fiber);
    }
    function popHostContainer(fiber) {
      pop(contextStackCursor, fiber);
      pop(contextFiberStackCursor, fiber);
      pop(rootInstanceStackCursor, fiber);
    }
    function getHostContext() {
      return requiredContext(contextStackCursor.current);
    }
    function pushHostContext(fiber) {
      fiber.memoizedState !== null && push(hostTransitionProviderCursor, fiber, fiber);
      var context = requiredContext(contextStackCursor.current);
      var type = fiber.type;
      var nextContext = getChildHostContextProd(context.context, type);
      type = updatedAncestorInfoDev(context.ancestorInfo, type);
      nextContext = { context: nextContext, ancestorInfo: type };
      context !== nextContext && (push(contextFiberStackCursor, fiber, fiber), push(contextStackCursor, nextContext, fiber));
    }
    function popHostContext(fiber) {
      contextFiberStackCursor.current === fiber && (pop(contextStackCursor, fiber), pop(contextFiberStackCursor, fiber));
      hostTransitionProviderCursor.current === fiber && (pop(hostTransitionProviderCursor, fiber), HostTransitionContext._currentValue = NotPendingTransition);
    }
    function disabledLog() {}
    function disableLogs() {
      if (disabledDepth === 0) {
        prevLog = console.log;
        prevInfo = console.info;
        prevWarn = console.warn;
        prevError = console.error;
        prevGroup = console.group;
        prevGroupCollapsed = console.groupCollapsed;
        prevGroupEnd = console.groupEnd;
        var props = {
          configurable: true,
          enumerable: true,
          value: disabledLog,
          writable: true
        };
        Object.defineProperties(console, {
          info: props,
          log: props,
          warn: props,
          error: props,
          group: props,
          groupCollapsed: props,
          groupEnd: props
        });
      }
      disabledDepth++;
    }
    function reenableLogs() {
      disabledDepth--;
      if (disabledDepth === 0) {
        var props = { configurable: true, enumerable: true, writable: true };
        Object.defineProperties(console, {
          log: assign({}, props, { value: prevLog }),
          info: assign({}, props, { value: prevInfo }),
          warn: assign({}, props, { value: prevWarn }),
          error: assign({}, props, { value: prevError }),
          group: assign({}, props, { value: prevGroup }),
          groupCollapsed: assign({}, props, { value: prevGroupCollapsed }),
          groupEnd: assign({}, props, { value: prevGroupEnd })
        });
      }
      0 > disabledDepth && console.error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
    }
    function formatOwnerStack(error) {
      var prevPrepareStackTrace = Error.prepareStackTrace;
      Error.prepareStackTrace = undefined;
      error = error.stack;
      Error.prepareStackTrace = prevPrepareStackTrace;
      error.startsWith(`Error: react-stack-top-frame
`) && (error = error.slice(29));
      prevPrepareStackTrace = error.indexOf(`
`);
      prevPrepareStackTrace !== -1 && (error = error.slice(prevPrepareStackTrace + 1));
      prevPrepareStackTrace = error.indexOf("react_stack_bottom_frame");
      prevPrepareStackTrace !== -1 && (prevPrepareStackTrace = error.lastIndexOf(`
`, prevPrepareStackTrace));
      if (prevPrepareStackTrace !== -1)
        error = error.slice(0, prevPrepareStackTrace);
      else
        return "";
      return error;
    }
    function describeBuiltInComponentFrame(name) {
      if (prefix === undefined)
        try {
          throw Error();
        } catch (x) {
          var match = x.stack.trim().match(/\n( *(at )?)/);
          prefix = match && match[1] || "";
          suffix = -1 < x.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < x.stack.indexOf("@") ? "@unknown:0:0" : "";
        }
      return `
` + prefix + name + suffix;
    }
    function describeNativeComponentFrame(fn, construct) {
      if (!fn || reentry)
        return "";
      var frame = componentFrameCache.get(fn);
      if (frame !== undefined)
        return frame;
      reentry = true;
      frame = Error.prepareStackTrace;
      Error.prepareStackTrace = undefined;
      var previousDispatcher2 = null;
      previousDispatcher2 = ReactSharedInternals.H;
      ReactSharedInternals.H = null;
      disableLogs();
      try {
        var RunInRootFrame = {
          DetermineComponentFrameRoot: function() {
            try {
              if (construct) {
                var Fake = function() {
                  throw Error();
                };
                Object.defineProperty(Fake.prototype, "props", {
                  set: function() {
                    throw Error();
                  }
                });
                if (typeof Reflect === "object" && Reflect.construct) {
                  try {
                    Reflect.construct(Fake, []);
                  } catch (x) {
                    var control = x;
                  }
                  Reflect.construct(fn, [], Fake);
                } else {
                  try {
                    Fake.call();
                  } catch (x$0) {
                    control = x$0;
                  }
                  fn.call(Fake.prototype);
                }
              } else {
                try {
                  throw Error();
                } catch (x$1) {
                  control = x$1;
                }
                (Fake = fn()) && typeof Fake.catch === "function" && Fake.catch(function() {});
              }
            } catch (sample) {
              if (sample && control && typeof sample.stack === "string")
                return [sample.stack, control.stack];
            }
            return [null, null];
          }
        };
        RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
        var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, "name");
        namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, "name", { value: "DetermineComponentFrameRoot" });
        var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];
        if (sampleStack && controlStack) {
          var sampleLines = sampleStack.split(`
`), controlLines = controlStack.split(`
`);
          for (_RunInRootFrame$Deter = namePropDescriptor = 0;namePropDescriptor < sampleLines.length && !sampleLines[namePropDescriptor].includes("DetermineComponentFrameRoot"); )
            namePropDescriptor++;
          for (;_RunInRootFrame$Deter < controlLines.length && !controlLines[_RunInRootFrame$Deter].includes("DetermineComponentFrameRoot"); )
            _RunInRootFrame$Deter++;
          if (namePropDescriptor === sampleLines.length || _RunInRootFrame$Deter === controlLines.length)
            for (namePropDescriptor = sampleLines.length - 1, _RunInRootFrame$Deter = controlLines.length - 1;1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter && sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]; )
              _RunInRootFrame$Deter--;
          for (;1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter; namePropDescriptor--, _RunInRootFrame$Deter--)
            if (sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
              if (namePropDescriptor !== 1 || _RunInRootFrame$Deter !== 1) {
                do
                  if (namePropDescriptor--, _RunInRootFrame$Deter--, 0 > _RunInRootFrame$Deter || sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
                    var _frame = `
` + sampleLines[namePropDescriptor].replace(" at new ", " at ");
                    fn.displayName && _frame.includes("<anonymous>") && (_frame = _frame.replace("<anonymous>", fn.displayName));
                    typeof fn === "function" && componentFrameCache.set(fn, _frame);
                    return _frame;
                  }
                while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter);
              }
              break;
            }
        }
      } finally {
        reentry = false, ReactSharedInternals.H = previousDispatcher2, reenableLogs(), Error.prepareStackTrace = frame;
      }
      sampleLines = (sampleLines = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(sampleLines) : "";
      typeof fn === "function" && componentFrameCache.set(fn, sampleLines);
      return sampleLines;
    }
    function describeFiber(fiber, childFiber) {
      switch (fiber.tag) {
        case 26:
        case 27:
        case 5:
          return describeBuiltInComponentFrame(fiber.type);
        case 16:
          return describeBuiltInComponentFrame("Lazy");
        case 13:
          return fiber.child !== childFiber && childFiber !== null ? describeBuiltInComponentFrame("Suspense Fallback") : describeBuiltInComponentFrame("Suspense");
        case 19:
          return describeBuiltInComponentFrame("SuspenseList");
        case 0:
        case 15:
          return describeNativeComponentFrame(fiber.type, false);
        case 11:
          return describeNativeComponentFrame(fiber.type.render, false);
        case 1:
          return describeNativeComponentFrame(fiber.type, true);
        case 31:
          return describeBuiltInComponentFrame("Activity");
        default:
          return "";
      }
    }
    function getStackByFiberInDevAndProd(workInProgress2) {
      try {
        var info = "", previous = null;
        do {
          info += describeFiber(workInProgress2, previous);
          var debugInfo = workInProgress2._debugInfo;
          if (debugInfo)
            for (var i = debugInfo.length - 1;0 <= i; i--) {
              var entry = debugInfo[i];
              if (typeof entry.name === "string") {
                var JSCompiler_temp_const = info;
                a: {
                  var { name, env: env2, debugLocation: location } = entry;
                  if (location != null) {
                    var childStack = formatOwnerStack(location), idx = childStack.lastIndexOf(`
`), lastLine = idx === -1 ? childStack : childStack.slice(idx + 1);
                    if (lastLine.indexOf(name) !== -1) {
                      var JSCompiler_inline_result = `
` + lastLine;
                      break a;
                    }
                  }
                  JSCompiler_inline_result = describeBuiltInComponentFrame(name + (env2 ? " [" + env2 + "]" : ""));
                }
                info = JSCompiler_temp_const + JSCompiler_inline_result;
              }
            }
          previous = workInProgress2;
          workInProgress2 = workInProgress2.return;
        } while (workInProgress2);
        return info;
      } catch (x) {
        return `
Error generating stack: ` + x.message + `
` + x.stack;
      }
    }
    function describeFunctionComponentFrameWithoutLineNumber(fn) {
      return (fn = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(fn) : "";
    }
    function getCurrentFiberOwnerNameInDevOrNull() {
      if (current === null)
        return null;
      var owner = current._debugOwner;
      return owner != null ? getComponentNameFromOwner(owner) : null;
    }
    function getCurrentFiberStackInDev() {
      if (current === null)
        return "";
      var workInProgress2 = current;
      try {
        var info = "";
        workInProgress2.tag === 6 && (workInProgress2 = workInProgress2.return);
        switch (workInProgress2.tag) {
          case 26:
          case 27:
          case 5:
            info += describeBuiltInComponentFrame(workInProgress2.type);
            break;
          case 13:
            info += describeBuiltInComponentFrame("Suspense");
            break;
          case 19:
            info += describeBuiltInComponentFrame("SuspenseList");
            break;
          case 31:
            info += describeBuiltInComponentFrame("Activity");
            break;
          case 30:
          case 0:
          case 15:
          case 1:
            workInProgress2._debugOwner || info !== "" || (info += describeFunctionComponentFrameWithoutLineNumber(workInProgress2.type));
            break;
          case 11:
            workInProgress2._debugOwner || info !== "" || (info += describeFunctionComponentFrameWithoutLineNumber(workInProgress2.type.render));
        }
        for (;workInProgress2; )
          if (typeof workInProgress2.tag === "number") {
            var fiber = workInProgress2;
            workInProgress2 = fiber._debugOwner;
            var debugStack = fiber._debugStack;
            if (workInProgress2 && debugStack) {
              var formattedStack = formatOwnerStack(debugStack);
              formattedStack !== "" && (info += `
` + formattedStack);
            }
          } else if (workInProgress2.debugStack != null) {
            var ownerStack = workInProgress2.debugStack;
            (workInProgress2 = workInProgress2.owner) && ownerStack && (info += `
` + formatOwnerStack(ownerStack));
          } else
            break;
        var JSCompiler_inline_result = info;
      } catch (x) {
        JSCompiler_inline_result = `
Error generating stack: ` + x.message + `
` + x.stack;
      }
      return JSCompiler_inline_result;
    }
    function runWithFiberInDEV(fiber, callback, arg0, arg1, arg2, arg3, arg4) {
      var previousFiber = current;
      setCurrentFiber(fiber);
      try {
        return fiber !== null && fiber._debugTask ? fiber._debugTask.run(callback.bind(null, arg0, arg1, arg2, arg3, arg4)) : callback(arg0, arg1, arg2, arg3, arg4);
      } finally {
        setCurrentFiber(previousFiber);
      }
      throw Error("runWithFiberInDEV should never be called in production. This is a bug in React.");
    }
    function setCurrentFiber(fiber) {
      ReactSharedInternals.getCurrentStack = fiber === null ? null : getCurrentFiberStackInDev;
      isRendering = false;
      current = fiber;
    }
    function typeName(value) {
      return typeof Symbol === "function" && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
    }
    function willCoercionThrow(value) {
      try {
        return testStringCoercion(value), false;
      } catch (e7) {
        return true;
      }
    }
    function testStringCoercion(value) {
      return "" + value;
    }
    function checkAttributeStringCoercion(value, attributeName) {
      if (willCoercionThrow(value))
        return console.error("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before using it here.", attributeName, typeName(value)), testStringCoercion(value);
    }
    function checkCSSPropertyStringCoercion(value, propName) {
      if (willCoercionThrow(value))
        return console.error("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before using it here.", propName, typeName(value)), testStringCoercion(value);
    }
    function checkFormFieldValueStringCoercion(value) {
      if (willCoercionThrow(value))
        return console.error("Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before using it here.", typeName(value)), testStringCoercion(value);
    }
    function injectInternals(internals) {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined")
        return false;
      var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (hook.isDisabled)
        return true;
      if (!hook.supportsFiber)
        return console.error("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://react.dev/link/react-devtools"), true;
      try {
        rendererID = hook.inject(internals), injectedHook = hook;
      } catch (err) {
        console.error("React instrumentation encountered an error: %o.", err);
      }
      return hook.checkDCE ? true : false;
    }
    function setIsStrictModeForDevtools(newIsStrictMode) {
      typeof log$1 === "function" && unstable_setDisableYieldValue2(newIsStrictMode);
      if (injectedHook && typeof injectedHook.setStrictMode === "function")
        try {
          injectedHook.setStrictMode(rendererID, newIsStrictMode);
        } catch (err) {
          hasLoggedError || (hasLoggedError = true, console.error("React instrumentation encountered an error: %o", err));
        }
    }
    function clz32Fallback(x) {
      x >>>= 0;
      return x === 0 ? 32 : 31 - (log2(x) / LN2 | 0) | 0;
    }
    function getHighestPriorityLanes(lanes) {
      var pendingSyncLanes = lanes & 42;
      if (pendingSyncLanes !== 0)
        return pendingSyncLanes;
      switch (lanes & -lanes) {
        case 1:
          return 1;
        case 2:
          return 2;
        case 4:
          return 4;
        case 8:
          return 8;
        case 16:
          return 16;
        case 32:
          return 32;
        case 64:
          return 64;
        case 128:
          return 128;
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
          return lanes & 261888;
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return lanes & 3932160;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          return lanes & 62914560;
        case 67108864:
          return 67108864;
        case 134217728:
          return 134217728;
        case 268435456:
          return 268435456;
        case 536870912:
          return 536870912;
        case 1073741824:
          return 0;
        default:
          return console.error("Should have found matching lanes. This is a bug in React."), lanes;
      }
    }
    function getNextLanes(root2, wipLanes, rootHasPendingCommit) {
      var pendingLanes = root2.pendingLanes;
      if (pendingLanes === 0)
        return 0;
      var nextLanes = 0, suspendedLanes = root2.suspendedLanes, pingedLanes = root2.pingedLanes;
      root2 = root2.warmLanes;
      var nonIdlePendingLanes = pendingLanes & 134217727;
      nonIdlePendingLanes !== 0 ? (pendingLanes = nonIdlePendingLanes & ~suspendedLanes, pendingLanes !== 0 ? nextLanes = getHighestPriorityLanes(pendingLanes) : (pingedLanes &= nonIdlePendingLanes, pingedLanes !== 0 ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = nonIdlePendingLanes & ~root2, rootHasPendingCommit !== 0 && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))))) : (nonIdlePendingLanes = pendingLanes & ~suspendedLanes, nonIdlePendingLanes !== 0 ? nextLanes = getHighestPriorityLanes(nonIdlePendingLanes) : pingedLanes !== 0 ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = pendingLanes & ~root2, rootHasPendingCommit !== 0 && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))));
      return nextLanes === 0 ? 0 : wipLanes !== 0 && wipLanes !== nextLanes && (wipLanes & suspendedLanes) === 0 && (suspendedLanes = nextLanes & -nextLanes, rootHasPendingCommit = wipLanes & -wipLanes, suspendedLanes >= rootHasPendingCommit || suspendedLanes === 32 && (rootHasPendingCommit & 4194048) !== 0) ? wipLanes : nextLanes;
    }
    function checkIfRootIsPrerendering(root2, renderLanes2) {
      return (root2.pendingLanes & ~(root2.suspendedLanes & ~root2.pingedLanes) & renderLanes2) === 0;
    }
    function computeExpirationTime(lane, currentTime) {
      switch (lane) {
        case 1:
        case 2:
        case 4:
        case 8:
        case 64:
          return currentTime + 250;
        case 16:
        case 32:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return currentTime + 5000;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          return -1;
        case 67108864:
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
          return -1;
        default:
          return console.error("Should have found matching lanes. This is a bug in React."), -1;
      }
    }
    function claimNextRetryLane() {
      var lane = nextRetryLane;
      nextRetryLane <<= 1;
      (nextRetryLane & 62914560) === 0 && (nextRetryLane = 4194304);
      return lane;
    }
    function createLaneMap(initial) {
      for (var laneMap = [], i = 0;31 > i; i++)
        laneMap.push(initial);
      return laneMap;
    }
    function markRootUpdated$1(root2, updateLane) {
      root2.pendingLanes |= updateLane;
      updateLane !== 268435456 && (root2.suspendedLanes = 0, root2.pingedLanes = 0, root2.warmLanes = 0);
    }
    function markRootFinished(root2, finishedLanes, remainingLanes, spawnedLane, updatedLanes, suspendedRetryLanes) {
      var previouslyPendingLanes = root2.pendingLanes;
      root2.pendingLanes = remainingLanes;
      root2.suspendedLanes = 0;
      root2.pingedLanes = 0;
      root2.warmLanes = 0;
      root2.expiredLanes &= remainingLanes;
      root2.entangledLanes &= remainingLanes;
      root2.errorRecoveryDisabledLanes &= remainingLanes;
      root2.shellSuspendCounter = 0;
      var { entanglements, expirationTimes, hiddenUpdates } = root2;
      for (remainingLanes = previouslyPendingLanes & ~remainingLanes;0 < remainingLanes; ) {
        var index = 31 - clz32(remainingLanes), lane = 1 << index;
        entanglements[index] = 0;
        expirationTimes[index] = -1;
        var hiddenUpdatesForLane = hiddenUpdates[index];
        if (hiddenUpdatesForLane !== null)
          for (hiddenUpdates[index] = null, index = 0;index < hiddenUpdatesForLane.length; index++) {
            var update = hiddenUpdatesForLane[index];
            update !== null && (update.lane &= -536870913);
          }
        remainingLanes &= ~lane;
      }
      spawnedLane !== 0 && markSpawnedDeferredLane(root2, spawnedLane, 0);
      suspendedRetryLanes !== 0 && updatedLanes === 0 && root2.tag !== 0 && (root2.suspendedLanes |= suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));
    }
    function markSpawnedDeferredLane(root2, spawnedLane, entangledLanes) {
      root2.pendingLanes |= spawnedLane;
      root2.suspendedLanes &= ~spawnedLane;
      var spawnedLaneIndex = 31 - clz32(spawnedLane);
      root2.entangledLanes |= spawnedLane;
      root2.entanglements[spawnedLaneIndex] = root2.entanglements[spawnedLaneIndex] | 1073741824 | entangledLanes & 261930;
    }
    function markRootEntangled(root2, entangledLanes) {
      var rootEntangledLanes = root2.entangledLanes |= entangledLanes;
      for (root2 = root2.entanglements;rootEntangledLanes; ) {
        var index = 31 - clz32(rootEntangledLanes), lane = 1 << index;
        lane & entangledLanes | root2[index] & entangledLanes && (root2[index] |= entangledLanes);
        rootEntangledLanes &= ~lane;
      }
    }
    function getBumpedLaneForHydration(root2, renderLanes2) {
      var renderLane = renderLanes2 & -renderLanes2;
      renderLane = (renderLane & 42) !== 0 ? 1 : getBumpedLaneForHydrationByLane(renderLane);
      return (renderLane & (root2.suspendedLanes | renderLanes2)) !== 0 ? 0 : renderLane;
    }
    function getBumpedLaneForHydrationByLane(lane) {
      switch (lane) {
        case 2:
          lane = 1;
          break;
        case 8:
          lane = 4;
          break;
        case 32:
          lane = 16;
          break;
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          lane = 128;
          break;
        case 268435456:
          lane = 134217728;
          break;
        default:
          lane = 0;
      }
      return lane;
    }
    function addFiberToLanesMap(root2, fiber, lanes) {
      if (isDevToolsPresent)
        for (root2 = root2.pendingUpdatersLaneMap;0 < lanes; ) {
          var index = 31 - clz32(lanes), lane = 1 << index;
          root2[index].add(fiber);
          lanes &= ~lane;
        }
    }
    function movePendingFibersToMemoized(root2, lanes) {
      if (isDevToolsPresent)
        for (var { pendingUpdatersLaneMap, memoizedUpdaters } = root2;0 < lanes; ) {
          var index = 31 - clz32(lanes);
          root2 = 1 << index;
          index = pendingUpdatersLaneMap[index];
          0 < index.size && (index.forEach(function(fiber) {
            var alternate = fiber.alternate;
            alternate !== null && memoizedUpdaters.has(alternate) || memoizedUpdaters.add(fiber);
          }), index.clear());
          lanes &= ~root2;
        }
    }
    function lanesToEventPriority(lanes) {
      lanes &= -lanes;
      return DiscreteEventPriority !== 0 && DiscreteEventPriority < lanes ? ContinuousEventPriority !== 0 && ContinuousEventPriority < lanes ? (lanes & 134217727) !== 0 ? DefaultEventPriority : IdleEventPriority : ContinuousEventPriority : DiscreteEventPriority;
    }
    function resolveUpdatePriority() {
      var updatePriority = ReactDOMSharedInternals.p;
      if (updatePriority !== 0)
        return updatePriority;
      updatePriority = window.event;
      return updatePriority === undefined ? DefaultEventPriority : getEventPriority(updatePriority.type);
    }
    function runWithPriority(priority, fn) {
      var previousPriority = ReactDOMSharedInternals.p;
      try {
        return ReactDOMSharedInternals.p = priority, fn();
      } finally {
        ReactDOMSharedInternals.p = previousPriority;
      }
    }
    function detachDeletedInstance(node) {
      delete node[internalInstanceKey];
      delete node[internalPropsKey];
      delete node[internalEventHandlersKey];
      delete node[internalEventHandlerListenersKey];
      delete node[internalEventHandlesSetKey];
    }
    function getClosestInstanceFromNode(targetNode) {
      var targetInst = targetNode[internalInstanceKey];
      if (targetInst)
        return targetInst;
      for (var parentNode = targetNode.parentNode;parentNode; ) {
        if (targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey]) {
          parentNode = targetInst.alternate;
          if (targetInst.child !== null || parentNode !== null && parentNode.child !== null)
            for (targetNode = getParentHydrationBoundary(targetNode);targetNode !== null; ) {
              if (parentNode = targetNode[internalInstanceKey])
                return parentNode;
              targetNode = getParentHydrationBoundary(targetNode);
            }
          return targetInst;
        }
        targetNode = parentNode;
        parentNode = targetNode.parentNode;
      }
      return null;
    }
    function getInstanceFromNode(node) {
      if (node = node[internalInstanceKey] || node[internalContainerInstanceKey]) {
        var tag = node.tag;
        if (tag === 5 || tag === 6 || tag === 13 || tag === 31 || tag === 26 || tag === 27 || tag === 3)
          return node;
      }
      return null;
    }
    function getNodeFromInstance(inst) {
      var tag = inst.tag;
      if (tag === 5 || tag === 26 || tag === 27 || tag === 6)
        return inst.stateNode;
      throw Error("getNodeFromInstance: Invalid argument.");
    }
    function getResourcesFromRoot(root2) {
      var resources = root2[internalRootNodeResourcesKey];
      resources || (resources = root2[internalRootNodeResourcesKey] = { hoistableStyles: new Map, hoistableScripts: new Map });
      return resources;
    }
    function markNodeAsHoistable(node) {
      node[internalHoistableMarker] = true;
    }
    function registerTwoPhaseEvent(registrationName, dependencies) {
      registerDirectEvent(registrationName, dependencies);
      registerDirectEvent(registrationName + "Capture", dependencies);
    }
    function registerDirectEvent(registrationName, dependencies) {
      registrationNameDependencies[registrationName] && console.error("EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.", registrationName);
      registrationNameDependencies[registrationName] = dependencies;
      var lowerCasedName = registrationName.toLowerCase();
      possibleRegistrationNames[lowerCasedName] = registrationName;
      registrationName === "onDoubleClick" && (possibleRegistrationNames.ondblclick = registrationName);
      for (registrationName = 0;registrationName < dependencies.length; registrationName++)
        allNativeEvents.add(dependencies[registrationName]);
    }
    function checkControlledValueProps(tagName, props) {
      hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null || (tagName === "select" ? console.error("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set `onChange`.") : console.error("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."));
      props.onChange || props.readOnly || props.disabled || props.checked == null || console.error("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
    }
    function isAttributeNameSafe(attributeName) {
      if (hasOwnProperty.call(validatedAttributeNameCache, attributeName))
        return true;
      if (hasOwnProperty.call(illegalAttributeNameCache, attributeName))
        return false;
      if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))
        return validatedAttributeNameCache[attributeName] = true;
      illegalAttributeNameCache[attributeName] = true;
      console.error("Invalid attribute name: `%s`", attributeName);
      return false;
    }
    function getValueForAttributeOnCustomComponent(node, name, expected) {
      if (isAttributeNameSafe(name)) {
        if (!node.hasAttribute(name)) {
          switch (typeof expected) {
            case "symbol":
            case "object":
              return expected;
            case "function":
              return expected;
            case "boolean":
              if (expected === false)
                return expected;
          }
          return expected === undefined ? undefined : null;
        }
        node = node.getAttribute(name);
        if (node === "" && expected === true)
          return true;
        checkAttributeStringCoercion(expected, name);
        return node === "" + expected ? expected : node;
      }
    }
    function setValueForAttribute(node, name, value) {
      if (isAttributeNameSafe(name))
        if (value === null)
          node.removeAttribute(name);
        else {
          switch (typeof value) {
            case "undefined":
            case "function":
            case "symbol":
              node.removeAttribute(name);
              return;
            case "boolean":
              var prefix2 = name.toLowerCase().slice(0, 5);
              if (prefix2 !== "data-" && prefix2 !== "aria-") {
                node.removeAttribute(name);
                return;
              }
          }
          checkAttributeStringCoercion(value, name);
          node.setAttribute(name, "" + value);
        }
    }
    function setValueForKnownAttribute(node, name, value) {
      if (value === null)
        node.removeAttribute(name);
      else {
        switch (typeof value) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            node.removeAttribute(name);
            return;
        }
        checkAttributeStringCoercion(value, name);
        node.setAttribute(name, "" + value);
      }
    }
    function setValueForNamespacedAttribute(node, namespace, name, value) {
      if (value === null)
        node.removeAttribute(name);
      else {
        switch (typeof value) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            node.removeAttribute(name);
            return;
        }
        checkAttributeStringCoercion(value, name);
        node.setAttributeNS(namespace, name, "" + value);
      }
    }
    function getToStringValue(value) {
      switch (typeof value) {
        case "bigint":
        case "boolean":
        case "number":
        case "string":
        case "undefined":
          return value;
        case "object":
          return checkFormFieldValueStringCoercion(value), value;
        default:
          return "";
      }
    }
    function isCheckable(elem) {
      var type = elem.type;
      return (elem = elem.nodeName) && elem.toLowerCase() === "input" && (type === "checkbox" || type === "radio");
    }
    function trackValueOnNode(node, valueField, currentValue) {
      var descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField);
      if (!node.hasOwnProperty(valueField) && typeof descriptor !== "undefined" && typeof descriptor.get === "function" && typeof descriptor.set === "function") {
        var { get, set } = descriptor;
        Object.defineProperty(node, valueField, {
          configurable: true,
          get: function() {
            return get.call(this);
          },
          set: function(value) {
            checkFormFieldValueStringCoercion(value);
            currentValue = "" + value;
            set.call(this, value);
          }
        });
        Object.defineProperty(node, valueField, {
          enumerable: descriptor.enumerable
        });
        return {
          getValue: function() {
            return currentValue;
          },
          setValue: function(value) {
            checkFormFieldValueStringCoercion(value);
            currentValue = "" + value;
          },
          stopTracking: function() {
            node._valueTracker = null;
            delete node[valueField];
          }
        };
      }
    }
    function track(node) {
      if (!node._valueTracker) {
        var valueField = isCheckable(node) ? "checked" : "value";
        node._valueTracker = trackValueOnNode(node, valueField, "" + node[valueField]);
      }
    }
    function updateValueIfChanged(node) {
      if (!node)
        return false;
      var tracker = node._valueTracker;
      if (!tracker)
        return true;
      var lastValue = tracker.getValue();
      var value = "";
      node && (value = isCheckable(node) ? node.checked ? "true" : "false" : node.value);
      node = value;
      return node !== lastValue ? (tracker.setValue(node), true) : false;
    }
    function getActiveElement(doc) {
      doc = doc || (typeof document !== "undefined" ? document : undefined);
      if (typeof doc === "undefined")
        return null;
      try {
        return doc.activeElement || doc.body;
      } catch (e7) {
        return doc.body;
      }
    }
    function escapeSelectorAttributeValueInsideDoubleQuotes(value) {
      return value.replace(escapeSelectorAttributeValueInsideDoubleQuotesRegex, function(ch) {
        return "\\" + ch.charCodeAt(0).toString(16) + " ";
      });
    }
    function validateInputProps(element, props) {
      props.checked === undefined || props.defaultChecked === undefined || didWarnCheckedDefaultChecked || (console.error("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component", props.type), didWarnCheckedDefaultChecked = true);
      props.value === undefined || props.defaultValue === undefined || didWarnValueDefaultValue$1 || (console.error("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component", props.type), didWarnValueDefaultValue$1 = true);
    }
    function updateInput(element, value, defaultValue, lastDefaultValue, checked, defaultChecked, type, name) {
      element.name = "";
      type != null && typeof type !== "function" && typeof type !== "symbol" && typeof type !== "boolean" ? (checkAttributeStringCoercion(type, "type"), element.type = type) : element.removeAttribute("type");
      if (value != null)
        if (type === "number") {
          if (value === 0 && element.value === "" || element.value != value)
            element.value = "" + getToStringValue(value);
        } else
          element.value !== "" + getToStringValue(value) && (element.value = "" + getToStringValue(value));
      else
        type !== "submit" && type !== "reset" || element.removeAttribute("value");
      value != null ? setDefaultValue(element, type, getToStringValue(value)) : defaultValue != null ? setDefaultValue(element, type, getToStringValue(defaultValue)) : lastDefaultValue != null && element.removeAttribute("value");
      checked == null && defaultChecked != null && (element.defaultChecked = !!defaultChecked);
      checked != null && (element.checked = checked && typeof checked !== "function" && typeof checked !== "symbol");
      name != null && typeof name !== "function" && typeof name !== "symbol" && typeof name !== "boolean" ? (checkAttributeStringCoercion(name, "name"), element.name = "" + getToStringValue(name)) : element.removeAttribute("name");
    }
    function initInput(element, value, defaultValue, checked, defaultChecked, type, name, isHydrating2) {
      type != null && typeof type !== "function" && typeof type !== "symbol" && typeof type !== "boolean" && (checkAttributeStringCoercion(type, "type"), element.type = type);
      if (value != null || defaultValue != null) {
        if (!(type !== "submit" && type !== "reset" || value !== undefined && value !== null)) {
          track(element);
          return;
        }
        defaultValue = defaultValue != null ? "" + getToStringValue(defaultValue) : "";
        value = value != null ? "" + getToStringValue(value) : defaultValue;
        isHydrating2 || value === element.value || (element.value = value);
        element.defaultValue = value;
      }
      checked = checked != null ? checked : defaultChecked;
      checked = typeof checked !== "function" && typeof checked !== "symbol" && !!checked;
      element.checked = isHydrating2 ? element.checked : !!checked;
      element.defaultChecked = !!checked;
      name != null && typeof name !== "function" && typeof name !== "symbol" && typeof name !== "boolean" && (checkAttributeStringCoercion(name, "name"), element.name = name);
      track(element);
    }
    function setDefaultValue(node, type, value) {
      type === "number" && getActiveElement(node.ownerDocument) === node || node.defaultValue === "" + value || (node.defaultValue = "" + value);
    }
    function validateOptionProps(element, props) {
      props.value == null && (typeof props.children === "object" && props.children !== null ? React6.Children.forEach(props.children, function(child) {
        child == null || typeof child === "string" || typeof child === "number" || typeof child === "bigint" || didWarnInvalidChild || (didWarnInvalidChild = true, console.error("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>."));
      }) : props.dangerouslySetInnerHTML == null || didWarnInvalidInnerHTML || (didWarnInvalidInnerHTML = true, console.error("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.")));
      props.selected == null || didWarnSelectedSetOnOption || (console.error("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."), didWarnSelectedSetOnOption = true);
    }
    function getDeclarationErrorAddendum() {
      var ownerName = getCurrentFiberOwnerNameInDevOrNull();
      return ownerName ? `

Check the render method of \`` + ownerName + "`." : "";
    }
    function updateOptions(node, multiple, propValue, setDefaultSelected) {
      node = node.options;
      if (multiple) {
        multiple = {};
        for (var i = 0;i < propValue.length; i++)
          multiple["$" + propValue[i]] = true;
        for (propValue = 0;propValue < node.length; propValue++)
          i = multiple.hasOwnProperty("$" + node[propValue].value), node[propValue].selected !== i && (node[propValue].selected = i), i && setDefaultSelected && (node[propValue].defaultSelected = true);
      } else {
        propValue = "" + getToStringValue(propValue);
        multiple = null;
        for (i = 0;i < node.length; i++) {
          if (node[i].value === propValue) {
            node[i].selected = true;
            setDefaultSelected && (node[i].defaultSelected = true);
            return;
          }
          multiple !== null || node[i].disabled || (multiple = node[i]);
        }
        multiple !== null && (multiple.selected = true);
      }
    }
    function validateSelectProps(element, props) {
      for (element = 0;element < valuePropNames.length; element++) {
        var propName = valuePropNames[element];
        if (props[propName] != null) {
          var propNameIsArray = isArrayImpl(props[propName]);
          props.multiple && !propNameIsArray ? console.error("The `%s` prop supplied to <select> must be an array if `multiple` is true.%s", propName, getDeclarationErrorAddendum()) : !props.multiple && propNameIsArray && console.error("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s", propName, getDeclarationErrorAddendum());
        }
      }
      props.value === undefined || props.defaultValue === undefined || didWarnValueDefaultValue || (console.error("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://react.dev/link/controlled-components"), didWarnValueDefaultValue = true);
    }
    function validateTextareaProps(element, props) {
      props.value === undefined || props.defaultValue === undefined || didWarnValDefaultVal || (console.error("%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://react.dev/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component"), didWarnValDefaultVal = true);
      props.children != null && props.value == null && console.error("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
    }
    function updateTextarea(element, value, defaultValue) {
      if (value != null && (value = "" + getToStringValue(value), value !== element.value && (element.value = value), defaultValue == null)) {
        element.defaultValue !== value && (element.defaultValue = value);
        return;
      }
      element.defaultValue = defaultValue != null ? "" + getToStringValue(defaultValue) : "";
    }
    function initTextarea(element, value, defaultValue, children) {
      if (value == null) {
        if (children != null) {
          if (defaultValue != null)
            throw Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
          if (isArrayImpl(children)) {
            if (1 < children.length)
              throw Error("<textarea> can only have at most one child.");
            children = children[0];
          }
          defaultValue = children;
        }
        defaultValue == null && (defaultValue = "");
        value = defaultValue;
      }
      defaultValue = getToStringValue(value);
      element.defaultValue = defaultValue;
      children = element.textContent;
      children === defaultValue && children !== "" && children !== null && (element.value = children);
      track(element);
    }
    function findNotableNode(node, indent) {
      return node.serverProps === undefined && node.serverTail.length === 0 && node.children.length === 1 && 3 < node.distanceFromLeaf && node.distanceFromLeaf > 15 - indent ? findNotableNode(node.children[0], indent) : node;
    }
    function indentation(indent) {
      return "  " + "  ".repeat(indent);
    }
    function added(indent) {
      return "+ " + "  ".repeat(indent);
    }
    function removed(indent) {
      return "- " + "  ".repeat(indent);
    }
    function describeFiberType(fiber) {
      switch (fiber.tag) {
        case 26:
        case 27:
        case 5:
          return fiber.type;
        case 16:
          return "Lazy";
        case 31:
          return "Activity";
        case 13:
          return "Suspense";
        case 19:
          return "SuspenseList";
        case 0:
        case 15:
          return fiber = fiber.type, fiber.displayName || fiber.name || null;
        case 11:
          return fiber = fiber.type.render, fiber.displayName || fiber.name || null;
        case 1:
          return fiber = fiber.type, fiber.displayName || fiber.name || null;
        default:
          return null;
      }
    }
    function describeTextNode(content, maxLength) {
      return needsEscaping.test(content) ? (content = JSON.stringify(content), content.length > maxLength - 2 ? 8 > maxLength ? '{"..."}' : "{" + content.slice(0, maxLength - 7) + '..."}' : "{" + content + "}") : content.length > maxLength ? 5 > maxLength ? '{"..."}' : content.slice(0, maxLength - 3) + "..." : content;
    }
    function describeTextDiff(clientText, serverProps, indent) {
      var maxLength = 120 - 2 * indent;
      if (serverProps === null)
        return added(indent) + describeTextNode(clientText, maxLength) + `
`;
      if (typeof serverProps === "string") {
        for (var firstDiff = 0;firstDiff < serverProps.length && firstDiff < clientText.length && serverProps.charCodeAt(firstDiff) === clientText.charCodeAt(firstDiff); firstDiff++)
          ;
        firstDiff > maxLength - 8 && 10 < firstDiff && (clientText = "..." + clientText.slice(firstDiff - 8), serverProps = "..." + serverProps.slice(firstDiff - 8));
        return added(indent) + describeTextNode(clientText, maxLength) + `
` + removed(indent) + describeTextNode(serverProps, maxLength) + `
`;
      }
      return indentation(indent) + describeTextNode(clientText, maxLength) + `
`;
    }
    function objectName(object) {
      return Object.prototype.toString.call(object).replace(/^\[object (.*)\]$/, function(m, p0) {
        return p0;
      });
    }
    function describeValue(value, maxLength) {
      switch (typeof value) {
        case "string":
          return value = JSON.stringify(value), value.length > maxLength ? 5 > maxLength ? '"..."' : value.slice(0, maxLength - 4) + '..."' : value;
        case "object":
          if (value === null)
            return "null";
          if (isArrayImpl(value))
            return "[...]";
          if (value.$$typeof === REACT_ELEMENT_TYPE)
            return (maxLength = getComponentNameFromType(value.type)) ? "<" + maxLength + ">" : "<...>";
          var name = objectName(value);
          if (name === "Object") {
            name = "";
            maxLength -= 2;
            for (var propName in value)
              if (value.hasOwnProperty(propName)) {
                var jsonPropName = JSON.stringify(propName);
                jsonPropName !== '"' + propName + '"' && (propName = jsonPropName);
                maxLength -= propName.length - 2;
                jsonPropName = describeValue(value[propName], 15 > maxLength ? maxLength : 15);
                maxLength -= jsonPropName.length;
                if (0 > maxLength) {
                  name += name === "" ? "..." : ", ...";
                  break;
                }
                name += (name === "" ? "" : ",") + propName + ":" + jsonPropName;
              }
            return "{" + name + "}";
          }
          return name;
        case "function":
          return (maxLength = value.displayName || value.name) ? "function " + maxLength : "function";
        default:
          return String(value);
      }
    }
    function describePropValue(value, maxLength) {
      return typeof value !== "string" || needsEscaping.test(value) ? "{" + describeValue(value, maxLength - 2) + "}" : value.length > maxLength - 2 ? 5 > maxLength ? '"..."' : '"' + value.slice(0, maxLength - 5) + '..."' : '"' + value + '"';
    }
    function describeExpandedElement(type, props, rowPrefix) {
      var remainingRowLength = 120 - rowPrefix.length - type.length, properties = [], propName;
      for (propName in props)
        if (props.hasOwnProperty(propName) && propName !== "children") {
          var propValue = describePropValue(props[propName], 120 - rowPrefix.length - propName.length - 1);
          remainingRowLength -= propName.length + propValue.length + 2;
          properties.push(propName + "=" + propValue);
        }
      return properties.length === 0 ? rowPrefix + "<" + type + `>
` : 0 < remainingRowLength ? rowPrefix + "<" + type + " " + properties.join(" ") + `>
` : rowPrefix + "<" + type + `
` + rowPrefix + "  " + properties.join(`
` + rowPrefix + "  ") + `
` + rowPrefix + `>
`;
    }
    function describePropertiesDiff(clientObject, serverObject, indent) {
      var properties = "", remainingServerProperties = assign({}, serverObject), propName;
      for (propName in clientObject)
        if (clientObject.hasOwnProperty(propName)) {
          delete remainingServerProperties[propName];
          var maxLength = 120 - 2 * indent - propName.length - 2, clientPropValue = describeValue(clientObject[propName], maxLength);
          serverObject.hasOwnProperty(propName) ? (maxLength = describeValue(serverObject[propName], maxLength), properties += added(indent) + propName + ": " + clientPropValue + `
`, properties += removed(indent) + propName + ": " + maxLength + `
`) : properties += added(indent) + propName + ": " + clientPropValue + `
`;
        }
      for (var _propName in remainingServerProperties)
        remainingServerProperties.hasOwnProperty(_propName) && (clientObject = describeValue(remainingServerProperties[_propName], 120 - 2 * indent - _propName.length - 2), properties += removed(indent) + _propName + ": " + clientObject + `
`);
      return properties;
    }
    function describeElementDiff(type, clientProps, serverProps, indent) {
      var content = "", serverPropNames = new Map;
      for (propName$jscomp$0 in serverProps)
        serverProps.hasOwnProperty(propName$jscomp$0) && serverPropNames.set(propName$jscomp$0.toLowerCase(), propName$jscomp$0);
      if (serverPropNames.size === 1 && serverPropNames.has("children"))
        content += describeExpandedElement(type, clientProps, indentation(indent));
      else {
        for (var _propName2 in clientProps)
          if (clientProps.hasOwnProperty(_propName2) && _propName2 !== "children") {
            var maxLength$jscomp$0 = 120 - 2 * (indent + 1) - _propName2.length - 1, serverPropName = serverPropNames.get(_propName2.toLowerCase());
            if (serverPropName !== undefined) {
              serverPropNames.delete(_propName2.toLowerCase());
              var propName$jscomp$0 = clientProps[_propName2];
              serverPropName = serverProps[serverPropName];
              var clientPropValue = describePropValue(propName$jscomp$0, maxLength$jscomp$0);
              maxLength$jscomp$0 = describePropValue(serverPropName, maxLength$jscomp$0);
              typeof propName$jscomp$0 === "object" && propName$jscomp$0 !== null && typeof serverPropName === "object" && serverPropName !== null && objectName(propName$jscomp$0) === "Object" && objectName(serverPropName) === "Object" && (2 < Object.keys(propName$jscomp$0).length || 2 < Object.keys(serverPropName).length || -1 < clientPropValue.indexOf("...") || -1 < maxLength$jscomp$0.indexOf("...")) ? content += indentation(indent + 1) + _propName2 + `={{
` + describePropertiesDiff(propName$jscomp$0, serverPropName, indent + 2) + indentation(indent + 1) + `}}
` : (content += added(indent + 1) + _propName2 + "=" + clientPropValue + `
`, content += removed(indent + 1) + _propName2 + "=" + maxLength$jscomp$0 + `
`);
            } else
              content += indentation(indent + 1) + _propName2 + "=" + describePropValue(clientProps[_propName2], maxLength$jscomp$0) + `
`;
          }
        serverPropNames.forEach(function(propName) {
          if (propName !== "children") {
            var maxLength = 120 - 2 * (indent + 1) - propName.length - 1;
            content += removed(indent + 1) + propName + "=" + describePropValue(serverProps[propName], maxLength) + `
`;
          }
        });
        content = content === "" ? indentation(indent) + "<" + type + `>
` : indentation(indent) + "<" + type + `
` + content + indentation(indent) + `>
`;
      }
      type = serverProps.children;
      clientProps = clientProps.children;
      if (typeof type === "string" || typeof type === "number" || typeof type === "bigint") {
        serverPropNames = "";
        if (typeof clientProps === "string" || typeof clientProps === "number" || typeof clientProps === "bigint")
          serverPropNames = "" + clientProps;
        content += describeTextDiff(serverPropNames, "" + type, indent + 1);
      } else if (typeof clientProps === "string" || typeof clientProps === "number" || typeof clientProps === "bigint")
        content = type == null ? content + describeTextDiff("" + clientProps, null, indent + 1) : content + describeTextDiff("" + clientProps, undefined, indent + 1);
      return content;
    }
    function describeSiblingFiber(fiber, indent) {
      var type = describeFiberType(fiber);
      if (type === null) {
        type = "";
        for (fiber = fiber.child;fiber; )
          type += describeSiblingFiber(fiber, indent), fiber = fiber.sibling;
        return type;
      }
      return indentation(indent) + "<" + type + `>
`;
    }
    function describeNode(node, indent) {
      var skipToNode = findNotableNode(node, indent);
      if (skipToNode !== node && (node.children.length !== 1 || node.children[0] !== skipToNode))
        return indentation(indent) + `...
` + describeNode(skipToNode, indent + 1);
      skipToNode = "";
      var debugInfo = node.fiber._debugInfo;
      if (debugInfo)
        for (var i = 0;i < debugInfo.length; i++) {
          var serverComponentName = debugInfo[i].name;
          typeof serverComponentName === "string" && (skipToNode += indentation(indent) + "<" + serverComponentName + `>
`, indent++);
        }
      debugInfo = "";
      i = node.fiber.pendingProps;
      if (node.fiber.tag === 6)
        debugInfo = describeTextDiff(i, node.serverProps, indent), indent++;
      else if (serverComponentName = describeFiberType(node.fiber), serverComponentName !== null)
        if (node.serverProps === undefined) {
          debugInfo = indent;
          var maxLength = 120 - 2 * debugInfo - serverComponentName.length - 2, content = "";
          for (propName in i)
            if (i.hasOwnProperty(propName) && propName !== "children") {
              var propValue = describePropValue(i[propName], 15);
              maxLength -= propName.length + propValue.length + 2;
              if (0 > maxLength) {
                content += " ...";
                break;
              }
              content += " " + propName + "=" + propValue;
            }
          debugInfo = indentation(debugInfo) + "<" + serverComponentName + content + `>
`;
          indent++;
        } else
          node.serverProps === null ? (debugInfo = describeExpandedElement(serverComponentName, i, added(indent)), indent++) : typeof node.serverProps === "string" ? console.error("Should not have matched a non HostText fiber to a Text node. This is a bug in React.") : (debugInfo = describeElementDiff(serverComponentName, i, node.serverProps, indent), indent++);
      var propName = "";
      i = node.fiber.child;
      for (serverComponentName = 0;i && serverComponentName < node.children.length; )
        maxLength = node.children[serverComponentName], maxLength.fiber === i ? (propName += describeNode(maxLength, indent), serverComponentName++) : propName += describeSiblingFiber(i, indent), i = i.sibling;
      i && 0 < node.children.length && (propName += indentation(indent) + `...
`);
      i = node.serverTail;
      node.serverProps === null && indent--;
      for (node = 0;node < i.length; node++)
        serverComponentName = i[node], propName = typeof serverComponentName === "string" ? propName + (removed(indent) + describeTextNode(serverComponentName, 120 - 2 * indent) + `
`) : propName + describeExpandedElement(serverComponentName.type, serverComponentName.props, removed(indent));
      return skipToNode + debugInfo + propName;
    }
    function describeDiff(rootNode) {
      try {
        return `

` + describeNode(rootNode, 0);
      } catch (x) {
        return "";
      }
    }
    function describeAncestors(ancestor, child, props) {
      for (var fiber = child, node = null, distanceFromLeaf = 0;fiber; )
        fiber === ancestor && (distanceFromLeaf = 0), node = {
          fiber,
          children: node !== null ? [node] : [],
          serverProps: fiber === child ? props : fiber === ancestor ? null : undefined,
          serverTail: [],
          distanceFromLeaf
        }, distanceFromLeaf++, fiber = fiber.return;
      return node !== null ? describeDiff(node).replaceAll(/^[+-]/gm, ">") : "";
    }
    function updatedAncestorInfoDev(oldInfo, tag) {
      var ancestorInfo = assign({}, oldInfo || emptyAncestorInfoDev), info = { tag };
      inScopeTags.indexOf(tag) !== -1 && (ancestorInfo.aTagInScope = null, ancestorInfo.buttonTagInScope = null, ancestorInfo.nobrTagInScope = null);
      buttonScopeTags.indexOf(tag) !== -1 && (ancestorInfo.pTagInButtonScope = null);
      specialTags.indexOf(tag) !== -1 && tag !== "address" && tag !== "div" && tag !== "p" && (ancestorInfo.listItemTagAutoclosing = null, ancestorInfo.dlItemTagAutoclosing = null);
      ancestorInfo.current = info;
      tag === "form" && (ancestorInfo.formTag = info);
      tag === "a" && (ancestorInfo.aTagInScope = info);
      tag === "button" && (ancestorInfo.buttonTagInScope = info);
      tag === "nobr" && (ancestorInfo.nobrTagInScope = info);
      tag === "p" && (ancestorInfo.pTagInButtonScope = info);
      tag === "li" && (ancestorInfo.listItemTagAutoclosing = info);
      if (tag === "dd" || tag === "dt")
        ancestorInfo.dlItemTagAutoclosing = info;
      tag === "#document" || tag === "html" ? ancestorInfo.containerTagInScope = null : ancestorInfo.containerTagInScope || (ancestorInfo.containerTagInScope = info);
      oldInfo !== null || tag !== "#document" && tag !== "html" && tag !== "body" ? ancestorInfo.implicitRootScope === true && (ancestorInfo.implicitRootScope = false) : ancestorInfo.implicitRootScope = true;
      return ancestorInfo;
    }
    function isTagValidWithParent(tag, parentTag, implicitRootScope) {
      switch (parentTag) {
        case "select":
          return tag === "hr" || tag === "option" || tag === "optgroup" || tag === "script" || tag === "template" || tag === "#text";
        case "optgroup":
          return tag === "option" || tag === "#text";
        case "option":
          return tag === "#text";
        case "tr":
          return tag === "th" || tag === "td" || tag === "style" || tag === "script" || tag === "template";
        case "tbody":
        case "thead":
        case "tfoot":
          return tag === "tr" || tag === "style" || tag === "script" || tag === "template";
        case "colgroup":
          return tag === "col" || tag === "template";
        case "table":
          return tag === "caption" || tag === "colgroup" || tag === "tbody" || tag === "tfoot" || tag === "thead" || tag === "style" || tag === "script" || tag === "template";
        case "head":
          return tag === "base" || tag === "basefont" || tag === "bgsound" || tag === "link" || tag === "meta" || tag === "title" || tag === "noscript" || tag === "noframes" || tag === "style" || tag === "script" || tag === "template";
        case "html":
          if (implicitRootScope)
            break;
          return tag === "head" || tag === "body" || tag === "frameset";
        case "frameset":
          return tag === "frame";
        case "#document":
          if (!implicitRootScope)
            return tag === "html";
      }
      switch (tag) {
        case "h1":
        case "h2":
        case "h3":
        case "h4":
        case "h5":
        case "h6":
          return parentTag !== "h1" && parentTag !== "h2" && parentTag !== "h3" && parentTag !== "h4" && parentTag !== "h5" && parentTag !== "h6";
        case "rp":
        case "rt":
          return impliedEndTags.indexOf(parentTag) === -1;
        case "caption":
        case "col":
        case "colgroup":
        case "frameset":
        case "frame":
        case "tbody":
        case "td":
        case "tfoot":
        case "th":
        case "thead":
        case "tr":
          return parentTag == null;
        case "head":
          return implicitRootScope || parentTag === null;
        case "html":
          return implicitRootScope && parentTag === "#document" || parentTag === null;
        case "body":
          return implicitRootScope && (parentTag === "#document" || parentTag === "html") || parentTag === null;
      }
      return true;
    }
    function findInvalidAncestorForTag(tag, ancestorInfo) {
      switch (tag) {
        case "address":
        case "article":
        case "aside":
        case "blockquote":
        case "center":
        case "details":
        case "dialog":
        case "dir":
        case "div":
        case "dl":
        case "fieldset":
        case "figcaption":
        case "figure":
        case "footer":
        case "header":
        case "hgroup":
        case "main":
        case "menu":
        case "nav":
        case "ol":
        case "p":
        case "section":
        case "summary":
        case "ul":
        case "pre":
        case "listing":
        case "table":
        case "hr":
        case "xmp":
        case "h1":
        case "h2":
        case "h3":
        case "h4":
        case "h5":
        case "h6":
          return ancestorInfo.pTagInButtonScope;
        case "form":
          return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;
        case "li":
          return ancestorInfo.listItemTagAutoclosing;
        case "dd":
        case "dt":
          return ancestorInfo.dlItemTagAutoclosing;
        case "button":
          return ancestorInfo.buttonTagInScope;
        case "a":
          return ancestorInfo.aTagInScope;
        case "nobr":
          return ancestorInfo.nobrTagInScope;
      }
      return null;
    }
    function findAncestor(parent, tagName) {
      for (;parent; ) {
        switch (parent.tag) {
          case 5:
          case 26:
          case 27:
            if (parent.type === tagName)
              return parent;
        }
        parent = parent.return;
      }
      return null;
    }
    function validateDOMNesting(childTag, ancestorInfo) {
      ancestorInfo = ancestorInfo || emptyAncestorInfoDev;
      var parentInfo = ancestorInfo.current;
      ancestorInfo = (parentInfo = isTagValidWithParent(childTag, parentInfo && parentInfo.tag, ancestorInfo.implicitRootScope) ? null : parentInfo) ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
      ancestorInfo = parentInfo || ancestorInfo;
      if (!ancestorInfo)
        return true;
      var ancestorTag = ancestorInfo.tag;
      ancestorInfo = String(!!parentInfo) + "|" + childTag + "|" + ancestorTag;
      if (didWarn[ancestorInfo])
        return false;
      didWarn[ancestorInfo] = true;
      var ancestor = (ancestorInfo = current) ? findAncestor(ancestorInfo.return, ancestorTag) : null, ancestorDescription = ancestorInfo !== null && ancestor !== null ? describeAncestors(ancestor, ancestorInfo, null) : "", tagDisplayName = "<" + childTag + ">";
      parentInfo ? (parentInfo = "", ancestorTag === "table" && childTag === "tr" && (parentInfo += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser."), console.error(`In HTML, %s cannot be a child of <%s>.%s
This will cause a hydration error.%s`, tagDisplayName, ancestorTag, parentInfo, ancestorDescription)) : console.error(`In HTML, %s cannot be a descendant of <%s>.
This will cause a hydration error.%s`, tagDisplayName, ancestorTag, ancestorDescription);
      ancestorInfo && (childTag = ancestorInfo.return, ancestor === null || childTag === null || ancestor === childTag && childTag._debugOwner === ancestorInfo._debugOwner || runWithFiberInDEV(ancestor, function() {
        console.error(`<%s> cannot contain a nested %s.
See this log for the ancestor stack trace.`, ancestorTag, tagDisplayName);
      }));
      return false;
    }
    function validateTextNesting(childText, parentTag, implicitRootScope) {
      if (implicitRootScope || isTagValidWithParent("#text", parentTag, false))
        return true;
      implicitRootScope = "#text|" + parentTag;
      if (didWarn[implicitRootScope])
        return false;
      didWarn[implicitRootScope] = true;
      var ancestor = (implicitRootScope = current) ? findAncestor(implicitRootScope, parentTag) : null;
      implicitRootScope = implicitRootScope !== null && ancestor !== null ? describeAncestors(ancestor, implicitRootScope, implicitRootScope.tag !== 6 ? { children: null } : null) : "";
      /\S/.test(childText) ? console.error(`In HTML, text nodes cannot be a child of <%s>.
This will cause a hydration error.%s`, parentTag, implicitRootScope) : console.error(`In HTML, whitespace text nodes cannot be a child of <%s>. Make sure you don't have any extra whitespace between tags on each line of your source code.
This will cause a hydration error.%s`, parentTag, implicitRootScope);
      return false;
    }
    function setTextContent(node, text) {
      if (text) {
        var firstChild = node.firstChild;
        if (firstChild && firstChild === node.lastChild && firstChild.nodeType === 3) {
          firstChild.nodeValue = text;
          return;
        }
      }
      node.textContent = text;
    }
    function camelize(string) {
      return string.replace(hyphenPattern, function(_, character) {
        return character.toUpperCase();
      });
    }
    function setValueForStyle(style2, styleName, value) {
      var isCustomProperty = styleName.indexOf("--") === 0;
      isCustomProperty || (-1 < styleName.indexOf("-") ? warnedStyleNames.hasOwnProperty(styleName) && warnedStyleNames[styleName] || (warnedStyleNames[styleName] = true, console.error("Unsupported style property %s. Did you mean %s?", styleName, camelize(styleName.replace(msPattern, "ms-")))) : badVendoredStyleNamePattern.test(styleName) ? warnedStyleNames.hasOwnProperty(styleName) && warnedStyleNames[styleName] || (warnedStyleNames[styleName] = true, console.error("Unsupported vendor-prefixed style property %s. Did you mean %s?", styleName, styleName.charAt(0).toUpperCase() + styleName.slice(1))) : !badStyleValueWithSemicolonPattern.test(value) || warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value] || (warnedStyleValues[value] = true, console.error(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, styleName, value.replace(badStyleValueWithSemicolonPattern, ""))), typeof value === "number" && (isNaN(value) ? warnedForNaNValue || (warnedForNaNValue = true, console.error("`NaN` is an invalid value for the `%s` css style property.", styleName)) : isFinite(value) || warnedForInfinityValue || (warnedForInfinityValue = true, console.error("`Infinity` is an invalid value for the `%s` css style property.", styleName))));
      value == null || typeof value === "boolean" || value === "" ? isCustomProperty ? style2.setProperty(styleName, "") : styleName === "float" ? style2.cssFloat = "" : style2[styleName] = "" : isCustomProperty ? style2.setProperty(styleName, value) : typeof value !== "number" || value === 0 || unitlessNumbers.has(styleName) ? styleName === "float" ? style2.cssFloat = value : (checkCSSPropertyStringCoercion(value, styleName), style2[styleName] = ("" + value).trim()) : style2[styleName] = value + "px";
    }
    function setValueForStyles(node, styles3, prevStyles) {
      if (styles3 != null && typeof styles3 !== "object")
        throw Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
      styles3 && Object.freeze(styles3);
      node = node.style;
      if (prevStyles != null) {
        if (styles3) {
          var expandedUpdates = {};
          if (prevStyles) {
            for (var key in prevStyles)
              if (prevStyles.hasOwnProperty(key) && !styles3.hasOwnProperty(key))
                for (var longhands = shorthandToLonghand[key] || [key], i = 0;i < longhands.length; i++)
                  expandedUpdates[longhands[i]] = key;
          }
          for (var _key in styles3)
            if (styles3.hasOwnProperty(_key) && (!prevStyles || prevStyles[_key] !== styles3[_key]))
              for (key = shorthandToLonghand[_key] || [_key], longhands = 0;longhands < key.length; longhands++)
                expandedUpdates[key[longhands]] = _key;
          _key = {};
          for (var key$jscomp$0 in styles3)
            for (key = shorthandToLonghand[key$jscomp$0] || [key$jscomp$0], longhands = 0;longhands < key.length; longhands++)
              _key[key[longhands]] = key$jscomp$0;
          key$jscomp$0 = {};
          for (var _key2 in expandedUpdates)
            if (key = expandedUpdates[_key2], (longhands = _key[_key2]) && key !== longhands && (i = key + "," + longhands, !key$jscomp$0[i])) {
              key$jscomp$0[i] = true;
              i = console;
              var value = styles3[key];
              i.error.call(i, "%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.", value == null || typeof value === "boolean" || value === "" ? "Removing" : "Updating", key, longhands);
            }
        }
        for (var styleName in prevStyles)
          !prevStyles.hasOwnProperty(styleName) || styles3 != null && styles3.hasOwnProperty(styleName) || (styleName.indexOf("--") === 0 ? node.setProperty(styleName, "") : styleName === "float" ? node.cssFloat = "" : node[styleName] = "");
        for (var _styleName in styles3)
          _key2 = styles3[_styleName], styles3.hasOwnProperty(_styleName) && prevStyles[_styleName] !== _key2 && setValueForStyle(node, _styleName, _key2);
      } else
        for (expandedUpdates in styles3)
          styles3.hasOwnProperty(expandedUpdates) && setValueForStyle(node, expandedUpdates, styles3[expandedUpdates]);
    }
    function isCustomElement(tagName) {
      if (tagName.indexOf("-") === -1)
        return false;
      switch (tagName) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return false;
        default:
          return true;
      }
    }
    function getAttributeAlias(name) {
      return aliases.get(name) || name;
    }
    function validateProperty$1(tagName, name) {
      if (hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name])
        return true;
      if (rARIACamel$1.test(name)) {
        tagName = "aria-" + name.slice(4).toLowerCase();
        tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;
        if (tagName == null)
          return console.error("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", name), warnedProperties$1[name] = true;
        if (name !== tagName)
          return console.error("Invalid ARIA attribute `%s`. Did you mean `%s`?", name, tagName), warnedProperties$1[name] = true;
      }
      if (rARIA$1.test(name)) {
        tagName = name.toLowerCase();
        tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;
        if (tagName == null)
          return warnedProperties$1[name] = true, false;
        name !== tagName && (console.error("Unknown ARIA attribute `%s`. Did you mean `%s`?", name, tagName), warnedProperties$1[name] = true);
      }
      return true;
    }
    function validateProperties$2(type, props) {
      var invalidProps = [], key;
      for (key in props)
        validateProperty$1(type, key) || invalidProps.push(key);
      props = invalidProps.map(function(prop) {
        return "`" + prop + "`";
      }).join(", ");
      invalidProps.length === 1 ? console.error("Invalid aria prop %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props", props, type) : 1 < invalidProps.length && console.error("Invalid aria props %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props", props, type);
    }
    function validateProperty(tagName, name, value, eventRegistry) {
      if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name])
        return true;
      var lowerCasedName = name.toLowerCase();
      if (lowerCasedName === "onfocusin" || lowerCasedName === "onfocusout")
        return console.error("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."), warnedProperties[name] = true;
      if (typeof value === "function" && (tagName === "form" && name === "action" || tagName === "input" && name === "formAction" || tagName === "button" && name === "formAction"))
        return true;
      if (eventRegistry != null) {
        tagName = eventRegistry.possibleRegistrationNames;
        if (eventRegistry.registrationNameDependencies.hasOwnProperty(name))
          return true;
        eventRegistry = tagName.hasOwnProperty(lowerCasedName) ? tagName[lowerCasedName] : null;
        if (eventRegistry != null)
          return console.error("Invalid event handler property `%s`. Did you mean `%s`?", name, eventRegistry), warnedProperties[name] = true;
        if (EVENT_NAME_REGEX.test(name))
          return console.error("Unknown event handler property `%s`. It will be ignored.", name), warnedProperties[name] = true;
      } else if (EVENT_NAME_REGEX.test(name))
        return INVALID_EVENT_NAME_REGEX.test(name) && console.error("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", name), warnedProperties[name] = true;
      if (rARIA.test(name) || rARIACamel.test(name))
        return true;
      if (lowerCasedName === "innerhtml")
        return console.error("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."), warnedProperties[name] = true;
      if (lowerCasedName === "aria")
        return console.error("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."), warnedProperties[name] = true;
      if (lowerCasedName === "is" && value !== null && value !== undefined && typeof value !== "string")
        return console.error("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof value), warnedProperties[name] = true;
      if (typeof value === "number" && isNaN(value))
        return console.error("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", name), warnedProperties[name] = true;
      if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
        if (lowerCasedName = possibleStandardNames[lowerCasedName], lowerCasedName !== name)
          return console.error("Invalid DOM property `%s`. Did you mean `%s`?", name, lowerCasedName), warnedProperties[name] = true;
      } else if (name !== lowerCasedName)
        return console.error("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", name, lowerCasedName), warnedProperties[name] = true;
      switch (name) {
        case "dangerouslySetInnerHTML":
        case "children":
        case "style":
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "ref":
          return true;
        case "innerText":
        case "textContent":
          return true;
      }
      switch (typeof value) {
        case "boolean":
          switch (name) {
            case "autoFocus":
            case "checked":
            case "multiple":
            case "muted":
            case "selected":
            case "contentEditable":
            case "spellCheck":
            case "draggable":
            case "value":
            case "autoReverse":
            case "externalResourcesRequired":
            case "focusable":
            case "preserveAlpha":
            case "allowFullScreen":
            case "async":
            case "autoPlay":
            case "controls":
            case "default":
            case "defer":
            case "disabled":
            case "disablePictureInPicture":
            case "disableRemotePlayback":
            case "formNoValidate":
            case "hidden":
            case "loop":
            case "noModule":
            case "noValidate":
            case "open":
            case "playsInline":
            case "readOnly":
            case "required":
            case "reversed":
            case "scoped":
            case "seamless":
            case "itemScope":
            case "capture":
            case "download":
            case "inert":
              return true;
            default:
              lowerCasedName = name.toLowerCase().slice(0, 5);
              if (lowerCasedName === "data-" || lowerCasedName === "aria-")
                return true;
              value ? console.error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', value, name, name, value, name) : console.error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', value, name, name, value, name, name, name);
              return warnedProperties[name] = true;
          }
        case "function":
        case "symbol":
          return warnedProperties[name] = true, false;
        case "string":
          if (value === "false" || value === "true") {
            switch (name) {
              case "checked":
              case "selected":
              case "multiple":
              case "muted":
              case "allowFullScreen":
              case "async":
              case "autoPlay":
              case "controls":
              case "default":
              case "defer":
              case "disabled":
              case "disablePictureInPicture":
              case "disableRemotePlayback":
              case "formNoValidate":
              case "hidden":
              case "loop":
              case "noModule":
              case "noValidate":
              case "open":
              case "playsInline":
              case "readOnly":
              case "required":
              case "reversed":
              case "scoped":
              case "seamless":
              case "itemScope":
              case "inert":
                break;
              default:
                return true;
            }
            console.error("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", value, name, value === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', name, value);
            warnedProperties[name] = true;
          }
      }
      return true;
    }
    function warnUnknownProperties(type, props, eventRegistry) {
      var unknownProps = [], key;
      for (key in props)
        validateProperty(type, key, props[key], eventRegistry) || unknownProps.push(key);
      props = unknownProps.map(function(prop) {
        return "`" + prop + "`";
      }).join(", ");
      unknownProps.length === 1 ? console.error("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://react.dev/link/attribute-behavior ", props, type) : 1 < unknownProps.length && console.error("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://react.dev/link/attribute-behavior ", props, type);
    }
    function sanitizeURL(url) {
      return isJavaScriptProtocol.test("" + url) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : url;
    }
    function noop$1() {}
    function getEventTarget(nativeEvent) {
      nativeEvent = nativeEvent.target || nativeEvent.srcElement || window;
      nativeEvent.correspondingUseElement && (nativeEvent = nativeEvent.correspondingUseElement);
      return nativeEvent.nodeType === 3 ? nativeEvent.parentNode : nativeEvent;
    }
    function restoreStateOfTarget(target) {
      var internalInstance = getInstanceFromNode(target);
      if (internalInstance && (target = internalInstance.stateNode)) {
        var props = target[internalPropsKey] || null;
        a:
          switch (target = internalInstance.stateNode, internalInstance.type) {
            case "input":
              updateInput(target, props.value, props.defaultValue, props.defaultValue, props.checked, props.defaultChecked, props.type, props.name);
              internalInstance = props.name;
              if (props.type === "radio" && internalInstance != null) {
                for (props = target;props.parentNode; )
                  props = props.parentNode;
                checkAttributeStringCoercion(internalInstance, "name");
                props = props.querySelectorAll('input[name="' + escapeSelectorAttributeValueInsideDoubleQuotes("" + internalInstance) + '"][type="radio"]');
                for (internalInstance = 0;internalInstance < props.length; internalInstance++) {
                  var otherNode = props[internalInstance];
                  if (otherNode !== target && otherNode.form === target.form) {
                    var otherProps = otherNode[internalPropsKey] || null;
                    if (!otherProps)
                      throw Error("ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.");
                    updateInput(otherNode, otherProps.value, otherProps.defaultValue, otherProps.defaultValue, otherProps.checked, otherProps.defaultChecked, otherProps.type, otherProps.name);
                  }
                }
                for (internalInstance = 0;internalInstance < props.length; internalInstance++)
                  otherNode = props[internalInstance], otherNode.form === target.form && updateValueIfChanged(otherNode);
              }
              break a;
            case "textarea":
              updateTextarea(target, props.value, props.defaultValue);
              break a;
            case "select":
              internalInstance = props.value, internalInstance != null && updateOptions(target, !!props.multiple, internalInstance, false);
          }
      }
    }
    function batchedUpdates$1(fn, a, b) {
      if (isInsideEventHandler)
        return fn(a, b);
      isInsideEventHandler = true;
      try {
        var JSCompiler_inline_result = fn(a);
        return JSCompiler_inline_result;
      } finally {
        if (isInsideEventHandler = false, restoreTarget !== null || restoreQueue !== null) {
          if (flushSyncWork$1(), restoreTarget && (a = restoreTarget, fn = restoreQueue, restoreQueue = restoreTarget = null, restoreStateOfTarget(a), fn))
            for (a = 0;a < fn.length; a++)
              restoreStateOfTarget(fn[a]);
        }
      }
    }
    function getListener(inst, registrationName) {
      var stateNode = inst.stateNode;
      if (stateNode === null)
        return null;
      var props = stateNode[internalPropsKey] || null;
      if (props === null)
        return null;
      stateNode = props[registrationName];
      a:
        switch (registrationName) {
          case "onClick":
          case "onClickCapture":
          case "onDoubleClick":
          case "onDoubleClickCapture":
          case "onMouseDown":
          case "onMouseDownCapture":
          case "onMouseMove":
          case "onMouseMoveCapture":
          case "onMouseUp":
          case "onMouseUpCapture":
          case "onMouseEnter":
            (props = !props.disabled) || (inst = inst.type, props = !(inst === "button" || inst === "input" || inst === "select" || inst === "textarea"));
            inst = !props;
            break a;
          default:
            inst = false;
        }
      if (inst)
        return null;
      if (stateNode && typeof stateNode !== "function")
        throw Error("Expected `" + registrationName + "` listener to be a function, instead got a value of `" + typeof stateNode + "` type.");
      return stateNode;
    }
    function getData() {
      if (fallbackText)
        return fallbackText;
      var start, startValue = startText, startLength = startValue.length, end, endValue = "value" in root ? root.value : root.textContent, endLength = endValue.length;
      for (start = 0;start < startLength && startValue[start] === endValue[start]; start++)
        ;
      var minEnd = startLength - start;
      for (end = 1;end <= minEnd && startValue[startLength - end] === endValue[endLength - end]; end++)
        ;
      return fallbackText = endValue.slice(start, 1 < end ? 1 - end : undefined);
    }
    function getEventCharCode(nativeEvent) {
      var keyCode = nativeEvent.keyCode;
      "charCode" in nativeEvent ? (nativeEvent = nativeEvent.charCode, nativeEvent === 0 && keyCode === 13 && (nativeEvent = 13)) : nativeEvent = keyCode;
      nativeEvent === 10 && (nativeEvent = 13);
      return 32 <= nativeEvent || nativeEvent === 13 ? nativeEvent : 0;
    }
    function functionThatReturnsTrue() {
      return true;
    }
    function functionThatReturnsFalse() {
      return false;
    }
    function createSyntheticEvent(Interface) {
      function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
        this._reactName = reactName;
        this._targetInst = targetInst;
        this.type = reactEventType;
        this.nativeEvent = nativeEvent;
        this.target = nativeEventTarget;
        this.currentTarget = null;
        for (var propName in Interface)
          Interface.hasOwnProperty(propName) && (reactName = Interface[propName], this[propName] = reactName ? reactName(nativeEvent) : nativeEvent[propName]);
        this.isDefaultPrevented = (nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false) ? functionThatReturnsTrue : functionThatReturnsFalse;
        this.isPropagationStopped = functionThatReturnsFalse;
        return this;
      }
      assign(SyntheticBaseEvent.prototype, {
        preventDefault: function() {
          this.defaultPrevented = true;
          var event = this.nativeEvent;
          event && (event.preventDefault ? event.preventDefault() : typeof event.returnValue !== "unknown" && (event.returnValue = false), this.isDefaultPrevented = functionThatReturnsTrue);
        },
        stopPropagation: function() {
          var event = this.nativeEvent;
          event && (event.stopPropagation ? event.stopPropagation() : typeof event.cancelBubble !== "unknown" && (event.cancelBubble = true), this.isPropagationStopped = functionThatReturnsTrue);
        },
        persist: function() {},
        isPersistent: functionThatReturnsTrue
      });
      return SyntheticBaseEvent;
    }
    function modifierStateGetter(keyArg) {
      var nativeEvent = this.nativeEvent;
      return nativeEvent.getModifierState ? nativeEvent.getModifierState(keyArg) : (keyArg = modifierKeyToProp[keyArg]) ? !!nativeEvent[keyArg] : false;
    }
    function getEventModifierState() {
      return modifierStateGetter;
    }
    function isFallbackCompositionEnd(domEventName, nativeEvent) {
      switch (domEventName) {
        case "keyup":
          return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
        case "keydown":
          return nativeEvent.keyCode !== START_KEYCODE;
        case "keypress":
        case "mousedown":
        case "focusout":
          return true;
        default:
          return false;
      }
    }
    function getDataFromCustomEvent(nativeEvent) {
      nativeEvent = nativeEvent.detail;
      return typeof nativeEvent === "object" && "data" in nativeEvent ? nativeEvent.data : null;
    }
    function getNativeBeforeInputChars(domEventName, nativeEvent) {
      switch (domEventName) {
        case "compositionend":
          return getDataFromCustomEvent(nativeEvent);
        case "keypress":
          if (nativeEvent.which !== SPACEBAR_CODE)
            return null;
          hasSpaceKeypress = true;
          return SPACEBAR_CHAR;
        case "textInput":
          return domEventName = nativeEvent.data, domEventName === SPACEBAR_CHAR && hasSpaceKeypress ? null : domEventName;
        default:
          return null;
      }
    }
    function getFallbackBeforeInputChars(domEventName, nativeEvent) {
      if (isComposing)
        return domEventName === "compositionend" || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent) ? (domEventName = getData(), fallbackText = startText = root = null, isComposing = false, domEventName) : null;
      switch (domEventName) {
        case "paste":
          return null;
        case "keypress":
          if (!(nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) || nativeEvent.ctrlKey && nativeEvent.altKey) {
            if (nativeEvent.char && 1 < nativeEvent.char.length)
              return nativeEvent.char;
            if (nativeEvent.which)
              return String.fromCharCode(nativeEvent.which);
          }
          return null;
        case "compositionend":
          return useFallbackCompositionData && nativeEvent.locale !== "ko" ? null : nativeEvent.data;
        default:
          return null;
      }
    }
    function isTextInputElement(elem) {
      var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
      return nodeName === "input" ? !!supportedInputTypes[elem.type] : nodeName === "textarea" ? true : false;
    }
    function isEventSupported(eventNameSuffix) {
      if (!canUseDOM)
        return false;
      eventNameSuffix = "on" + eventNameSuffix;
      var isSupported = eventNameSuffix in document;
      isSupported || (isSupported = document.createElement("div"), isSupported.setAttribute(eventNameSuffix, "return;"), isSupported = typeof isSupported[eventNameSuffix] === "function");
      return isSupported;
    }
    function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {
      restoreTarget ? restoreQueue ? restoreQueue.push(target) : restoreQueue = [target] : restoreTarget = target;
      inst = accumulateTwoPhaseListeners(inst, "onChange");
      0 < inst.length && (nativeEvent = new SyntheticEvent("onChange", "change", null, nativeEvent, target), dispatchQueue.push({ event: nativeEvent, listeners: inst }));
    }
    function runEventInBatch(dispatchQueue) {
      processDispatchQueue(dispatchQueue, 0);
    }
    function getInstIfValueChanged(targetInst) {
      var targetNode = getNodeFromInstance(targetInst);
      if (updateValueIfChanged(targetNode))
        return targetInst;
    }
    function getTargetInstForChangeEvent(domEventName, targetInst) {
      if (domEventName === "change")
        return targetInst;
    }
    function stopWatchingForValueChange() {
      activeElement$1 && (activeElement$1.detachEvent("onpropertychange", handlePropertyChange), activeElementInst$1 = activeElement$1 = null);
    }
    function handlePropertyChange(nativeEvent) {
      if (nativeEvent.propertyName === "value" && getInstIfValueChanged(activeElementInst$1)) {
        var dispatchQueue = [];
        createAndAccumulateChangeEvent(dispatchQueue, activeElementInst$1, nativeEvent, getEventTarget(nativeEvent));
        batchedUpdates$1(runEventInBatch, dispatchQueue);
      }
    }
    function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
      domEventName === "focusin" ? (stopWatchingForValueChange(), activeElement$1 = target, activeElementInst$1 = targetInst, activeElement$1.attachEvent("onpropertychange", handlePropertyChange)) : domEventName === "focusout" && stopWatchingForValueChange();
    }
    function getTargetInstForInputEventPolyfill(domEventName) {
      if (domEventName === "selectionchange" || domEventName === "keyup" || domEventName === "keydown")
        return getInstIfValueChanged(activeElementInst$1);
    }
    function getTargetInstForClickEvent(domEventName, targetInst) {
      if (domEventName === "click")
        return getInstIfValueChanged(targetInst);
    }
    function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
      if (domEventName === "input" || domEventName === "change")
        return getInstIfValueChanged(targetInst);
    }
    function is(x, y) {
      return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
    }
    function shallowEqual(objA, objB) {
      if (objectIs(objA, objB))
        return true;
      if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null)
        return false;
      var keysA = Object.keys(objA), keysB = Object.keys(objB);
      if (keysA.length !== keysB.length)
        return false;
      for (keysB = 0;keysB < keysA.length; keysB++) {
        var currentKey = keysA[keysB];
        if (!hasOwnProperty.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey]))
          return false;
      }
      return true;
    }
    function getLeafNode(node) {
      for (;node && node.firstChild; )
        node = node.firstChild;
      return node;
    }
    function getNodeForCharacterOffset(root2, offset) {
      var node = getLeafNode(root2);
      root2 = 0;
      for (var nodeEnd;node; ) {
        if (node.nodeType === 3) {
          nodeEnd = root2 + node.textContent.length;
          if (root2 <= offset && nodeEnd >= offset)
            return { node, offset: offset - root2 };
          root2 = nodeEnd;
        }
        a: {
          for (;node; ) {
            if (node.nextSibling) {
              node = node.nextSibling;
              break a;
            }
            node = node.parentNode;
          }
          node = undefined;
        }
        node = getLeafNode(node);
      }
    }
    function containsNode(outerNode, innerNode) {
      return outerNode && innerNode ? outerNode === innerNode ? true : outerNode && outerNode.nodeType === 3 ? false : innerNode && innerNode.nodeType === 3 ? containsNode(outerNode, innerNode.parentNode) : ("contains" in outerNode) ? outerNode.contains(innerNode) : outerNode.compareDocumentPosition ? !!(outerNode.compareDocumentPosition(innerNode) & 16) : false : false;
    }
    function getActiveElementDeep(containerInfo) {
      containerInfo = containerInfo != null && containerInfo.ownerDocument != null && containerInfo.ownerDocument.defaultView != null ? containerInfo.ownerDocument.defaultView : window;
      for (var element = getActiveElement(containerInfo.document);element instanceof containerInfo.HTMLIFrameElement; ) {
        try {
          var JSCompiler_inline_result = typeof element.contentWindow.location.href === "string";
        } catch (err) {
          JSCompiler_inline_result = false;
        }
        if (JSCompiler_inline_result)
          containerInfo = element.contentWindow;
        else
          break;
        element = getActiveElement(containerInfo.document);
      }
      return element;
    }
    function hasSelectionCapabilities(elem) {
      var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
      return nodeName && (nodeName === "input" && (elem.type === "text" || elem.type === "search" || elem.type === "tel" || elem.type === "url" || elem.type === "password") || nodeName === "textarea" || elem.contentEditable === "true");
    }
    function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
      var doc = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget.document : nativeEventTarget.nodeType === 9 ? nativeEventTarget : nativeEventTarget.ownerDocument;
      mouseDown || activeElement == null || activeElement !== getActiveElement(doc) || (doc = activeElement, ("selectionStart" in doc) && hasSelectionCapabilities(doc) ? doc = { start: doc.selectionStart, end: doc.selectionEnd } : (doc = (doc.ownerDocument && doc.ownerDocument.defaultView || window).getSelection(), doc = {
        anchorNode: doc.anchorNode,
        anchorOffset: doc.anchorOffset,
        focusNode: doc.focusNode,
        focusOffset: doc.focusOffset
      }), lastSelection && shallowEqual(lastSelection, doc) || (lastSelection = doc, doc = accumulateTwoPhaseListeners(activeElementInst, "onSelect"), 0 < doc.length && (nativeEvent = new SyntheticEvent("onSelect", "select", null, nativeEvent, nativeEventTarget), dispatchQueue.push({ event: nativeEvent, listeners: doc }), nativeEvent.target = activeElement)));
    }
    function makePrefixMap(styleProp, eventName) {
      var prefixes = {};
      prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
      prefixes["Webkit" + styleProp] = "webkit" + eventName;
      prefixes["Moz" + styleProp] = "moz" + eventName;
      return prefixes;
    }
    function getVendorPrefixedEventName(eventName) {
      if (prefixedEventNames[eventName])
        return prefixedEventNames[eventName];
      if (!vendorPrefixes[eventName])
        return eventName;
      var prefixMap = vendorPrefixes[eventName], styleProp;
      for (styleProp in prefixMap)
        if (prefixMap.hasOwnProperty(styleProp) && styleProp in style)
          return prefixedEventNames[eventName] = prefixMap[styleProp];
      return eventName;
    }
    function registerSimpleEvent(domEventName, reactName) {
      topLevelEventsToReactNames.set(domEventName, reactName);
      registerTwoPhaseEvent(reactName, [domEventName]);
    }
    function getArrayKind(array) {
      for (var kind = EMPTY_ARRAY, i = 0;i < array.length; i++) {
        var value = array[i];
        if (typeof value === "object" && value !== null)
          if (isArrayImpl(value) && value.length === 2 && typeof value[0] === "string") {
            if (kind !== EMPTY_ARRAY && kind !== ENTRIES_ARRAY)
              return COMPLEX_ARRAY;
            kind = ENTRIES_ARRAY;
          } else
            return COMPLEX_ARRAY;
        else {
          if (typeof value === "function" || typeof value === "string" && 50 < value.length || kind !== EMPTY_ARRAY && kind !== PRIMITIVE_ARRAY)
            return COMPLEX_ARRAY;
          kind = PRIMITIVE_ARRAY;
        }
      }
      return kind;
    }
    function addObjectToProperties(object, properties, indent, prefix2) {
      for (var key in object)
        hasOwnProperty.call(object, key) && key[0] !== "_" && addValueToProperties(key, object[key], properties, indent, prefix2);
    }
    function addValueToProperties(propertyName, value, properties, indent, prefix2) {
      switch (typeof value) {
        case "object":
          if (value === null) {
            value = "null";
            break;
          } else {
            if (value.$$typeof === REACT_ELEMENT_TYPE) {
              var typeName2 = getComponentNameFromType(value.type) || "", key = value.key;
              value = value.props;
              var propsKeys = Object.keys(value), propsLength = propsKeys.length;
              if (key == null && propsLength === 0) {
                value = "<" + typeName2 + " />";
                break;
              }
              if (3 > indent || propsLength === 1 && propsKeys[0] === "children" && key == null) {
                value = "<" + typeName2 + "  />";
                break;
              }
              properties.push([
                prefix2 + "".repeat(indent) + propertyName,
                "<" + typeName2
              ]);
              key !== null && addValueToProperties("key", key, properties, indent + 1, prefix2);
              propertyName = false;
              for (var propKey in value)
                propKey === "children" ? value.children != null && (!isArrayImpl(value.children) || 0 < value.children.length) && (propertyName = true) : hasOwnProperty.call(value, propKey) && propKey[0] !== "_" && addValueToProperties(propKey, value[propKey], properties, indent + 1, prefix2);
              properties.push([
                "",
                propertyName ? "></" + typeName2 + ">" : "/>"
              ]);
              return;
            }
            typeName2 = Object.prototype.toString.call(value);
            typeName2 = typeName2.slice(8, typeName2.length - 1);
            if (typeName2 === "Array") {
              if (propKey = getArrayKind(value), propKey === PRIMITIVE_ARRAY || propKey === EMPTY_ARRAY) {
                value = JSON.stringify(value);
                break;
              } else if (propKey === ENTRIES_ARRAY) {
                properties.push([
                  prefix2 + "".repeat(indent) + propertyName,
                  ""
                ]);
                for (propertyName = 0;propertyName < value.length; propertyName++)
                  typeName2 = value[propertyName], addValueToProperties(typeName2[0], typeName2[1], properties, indent + 1, prefix2);
                return;
              }
            }
            if (typeName2 === "Promise") {
              if (value.status === "fulfilled") {
                if (typeName2 = properties.length, addValueToProperties(propertyName, value.value, properties, indent, prefix2), properties.length > typeName2) {
                  properties = properties[typeName2];
                  properties[1] = "Promise<" + (properties[1] || "Object") + ">";
                  return;
                }
              } else if (value.status === "rejected" && (typeName2 = properties.length, addValueToProperties(propertyName, value.reason, properties, indent, prefix2), properties.length > typeName2)) {
                properties = properties[typeName2];
                properties[1] = "Rejected Promise<" + properties[1] + ">";
                return;
              }
              properties.push([
                "".repeat(indent) + propertyName,
                "Promise"
              ]);
              return;
            }
            typeName2 === "Object" && (propKey = Object.getPrototypeOf(value)) && typeof propKey.constructor === "function" && (typeName2 = propKey.constructor.name);
            properties.push([
              prefix2 + "".repeat(indent) + propertyName,
              typeName2 === "Object" ? 3 > indent ? "" : "" : typeName2
            ]);
            3 > indent && addObjectToProperties(value, properties, indent + 1, prefix2);
            return;
          }
        case "function":
          value = value.name === "" ? "() => {}" : value.name + "() {}";
          break;
        case "string":
          value = value === OMITTED_PROP_ERROR ? "" : JSON.stringify(value);
          break;
        case "undefined":
          value = "undefined";
          break;
        case "boolean":
          value = value ? "true" : "false";
          break;
        default:
          value = String(value);
      }
      properties.push([
        prefix2 + "".repeat(indent) + propertyName,
        value
      ]);
    }
    function addObjectDiffToProperties(prev, next, properties, indent) {
      var isDeeplyEqual = true;
      for (key in prev)
        key in next || (properties.push([
          REMOVED + "".repeat(indent) + key,
          ""
        ]), isDeeplyEqual = false);
      for (var _key in next)
        if (_key in prev) {
          var key = prev[_key];
          var nextValue = next[_key];
          if (key !== nextValue) {
            if (indent === 0 && _key === "children")
              isDeeplyEqual = "".repeat(indent) + _key, properties.push([REMOVED + isDeeplyEqual, ""], [ADDED + isDeeplyEqual, ""]);
            else {
              if (!(3 <= indent)) {
                if (typeof key === "object" && typeof nextValue === "object" && key !== null && nextValue !== null && key.$$typeof === nextValue.$$typeof)
                  if (nextValue.$$typeof === REACT_ELEMENT_TYPE) {
                    if (key.type === nextValue.type && key.key === nextValue.key) {
                      key = getComponentNameFromType(nextValue.type) || "";
                      isDeeplyEqual = "".repeat(indent) + _key;
                      key = "<" + key + "  />";
                      properties.push([REMOVED + isDeeplyEqual, key], [ADDED + isDeeplyEqual, key]);
                      isDeeplyEqual = false;
                      continue;
                    }
                  } else {
                    var prevKind = Object.prototype.toString.call(key), nextKind = Object.prototype.toString.call(nextValue);
                    if (prevKind === nextKind && (nextKind === "[object Object]" || nextKind === "[object Array]")) {
                      prevKind = [
                        UNCHANGED + "".repeat(indent) + _key,
                        nextKind === "[object Array]" ? "Array" : ""
                      ];
                      properties.push(prevKind);
                      nextKind = properties.length;
                      addObjectDiffToProperties(key, nextValue, properties, indent + 1) ? nextKind === properties.length && (prevKind[1] = "Referentially unequal but deeply equal objects. Consider memoization.") : isDeeplyEqual = false;
                      continue;
                    }
                  }
                else if (typeof key === "function" && typeof nextValue === "function" && key.name === nextValue.name && key.length === nextValue.length && (prevKind = Function.prototype.toString.call(key), nextKind = Function.prototype.toString.call(nextValue), prevKind === nextKind)) {
                  key = nextValue.name === "" ? "() => {}" : nextValue.name + "() {}";
                  properties.push([
                    UNCHANGED + "".repeat(indent) + _key,
                    key + " Referentially unequal function closure. Consider memoization."
                  ]);
                  continue;
                }
              }
              addValueToProperties(_key, key, properties, indent, REMOVED);
              addValueToProperties(_key, nextValue, properties, indent, ADDED);
            }
            isDeeplyEqual = false;
          }
        } else
          properties.push([
            ADDED + "".repeat(indent) + _key,
            ""
          ]), isDeeplyEqual = false;
      return isDeeplyEqual;
    }
    function setCurrentTrackFromLanes(lanes) {
      currentTrack = lanes & 63 ? "Blocking" : lanes & 64 ? "Gesture" : lanes & 4194176 ? "Transition" : lanes & 62914560 ? "Suspense" : lanes & 2080374784 ? "Idle" : "Other";
    }
    function logComponentTrigger(fiber, startTime, endTime, trigger) {
      supportsUserTiming && (reusableComponentOptions.start = startTime, reusableComponentOptions.end = endTime, reusableComponentDevToolDetails.color = "warning", reusableComponentDevToolDetails.tooltipText = trigger, reusableComponentDevToolDetails.properties = null, (fiber = fiber._debugTask) ? fiber.run(performance.measure.bind(performance, trigger, reusableComponentOptions)) : performance.measure(trigger, reusableComponentOptions));
    }
    function logComponentReappeared(fiber, startTime, endTime) {
      logComponentTrigger(fiber, startTime, endTime, "Reconnect");
    }
    function logComponentRender(fiber, startTime, endTime, wasHydrated, committedLanes) {
      var name = getComponentNameFromFiber(fiber);
      if (name !== null && supportsUserTiming) {
        var { alternate, actualDuration: selfTime } = fiber;
        if (alternate === null || alternate.child !== fiber.child)
          for (var child = fiber.child;child !== null; child = child.sibling)
            selfTime -= child.actualDuration;
        wasHydrated = 0.5 > selfTime ? wasHydrated ? "tertiary-light" : "primary-light" : 10 > selfTime ? wasHydrated ? "tertiary" : "primary" : 100 > selfTime ? wasHydrated ? "tertiary-dark" : "primary-dark" : "error";
        var props = fiber.memoizedProps;
        selfTime = fiber._debugTask;
        props !== null && alternate !== null && alternate.memoizedProps !== props ? (child = [resuableChangedPropsEntry], props = addObjectDiffToProperties(alternate.memoizedProps, props, child, 0), 1 < child.length && (props && !alreadyWarnedForDeepEquality && (alternate.lanes & committedLanes) === 0 && 100 < fiber.actualDuration ? (alreadyWarnedForDeepEquality = true, child[0] = reusableDeeplyEqualPropsEntry, reusableComponentDevToolDetails.color = "warning", reusableComponentDevToolDetails.tooltipText = DEEP_EQUALITY_WARNING) : (reusableComponentDevToolDetails.color = wasHydrated, reusableComponentDevToolDetails.tooltipText = name), reusableComponentDevToolDetails.properties = child, reusableComponentOptions.start = startTime, reusableComponentOptions.end = endTime, selfTime != null ? selfTime.run(performance.measure.bind(performance, "" + name, reusableComponentOptions)) : performance.measure("" + name, reusableComponentOptions))) : selfTime != null ? selfTime.run(console.timeStamp.bind(console, name, startTime, endTime, COMPONENTS_TRACK, undefined, wasHydrated)) : console.timeStamp(name, startTime, endTime, COMPONENTS_TRACK, undefined, wasHydrated);
      }
    }
    function logComponentErrored(fiber, startTime, endTime, errors2) {
      if (supportsUserTiming) {
        var name = getComponentNameFromFiber(fiber);
        if (name !== null) {
          for (var debugTask = null, properties = [], i = 0;i < errors2.length; i++) {
            var capturedValue = errors2[i];
            debugTask == null && capturedValue.source !== null && (debugTask = capturedValue.source._debugTask);
            capturedValue = capturedValue.value;
            properties.push([
              "Error",
              typeof capturedValue === "object" && capturedValue !== null && typeof capturedValue.message === "string" ? String(capturedValue.message) : String(capturedValue)
            ]);
          }
          fiber.key !== null && addValueToProperties("key", fiber.key, properties, 0, "");
          fiber.memoizedProps !== null && addObjectToProperties(fiber.memoizedProps, properties, 0, "");
          debugTask == null && (debugTask = fiber._debugTask);
          fiber = {
            start: startTime,
            end: endTime,
            detail: {
              devtools: {
                color: "error",
                track: COMPONENTS_TRACK,
                tooltipText: fiber.tag === 13 ? "Hydration failed" : "Error boundary caught an error",
                properties
              }
            }
          };
          debugTask ? debugTask.run(performance.measure.bind(performance, "" + name, fiber)) : performance.measure("" + name, fiber);
        }
      }
    }
    function logComponentEffect(fiber, startTime, endTime, selfTime, errors2) {
      if (errors2 !== null) {
        if (supportsUserTiming) {
          var name = getComponentNameFromFiber(fiber);
          if (name !== null) {
            selfTime = [];
            for (var i = 0;i < errors2.length; i++) {
              var error = errors2[i].value;
              selfTime.push([
                "Error",
                typeof error === "object" && error !== null && typeof error.message === "string" ? String(error.message) : String(error)
              ]);
            }
            fiber.key !== null && addValueToProperties("key", fiber.key, selfTime, 0, "");
            fiber.memoizedProps !== null && addObjectToProperties(fiber.memoizedProps, selfTime, 0, "");
            startTime = {
              start: startTime,
              end: endTime,
              detail: {
                devtools: {
                  color: "error",
                  track: COMPONENTS_TRACK,
                  tooltipText: "A lifecycle or effect errored",
                  properties: selfTime
                }
              }
            };
            (fiber = fiber._debugTask) ? fiber.run(performance.measure.bind(performance, "" + name, startTime)) : performance.measure("" + name, startTime);
          }
        }
      } else
        name = getComponentNameFromFiber(fiber), name !== null && supportsUserTiming && (errors2 = 1 > selfTime ? "secondary-light" : 100 > selfTime ? "secondary" : 500 > selfTime ? "secondary-dark" : "error", (fiber = fiber._debugTask) ? fiber.run(console.timeStamp.bind(console, name, startTime, endTime, COMPONENTS_TRACK, undefined, errors2)) : console.timeStamp(name, startTime, endTime, COMPONENTS_TRACK, undefined, errors2));
    }
    function logRenderPhase(startTime, endTime, lanes, debugTask) {
      if (supportsUserTiming && !(endTime <= startTime)) {
        var color = (lanes & 738197653) === lanes ? "tertiary-dark" : "primary-dark";
        lanes = (lanes & 536870912) === lanes ? "Prepared" : (lanes & 201326741) === lanes ? "Hydrated" : "Render";
        debugTask ? debugTask.run(console.timeStamp.bind(console, lanes, startTime, endTime, currentTrack, LANES_TRACK_GROUP, color)) : console.timeStamp(lanes, startTime, endTime, currentTrack, LANES_TRACK_GROUP, color);
      }
    }
    function logSuspendedRenderPhase(startTime, endTime, lanes, debugTask) {
      !supportsUserTiming || endTime <= startTime || (lanes = (lanes & 738197653) === lanes ? "tertiary-dark" : "primary-dark", debugTask ? debugTask.run(console.timeStamp.bind(console, "Prewarm", startTime, endTime, currentTrack, LANES_TRACK_GROUP, lanes)) : console.timeStamp("Prewarm", startTime, endTime, currentTrack, LANES_TRACK_GROUP, lanes));
    }
    function logSuspendedWithDelayPhase(startTime, endTime, lanes, debugTask) {
      !supportsUserTiming || endTime <= startTime || (lanes = (lanes & 738197653) === lanes ? "tertiary-dark" : "primary-dark", debugTask ? debugTask.run(console.timeStamp.bind(console, "Suspended", startTime, endTime, currentTrack, LANES_TRACK_GROUP, lanes)) : console.timeStamp("Suspended", startTime, endTime, currentTrack, LANES_TRACK_GROUP, lanes));
    }
    function logRecoveredRenderPhase(startTime, endTime, lanes, recoverableErrors, hydrationFailed, debugTask) {
      if (supportsUserTiming && !(endTime <= startTime)) {
        lanes = [];
        for (var i = 0;i < recoverableErrors.length; i++) {
          var error = recoverableErrors[i].value;
          lanes.push([
            "Recoverable Error",
            typeof error === "object" && error !== null && typeof error.message === "string" ? String(error.message) : String(error)
          ]);
        }
        startTime = {
          start: startTime,
          end: endTime,
          detail: {
            devtools: {
              color: "primary-dark",
              track: currentTrack,
              trackGroup: LANES_TRACK_GROUP,
              tooltipText: hydrationFailed ? "Hydration Failed" : "Recovered after Error",
              properties: lanes
            }
          }
        };
        debugTask ? debugTask.run(performance.measure.bind(performance, "Recovered", startTime)) : performance.measure("Recovered", startTime);
      }
    }
    function logErroredRenderPhase(startTime, endTime, lanes, debugTask) {
      !supportsUserTiming || endTime <= startTime || (debugTask ? debugTask.run(console.timeStamp.bind(console, "Errored", startTime, endTime, currentTrack, LANES_TRACK_GROUP, "error")) : console.timeStamp("Errored", startTime, endTime, currentTrack, LANES_TRACK_GROUP, "error"));
    }
    function logSuspendedCommitPhase(startTime, endTime, reason, debugTask) {
      !supportsUserTiming || endTime <= startTime || (debugTask ? debugTask.run(console.timeStamp.bind(console, reason, startTime, endTime, currentTrack, LANES_TRACK_GROUP, "secondary-light")) : console.timeStamp(reason, startTime, endTime, currentTrack, LANES_TRACK_GROUP, "secondary-light"));
    }
    function logCommitErrored(startTime, endTime, errors2, passive, debugTask) {
      if (supportsUserTiming && !(endTime <= startTime)) {
        for (var properties = [], i = 0;i < errors2.length; i++) {
          var error = errors2[i].value;
          properties.push([
            "Error",
            typeof error === "object" && error !== null && typeof error.message === "string" ? String(error.message) : String(error)
          ]);
        }
        startTime = {
          start: startTime,
          end: endTime,
          detail: {
            devtools: {
              color: "error",
              track: currentTrack,
              trackGroup: LANES_TRACK_GROUP,
              tooltipText: passive ? "Remaining Effects Errored" : "Commit Errored",
              properties
            }
          }
        };
        debugTask ? debugTask.run(performance.measure.bind(performance, "Errored", startTime)) : performance.measure("Errored", startTime);
      }
    }
    function logAnimatingPhase(startTime, endTime, debugTask) {
      !supportsUserTiming || endTime <= startTime || (debugTask ? debugTask.run(console.timeStamp.bind(console, "Animating", startTime, endTime, currentTrack, LANES_TRACK_GROUP, "secondary-dark")) : console.timeStamp("Animating", startTime, endTime, currentTrack, LANES_TRACK_GROUP, "secondary-dark"));
    }
    function finishQueueingConcurrentUpdates() {
      for (var endIndex = concurrentQueuesIndex, i = concurrentlyUpdatedLanes = concurrentQueuesIndex = 0;i < endIndex; ) {
        var fiber = concurrentQueues[i];
        concurrentQueues[i++] = null;
        var queue = concurrentQueues[i];
        concurrentQueues[i++] = null;
        var update = concurrentQueues[i];
        concurrentQueues[i++] = null;
        var lane = concurrentQueues[i];
        concurrentQueues[i++] = null;
        if (queue !== null && update !== null) {
          var pending = queue.pending;
          pending === null ? update.next = update : (update.next = pending.next, pending.next = update);
          queue.pending = update;
        }
        lane !== 0 && markUpdateLaneFromFiberToRoot(fiber, update, lane);
      }
    }
    function enqueueUpdate$1(fiber, queue, update, lane) {
      concurrentQueues[concurrentQueuesIndex++] = fiber;
      concurrentQueues[concurrentQueuesIndex++] = queue;
      concurrentQueues[concurrentQueuesIndex++] = update;
      concurrentQueues[concurrentQueuesIndex++] = lane;
      concurrentlyUpdatedLanes |= lane;
      fiber.lanes |= lane;
      fiber = fiber.alternate;
      fiber !== null && (fiber.lanes |= lane);
    }
    function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
      enqueueUpdate$1(fiber, queue, update, lane);
      return getRootForUpdatedFiber(fiber);
    }
    function enqueueConcurrentRenderForLane(fiber, lane) {
      enqueueUpdate$1(fiber, null, null, lane);
      return getRootForUpdatedFiber(fiber);
    }
    function markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {
      sourceFiber.lanes |= lane;
      var alternate = sourceFiber.alternate;
      alternate !== null && (alternate.lanes |= lane);
      for (var isHidden = false, parent = sourceFiber.return;parent !== null; )
        parent.childLanes |= lane, alternate = parent.alternate, alternate !== null && (alternate.childLanes |= lane), parent.tag === 22 && (sourceFiber = parent.stateNode, sourceFiber === null || sourceFiber._visibility & OffscreenVisible || (isHidden = true)), sourceFiber = parent, parent = parent.return;
      return sourceFiber.tag === 3 ? (parent = sourceFiber.stateNode, isHidden && update !== null && (isHidden = 31 - clz32(lane), sourceFiber = parent.hiddenUpdates, alternate = sourceFiber[isHidden], alternate === null ? sourceFiber[isHidden] = [update] : alternate.push(update), update.lane = lane | 536870912), parent) : null;
    }
    function getRootForUpdatedFiber(sourceFiber) {
      if (nestedUpdateCount > NESTED_UPDATE_LIMIT)
        throw nestedPassiveUpdateCount = nestedUpdateCount = 0, rootWithPassiveNestedUpdates = rootWithNestedUpdates = null, Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
      nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT && (nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null, console.error("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."));
      sourceFiber.alternate === null && (sourceFiber.flags & 4098) !== 0 && warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
      for (var node = sourceFiber, parent = node.return;parent !== null; )
        node.alternate === null && (node.flags & 4098) !== 0 && warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber), node = parent, parent = node.return;
      return node.tag === 3 ? node.stateNode : null;
    }
    function resolveFunctionForHotReloading(type) {
      if (resolveFamily === null)
        return type;
      var family = resolveFamily(type);
      return family === undefined ? type : family.current;
    }
    function resolveForwardRefForHotReloading(type) {
      if (resolveFamily === null)
        return type;
      var family = resolveFamily(type);
      return family === undefined ? type !== null && type !== undefined && typeof type.render === "function" && (family = resolveFunctionForHotReloading(type.render), type.render !== family) ? (family = { $$typeof: REACT_FORWARD_REF_TYPE, render: family }, type.displayName !== undefined && (family.displayName = type.displayName), family) : type : family.current;
    }
    function isCompatibleFamilyForHotReloading(fiber, element) {
      if (resolveFamily === null)
        return false;
      var prevType = fiber.elementType;
      element = element.type;
      var needsCompareFamilies = false, $$typeofNextType = typeof element === "object" && element !== null ? element.$$typeof : null;
      switch (fiber.tag) {
        case 1:
          typeof element === "function" && (needsCompareFamilies = true);
          break;
        case 0:
          typeof element === "function" ? needsCompareFamilies = true : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = true);
          break;
        case 11:
          $$typeofNextType === REACT_FORWARD_REF_TYPE ? needsCompareFamilies = true : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = true);
          break;
        case 14:
        case 15:
          $$typeofNextType === REACT_MEMO_TYPE ? needsCompareFamilies = true : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = true);
          break;
        default:
          return false;
      }
      return needsCompareFamilies && (fiber = resolveFamily(prevType), fiber !== undefined && fiber === resolveFamily(element)) ? true : false;
    }
    function markFailedErrorBoundaryForHotReloading(fiber) {
      resolveFamily !== null && typeof WeakSet === "function" && (failedBoundaries === null && (failedBoundaries = new WeakSet), failedBoundaries.add(fiber));
    }
    function scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {
      do {
        var _fiber = fiber, alternate = _fiber.alternate, child = _fiber.child, sibling = _fiber.sibling, tag = _fiber.tag;
        _fiber = _fiber.type;
        var candidateType = null;
        switch (tag) {
          case 0:
          case 15:
          case 1:
            candidateType = _fiber;
            break;
          case 11:
            candidateType = _fiber.render;
        }
        if (resolveFamily === null)
          throw Error("Expected resolveFamily to be set during hot reload.");
        var needsRender = false;
        _fiber = false;
        candidateType !== null && (candidateType = resolveFamily(candidateType), candidateType !== undefined && (staleFamilies.has(candidateType) ? _fiber = true : updatedFamilies.has(candidateType) && (tag === 1 ? _fiber = true : needsRender = true)));
        failedBoundaries !== null && (failedBoundaries.has(fiber) || alternate !== null && failedBoundaries.has(alternate)) && (_fiber = true);
        _fiber && (fiber._debugNeedsRemount = true);
        if (_fiber || needsRender)
          alternate = enqueueConcurrentRenderForLane(fiber, 2), alternate !== null && scheduleUpdateOnFiber(alternate, fiber, 2);
        child === null || _fiber || scheduleFibersWithFamiliesRecursively(child, updatedFamilies, staleFamilies);
        if (sibling === null)
          break;
        fiber = sibling;
      } while (1);
    }
    function FiberNode(tag, pendingProps, key, mode) {
      this.tag = tag;
      this.key = key;
      this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
      this.index = 0;
      this.refCleanup = this.ref = null;
      this.pendingProps = pendingProps;
      this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
      this.mode = mode;
      this.subtreeFlags = this.flags = 0;
      this.deletions = null;
      this.childLanes = this.lanes = 0;
      this.alternate = null;
      this.actualDuration = -0;
      this.actualStartTime = -1.1;
      this.treeBaseDuration = this.selfBaseDuration = -0;
      this._debugTask = this._debugStack = this._debugOwner = this._debugInfo = null;
      this._debugNeedsRemount = false;
      this._debugHookTypes = null;
      hasBadMapPolyfill || typeof Object.preventExtensions !== "function" || Object.preventExtensions(this);
    }
    function shouldConstruct(Component) {
      Component = Component.prototype;
      return !(!Component || !Component.isReactComponent);
    }
    function createWorkInProgress(current2, pendingProps) {
      var workInProgress2 = current2.alternate;
      workInProgress2 === null ? (workInProgress2 = createFiber(current2.tag, pendingProps, current2.key, current2.mode), workInProgress2.elementType = current2.elementType, workInProgress2.type = current2.type, workInProgress2.stateNode = current2.stateNode, workInProgress2._debugOwner = current2._debugOwner, workInProgress2._debugStack = current2._debugStack, workInProgress2._debugTask = current2._debugTask, workInProgress2._debugHookTypes = current2._debugHookTypes, workInProgress2.alternate = current2, current2.alternate = workInProgress2) : (workInProgress2.pendingProps = pendingProps, workInProgress2.type = current2.type, workInProgress2.flags = 0, workInProgress2.subtreeFlags = 0, workInProgress2.deletions = null, workInProgress2.actualDuration = -0, workInProgress2.actualStartTime = -1.1);
      workInProgress2.flags = current2.flags & 65011712;
      workInProgress2.childLanes = current2.childLanes;
      workInProgress2.lanes = current2.lanes;
      workInProgress2.child = current2.child;
      workInProgress2.memoizedProps = current2.memoizedProps;
      workInProgress2.memoizedState = current2.memoizedState;
      workInProgress2.updateQueue = current2.updateQueue;
      pendingProps = current2.dependencies;
      workInProgress2.dependencies = pendingProps === null ? null : {
        lanes: pendingProps.lanes,
        firstContext: pendingProps.firstContext,
        _debugThenableState: pendingProps._debugThenableState
      };
      workInProgress2.sibling = current2.sibling;
      workInProgress2.index = current2.index;
      workInProgress2.ref = current2.ref;
      workInProgress2.refCleanup = current2.refCleanup;
      workInProgress2.selfBaseDuration = current2.selfBaseDuration;
      workInProgress2.treeBaseDuration = current2.treeBaseDuration;
      workInProgress2._debugInfo = current2._debugInfo;
      workInProgress2._debugNeedsRemount = current2._debugNeedsRemount;
      switch (workInProgress2.tag) {
        case 0:
        case 15:
          workInProgress2.type = resolveFunctionForHotReloading(current2.type);
          break;
        case 1:
          workInProgress2.type = resolveFunctionForHotReloading(current2.type);
          break;
        case 11:
          workInProgress2.type = resolveForwardRefForHotReloading(current2.type);
      }
      return workInProgress2;
    }
    function resetWorkInProgress(workInProgress2, renderLanes2) {
      workInProgress2.flags &= 65011714;
      var current2 = workInProgress2.alternate;
      current2 === null ? (workInProgress2.childLanes = 0, workInProgress2.lanes = renderLanes2, workInProgress2.child = null, workInProgress2.subtreeFlags = 0, workInProgress2.memoizedProps = null, workInProgress2.memoizedState = null, workInProgress2.updateQueue = null, workInProgress2.dependencies = null, workInProgress2.stateNode = null, workInProgress2.selfBaseDuration = 0, workInProgress2.treeBaseDuration = 0) : (workInProgress2.childLanes = current2.childLanes, workInProgress2.lanes = current2.lanes, workInProgress2.child = current2.child, workInProgress2.subtreeFlags = 0, workInProgress2.deletions = null, workInProgress2.memoizedProps = current2.memoizedProps, workInProgress2.memoizedState = current2.memoizedState, workInProgress2.updateQueue = current2.updateQueue, workInProgress2.type = current2.type, renderLanes2 = current2.dependencies, workInProgress2.dependencies = renderLanes2 === null ? null : {
        lanes: renderLanes2.lanes,
        firstContext: renderLanes2.firstContext,
        _debugThenableState: renderLanes2._debugThenableState
      }, workInProgress2.selfBaseDuration = current2.selfBaseDuration, workInProgress2.treeBaseDuration = current2.treeBaseDuration);
      return workInProgress2;
    }
    function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {
      var fiberTag = 0, resolvedType = type;
      if (typeof type === "function")
        shouldConstruct(type) && (fiberTag = 1), resolvedType = resolveFunctionForHotReloading(resolvedType);
      else if (typeof type === "string")
        fiberTag = getHostContext(), fiberTag = isHostHoistableType(type, pendingProps, fiberTag) ? 26 : type === "html" || type === "head" || type === "body" ? 27 : 5;
      else
        a:
          switch (type) {
            case REACT_ACTIVITY_TYPE:
              return key = createFiber(31, pendingProps, key, mode), key.elementType = REACT_ACTIVITY_TYPE, key.lanes = lanes, key;
            case REACT_FRAGMENT_TYPE:
              return createFiberFromFragment(pendingProps.children, mode, lanes, key);
            case REACT_STRICT_MODE_TYPE:
              fiberTag = 8;
              mode |= StrictLegacyMode;
              mode |= StrictEffectsMode;
              break;
            case REACT_PROFILER_TYPE:
              return type = pendingProps, owner = mode, typeof type.id !== "string" && console.error('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.', typeof type.id), key = createFiber(12, type, key, owner | ProfileMode), key.elementType = REACT_PROFILER_TYPE, key.lanes = lanes, key.stateNode = { effectDuration: 0, passiveEffectDuration: 0 }, key;
            case REACT_SUSPENSE_TYPE:
              return key = createFiber(13, pendingProps, key, mode), key.elementType = REACT_SUSPENSE_TYPE, key.lanes = lanes, key;
            case REACT_SUSPENSE_LIST_TYPE:
              return key = createFiber(19, pendingProps, key, mode), key.elementType = REACT_SUSPENSE_LIST_TYPE, key.lanes = lanes, key;
            default:
              if (typeof type === "object" && type !== null)
                switch (type.$$typeof) {
                  case REACT_CONTEXT_TYPE:
                    fiberTag = 10;
                    break a;
                  case REACT_CONSUMER_TYPE:
                    fiberTag = 9;
                    break a;
                  case REACT_FORWARD_REF_TYPE:
                    fiberTag = 11;
                    resolvedType = resolveForwardRefForHotReloading(resolvedType);
                    break a;
                  case REACT_MEMO_TYPE:
                    fiberTag = 14;
                    break a;
                  case REACT_LAZY_TYPE:
                    fiberTag = 16;
                    resolvedType = null;
                    break a;
                }
              resolvedType = "";
              if (type === undefined || typeof type === "object" && type !== null && Object.keys(type).length === 0)
                resolvedType += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
              type === null ? pendingProps = "null" : isArrayImpl(type) ? pendingProps = "array" : type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE ? (pendingProps = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />", resolvedType = " Did you accidentally export a JSX literal instead of a component?") : pendingProps = typeof type;
              (fiberTag = owner ? getComponentNameFromOwner(owner) : null) && (resolvedType += `

Check the render method of \`` + fiberTag + "`.");
              fiberTag = 29;
              pendingProps = Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + (pendingProps + "." + resolvedType));
              resolvedType = null;
          }
      key = createFiber(fiberTag, pendingProps, key, mode);
      key.elementType = type;
      key.type = resolvedType;
      key.lanes = lanes;
      key._debugOwner = owner;
      return key;
    }
    function createFiberFromElement(element, mode, lanes) {
      mode = createFiberFromTypeAndProps(element.type, element.key, element.props, element._owner, mode, lanes);
      mode._debugOwner = element._owner;
      mode._debugStack = element._debugStack;
      mode._debugTask = element._debugTask;
      return mode;
    }
    function createFiberFromFragment(elements, mode, lanes, key) {
      elements = createFiber(7, elements, key, mode);
      elements.lanes = lanes;
      return elements;
    }
    function createFiberFromText(content, mode, lanes) {
      content = createFiber(6, content, null, mode);
      content.lanes = lanes;
      return content;
    }
    function createFiberFromDehydratedFragment(dehydratedNode) {
      var fiber = createFiber(18, null, null, NoMode);
      fiber.stateNode = dehydratedNode;
      return fiber;
    }
    function createFiberFromPortal(portal, mode, lanes) {
      mode = createFiber(4, portal.children !== null ? portal.children : [], portal.key, mode);
      mode.lanes = lanes;
      mode.stateNode = {
        containerInfo: portal.containerInfo,
        pendingChildren: null,
        implementation: portal.implementation
      };
      return mode;
    }
    function createCapturedValueAtFiber(value, source) {
      if (typeof value === "object" && value !== null) {
        var existing = CapturedStacks.get(value);
        if (existing !== undefined)
          return existing;
        source = {
          value,
          source,
          stack: getStackByFiberInDevAndProd(source)
        };
        CapturedStacks.set(value, source);
        return source;
      }
      return {
        value,
        source,
        stack: getStackByFiberInDevAndProd(source)
      };
    }
    function pushTreeFork(workInProgress2, totalChildren) {
      warnIfNotHydrating();
      forkStack[forkStackIndex++] = treeForkCount;
      forkStack[forkStackIndex++] = treeForkProvider;
      treeForkProvider = workInProgress2;
      treeForkCount = totalChildren;
    }
    function pushTreeId(workInProgress2, totalChildren, index) {
      warnIfNotHydrating();
      idStack[idStackIndex++] = treeContextId;
      idStack[idStackIndex++] = treeContextOverflow;
      idStack[idStackIndex++] = treeContextProvider;
      treeContextProvider = workInProgress2;
      var baseIdWithLeadingBit = treeContextId;
      workInProgress2 = treeContextOverflow;
      var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
      baseIdWithLeadingBit &= ~(1 << baseLength);
      index += 1;
      var length = 32 - clz32(totalChildren) + baseLength;
      if (30 < length) {
        var numberOfOverflowBits = baseLength - baseLength % 5;
        length = (baseIdWithLeadingBit & (1 << numberOfOverflowBits) - 1).toString(32);
        baseIdWithLeadingBit >>= numberOfOverflowBits;
        baseLength -= numberOfOverflowBits;
        treeContextId = 1 << 32 - clz32(totalChildren) + baseLength | index << baseLength | baseIdWithLeadingBit;
        treeContextOverflow = length + workInProgress2;
      } else
        treeContextId = 1 << length | index << baseLength | baseIdWithLeadingBit, treeContextOverflow = workInProgress2;
    }
    function pushMaterializedTreeId(workInProgress2) {
      warnIfNotHydrating();
      workInProgress2.return !== null && (pushTreeFork(workInProgress2, 1), pushTreeId(workInProgress2, 1, 0));
    }
    function popTreeContext(workInProgress2) {
      for (;workInProgress2 === treeForkProvider; )
        treeForkProvider = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null, treeForkCount = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null;
      for (;workInProgress2 === treeContextProvider; )
        treeContextProvider = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextOverflow = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextId = idStack[--idStackIndex], idStack[idStackIndex] = null;
    }
    function getSuspendedTreeContext() {
      warnIfNotHydrating();
      return treeContextProvider !== null ? { id: treeContextId, overflow: treeContextOverflow } : null;
    }
    function restoreSuspendedTreeContext(workInProgress2, suspendedContext) {
      warnIfNotHydrating();
      idStack[idStackIndex++] = treeContextId;
      idStack[idStackIndex++] = treeContextOverflow;
      idStack[idStackIndex++] = treeContextProvider;
      treeContextId = suspendedContext.id;
      treeContextOverflow = suspendedContext.overflow;
      treeContextProvider = workInProgress2;
    }
    function warnIfNotHydrating() {
      isHydrating || console.error("Expected to be hydrating. This is a bug in React. Please file an issue.");
    }
    function buildHydrationDiffNode(fiber, distanceFromLeaf) {
      if (fiber.return === null) {
        if (hydrationDiffRootDEV === null)
          hydrationDiffRootDEV = {
            fiber,
            children: [],
            serverProps: undefined,
            serverTail: [],
            distanceFromLeaf
          };
        else {
          if (hydrationDiffRootDEV.fiber !== fiber)
            throw Error("Saw multiple hydration diff roots in a pass. This is a bug in React.");
          hydrationDiffRootDEV.distanceFromLeaf > distanceFromLeaf && (hydrationDiffRootDEV.distanceFromLeaf = distanceFromLeaf);
        }
        return hydrationDiffRootDEV;
      }
      var siblings = buildHydrationDiffNode(fiber.return, distanceFromLeaf + 1).children;
      if (0 < siblings.length && siblings[siblings.length - 1].fiber === fiber)
        return siblings = siblings[siblings.length - 1], siblings.distanceFromLeaf > distanceFromLeaf && (siblings.distanceFromLeaf = distanceFromLeaf), siblings;
      distanceFromLeaf = {
        fiber,
        children: [],
        serverProps: undefined,
        serverTail: [],
        distanceFromLeaf
      };
      siblings.push(distanceFromLeaf);
      return distanceFromLeaf;
    }
    function warnIfHydrating() {
      isHydrating && console.error("We should not be hydrating here. This is a bug in React. Please file a bug.");
    }
    function warnNonHydratedInstance(fiber, rejectedCandidate) {
      didSuspendOrErrorDEV || (fiber = buildHydrationDiffNode(fiber, 0), fiber.serverProps = null, rejectedCandidate !== null && (rejectedCandidate = describeHydratableInstanceForDevWarnings(rejectedCandidate), fiber.serverTail.push(rejectedCandidate)));
    }
    function throwOnHydrationMismatch(fiber) {
      var fromText = 1 < arguments.length && arguments[1] !== undefined ? arguments[1] : false, diff = "", diffRoot = hydrationDiffRootDEV;
      diffRoot !== null && (hydrationDiffRootDEV = null, diff = describeDiff(diffRoot));
      queueHydrationError(createCapturedValueAtFiber(Error("Hydration failed because the server rendered " + (fromText ? "text" : "HTML") + ` didn't match the client. As a result this tree will be regenerated on the client. This can happen if a SSR-ed Client Component used:

- A server/client branch \`if (typeof window !== 'undefined')\`.
- Variable input such as \`Date.now()\` or \`Math.random()\` which changes each time it's called.
- Date formatting in a user's locale which doesn't match the server.
- External changing data without sending a snapshot of it along with the HTML.
- Invalid HTML tag nesting.

It can also happen if the client has a browser extension installed which messes with the HTML before React loaded.

https://react.dev/link/hydration-mismatch` + diff), fiber));
      throw HydrationMismatchException;
    }
    function prepareToHydrateHostInstance(fiber) {
      var didHydrate = fiber.stateNode;
      var { type, memoizedProps: props } = fiber;
      didHydrate[internalInstanceKey] = fiber;
      didHydrate[internalPropsKey] = props;
      validatePropertiesInDevelopment(type, props);
      switch (type) {
        case "dialog":
          listenToNonDelegatedEvent("cancel", didHydrate);
          listenToNonDelegatedEvent("close", didHydrate);
          break;
        case "iframe":
        case "object":
        case "embed":
          listenToNonDelegatedEvent("load", didHydrate);
          break;
        case "video":
        case "audio":
          for (type = 0;type < mediaEventTypes.length; type++)
            listenToNonDelegatedEvent(mediaEventTypes[type], didHydrate);
          break;
        case "source":
          listenToNonDelegatedEvent("error", didHydrate);
          break;
        case "img":
        case "image":
        case "link":
          listenToNonDelegatedEvent("error", didHydrate);
          listenToNonDelegatedEvent("load", didHydrate);
          break;
        case "details":
          listenToNonDelegatedEvent("toggle", didHydrate);
          break;
        case "input":
          checkControlledValueProps("input", props);
          listenToNonDelegatedEvent("invalid", didHydrate);
          validateInputProps(didHydrate, props);
          initInput(didHydrate, props.value, props.defaultValue, props.checked, props.defaultChecked, props.type, props.name, true);
          break;
        case "option":
          validateOptionProps(didHydrate, props);
          break;
        case "select":
          checkControlledValueProps("select", props);
          listenToNonDelegatedEvent("invalid", didHydrate);
          validateSelectProps(didHydrate, props);
          break;
        case "textarea":
          checkControlledValueProps("textarea", props), listenToNonDelegatedEvent("invalid", didHydrate), validateTextareaProps(didHydrate, props), initTextarea(didHydrate, props.value, props.defaultValue, props.children);
      }
      type = props.children;
      typeof type !== "string" && typeof type !== "number" && typeof type !== "bigint" || didHydrate.textContent === "" + type || props.suppressHydrationWarning === true || checkForUnmatchedText(didHydrate.textContent, type) ? (props.popover != null && (listenToNonDelegatedEvent("beforetoggle", didHydrate), listenToNonDelegatedEvent("toggle", didHydrate)), props.onScroll != null && listenToNonDelegatedEvent("scroll", didHydrate), props.onScrollEnd != null && listenToNonDelegatedEvent("scrollend", didHydrate), props.onClick != null && (didHydrate.onclick = noop$1), didHydrate = true) : didHydrate = false;
      didHydrate || throwOnHydrationMismatch(fiber, true);
    }
    function popToNextHostParent(fiber) {
      for (hydrationParentFiber = fiber.return;hydrationParentFiber; )
        switch (hydrationParentFiber.tag) {
          case 5:
          case 31:
          case 13:
            rootOrSingletonContext = false;
            return;
          case 27:
          case 3:
            rootOrSingletonContext = true;
            return;
          default:
            hydrationParentFiber = hydrationParentFiber.return;
        }
    }
    function popHydrationState(fiber) {
      if (fiber !== hydrationParentFiber)
        return false;
      if (!isHydrating)
        return popToNextHostParent(fiber), isHydrating = true, false;
      var tag = fiber.tag, JSCompiler_temp;
      if (JSCompiler_temp = tag !== 3 && tag !== 27) {
        if (JSCompiler_temp = tag === 5)
          JSCompiler_temp = fiber.type, JSCompiler_temp = !(JSCompiler_temp !== "form" && JSCompiler_temp !== "button") || shouldSetTextContent(fiber.type, fiber.memoizedProps);
        JSCompiler_temp = !JSCompiler_temp;
      }
      if (JSCompiler_temp && nextHydratableInstance) {
        for (JSCompiler_temp = nextHydratableInstance;JSCompiler_temp; ) {
          var diffNode = buildHydrationDiffNode(fiber, 0), description = describeHydratableInstanceForDevWarnings(JSCompiler_temp);
          diffNode.serverTail.push(description);
          JSCompiler_temp = description.type === "Suspense" ? getNextHydratableInstanceAfterHydrationBoundary(JSCompiler_temp) : getNextHydratable(JSCompiler_temp.nextSibling);
        }
        throwOnHydrationMismatch(fiber);
      }
      popToNextHostParent(fiber);
      if (tag === 13) {
        fiber = fiber.memoizedState;
        fiber = fiber !== null ? fiber.dehydrated : null;
        if (!fiber)
          throw Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
        nextHydratableInstance = getNextHydratableInstanceAfterHydrationBoundary(fiber);
      } else if (tag === 31) {
        fiber = fiber.memoizedState;
        fiber = fiber !== null ? fiber.dehydrated : null;
        if (!fiber)
          throw Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
        nextHydratableInstance = getNextHydratableInstanceAfterHydrationBoundary(fiber);
      } else
        tag === 27 ? (tag = nextHydratableInstance, isSingletonScope(fiber.type) ? (fiber = previousHydratableOnEnteringScopedSingleton, previousHydratableOnEnteringScopedSingleton = null, nextHydratableInstance = fiber) : nextHydratableInstance = tag) : nextHydratableInstance = hydrationParentFiber ? getNextHydratable(fiber.stateNode.nextSibling) : null;
      return true;
    }
    function resetHydrationState() {
      nextHydratableInstance = hydrationParentFiber = null;
      didSuspendOrErrorDEV = isHydrating = false;
    }
    function upgradeHydrationErrorsToRecoverable() {
      var queuedErrors = hydrationErrors;
      queuedErrors !== null && (workInProgressRootRecoverableErrors === null ? workInProgressRootRecoverableErrors = queuedErrors : workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors, queuedErrors), hydrationErrors = null);
      return queuedErrors;
    }
    function queueHydrationError(error) {
      hydrationErrors === null ? hydrationErrors = [error] : hydrationErrors.push(error);
    }
    function emitPendingHydrationWarnings() {
      var diffRoot = hydrationDiffRootDEV;
      if (diffRoot !== null) {
        hydrationDiffRootDEV = null;
        for (var diff = describeDiff(diffRoot);0 < diffRoot.children.length; )
          diffRoot = diffRoot.children[0];
        runWithFiberInDEV(diffRoot.fiber, function() {
          console.error(`A tree hydrated but some attributes of the server rendered HTML didn't match the client properties. This won't be patched up. This can happen if a SSR-ed Client Component used:

- A server/client branch \`if (typeof window !== 'undefined')\`.
- Variable input such as \`Date.now()\` or \`Math.random()\` which changes each time it's called.
- Date formatting in a user's locale which doesn't match the server.
- External changing data without sending a snapshot of it along with the HTML.
- Invalid HTML tag nesting.

It can also happen if the client has a browser extension installed which messes with the HTML before React loaded.

%s%s`, "https://react.dev/link/hydration-mismatch", diff);
        });
      }
    }
    function resetContextDependencies() {
      lastContextDependency = currentlyRenderingFiber$1 = null;
      isDisallowedContextReadInDEV = false;
    }
    function pushProvider(providerFiber, context, nextValue) {
      push(valueCursor, context._currentValue, providerFiber);
      context._currentValue = nextValue;
      push(rendererCursorDEV, context._currentRenderer, providerFiber);
      context._currentRenderer !== undefined && context._currentRenderer !== null && context._currentRenderer !== rendererSigil && console.error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
      context._currentRenderer = rendererSigil;
    }
    function popProvider(context, providerFiber) {
      context._currentValue = valueCursor.current;
      var currentRenderer = rendererCursorDEV.current;
      pop(rendererCursorDEV, providerFiber);
      context._currentRenderer = currentRenderer;
      pop(valueCursor, providerFiber);
    }
    function scheduleContextWorkOnParentPath(parent, renderLanes2, propagationRoot) {
      for (;parent !== null; ) {
        var alternate = parent.alternate;
        (parent.childLanes & renderLanes2) !== renderLanes2 ? (parent.childLanes |= renderLanes2, alternate !== null && (alternate.childLanes |= renderLanes2)) : alternate !== null && (alternate.childLanes & renderLanes2) !== renderLanes2 && (alternate.childLanes |= renderLanes2);
        if (parent === propagationRoot)
          break;
        parent = parent.return;
      }
      parent !== propagationRoot && console.error("Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.");
    }
    function propagateContextChanges(workInProgress2, contexts, renderLanes2, forcePropagateEntireTree) {
      var fiber = workInProgress2.child;
      fiber !== null && (fiber.return = workInProgress2);
      for (;fiber !== null; ) {
        var list = fiber.dependencies;
        if (list !== null) {
          var nextFiber = fiber.child;
          list = list.firstContext;
          a:
            for (;list !== null; ) {
              var dependency = list;
              list = fiber;
              for (var i = 0;i < contexts.length; i++)
                if (dependency.context === contexts[i]) {
                  list.lanes |= renderLanes2;
                  dependency = list.alternate;
                  dependency !== null && (dependency.lanes |= renderLanes2);
                  scheduleContextWorkOnParentPath(list.return, renderLanes2, workInProgress2);
                  forcePropagateEntireTree || (nextFiber = null);
                  break a;
                }
              list = dependency.next;
            }
        } else if (fiber.tag === 18) {
          nextFiber = fiber.return;
          if (nextFiber === null)
            throw Error("We just came from a parent so we must have had a parent. This is a bug in React.");
          nextFiber.lanes |= renderLanes2;
          list = nextFiber.alternate;
          list !== null && (list.lanes |= renderLanes2);
          scheduleContextWorkOnParentPath(nextFiber, renderLanes2, workInProgress2);
          nextFiber = null;
        } else
          nextFiber = fiber.child;
        if (nextFiber !== null)
          nextFiber.return = fiber;
        else
          for (nextFiber = fiber;nextFiber !== null; ) {
            if (nextFiber === workInProgress2) {
              nextFiber = null;
              break;
            }
            fiber = nextFiber.sibling;
            if (fiber !== null) {
              fiber.return = nextFiber.return;
              nextFiber = fiber;
              break;
            }
            nextFiber = nextFiber.return;
          }
        fiber = nextFiber;
      }
    }
    function propagateParentContextChanges(current2, workInProgress2, renderLanes2, forcePropagateEntireTree) {
      current2 = null;
      for (var parent = workInProgress2, isInsidePropagationBailout = false;parent !== null; ) {
        if (!isInsidePropagationBailout) {
          if ((parent.flags & 524288) !== 0)
            isInsidePropagationBailout = true;
          else if ((parent.flags & 262144) !== 0)
            break;
        }
        if (parent.tag === 10) {
          var currentParent = parent.alternate;
          if (currentParent === null)
            throw Error("Should have a current fiber. This is a bug in React.");
          currentParent = currentParent.memoizedProps;
          if (currentParent !== null) {
            var context = parent.type;
            objectIs(parent.pendingProps.value, currentParent.value) || (current2 !== null ? current2.push(context) : current2 = [context]);
          }
        } else if (parent === hostTransitionProviderCursor.current) {
          currentParent = parent.alternate;
          if (currentParent === null)
            throw Error("Should have a current fiber. This is a bug in React.");
          currentParent.memoizedState.memoizedState !== parent.memoizedState.memoizedState && (current2 !== null ? current2.push(HostTransitionContext) : current2 = [HostTransitionContext]);
        }
        parent = parent.return;
      }
      current2 !== null && propagateContextChanges(workInProgress2, current2, renderLanes2, forcePropagateEntireTree);
      workInProgress2.flags |= 262144;
    }
    function checkIfContextChanged(currentDependencies) {
      for (currentDependencies = currentDependencies.firstContext;currentDependencies !== null; ) {
        if (!objectIs(currentDependencies.context._currentValue, currentDependencies.memoizedValue))
          return true;
        currentDependencies = currentDependencies.next;
      }
      return false;
    }
    function prepareToReadContext(workInProgress2) {
      currentlyRenderingFiber$1 = workInProgress2;
      lastContextDependency = null;
      workInProgress2 = workInProgress2.dependencies;
      workInProgress2 !== null && (workInProgress2.firstContext = null);
    }
    function readContext(context) {
      isDisallowedContextReadInDEV && console.error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      return readContextForConsumer(currentlyRenderingFiber$1, context);
    }
    function readContextDuringReconciliation(consumer, context) {
      currentlyRenderingFiber$1 === null && prepareToReadContext(consumer);
      return readContextForConsumer(consumer, context);
    }
    function readContextForConsumer(consumer, context) {
      var value = context._currentValue;
      context = { context, memoizedValue: value, next: null };
      if (lastContextDependency === null) {
        if (consumer === null)
          throw Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
        lastContextDependency = context;
        consumer.dependencies = {
          lanes: 0,
          firstContext: context,
          _debugThenableState: null
        };
        consumer.flags |= 524288;
      } else
        lastContextDependency = lastContextDependency.next = context;
      return value;
    }
    function createCache() {
      return {
        controller: new AbortControllerLocal,
        data: new Map,
        refCount: 0
      };
    }
    function retainCache(cache2) {
      cache2.controller.signal.aborted && console.warn("A cache instance was retained after it was already freed. This likely indicates a bug in React.");
      cache2.refCount++;
    }
    function releaseCache(cache2) {
      cache2.refCount--;
      0 > cache2.refCount && console.warn("A cache instance was released after it was already freed. This likely indicates a bug in React.");
      cache2.refCount === 0 && scheduleCallback$2(NormalPriority, function() {
        cache2.controller.abort();
      });
    }
    function startUpdateTimerByLane(lane, method, fiber) {
      if ((lane & 127) !== 0)
        0 > blockingUpdateTime && (blockingUpdateTime = now(), blockingUpdateTask = createTask(method), blockingUpdateMethodName = method, fiber != null && (blockingUpdateComponentName = getComponentNameFromFiber(fiber)), (executionContext & (RenderContext | CommitContext)) !== NoContext && (componentEffectSpawnedUpdate = true, blockingUpdateType = SPAWNED_UPDATE), lane = resolveEventTimeStamp(), method = resolveEventType(), lane !== blockingEventRepeatTime || method !== blockingEventType ? blockingEventRepeatTime = -1.1 : method !== null && (blockingUpdateType = SPAWNED_UPDATE), blockingEventTime = lane, blockingEventType = method);
      else if ((lane & 4194048) !== 0 && 0 > transitionUpdateTime && (transitionUpdateTime = now(), transitionUpdateTask = createTask(method), transitionUpdateMethodName = method, fiber != null && (transitionUpdateComponentName = getComponentNameFromFiber(fiber)), 0 > transitionStartTime)) {
        lane = resolveEventTimeStamp();
        method = resolveEventType();
        if (lane !== transitionEventRepeatTime || method !== transitionEventType)
          transitionEventRepeatTime = -1.1;
        transitionEventTime = lane;
        transitionEventType = method;
      }
    }
    function startHostActionTimer(fiber) {
      if (0 > blockingUpdateTime) {
        blockingUpdateTime = now();
        blockingUpdateTask = fiber._debugTask != null ? fiber._debugTask : null;
        (executionContext & (RenderContext | CommitContext)) !== NoContext && (blockingUpdateType = SPAWNED_UPDATE);
        var newEventTime = resolveEventTimeStamp(), newEventType = resolveEventType();
        newEventTime !== blockingEventRepeatTime || newEventType !== blockingEventType ? blockingEventRepeatTime = -1.1 : newEventType !== null && (blockingUpdateType = SPAWNED_UPDATE);
        blockingEventTime = newEventTime;
        blockingEventType = newEventType;
      }
      if (0 > transitionUpdateTime && (transitionUpdateTime = now(), transitionUpdateTask = fiber._debugTask != null ? fiber._debugTask : null, 0 > transitionStartTime)) {
        fiber = resolveEventTimeStamp();
        newEventTime = resolveEventType();
        if (fiber !== transitionEventRepeatTime || newEventTime !== transitionEventType)
          transitionEventRepeatTime = -1.1;
        transitionEventTime = fiber;
        transitionEventType = newEventTime;
      }
    }
    function pushNestedEffectDurations() {
      var prevEffectDuration = profilerEffectDuration;
      profilerEffectDuration = 0;
      return prevEffectDuration;
    }
    function popNestedEffectDurations(prevEffectDuration) {
      var elapsedTime = profilerEffectDuration;
      profilerEffectDuration = prevEffectDuration;
      return elapsedTime;
    }
    function bubbleNestedEffectDurations(prevEffectDuration) {
      var elapsedTime = profilerEffectDuration;
      profilerEffectDuration += prevEffectDuration;
      return elapsedTime;
    }
    function resetComponentEffectTimers() {
      componentEffectEndTime = componentEffectStartTime = -1.1;
    }
    function pushComponentEffectStart() {
      var prevEffectStart = componentEffectStartTime;
      componentEffectStartTime = -1.1;
      return prevEffectStart;
    }
    function popComponentEffectStart(prevEffectStart) {
      0 <= prevEffectStart && (componentEffectStartTime = prevEffectStart);
    }
    function pushComponentEffectDuration() {
      var prevEffectDuration = componentEffectDuration;
      componentEffectDuration = -0;
      return prevEffectDuration;
    }
    function popComponentEffectDuration(prevEffectDuration) {
      0 <= prevEffectDuration && (componentEffectDuration = prevEffectDuration);
    }
    function pushComponentEffectErrors() {
      var prevErrors = componentEffectErrors;
      componentEffectErrors = null;
      return prevErrors;
    }
    function pushComponentEffectDidSpawnUpdate() {
      var prev = componentEffectSpawnedUpdate;
      componentEffectSpawnedUpdate = false;
      return prev;
    }
    function startProfilerTimer(fiber) {
      profilerStartTime = now();
      0 > fiber.actualStartTime && (fiber.actualStartTime = profilerStartTime);
    }
    function stopProfilerTimerIfRunningAndRecordDuration(fiber) {
      if (0 <= profilerStartTime) {
        var elapsedTime = now() - profilerStartTime;
        fiber.actualDuration += elapsedTime;
        fiber.selfBaseDuration = elapsedTime;
        profilerStartTime = -1;
      }
    }
    function stopProfilerTimerIfRunningAndRecordIncompleteDuration(fiber) {
      if (0 <= profilerStartTime) {
        var elapsedTime = now() - profilerStartTime;
        fiber.actualDuration += elapsedTime;
        profilerStartTime = -1;
      }
    }
    function recordEffectDuration() {
      if (0 <= profilerStartTime) {
        var endTime = now(), elapsedTime = endTime - profilerStartTime;
        profilerStartTime = -1;
        profilerEffectDuration += elapsedTime;
        componentEffectDuration += elapsedTime;
        componentEffectEndTime = endTime;
      }
    }
    function recordEffectError(errorInfo) {
      componentEffectErrors === null && (componentEffectErrors = []);
      componentEffectErrors.push(errorInfo);
      commitErrors === null && (commitErrors = []);
      commitErrors.push(errorInfo);
    }
    function startEffectTimer() {
      profilerStartTime = now();
      0 > componentEffectStartTime && (componentEffectStartTime = profilerStartTime);
    }
    function transferActualDuration(fiber) {
      for (var child = fiber.child;child; )
        fiber.actualDuration += child.actualDuration, child = child.sibling;
    }
    function entangleAsyncAction(transition, thenable) {
      if (currentEntangledListeners === null) {
        var entangledListeners = currentEntangledListeners = [];
        currentEntangledPendingCount = 0;
        currentEntangledLane = requestTransitionLane();
        currentEntangledActionThenable = {
          status: "pending",
          value: undefined,
          then: function(resolve) {
            entangledListeners.push(resolve);
          }
        };
      }
      currentEntangledPendingCount++;
      thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);
      return thenable;
    }
    function pingEngtangledActionScope() {
      if (--currentEntangledPendingCount === 0 && (-1 < transitionUpdateTime || (transitionStartTime = -1.1), currentEntangledListeners !== null)) {
        currentEntangledActionThenable !== null && (currentEntangledActionThenable.status = "fulfilled");
        var listeners = currentEntangledListeners;
        currentEntangledListeners = null;
        currentEntangledLane = 0;
        currentEntangledActionThenable = null;
        for (var i = 0;i < listeners.length; i++)
          (0, listeners[i])();
      }
    }
    function chainThenableValue(thenable, result) {
      var listeners = [], thenableWithOverride = {
        status: "pending",
        value: null,
        reason: null,
        then: function(resolve) {
          listeners.push(resolve);
        }
      };
      thenable.then(function() {
        thenableWithOverride.status = "fulfilled";
        thenableWithOverride.value = result;
        for (var i = 0;i < listeners.length; i++)
          (0, listeners[i])(result);
      }, function(error) {
        thenableWithOverride.status = "rejected";
        thenableWithOverride.reason = error;
        for (error = 0;error < listeners.length; error++)
          (0, listeners[error])(undefined);
      });
      return thenableWithOverride;
    }
    function peekCacheFromPool() {
      var cacheResumedFromPreviousRender = resumedCache.current;
      return cacheResumedFromPreviousRender !== null ? cacheResumedFromPreviousRender : workInProgressRoot.pooledCache;
    }
    function pushTransition(offscreenWorkInProgress, prevCachePool) {
      prevCachePool === null ? push(resumedCache, resumedCache.current, offscreenWorkInProgress) : push(resumedCache, prevCachePool.pool, offscreenWorkInProgress);
    }
    function getSuspendedCache() {
      var cacheFromPool = peekCacheFromPool();
      return cacheFromPool === null ? null : { parent: CacheContext._currentValue, pool: cacheFromPool };
    }
    function createThenableState() {
      return { didWarnAboutUncachedPromise: false, thenables: [] };
    }
    function isThenableResolved(thenable) {
      thenable = thenable.status;
      return thenable === "fulfilled" || thenable === "rejected";
    }
    function trackUsedThenable(thenableState2, thenable, index) {
      ReactSharedInternals.actQueue !== null && (ReactSharedInternals.didUsePromise = true);
      var trackedThenables = thenableState2.thenables;
      index = trackedThenables[index];
      index === undefined ? trackedThenables.push(thenable) : index !== thenable && (thenableState2.didWarnAboutUncachedPromise || (thenableState2.didWarnAboutUncachedPromise = true, console.error("A component was suspended by an uncached promise. Creating promises inside a Client Component or hook is not yet supported, except via a Suspense-compatible library or framework.")), thenable.then(noop$1, noop$1), thenable = index);
      if (thenable._debugInfo === undefined) {
        thenableState2 = performance.now();
        trackedThenables = thenable.displayName;
        var ioInfo = {
          name: typeof trackedThenables === "string" ? trackedThenables : "Promise",
          start: thenableState2,
          end: thenableState2,
          value: thenable
        };
        thenable._debugInfo = [{ awaited: ioInfo }];
        thenable.status !== "fulfilled" && thenable.status !== "rejected" && (thenableState2 = function() {
          ioInfo.end = performance.now();
        }, thenable.then(thenableState2, thenableState2));
      }
      switch (thenable.status) {
        case "fulfilled":
          return thenable.value;
        case "rejected":
          throw thenableState2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState2), thenableState2;
        default:
          if (typeof thenable.status === "string")
            thenable.then(noop$1, noop$1);
          else {
            thenableState2 = workInProgressRoot;
            if (thenableState2 !== null && 100 < thenableState2.shellSuspendCounter)
              throw Error("An unknown Component is an async Client Component. Only Server Components can be async at the moment. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server.");
            thenableState2 = thenable;
            thenableState2.status = "pending";
            thenableState2.then(function(fulfilledValue) {
              if (thenable.status === "pending") {
                var fulfilledThenable = thenable;
                fulfilledThenable.status = "fulfilled";
                fulfilledThenable.value = fulfilledValue;
              }
            }, function(error) {
              if (thenable.status === "pending") {
                var rejectedThenable = thenable;
                rejectedThenable.status = "rejected";
                rejectedThenable.reason = error;
              }
            });
          }
          switch (thenable.status) {
            case "fulfilled":
              return thenable.value;
            case "rejected":
              throw thenableState2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState2), thenableState2;
          }
          suspendedThenable = thenable;
          needsToResetSuspendedThenableDEV = true;
          throw SuspenseException;
      }
    }
    function resolveLazy(lazyType) {
      try {
        return callLazyInitInDEV(lazyType);
      } catch (x) {
        if (x !== null && typeof x === "object" && typeof x.then === "function")
          throw suspendedThenable = x, needsToResetSuspendedThenableDEV = true, SuspenseException;
        throw x;
      }
    }
    function getSuspendedThenable() {
      if (suspendedThenable === null)
        throw Error("Expected a suspended thenable. This is a bug in React. Please file an issue.");
      var thenable = suspendedThenable;
      suspendedThenable = null;
      needsToResetSuspendedThenableDEV = false;
      return thenable;
    }
    function checkIfUseWrappedInAsyncCatch(rejectedReason) {
      if (rejectedReason === SuspenseException || rejectedReason === SuspenseActionException)
        throw Error("Hooks are not supported inside an async component. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server.");
    }
    function pushDebugInfo(debugInfo) {
      var previousDebugInfo = currentDebugInfo;
      debugInfo != null && (currentDebugInfo = previousDebugInfo === null ? debugInfo : previousDebugInfo.concat(debugInfo));
      return previousDebugInfo;
    }
    function getCurrentDebugTask() {
      var debugInfo = currentDebugInfo;
      if (debugInfo != null) {
        for (var i = debugInfo.length - 1;0 <= i; i--)
          if (debugInfo[i].name != null) {
            var debugTask = debugInfo[i].debugTask;
            if (debugTask != null)
              return debugTask;
          }
      }
      return null;
    }
    function validateFragmentProps(element, fiber, returnFiber) {
      for (var keys2 = Object.keys(element.props), i = 0;i < keys2.length; i++) {
        var key = keys2[i];
        if (key !== "children" && key !== "key") {
          fiber === null && (fiber = createFiberFromElement(element, returnFiber.mode, 0), fiber._debugInfo = currentDebugInfo, fiber.return = returnFiber);
          runWithFiberInDEV(fiber, function(erroredKey) {
            console.error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", erroredKey);
          }, key);
          break;
        }
      }
    }
    function unwrapThenable(thenable) {
      var index = thenableIndexCounter$1;
      thenableIndexCounter$1 += 1;
      thenableState$1 === null && (thenableState$1 = createThenableState());
      return trackUsedThenable(thenableState$1, thenable, index);
    }
    function coerceRef(workInProgress2, element) {
      element = element.props.ref;
      workInProgress2.ref = element !== undefined ? element : null;
    }
    function throwOnInvalidObjectTypeImpl(returnFiber, newChild) {
      if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE)
        throw Error(`A React Element from an older version of React was rendered. This is not supported. It can happen if:
- Multiple copies of the "react" package is used.
- A library pre-bundled an old copy of "react" or "react/jsx-runtime".
- A compiler tries to "inline" JSX instead of using the runtime.`);
      returnFiber = Object.prototype.toString.call(newChild);
      throw Error("Objects are not valid as a React child (found: " + (returnFiber === "[object Object]" ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : returnFiber) + "). If you meant to render a collection of children, use an array instead.");
    }
    function throwOnInvalidObjectType(returnFiber, newChild) {
      var debugTask = getCurrentDebugTask();
      debugTask !== null ? debugTask.run(throwOnInvalidObjectTypeImpl.bind(null, returnFiber, newChild)) : throwOnInvalidObjectTypeImpl(returnFiber, newChild);
    }
    function warnOnFunctionTypeImpl(returnFiber, invalidChild) {
      var parentName = getComponentNameFromFiber(returnFiber) || "Component";
      ownerHasFunctionTypeWarning[parentName] || (ownerHasFunctionTypeWarning[parentName] = true, invalidChild = invalidChild.displayName || invalidChild.name || "Component", returnFiber.tag === 3 ? console.error(`Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.
  root.render(%s)`, invalidChild, invalidChild, invalidChild) : console.error(`Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.
  <%s>{%s}</%s>`, invalidChild, invalidChild, parentName, invalidChild, parentName));
    }
    function warnOnFunctionType(returnFiber, invalidChild) {
      var debugTask = getCurrentDebugTask();
      debugTask !== null ? debugTask.run(warnOnFunctionTypeImpl.bind(null, returnFiber, invalidChild)) : warnOnFunctionTypeImpl(returnFiber, invalidChild);
    }
    function warnOnSymbolTypeImpl(returnFiber, invalidChild) {
      var parentName = getComponentNameFromFiber(returnFiber) || "Component";
      ownerHasSymbolTypeWarning[parentName] || (ownerHasSymbolTypeWarning[parentName] = true, invalidChild = String(invalidChild), returnFiber.tag === 3 ? console.error(`Symbols are not valid as a React child.
  root.render(%s)`, invalidChild) : console.error(`Symbols are not valid as a React child.
  <%s>%s</%s>`, parentName, invalidChild, parentName));
    }
    function warnOnSymbolType(returnFiber, invalidChild) {
      var debugTask = getCurrentDebugTask();
      debugTask !== null ? debugTask.run(warnOnSymbolTypeImpl.bind(null, returnFiber, invalidChild)) : warnOnSymbolTypeImpl(returnFiber, invalidChild);
    }
    function createChildReconciler(shouldTrackSideEffects) {
      function deleteChild(returnFiber, childToDelete) {
        if (shouldTrackSideEffects) {
          var deletions = returnFiber.deletions;
          deletions === null ? (returnFiber.deletions = [childToDelete], returnFiber.flags |= 16) : deletions.push(childToDelete);
        }
      }
      function deleteRemainingChildren(returnFiber, currentFirstChild) {
        if (!shouldTrackSideEffects)
          return null;
        for (;currentFirstChild !== null; )
          deleteChild(returnFiber, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
        return null;
      }
      function mapRemainingChildren(currentFirstChild) {
        for (var existingChildren = new Map;currentFirstChild !== null; )
          currentFirstChild.key !== null ? existingChildren.set(currentFirstChild.key, currentFirstChild) : existingChildren.set(currentFirstChild.index, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
        return existingChildren;
      }
      function useFiber(fiber, pendingProps) {
        fiber = createWorkInProgress(fiber, pendingProps);
        fiber.index = 0;
        fiber.sibling = null;
        return fiber;
      }
      function placeChild(newFiber, lastPlacedIndex, newIndex) {
        newFiber.index = newIndex;
        if (!shouldTrackSideEffects)
          return newFiber.flags |= 1048576, lastPlacedIndex;
        newIndex = newFiber.alternate;
        if (newIndex !== null)
          return newIndex = newIndex.index, newIndex < lastPlacedIndex ? (newFiber.flags |= 67108866, lastPlacedIndex) : newIndex;
        newFiber.flags |= 67108866;
        return lastPlacedIndex;
      }
      function placeSingleChild(newFiber) {
        shouldTrackSideEffects && newFiber.alternate === null && (newFiber.flags |= 67108866);
        return newFiber;
      }
      function updateTextNode(returnFiber, current2, textContent, lanes) {
        if (current2 === null || current2.tag !== 6)
          return current2 = createFiberFromText(textContent, returnFiber.mode, lanes), current2.return = returnFiber, current2._debugOwner = returnFiber, current2._debugTask = returnFiber._debugTask, current2._debugInfo = currentDebugInfo, current2;
        current2 = useFiber(current2, textContent);
        current2.return = returnFiber;
        current2._debugInfo = currentDebugInfo;
        return current2;
      }
      function updateElement(returnFiber, current2, element, lanes) {
        var elementType = element.type;
        if (elementType === REACT_FRAGMENT_TYPE)
          return current2 = updateFragment(returnFiber, current2, element.props.children, lanes, element.key), validateFragmentProps(element, current2, returnFiber), current2;
        if (current2 !== null && (current2.elementType === elementType || isCompatibleFamilyForHotReloading(current2, element) || typeof elementType === "object" && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === current2.type))
          return current2 = useFiber(current2, element.props), coerceRef(current2, element), current2.return = returnFiber, current2._debugOwner = element._owner, current2._debugInfo = currentDebugInfo, current2;
        current2 = createFiberFromElement(element, returnFiber.mode, lanes);
        coerceRef(current2, element);
        current2.return = returnFiber;
        current2._debugInfo = currentDebugInfo;
        return current2;
      }
      function updatePortal(returnFiber, current2, portal, lanes) {
        if (current2 === null || current2.tag !== 4 || current2.stateNode.containerInfo !== portal.containerInfo || current2.stateNode.implementation !== portal.implementation)
          return current2 = createFiberFromPortal(portal, returnFiber.mode, lanes), current2.return = returnFiber, current2._debugInfo = currentDebugInfo, current2;
        current2 = useFiber(current2, portal.children || []);
        current2.return = returnFiber;
        current2._debugInfo = currentDebugInfo;
        return current2;
      }
      function updateFragment(returnFiber, current2, fragment, lanes, key) {
        if (current2 === null || current2.tag !== 7)
          return current2 = createFiberFromFragment(fragment, returnFiber.mode, lanes, key), current2.return = returnFiber, current2._debugOwner = returnFiber, current2._debugTask = returnFiber._debugTask, current2._debugInfo = currentDebugInfo, current2;
        current2 = useFiber(current2, fragment);
        current2.return = returnFiber;
        current2._debugInfo = currentDebugInfo;
        return current2;
      }
      function createChild(returnFiber, newChild, lanes) {
        if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number" || typeof newChild === "bigint")
          return newChild = createFiberFromText("" + newChild, returnFiber.mode, lanes), newChild.return = returnFiber, newChild._debugOwner = returnFiber, newChild._debugTask = returnFiber._debugTask, newChild._debugInfo = currentDebugInfo, newChild;
        if (typeof newChild === "object" && newChild !== null) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE:
              return lanes = createFiberFromElement(newChild, returnFiber.mode, lanes), coerceRef(lanes, newChild), lanes.return = returnFiber, returnFiber = pushDebugInfo(newChild._debugInfo), lanes._debugInfo = currentDebugInfo, currentDebugInfo = returnFiber, lanes;
            case REACT_PORTAL_TYPE:
              return newChild = createFiberFromPortal(newChild, returnFiber.mode, lanes), newChild.return = returnFiber, newChild._debugInfo = currentDebugInfo, newChild;
            case REACT_LAZY_TYPE:
              var _prevDebugInfo = pushDebugInfo(newChild._debugInfo);
              newChild = resolveLazy(newChild);
              returnFiber = createChild(returnFiber, newChild, lanes);
              currentDebugInfo = _prevDebugInfo;
              return returnFiber;
          }
          if (isArrayImpl(newChild) || getIteratorFn(newChild))
            return lanes = createFiberFromFragment(newChild, returnFiber.mode, lanes, null), lanes.return = returnFiber, lanes._debugOwner = returnFiber, lanes._debugTask = returnFiber._debugTask, returnFiber = pushDebugInfo(newChild._debugInfo), lanes._debugInfo = currentDebugInfo, currentDebugInfo = returnFiber, lanes;
          if (typeof newChild.then === "function")
            return _prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = createChild(returnFiber, unwrapThenable(newChild), lanes), currentDebugInfo = _prevDebugInfo, returnFiber;
          if (newChild.$$typeof === REACT_CONTEXT_TYPE)
            return createChild(returnFiber, readContextDuringReconciliation(returnFiber, newChild), lanes);
          throwOnInvalidObjectType(returnFiber, newChild);
        }
        typeof newChild === "function" && warnOnFunctionType(returnFiber, newChild);
        typeof newChild === "symbol" && warnOnSymbolType(returnFiber, newChild);
        return null;
      }
      function updateSlot(returnFiber, oldFiber, newChild, lanes) {
        var key = oldFiber !== null ? oldFiber.key : null;
        if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number" || typeof newChild === "bigint")
          return key !== null ? null : updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
        if (typeof newChild === "object" && newChild !== null) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE:
              return newChild.key === key ? (key = pushDebugInfo(newChild._debugInfo), returnFiber = updateElement(returnFiber, oldFiber, newChild, lanes), currentDebugInfo = key, returnFiber) : null;
            case REACT_PORTAL_TYPE:
              return newChild.key === key ? updatePortal(returnFiber, oldFiber, newChild, lanes) : null;
            case REACT_LAZY_TYPE:
              return key = pushDebugInfo(newChild._debugInfo), newChild = resolveLazy(newChild), returnFiber = updateSlot(returnFiber, oldFiber, newChild, lanes), currentDebugInfo = key, returnFiber;
          }
          if (isArrayImpl(newChild) || getIteratorFn(newChild)) {
            if (key !== null)
              return null;
            key = pushDebugInfo(newChild._debugInfo);
            returnFiber = updateFragment(returnFiber, oldFiber, newChild, lanes, null);
            currentDebugInfo = key;
            return returnFiber;
          }
          if (typeof newChild.then === "function")
            return key = pushDebugInfo(newChild._debugInfo), returnFiber = updateSlot(returnFiber, oldFiber, unwrapThenable(newChild), lanes), currentDebugInfo = key, returnFiber;
          if (newChild.$$typeof === REACT_CONTEXT_TYPE)
            return updateSlot(returnFiber, oldFiber, readContextDuringReconciliation(returnFiber, newChild), lanes);
          throwOnInvalidObjectType(returnFiber, newChild);
        }
        typeof newChild === "function" && warnOnFunctionType(returnFiber, newChild);
        typeof newChild === "symbol" && warnOnSymbolType(returnFiber, newChild);
        return null;
      }
      function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
        if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number" || typeof newChild === "bigint")
          return existingChildren = existingChildren.get(newIdx) || null, updateTextNode(returnFiber, existingChildren, "" + newChild, lanes);
        if (typeof newChild === "object" && newChild !== null) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE:
              return newIdx = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null, existingChildren = pushDebugInfo(newChild._debugInfo), returnFiber = updateElement(returnFiber, newIdx, newChild, lanes), currentDebugInfo = existingChildren, returnFiber;
            case REACT_PORTAL_TYPE:
              return existingChildren = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null, updatePortal(returnFiber, existingChildren, newChild, lanes);
            case REACT_LAZY_TYPE:
              var _prevDebugInfo7 = pushDebugInfo(newChild._debugInfo);
              newChild = resolveLazy(newChild);
              returnFiber = updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes);
              currentDebugInfo = _prevDebugInfo7;
              return returnFiber;
          }
          if (isArrayImpl(newChild) || getIteratorFn(newChild))
            return newIdx = existingChildren.get(newIdx) || null, existingChildren = pushDebugInfo(newChild._debugInfo), returnFiber = updateFragment(returnFiber, newIdx, newChild, lanes, null), currentDebugInfo = existingChildren, returnFiber;
          if (typeof newChild.then === "function")
            return _prevDebugInfo7 = pushDebugInfo(newChild._debugInfo), returnFiber = updateFromMap(existingChildren, returnFiber, newIdx, unwrapThenable(newChild), lanes), currentDebugInfo = _prevDebugInfo7, returnFiber;
          if (newChild.$$typeof === REACT_CONTEXT_TYPE)
            return updateFromMap(existingChildren, returnFiber, newIdx, readContextDuringReconciliation(returnFiber, newChild), lanes);
          throwOnInvalidObjectType(returnFiber, newChild);
        }
        typeof newChild === "function" && warnOnFunctionType(returnFiber, newChild);
        typeof newChild === "symbol" && warnOnSymbolType(returnFiber, newChild);
        return null;
      }
      function warnOnInvalidKey(returnFiber, workInProgress2, child, knownKeys) {
        if (typeof child !== "object" || child === null)
          return knownKeys;
        switch (child.$$typeof) {
          case REACT_ELEMENT_TYPE:
          case REACT_PORTAL_TYPE:
            warnForMissingKey(returnFiber, workInProgress2, child);
            var key = child.key;
            if (typeof key !== "string")
              break;
            if (knownKeys === null) {
              knownKeys = new Set;
              knownKeys.add(key);
              break;
            }
            if (!knownKeys.has(key)) {
              knownKeys.add(key);
              break;
            }
            runWithFiberInDEV(workInProgress2, function() {
              console.error("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted  the behavior is unsupported and could change in a future version.", key);
            });
            break;
          case REACT_LAZY_TYPE:
            child = resolveLazy(child), warnOnInvalidKey(returnFiber, workInProgress2, child, knownKeys);
        }
        return knownKeys;
      }
      function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
        for (var knownKeys = null, resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null;oldFiber !== null && newIdx < newChildren.length; newIdx++) {
          oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
          var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], lanes);
          if (newFiber === null) {
            oldFiber === null && (oldFiber = nextOldFiber);
            break;
          }
          knownKeys = warnOnInvalidKey(returnFiber, newFiber, newChildren[newIdx], knownKeys);
          shouldTrackSideEffects && oldFiber && newFiber.alternate === null && deleteChild(returnFiber, oldFiber);
          currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
          previousNewFiber === null ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
          previousNewFiber = newFiber;
          oldFiber = nextOldFiber;
        }
        if (newIdx === newChildren.length)
          return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
        if (oldFiber === null) {
          for (;newIdx < newChildren.length; newIdx++)
            oldFiber = createChild(returnFiber, newChildren[newIdx], lanes), oldFiber !== null && (knownKeys = warnOnInvalidKey(returnFiber, oldFiber, newChildren[newIdx], knownKeys), currentFirstChild = placeChild(oldFiber, currentFirstChild, newIdx), previousNewFiber === null ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);
          isHydrating && pushTreeFork(returnFiber, newIdx);
          return resultingFirstChild;
        }
        for (oldFiber = mapRemainingChildren(oldFiber);newIdx < newChildren.length; newIdx++)
          nextOldFiber = updateFromMap(oldFiber, returnFiber, newIdx, newChildren[newIdx], lanes), nextOldFiber !== null && (knownKeys = warnOnInvalidKey(returnFiber, nextOldFiber, newChildren[newIdx], knownKeys), shouldTrackSideEffects && nextOldFiber.alternate !== null && oldFiber.delete(nextOldFiber.key === null ? newIdx : nextOldFiber.key), currentFirstChild = placeChild(nextOldFiber, currentFirstChild, newIdx), previousNewFiber === null ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);
        shouldTrackSideEffects && oldFiber.forEach(function(child) {
          return deleteChild(returnFiber, child);
        });
        isHydrating && pushTreeFork(returnFiber, newIdx);
        return resultingFirstChild;
      }
      function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes) {
        if (newChildren == null)
          throw Error("An iterable object provided no iterator.");
        for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null, knownKeys = null, step = newChildren.next();oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {
          oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
          var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
          if (newFiber === null) {
            oldFiber === null && (oldFiber = nextOldFiber);
            break;
          }
          knownKeys = warnOnInvalidKey(returnFiber, newFiber, step.value, knownKeys);
          shouldTrackSideEffects && oldFiber && newFiber.alternate === null && deleteChild(returnFiber, oldFiber);
          currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
          previousNewFiber === null ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
          previousNewFiber = newFiber;
          oldFiber = nextOldFiber;
        }
        if (step.done)
          return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
        if (oldFiber === null) {
          for (;!step.done; newIdx++, step = newChildren.next())
            oldFiber = createChild(returnFiber, step.value, lanes), oldFiber !== null && (knownKeys = warnOnInvalidKey(returnFiber, oldFiber, step.value, knownKeys), currentFirstChild = placeChild(oldFiber, currentFirstChild, newIdx), previousNewFiber === null ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);
          isHydrating && pushTreeFork(returnFiber, newIdx);
          return resultingFirstChild;
        }
        for (oldFiber = mapRemainingChildren(oldFiber);!step.done; newIdx++, step = newChildren.next())
          nextOldFiber = updateFromMap(oldFiber, returnFiber, newIdx, step.value, lanes), nextOldFiber !== null && (knownKeys = warnOnInvalidKey(returnFiber, nextOldFiber, step.value, knownKeys), shouldTrackSideEffects && nextOldFiber.alternate !== null && oldFiber.delete(nextOldFiber.key === null ? newIdx : nextOldFiber.key), currentFirstChild = placeChild(nextOldFiber, currentFirstChild, newIdx), previousNewFiber === null ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);
        shouldTrackSideEffects && oldFiber.forEach(function(child) {
          return deleteChild(returnFiber, child);
        });
        isHydrating && pushTreeFork(returnFiber, newIdx);
        return resultingFirstChild;
      }
      function reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes) {
        typeof newChild === "object" && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null && (validateFragmentProps(newChild, null, returnFiber), newChild = newChild.props.children);
        if (typeof newChild === "object" && newChild !== null) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE:
              var prevDebugInfo = pushDebugInfo(newChild._debugInfo);
              a: {
                for (var key = newChild.key;currentFirstChild !== null; ) {
                  if (currentFirstChild.key === key) {
                    key = newChild.type;
                    if (key === REACT_FRAGMENT_TYPE) {
                      if (currentFirstChild.tag === 7) {
                        deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
                        lanes = useFiber(currentFirstChild, newChild.props.children);
                        lanes.return = returnFiber;
                        lanes._debugOwner = newChild._owner;
                        lanes._debugInfo = currentDebugInfo;
                        validateFragmentProps(newChild, lanes, returnFiber);
                        returnFiber = lanes;
                        break a;
                      }
                    } else if (currentFirstChild.elementType === key || isCompatibleFamilyForHotReloading(currentFirstChild, newChild) || typeof key === "object" && key !== null && key.$$typeof === REACT_LAZY_TYPE && resolveLazy(key) === currentFirstChild.type) {
                      deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
                      lanes = useFiber(currentFirstChild, newChild.props);
                      coerceRef(lanes, newChild);
                      lanes.return = returnFiber;
                      lanes._debugOwner = newChild._owner;
                      lanes._debugInfo = currentDebugInfo;
                      returnFiber = lanes;
                      break a;
                    }
                    deleteRemainingChildren(returnFiber, currentFirstChild);
                    break;
                  } else
                    deleteChild(returnFiber, currentFirstChild);
                  currentFirstChild = currentFirstChild.sibling;
                }
                newChild.type === REACT_FRAGMENT_TYPE ? (lanes = createFiberFromFragment(newChild.props.children, returnFiber.mode, lanes, newChild.key), lanes.return = returnFiber, lanes._debugOwner = returnFiber, lanes._debugTask = returnFiber._debugTask, lanes._debugInfo = currentDebugInfo, validateFragmentProps(newChild, lanes, returnFiber), returnFiber = lanes) : (lanes = createFiberFromElement(newChild, returnFiber.mode, lanes), coerceRef(lanes, newChild), lanes.return = returnFiber, lanes._debugInfo = currentDebugInfo, returnFiber = lanes);
              }
              returnFiber = placeSingleChild(returnFiber);
              currentDebugInfo = prevDebugInfo;
              return returnFiber;
            case REACT_PORTAL_TYPE:
              a: {
                prevDebugInfo = newChild;
                for (newChild = prevDebugInfo.key;currentFirstChild !== null; ) {
                  if (currentFirstChild.key === newChild)
                    if (currentFirstChild.tag === 4 && currentFirstChild.stateNode.containerInfo === prevDebugInfo.containerInfo && currentFirstChild.stateNode.implementation === prevDebugInfo.implementation) {
                      deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
                      lanes = useFiber(currentFirstChild, prevDebugInfo.children || []);
                      lanes.return = returnFiber;
                      returnFiber = lanes;
                      break a;
                    } else {
                      deleteRemainingChildren(returnFiber, currentFirstChild);
                      break;
                    }
                  else
                    deleteChild(returnFiber, currentFirstChild);
                  currentFirstChild = currentFirstChild.sibling;
                }
                lanes = createFiberFromPortal(prevDebugInfo, returnFiber.mode, lanes);
                lanes.return = returnFiber;
                returnFiber = lanes;
              }
              return placeSingleChild(returnFiber);
            case REACT_LAZY_TYPE:
              return prevDebugInfo = pushDebugInfo(newChild._debugInfo), newChild = resolveLazy(newChild), returnFiber = reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes), currentDebugInfo = prevDebugInfo, returnFiber;
          }
          if (isArrayImpl(newChild))
            return prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes), currentDebugInfo = prevDebugInfo, returnFiber;
          if (getIteratorFn(newChild)) {
            prevDebugInfo = pushDebugInfo(newChild._debugInfo);
            key = getIteratorFn(newChild);
            if (typeof key !== "function")
              throw Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
            var newChildren = key.call(newChild);
            if (newChildren === newChild) {
              if (returnFiber.tag !== 0 || Object.prototype.toString.call(returnFiber.type) !== "[object GeneratorFunction]" || Object.prototype.toString.call(newChildren) !== "[object Generator]")
                didWarnAboutGenerators || console.error("Using Iterators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. You can also use an Iterable that can iterate multiple times over the same items."), didWarnAboutGenerators = true;
            } else
              newChild.entries !== key || didWarnAboutMaps || (console.error("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), didWarnAboutMaps = true);
            returnFiber = reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes);
            currentDebugInfo = prevDebugInfo;
            return returnFiber;
          }
          if (typeof newChild.then === "function")
            return prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = reconcileChildFibersImpl(returnFiber, currentFirstChild, unwrapThenable(newChild), lanes), currentDebugInfo = prevDebugInfo, returnFiber;
          if (newChild.$$typeof === REACT_CONTEXT_TYPE)
            return reconcileChildFibersImpl(returnFiber, currentFirstChild, readContextDuringReconciliation(returnFiber, newChild), lanes);
          throwOnInvalidObjectType(returnFiber, newChild);
        }
        if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number" || typeof newChild === "bigint")
          return prevDebugInfo = "" + newChild, currentFirstChild !== null && currentFirstChild.tag === 6 ? (deleteRemainingChildren(returnFiber, currentFirstChild.sibling), lanes = useFiber(currentFirstChild, prevDebugInfo), lanes.return = returnFiber, returnFiber = lanes) : (deleteRemainingChildren(returnFiber, currentFirstChild), lanes = createFiberFromText(prevDebugInfo, returnFiber.mode, lanes), lanes.return = returnFiber, lanes._debugOwner = returnFiber, lanes._debugTask = returnFiber._debugTask, lanes._debugInfo = currentDebugInfo, returnFiber = lanes), placeSingleChild(returnFiber);
        typeof newChild === "function" && warnOnFunctionType(returnFiber, newChild);
        typeof newChild === "symbol" && warnOnSymbolType(returnFiber, newChild);
        return deleteRemainingChildren(returnFiber, currentFirstChild);
      }
      return function(returnFiber, currentFirstChild, newChild, lanes) {
        var prevDebugInfo = currentDebugInfo;
        currentDebugInfo = null;
        try {
          thenableIndexCounter$1 = 0;
          var firstChildFiber = reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes);
          thenableState$1 = null;
          return firstChildFiber;
        } catch (x) {
          if (x === SuspenseException || x === SuspenseActionException)
            throw x;
          var fiber = createFiber(29, x, null, returnFiber.mode);
          fiber.lanes = lanes;
          fiber.return = returnFiber;
          var debugInfo = fiber._debugInfo = currentDebugInfo;
          fiber._debugOwner = returnFiber._debugOwner;
          fiber._debugTask = returnFiber._debugTask;
          if (debugInfo != null) {
            for (var i = debugInfo.length - 1;0 <= i; i--)
              if (typeof debugInfo[i].stack === "string") {
                fiber._debugOwner = debugInfo[i];
                fiber._debugTask = debugInfo[i].debugTask;
                break;
              }
          }
          return fiber;
        } finally {
          currentDebugInfo = prevDebugInfo;
        }
      };
    }
    function validateSuspenseListNestedChild(childSlot, index) {
      var isAnArray = isArrayImpl(childSlot);
      childSlot = !isAnArray && typeof getIteratorFn(childSlot) === "function";
      return isAnArray || childSlot ? (isAnArray = isAnArray ? "array" : "iterable", console.error("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", isAnArray, index, isAnArray), false) : true;
    }
    function initializeUpdateQueue(fiber) {
      fiber.updateQueue = {
        baseState: fiber.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: { pending: null, lanes: 0, hiddenCallbacks: null },
        callbacks: null
      };
    }
    function cloneUpdateQueue(current2, workInProgress2) {
      current2 = current2.updateQueue;
      workInProgress2.updateQueue === current2 && (workInProgress2.updateQueue = {
        baseState: current2.baseState,
        firstBaseUpdate: current2.firstBaseUpdate,
        lastBaseUpdate: current2.lastBaseUpdate,
        shared: current2.shared,
        callbacks: null
      });
    }
    function createUpdate(lane) {
      return {
        lane,
        tag: UpdateState,
        payload: null,
        callback: null,
        next: null
      };
    }
    function enqueueUpdate(fiber, update, lane) {
      var updateQueue = fiber.updateQueue;
      if (updateQueue === null)
        return null;
      updateQueue = updateQueue.shared;
      if (currentlyProcessingQueue === updateQueue && !didWarnUpdateInsideUpdate) {
        var componentName2 = getComponentNameFromFiber(fiber);
        console.error(`An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback.

Please update the following component: %s`, componentName2);
        didWarnUpdateInsideUpdate = true;
      }
      if ((executionContext & RenderContext) !== NoContext)
        return componentName2 = updateQueue.pending, componentName2 === null ? update.next = update : (update.next = componentName2.next, componentName2.next = update), updateQueue.pending = update, update = getRootForUpdatedFiber(fiber), markUpdateLaneFromFiberToRoot(fiber, null, lane), update;
      enqueueUpdate$1(fiber, updateQueue, update, lane);
      return getRootForUpdatedFiber(fiber);
    }
    function entangleTransitions(root2, fiber, lane) {
      fiber = fiber.updateQueue;
      if (fiber !== null && (fiber = fiber.shared, (lane & 4194048) !== 0)) {
        var queueLanes = fiber.lanes;
        queueLanes &= root2.pendingLanes;
        lane |= queueLanes;
        fiber.lanes = lane;
        markRootEntangled(root2, lane);
      }
    }
    function enqueueCapturedUpdate(workInProgress2, capturedUpdate) {
      var { updateQueue: queue, alternate: current2 } = workInProgress2;
      if (current2 !== null && (current2 = current2.updateQueue, queue === current2)) {
        var newFirst = null, newLast = null;
        queue = queue.firstBaseUpdate;
        if (queue !== null) {
          do {
            var clone = {
              lane: queue.lane,
              tag: queue.tag,
              payload: queue.payload,
              callback: null,
              next: null
            };
            newLast === null ? newFirst = newLast = clone : newLast = newLast.next = clone;
            queue = queue.next;
          } while (queue !== null);
          newLast === null ? newFirst = newLast = capturedUpdate : newLast = newLast.next = capturedUpdate;
        } else
          newFirst = newLast = capturedUpdate;
        queue = {
          baseState: current2.baseState,
          firstBaseUpdate: newFirst,
          lastBaseUpdate: newLast,
          shared: current2.shared,
          callbacks: current2.callbacks
        };
        workInProgress2.updateQueue = queue;
        return;
      }
      workInProgress2 = queue.lastBaseUpdate;
      workInProgress2 === null ? queue.firstBaseUpdate = capturedUpdate : workInProgress2.next = capturedUpdate;
      queue.lastBaseUpdate = capturedUpdate;
    }
    function suspendIfUpdateReadFromEntangledAsyncAction() {
      if (didReadFromEntangledAsyncAction) {
        var entangledActionThenable = currentEntangledActionThenable;
        if (entangledActionThenable !== null)
          throw entangledActionThenable;
      }
    }
    function processUpdateQueue(workInProgress2, props, instance$jscomp$0, renderLanes2) {
      didReadFromEntangledAsyncAction = false;
      var queue = workInProgress2.updateQueue;
      hasForceUpdate = false;
      currentlyProcessingQueue = queue.shared;
      var { firstBaseUpdate, lastBaseUpdate } = queue, pendingQueue = queue.shared.pending;
      if (pendingQueue !== null) {
        queue.shared.pending = null;
        var lastPendingUpdate = pendingQueue, firstPendingUpdate = lastPendingUpdate.next;
        lastPendingUpdate.next = null;
        lastBaseUpdate === null ? firstBaseUpdate = firstPendingUpdate : lastBaseUpdate.next = firstPendingUpdate;
        lastBaseUpdate = lastPendingUpdate;
        var current2 = workInProgress2.alternate;
        current2 !== null && (current2 = current2.updateQueue, pendingQueue = current2.lastBaseUpdate, pendingQueue !== lastBaseUpdate && (pendingQueue === null ? current2.firstBaseUpdate = firstPendingUpdate : pendingQueue.next = firstPendingUpdate, current2.lastBaseUpdate = lastPendingUpdate));
      }
      if (firstBaseUpdate !== null) {
        var newState = queue.baseState;
        lastBaseUpdate = 0;
        current2 = firstPendingUpdate = lastPendingUpdate = null;
        pendingQueue = firstBaseUpdate;
        do {
          var updateLane = pendingQueue.lane & -536870913, isHiddenUpdate = updateLane !== pendingQueue.lane;
          if (isHiddenUpdate ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes2 & updateLane) === updateLane) {
            updateLane !== 0 && updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction = true);
            current2 !== null && (current2 = current2.next = {
              lane: 0,
              tag: pendingQueue.tag,
              payload: pendingQueue.payload,
              callback: null,
              next: null
            });
            a: {
              updateLane = workInProgress2;
              var partialState = pendingQueue;
              var nextProps = props, instance = instance$jscomp$0;
              switch (partialState.tag) {
                case ReplaceState:
                  partialState = partialState.payload;
                  if (typeof partialState === "function") {
                    isDisallowedContextReadInDEV = true;
                    var nextState = partialState.call(instance, newState, nextProps);
                    if (updateLane.mode & StrictLegacyMode) {
                      setIsStrictModeForDevtools(true);
                      try {
                        partialState.call(instance, newState, nextProps);
                      } finally {
                        setIsStrictModeForDevtools(false);
                      }
                    }
                    isDisallowedContextReadInDEV = false;
                    newState = nextState;
                    break a;
                  }
                  newState = partialState;
                  break a;
                case CaptureUpdate:
                  updateLane.flags = updateLane.flags & -65537 | 128;
                case UpdateState:
                  nextState = partialState.payload;
                  if (typeof nextState === "function") {
                    isDisallowedContextReadInDEV = true;
                    partialState = nextState.call(instance, newState, nextProps);
                    if (updateLane.mode & StrictLegacyMode) {
                      setIsStrictModeForDevtools(true);
                      try {
                        nextState.call(instance, newState, nextProps);
                      } finally {
                        setIsStrictModeForDevtools(false);
                      }
                    }
                    isDisallowedContextReadInDEV = false;
                  } else
                    partialState = nextState;
                  if (partialState === null || partialState === undefined)
                    break a;
                  newState = assign({}, newState, partialState);
                  break a;
                case ForceUpdate:
                  hasForceUpdate = true;
              }
            }
            updateLane = pendingQueue.callback;
            updateLane !== null && (workInProgress2.flags |= 64, isHiddenUpdate && (workInProgress2.flags |= 8192), isHiddenUpdate = queue.callbacks, isHiddenUpdate === null ? queue.callbacks = [updateLane] : isHiddenUpdate.push(updateLane));
          } else
            isHiddenUpdate = {
              lane: updateLane,
              tag: pendingQueue.tag,
              payload: pendingQueue.payload,
              callback: pendingQueue.callback,
              next: null
            }, current2 === null ? (firstPendingUpdate = current2 = isHiddenUpdate, lastPendingUpdate = newState) : current2 = current2.next = isHiddenUpdate, lastBaseUpdate |= updateLane;
          pendingQueue = pendingQueue.next;
          if (pendingQueue === null)
            if (pendingQueue = queue.shared.pending, pendingQueue === null)
              break;
            else
              isHiddenUpdate = pendingQueue, pendingQueue = isHiddenUpdate.next, isHiddenUpdate.next = null, queue.lastBaseUpdate = isHiddenUpdate, queue.shared.pending = null;
        } while (1);
        current2 === null && (lastPendingUpdate = newState);
        queue.baseState = lastPendingUpdate;
        queue.firstBaseUpdate = firstPendingUpdate;
        queue.lastBaseUpdate = current2;
        firstBaseUpdate === null && (queue.shared.lanes = 0);
        workInProgressRootSkippedLanes |= lastBaseUpdate;
        workInProgress2.lanes = lastBaseUpdate;
        workInProgress2.memoizedState = newState;
      }
      currentlyProcessingQueue = null;
    }
    function callCallback(callback, context) {
      if (typeof callback !== "function")
        throw Error("Invalid argument passed as callback. Expected a function. Instead received: " + callback);
      callback.call(context);
    }
    function commitHiddenCallbacks(updateQueue, context) {
      var hiddenCallbacks = updateQueue.shared.hiddenCallbacks;
      if (hiddenCallbacks !== null)
        for (updateQueue.shared.hiddenCallbacks = null, updateQueue = 0;updateQueue < hiddenCallbacks.length; updateQueue++)
          callCallback(hiddenCallbacks[updateQueue], context);
    }
    function commitCallbacks(updateQueue, context) {
      var callbacks = updateQueue.callbacks;
      if (callbacks !== null)
        for (updateQueue.callbacks = null, updateQueue = 0;updateQueue < callbacks.length; updateQueue++)
          callCallback(callbacks[updateQueue], context);
    }
    function pushHiddenContext(fiber, context) {
      var prevEntangledRenderLanes = entangledRenderLanes;
      push(prevEntangledRenderLanesCursor, prevEntangledRenderLanes, fiber);
      push(currentTreeHiddenStackCursor, context, fiber);
      entangledRenderLanes = prevEntangledRenderLanes | context.baseLanes;
    }
    function reuseHiddenContextOnStack(fiber) {
      push(prevEntangledRenderLanesCursor, entangledRenderLanes, fiber);
      push(currentTreeHiddenStackCursor, currentTreeHiddenStackCursor.current, fiber);
    }
    function popHiddenContext(fiber) {
      entangledRenderLanes = prevEntangledRenderLanesCursor.current;
      pop(currentTreeHiddenStackCursor, fiber);
      pop(prevEntangledRenderLanesCursor, fiber);
    }
    function pushPrimaryTreeSuspenseHandler(handler) {
      var current2 = handler.alternate;
      push(suspenseStackCursor, suspenseStackCursor.current & SubtreeSuspenseContextMask, handler);
      push(suspenseHandlerStackCursor, handler, handler);
      shellBoundary === null && (current2 === null || currentTreeHiddenStackCursor.current !== null ? shellBoundary = handler : current2.memoizedState !== null && (shellBoundary = handler));
    }
    function pushDehydratedActivitySuspenseHandler(fiber) {
      push(suspenseStackCursor, suspenseStackCursor.current, fiber);
      push(suspenseHandlerStackCursor, fiber, fiber);
      shellBoundary === null && (shellBoundary = fiber);
    }
    function pushOffscreenSuspenseHandler(fiber) {
      fiber.tag === 22 ? (push(suspenseStackCursor, suspenseStackCursor.current, fiber), push(suspenseHandlerStackCursor, fiber, fiber), shellBoundary === null && (shellBoundary = fiber)) : reuseSuspenseHandlerOnStack(fiber);
    }
    function reuseSuspenseHandlerOnStack(fiber) {
      push(suspenseStackCursor, suspenseStackCursor.current, fiber);
      push(suspenseHandlerStackCursor, suspenseHandlerStackCursor.current, fiber);
    }
    function popSuspenseHandler(fiber) {
      pop(suspenseHandlerStackCursor, fiber);
      shellBoundary === fiber && (shellBoundary = null);
      pop(suspenseStackCursor, fiber);
    }
    function findFirstSuspended(row) {
      for (var node = row;node !== null; ) {
        if (node.tag === 13) {
          var state = node.memoizedState;
          if (state !== null && (state = state.dehydrated, state === null || isSuspenseInstancePending(state) || isSuspenseInstanceFallback(state)))
            return node;
        } else if (node.tag === 19 && (node.memoizedProps.revealOrder === "forwards" || node.memoizedProps.revealOrder === "backwards" || node.memoizedProps.revealOrder === "unstable_legacy-backwards" || node.memoizedProps.revealOrder === "together")) {
          if ((node.flags & 128) !== 0)
            return node;
        } else if (node.child !== null) {
          node.child.return = node;
          node = node.child;
          continue;
        }
        if (node === row)
          break;
        for (;node.sibling === null; ) {
          if (node.return === null || node.return === row)
            return null;
          node = node.return;
        }
        node.sibling.return = node.return;
        node = node.sibling;
      }
      return null;
    }
    function mountHookTypesDev() {
      var hookName = currentHookNameInDev;
      hookTypesDev === null ? hookTypesDev = [hookName] : hookTypesDev.push(hookName);
    }
    function updateHookTypesDev() {
      var hookName = currentHookNameInDev;
      if (hookTypesDev !== null && (hookTypesUpdateIndexDev++, hookTypesDev[hookTypesUpdateIndexDev] !== hookName)) {
        var componentName2 = getComponentNameFromFiber(currentlyRenderingFiber);
        if (!didWarnAboutMismatchedHooksForComponent.has(componentName2) && (didWarnAboutMismatchedHooksForComponent.add(componentName2), hookTypesDev !== null)) {
          for (var table = "", i = 0;i <= hookTypesUpdateIndexDev; i++) {
            var oldHookName = hookTypesDev[i], newHookName = i === hookTypesUpdateIndexDev ? hookName : oldHookName;
            for (oldHookName = i + 1 + ". " + oldHookName;30 > oldHookName.length; )
              oldHookName += " ";
            oldHookName += newHookName + `
`;
            table += oldHookName;
          }
          console.error(`React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://react.dev/link/rules-of-hooks

   Previous render            Next render
   ------------------------------------------------------
%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
`, componentName2, table);
        }
      }
    }
    function checkDepsAreArrayDev(deps) {
      deps === undefined || deps === null || isArrayImpl(deps) || console.error("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", currentHookNameInDev, typeof deps);
    }
    function warnOnUseFormStateInDev() {
      var componentName2 = getComponentNameFromFiber(currentlyRenderingFiber);
      didWarnAboutUseFormState.has(componentName2) || (didWarnAboutUseFormState.add(componentName2), console.error("ReactDOM.useFormState has been renamed to React.useActionState. Please update %s to use React.useActionState.", componentName2));
    }
    function throwInvalidHookError() {
      throw Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.`);
    }
    function areHookInputsEqual(nextDeps, prevDeps) {
      if (ignorePreviousDependencies)
        return false;
      if (prevDeps === null)
        return console.error("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", currentHookNameInDev), false;
      nextDeps.length !== prevDeps.length && console.error(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, currentHookNameInDev, "[" + prevDeps.join(", ") + "]", "[" + nextDeps.join(", ") + "]");
      for (var i = 0;i < prevDeps.length && i < nextDeps.length; i++)
        if (!objectIs(nextDeps[i], prevDeps[i]))
          return false;
      return true;
    }
    function renderWithHooks(current2, workInProgress2, Component, props, secondArg, nextRenderLanes) {
      renderLanes = nextRenderLanes;
      currentlyRenderingFiber = workInProgress2;
      hookTypesDev = current2 !== null ? current2._debugHookTypes : null;
      hookTypesUpdateIndexDev = -1;
      ignorePreviousDependencies = current2 !== null && current2.type !== workInProgress2.type;
      if (Object.prototype.toString.call(Component) === "[object AsyncFunction]" || Object.prototype.toString.call(Component) === "[object AsyncGeneratorFunction]")
        nextRenderLanes = getComponentNameFromFiber(currentlyRenderingFiber), didWarnAboutAsyncClientComponent.has(nextRenderLanes) || (didWarnAboutAsyncClientComponent.add(nextRenderLanes), console.error("%s is an async Client Component. Only Server Components can be async at the moment. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server.", nextRenderLanes === null ? "An unknown Component" : "<" + nextRenderLanes + ">"));
      workInProgress2.memoizedState = null;
      workInProgress2.updateQueue = null;
      workInProgress2.lanes = 0;
      ReactSharedInternals.H = current2 !== null && current2.memoizedState !== null ? HooksDispatcherOnUpdateInDEV : hookTypesDev !== null ? HooksDispatcherOnMountWithHookTypesInDEV : HooksDispatcherOnMountInDEV;
      shouldDoubleInvokeUserFnsInHooksDEV = nextRenderLanes = (workInProgress2.mode & StrictLegacyMode) !== NoMode;
      var children = callComponentInDEV(Component, props, secondArg);
      shouldDoubleInvokeUserFnsInHooksDEV = false;
      didScheduleRenderPhaseUpdateDuringThisPass && (children = renderWithHooksAgain(workInProgress2, Component, props, secondArg));
      if (nextRenderLanes) {
        setIsStrictModeForDevtools(true);
        try {
          children = renderWithHooksAgain(workInProgress2, Component, props, secondArg);
        } finally {
          setIsStrictModeForDevtools(false);
        }
      }
      finishRenderingHooks(current2, workInProgress2);
      return children;
    }
    function finishRenderingHooks(current2, workInProgress2) {
      workInProgress2._debugHookTypes = hookTypesDev;
      workInProgress2.dependencies === null ? thenableState !== null && (workInProgress2.dependencies = {
        lanes: 0,
        firstContext: null,
        _debugThenableState: thenableState
      }) : workInProgress2.dependencies._debugThenableState = thenableState;
      ReactSharedInternals.H = ContextOnlyDispatcher;
      var didRenderTooFewHooks = currentHook !== null && currentHook.next !== null;
      renderLanes = 0;
      hookTypesDev = currentHookNameInDev = workInProgressHook = currentHook = currentlyRenderingFiber = null;
      hookTypesUpdateIndexDev = -1;
      current2 !== null && (current2.flags & 65011712) !== (workInProgress2.flags & 65011712) && console.error("Internal React error: Expected static flag was missing. Please notify the React team.");
      didScheduleRenderPhaseUpdate = false;
      thenableIndexCounter = 0;
      thenableState = null;
      if (didRenderTooFewHooks)
        throw Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
      current2 === null || didReceiveUpdate || (current2 = current2.dependencies, current2 !== null && checkIfContextChanged(current2) && (didReceiveUpdate = true));
      needsToResetSuspendedThenableDEV ? (needsToResetSuspendedThenableDEV = false, current2 = true) : current2 = false;
      current2 && (workInProgress2 = getComponentNameFromFiber(workInProgress2) || "Unknown", didWarnAboutUseWrappedInTryCatch.has(workInProgress2) || didWarnAboutAsyncClientComponent.has(workInProgress2) || (didWarnAboutUseWrappedInTryCatch.add(workInProgress2), console.error("`use` was called from inside a try/catch block. This is not allowed and can lead to unexpected behavior. To handle errors triggered by `use`, wrap your component in a error boundary.")));
    }
    function renderWithHooksAgain(workInProgress2, Component, props, secondArg) {
      currentlyRenderingFiber = workInProgress2;
      var numberOfReRenders = 0;
      do {
        didScheduleRenderPhaseUpdateDuringThisPass && (thenableState = null);
        thenableIndexCounter = 0;
        didScheduleRenderPhaseUpdateDuringThisPass = false;
        if (numberOfReRenders >= RE_RENDER_LIMIT)
          throw Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
        numberOfReRenders += 1;
        ignorePreviousDependencies = false;
        workInProgressHook = currentHook = null;
        if (workInProgress2.updateQueue != null) {
          var children = workInProgress2.updateQueue;
          children.lastEffect = null;
          children.events = null;
          children.stores = null;
          children.memoCache != null && (children.memoCache.index = 0);
        }
        hookTypesUpdateIndexDev = -1;
        ReactSharedInternals.H = HooksDispatcherOnRerenderInDEV;
        children = callComponentInDEV(Component, props, secondArg);
      } while (didScheduleRenderPhaseUpdateDuringThisPass);
      return children;
    }
    function TransitionAwareHostComponent() {
      var dispatcher = ReactSharedInternals.H, maybeThenable = dispatcher.useState()[0];
      maybeThenable = typeof maybeThenable.then === "function" ? useThenable(maybeThenable) : maybeThenable;
      dispatcher = dispatcher.useState()[0];
      (currentHook !== null ? currentHook.memoizedState : null) !== dispatcher && (currentlyRenderingFiber.flags |= 1024);
      return maybeThenable;
    }
    function checkDidRenderIdHook() {
      var didRenderIdHook = localIdCounter !== 0;
      localIdCounter = 0;
      return didRenderIdHook;
    }
    function bailoutHooks(current2, workInProgress2, lanes) {
      workInProgress2.updateQueue = current2.updateQueue;
      workInProgress2.flags = (workInProgress2.mode & StrictEffectsMode) !== NoMode ? workInProgress2.flags & -402655237 : workInProgress2.flags & -2053;
      current2.lanes &= ~lanes;
    }
    function resetHooksOnUnwind(workInProgress2) {
      if (didScheduleRenderPhaseUpdate) {
        for (workInProgress2 = workInProgress2.memoizedState;workInProgress2 !== null; ) {
          var queue = workInProgress2.queue;
          queue !== null && (queue.pending = null);
          workInProgress2 = workInProgress2.next;
        }
        didScheduleRenderPhaseUpdate = false;
      }
      renderLanes = 0;
      hookTypesDev = workInProgressHook = currentHook = currentlyRenderingFiber = null;
      hookTypesUpdateIndexDev = -1;
      currentHookNameInDev = null;
      didScheduleRenderPhaseUpdateDuringThisPass = false;
      thenableIndexCounter = localIdCounter = 0;
      thenableState = null;
    }
    function mountWorkInProgressHook() {
      var hook = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
      };
      workInProgressHook === null ? currentlyRenderingFiber.memoizedState = workInProgressHook = hook : workInProgressHook = workInProgressHook.next = hook;
      return workInProgressHook;
    }
    function updateWorkInProgressHook() {
      if (currentHook === null) {
        var nextCurrentHook = currentlyRenderingFiber.alternate;
        nextCurrentHook = nextCurrentHook !== null ? nextCurrentHook.memoizedState : null;
      } else
        nextCurrentHook = currentHook.next;
      var nextWorkInProgressHook = workInProgressHook === null ? currentlyRenderingFiber.memoizedState : workInProgressHook.next;
      if (nextWorkInProgressHook !== null)
        workInProgressHook = nextWorkInProgressHook, currentHook = nextCurrentHook;
      else {
        if (nextCurrentHook === null) {
          if (currentlyRenderingFiber.alternate === null)
            throw Error("Update hook called on initial render. This is likely a bug in React. Please file an issue.");
          throw Error("Rendered more hooks than during the previous render.");
        }
        currentHook = nextCurrentHook;
        nextCurrentHook = {
          memoizedState: currentHook.memoizedState,
          baseState: currentHook.baseState,
          baseQueue: currentHook.baseQueue,
          queue: currentHook.queue,
          next: null
        };
        workInProgressHook === null ? currentlyRenderingFiber.memoizedState = workInProgressHook = nextCurrentHook : workInProgressHook = workInProgressHook.next = nextCurrentHook;
      }
      return workInProgressHook;
    }
    function createFunctionComponentUpdateQueue() {
      return { lastEffect: null, events: null, stores: null, memoCache: null };
    }
    function useThenable(thenable) {
      var index = thenableIndexCounter;
      thenableIndexCounter += 1;
      thenableState === null && (thenableState = createThenableState());
      thenable = trackUsedThenable(thenableState, thenable, index);
      index = currentlyRenderingFiber;
      (workInProgressHook === null ? index.memoizedState : workInProgressHook.next) === null && (index = index.alternate, ReactSharedInternals.H = index !== null && index.memoizedState !== null ? HooksDispatcherOnUpdateInDEV : HooksDispatcherOnMountInDEV);
      return thenable;
    }
    function use(usable) {
      if (usable !== null && typeof usable === "object") {
        if (typeof usable.then === "function")
          return useThenable(usable);
        if (usable.$$typeof === REACT_CONTEXT_TYPE)
          return readContext(usable);
      }
      throw Error("An unsupported type was passed to use(): " + String(usable));
    }
    function useMemoCache(size) {
      var memoCache = null, updateQueue = currentlyRenderingFiber.updateQueue;
      updateQueue !== null && (memoCache = updateQueue.memoCache);
      if (memoCache == null) {
        var current2 = currentlyRenderingFiber.alternate;
        current2 !== null && (current2 = current2.updateQueue, current2 !== null && (current2 = current2.memoCache, current2 != null && (memoCache = {
          data: current2.data.map(function(array) {
            return array.slice();
          }),
          index: 0
        })));
      }
      memoCache == null && (memoCache = { data: [], index: 0 });
      updateQueue === null && (updateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = updateQueue);
      updateQueue.memoCache = memoCache;
      updateQueue = memoCache.data[memoCache.index];
      if (updateQueue === undefined || ignorePreviousDependencies)
        for (updateQueue = memoCache.data[memoCache.index] = Array(size), current2 = 0;current2 < size; current2++)
          updateQueue[current2] = REACT_MEMO_CACHE_SENTINEL;
      else
        updateQueue.length !== size && console.error("Expected a constant size argument for each invocation of useMemoCache. The previous cache was allocated with size %s but size %s was requested.", updateQueue.length, size);
      memoCache.index++;
      return updateQueue;
    }
    function basicStateReducer(state, action) {
      return typeof action === "function" ? action(state) : action;
    }
    function mountReducer(reducer, initialArg, init2) {
      var hook = mountWorkInProgressHook();
      if (init2 !== undefined) {
        var initialState = init2(initialArg);
        if (shouldDoubleInvokeUserFnsInHooksDEV) {
          setIsStrictModeForDevtools(true);
          try {
            init2(initialArg);
          } finally {
            setIsStrictModeForDevtools(false);
          }
        }
      } else
        initialState = initialArg;
      hook.memoizedState = hook.baseState = initialState;
      reducer = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: reducer,
        lastRenderedState: initialState
      };
      hook.queue = reducer;
      reducer = reducer.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber, reducer);
      return [hook.memoizedState, reducer];
    }
    function updateReducer(reducer) {
      var hook = updateWorkInProgressHook();
      return updateReducerImpl(hook, currentHook, reducer);
    }
    function updateReducerImpl(hook, current2, reducer) {
      var queue = hook.queue;
      if (queue === null)
        throw Error("Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)");
      queue.lastRenderedReducer = reducer;
      var baseQueue = hook.baseQueue, pendingQueue = queue.pending;
      if (pendingQueue !== null) {
        if (baseQueue !== null) {
          var baseFirst = baseQueue.next;
          baseQueue.next = pendingQueue.next;
          pendingQueue.next = baseFirst;
        }
        current2.baseQueue !== baseQueue && console.error("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React.");
        current2.baseQueue = baseQueue = pendingQueue;
        queue.pending = null;
      }
      pendingQueue = hook.baseState;
      if (baseQueue === null)
        hook.memoizedState = pendingQueue;
      else {
        current2 = baseQueue.next;
        var newBaseQueueFirst = baseFirst = null, newBaseQueueLast = null, update = current2, didReadFromEntangledAsyncAction2 = false;
        do {
          var updateLane = update.lane & -536870913;
          if (updateLane !== update.lane ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes & updateLane) === updateLane) {
            var revertLane = update.revertLane;
            if (revertLane === 0)
              newBaseQueueLast !== null && (newBaseQueueLast = newBaseQueueLast.next = {
                lane: 0,
                revertLane: 0,
                gesture: null,
                action: update.action,
                hasEagerState: update.hasEagerState,
                eagerState: update.eagerState,
                next: null
              }), updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction2 = true);
            else if ((renderLanes & revertLane) === revertLane) {
              update = update.next;
              revertLane === currentEntangledLane && (didReadFromEntangledAsyncAction2 = true);
              continue;
            } else
              updateLane = {
                lane: 0,
                revertLane: update.revertLane,
                gesture: null,
                action: update.action,
                hasEagerState: update.hasEagerState,
                eagerState: update.eagerState,
                next: null
              }, newBaseQueueLast === null ? (newBaseQueueFirst = newBaseQueueLast = updateLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = updateLane, currentlyRenderingFiber.lanes |= revertLane, workInProgressRootSkippedLanes |= revertLane;
            updateLane = update.action;
            shouldDoubleInvokeUserFnsInHooksDEV && reducer(pendingQueue, updateLane);
            pendingQueue = update.hasEagerState ? update.eagerState : reducer(pendingQueue, updateLane);
          } else
            revertLane = {
              lane: updateLane,
              revertLane: update.revertLane,
              gesture: update.gesture,
              action: update.action,
              hasEagerState: update.hasEagerState,
              eagerState: update.eagerState,
              next: null
            }, newBaseQueueLast === null ? (newBaseQueueFirst = newBaseQueueLast = revertLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = revertLane, currentlyRenderingFiber.lanes |= updateLane, workInProgressRootSkippedLanes |= updateLane;
          update = update.next;
        } while (update !== null && update !== current2);
        newBaseQueueLast === null ? baseFirst = pendingQueue : newBaseQueueLast.next = newBaseQueueFirst;
        if (!objectIs(pendingQueue, hook.memoizedState) && (didReceiveUpdate = true, didReadFromEntangledAsyncAction2 && (reducer = currentEntangledActionThenable, reducer !== null)))
          throw reducer;
        hook.memoizedState = pendingQueue;
        hook.baseState = baseFirst;
        hook.baseQueue = newBaseQueueLast;
        queue.lastRenderedState = pendingQueue;
      }
      baseQueue === null && (queue.lanes = 0);
      return [hook.memoizedState, queue.dispatch];
    }
    function rerenderReducer(reducer) {
      var hook = updateWorkInProgressHook(), queue = hook.queue;
      if (queue === null)
        throw Error("Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)");
      queue.lastRenderedReducer = reducer;
      var { dispatch, pending: lastRenderPhaseUpdate } = queue, newState = hook.memoizedState;
      if (lastRenderPhaseUpdate !== null) {
        queue.pending = null;
        var update = lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
        do
          newState = reducer(newState, update.action), update = update.next;
        while (update !== lastRenderPhaseUpdate);
        objectIs(newState, hook.memoizedState) || (didReceiveUpdate = true);
        hook.memoizedState = newState;
        hook.baseQueue === null && (hook.baseState = newState);
        queue.lastRenderedState = newState;
      }
      return [newState, dispatch];
    }
    function mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
      var fiber = currentlyRenderingFiber, hook = mountWorkInProgressHook();
      if (isHydrating) {
        if (getServerSnapshot === undefined)
          throw Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
        var nextSnapshot = getServerSnapshot();
        didWarnUncachedGetSnapshot || nextSnapshot === getServerSnapshot() || (console.error("The result of getServerSnapshot should be cached to avoid an infinite loop"), didWarnUncachedGetSnapshot = true);
      } else {
        nextSnapshot = getSnapshot();
        didWarnUncachedGetSnapshot || (getServerSnapshot = getSnapshot(), objectIs(nextSnapshot, getServerSnapshot) || (console.error("The result of getSnapshot should be cached to avoid an infinite loop"), didWarnUncachedGetSnapshot = true));
        if (workInProgressRoot === null)
          throw Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        (workInProgressRootRenderLanes & 127) !== 0 || pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);
      }
      hook.memoizedState = nextSnapshot;
      getServerSnapshot = { value: nextSnapshot, getSnapshot };
      hook.queue = getServerSnapshot;
      mountEffect(subscribeToStore.bind(null, fiber, getServerSnapshot, subscribe), [subscribe]);
      fiber.flags |= 2048;
      pushSimpleEffect(HasEffect | Passive, { destroy: undefined }, updateStoreInstance.bind(null, fiber, getServerSnapshot, nextSnapshot, getSnapshot), null);
      return nextSnapshot;
    }
    function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
      var fiber = currentlyRenderingFiber, hook = updateWorkInProgressHook(), isHydrating$jscomp$0 = isHydrating;
      if (isHydrating$jscomp$0) {
        if (getServerSnapshot === undefined)
          throw Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
        getServerSnapshot = getServerSnapshot();
      } else if (getServerSnapshot = getSnapshot(), !didWarnUncachedGetSnapshot) {
        var cachedSnapshot = getSnapshot();
        objectIs(getServerSnapshot, cachedSnapshot) || (console.error("The result of getSnapshot should be cached to avoid an infinite loop"), didWarnUncachedGetSnapshot = true);
      }
      if (cachedSnapshot = !objectIs((currentHook || hook).memoizedState, getServerSnapshot))
        hook.memoizedState = getServerSnapshot, didReceiveUpdate = true;
      hook = hook.queue;
      var create = subscribeToStore.bind(null, fiber, hook, subscribe);
      updateEffectImpl(2048, Passive, create, [subscribe]);
      if (hook.getSnapshot !== getSnapshot || cachedSnapshot || workInProgressHook !== null && workInProgressHook.memoizedState.tag & HasEffect) {
        fiber.flags |= 2048;
        pushSimpleEffect(HasEffect | Passive, { destroy: undefined }, updateStoreInstance.bind(null, fiber, hook, getServerSnapshot, getSnapshot), null);
        if (workInProgressRoot === null)
          throw Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        isHydrating$jscomp$0 || (renderLanes & 127) !== 0 || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
      }
      return getServerSnapshot;
    }
    function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
      fiber.flags |= 16384;
      fiber = { getSnapshot, value: renderedSnapshot };
      getSnapshot = currentlyRenderingFiber.updateQueue;
      getSnapshot === null ? (getSnapshot = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = getSnapshot, getSnapshot.stores = [fiber]) : (renderedSnapshot = getSnapshot.stores, renderedSnapshot === null ? getSnapshot.stores = [fiber] : renderedSnapshot.push(fiber));
    }
    function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
      inst.value = nextSnapshot;
      inst.getSnapshot = getSnapshot;
      checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
    }
    function subscribeToStore(fiber, inst, subscribe) {
      return subscribe(function() {
        checkIfSnapshotChanged(inst) && (startUpdateTimerByLane(2, "updateSyncExternalStore()", fiber), forceStoreRerender(fiber));
      });
    }
    function checkIfSnapshotChanged(inst) {
      var latestGetSnapshot = inst.getSnapshot;
      inst = inst.value;
      try {
        var nextValue = latestGetSnapshot();
        return !objectIs(inst, nextValue);
      } catch (error) {
        return true;
      }
    }
    function forceStoreRerender(fiber) {
      var root2 = enqueueConcurrentRenderForLane(fiber, 2);
      root2 !== null && scheduleUpdateOnFiber(root2, fiber, 2);
    }
    function mountStateImpl(initialState) {
      var hook = mountWorkInProgressHook();
      if (typeof initialState === "function") {
        var initialStateInitializer = initialState;
        initialState = initialStateInitializer();
        if (shouldDoubleInvokeUserFnsInHooksDEV) {
          setIsStrictModeForDevtools(true);
          try {
            initialStateInitializer();
          } finally {
            setIsStrictModeForDevtools(false);
          }
        }
      }
      hook.memoizedState = hook.baseState = initialState;
      hook.queue = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: basicStateReducer,
        lastRenderedState: initialState
      };
      return hook;
    }
    function mountState(initialState) {
      initialState = mountStateImpl(initialState);
      var queue = initialState.queue, dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue);
      queue.dispatch = dispatch;
      return [initialState.memoizedState, dispatch];
    }
    function mountOptimistic(passthrough) {
      var hook = mountWorkInProgressHook();
      hook.memoizedState = hook.baseState = passthrough;
      var queue = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: null,
        lastRenderedState: null
      };
      hook.queue = queue;
      hook = dispatchOptimisticSetState.bind(null, currentlyRenderingFiber, true, queue);
      queue.dispatch = hook;
      return [passthrough, hook];
    }
    function updateOptimistic(passthrough, reducer) {
      var hook = updateWorkInProgressHook();
      return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
    }
    function updateOptimisticImpl(hook, current2, passthrough, reducer) {
      hook.baseState = passthrough;
      return updateReducerImpl(hook, currentHook, typeof reducer === "function" ? reducer : basicStateReducer);
    }
    function rerenderOptimistic(passthrough, reducer) {
      var hook = updateWorkInProgressHook();
      if (currentHook !== null)
        return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
      hook.baseState = passthrough;
      return [passthrough, hook.queue.dispatch];
    }
    function dispatchActionState(fiber, actionQueue, setPendingState, setState, payload) {
      if (isRenderPhaseUpdate(fiber))
        throw Error("Cannot update form state while rendering.");
      fiber = actionQueue.action;
      if (fiber !== null) {
        var actionNode = {
          payload,
          action: fiber,
          next: null,
          isTransition: true,
          status: "pending",
          value: null,
          reason: null,
          listeners: [],
          then: function(listener) {
            actionNode.listeners.push(listener);
          }
        };
        ReactSharedInternals.T !== null ? setPendingState(true) : actionNode.isTransition = false;
        setState(actionNode);
        setPendingState = actionQueue.pending;
        setPendingState === null ? (actionNode.next = actionQueue.pending = actionNode, runActionStateAction(actionQueue, actionNode)) : (actionNode.next = setPendingState.next, actionQueue.pending = setPendingState.next = actionNode);
      }
    }
    function runActionStateAction(actionQueue, node) {
      var { action, payload } = node, prevState = actionQueue.state;
      if (node.isTransition) {
        var prevTransition = ReactSharedInternals.T, currentTransition = {};
        currentTransition._updatedFibers = new Set;
        ReactSharedInternals.T = currentTransition;
        try {
          var returnValue = action(prevState, payload), onStartTransitionFinish = ReactSharedInternals.S;
          onStartTransitionFinish !== null && onStartTransitionFinish(currentTransition, returnValue);
          handleActionReturnValue(actionQueue, node, returnValue);
        } catch (error) {
          onActionError(actionQueue, node, error);
        } finally {
          prevTransition !== null && currentTransition.types !== null && (prevTransition.types !== null && prevTransition.types !== currentTransition.types && console.error("We expected inner Transitions to have transferred the outer types set and that you cannot add to the outer Transition while inside the inner.This is a bug in React."), prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition, prevTransition === null && currentTransition._updatedFibers && (actionQueue = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < actionQueue && console.warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."));
        }
      } else
        try {
          currentTransition = action(prevState, payload), handleActionReturnValue(actionQueue, node, currentTransition);
        } catch (error$4) {
          onActionError(actionQueue, node, error$4);
        }
    }
    function handleActionReturnValue(actionQueue, node, returnValue) {
      returnValue !== null && typeof returnValue === "object" && typeof returnValue.then === "function" ? (ReactSharedInternals.asyncTransitions++, returnValue.then(releaseAsyncTransition, releaseAsyncTransition), returnValue.then(function(nextState) {
        onActionSuccess(actionQueue, node, nextState);
      }, function(error) {
        return onActionError(actionQueue, node, error);
      }), node.isTransition || console.error("An async function with useActionState was called outside of a transition. This is likely not what you intended (for example, isPending will not update correctly). Either call the returned function inside startTransition, or pass it to an `action` or `formAction` prop.")) : onActionSuccess(actionQueue, node, returnValue);
    }
    function onActionSuccess(actionQueue, actionNode, nextState) {
      actionNode.status = "fulfilled";
      actionNode.value = nextState;
      notifyActionListeners(actionNode);
      actionQueue.state = nextState;
      actionNode = actionQueue.pending;
      actionNode !== null && (nextState = actionNode.next, nextState === actionNode ? actionQueue.pending = null : (nextState = nextState.next, actionNode.next = nextState, runActionStateAction(actionQueue, nextState)));
    }
    function onActionError(actionQueue, actionNode, error) {
      var last = actionQueue.pending;
      actionQueue.pending = null;
      if (last !== null) {
        last = last.next;
        do
          actionNode.status = "rejected", actionNode.reason = error, notifyActionListeners(actionNode), actionNode = actionNode.next;
        while (actionNode !== last);
      }
      actionQueue.action = null;
    }
    function notifyActionListeners(actionNode) {
      actionNode = actionNode.listeners;
      for (var i = 0;i < actionNode.length; i++)
        (0, actionNode[i])();
    }
    function actionStateReducer(oldState, newState) {
      return newState;
    }
    function mountActionState(action, initialStateProp) {
      if (isHydrating) {
        var ssrFormState = workInProgressRoot.formState;
        if (ssrFormState !== null) {
          a: {
            var isMatching = currentlyRenderingFiber;
            if (isHydrating) {
              if (nextHydratableInstance) {
                b: {
                  var markerInstance = nextHydratableInstance;
                  for (var inRootOrSingleton = rootOrSingletonContext;markerInstance.nodeType !== 8; ) {
                    if (!inRootOrSingleton) {
                      markerInstance = null;
                      break b;
                    }
                    markerInstance = getNextHydratable(markerInstance.nextSibling);
                    if (markerInstance === null) {
                      markerInstance = null;
                      break b;
                    }
                  }
                  inRootOrSingleton = markerInstance.data;
                  markerInstance = inRootOrSingleton === FORM_STATE_IS_MATCHING || inRootOrSingleton === FORM_STATE_IS_NOT_MATCHING ? markerInstance : null;
                }
                if (markerInstance) {
                  nextHydratableInstance = getNextHydratable(markerInstance.nextSibling);
                  isMatching = markerInstance.data === FORM_STATE_IS_MATCHING;
                  break a;
                }
              }
              throwOnHydrationMismatch(isMatching);
            }
            isMatching = false;
          }
          isMatching && (initialStateProp = ssrFormState[0]);
        }
      }
      ssrFormState = mountWorkInProgressHook();
      ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;
      isMatching = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: actionStateReducer,
        lastRenderedState: initialStateProp
      };
      ssrFormState.queue = isMatching;
      ssrFormState = dispatchSetState.bind(null, currentlyRenderingFiber, isMatching);
      isMatching.dispatch = ssrFormState;
      isMatching = mountStateImpl(false);
      inRootOrSingleton = dispatchOptimisticSetState.bind(null, currentlyRenderingFiber, false, isMatching.queue);
      isMatching = mountWorkInProgressHook();
      markerInstance = {
        state: initialStateProp,
        dispatch: null,
        action,
        pending: null
      };
      isMatching.queue = markerInstance;
      ssrFormState = dispatchActionState.bind(null, currentlyRenderingFiber, markerInstance, inRootOrSingleton, ssrFormState);
      markerInstance.dispatch = ssrFormState;
      isMatching.memoizedState = action;
      return [initialStateProp, ssrFormState, false];
    }
    function updateActionState(action) {
      var stateHook = updateWorkInProgressHook();
      return updateActionStateImpl(stateHook, currentHook, action);
    }
    function updateActionStateImpl(stateHook, currentStateHook, action) {
      currentStateHook = updateReducerImpl(stateHook, currentStateHook, actionStateReducer)[0];
      stateHook = updateReducer(basicStateReducer)[0];
      if (typeof currentStateHook === "object" && currentStateHook !== null && typeof currentStateHook.then === "function")
        try {
          var state = useThenable(currentStateHook);
        } catch (x) {
          if (x === SuspenseException)
            throw SuspenseActionException;
          throw x;
        }
      else
        state = currentStateHook;
      currentStateHook = updateWorkInProgressHook();
      var actionQueue = currentStateHook.queue, dispatch = actionQueue.dispatch;
      action !== currentStateHook.memoizedState && (currentlyRenderingFiber.flags |= 2048, pushSimpleEffect(HasEffect | Passive, { destroy: undefined }, actionStateActionEffect.bind(null, actionQueue, action), null));
      return [state, dispatch, stateHook];
    }
    function actionStateActionEffect(actionQueue, action) {
      actionQueue.action = action;
    }
    function rerenderActionState(action) {
      var stateHook = updateWorkInProgressHook(), currentStateHook = currentHook;
      if (currentStateHook !== null)
        return updateActionStateImpl(stateHook, currentStateHook, action);
      updateWorkInProgressHook();
      stateHook = stateHook.memoizedState;
      currentStateHook = updateWorkInProgressHook();
      var dispatch = currentStateHook.queue.dispatch;
      currentStateHook.memoizedState = action;
      return [stateHook, dispatch, false];
    }
    function pushSimpleEffect(tag, inst, create, deps) {
      tag = { tag, create, deps, inst, next: null };
      inst = currentlyRenderingFiber.updateQueue;
      inst === null && (inst = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = inst);
      create = inst.lastEffect;
      create === null ? inst.lastEffect = tag.next = tag : (deps = create.next, create.next = tag, tag.next = deps, inst.lastEffect = tag);
      return tag;
    }
    function mountRef(initialValue) {
      var hook = mountWorkInProgressHook();
      initialValue = { current: initialValue };
      return hook.memoizedState = initialValue;
    }
    function mountEffectImpl(fiberFlags, hookFlags, create, deps) {
      var hook = mountWorkInProgressHook();
      currentlyRenderingFiber.flags |= fiberFlags;
      hook.memoizedState = pushSimpleEffect(HasEffect | hookFlags, { destroy: undefined }, create, deps === undefined ? null : deps);
    }
    function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
      var hook = updateWorkInProgressHook();
      deps = deps === undefined ? null : deps;
      var inst = hook.memoizedState.inst;
      currentHook !== null && deps !== null && areHookInputsEqual(deps, currentHook.memoizedState.deps) ? hook.memoizedState = pushSimpleEffect(hookFlags, inst, create, deps) : (currentlyRenderingFiber.flags |= fiberFlags, hook.memoizedState = pushSimpleEffect(HasEffect | hookFlags, inst, create, deps));
    }
    function mountEffect(create, deps) {
      (currentlyRenderingFiber.mode & StrictEffectsMode) !== NoMode ? mountEffectImpl(276826112, Passive, create, deps) : mountEffectImpl(8390656, Passive, create, deps);
    }
    function useEffectEventImpl(payload) {
      currentlyRenderingFiber.flags |= 4;
      var componentUpdateQueue = currentlyRenderingFiber.updateQueue;
      if (componentUpdateQueue === null)
        componentUpdateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = componentUpdateQueue, componentUpdateQueue.events = [payload];
      else {
        var events = componentUpdateQueue.events;
        events === null ? componentUpdateQueue.events = [payload] : events.push(payload);
      }
    }
    function mountEvent(callback) {
      var hook = mountWorkInProgressHook(), ref = { impl: callback };
      hook.memoizedState = ref;
      return function() {
        if ((executionContext & RenderContext) !== NoContext)
          throw Error("A function wrapped in useEffectEvent can't be called during rendering.");
        return ref.impl.apply(undefined, arguments);
      };
    }
    function updateEvent(callback) {
      var ref = updateWorkInProgressHook().memoizedState;
      useEffectEventImpl({ ref, nextImpl: callback });
      return function() {
        if ((executionContext & RenderContext) !== NoContext)
          throw Error("A function wrapped in useEffectEvent can't be called during rendering.");
        return ref.impl.apply(undefined, arguments);
      };
    }
    function mountLayoutEffect(create, deps) {
      var fiberFlags = 4194308;
      (currentlyRenderingFiber.mode & StrictEffectsMode) !== NoMode && (fiberFlags |= 134217728);
      return mountEffectImpl(fiberFlags, Layout, create, deps);
    }
    function imperativeHandleEffect(create, ref) {
      if (typeof ref === "function") {
        create = create();
        var refCleanup = ref(create);
        return function() {
          typeof refCleanup === "function" ? refCleanup() : ref(null);
        };
      }
      if (ref !== null && ref !== undefined)
        return ref.hasOwnProperty("current") || console.error("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(ref).join(", ") + "}"), create = create(), ref.current = create, function() {
          ref.current = null;
        };
    }
    function mountImperativeHandle(ref, create, deps) {
      typeof create !== "function" && console.error("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", create !== null ? typeof create : "null");
      deps = deps !== null && deps !== undefined ? deps.concat([ref]) : null;
      var fiberFlags = 4194308;
      (currentlyRenderingFiber.mode & StrictEffectsMode) !== NoMode && (fiberFlags |= 134217728);
      mountEffectImpl(fiberFlags, Layout, imperativeHandleEffect.bind(null, create, ref), deps);
    }
    function updateImperativeHandle(ref, create, deps) {
      typeof create !== "function" && console.error("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", create !== null ? typeof create : "null");
      deps = deps !== null && deps !== undefined ? deps.concat([ref]) : null;
      updateEffectImpl(4, Layout, imperativeHandleEffect.bind(null, create, ref), deps);
    }
    function mountCallback(callback, deps) {
      mountWorkInProgressHook().memoizedState = [
        callback,
        deps === undefined ? null : deps
      ];
      return callback;
    }
    function updateCallback(callback, deps) {
      var hook = updateWorkInProgressHook();
      deps = deps === undefined ? null : deps;
      var prevState = hook.memoizedState;
      if (deps !== null && areHookInputsEqual(deps, prevState[1]))
        return prevState[0];
      hook.memoizedState = [callback, deps];
      return callback;
    }
    function mountMemo(nextCreate, deps) {
      var hook = mountWorkInProgressHook();
      deps = deps === undefined ? null : deps;
      var nextValue = nextCreate();
      if (shouldDoubleInvokeUserFnsInHooksDEV) {
        setIsStrictModeForDevtools(true);
        try {
          nextCreate();
        } finally {
          setIsStrictModeForDevtools(false);
        }
      }
      hook.memoizedState = [nextValue, deps];
      return nextValue;
    }
    function updateMemo(nextCreate, deps) {
      var hook = updateWorkInProgressHook();
      deps = deps === undefined ? null : deps;
      var prevState = hook.memoizedState;
      if (deps !== null && areHookInputsEqual(deps, prevState[1]))
        return prevState[0];
      prevState = nextCreate();
      if (shouldDoubleInvokeUserFnsInHooksDEV) {
        setIsStrictModeForDevtools(true);
        try {
          nextCreate();
        } finally {
          setIsStrictModeForDevtools(false);
        }
      }
      hook.memoizedState = [prevState, deps];
      return prevState;
    }
    function mountDeferredValue(value, initialValue) {
      var hook = mountWorkInProgressHook();
      return mountDeferredValueImpl(hook, value, initialValue);
    }
    function updateDeferredValue(value, initialValue) {
      var hook = updateWorkInProgressHook();
      return updateDeferredValueImpl(hook, currentHook.memoizedState, value, initialValue);
    }
    function rerenderDeferredValue(value, initialValue) {
      var hook = updateWorkInProgressHook();
      return currentHook === null ? mountDeferredValueImpl(hook, value, initialValue) : updateDeferredValueImpl(hook, currentHook.memoizedState, value, initialValue);
    }
    function mountDeferredValueImpl(hook, value, initialValue) {
      if (initialValue === undefined || (renderLanes & 1073741824) !== 0 && (workInProgressRootRenderLanes & 261930) === 0)
        return hook.memoizedState = value;
      hook.memoizedState = initialValue;
      hook = requestDeferredLane();
      currentlyRenderingFiber.lanes |= hook;
      workInProgressRootSkippedLanes |= hook;
      return initialValue;
    }
    function updateDeferredValueImpl(hook, prevValue, value, initialValue) {
      if (objectIs(value, prevValue))
        return value;
      if (currentTreeHiddenStackCursor.current !== null)
        return hook = mountDeferredValueImpl(hook, value, initialValue), objectIs(hook, prevValue) || (didReceiveUpdate = true), hook;
      if ((renderLanes & 42) === 0 || (renderLanes & 1073741824) !== 0 && (workInProgressRootRenderLanes & 261930) === 0)
        return didReceiveUpdate = true, hook.memoizedState = value;
      hook = requestDeferredLane();
      currentlyRenderingFiber.lanes |= hook;
      workInProgressRootSkippedLanes |= hook;
      return prevValue;
    }
    function releaseAsyncTransition() {
      ReactSharedInternals.asyncTransitions--;
    }
    function startTransition(fiber, queue, pendingState, finishedState, callback) {
      var previousPriority = ReactDOMSharedInternals.p;
      ReactDOMSharedInternals.p = previousPriority !== 0 && previousPriority < ContinuousEventPriority ? previousPriority : ContinuousEventPriority;
      var prevTransition = ReactSharedInternals.T, currentTransition = {};
      currentTransition._updatedFibers = new Set;
      ReactSharedInternals.T = currentTransition;
      dispatchOptimisticSetState(fiber, false, queue, pendingState);
      try {
        var returnValue = callback(), onStartTransitionFinish = ReactSharedInternals.S;
        onStartTransitionFinish !== null && onStartTransitionFinish(currentTransition, returnValue);
        if (returnValue !== null && typeof returnValue === "object" && typeof returnValue.then === "function") {
          ReactSharedInternals.asyncTransitions++;
          returnValue.then(releaseAsyncTransition, releaseAsyncTransition);
          var thenableForFinishedState = chainThenableValue(returnValue, finishedState);
          dispatchSetStateInternal(fiber, queue, thenableForFinishedState, requestUpdateLane(fiber));
        } else
          dispatchSetStateInternal(fiber, queue, finishedState, requestUpdateLane(fiber));
      } catch (error) {
        dispatchSetStateInternal(fiber, queue, { then: function() {}, status: "rejected", reason: error }, requestUpdateLane(fiber));
      } finally {
        ReactDOMSharedInternals.p = previousPriority, prevTransition !== null && currentTransition.types !== null && (prevTransition.types !== null && prevTransition.types !== currentTransition.types && console.error("We expected inner Transitions to have transferred the outer types set and that you cannot add to the outer Transition while inside the inner.This is a bug in React."), prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition, prevTransition === null && currentTransition._updatedFibers && (fiber = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < fiber && console.warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."));
      }
    }
    function startHostTransition(formFiber, pendingState, action, formData) {
      if (formFiber.tag !== 5)
        throw Error("Expected the form instance to be a HostComponent. This is a bug in React.");
      var queue = ensureFormComponentIsStateful(formFiber).queue;
      startHostActionTimer(formFiber);
      startTransition(formFiber, queue, pendingState, NotPendingTransition, action === null ? noop2 : function() {
        requestFormReset$1(formFiber);
        return action(formData);
      });
    }
    function ensureFormComponentIsStateful(formFiber) {
      var existingStateHook = formFiber.memoizedState;
      if (existingStateHook !== null)
        return existingStateHook;
      existingStateHook = {
        memoizedState: NotPendingTransition,
        baseState: NotPendingTransition,
        baseQueue: null,
        queue: {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: basicStateReducer,
          lastRenderedState: NotPendingTransition
        },
        next: null
      };
      var initialResetState = {};
      existingStateHook.next = {
        memoizedState: initialResetState,
        baseState: initialResetState,
        baseQueue: null,
        queue: {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: basicStateReducer,
          lastRenderedState: initialResetState
        },
        next: null
      };
      formFiber.memoizedState = existingStateHook;
      formFiber = formFiber.alternate;
      formFiber !== null && (formFiber.memoizedState = existingStateHook);
      return existingStateHook;
    }
    function requestFormReset$1(formFiber) {
      ReactSharedInternals.T === null && console.error("requestFormReset was called outside a transition or action. To fix, move to an action, or wrap with startTransition.");
      var stateHook = ensureFormComponentIsStateful(formFiber);
      stateHook.next === null && (stateHook = formFiber.alternate.memoizedState);
      dispatchSetStateInternal(formFiber, stateHook.next.queue, {}, requestUpdateLane(formFiber));
    }
    function mountTransition() {
      var stateHook = mountStateImpl(false);
      stateHook = startTransition.bind(null, currentlyRenderingFiber, stateHook.queue, true, false);
      mountWorkInProgressHook().memoizedState = stateHook;
      return [false, stateHook];
    }
    function updateTransition() {
      var booleanOrThenable = updateReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
      return [
        typeof booleanOrThenable === "boolean" ? booleanOrThenable : useThenable(booleanOrThenable),
        start
      ];
    }
    function rerenderTransition() {
      var booleanOrThenable = rerenderReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
      return [
        typeof booleanOrThenable === "boolean" ? booleanOrThenable : useThenable(booleanOrThenable),
        start
      ];
    }
    function useHostTransitionStatus() {
      return readContext(HostTransitionContext);
    }
    function mountId() {
      var hook = mountWorkInProgressHook(), identifierPrefix = workInProgressRoot.identifierPrefix;
      if (isHydrating) {
        var treeId = treeContextOverflow;
        var idWithLeadingBit = treeContextId;
        treeId = (idWithLeadingBit & ~(1 << 32 - clz32(idWithLeadingBit) - 1)).toString(32) + treeId;
        identifierPrefix = "_" + identifierPrefix + "R_" + treeId;
        treeId = localIdCounter++;
        0 < treeId && (identifierPrefix += "H" + treeId.toString(32));
        identifierPrefix += "_";
      } else
        treeId = globalClientIdCounter++, identifierPrefix = "_" + identifierPrefix + "r_" + treeId.toString(32) + "_";
      return hook.memoizedState = identifierPrefix;
    }
    function mountRefresh() {
      return mountWorkInProgressHook().memoizedState = refreshCache.bind(null, currentlyRenderingFiber);
    }
    function refreshCache(fiber, seedKey) {
      for (var provider = fiber.return;provider !== null; ) {
        switch (provider.tag) {
          case 24:
          case 3:
            var lane = requestUpdateLane(provider), refreshUpdate = createUpdate(lane), root2 = enqueueUpdate(provider, refreshUpdate, lane);
            root2 !== null && (startUpdateTimerByLane(lane, "refresh()", fiber), scheduleUpdateOnFiber(root2, provider, lane), entangleTransitions(root2, provider, lane));
            fiber = createCache();
            seedKey !== null && seedKey !== undefined && root2 !== null && console.error("The seed argument is not enabled outside experimental channels.");
            refreshUpdate.payload = { cache: fiber };
            return;
        }
        provider = provider.return;
      }
    }
    function dispatchReducerAction(fiber, queue, action) {
      var args = arguments;
      typeof args[3] === "function" && console.error("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      args = requestUpdateLane(fiber);
      var update = {
        lane: args,
        revertLane: 0,
        gesture: null,
        action,
        hasEagerState: false,
        eagerState: null,
        next: null
      };
      isRenderPhaseUpdate(fiber) ? enqueueRenderPhaseUpdate(queue, update) : (update = enqueueConcurrentHookUpdate(fiber, queue, update, args), update !== null && (startUpdateTimerByLane(args, "dispatch()", fiber), scheduleUpdateOnFiber(update, fiber, args), entangleTransitionUpdate(update, queue, args)));
    }
    function dispatchSetState(fiber, queue, action) {
      var args = arguments;
      typeof args[3] === "function" && console.error("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      args = requestUpdateLane(fiber);
      dispatchSetStateInternal(fiber, queue, action, args) && startUpdateTimerByLane(args, "setState()", fiber);
    }
    function dispatchSetStateInternal(fiber, queue, action, lane) {
      var update = {
        lane,
        revertLane: 0,
        gesture: null,
        action,
        hasEagerState: false,
        eagerState: null,
        next: null
      };
      if (isRenderPhaseUpdate(fiber))
        enqueueRenderPhaseUpdate(queue, update);
      else {
        var alternate = fiber.alternate;
        if (fiber.lanes === 0 && (alternate === null || alternate.lanes === 0) && (alternate = queue.lastRenderedReducer, alternate !== null)) {
          var prevDispatcher = ReactSharedInternals.H;
          ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
          try {
            var currentState = queue.lastRenderedState, eagerState = alternate(currentState, action);
            update.hasEagerState = true;
            update.eagerState = eagerState;
            if (objectIs(eagerState, currentState))
              return enqueueUpdate$1(fiber, queue, update, 0), workInProgressRoot === null && finishQueueingConcurrentUpdates(), false;
          } catch (error) {} finally {
            ReactSharedInternals.H = prevDispatcher;
          }
        }
        action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
        if (action !== null)
          return scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane), true;
      }
      return false;
    }
    function dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {
      ReactSharedInternals.T === null && currentEntangledLane === 0 && console.error("An optimistic state update occurred outside a transition or action. To fix, move the update to an action, or wrap with startTransition.");
      action = {
        lane: 2,
        revertLane: requestTransitionLane(),
        gesture: null,
        action,
        hasEagerState: false,
        eagerState: null,
        next: null
      };
      if (isRenderPhaseUpdate(fiber)) {
        if (throwIfDuringRender)
          throw Error("Cannot update optimistic state while rendering.");
        console.error("Cannot call startTransition while rendering.");
      } else
        throwIfDuringRender = enqueueConcurrentHookUpdate(fiber, queue, action, 2), throwIfDuringRender !== null && (startUpdateTimerByLane(2, "setOptimistic()", fiber), scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2));
    }
    function isRenderPhaseUpdate(fiber) {
      var alternate = fiber.alternate;
      return fiber === currentlyRenderingFiber || alternate !== null && alternate === currentlyRenderingFiber;
    }
    function enqueueRenderPhaseUpdate(queue, update) {
      didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
      var pending = queue.pending;
      pending === null ? update.next = update : (update.next = pending.next, pending.next = update);
      queue.pending = update;
    }
    function entangleTransitionUpdate(root2, queue, lane) {
      if ((lane & 4194048) !== 0) {
        var queueLanes = queue.lanes;
        queueLanes &= root2.pendingLanes;
        lane |= queueLanes;
        queue.lanes = lane;
        markRootEntangled(root2, lane);
      }
    }
    function warnOnInvalidCallback(callback) {
      if (callback !== null && typeof callback !== "function") {
        var key = String(callback);
        didWarnOnInvalidCallback.has(key) || (didWarnOnInvalidCallback.add(key), console.error("Expected the last optional `callback` argument to be a function. Instead received: %s.", callback));
      }
    }
    function applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, nextProps) {
      var prevState = workInProgress2.memoizedState, partialState = getDerivedStateFromProps(nextProps, prevState);
      if (workInProgress2.mode & StrictLegacyMode) {
        setIsStrictModeForDevtools(true);
        try {
          partialState = getDerivedStateFromProps(nextProps, prevState);
        } finally {
          setIsStrictModeForDevtools(false);
        }
      }
      partialState === undefined && (ctor = getComponentNameFromType(ctor) || "Component", didWarnAboutUndefinedDerivedState.has(ctor) || (didWarnAboutUndefinedDerivedState.add(ctor), console.error("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", ctor)));
      prevState = partialState === null || partialState === undefined ? prevState : assign({}, prevState, partialState);
      workInProgress2.memoizedState = prevState;
      workInProgress2.lanes === 0 && (workInProgress2.updateQueue.baseState = prevState);
    }
    function checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) {
      var instance = workInProgress2.stateNode;
      if (typeof instance.shouldComponentUpdate === "function") {
        oldProps = instance.shouldComponentUpdate(newProps, newState, nextContext);
        if (workInProgress2.mode & StrictLegacyMode) {
          setIsStrictModeForDevtools(true);
          try {
            oldProps = instance.shouldComponentUpdate(newProps, newState, nextContext);
          } finally {
            setIsStrictModeForDevtools(false);
          }
        }
        oldProps === undefined && console.error("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", getComponentNameFromType(ctor) || "Component");
        return oldProps;
      }
      return ctor.prototype && ctor.prototype.isPureReactComponent ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState) : true;
    }
    function callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext) {
      var oldState = instance.state;
      typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps(newProps, nextContext);
      typeof instance.UNSAFE_componentWillReceiveProps === "function" && instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
      instance.state !== oldState && (workInProgress2 = getComponentNameFromFiber(workInProgress2) || "Component", didWarnAboutStateAssignmentForComponent.has(workInProgress2) || (didWarnAboutStateAssignmentForComponent.add(workInProgress2), console.error("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", workInProgress2)), classComponentUpdater.enqueueReplaceState(instance, instance.state, null));
    }
    function resolveClassComponentProps(Component, baseProps) {
      var newProps = baseProps;
      if ("ref" in baseProps) {
        newProps = {};
        for (var propName in baseProps)
          propName !== "ref" && (newProps[propName] = baseProps[propName]);
      }
      if (Component = Component.defaultProps) {
        newProps === baseProps && (newProps = assign({}, newProps));
        for (var _propName in Component)
          newProps[_propName] === undefined && (newProps[_propName] = Component[_propName]);
      }
      return newProps;
    }
    function defaultOnUncaughtError(error) {
      reportGlobalError(error);
      console.warn(`%s

%s
`, componentName ? "An error occurred in the <" + componentName + "> component." : "An error occurred in one of your React components.", `Consider adding an error boundary to your tree to customize error handling behavior.
Visit https://react.dev/link/error-boundaries to learn more about error boundaries.`);
    }
    function defaultOnCaughtError(error) {
      var componentNameMessage = componentName ? "The above error occurred in the <" + componentName + "> component." : "The above error occurred in one of your React components.", recreateMessage = "React will try to recreate this component tree from scratch using the error boundary you provided, " + ((errorBoundaryName || "Anonymous") + ".");
      if (typeof error === "object" && error !== null && typeof error.environmentName === "string") {
        var JSCompiler_inline_result = error.environmentName;
        error = [
          `%o

%s

%s
`,
          error,
          componentNameMessage,
          recreateMessage
        ].slice(0);
        typeof error[0] === "string" ? error.splice(0, 1, badgeFormat + " " + error[0], badgeStyle, pad + JSCompiler_inline_result + pad, resetStyle) : error.splice(0, 0, badgeFormat, badgeStyle, pad + JSCompiler_inline_result + pad, resetStyle);
        error.unshift(console);
        JSCompiler_inline_result = bind.apply(console.error, error);
        JSCompiler_inline_result();
      } else
        console.error(`%o

%s

%s
`, error, componentNameMessage, recreateMessage);
    }
    function defaultOnRecoverableError(error) {
      reportGlobalError(error);
    }
    function logUncaughtError(root2, errorInfo) {
      try {
        componentName = errorInfo.source ? getComponentNameFromFiber(errorInfo.source) : null;
        errorBoundaryName = null;
        var error = errorInfo.value;
        if (ReactSharedInternals.actQueue !== null)
          ReactSharedInternals.thrownErrors.push(error);
        else {
          var onUncaughtError = root2.onUncaughtError;
          onUncaughtError(error, { componentStack: errorInfo.stack });
        }
      } catch (e$5) {
        setTimeout(function() {
          throw e$5;
        });
      }
    }
    function logCaughtError(root2, boundary, errorInfo) {
      try {
        componentName = errorInfo.source ? getComponentNameFromFiber(errorInfo.source) : null;
        errorBoundaryName = getComponentNameFromFiber(boundary);
        var onCaughtError = root2.onCaughtError;
        onCaughtError(errorInfo.value, {
          componentStack: errorInfo.stack,
          errorBoundary: boundary.tag === 1 ? boundary.stateNode : null
        });
      } catch (e$6) {
        setTimeout(function() {
          throw e$6;
        });
      }
    }
    function createRootErrorUpdate(root2, errorInfo, lane) {
      lane = createUpdate(lane);
      lane.tag = CaptureUpdate;
      lane.payload = { element: null };
      lane.callback = function() {
        runWithFiberInDEV(errorInfo.source, logUncaughtError, root2, errorInfo);
      };
      return lane;
    }
    function createClassErrorUpdate(lane) {
      lane = createUpdate(lane);
      lane.tag = CaptureUpdate;
      return lane;
    }
    function initializeClassErrorUpdate(update, root2, fiber, errorInfo) {
      var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
      if (typeof getDerivedStateFromError === "function") {
        var error = errorInfo.value;
        update.payload = function() {
          return getDerivedStateFromError(error);
        };
        update.callback = function() {
          markFailedErrorBoundaryForHotReloading(fiber);
          runWithFiberInDEV(errorInfo.source, logCaughtError, root2, fiber, errorInfo);
        };
      }
      var inst = fiber.stateNode;
      inst !== null && typeof inst.componentDidCatch === "function" && (update.callback = function() {
        markFailedErrorBoundaryForHotReloading(fiber);
        runWithFiberInDEV(errorInfo.source, logCaughtError, root2, fiber, errorInfo);
        typeof getDerivedStateFromError !== "function" && (legacyErrorBoundariesThatAlreadyFailed === null ? legacyErrorBoundariesThatAlreadyFailed = new Set([this]) : legacyErrorBoundariesThatAlreadyFailed.add(this));
        callComponentDidCatchInDEV(this, errorInfo);
        typeof getDerivedStateFromError === "function" || (fiber.lanes & 2) === 0 && console.error("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", getComponentNameFromFiber(fiber) || "Unknown");
      });
    }
    function throwException(root2, returnFiber, sourceFiber, value, rootRenderLanes) {
      sourceFiber.flags |= 32768;
      isDevToolsPresent && restorePendingUpdaters(root2, rootRenderLanes);
      if (value !== null && typeof value === "object" && typeof value.then === "function") {
        returnFiber = sourceFiber.alternate;
        returnFiber !== null && propagateParentContextChanges(returnFiber, sourceFiber, rootRenderLanes, true);
        isHydrating && (didSuspendOrErrorDEV = true);
        sourceFiber = suspenseHandlerStackCursor.current;
        if (sourceFiber !== null) {
          switch (sourceFiber.tag) {
            case 31:
            case 13:
              return shellBoundary === null ? renderDidSuspendDelayIfPossible() : sourceFiber.alternate === null && workInProgressRootExitStatus === RootInProgress && (workInProgressRootExitStatus = RootSuspended), sourceFiber.flags &= -257, sourceFiber.flags |= 65536, sourceFiber.lanes = rootRenderLanes, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, returnFiber === null ? sourceFiber.updateQueue = new Set([value]) : returnFiber.add(value), attachPingListener(root2, value, rootRenderLanes)), false;
            case 22:
              return sourceFiber.flags |= 65536, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, returnFiber === null ? (returnFiber = {
                transitions: null,
                markerInstances: null,
                retryQueue: new Set([value])
              }, sourceFiber.updateQueue = returnFiber) : (sourceFiber = returnFiber.retryQueue, sourceFiber === null ? returnFiber.retryQueue = new Set([value]) : sourceFiber.add(value)), attachPingListener(root2, value, rootRenderLanes)), false;
          }
          throw Error("Unexpected Suspense handler tag (" + sourceFiber.tag + "). This is a bug in React.");
        }
        attachPingListener(root2, value, rootRenderLanes);
        renderDidSuspendDelayIfPossible();
        return false;
      }
      if (isHydrating)
        return didSuspendOrErrorDEV = true, returnFiber = suspenseHandlerStackCursor.current, returnFiber !== null ? ((returnFiber.flags & 65536) === 0 && (returnFiber.flags |= 256), returnFiber.flags |= 65536, returnFiber.lanes = rootRenderLanes, value !== HydrationMismatchException && queueHydrationError(createCapturedValueAtFiber(Error("There was an error while hydrating but React was able to recover by instead client rendering from the nearest Suspense boundary.", { cause: value }), sourceFiber))) : (value !== HydrationMismatchException && queueHydrationError(createCapturedValueAtFiber(Error("There was an error while hydrating but React was able to recover by instead client rendering the entire root.", { cause: value }), sourceFiber)), root2 = root2.current.alternate, root2.flags |= 65536, rootRenderLanes &= -rootRenderLanes, root2.lanes |= rootRenderLanes, value = createCapturedValueAtFiber(value, sourceFiber), rootRenderLanes = createRootErrorUpdate(root2.stateNode, value, rootRenderLanes), enqueueCapturedUpdate(root2, rootRenderLanes), workInProgressRootExitStatus !== RootSuspendedWithDelay && (workInProgressRootExitStatus = RootErrored)), false;
      var error = createCapturedValueAtFiber(Error("There was an error during concurrent rendering but React was able to recover by instead synchronously rendering the entire root.", { cause: value }), sourceFiber);
      workInProgressRootConcurrentErrors === null ? workInProgressRootConcurrentErrors = [error] : workInProgressRootConcurrentErrors.push(error);
      workInProgressRootExitStatus !== RootSuspendedWithDelay && (workInProgressRootExitStatus = RootErrored);
      if (returnFiber === null)
        return true;
      value = createCapturedValueAtFiber(value, sourceFiber);
      sourceFiber = returnFiber;
      do {
        switch (sourceFiber.tag) {
          case 3:
            return sourceFiber.flags |= 65536, root2 = rootRenderLanes & -rootRenderLanes, sourceFiber.lanes |= root2, root2 = createRootErrorUpdate(sourceFiber.stateNode, value, root2), enqueueCapturedUpdate(sourceFiber, root2), false;
          case 1:
            if (returnFiber = sourceFiber.type, error = sourceFiber.stateNode, (sourceFiber.flags & 128) === 0 && (typeof returnFiber.getDerivedStateFromError === "function" || error !== null && typeof error.componentDidCatch === "function" && (legacyErrorBoundariesThatAlreadyFailed === null || !legacyErrorBoundariesThatAlreadyFailed.has(error))))
              return sourceFiber.flags |= 65536, rootRenderLanes &= -rootRenderLanes, sourceFiber.lanes |= rootRenderLanes, rootRenderLanes = createClassErrorUpdate(rootRenderLanes), initializeClassErrorUpdate(rootRenderLanes, root2, sourceFiber, value), enqueueCapturedUpdate(sourceFiber, rootRenderLanes), false;
        }
        sourceFiber = sourceFiber.return;
      } while (sourceFiber !== null);
      return false;
    }
    function reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2) {
      workInProgress2.child = current2 === null ? mountChildFibers(workInProgress2, null, nextChildren, renderLanes2) : reconcileChildFibers(workInProgress2, current2.child, nextChildren, renderLanes2);
    }
    function updateForwardRef(current2, workInProgress2, Component, nextProps, renderLanes2) {
      Component = Component.render;
      var ref = workInProgress2.ref;
      if ("ref" in nextProps) {
        var propsWithoutRef = {};
        for (var key in nextProps)
          key !== "ref" && (propsWithoutRef[key] = nextProps[key]);
      } else
        propsWithoutRef = nextProps;
      prepareToReadContext(workInProgress2);
      nextProps = renderWithHooks(current2, workInProgress2, Component, propsWithoutRef, ref, renderLanes2);
      key = checkDidRenderIdHook();
      if (current2 !== null && !didReceiveUpdate)
        return bailoutHooks(current2, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
      isHydrating && key && pushMaterializedTreeId(workInProgress2);
      workInProgress2.flags |= 1;
      reconcileChildren(current2, workInProgress2, nextProps, renderLanes2);
      return workInProgress2.child;
    }
    function updateMemoComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
      if (current2 === null) {
        var type = Component.type;
        if (typeof type === "function" && !shouldConstruct(type) && type.defaultProps === undefined && Component.compare === null)
          return Component = resolveFunctionForHotReloading(type), workInProgress2.tag = 15, workInProgress2.type = Component, validateFunctionComponentInDev(workInProgress2, type), updateSimpleMemoComponent(current2, workInProgress2, Component, nextProps, renderLanes2);
        current2 = createFiberFromTypeAndProps(Component.type, null, nextProps, workInProgress2, workInProgress2.mode, renderLanes2);
        current2.ref = workInProgress2.ref;
        current2.return = workInProgress2;
        return workInProgress2.child = current2;
      }
      type = current2.child;
      if (!checkScheduledUpdateOrContext(current2, renderLanes2)) {
        var prevProps = type.memoizedProps;
        Component = Component.compare;
        Component = Component !== null ? Component : shallowEqual;
        if (Component(prevProps, nextProps) && current2.ref === workInProgress2.ref)
          return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
      }
      workInProgress2.flags |= 1;
      current2 = createWorkInProgress(type, nextProps);
      current2.ref = workInProgress2.ref;
      current2.return = workInProgress2;
      return workInProgress2.child = current2;
    }
    function updateSimpleMemoComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
      if (current2 !== null) {
        var prevProps = current2.memoizedProps;
        if (shallowEqual(prevProps, nextProps) && current2.ref === workInProgress2.ref && workInProgress2.type === current2.type)
          if (didReceiveUpdate = false, workInProgress2.pendingProps = nextProps = prevProps, checkScheduledUpdateOrContext(current2, renderLanes2))
            (current2.flags & 131072) !== 0 && (didReceiveUpdate = true);
          else
            return workInProgress2.lanes = current2.lanes, bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
      }
      return updateFunctionComponent(current2, workInProgress2, Component, nextProps, renderLanes2);
    }
    function updateOffscreenComponent(current2, workInProgress2, renderLanes2, nextProps) {
      var nextChildren = nextProps.children, prevState = current2 !== null ? current2.memoizedState : null;
      current2 === null && workInProgress2.stateNode === null && (workInProgress2.stateNode = {
        _visibility: OffscreenVisible,
        _pendingMarkers: null,
        _retryCache: null,
        _transitions: null
      });
      if (nextProps.mode === "hidden") {
        if ((workInProgress2.flags & 128) !== 0) {
          prevState = prevState !== null ? prevState.baseLanes | renderLanes2 : renderLanes2;
          if (current2 !== null) {
            nextProps = workInProgress2.child = current2.child;
            for (nextChildren = 0;nextProps !== null; )
              nextChildren = nextChildren | nextProps.lanes | nextProps.childLanes, nextProps = nextProps.sibling;
            nextProps = nextChildren & ~prevState;
          } else
            nextProps = 0, workInProgress2.child = null;
          return deferHiddenOffscreenComponent(current2, workInProgress2, prevState, renderLanes2, nextProps);
        }
        if ((renderLanes2 & 536870912) !== 0)
          workInProgress2.memoizedState = { baseLanes: 0, cachePool: null }, current2 !== null && pushTransition(workInProgress2, prevState !== null ? prevState.cachePool : null), prevState !== null ? pushHiddenContext(workInProgress2, prevState) : reuseHiddenContextOnStack(workInProgress2), pushOffscreenSuspenseHandler(workInProgress2);
        else
          return nextProps = workInProgress2.lanes = 536870912, deferHiddenOffscreenComponent(current2, workInProgress2, prevState !== null ? prevState.baseLanes | renderLanes2 : renderLanes2, renderLanes2, nextProps);
      } else
        prevState !== null ? (pushTransition(workInProgress2, prevState.cachePool), pushHiddenContext(workInProgress2, prevState), reuseSuspenseHandlerOnStack(workInProgress2), workInProgress2.memoizedState = null) : (current2 !== null && pushTransition(workInProgress2, null), reuseHiddenContextOnStack(workInProgress2), reuseSuspenseHandlerOnStack(workInProgress2));
      reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
      return workInProgress2.child;
    }
    function bailoutOffscreenComponent(current2, workInProgress2) {
      current2 !== null && current2.tag === 22 || workInProgress2.stateNode !== null || (workInProgress2.stateNode = {
        _visibility: OffscreenVisible,
        _pendingMarkers: null,
        _retryCache: null,
        _transitions: null
      });
      return workInProgress2.sibling;
    }
    function deferHiddenOffscreenComponent(current2, workInProgress2, nextBaseLanes, renderLanes2, remainingChildLanes) {
      var JSCompiler_inline_result = peekCacheFromPool();
      JSCompiler_inline_result = JSCompiler_inline_result === null ? null : {
        parent: CacheContext._currentValue,
        pool: JSCompiler_inline_result
      };
      workInProgress2.memoizedState = {
        baseLanes: nextBaseLanes,
        cachePool: JSCompiler_inline_result
      };
      current2 !== null && pushTransition(workInProgress2, null);
      reuseHiddenContextOnStack(workInProgress2);
      pushOffscreenSuspenseHandler(workInProgress2);
      current2 !== null && propagateParentContextChanges(current2, workInProgress2, renderLanes2, true);
      workInProgress2.childLanes = remainingChildLanes;
      return null;
    }
    function mountActivityChildren(workInProgress2, nextProps) {
      var hiddenProp = nextProps.hidden;
      hiddenProp !== undefined && console.error(`<Activity> doesn't accept a hidden prop. Use mode="hidden" instead.
- <Activity %s>
+ <Activity %s>`, hiddenProp === true ? "hidden" : hiddenProp === false ? "hidden={false}" : "hidden={...}", hiddenProp ? 'mode="hidden"' : 'mode="visible"');
      nextProps = mountWorkInProgressOffscreenFiber({ mode: nextProps.mode, children: nextProps.children }, workInProgress2.mode);
      nextProps.ref = workInProgress2.ref;
      workInProgress2.child = nextProps;
      nextProps.return = workInProgress2;
      return nextProps;
    }
    function retryActivityComponentWithoutHydrating(current2, workInProgress2, renderLanes2) {
      reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
      current2 = mountActivityChildren(workInProgress2, workInProgress2.pendingProps);
      current2.flags |= 2;
      popSuspenseHandler(workInProgress2);
      workInProgress2.memoizedState = null;
      return current2;
    }
    function updateActivityComponent(current2, workInProgress2, renderLanes2) {
      var nextProps = workInProgress2.pendingProps, didSuspend = (workInProgress2.flags & 128) !== 0;
      workInProgress2.flags &= -129;
      if (current2 === null) {
        if (isHydrating) {
          if (nextProps.mode === "hidden")
            return current2 = mountActivityChildren(workInProgress2, nextProps), workInProgress2.lanes = 536870912, bailoutOffscreenComponent(null, current2);
          pushDehydratedActivitySuspenseHandler(workInProgress2);
          (current2 = nextHydratableInstance) ? (renderLanes2 = canHydrateHydrationBoundary(current2, rootOrSingletonContext), renderLanes2 = renderLanes2 !== null && renderLanes2.data === ACTIVITY_START_DATA ? renderLanes2 : null, renderLanes2 !== null && (nextProps = {
            dehydrated: renderLanes2,
            treeContext: getSuspendedTreeContext(),
            retryLane: 536870912,
            hydrationErrors: null
          }, workInProgress2.memoizedState = nextProps, nextProps = createFiberFromDehydratedFragment(renderLanes2), nextProps.return = workInProgress2, workInProgress2.child = nextProps, hydrationParentFiber = workInProgress2, nextHydratableInstance = null)) : renderLanes2 = null;
          if (renderLanes2 === null)
            throw warnNonHydratedInstance(workInProgress2, current2), throwOnHydrationMismatch(workInProgress2);
          workInProgress2.lanes = 536870912;
          return null;
        }
        return mountActivityChildren(workInProgress2, nextProps);
      }
      var prevState = current2.memoizedState;
      if (prevState !== null) {
        var activityInstance = prevState.dehydrated;
        pushDehydratedActivitySuspenseHandler(workInProgress2);
        if (didSuspend)
          if (workInProgress2.flags & 256)
            workInProgress2.flags &= -257, workInProgress2 = retryActivityComponentWithoutHydrating(current2, workInProgress2, renderLanes2);
          else if (workInProgress2.memoizedState !== null)
            workInProgress2.child = current2.child, workInProgress2.flags |= 128, workInProgress2 = null;
          else
            throw Error("Client rendering an Activity suspended it again. This is a bug in React.");
        else if (warnIfHydrating(), (renderLanes2 & 536870912) !== 0 && markRenderDerivedCause(workInProgress2), didReceiveUpdate || propagateParentContextChanges(current2, workInProgress2, renderLanes2, false), didSuspend = (renderLanes2 & current2.childLanes) !== 0, didReceiveUpdate || didSuspend) {
          nextProps = workInProgressRoot;
          if (nextProps !== null && (activityInstance = getBumpedLaneForHydration(nextProps, renderLanes2), activityInstance !== 0 && activityInstance !== prevState.retryLane))
            throw prevState.retryLane = activityInstance, enqueueConcurrentRenderForLane(current2, activityInstance), scheduleUpdateOnFiber(nextProps, current2, activityInstance), SelectiveHydrationException;
          renderDidSuspendDelayIfPossible();
          workInProgress2 = retryActivityComponentWithoutHydrating(current2, workInProgress2, renderLanes2);
        } else
          current2 = prevState.treeContext, nextHydratableInstance = getNextHydratable(activityInstance.nextSibling), hydrationParentFiber = workInProgress2, isHydrating = true, hydrationErrors = null, didSuspendOrErrorDEV = false, hydrationDiffRootDEV = null, rootOrSingletonContext = false, current2 !== null && restoreSuspendedTreeContext(workInProgress2, current2), workInProgress2 = mountActivityChildren(workInProgress2, nextProps), workInProgress2.flags |= 4096;
        return workInProgress2;
      }
      prevState = current2.child;
      nextProps = { mode: nextProps.mode, children: nextProps.children };
      (renderLanes2 & 536870912) !== 0 && (renderLanes2 & current2.lanes) !== 0 && markRenderDerivedCause(workInProgress2);
      current2 = createWorkInProgress(prevState, nextProps);
      current2.ref = workInProgress2.ref;
      workInProgress2.child = current2;
      current2.return = workInProgress2;
      return current2;
    }
    function markRef(current2, workInProgress2) {
      var ref = workInProgress2.ref;
      if (ref === null)
        current2 !== null && current2.ref !== null && (workInProgress2.flags |= 4194816);
      else {
        if (typeof ref !== "function" && typeof ref !== "object")
          throw Error("Expected ref to be a function, an object returned by React.createRef(), or undefined/null.");
        if (current2 === null || current2.ref !== ref)
          workInProgress2.flags |= 4194816;
      }
    }
    function updateFunctionComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
      if (Component.prototype && typeof Component.prototype.render === "function") {
        var componentName2 = getComponentNameFromType(Component) || "Unknown";
        didWarnAboutBadClass[componentName2] || (console.error("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", componentName2, componentName2), didWarnAboutBadClass[componentName2] = true);
      }
      workInProgress2.mode & StrictLegacyMode && ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress2, null);
      current2 === null && (validateFunctionComponentInDev(workInProgress2, workInProgress2.type), Component.contextTypes && (componentName2 = getComponentNameFromType(Component) || "Unknown", didWarnAboutContextTypes[componentName2] || (didWarnAboutContextTypes[componentName2] = true, console.error("%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with React.useContext() instead. (https://react.dev/link/legacy-context)", componentName2))));
      prepareToReadContext(workInProgress2);
      Component = renderWithHooks(current2, workInProgress2, Component, nextProps, undefined, renderLanes2);
      nextProps = checkDidRenderIdHook();
      if (current2 !== null && !didReceiveUpdate)
        return bailoutHooks(current2, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
      isHydrating && nextProps && pushMaterializedTreeId(workInProgress2);
      workInProgress2.flags |= 1;
      reconcileChildren(current2, workInProgress2, Component, renderLanes2);
      return workInProgress2.child;
    }
    function replayFunctionComponent(current2, workInProgress2, nextProps, Component, secondArg, renderLanes2) {
      prepareToReadContext(workInProgress2);
      hookTypesUpdateIndexDev = -1;
      ignorePreviousDependencies = current2 !== null && current2.type !== workInProgress2.type;
      workInProgress2.updateQueue = null;
      nextProps = renderWithHooksAgain(workInProgress2, Component, nextProps, secondArg);
      finishRenderingHooks(current2, workInProgress2);
      Component = checkDidRenderIdHook();
      if (current2 !== null && !didReceiveUpdate)
        return bailoutHooks(current2, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
      isHydrating && Component && pushMaterializedTreeId(workInProgress2);
      workInProgress2.flags |= 1;
      reconcileChildren(current2, workInProgress2, nextProps, renderLanes2);
      return workInProgress2.child;
    }
    function updateClassComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
      switch (shouldErrorImpl(workInProgress2)) {
        case false:
          var _instance = workInProgress2.stateNode, state = new workInProgress2.type(workInProgress2.memoizedProps, _instance.context).state;
          _instance.updater.enqueueSetState(_instance, state, null);
          break;
        case true:
          workInProgress2.flags |= 128;
          workInProgress2.flags |= 65536;
          _instance = Error("Simulated error coming from DevTools");
          var lane = renderLanes2 & -renderLanes2;
          workInProgress2.lanes |= lane;
          state = workInProgressRoot;
          if (state === null)
            throw Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
          lane = createClassErrorUpdate(lane);
          initializeClassErrorUpdate(lane, state, workInProgress2, createCapturedValueAtFiber(_instance, workInProgress2));
          enqueueCapturedUpdate(workInProgress2, lane);
      }
      prepareToReadContext(workInProgress2);
      if (workInProgress2.stateNode === null) {
        state = emptyContextObject;
        _instance = Component.contextType;
        "contextType" in Component && _instance !== null && (_instance === undefined || _instance.$$typeof !== REACT_CONTEXT_TYPE) && !didWarnAboutInvalidateContextType.has(Component) && (didWarnAboutInvalidateContextType.add(Component), lane = _instance === undefined ? " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof _instance !== "object" ? " However, it is set to a " + typeof _instance + "." : _instance.$$typeof === REACT_CONSUMER_TYPE ? " Did you accidentally pass the Context.Consumer instead?" : " However, it is set to an object with keys {" + Object.keys(_instance).join(", ") + "}.", console.error("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", getComponentNameFromType(Component) || "Component", lane));
        typeof _instance === "object" && _instance !== null && (state = readContext(_instance));
        _instance = new Component(nextProps, state);
        if (workInProgress2.mode & StrictLegacyMode) {
          setIsStrictModeForDevtools(true);
          try {
            _instance = new Component(nextProps, state);
          } finally {
            setIsStrictModeForDevtools(false);
          }
        }
        state = workInProgress2.memoizedState = _instance.state !== null && _instance.state !== undefined ? _instance.state : null;
        _instance.updater = classComponentUpdater;
        workInProgress2.stateNode = _instance;
        _instance._reactInternals = workInProgress2;
        _instance._reactInternalInstance = fakeInternalInstance;
        typeof Component.getDerivedStateFromProps === "function" && state === null && (state = getComponentNameFromType(Component) || "Component", didWarnAboutUninitializedState.has(state) || (didWarnAboutUninitializedState.add(state), console.error("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", state, _instance.state === null ? "null" : "undefined", state)));
        if (typeof Component.getDerivedStateFromProps === "function" || typeof _instance.getSnapshotBeforeUpdate === "function") {
          var foundWillUpdateName = lane = state = null;
          typeof _instance.componentWillMount === "function" && _instance.componentWillMount.__suppressDeprecationWarning !== true ? state = "componentWillMount" : typeof _instance.UNSAFE_componentWillMount === "function" && (state = "UNSAFE_componentWillMount");
          typeof _instance.componentWillReceiveProps === "function" && _instance.componentWillReceiveProps.__suppressDeprecationWarning !== true ? lane = "componentWillReceiveProps" : typeof _instance.UNSAFE_componentWillReceiveProps === "function" && (lane = "UNSAFE_componentWillReceiveProps");
          typeof _instance.componentWillUpdate === "function" && _instance.componentWillUpdate.__suppressDeprecationWarning !== true ? foundWillUpdateName = "componentWillUpdate" : typeof _instance.UNSAFE_componentWillUpdate === "function" && (foundWillUpdateName = "UNSAFE_componentWillUpdate");
          if (state !== null || lane !== null || foundWillUpdateName !== null) {
            _instance = getComponentNameFromType(Component) || "Component";
            var newApiName = typeof Component.getDerivedStateFromProps === "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            didWarnAboutLegacyLifecyclesAndDerivedState.has(_instance) || (didWarnAboutLegacyLifecyclesAndDerivedState.add(_instance), console.error(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://react.dev/link/unsafe-component-lifecycles`, _instance, newApiName, state !== null ? `
  ` + state : "", lane !== null ? `
  ` + lane : "", foundWillUpdateName !== null ? `
  ` + foundWillUpdateName : ""));
          }
        }
        _instance = workInProgress2.stateNode;
        state = getComponentNameFromType(Component) || "Component";
        _instance.render || (Component.prototype && typeof Component.prototype.render === "function" ? console.error("No `render` method found on the %s instance: did you accidentally return an object from the constructor?", state) : console.error("No `render` method found on the %s instance: you may have forgotten to define `render`.", state));
        !_instance.getInitialState || _instance.getInitialState.isReactClassApproved || _instance.state || console.error("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", state);
        _instance.getDefaultProps && !_instance.getDefaultProps.isReactClassApproved && console.error("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", state);
        _instance.contextType && console.error("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", state);
        Component.childContextTypes && !didWarnAboutChildContextTypes.has(Component) && (didWarnAboutChildContextTypes.add(Component), console.error("%s uses the legacy childContextTypes API which was removed in React 19. Use React.createContext() instead. (https://react.dev/link/legacy-context)", state));
        Component.contextTypes && !didWarnAboutContextTypes$1.has(Component) && (didWarnAboutContextTypes$1.add(Component), console.error("%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with static contextType instead. (https://react.dev/link/legacy-context)", state));
        typeof _instance.componentShouldUpdate === "function" && console.error("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", state);
        Component.prototype && Component.prototype.isPureReactComponent && typeof _instance.shouldComponentUpdate !== "undefined" && console.error("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", getComponentNameFromType(Component) || "A pure component");
        typeof _instance.componentDidUnmount === "function" && console.error("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", state);
        typeof _instance.componentDidReceiveProps === "function" && console.error("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", state);
        typeof _instance.componentWillRecieveProps === "function" && console.error("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", state);
        typeof _instance.UNSAFE_componentWillRecieveProps === "function" && console.error("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", state);
        lane = _instance.props !== nextProps;
        _instance.props !== undefined && lane && console.error("When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", state);
        _instance.defaultProps && console.error("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", state, state);
        typeof _instance.getSnapshotBeforeUpdate !== "function" || typeof _instance.componentDidUpdate === "function" || didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(Component) || (didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(Component), console.error("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", getComponentNameFromType(Component)));
        typeof _instance.getDerivedStateFromProps === "function" && console.error("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", state);
        typeof _instance.getDerivedStateFromError === "function" && console.error("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", state);
        typeof Component.getSnapshotBeforeUpdate === "function" && console.error("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", state);
        (lane = _instance.state) && (typeof lane !== "object" || isArrayImpl(lane)) && console.error("%s.state: must be set to an object or null", state);
        typeof _instance.getChildContext === "function" && typeof Component.childContextTypes !== "object" && console.error("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", state);
        _instance = workInProgress2.stateNode;
        _instance.props = nextProps;
        _instance.state = workInProgress2.memoizedState;
        _instance.refs = {};
        initializeUpdateQueue(workInProgress2);
        state = Component.contextType;
        _instance.context = typeof state === "object" && state !== null ? readContext(state) : emptyContextObject;
        _instance.state === nextProps && (state = getComponentNameFromType(Component) || "Component", didWarnAboutDirectlyAssigningPropsToState.has(state) || (didWarnAboutDirectlyAssigningPropsToState.add(state), console.error("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", state)));
        workInProgress2.mode & StrictLegacyMode && ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress2, _instance);
        ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress2, _instance);
        _instance.state = workInProgress2.memoizedState;
        state = Component.getDerivedStateFromProps;
        typeof state === "function" && (applyDerivedStateFromProps(workInProgress2, Component, state, nextProps), _instance.state = workInProgress2.memoizedState);
        typeof Component.getDerivedStateFromProps === "function" || typeof _instance.getSnapshotBeforeUpdate === "function" || typeof _instance.UNSAFE_componentWillMount !== "function" && typeof _instance.componentWillMount !== "function" || (state = _instance.state, typeof _instance.componentWillMount === "function" && _instance.componentWillMount(), typeof _instance.UNSAFE_componentWillMount === "function" && _instance.UNSAFE_componentWillMount(), state !== _instance.state && (console.error("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", getComponentNameFromFiber(workInProgress2) || "Component"), classComponentUpdater.enqueueReplaceState(_instance, _instance.state, null)), processUpdateQueue(workInProgress2, nextProps, _instance, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction(), _instance.state = workInProgress2.memoizedState);
        typeof _instance.componentDidMount === "function" && (workInProgress2.flags |= 4194308);
        (workInProgress2.mode & StrictEffectsMode) !== NoMode && (workInProgress2.flags |= 134217728);
        _instance = true;
      } else if (current2 === null) {
        _instance = workInProgress2.stateNode;
        var unresolvedOldProps = workInProgress2.memoizedProps;
        lane = resolveClassComponentProps(Component, unresolvedOldProps);
        _instance.props = lane;
        var oldContext = _instance.context;
        foundWillUpdateName = Component.contextType;
        state = emptyContextObject;
        typeof foundWillUpdateName === "object" && foundWillUpdateName !== null && (state = readContext(foundWillUpdateName));
        newApiName = Component.getDerivedStateFromProps;
        foundWillUpdateName = typeof newApiName === "function" || typeof _instance.getSnapshotBeforeUpdate === "function";
        unresolvedOldProps = workInProgress2.pendingProps !== unresolvedOldProps;
        foundWillUpdateName || typeof _instance.UNSAFE_componentWillReceiveProps !== "function" && typeof _instance.componentWillReceiveProps !== "function" || (unresolvedOldProps || oldContext !== state) && callComponentWillReceiveProps(workInProgress2, _instance, nextProps, state);
        hasForceUpdate = false;
        var oldState = workInProgress2.memoizedState;
        _instance.state = oldState;
        processUpdateQueue(workInProgress2, nextProps, _instance, renderLanes2);
        suspendIfUpdateReadFromEntangledAsyncAction();
        oldContext = workInProgress2.memoizedState;
        unresolvedOldProps || oldState !== oldContext || hasForceUpdate ? (typeof newApiName === "function" && (applyDerivedStateFromProps(workInProgress2, Component, newApiName, nextProps), oldContext = workInProgress2.memoizedState), (lane = hasForceUpdate || checkShouldComponentUpdate(workInProgress2, Component, lane, nextProps, oldState, oldContext, state)) ? (foundWillUpdateName || typeof _instance.UNSAFE_componentWillMount !== "function" && typeof _instance.componentWillMount !== "function" || (typeof _instance.componentWillMount === "function" && _instance.componentWillMount(), typeof _instance.UNSAFE_componentWillMount === "function" && _instance.UNSAFE_componentWillMount()), typeof _instance.componentDidMount === "function" && (workInProgress2.flags |= 4194308), (workInProgress2.mode & StrictEffectsMode) !== NoMode && (workInProgress2.flags |= 134217728)) : (typeof _instance.componentDidMount === "function" && (workInProgress2.flags |= 4194308), (workInProgress2.mode & StrictEffectsMode) !== NoMode && (workInProgress2.flags |= 134217728), workInProgress2.memoizedProps = nextProps, workInProgress2.memoizedState = oldContext), _instance.props = nextProps, _instance.state = oldContext, _instance.context = state, _instance = lane) : (typeof _instance.componentDidMount === "function" && (workInProgress2.flags |= 4194308), (workInProgress2.mode & StrictEffectsMode) !== NoMode && (workInProgress2.flags |= 134217728), _instance = false);
      } else {
        _instance = workInProgress2.stateNode;
        cloneUpdateQueue(current2, workInProgress2);
        state = workInProgress2.memoizedProps;
        foundWillUpdateName = resolveClassComponentProps(Component, state);
        _instance.props = foundWillUpdateName;
        newApiName = workInProgress2.pendingProps;
        oldState = _instance.context;
        oldContext = Component.contextType;
        lane = emptyContextObject;
        typeof oldContext === "object" && oldContext !== null && (lane = readContext(oldContext));
        unresolvedOldProps = Component.getDerivedStateFromProps;
        (oldContext = typeof unresolvedOldProps === "function" || typeof _instance.getSnapshotBeforeUpdate === "function") || typeof _instance.UNSAFE_componentWillReceiveProps !== "function" && typeof _instance.componentWillReceiveProps !== "function" || (state !== newApiName || oldState !== lane) && callComponentWillReceiveProps(workInProgress2, _instance, nextProps, lane);
        hasForceUpdate = false;
        oldState = workInProgress2.memoizedState;
        _instance.state = oldState;
        processUpdateQueue(workInProgress2, nextProps, _instance, renderLanes2);
        suspendIfUpdateReadFromEntangledAsyncAction();
        var newState = workInProgress2.memoizedState;
        state !== newApiName || oldState !== newState || hasForceUpdate || current2 !== null && current2.dependencies !== null && checkIfContextChanged(current2.dependencies) ? (typeof unresolvedOldProps === "function" && (applyDerivedStateFromProps(workInProgress2, Component, unresolvedOldProps, nextProps), newState = workInProgress2.memoizedState), (foundWillUpdateName = hasForceUpdate || checkShouldComponentUpdate(workInProgress2, Component, foundWillUpdateName, nextProps, oldState, newState, lane) || current2 !== null && current2.dependencies !== null && checkIfContextChanged(current2.dependencies)) ? (oldContext || typeof _instance.UNSAFE_componentWillUpdate !== "function" && typeof _instance.componentWillUpdate !== "function" || (typeof _instance.componentWillUpdate === "function" && _instance.componentWillUpdate(nextProps, newState, lane), typeof _instance.UNSAFE_componentWillUpdate === "function" && _instance.UNSAFE_componentWillUpdate(nextProps, newState, lane)), typeof _instance.componentDidUpdate === "function" && (workInProgress2.flags |= 4), typeof _instance.getSnapshotBeforeUpdate === "function" && (workInProgress2.flags |= 1024)) : (typeof _instance.componentDidUpdate !== "function" || state === current2.memoizedProps && oldState === current2.memoizedState || (workInProgress2.flags |= 4), typeof _instance.getSnapshotBeforeUpdate !== "function" || state === current2.memoizedProps && oldState === current2.memoizedState || (workInProgress2.flags |= 1024), workInProgress2.memoizedProps = nextProps, workInProgress2.memoizedState = newState), _instance.props = nextProps, _instance.state = newState, _instance.context = lane, _instance = foundWillUpdateName) : (typeof _instance.componentDidUpdate !== "function" || state === current2.memoizedProps && oldState === current2.memoizedState || (workInProgress2.flags |= 4), typeof _instance.getSnapshotBeforeUpdate !== "function" || state === current2.memoizedProps && oldState === current2.memoizedState || (workInProgress2.flags |= 1024), _instance = false);
      }
      lane = _instance;
      markRef(current2, workInProgress2);
      state = (workInProgress2.flags & 128) !== 0;
      if (lane || state) {
        lane = workInProgress2.stateNode;
        setCurrentFiber(workInProgress2);
        if (state && typeof Component.getDerivedStateFromError !== "function")
          Component = null, profilerStartTime = -1;
        else if (Component = callRenderInDEV(lane), workInProgress2.mode & StrictLegacyMode) {
          setIsStrictModeForDevtools(true);
          try {
            callRenderInDEV(lane);
          } finally {
            setIsStrictModeForDevtools(false);
          }
        }
        workInProgress2.flags |= 1;
        current2 !== null && state ? (workInProgress2.child = reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2), workInProgress2.child = reconcileChildFibers(workInProgress2, null, Component, renderLanes2)) : reconcileChildren(current2, workInProgress2, Component, renderLanes2);
        workInProgress2.memoizedState = lane.state;
        current2 = workInProgress2.child;
      } else
        current2 = bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
      renderLanes2 = workInProgress2.stateNode;
      _instance && renderLanes2.props !== nextProps && (didWarnAboutReassigningProps || console.error("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", getComponentNameFromFiber(workInProgress2) || "a component"), didWarnAboutReassigningProps = true);
      return current2;
    }
    function mountHostRootWithoutHydrating(current2, workInProgress2, nextChildren, renderLanes2) {
      resetHydrationState();
      workInProgress2.flags |= 256;
      reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
      return workInProgress2.child;
    }
    function validateFunctionComponentInDev(workInProgress2, Component) {
      Component && Component.childContextTypes && console.error(`childContextTypes cannot be defined on a function component.
  %s.childContextTypes = ...`, Component.displayName || Component.name || "Component");
      typeof Component.getDerivedStateFromProps === "function" && (workInProgress2 = getComponentNameFromType(Component) || "Unknown", didWarnAboutGetDerivedStateOnFunctionComponent[workInProgress2] || (console.error("%s: Function components do not support getDerivedStateFromProps.", workInProgress2), didWarnAboutGetDerivedStateOnFunctionComponent[workInProgress2] = true));
      typeof Component.contextType === "object" && Component.contextType !== null && (Component = getComponentNameFromType(Component) || "Unknown", didWarnAboutContextTypeOnFunctionComponent[Component] || (console.error("%s: Function components do not support contextType.", Component), didWarnAboutContextTypeOnFunctionComponent[Component] = true));
    }
    function mountSuspenseOffscreenState(renderLanes2) {
      return { baseLanes: renderLanes2, cachePool: getSuspendedCache() };
    }
    function getRemainingWorkInPrimaryTree(current2, primaryTreeDidDefer, renderLanes2) {
      current2 = current2 !== null ? current2.childLanes & ~renderLanes2 : 0;
      primaryTreeDidDefer && (current2 |= workInProgressDeferredLane);
      return current2;
    }
    function updateSuspenseComponent(current2, workInProgress2, renderLanes2) {
      var JSCompiler_object_inline_digest_2724;
      var JSCompiler_object_inline_stack_2725 = workInProgress2.pendingProps;
      shouldSuspendImpl(workInProgress2) && (workInProgress2.flags |= 128);
      var JSCompiler_object_inline_message_2723 = false;
      var didSuspend = (workInProgress2.flags & 128) !== 0;
      (JSCompiler_object_inline_digest_2724 = didSuspend) || (JSCompiler_object_inline_digest_2724 = current2 !== null && current2.memoizedState === null ? false : (suspenseStackCursor.current & ForceSuspenseFallback) !== 0);
      JSCompiler_object_inline_digest_2724 && (JSCompiler_object_inline_message_2723 = true, workInProgress2.flags &= -129);
      JSCompiler_object_inline_digest_2724 = (workInProgress2.flags & 32) !== 0;
      workInProgress2.flags &= -33;
      if (current2 === null) {
        if (isHydrating) {
          JSCompiler_object_inline_message_2723 ? pushPrimaryTreeSuspenseHandler(workInProgress2) : reuseSuspenseHandlerOnStack(workInProgress2);
          (current2 = nextHydratableInstance) ? (renderLanes2 = canHydrateHydrationBoundary(current2, rootOrSingletonContext), renderLanes2 = renderLanes2 !== null && renderLanes2.data !== ACTIVITY_START_DATA ? renderLanes2 : null, renderLanes2 !== null && (JSCompiler_object_inline_digest_2724 = {
            dehydrated: renderLanes2,
            treeContext: getSuspendedTreeContext(),
            retryLane: 536870912,
            hydrationErrors: null
          }, workInProgress2.memoizedState = JSCompiler_object_inline_digest_2724, JSCompiler_object_inline_digest_2724 = createFiberFromDehydratedFragment(renderLanes2), JSCompiler_object_inline_digest_2724.return = workInProgress2, workInProgress2.child = JSCompiler_object_inline_digest_2724, hydrationParentFiber = workInProgress2, nextHydratableInstance = null)) : renderLanes2 = null;
          if (renderLanes2 === null)
            throw warnNonHydratedInstance(workInProgress2, current2), throwOnHydrationMismatch(workInProgress2);
          isSuspenseInstanceFallback(renderLanes2) ? workInProgress2.lanes = 32 : workInProgress2.lanes = 536870912;
          return null;
        }
        var nextPrimaryChildren = JSCompiler_object_inline_stack_2725.children;
        JSCompiler_object_inline_stack_2725 = JSCompiler_object_inline_stack_2725.fallback;
        if (JSCompiler_object_inline_message_2723) {
          reuseSuspenseHandlerOnStack(workInProgress2);
          var mode = workInProgress2.mode;
          nextPrimaryChildren = mountWorkInProgressOffscreenFiber({ mode: "hidden", children: nextPrimaryChildren }, mode);
          JSCompiler_object_inline_stack_2725 = createFiberFromFragment(JSCompiler_object_inline_stack_2725, mode, renderLanes2, null);
          nextPrimaryChildren.return = workInProgress2;
          JSCompiler_object_inline_stack_2725.return = workInProgress2;
          nextPrimaryChildren.sibling = JSCompiler_object_inline_stack_2725;
          workInProgress2.child = nextPrimaryChildren;
          JSCompiler_object_inline_stack_2725 = workInProgress2.child;
          JSCompiler_object_inline_stack_2725.memoizedState = mountSuspenseOffscreenState(renderLanes2);
          JSCompiler_object_inline_stack_2725.childLanes = getRemainingWorkInPrimaryTree(current2, JSCompiler_object_inline_digest_2724, renderLanes2);
          workInProgress2.memoizedState = SUSPENDED_MARKER;
          return bailoutOffscreenComponent(null, JSCompiler_object_inline_stack_2725);
        }
        pushPrimaryTreeSuspenseHandler(workInProgress2);
        return mountSuspensePrimaryChildren(workInProgress2, nextPrimaryChildren);
      }
      var prevState = current2.memoizedState;
      if (prevState !== null) {
        var JSCompiler_object_inline_componentStack_2726 = prevState.dehydrated;
        if (JSCompiler_object_inline_componentStack_2726 !== null) {
          if (didSuspend)
            workInProgress2.flags & 256 ? (pushPrimaryTreeSuspenseHandler(workInProgress2), workInProgress2.flags &= -257, workInProgress2 = retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2)) : workInProgress2.memoizedState !== null ? (reuseSuspenseHandlerOnStack(workInProgress2), workInProgress2.child = current2.child, workInProgress2.flags |= 128, workInProgress2 = null) : (reuseSuspenseHandlerOnStack(workInProgress2), nextPrimaryChildren = JSCompiler_object_inline_stack_2725.fallback, mode = workInProgress2.mode, JSCompiler_object_inline_stack_2725 = mountWorkInProgressOffscreenFiber({
              mode: "visible",
              children: JSCompiler_object_inline_stack_2725.children
            }, mode), nextPrimaryChildren = createFiberFromFragment(nextPrimaryChildren, mode, renderLanes2, null), nextPrimaryChildren.flags |= 2, JSCompiler_object_inline_stack_2725.return = workInProgress2, nextPrimaryChildren.return = workInProgress2, JSCompiler_object_inline_stack_2725.sibling = nextPrimaryChildren, workInProgress2.child = JSCompiler_object_inline_stack_2725, reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2), JSCompiler_object_inline_stack_2725 = workInProgress2.child, JSCompiler_object_inline_stack_2725.memoizedState = mountSuspenseOffscreenState(renderLanes2), JSCompiler_object_inline_stack_2725.childLanes = getRemainingWorkInPrimaryTree(current2, JSCompiler_object_inline_digest_2724, renderLanes2), workInProgress2.memoizedState = SUSPENDED_MARKER, workInProgress2 = bailoutOffscreenComponent(null, JSCompiler_object_inline_stack_2725));
          else if (pushPrimaryTreeSuspenseHandler(workInProgress2), warnIfHydrating(), (renderLanes2 & 536870912) !== 0 && markRenderDerivedCause(workInProgress2), isSuspenseInstanceFallback(JSCompiler_object_inline_componentStack_2726)) {
            JSCompiler_object_inline_digest_2724 = JSCompiler_object_inline_componentStack_2726.nextSibling && JSCompiler_object_inline_componentStack_2726.nextSibling.dataset;
            if (JSCompiler_object_inline_digest_2724) {
              nextPrimaryChildren = JSCompiler_object_inline_digest_2724.dgst;
              var message = JSCompiler_object_inline_digest_2724.msg;
              mode = JSCompiler_object_inline_digest_2724.stck;
              var componentStack = JSCompiler_object_inline_digest_2724.cstck;
            }
            JSCompiler_object_inline_message_2723 = message;
            JSCompiler_object_inline_digest_2724 = nextPrimaryChildren;
            JSCompiler_object_inline_stack_2725 = mode;
            JSCompiler_object_inline_componentStack_2726 = componentStack;
            nextPrimaryChildren = JSCompiler_object_inline_message_2723;
            mode = JSCompiler_object_inline_componentStack_2726;
            nextPrimaryChildren = nextPrimaryChildren ? Error(nextPrimaryChildren) : Error("The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.");
            nextPrimaryChildren.stack = JSCompiler_object_inline_stack_2725 || "";
            nextPrimaryChildren.digest = JSCompiler_object_inline_digest_2724;
            JSCompiler_object_inline_digest_2724 = mode === undefined ? null : mode;
            JSCompiler_object_inline_stack_2725 = {
              value: nextPrimaryChildren,
              source: null,
              stack: JSCompiler_object_inline_digest_2724
            };
            typeof JSCompiler_object_inline_digest_2724 === "string" && CapturedStacks.set(nextPrimaryChildren, JSCompiler_object_inline_stack_2725);
            queueHydrationError(JSCompiler_object_inline_stack_2725);
            workInProgress2 = retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2);
          } else if (didReceiveUpdate || propagateParentContextChanges(current2, workInProgress2, renderLanes2, false), JSCompiler_object_inline_digest_2724 = (renderLanes2 & current2.childLanes) !== 0, didReceiveUpdate || JSCompiler_object_inline_digest_2724) {
            JSCompiler_object_inline_digest_2724 = workInProgressRoot;
            if (JSCompiler_object_inline_digest_2724 !== null && (JSCompiler_object_inline_stack_2725 = getBumpedLaneForHydration(JSCompiler_object_inline_digest_2724, renderLanes2), JSCompiler_object_inline_stack_2725 !== 0 && JSCompiler_object_inline_stack_2725 !== prevState.retryLane))
              throw prevState.retryLane = JSCompiler_object_inline_stack_2725, enqueueConcurrentRenderForLane(current2, JSCompiler_object_inline_stack_2725), scheduleUpdateOnFiber(JSCompiler_object_inline_digest_2724, current2, JSCompiler_object_inline_stack_2725), SelectiveHydrationException;
            isSuspenseInstancePending(JSCompiler_object_inline_componentStack_2726) || renderDidSuspendDelayIfPossible();
            workInProgress2 = retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2);
          } else
            isSuspenseInstancePending(JSCompiler_object_inline_componentStack_2726) ? (workInProgress2.flags |= 192, workInProgress2.child = current2.child, workInProgress2 = null) : (current2 = prevState.treeContext, nextHydratableInstance = getNextHydratable(JSCompiler_object_inline_componentStack_2726.nextSibling), hydrationParentFiber = workInProgress2, isHydrating = true, hydrationErrors = null, didSuspendOrErrorDEV = false, hydrationDiffRootDEV = null, rootOrSingletonContext = false, current2 !== null && restoreSuspendedTreeContext(workInProgress2, current2), workInProgress2 = mountSuspensePrimaryChildren(workInProgress2, JSCompiler_object_inline_stack_2725.children), workInProgress2.flags |= 4096);
          return workInProgress2;
        }
      }
      if (JSCompiler_object_inline_message_2723)
        return reuseSuspenseHandlerOnStack(workInProgress2), nextPrimaryChildren = JSCompiler_object_inline_stack_2725.fallback, mode = workInProgress2.mode, componentStack = current2.child, JSCompiler_object_inline_componentStack_2726 = componentStack.sibling, JSCompiler_object_inline_stack_2725 = createWorkInProgress(componentStack, {
          mode: "hidden",
          children: JSCompiler_object_inline_stack_2725.children
        }), JSCompiler_object_inline_stack_2725.subtreeFlags = componentStack.subtreeFlags & 65011712, JSCompiler_object_inline_componentStack_2726 !== null ? nextPrimaryChildren = createWorkInProgress(JSCompiler_object_inline_componentStack_2726, nextPrimaryChildren) : (nextPrimaryChildren = createFiberFromFragment(nextPrimaryChildren, mode, renderLanes2, null), nextPrimaryChildren.flags |= 2), nextPrimaryChildren.return = workInProgress2, JSCompiler_object_inline_stack_2725.return = workInProgress2, JSCompiler_object_inline_stack_2725.sibling = nextPrimaryChildren, workInProgress2.child = JSCompiler_object_inline_stack_2725, bailoutOffscreenComponent(null, JSCompiler_object_inline_stack_2725), JSCompiler_object_inline_stack_2725 = workInProgress2.child, nextPrimaryChildren = current2.child.memoizedState, nextPrimaryChildren === null ? nextPrimaryChildren = mountSuspenseOffscreenState(renderLanes2) : (mode = nextPrimaryChildren.cachePool, mode !== null ? (componentStack = CacheContext._currentValue, mode = mode.parent !== componentStack ? { parent: componentStack, pool: componentStack } : mode) : mode = getSuspendedCache(), nextPrimaryChildren = {
          baseLanes: nextPrimaryChildren.baseLanes | renderLanes2,
          cachePool: mode
        }), JSCompiler_object_inline_stack_2725.memoizedState = nextPrimaryChildren, JSCompiler_object_inline_stack_2725.childLanes = getRemainingWorkInPrimaryTree(current2, JSCompiler_object_inline_digest_2724, renderLanes2), workInProgress2.memoizedState = SUSPENDED_MARKER, bailoutOffscreenComponent(current2.child, JSCompiler_object_inline_stack_2725);
      prevState !== null && (renderLanes2 & 62914560) === renderLanes2 && (renderLanes2 & current2.lanes) !== 0 && markRenderDerivedCause(workInProgress2);
      pushPrimaryTreeSuspenseHandler(workInProgress2);
      renderLanes2 = current2.child;
      current2 = renderLanes2.sibling;
      renderLanes2 = createWorkInProgress(renderLanes2, {
        mode: "visible",
        children: JSCompiler_object_inline_stack_2725.children
      });
      renderLanes2.return = workInProgress2;
      renderLanes2.sibling = null;
      current2 !== null && (JSCompiler_object_inline_digest_2724 = workInProgress2.deletions, JSCompiler_object_inline_digest_2724 === null ? (workInProgress2.deletions = [current2], workInProgress2.flags |= 16) : JSCompiler_object_inline_digest_2724.push(current2));
      workInProgress2.child = renderLanes2;
      workInProgress2.memoizedState = null;
      return renderLanes2;
    }
    function mountSuspensePrimaryChildren(workInProgress2, primaryChildren) {
      primaryChildren = mountWorkInProgressOffscreenFiber({ mode: "visible", children: primaryChildren }, workInProgress2.mode);
      primaryChildren.return = workInProgress2;
      return workInProgress2.child = primaryChildren;
    }
    function mountWorkInProgressOffscreenFiber(offscreenProps, mode) {
      offscreenProps = createFiber(22, offscreenProps, null, mode);
      offscreenProps.lanes = 0;
      return offscreenProps;
    }
    function retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2) {
      reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
      current2 = mountSuspensePrimaryChildren(workInProgress2, workInProgress2.pendingProps.children);
      current2.flags |= 2;
      workInProgress2.memoizedState = null;
      return current2;
    }
    function scheduleSuspenseWorkOnFiber(fiber, renderLanes2, propagationRoot) {
      fiber.lanes |= renderLanes2;
      var alternate = fiber.alternate;
      alternate !== null && (alternate.lanes |= renderLanes2);
      scheduleContextWorkOnParentPath(fiber.return, renderLanes2, propagationRoot);
    }
    function initSuspenseListRenderState(workInProgress2, isBackwards, tail, lastContentRow, tailMode, treeForkCount2) {
      var renderState = workInProgress2.memoizedState;
      renderState === null ? workInProgress2.memoizedState = {
        isBackwards,
        rendering: null,
        renderingStartTime: 0,
        last: lastContentRow,
        tail,
        tailMode,
        treeForkCount: treeForkCount2
      } : (renderState.isBackwards = isBackwards, renderState.rendering = null, renderState.renderingStartTime = 0, renderState.last = lastContentRow, renderState.tail = tail, renderState.tailMode = tailMode, renderState.treeForkCount = treeForkCount2);
    }
    function updateSuspenseListComponent(current2, workInProgress2, renderLanes2) {
      var nextProps = workInProgress2.pendingProps, revealOrder = nextProps.revealOrder, tailMode = nextProps.tail, newChildren = nextProps.children, suspenseContext = suspenseStackCursor.current;
      (nextProps = (suspenseContext & ForceSuspenseFallback) !== 0) ? (suspenseContext = suspenseContext & SubtreeSuspenseContextMask | ForceSuspenseFallback, workInProgress2.flags |= 128) : suspenseContext &= SubtreeSuspenseContextMask;
      push(suspenseStackCursor, suspenseContext, workInProgress2);
      suspenseContext = revealOrder == null ? "null" : revealOrder;
      if (revealOrder !== "forwards" && revealOrder !== "unstable_legacy-backwards" && revealOrder !== "together" && revealOrder !== "independent" && !didWarnAboutRevealOrder[suspenseContext])
        if (didWarnAboutRevealOrder[suspenseContext] = true, revealOrder == null)
          console.error('The default for the <SuspenseList revealOrder="..."> prop is changing. To be future compatible you must explictly specify either "independent" (the current default), "together", "forwards" or "legacy_unstable-backwards".');
        else if (revealOrder === "backwards")
          console.error('The rendering order of <SuspenseList revealOrder="backwards"> is changing. To be future compatible you must specify revealOrder="legacy_unstable-backwards" instead.');
        else if (typeof revealOrder === "string")
          switch (revealOrder.toLowerCase()) {
            case "together":
            case "forwards":
            case "backwards":
            case "independent":
              console.error('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', revealOrder, revealOrder.toLowerCase());
              break;
            case "forward":
            case "backward":
              console.error('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', revealOrder, revealOrder.toLowerCase());
              break;
            default:
              console.error('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "independent", "together", "forwards" or "backwards"?', revealOrder);
          }
        else
          console.error('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "independent", "together", "forwards" or "backwards"?', revealOrder);
      suspenseContext = tailMode == null ? "null" : tailMode;
      if (!didWarnAboutTailOptions[suspenseContext])
        if (tailMode == null) {
          if (revealOrder === "forwards" || revealOrder === "backwards" || revealOrder === "unstable_legacy-backwards")
            didWarnAboutTailOptions[suspenseContext] = true, console.error('The default for the <SuspenseList tail="..."> prop is changing. To be future compatible you must explictly specify either "visible" (the current default), "collapsed" or "hidden".');
        } else
          tailMode !== "visible" && tailMode !== "collapsed" && tailMode !== "hidden" ? (didWarnAboutTailOptions[suspenseContext] = true, console.error('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "visible", "collapsed" or "hidden"?', tailMode)) : revealOrder !== "forwards" && revealOrder !== "backwards" && revealOrder !== "unstable_legacy-backwards" && (didWarnAboutTailOptions[suspenseContext] = true, console.error('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', tailMode));
      a:
        if ((revealOrder === "forwards" || revealOrder === "backwards" || revealOrder === "unstable_legacy-backwards") && newChildren !== undefined && newChildren !== null && newChildren !== false)
          if (isArrayImpl(newChildren))
            for (suspenseContext = 0;suspenseContext < newChildren.length; suspenseContext++) {
              if (!validateSuspenseListNestedChild(newChildren[suspenseContext], suspenseContext))
                break a;
            }
          else if (suspenseContext = getIteratorFn(newChildren), typeof suspenseContext === "function") {
            if (suspenseContext = suspenseContext.call(newChildren))
              for (var step = suspenseContext.next(), _i = 0;!step.done; step = suspenseContext.next()) {
                if (!validateSuspenseListNestedChild(step.value, _i))
                  break a;
                _i++;
              }
          } else
            console.error('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', revealOrder);
      reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);
      isHydrating ? (warnIfNotHydrating(), newChildren = treeForkCount) : newChildren = 0;
      if (!nextProps && current2 !== null && (current2.flags & 128) !== 0)
        a:
          for (current2 = workInProgress2.child;current2 !== null; ) {
            if (current2.tag === 13)
              current2.memoizedState !== null && scheduleSuspenseWorkOnFiber(current2, renderLanes2, workInProgress2);
            else if (current2.tag === 19)
              scheduleSuspenseWorkOnFiber(current2, renderLanes2, workInProgress2);
            else if (current2.child !== null) {
              current2.child.return = current2;
              current2 = current2.child;
              continue;
            }
            if (current2 === workInProgress2)
              break a;
            for (;current2.sibling === null; ) {
              if (current2.return === null || current2.return === workInProgress2)
                break a;
              current2 = current2.return;
            }
            current2.sibling.return = current2.return;
            current2 = current2.sibling;
          }
      switch (revealOrder) {
        case "forwards":
          renderLanes2 = workInProgress2.child;
          for (revealOrder = null;renderLanes2 !== null; )
            current2 = renderLanes2.alternate, current2 !== null && findFirstSuspended(current2) === null && (revealOrder = renderLanes2), renderLanes2 = renderLanes2.sibling;
          renderLanes2 = revealOrder;
          renderLanes2 === null ? (revealOrder = workInProgress2.child, workInProgress2.child = null) : (revealOrder = renderLanes2.sibling, renderLanes2.sibling = null);
          initSuspenseListRenderState(workInProgress2, false, revealOrder, renderLanes2, tailMode, newChildren);
          break;
        case "backwards":
        case "unstable_legacy-backwards":
          renderLanes2 = null;
          revealOrder = workInProgress2.child;
          for (workInProgress2.child = null;revealOrder !== null; ) {
            current2 = revealOrder.alternate;
            if (current2 !== null && findFirstSuspended(current2) === null) {
              workInProgress2.child = revealOrder;
              break;
            }
            current2 = revealOrder.sibling;
            revealOrder.sibling = renderLanes2;
            renderLanes2 = revealOrder;
            revealOrder = current2;
          }
          initSuspenseListRenderState(workInProgress2, true, renderLanes2, null, tailMode, newChildren);
          break;
        case "together":
          initSuspenseListRenderState(workInProgress2, false, null, null, undefined, newChildren);
          break;
        default:
          workInProgress2.memoizedState = null;
      }
      return workInProgress2.child;
    }
    function bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2) {
      current2 !== null && (workInProgress2.dependencies = current2.dependencies);
      profilerStartTime = -1;
      workInProgressRootSkippedLanes |= workInProgress2.lanes;
      if ((renderLanes2 & workInProgress2.childLanes) === 0)
        if (current2 !== null) {
          if (propagateParentContextChanges(current2, workInProgress2, renderLanes2, false), (renderLanes2 & workInProgress2.childLanes) === 0)
            return null;
        } else
          return null;
      if (current2 !== null && workInProgress2.child !== current2.child)
        throw Error("Resuming work not yet implemented.");
      if (workInProgress2.child !== null) {
        current2 = workInProgress2.child;
        renderLanes2 = createWorkInProgress(current2, current2.pendingProps);
        workInProgress2.child = renderLanes2;
        for (renderLanes2.return = workInProgress2;current2.sibling !== null; )
          current2 = current2.sibling, renderLanes2 = renderLanes2.sibling = createWorkInProgress(current2, current2.pendingProps), renderLanes2.return = workInProgress2;
        renderLanes2.sibling = null;
      }
      return workInProgress2.child;
    }
    function checkScheduledUpdateOrContext(current2, renderLanes2) {
      if ((current2.lanes & renderLanes2) !== 0)
        return true;
      current2 = current2.dependencies;
      return current2 !== null && checkIfContextChanged(current2) ? true : false;
    }
    function attemptEarlyBailoutIfNoScheduledUpdate(current2, workInProgress2, renderLanes2) {
      switch (workInProgress2.tag) {
        case 3:
          pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
          pushProvider(workInProgress2, CacheContext, current2.memoizedState.cache);
          resetHydrationState();
          break;
        case 27:
        case 5:
          pushHostContext(workInProgress2);
          break;
        case 4:
          pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
          break;
        case 10:
          pushProvider(workInProgress2, workInProgress2.type, workInProgress2.memoizedProps.value);
          break;
        case 12:
          (renderLanes2 & workInProgress2.childLanes) !== 0 && (workInProgress2.flags |= 4);
          workInProgress2.flags |= 2048;
          var stateNode = workInProgress2.stateNode;
          stateNode.effectDuration = -0;
          stateNode.passiveEffectDuration = -0;
          break;
        case 31:
          if (workInProgress2.memoizedState !== null)
            return workInProgress2.flags |= 128, pushDehydratedActivitySuspenseHandler(workInProgress2), null;
          break;
        case 13:
          stateNode = workInProgress2.memoizedState;
          if (stateNode !== null) {
            if (stateNode.dehydrated !== null)
              return pushPrimaryTreeSuspenseHandler(workInProgress2), workInProgress2.flags |= 128, null;
            if ((renderLanes2 & workInProgress2.child.childLanes) !== 0)
              return updateSuspenseComponent(current2, workInProgress2, renderLanes2);
            pushPrimaryTreeSuspenseHandler(workInProgress2);
            current2 = bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
            return current2 !== null ? current2.sibling : null;
          }
          pushPrimaryTreeSuspenseHandler(workInProgress2);
          break;
        case 19:
          var didSuspendBefore = (current2.flags & 128) !== 0;
          stateNode = (renderLanes2 & workInProgress2.childLanes) !== 0;
          stateNode || (propagateParentContextChanges(current2, workInProgress2, renderLanes2, false), stateNode = (renderLanes2 & workInProgress2.childLanes) !== 0);
          if (didSuspendBefore) {
            if (stateNode)
              return updateSuspenseListComponent(current2, workInProgress2, renderLanes2);
            workInProgress2.flags |= 128;
          }
          didSuspendBefore = workInProgress2.memoizedState;
          didSuspendBefore !== null && (didSuspendBefore.rendering = null, didSuspendBefore.tail = null, didSuspendBefore.lastEffect = null);
          push(suspenseStackCursor, suspenseStackCursor.current, workInProgress2);
          if (stateNode)
            break;
          else
            return null;
        case 22:
          return workInProgress2.lanes = 0, updateOffscreenComponent(current2, workInProgress2, renderLanes2, workInProgress2.pendingProps);
        case 24:
          pushProvider(workInProgress2, CacheContext, current2.memoizedState.cache);
      }
      return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
    }
    function beginWork(current2, workInProgress2, renderLanes2) {
      if (workInProgress2._debugNeedsRemount && current2 !== null) {
        renderLanes2 = createFiberFromTypeAndProps(workInProgress2.type, workInProgress2.key, workInProgress2.pendingProps, workInProgress2._debugOwner || null, workInProgress2.mode, workInProgress2.lanes);
        renderLanes2._debugStack = workInProgress2._debugStack;
        renderLanes2._debugTask = workInProgress2._debugTask;
        var returnFiber = workInProgress2.return;
        if (returnFiber === null)
          throw Error("Cannot swap the root fiber.");
        current2.alternate = null;
        workInProgress2.alternate = null;
        renderLanes2.index = workInProgress2.index;
        renderLanes2.sibling = workInProgress2.sibling;
        renderLanes2.return = workInProgress2.return;
        renderLanes2.ref = workInProgress2.ref;
        renderLanes2._debugInfo = workInProgress2._debugInfo;
        if (workInProgress2 === returnFiber.child)
          returnFiber.child = renderLanes2;
        else {
          var prevSibling = returnFiber.child;
          if (prevSibling === null)
            throw Error("Expected parent to have a child.");
          for (;prevSibling.sibling !== workInProgress2; )
            if (prevSibling = prevSibling.sibling, prevSibling === null)
              throw Error("Expected to find the previous sibling.");
          prevSibling.sibling = renderLanes2;
        }
        workInProgress2 = returnFiber.deletions;
        workInProgress2 === null ? (returnFiber.deletions = [current2], returnFiber.flags |= 16) : workInProgress2.push(current2);
        renderLanes2.flags |= 2;
        return renderLanes2;
      }
      if (current2 !== null)
        if (current2.memoizedProps !== workInProgress2.pendingProps || workInProgress2.type !== current2.type)
          didReceiveUpdate = true;
        else {
          if (!checkScheduledUpdateOrContext(current2, renderLanes2) && (workInProgress2.flags & 128) === 0)
            return didReceiveUpdate = false, attemptEarlyBailoutIfNoScheduledUpdate(current2, workInProgress2, renderLanes2);
          didReceiveUpdate = (current2.flags & 131072) !== 0 ? true : false;
        }
      else {
        didReceiveUpdate = false;
        if (returnFiber = isHydrating)
          warnIfNotHydrating(), returnFiber = (workInProgress2.flags & 1048576) !== 0;
        returnFiber && (returnFiber = workInProgress2.index, warnIfNotHydrating(), pushTreeId(workInProgress2, treeForkCount, returnFiber));
      }
      workInProgress2.lanes = 0;
      switch (workInProgress2.tag) {
        case 16:
          a:
            if (returnFiber = workInProgress2.pendingProps, current2 = resolveLazy(workInProgress2.elementType), workInProgress2.type = current2, typeof current2 === "function")
              shouldConstruct(current2) ? (returnFiber = resolveClassComponentProps(current2, returnFiber), workInProgress2.tag = 1, workInProgress2.type = current2 = resolveFunctionForHotReloading(current2), workInProgress2 = updateClassComponent(null, workInProgress2, current2, returnFiber, renderLanes2)) : (workInProgress2.tag = 0, validateFunctionComponentInDev(workInProgress2, current2), workInProgress2.type = current2 = resolveFunctionForHotReloading(current2), workInProgress2 = updateFunctionComponent(null, workInProgress2, current2, returnFiber, renderLanes2));
            else {
              if (current2 !== undefined && current2 !== null) {
                if (prevSibling = current2.$$typeof, prevSibling === REACT_FORWARD_REF_TYPE) {
                  workInProgress2.tag = 11;
                  workInProgress2.type = current2 = resolveForwardRefForHotReloading(current2);
                  workInProgress2 = updateForwardRef(null, workInProgress2, current2, returnFiber, renderLanes2);
                  break a;
                } else if (prevSibling === REACT_MEMO_TYPE) {
                  workInProgress2.tag = 14;
                  workInProgress2 = updateMemoComponent(null, workInProgress2, current2, returnFiber, renderLanes2);
                  break a;
                }
              }
              workInProgress2 = "";
              current2 !== null && typeof current2 === "object" && current2.$$typeof === REACT_LAZY_TYPE && (workInProgress2 = " Did you wrap a component in React.lazy() more than once?");
              renderLanes2 = getComponentNameFromType(current2) || current2;
              throw Error("Element type is invalid. Received a promise that resolves to: " + renderLanes2 + ". Lazy element type must resolve to a class or function." + workInProgress2);
            }
          return workInProgress2;
        case 0:
          return updateFunctionComponent(current2, workInProgress2, workInProgress2.type, workInProgress2.pendingProps, renderLanes2);
        case 1:
          return returnFiber = workInProgress2.type, prevSibling = resolveClassComponentProps(returnFiber, workInProgress2.pendingProps), updateClassComponent(current2, workInProgress2, returnFiber, prevSibling, renderLanes2);
        case 3:
          a: {
            pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
            if (current2 === null)
              throw Error("Should have a current fiber. This is a bug in React.");
            returnFiber = workInProgress2.pendingProps;
            var prevState = workInProgress2.memoizedState;
            prevSibling = prevState.element;
            cloneUpdateQueue(current2, workInProgress2);
            processUpdateQueue(workInProgress2, returnFiber, null, renderLanes2);
            var nextState = workInProgress2.memoizedState;
            returnFiber = nextState.cache;
            pushProvider(workInProgress2, CacheContext, returnFiber);
            returnFiber !== prevState.cache && propagateContextChanges(workInProgress2, [CacheContext], renderLanes2, true);
            suspendIfUpdateReadFromEntangledAsyncAction();
            returnFiber = nextState.element;
            if (prevState.isDehydrated)
              if (prevState = {
                element: returnFiber,
                isDehydrated: false,
                cache: nextState.cache
              }, workInProgress2.updateQueue.baseState = prevState, workInProgress2.memoizedState = prevState, workInProgress2.flags & 256) {
                workInProgress2 = mountHostRootWithoutHydrating(current2, workInProgress2, returnFiber, renderLanes2);
                break a;
              } else if (returnFiber !== prevSibling) {
                prevSibling = createCapturedValueAtFiber(Error("This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."), workInProgress2);
                queueHydrationError(prevSibling);
                workInProgress2 = mountHostRootWithoutHydrating(current2, workInProgress2, returnFiber, renderLanes2);
                break a;
              } else {
                current2 = workInProgress2.stateNode.containerInfo;
                switch (current2.nodeType) {
                  case 9:
                    current2 = current2.body;
                    break;
                  default:
                    current2 = current2.nodeName === "HTML" ? current2.ownerDocument.body : current2;
                }
                nextHydratableInstance = getNextHydratable(current2.firstChild);
                hydrationParentFiber = workInProgress2;
                isHydrating = true;
                hydrationErrors = null;
                didSuspendOrErrorDEV = false;
                hydrationDiffRootDEV = null;
                rootOrSingletonContext = true;
                renderLanes2 = mountChildFibers(workInProgress2, null, returnFiber, renderLanes2);
                for (workInProgress2.child = renderLanes2;renderLanes2; )
                  renderLanes2.flags = renderLanes2.flags & -3 | 4096, renderLanes2 = renderLanes2.sibling;
              }
            else {
              resetHydrationState();
              if (returnFiber === prevSibling) {
                workInProgress2 = bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
                break a;
              }
              reconcileChildren(current2, workInProgress2, returnFiber, renderLanes2);
            }
            workInProgress2 = workInProgress2.child;
          }
          return workInProgress2;
        case 26:
          return markRef(current2, workInProgress2), current2 === null ? (renderLanes2 = getResource(workInProgress2.type, null, workInProgress2.pendingProps, null)) ? workInProgress2.memoizedState = renderLanes2 : isHydrating || (renderLanes2 = workInProgress2.type, current2 = workInProgress2.pendingProps, returnFiber = requiredContext(rootInstanceStackCursor.current), returnFiber = getOwnerDocumentFromRootContainer(returnFiber).createElement(renderLanes2), returnFiber[internalInstanceKey] = workInProgress2, returnFiber[internalPropsKey] = current2, setInitialProperties(returnFiber, renderLanes2, current2), markNodeAsHoistable(returnFiber), workInProgress2.stateNode = returnFiber) : workInProgress2.memoizedState = getResource(workInProgress2.type, current2.memoizedProps, workInProgress2.pendingProps, current2.memoizedState), null;
        case 27:
          return pushHostContext(workInProgress2), current2 === null && isHydrating && (returnFiber = requiredContext(rootInstanceStackCursor.current), prevSibling = getHostContext(), returnFiber = workInProgress2.stateNode = resolveSingletonInstance(workInProgress2.type, workInProgress2.pendingProps, returnFiber, prevSibling, false), didSuspendOrErrorDEV || (prevSibling = diffHydratedProperties(returnFiber, workInProgress2.type, workInProgress2.pendingProps, prevSibling), prevSibling !== null && (buildHydrationDiffNode(workInProgress2, 0).serverProps = prevSibling)), hydrationParentFiber = workInProgress2, rootOrSingletonContext = true, prevSibling = nextHydratableInstance, isSingletonScope(workInProgress2.type) ? (previousHydratableOnEnteringScopedSingleton = prevSibling, nextHydratableInstance = getNextHydratable(returnFiber.firstChild)) : nextHydratableInstance = prevSibling), reconcileChildren(current2, workInProgress2, workInProgress2.pendingProps.children, renderLanes2), markRef(current2, workInProgress2), current2 === null && (workInProgress2.flags |= 4194304), workInProgress2.child;
        case 5:
          return current2 === null && isHydrating && (prevState = getHostContext(), returnFiber = validateDOMNesting(workInProgress2.type, prevState.ancestorInfo), prevSibling = nextHydratableInstance, (nextState = !prevSibling) || (nextState = canHydrateInstance(prevSibling, workInProgress2.type, workInProgress2.pendingProps, rootOrSingletonContext), nextState !== null ? (workInProgress2.stateNode = nextState, didSuspendOrErrorDEV || (prevState = diffHydratedProperties(nextState, workInProgress2.type, workInProgress2.pendingProps, prevState), prevState !== null && (buildHydrationDiffNode(workInProgress2, 0).serverProps = prevState)), hydrationParentFiber = workInProgress2, nextHydratableInstance = getNextHydratable(nextState.firstChild), rootOrSingletonContext = false, prevState = true) : prevState = false, nextState = !prevState), nextState && (returnFiber && warnNonHydratedInstance(workInProgress2, prevSibling), throwOnHydrationMismatch(workInProgress2))), pushHostContext(workInProgress2), prevSibling = workInProgress2.type, prevState = workInProgress2.pendingProps, nextState = current2 !== null ? current2.memoizedProps : null, returnFiber = prevState.children, shouldSetTextContent(prevSibling, prevState) ? returnFiber = null : nextState !== null && shouldSetTextContent(prevSibling, nextState) && (workInProgress2.flags |= 32), workInProgress2.memoizedState !== null && (prevSibling = renderWithHooks(current2, workInProgress2, TransitionAwareHostComponent, null, null, renderLanes2), HostTransitionContext._currentValue = prevSibling), markRef(current2, workInProgress2), reconcileChildren(current2, workInProgress2, returnFiber, renderLanes2), workInProgress2.child;
        case 6:
          return current2 === null && isHydrating && (renderLanes2 = workInProgress2.pendingProps, current2 = getHostContext(), returnFiber = current2.ancestorInfo.current, renderLanes2 = returnFiber != null ? validateTextNesting(renderLanes2, returnFiber.tag, current2.ancestorInfo.implicitRootScope) : true, current2 = nextHydratableInstance, (returnFiber = !current2) || (returnFiber = canHydrateTextInstance(current2, workInProgress2.pendingProps, rootOrSingletonContext), returnFiber !== null ? (workInProgress2.stateNode = returnFiber, hydrationParentFiber = workInProgress2, nextHydratableInstance = null, returnFiber = true) : returnFiber = false, returnFiber = !returnFiber), returnFiber && (renderLanes2 && warnNonHydratedInstance(workInProgress2, current2), throwOnHydrationMismatch(workInProgress2))), null;
        case 13:
          return updateSuspenseComponent(current2, workInProgress2, renderLanes2);
        case 4:
          return pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo), returnFiber = workInProgress2.pendingProps, current2 === null ? workInProgress2.child = reconcileChildFibers(workInProgress2, null, returnFiber, renderLanes2) : reconcileChildren(current2, workInProgress2, returnFiber, renderLanes2), workInProgress2.child;
        case 11:
          return updateForwardRef(current2, workInProgress2, workInProgress2.type, workInProgress2.pendingProps, renderLanes2);
        case 7:
          return reconcileChildren(current2, workInProgress2, workInProgress2.pendingProps, renderLanes2), workInProgress2.child;
        case 8:
          return reconcileChildren(current2, workInProgress2, workInProgress2.pendingProps.children, renderLanes2), workInProgress2.child;
        case 12:
          return workInProgress2.flags |= 4, workInProgress2.flags |= 2048, returnFiber = workInProgress2.stateNode, returnFiber.effectDuration = -0, returnFiber.passiveEffectDuration = -0, reconcileChildren(current2, workInProgress2, workInProgress2.pendingProps.children, renderLanes2), workInProgress2.child;
        case 10:
          return returnFiber = workInProgress2.type, prevSibling = workInProgress2.pendingProps, prevState = prevSibling.value, "value" in prevSibling || hasWarnedAboutUsingNoValuePropOnContextProvider || (hasWarnedAboutUsingNoValuePropOnContextProvider = true, console.error("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?")), pushProvider(workInProgress2, returnFiber, prevState), reconcileChildren(current2, workInProgress2, prevSibling.children, renderLanes2), workInProgress2.child;
        case 9:
          return prevSibling = workInProgress2.type._context, returnFiber = workInProgress2.pendingProps.children, typeof returnFiber !== "function" && console.error("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."), prepareToReadContext(workInProgress2), prevSibling = readContext(prevSibling), returnFiber = callComponentInDEV(returnFiber, prevSibling, undefined), workInProgress2.flags |= 1, reconcileChildren(current2, workInProgress2, returnFiber, renderLanes2), workInProgress2.child;
        case 14:
          return updateMemoComponent(current2, workInProgress2, workInProgress2.type, workInProgress2.pendingProps, renderLanes2);
        case 15:
          return updateSimpleMemoComponent(current2, workInProgress2, workInProgress2.type, workInProgress2.pendingProps, renderLanes2);
        case 19:
          return updateSuspenseListComponent(current2, workInProgress2, renderLanes2);
        case 31:
          return updateActivityComponent(current2, workInProgress2, renderLanes2);
        case 22:
          return updateOffscreenComponent(current2, workInProgress2, renderLanes2, workInProgress2.pendingProps);
        case 24:
          return prepareToReadContext(workInProgress2), returnFiber = readContext(CacheContext), current2 === null ? (prevSibling = peekCacheFromPool(), prevSibling === null && (prevSibling = workInProgressRoot, prevState = createCache(), prevSibling.pooledCache = prevState, retainCache(prevState), prevState !== null && (prevSibling.pooledCacheLanes |= renderLanes2), prevSibling = prevState), workInProgress2.memoizedState = {
            parent: returnFiber,
            cache: prevSibling
          }, initializeUpdateQueue(workInProgress2), pushProvider(workInProgress2, CacheContext, prevSibling)) : ((current2.lanes & renderLanes2) !== 0 && (cloneUpdateQueue(current2, workInProgress2), processUpdateQueue(workInProgress2, null, null, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction()), prevSibling = current2.memoizedState, prevState = workInProgress2.memoizedState, prevSibling.parent !== returnFiber ? (prevSibling = {
            parent: returnFiber,
            cache: returnFiber
          }, workInProgress2.memoizedState = prevSibling, workInProgress2.lanes === 0 && (workInProgress2.memoizedState = workInProgress2.updateQueue.baseState = prevSibling), pushProvider(workInProgress2, CacheContext, returnFiber)) : (returnFiber = prevState.cache, pushProvider(workInProgress2, CacheContext, returnFiber), returnFiber !== prevSibling.cache && propagateContextChanges(workInProgress2, [CacheContext], renderLanes2, true))), reconcileChildren(current2, workInProgress2, workInProgress2.pendingProps.children, renderLanes2), workInProgress2.child;
        case 29:
          throw workInProgress2.pendingProps;
      }
      throw Error("Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function markUpdate(workInProgress2) {
      workInProgress2.flags |= 4;
    }
    function preloadInstanceAndSuspendIfNeeded(workInProgress2, type, oldProps, newProps, renderLanes2) {
      if (type = (workInProgress2.mode & SuspenseyImagesMode) !== NoMode)
        type = false;
      if (type) {
        if (workInProgress2.flags |= 16777216, (renderLanes2 & 335544128) === renderLanes2)
          if (workInProgress2.stateNode.complete)
            workInProgress2.flags |= 8192;
          else if (shouldRemainOnPreviousScreen())
            workInProgress2.flags |= 8192;
          else
            throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;
      } else
        workInProgress2.flags &= -16777217;
    }
    function preloadResourceAndSuspendIfNeeded(workInProgress2, resource) {
      if (resource.type !== "stylesheet" || (resource.state.loading & Inserted) !== NotLoaded)
        workInProgress2.flags &= -16777217;
      else if (workInProgress2.flags |= 16777216, !preloadResource(resource))
        if (shouldRemainOnPreviousScreen())
          workInProgress2.flags |= 8192;
        else
          throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;
    }
    function scheduleRetryEffect(workInProgress2, retryQueue) {
      retryQueue !== null && (workInProgress2.flags |= 4);
      workInProgress2.flags & 16384 && (retryQueue = workInProgress2.tag !== 22 ? claimNextRetryLane() : 536870912, workInProgress2.lanes |= retryQueue, workInProgressSuspendedRetryLanes |= retryQueue);
    }
    function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
      if (!isHydrating)
        switch (renderState.tailMode) {
          case "hidden":
            hasRenderedATailFallback = renderState.tail;
            for (var lastTailNode = null;hasRenderedATailFallback !== null; )
              hasRenderedATailFallback.alternate !== null && (lastTailNode = hasRenderedATailFallback), hasRenderedATailFallback = hasRenderedATailFallback.sibling;
            lastTailNode === null ? renderState.tail = null : lastTailNode.sibling = null;
            break;
          case "collapsed":
            lastTailNode = renderState.tail;
            for (var _lastTailNode = null;lastTailNode !== null; )
              lastTailNode.alternate !== null && (_lastTailNode = lastTailNode), lastTailNode = lastTailNode.sibling;
            _lastTailNode === null ? hasRenderedATailFallback || renderState.tail === null ? renderState.tail = null : renderState.tail.sibling = null : _lastTailNode.sibling = null;
        }
    }
    function bubbleProperties(completedWork) {
      var didBailout = completedWork.alternate !== null && completedWork.alternate.child === completedWork.child, newChildLanes = 0, subtreeFlags = 0;
      if (didBailout)
        if ((completedWork.mode & ProfileMode) !== NoMode) {
          for (var { selfBaseDuration: _treeBaseDuration, child: _child2 } = completedWork;_child2 !== null; )
            newChildLanes |= _child2.lanes | _child2.childLanes, subtreeFlags |= _child2.subtreeFlags & 65011712, subtreeFlags |= _child2.flags & 65011712, _treeBaseDuration += _child2.treeBaseDuration, _child2 = _child2.sibling;
          completedWork.treeBaseDuration = _treeBaseDuration;
        } else
          for (_treeBaseDuration = completedWork.child;_treeBaseDuration !== null; )
            newChildLanes |= _treeBaseDuration.lanes | _treeBaseDuration.childLanes, subtreeFlags |= _treeBaseDuration.subtreeFlags & 65011712, subtreeFlags |= _treeBaseDuration.flags & 65011712, _treeBaseDuration.return = completedWork, _treeBaseDuration = _treeBaseDuration.sibling;
      else if ((completedWork.mode & ProfileMode) !== NoMode) {
        _treeBaseDuration = completedWork.actualDuration;
        _child2 = completedWork.selfBaseDuration;
        for (var child = completedWork.child;child !== null; )
          newChildLanes |= child.lanes | child.childLanes, subtreeFlags |= child.subtreeFlags, subtreeFlags |= child.flags, _treeBaseDuration += child.actualDuration, _child2 += child.treeBaseDuration, child = child.sibling;
        completedWork.actualDuration = _treeBaseDuration;
        completedWork.treeBaseDuration = _child2;
      } else
        for (_treeBaseDuration = completedWork.child;_treeBaseDuration !== null; )
          newChildLanes |= _treeBaseDuration.lanes | _treeBaseDuration.childLanes, subtreeFlags |= _treeBaseDuration.subtreeFlags, subtreeFlags |= _treeBaseDuration.flags, _treeBaseDuration.return = completedWork, _treeBaseDuration = _treeBaseDuration.sibling;
      completedWork.subtreeFlags |= subtreeFlags;
      completedWork.childLanes = newChildLanes;
      return didBailout;
    }
    function completeWork(current2, workInProgress2, renderLanes2) {
      var newProps = workInProgress2.pendingProps;
      popTreeContext(workInProgress2);
      switch (workInProgress2.tag) {
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
          return bubbleProperties(workInProgress2), null;
        case 1:
          return bubbleProperties(workInProgress2), null;
        case 3:
          renderLanes2 = workInProgress2.stateNode;
          newProps = null;
          current2 !== null && (newProps = current2.memoizedState.cache);
          workInProgress2.memoizedState.cache !== newProps && (workInProgress2.flags |= 2048);
          popProvider(CacheContext, workInProgress2);
          popHostContainer(workInProgress2);
          renderLanes2.pendingContext && (renderLanes2.context = renderLanes2.pendingContext, renderLanes2.pendingContext = null);
          if (current2 === null || current2.child === null)
            popHydrationState(workInProgress2) ? (emitPendingHydrationWarnings(), markUpdate(workInProgress2)) : current2 === null || current2.memoizedState.isDehydrated && (workInProgress2.flags & 256) === 0 || (workInProgress2.flags |= 1024, upgradeHydrationErrorsToRecoverable());
          bubbleProperties(workInProgress2);
          return null;
        case 26:
          var { type, memoizedState: nextResource } = workInProgress2;
          current2 === null ? (markUpdate(workInProgress2), nextResource !== null ? (bubbleProperties(workInProgress2), preloadResourceAndSuspendIfNeeded(workInProgress2, nextResource)) : (bubbleProperties(workInProgress2), preloadInstanceAndSuspendIfNeeded(workInProgress2, type, null, newProps, renderLanes2))) : nextResource ? nextResource !== current2.memoizedState ? (markUpdate(workInProgress2), bubbleProperties(workInProgress2), preloadResourceAndSuspendIfNeeded(workInProgress2, nextResource)) : (bubbleProperties(workInProgress2), workInProgress2.flags &= -16777217) : (current2 = current2.memoizedProps, current2 !== newProps && markUpdate(workInProgress2), bubbleProperties(workInProgress2), preloadInstanceAndSuspendIfNeeded(workInProgress2, type, current2, newProps, renderLanes2));
          return null;
        case 27:
          popHostContext(workInProgress2);
          renderLanes2 = requiredContext(rootInstanceStackCursor.current);
          type = workInProgress2.type;
          if (current2 !== null && workInProgress2.stateNode != null)
            current2.memoizedProps !== newProps && markUpdate(workInProgress2);
          else {
            if (!newProps) {
              if (workInProgress2.stateNode === null)
                throw Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
              bubbleProperties(workInProgress2);
              return null;
            }
            current2 = getHostContext();
            popHydrationState(workInProgress2) ? prepareToHydrateHostInstance(workInProgress2, current2) : (current2 = resolveSingletonInstance(type, newProps, renderLanes2, current2, true), workInProgress2.stateNode = current2, markUpdate(workInProgress2));
          }
          bubbleProperties(workInProgress2);
          return null;
        case 5:
          popHostContext(workInProgress2);
          type = workInProgress2.type;
          if (current2 !== null && workInProgress2.stateNode != null)
            current2.memoizedProps !== newProps && markUpdate(workInProgress2);
          else {
            if (!newProps) {
              if (workInProgress2.stateNode === null)
                throw Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
              bubbleProperties(workInProgress2);
              return null;
            }
            var _currentHostContext = getHostContext();
            if (popHydrationState(workInProgress2))
              prepareToHydrateHostInstance(workInProgress2, _currentHostContext);
            else {
              nextResource = requiredContext(rootInstanceStackCursor.current);
              validateDOMNesting(type, _currentHostContext.ancestorInfo);
              _currentHostContext = _currentHostContext.context;
              nextResource = getOwnerDocumentFromRootContainer(nextResource);
              switch (_currentHostContext) {
                case HostContextNamespaceSvg:
                  nextResource = nextResource.createElementNS(SVG_NAMESPACE, type);
                  break;
                case HostContextNamespaceMath:
                  nextResource = nextResource.createElementNS(MATH_NAMESPACE, type);
                  break;
                default:
                  switch (type) {
                    case "svg":
                      nextResource = nextResource.createElementNS(SVG_NAMESPACE, type);
                      break;
                    case "math":
                      nextResource = nextResource.createElementNS(MATH_NAMESPACE, type);
                      break;
                    case "script":
                      nextResource = nextResource.createElement("div");
                      nextResource.innerHTML = "<script></script>";
                      nextResource = nextResource.removeChild(nextResource.firstChild);
                      break;
                    case "select":
                      nextResource = typeof newProps.is === "string" ? nextResource.createElement("select", {
                        is: newProps.is
                      }) : nextResource.createElement("select");
                      newProps.multiple ? nextResource.multiple = true : newProps.size && (nextResource.size = newProps.size);
                      break;
                    default:
                      nextResource = typeof newProps.is === "string" ? nextResource.createElement(type, {
                        is: newProps.is
                      }) : nextResource.createElement(type), type.indexOf("-") === -1 && (type !== type.toLowerCase() && console.error("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", type), Object.prototype.toString.call(nextResource) !== "[object HTMLUnknownElement]" || hasOwnProperty.call(warnedUnknownTags, type) || (warnedUnknownTags[type] = true, console.error("The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.", type)));
                  }
              }
              nextResource[internalInstanceKey] = workInProgress2;
              nextResource[internalPropsKey] = newProps;
              a:
                for (_currentHostContext = workInProgress2.child;_currentHostContext !== null; ) {
                  if (_currentHostContext.tag === 5 || _currentHostContext.tag === 6)
                    nextResource.appendChild(_currentHostContext.stateNode);
                  else if (_currentHostContext.tag !== 4 && _currentHostContext.tag !== 27 && _currentHostContext.child !== null) {
                    _currentHostContext.child.return = _currentHostContext;
                    _currentHostContext = _currentHostContext.child;
                    continue;
                  }
                  if (_currentHostContext === workInProgress2)
                    break a;
                  for (;_currentHostContext.sibling === null; ) {
                    if (_currentHostContext.return === null || _currentHostContext.return === workInProgress2)
                      break a;
                    _currentHostContext = _currentHostContext.return;
                  }
                  _currentHostContext.sibling.return = _currentHostContext.return;
                  _currentHostContext = _currentHostContext.sibling;
                }
              workInProgress2.stateNode = nextResource;
              a:
                switch (setInitialProperties(nextResource, type, newProps), type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    newProps = !!newProps.autoFocus;
                    break a;
                  case "img":
                    newProps = true;
                    break a;
                  default:
                    newProps = false;
                }
              newProps && markUpdate(workInProgress2);
            }
          }
          bubbleProperties(workInProgress2);
          preloadInstanceAndSuspendIfNeeded(workInProgress2, workInProgress2.type, current2 === null ? null : current2.memoizedProps, workInProgress2.pendingProps, renderLanes2);
          return null;
        case 6:
          if (current2 && workInProgress2.stateNode != null)
            current2.memoizedProps !== newProps && markUpdate(workInProgress2);
          else {
            if (typeof newProps !== "string" && workInProgress2.stateNode === null)
              throw Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
            current2 = requiredContext(rootInstanceStackCursor.current);
            renderLanes2 = getHostContext();
            if (popHydrationState(workInProgress2)) {
              current2 = workInProgress2.stateNode;
              renderLanes2 = workInProgress2.memoizedProps;
              type = !didSuspendOrErrorDEV;
              newProps = null;
              nextResource = hydrationParentFiber;
              if (nextResource !== null)
                switch (nextResource.tag) {
                  case 3:
                    type && (type = diffHydratedTextForDevWarnings(current2, renderLanes2, newProps), type !== null && (buildHydrationDiffNode(workInProgress2, 0).serverProps = type));
                    break;
                  case 27:
                  case 5:
                    newProps = nextResource.memoizedProps, type && (type = diffHydratedTextForDevWarnings(current2, renderLanes2, newProps), type !== null && (buildHydrationDiffNode(workInProgress2, 0).serverProps = type));
                }
              current2[internalInstanceKey] = workInProgress2;
              current2 = current2.nodeValue === renderLanes2 || newProps !== null && newProps.suppressHydrationWarning === true || checkForUnmatchedText(current2.nodeValue, renderLanes2) ? true : false;
              current2 || throwOnHydrationMismatch(workInProgress2, true);
            } else
              type = renderLanes2.ancestorInfo.current, type != null && validateTextNesting(newProps, type.tag, renderLanes2.ancestorInfo.implicitRootScope), current2 = getOwnerDocumentFromRootContainer(current2).createTextNode(newProps), current2[internalInstanceKey] = workInProgress2, workInProgress2.stateNode = current2;
          }
          bubbleProperties(workInProgress2);
          return null;
        case 31:
          renderLanes2 = workInProgress2.memoizedState;
          if (current2 === null || current2.memoizedState !== null) {
            newProps = popHydrationState(workInProgress2);
            if (renderLanes2 !== null) {
              if (current2 === null) {
                if (!newProps)
                  throw Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
                current2 = workInProgress2.memoizedState;
                current2 = current2 !== null ? current2.dehydrated : null;
                if (!current2)
                  throw Error("Expected to have a hydrated activity instance. This error is likely caused by a bug in React. Please file an issue.");
                current2[internalInstanceKey] = workInProgress2;
                bubbleProperties(workInProgress2);
                (workInProgress2.mode & ProfileMode) !== NoMode && renderLanes2 !== null && (current2 = workInProgress2.child, current2 !== null && (workInProgress2.treeBaseDuration -= current2.treeBaseDuration));
              } else
                emitPendingHydrationWarnings(), resetHydrationState(), (workInProgress2.flags & 128) === 0 && (renderLanes2 = workInProgress2.memoizedState = null), workInProgress2.flags |= 4, bubbleProperties(workInProgress2), (workInProgress2.mode & ProfileMode) !== NoMode && renderLanes2 !== null && (current2 = workInProgress2.child, current2 !== null && (workInProgress2.treeBaseDuration -= current2.treeBaseDuration));
              current2 = false;
            } else
              renderLanes2 = upgradeHydrationErrorsToRecoverable(), current2 !== null && current2.memoizedState !== null && (current2.memoizedState.hydrationErrors = renderLanes2), current2 = true;
            if (!current2) {
              if (workInProgress2.flags & 256)
                return popSuspenseHandler(workInProgress2), workInProgress2;
              popSuspenseHandler(workInProgress2);
              return null;
            }
            if ((workInProgress2.flags & 128) !== 0)
              throw Error("Client rendering an Activity suspended it again. This is a bug in React.");
          }
          bubbleProperties(workInProgress2);
          return null;
        case 13:
          newProps = workInProgress2.memoizedState;
          if (current2 === null || current2.memoizedState !== null && current2.memoizedState.dehydrated !== null) {
            type = newProps;
            nextResource = popHydrationState(workInProgress2);
            if (type !== null && type.dehydrated !== null) {
              if (current2 === null) {
                if (!nextResource)
                  throw Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
                nextResource = workInProgress2.memoizedState;
                nextResource = nextResource !== null ? nextResource.dehydrated : null;
                if (!nextResource)
                  throw Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
                nextResource[internalInstanceKey] = workInProgress2;
                bubbleProperties(workInProgress2);
                (workInProgress2.mode & ProfileMode) !== NoMode && type !== null && (type = workInProgress2.child, type !== null && (workInProgress2.treeBaseDuration -= type.treeBaseDuration));
              } else
                emitPendingHydrationWarnings(), resetHydrationState(), (workInProgress2.flags & 128) === 0 && (type = workInProgress2.memoizedState = null), workInProgress2.flags |= 4, bubbleProperties(workInProgress2), (workInProgress2.mode & ProfileMode) !== NoMode && type !== null && (type = workInProgress2.child, type !== null && (workInProgress2.treeBaseDuration -= type.treeBaseDuration));
              type = false;
            } else
              type = upgradeHydrationErrorsToRecoverable(), current2 !== null && current2.memoizedState !== null && (current2.memoizedState.hydrationErrors = type), type = true;
            if (!type) {
              if (workInProgress2.flags & 256)
                return popSuspenseHandler(workInProgress2), workInProgress2;
              popSuspenseHandler(workInProgress2);
              return null;
            }
          }
          popSuspenseHandler(workInProgress2);
          if ((workInProgress2.flags & 128) !== 0)
            return workInProgress2.lanes = renderLanes2, (workInProgress2.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress2), workInProgress2;
          renderLanes2 = newProps !== null;
          current2 = current2 !== null && current2.memoizedState !== null;
          renderLanes2 && (newProps = workInProgress2.child, type = null, newProps.alternate !== null && newProps.alternate.memoizedState !== null && newProps.alternate.memoizedState.cachePool !== null && (type = newProps.alternate.memoizedState.cachePool.pool), nextResource = null, newProps.memoizedState !== null && newProps.memoizedState.cachePool !== null && (nextResource = newProps.memoizedState.cachePool.pool), nextResource !== type && (newProps.flags |= 2048));
          renderLanes2 !== current2 && renderLanes2 && (workInProgress2.child.flags |= 8192);
          scheduleRetryEffect(workInProgress2, workInProgress2.updateQueue);
          bubbleProperties(workInProgress2);
          (workInProgress2.mode & ProfileMode) !== NoMode && renderLanes2 && (current2 = workInProgress2.child, current2 !== null && (workInProgress2.treeBaseDuration -= current2.treeBaseDuration));
          return null;
        case 4:
          return popHostContainer(workInProgress2), current2 === null && listenToAllSupportedEvents(workInProgress2.stateNode.containerInfo), bubbleProperties(workInProgress2), null;
        case 10:
          return popProvider(workInProgress2.type, workInProgress2), bubbleProperties(workInProgress2), null;
        case 19:
          pop(suspenseStackCursor, workInProgress2);
          newProps = workInProgress2.memoizedState;
          if (newProps === null)
            return bubbleProperties(workInProgress2), null;
          type = (workInProgress2.flags & 128) !== 0;
          nextResource = newProps.rendering;
          if (nextResource === null)
            if (type)
              cutOffTailIfNeeded(newProps, false);
            else {
              if (workInProgressRootExitStatus !== RootInProgress || current2 !== null && (current2.flags & 128) !== 0)
                for (current2 = workInProgress2.child;current2 !== null; ) {
                  nextResource = findFirstSuspended(current2);
                  if (nextResource !== null) {
                    workInProgress2.flags |= 128;
                    cutOffTailIfNeeded(newProps, false);
                    current2 = nextResource.updateQueue;
                    workInProgress2.updateQueue = current2;
                    scheduleRetryEffect(workInProgress2, current2);
                    workInProgress2.subtreeFlags = 0;
                    current2 = renderLanes2;
                    for (renderLanes2 = workInProgress2.child;renderLanes2 !== null; )
                      resetWorkInProgress(renderLanes2, current2), renderLanes2 = renderLanes2.sibling;
                    push(suspenseStackCursor, suspenseStackCursor.current & SubtreeSuspenseContextMask | ForceSuspenseFallback, workInProgress2);
                    isHydrating && pushTreeFork(workInProgress2, newProps.treeForkCount);
                    return workInProgress2.child;
                  }
                  current2 = current2.sibling;
                }
              newProps.tail !== null && now$1() > workInProgressRootRenderTargetTime && (workInProgress2.flags |= 128, type = true, cutOffTailIfNeeded(newProps, false), workInProgress2.lanes = 4194304);
            }
          else {
            if (!type)
              if (current2 = findFirstSuspended(nextResource), current2 !== null) {
                if (workInProgress2.flags |= 128, type = true, current2 = current2.updateQueue, workInProgress2.updateQueue = current2, scheduleRetryEffect(workInProgress2, current2), cutOffTailIfNeeded(newProps, true), newProps.tail === null && newProps.tailMode === "hidden" && !nextResource.alternate && !isHydrating)
                  return bubbleProperties(workInProgress2), null;
              } else
                2 * now$1() - newProps.renderingStartTime > workInProgressRootRenderTargetTime && renderLanes2 !== 536870912 && (workInProgress2.flags |= 128, type = true, cutOffTailIfNeeded(newProps, false), workInProgress2.lanes = 4194304);
            newProps.isBackwards ? (nextResource.sibling = workInProgress2.child, workInProgress2.child = nextResource) : (current2 = newProps.last, current2 !== null ? current2.sibling = nextResource : workInProgress2.child = nextResource, newProps.last = nextResource);
          }
          if (newProps.tail !== null)
            return current2 = newProps.tail, newProps.rendering = current2, newProps.tail = current2.sibling, newProps.renderingStartTime = now$1(), current2.sibling = null, renderLanes2 = suspenseStackCursor.current, renderLanes2 = type ? renderLanes2 & SubtreeSuspenseContextMask | ForceSuspenseFallback : renderLanes2 & SubtreeSuspenseContextMask, push(suspenseStackCursor, renderLanes2, workInProgress2), isHydrating && pushTreeFork(workInProgress2, newProps.treeForkCount), current2;
          bubbleProperties(workInProgress2);
          return null;
        case 22:
        case 23:
          return popSuspenseHandler(workInProgress2), popHiddenContext(workInProgress2), newProps = workInProgress2.memoizedState !== null, current2 !== null ? current2.memoizedState !== null !== newProps && (workInProgress2.flags |= 8192) : newProps && (workInProgress2.flags |= 8192), newProps ? (renderLanes2 & 536870912) !== 0 && (workInProgress2.flags & 128) === 0 && (bubbleProperties(workInProgress2), workInProgress2.subtreeFlags & 6 && (workInProgress2.flags |= 8192)) : bubbleProperties(workInProgress2), renderLanes2 = workInProgress2.updateQueue, renderLanes2 !== null && scheduleRetryEffect(workInProgress2, renderLanes2.retryQueue), renderLanes2 = null, current2 !== null && current2.memoizedState !== null && current2.memoizedState.cachePool !== null && (renderLanes2 = current2.memoizedState.cachePool.pool), newProps = null, workInProgress2.memoizedState !== null && workInProgress2.memoizedState.cachePool !== null && (newProps = workInProgress2.memoizedState.cachePool.pool), newProps !== renderLanes2 && (workInProgress2.flags |= 2048), current2 !== null && pop(resumedCache, workInProgress2), null;
        case 24:
          return renderLanes2 = null, current2 !== null && (renderLanes2 = current2.memoizedState.cache), workInProgress2.memoizedState.cache !== renderLanes2 && (workInProgress2.flags |= 2048), popProvider(CacheContext, workInProgress2), bubbleProperties(workInProgress2), null;
        case 25:
          return null;
        case 30:
          return null;
      }
      throw Error("Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function unwindWork(current2, workInProgress2) {
      popTreeContext(workInProgress2);
      switch (workInProgress2.tag) {
        case 1:
          return current2 = workInProgress2.flags, current2 & 65536 ? (workInProgress2.flags = current2 & -65537 | 128, (workInProgress2.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress2), workInProgress2) : null;
        case 3:
          return popProvider(CacheContext, workInProgress2), popHostContainer(workInProgress2), current2 = workInProgress2.flags, (current2 & 65536) !== 0 && (current2 & 128) === 0 ? (workInProgress2.flags = current2 & -65537 | 128, workInProgress2) : null;
        case 26:
        case 27:
        case 5:
          return popHostContext(workInProgress2), null;
        case 31:
          if (workInProgress2.memoizedState !== null) {
            popSuspenseHandler(workInProgress2);
            if (workInProgress2.alternate === null)
              throw Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
            resetHydrationState();
          }
          current2 = workInProgress2.flags;
          return current2 & 65536 ? (workInProgress2.flags = current2 & -65537 | 128, (workInProgress2.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress2), workInProgress2) : null;
        case 13:
          popSuspenseHandler(workInProgress2);
          current2 = workInProgress2.memoizedState;
          if (current2 !== null && current2.dehydrated !== null) {
            if (workInProgress2.alternate === null)
              throw Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
            resetHydrationState();
          }
          current2 = workInProgress2.flags;
          return current2 & 65536 ? (workInProgress2.flags = current2 & -65537 | 128, (workInProgress2.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress2), workInProgress2) : null;
        case 19:
          return pop(suspenseStackCursor, workInProgress2), null;
        case 4:
          return popHostContainer(workInProgress2), null;
        case 10:
          return popProvider(workInProgress2.type, workInProgress2), null;
        case 22:
        case 23:
          return popSuspenseHandler(workInProgress2), popHiddenContext(workInProgress2), current2 !== null && pop(resumedCache, workInProgress2), current2 = workInProgress2.flags, current2 & 65536 ? (workInProgress2.flags = current2 & -65537 | 128, (workInProgress2.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress2), workInProgress2) : null;
        case 24:
          return popProvider(CacheContext, workInProgress2), null;
        case 25:
          return null;
        default:
          return null;
      }
    }
    function unwindInterruptedWork(current2, interruptedWork) {
      popTreeContext(interruptedWork);
      switch (interruptedWork.tag) {
        case 3:
          popProvider(CacheContext, interruptedWork);
          popHostContainer(interruptedWork);
          break;
        case 26:
        case 27:
        case 5:
          popHostContext(interruptedWork);
          break;
        case 4:
          popHostContainer(interruptedWork);
          break;
        case 31:
          interruptedWork.memoizedState !== null && popSuspenseHandler(interruptedWork);
          break;
        case 13:
          popSuspenseHandler(interruptedWork);
          break;
        case 19:
          pop(suspenseStackCursor, interruptedWork);
          break;
        case 10:
          popProvider(interruptedWork.type, interruptedWork);
          break;
        case 22:
        case 23:
          popSuspenseHandler(interruptedWork);
          popHiddenContext(interruptedWork);
          current2 !== null && pop(resumedCache, interruptedWork);
          break;
        case 24:
          popProvider(CacheContext, interruptedWork);
      }
    }
    function shouldProfile(current2) {
      return (current2.mode & ProfileMode) !== NoMode;
    }
    function commitHookLayoutEffects(finishedWork, hookFlags) {
      shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListMount(hookFlags, finishedWork), recordEffectDuration()) : commitHookEffectListMount(hookFlags, finishedWork);
    }
    function commitHookLayoutUnmountEffects(finishedWork, nearestMountedAncestor, hookFlags) {
      shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListUnmount(hookFlags, finishedWork, nearestMountedAncestor), recordEffectDuration()) : commitHookEffectListUnmount(hookFlags, finishedWork, nearestMountedAncestor);
    }
    function commitHookEffectListMount(flags, finishedWork) {
      try {
        var updateQueue = finishedWork.updateQueue, lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
        if (lastEffect !== null) {
          var firstEffect = lastEffect.next;
          updateQueue = firstEffect;
          do {
            if ((updateQueue.tag & flags) === flags && (lastEffect = undefined, (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = true), lastEffect = runWithFiberInDEV(finishedWork, callCreateInDEV, updateQueue), (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = false), lastEffect !== undefined && typeof lastEffect !== "function")) {
              var hookName = undefined;
              hookName = (updateQueue.tag & Layout) !== 0 ? "useLayoutEffect" : (updateQueue.tag & Insertion) !== 0 ? "useInsertionEffect" : "useEffect";
              var addendum = undefined;
              addendum = lastEffect === null ? " You returned null. If your effect does not require clean up, return undefined (or nothing)." : typeof lastEffect.then === "function" ? `

It looks like you wrote ` + hookName + `(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:

` + hookName + `(() => {
  async function fetchData() {
    // You can await here
    const response = await MyAPI.getData(someId);
    // ...
  }
  fetchData();
}, [someId]); // Or [] if effect doesn't need props or state

Learn more about data fetching with Hooks: https://react.dev/link/hooks-data-fetching` : " You returned: " + lastEffect;
              runWithFiberInDEV(finishedWork, function(n, a) {
                console.error("%s must not return anything besides a function, which is used for clean-up.%s", n, a);
              }, hookName, addendum);
            }
            updateQueue = updateQueue.next;
          } while (updateQueue !== firstEffect);
        }
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor) {
      try {
        var updateQueue = finishedWork.updateQueue, lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
        if (lastEffect !== null) {
          var firstEffect = lastEffect.next;
          updateQueue = firstEffect;
          do {
            if ((updateQueue.tag & flags) === flags) {
              var inst = updateQueue.inst, destroy = inst.destroy;
              destroy !== undefined && (inst.destroy = undefined, (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = true), lastEffect = finishedWork, runWithFiberInDEV(lastEffect, callDestroyInDEV, lastEffect, nearestMountedAncestor, destroy), (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = false));
            }
            updateQueue = updateQueue.next;
          } while (updateQueue !== firstEffect);
        }
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function commitHookPassiveMountEffects(finishedWork, hookFlags) {
      shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListMount(hookFlags, finishedWork), recordEffectDuration()) : commitHookEffectListMount(hookFlags, finishedWork);
    }
    function commitHookPassiveUnmountEffects(finishedWork, nearestMountedAncestor, hookFlags) {
      shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListUnmount(hookFlags, finishedWork, nearestMountedAncestor), recordEffectDuration()) : commitHookEffectListUnmount(hookFlags, finishedWork, nearestMountedAncestor);
    }
    function commitClassCallbacks(finishedWork) {
      var updateQueue = finishedWork.updateQueue;
      if (updateQueue !== null) {
        var instance = finishedWork.stateNode;
        finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (instance.props !== finishedWork.memoizedProps && console.error("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance"), instance.state !== finishedWork.memoizedState && console.error("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance"));
        try {
          runWithFiberInDEV(finishedWork, commitCallbacks, updateQueue, instance);
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
    }
    function callGetSnapshotBeforeUpdates(instance, prevProps, prevState) {
      return instance.getSnapshotBeforeUpdate(prevProps, prevState);
    }
    function commitClassSnapshot(finishedWork, current2) {
      var { memoizedProps: prevProps, memoizedState: prevState } = current2;
      current2 = finishedWork.stateNode;
      finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (current2.props !== finishedWork.memoizedProps && console.error("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance"), current2.state !== finishedWork.memoizedState && console.error("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance"));
      try {
        var resolvedPrevProps = resolveClassComponentProps(finishedWork.type, prevProps);
        var snapshot = runWithFiberInDEV(finishedWork, callGetSnapshotBeforeUpdates, current2, resolvedPrevProps, prevState);
        prevProps = didWarnAboutUndefinedSnapshotBeforeUpdate;
        snapshot !== undefined || prevProps.has(finishedWork.type) || (prevProps.add(finishedWork.type), runWithFiberInDEV(finishedWork, function() {
          console.error("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", getComponentNameFromFiber(finishedWork));
        }));
        current2.__reactInternalSnapshotBeforeUpdate = snapshot;
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function safelyCallComponentWillUnmount(current2, nearestMountedAncestor, instance) {
      instance.props = resolveClassComponentProps(current2.type, current2.memoizedProps);
      instance.state = current2.memoizedState;
      shouldProfile(current2) ? (startEffectTimer(), runWithFiberInDEV(current2, callComponentWillUnmountInDEV, current2, nearestMountedAncestor, instance), recordEffectDuration()) : runWithFiberInDEV(current2, callComponentWillUnmountInDEV, current2, nearestMountedAncestor, instance);
    }
    function commitAttachRef(finishedWork) {
      var ref = finishedWork.ref;
      if (ref !== null) {
        switch (finishedWork.tag) {
          case 26:
          case 27:
          case 5:
            var instanceToUse = finishedWork.stateNode;
            break;
          case 30:
            instanceToUse = finishedWork.stateNode;
            break;
          default:
            instanceToUse = finishedWork.stateNode;
        }
        if (typeof ref === "function")
          if (shouldProfile(finishedWork))
            try {
              startEffectTimer(), finishedWork.refCleanup = ref(instanceToUse);
            } finally {
              recordEffectDuration();
            }
          else
            finishedWork.refCleanup = ref(instanceToUse);
        else
          typeof ref === "string" ? console.error("String refs are no longer supported.") : ref.hasOwnProperty("current") || console.error("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", getComponentNameFromFiber(finishedWork)), ref.current = instanceToUse;
      }
    }
    function safelyAttachRef(current2, nearestMountedAncestor) {
      try {
        runWithFiberInDEV(current2, commitAttachRef, current2);
      } catch (error) {
        captureCommitPhaseError(current2, nearestMountedAncestor, error);
      }
    }
    function safelyDetachRef(current2, nearestMountedAncestor) {
      var { ref, refCleanup } = current2;
      if (ref !== null)
        if (typeof refCleanup === "function")
          try {
            if (shouldProfile(current2))
              try {
                startEffectTimer(), runWithFiberInDEV(current2, refCleanup);
              } finally {
                recordEffectDuration(current2);
              }
            else
              runWithFiberInDEV(current2, refCleanup);
          } catch (error) {
            captureCommitPhaseError(current2, nearestMountedAncestor, error);
          } finally {
            current2.refCleanup = null, current2 = current2.alternate, current2 != null && (current2.refCleanup = null);
          }
        else if (typeof ref === "function")
          try {
            if (shouldProfile(current2))
              try {
                startEffectTimer(), runWithFiberInDEV(current2, ref, null);
              } finally {
                recordEffectDuration(current2);
              }
            else
              runWithFiberInDEV(current2, ref, null);
          } catch (error$7) {
            captureCommitPhaseError(current2, nearestMountedAncestor, error$7);
          }
        else
          ref.current = null;
    }
    function commitProfiler(finishedWork, current2, commitStartTime2, effectDuration) {
      var _finishedWork$memoize = finishedWork.memoizedProps, id = _finishedWork$memoize.id, onCommit = _finishedWork$memoize.onCommit;
      _finishedWork$memoize = _finishedWork$memoize.onRender;
      current2 = current2 === null ? "mount" : "update";
      currentUpdateIsNested && (current2 = "nested-update");
      typeof _finishedWork$memoize === "function" && _finishedWork$memoize(id, current2, finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, commitStartTime2);
      typeof onCommit === "function" && onCommit(id, current2, effectDuration, commitStartTime2);
    }
    function commitProfilerPostCommitImpl(finishedWork, current2, commitStartTime2, passiveEffectDuration) {
      var _finishedWork$memoize2 = finishedWork.memoizedProps;
      finishedWork = _finishedWork$memoize2.id;
      _finishedWork$memoize2 = _finishedWork$memoize2.onPostCommit;
      current2 = current2 === null ? "mount" : "update";
      currentUpdateIsNested && (current2 = "nested-update");
      typeof _finishedWork$memoize2 === "function" && _finishedWork$memoize2(finishedWork, current2, passiveEffectDuration, commitStartTime2);
    }
    function commitHostMount(finishedWork) {
      var { type, memoizedProps: props, stateNode: instance } = finishedWork;
      try {
        runWithFiberInDEV(finishedWork, commitMount, instance, type, props, finishedWork);
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function commitHostUpdate(finishedWork, newProps, oldProps) {
      try {
        runWithFiberInDEV(finishedWork, commitUpdate, finishedWork.stateNode, finishedWork.type, oldProps, newProps, finishedWork);
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function isHostParent(fiber) {
      return fiber.tag === 5 || fiber.tag === 3 || fiber.tag === 26 || fiber.tag === 27 && isSingletonScope(fiber.type) || fiber.tag === 4;
    }
    function getHostSibling(fiber) {
      a:
        for (;; ) {
          for (;fiber.sibling === null; ) {
            if (fiber.return === null || isHostParent(fiber.return))
              return null;
            fiber = fiber.return;
          }
          fiber.sibling.return = fiber.return;
          for (fiber = fiber.sibling;fiber.tag !== 5 && fiber.tag !== 6 && fiber.tag !== 18; ) {
            if (fiber.tag === 27 && isSingletonScope(fiber.type))
              continue a;
            if (fiber.flags & 2)
              continue a;
            if (fiber.child === null || fiber.tag === 4)
              continue a;
            else
              fiber.child.return = fiber, fiber = fiber.child;
          }
          if (!(fiber.flags & 2))
            return fiber.stateNode;
        }
    }
    function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
      var tag = node.tag;
      if (tag === 5 || tag === 6)
        node = node.stateNode, before ? (warnForReactChildrenConflict(parent), (parent.nodeType === 9 ? parent.body : parent.nodeName === "HTML" ? parent.ownerDocument.body : parent).insertBefore(node, before)) : (warnForReactChildrenConflict(parent), before = parent.nodeType === 9 ? parent.body : parent.nodeName === "HTML" ? parent.ownerDocument.body : parent, before.appendChild(node), parent = parent._reactRootContainer, parent !== null && parent !== undefined || before.onclick !== null || (before.onclick = noop$1));
      else if (tag !== 4 && (tag === 27 && isSingletonScope(node.type) && (parent = node.stateNode, before = null), node = node.child, node !== null))
        for (insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling;node !== null; )
          insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling;
    }
    function insertOrAppendPlacementNode(node, before, parent) {
      var tag = node.tag;
      if (tag === 5 || tag === 6)
        node = node.stateNode, before ? parent.insertBefore(node, before) : parent.appendChild(node);
      else if (tag !== 4 && (tag === 27 && isSingletonScope(node.type) && (parent = node.stateNode), node = node.child, node !== null))
        for (insertOrAppendPlacementNode(node, before, parent), node = node.sibling;node !== null; )
          insertOrAppendPlacementNode(node, before, parent), node = node.sibling;
    }
    function commitPlacement(finishedWork) {
      for (var hostParentFiber, parentFiber = finishedWork.return;parentFiber !== null; ) {
        if (isHostParent(parentFiber)) {
          hostParentFiber = parentFiber;
          break;
        }
        parentFiber = parentFiber.return;
      }
      if (hostParentFiber == null)
        throw Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
      switch (hostParentFiber.tag) {
        case 27:
          hostParentFiber = hostParentFiber.stateNode;
          parentFiber = getHostSibling(finishedWork);
          insertOrAppendPlacementNode(finishedWork, parentFiber, hostParentFiber);
          break;
        case 5:
          parentFiber = hostParentFiber.stateNode;
          hostParentFiber.flags & 32 && (resetTextContent(parentFiber), hostParentFiber.flags &= -33);
          hostParentFiber = getHostSibling(finishedWork);
          insertOrAppendPlacementNode(finishedWork, hostParentFiber, parentFiber);
          break;
        case 3:
        case 4:
          hostParentFiber = hostParentFiber.stateNode.containerInfo;
          parentFiber = getHostSibling(finishedWork);
          insertOrAppendPlacementNodeIntoContainer(finishedWork, parentFiber, hostParentFiber);
          break;
        default:
          throw Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    function commitHostSingletonAcquisition(finishedWork) {
      var { stateNode: singleton, memoizedProps: props } = finishedWork;
      try {
        runWithFiberInDEV(finishedWork, acquireSingletonInstance, finishedWork.type, props, singleton, finishedWork);
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function isHydratingParent(current2, finishedWork) {
      return finishedWork.tag === 31 ? (finishedWork = finishedWork.memoizedState, current2.memoizedState !== null && finishedWork === null) : finishedWork.tag === 13 ? (current2 = current2.memoizedState, finishedWork = finishedWork.memoizedState, current2 !== null && current2.dehydrated !== null && (finishedWork === null || finishedWork.dehydrated === null)) : finishedWork.tag === 3 ? current2.memoizedState.isDehydrated && (finishedWork.flags & 256) === 0 : false;
    }
    function commitBeforeMutationEffects(root2, firstChild) {
      root2 = root2.containerInfo;
      eventsEnabled = _enabled;
      root2 = getActiveElementDeep(root2);
      if (hasSelectionCapabilities(root2)) {
        if ("selectionStart" in root2)
          var JSCompiler_temp = {
            start: root2.selectionStart,
            end: root2.selectionEnd
          };
        else
          a: {
            JSCompiler_temp = (JSCompiler_temp = root2.ownerDocument) && JSCompiler_temp.defaultView || window;
            var selection = JSCompiler_temp.getSelection && JSCompiler_temp.getSelection();
            if (selection && selection.rangeCount !== 0) {
              JSCompiler_temp = selection.anchorNode;
              var { anchorOffset, focusNode } = selection;
              selection = selection.focusOffset;
              try {
                JSCompiler_temp.nodeType, focusNode.nodeType;
              } catch (e$2) {
                JSCompiler_temp = null;
                break a;
              }
              var length = 0, start = -1, end = -1, indexWithinAnchor = 0, indexWithinFocus = 0, node = root2, parentNode = null;
              b:
                for (;; ) {
                  for (var next;; ) {
                    node !== JSCompiler_temp || anchorOffset !== 0 && node.nodeType !== 3 || (start = length + anchorOffset);
                    node !== focusNode || selection !== 0 && node.nodeType !== 3 || (end = length + selection);
                    node.nodeType === 3 && (length += node.nodeValue.length);
                    if ((next = node.firstChild) === null)
                      break;
                    parentNode = node;
                    node = next;
                  }
                  for (;; ) {
                    if (node === root2)
                      break b;
                    parentNode === JSCompiler_temp && ++indexWithinAnchor === anchorOffset && (start = length);
                    parentNode === focusNode && ++indexWithinFocus === selection && (end = length);
                    if ((next = node.nextSibling) !== null)
                      break;
                    node = parentNode;
                    parentNode = node.parentNode;
                  }
                  node = next;
                }
              JSCompiler_temp = start === -1 || end === -1 ? null : { start, end };
            } else
              JSCompiler_temp = null;
          }
        JSCompiler_temp = JSCompiler_temp || { start: 0, end: 0 };
      } else
        JSCompiler_temp = null;
      selectionInformation = {
        focusedElem: root2,
        selectionRange: JSCompiler_temp
      };
      _enabled = false;
      for (nextEffect = firstChild;nextEffect !== null; )
        if (firstChild = nextEffect, root2 = firstChild.child, (firstChild.subtreeFlags & 1028) !== 0 && root2 !== null)
          root2.return = firstChild, nextEffect = root2;
        else
          for (;nextEffect !== null; ) {
            root2 = firstChild = nextEffect;
            JSCompiler_temp = root2.alternate;
            anchorOffset = root2.flags;
            switch (root2.tag) {
              case 0:
                if ((anchorOffset & 4) !== 0 && (root2 = root2.updateQueue, root2 = root2 !== null ? root2.events : null, root2 !== null))
                  for (JSCompiler_temp = 0;JSCompiler_temp < root2.length; JSCompiler_temp++)
                    anchorOffset = root2[JSCompiler_temp], anchorOffset.ref.impl = anchorOffset.nextImpl;
                break;
              case 11:
              case 15:
                break;
              case 1:
                (anchorOffset & 1024) !== 0 && JSCompiler_temp !== null && commitClassSnapshot(root2, JSCompiler_temp);
                break;
              case 3:
                if ((anchorOffset & 1024) !== 0) {
                  if (root2 = root2.stateNode.containerInfo, JSCompiler_temp = root2.nodeType, JSCompiler_temp === 9)
                    clearContainerSparingly(root2);
                  else if (JSCompiler_temp === 1)
                    switch (root2.nodeName) {
                      case "HEAD":
                      case "HTML":
                      case "BODY":
                        clearContainerSparingly(root2);
                        break;
                      default:
                        root2.textContent = "";
                    }
                }
                break;
              case 5:
              case 26:
              case 27:
              case 6:
              case 4:
              case 17:
                break;
              default:
                if ((anchorOffset & 1024) !== 0)
                  throw Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
            }
            root2 = firstChild.sibling;
            if (root2 !== null) {
              root2.return = firstChild.return;
              nextEffect = root2;
              break;
            }
            nextEffect = firstChild.return;
          }
    }
    function commitLayoutEffectOnFiber(finishedRoot, current2, finishedWork) {
      var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate(), flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          flags & 4 && commitHookLayoutEffects(finishedWork, Layout | HasEffect);
          break;
        case 1:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          if (flags & 4)
            if (finishedRoot = finishedWork.stateNode, current2 === null)
              finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (finishedRoot.props !== finishedWork.memoizedProps && console.error("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance"), finishedRoot.state !== finishedWork.memoizedState && console.error("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance")), shouldProfile(finishedWork) ? (startEffectTimer(), runWithFiberInDEV(finishedWork, callComponentDidMountInDEV, finishedWork, finishedRoot), recordEffectDuration()) : runWithFiberInDEV(finishedWork, callComponentDidMountInDEV, finishedWork, finishedRoot);
            else {
              var prevProps = resolveClassComponentProps(finishedWork.type, current2.memoizedProps);
              current2 = current2.memoizedState;
              finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (finishedRoot.props !== finishedWork.memoizedProps && console.error("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance"), finishedRoot.state !== finishedWork.memoizedState && console.error("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance"));
              shouldProfile(finishedWork) ? (startEffectTimer(), runWithFiberInDEV(finishedWork, callComponentDidUpdateInDEV, finishedWork, finishedRoot, prevProps, current2, finishedRoot.__reactInternalSnapshotBeforeUpdate), recordEffectDuration()) : runWithFiberInDEV(finishedWork, callComponentDidUpdateInDEV, finishedWork, finishedRoot, prevProps, current2, finishedRoot.__reactInternalSnapshotBeforeUpdate);
            }
          flags & 64 && commitClassCallbacks(finishedWork);
          flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
          break;
        case 3:
          current2 = pushNestedEffectDurations();
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          if (flags & 64 && (flags = finishedWork.updateQueue, flags !== null)) {
            prevProps = null;
            if (finishedWork.child !== null)
              switch (finishedWork.child.tag) {
                case 27:
                case 5:
                  prevProps = finishedWork.child.stateNode;
                  break;
                case 1:
                  prevProps = finishedWork.child.stateNode;
              }
            try {
              runWithFiberInDEV(finishedWork, commitCallbacks, flags, prevProps);
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
          finishedRoot.effectDuration += popNestedEffectDurations(current2);
          break;
        case 27:
          current2 === null && flags & 4 && commitHostSingletonAcquisition(finishedWork);
        case 26:
        case 5:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          if (current2 === null) {
            if (flags & 4)
              commitHostMount(finishedWork);
            else if (flags & 64) {
              finishedRoot = finishedWork.type;
              current2 = finishedWork.memoizedProps;
              prevProps = finishedWork.stateNode;
              try {
                runWithFiberInDEV(finishedWork, commitHydratedInstance, prevProps, finishedRoot, current2, finishedWork);
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            }
          }
          flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
          break;
        case 12:
          if (flags & 4) {
            flags = pushNestedEffectDurations();
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            finishedRoot = finishedWork.stateNode;
            finishedRoot.effectDuration += bubbleNestedEffectDurations(flags);
            try {
              runWithFiberInDEV(finishedWork, commitProfiler, finishedWork, current2, commitStartTime, finishedRoot.effectDuration);
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          } else
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          break;
        case 31:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          flags & 4 && commitActivityHydrationCallbacks(finishedRoot, finishedWork);
          break;
        case 13:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
          flags & 64 && (finishedRoot = finishedWork.memoizedState, finishedRoot !== null && (finishedRoot = finishedRoot.dehydrated, finishedRoot !== null && (flags = retryDehydratedSuspenseBoundary.bind(null, finishedWork), registerSuspenseInstanceRetry(finishedRoot, flags))));
          break;
        case 22:
          flags = finishedWork.memoizedState !== null || offscreenSubtreeIsHidden;
          if (!flags) {
            current2 = current2 !== null && current2.memoizedState !== null || offscreenSubtreeWasHidden;
            prevProps = offscreenSubtreeIsHidden;
            var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
            offscreenSubtreeIsHidden = flags;
            (offscreenSubtreeWasHidden = current2) && !prevOffscreenSubtreeWasHidden ? (recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, (finishedWork.subtreeFlags & 8772) !== 0), (finishedWork.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentReappeared(finishedWork, componentEffectStartTime, componentEffectEndTime)) : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            offscreenSubtreeIsHidden = prevProps;
            offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
          }
          break;
        case 30:
          break;
        default:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
      }
      (finishedWork.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && ((componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(finishedWork, componentEffectStartTime, componentEffectEndTime, componentEffectDuration, componentEffectErrors), finishedWork.alternate === null && finishedWork.return !== null && finishedWork.return.alternate !== null && 0.05 < componentEffectEndTime - componentEffectStartTime && (isHydratingParent(finishedWork.return.alternate, finishedWork.return) || logComponentTrigger(finishedWork, componentEffectStartTime, componentEffectEndTime, "Mount")));
      popComponentEffectStart(prevEffectStart);
      popComponentEffectDuration(prevEffectDuration);
      componentEffectErrors = prevEffectErrors;
      componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
    }
    function detachFiberAfterEffects(fiber) {
      var alternate = fiber.alternate;
      alternate !== null && (fiber.alternate = null, detachFiberAfterEffects(alternate));
      fiber.child = null;
      fiber.deletions = null;
      fiber.sibling = null;
      fiber.tag === 5 && (alternate = fiber.stateNode, alternate !== null && detachDeletedInstance(alternate));
      fiber.stateNode = null;
      fiber._debugOwner = null;
      fiber.return = null;
      fiber.dependencies = null;
      fiber.memoizedProps = null;
      fiber.memoizedState = null;
      fiber.pendingProps = null;
      fiber.stateNode = null;
      fiber.updateQueue = null;
    }
    function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
      for (parent = parent.child;parent !== null; )
        commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, parent), parent = parent.sibling;
    }
    function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
      if (injectedHook && typeof injectedHook.onCommitFiberUnmount === "function")
        try {
          injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);
        } catch (err) {
          hasLoggedError || (hasLoggedError = true, console.error("React instrumentation encountered an error: %o", err));
        }
      var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate();
      switch (deletedFiber.tag) {
        case 26:
          offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
          deletedFiber.memoizedState ? deletedFiber.memoizedState.count-- : deletedFiber.stateNode && (finishedRoot = deletedFiber.stateNode, finishedRoot.parentNode.removeChild(finishedRoot));
          break;
        case 27:
          offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
          var prevHostParent = hostParent, prevHostParentIsContainer = hostParentIsContainer;
          isSingletonScope(deletedFiber.type) && (hostParent = deletedFiber.stateNode, hostParentIsContainer = false);
          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
          runWithFiberInDEV(deletedFiber, releaseSingletonInstance, deletedFiber.stateNode);
          hostParent = prevHostParent;
          hostParentIsContainer = prevHostParentIsContainer;
          break;
        case 5:
          offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
        case 6:
          prevHostParent = hostParent;
          prevHostParentIsContainer = hostParentIsContainer;
          hostParent = null;
          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
          hostParent = prevHostParent;
          hostParentIsContainer = prevHostParentIsContainer;
          if (hostParent !== null)
            if (hostParentIsContainer)
              try {
                runWithFiberInDEV(deletedFiber, removeChildFromContainer, hostParent, deletedFiber.stateNode);
              } catch (error) {
                captureCommitPhaseError(deletedFiber, nearestMountedAncestor, error);
              }
            else
              try {
                runWithFiberInDEV(deletedFiber, removeChild, hostParent, deletedFiber.stateNode);
              } catch (error) {
                captureCommitPhaseError(deletedFiber, nearestMountedAncestor, error);
              }
          break;
        case 18:
          hostParent !== null && (hostParentIsContainer ? (finishedRoot = hostParent, clearHydrationBoundary(finishedRoot.nodeType === 9 ? finishedRoot.body : finishedRoot.nodeName === "HTML" ? finishedRoot.ownerDocument.body : finishedRoot, deletedFiber.stateNode), retryIfBlockedOn(finishedRoot)) : clearHydrationBoundary(hostParent, deletedFiber.stateNode));
          break;
        case 4:
          prevHostParent = hostParent;
          prevHostParentIsContainer = hostParentIsContainer;
          hostParent = deletedFiber.stateNode.containerInfo;
          hostParentIsContainer = true;
          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
          hostParent = prevHostParent;
          hostParentIsContainer = prevHostParentIsContainer;
          break;
        case 0:
        case 11:
        case 14:
        case 15:
          commitHookEffectListUnmount(Insertion, deletedFiber, nearestMountedAncestor);
          offscreenSubtreeWasHidden || commitHookLayoutUnmountEffects(deletedFiber, nearestMountedAncestor, Layout);
          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
          break;
        case 1:
          offscreenSubtreeWasHidden || (safelyDetachRef(deletedFiber, nearestMountedAncestor), prevHostParent = deletedFiber.stateNode, typeof prevHostParent.componentWillUnmount === "function" && safelyCallComponentWillUnmount(deletedFiber, nearestMountedAncestor, prevHostParent));
          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
          break;
        case 21:
          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
          break;
        case 22:
          offscreenSubtreeWasHidden = (prevHostParent = offscreenSubtreeWasHidden) || deletedFiber.memoizedState !== null;
          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
          offscreenSubtreeWasHidden = prevHostParent;
          break;
        default:
          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
      }
      (deletedFiber.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && (componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(deletedFiber, componentEffectStartTime, componentEffectEndTime, componentEffectDuration, componentEffectErrors);
      popComponentEffectStart(prevEffectStart);
      popComponentEffectDuration(prevEffectDuration);
      componentEffectErrors = prevEffectErrors;
      componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
    }
    function commitActivityHydrationCallbacks(finishedRoot, finishedWork) {
      if (finishedWork.memoizedState === null && (finishedRoot = finishedWork.alternate, finishedRoot !== null && (finishedRoot = finishedRoot.memoizedState, finishedRoot !== null))) {
        finishedRoot = finishedRoot.dehydrated;
        try {
          runWithFiberInDEV(finishedWork, commitHydratedActivityInstance, finishedRoot);
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
    }
    function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
      if (finishedWork.memoizedState === null && (finishedRoot = finishedWork.alternate, finishedRoot !== null && (finishedRoot = finishedRoot.memoizedState, finishedRoot !== null && (finishedRoot = finishedRoot.dehydrated, finishedRoot !== null))))
        try {
          runWithFiberInDEV(finishedWork, commitHydratedSuspenseInstance, finishedRoot);
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
    }
    function getRetryCache(finishedWork) {
      switch (finishedWork.tag) {
        case 31:
        case 13:
        case 19:
          var retryCache = finishedWork.stateNode;
          retryCache === null && (retryCache = finishedWork.stateNode = new PossiblyWeakSet);
          return retryCache;
        case 22:
          return finishedWork = finishedWork.stateNode, retryCache = finishedWork._retryCache, retryCache === null && (retryCache = finishedWork._retryCache = new PossiblyWeakSet), retryCache;
        default:
          throw Error("Unexpected Suspense handler tag (" + finishedWork.tag + "). This is a bug in React.");
      }
    }
    function attachSuspenseRetryListeners(finishedWork, wakeables) {
      var retryCache = getRetryCache(finishedWork);
      wakeables.forEach(function(wakeable) {
        if (!retryCache.has(wakeable)) {
          retryCache.add(wakeable);
          if (isDevToolsPresent)
            if (inProgressLanes !== null && inProgressRoot !== null)
              restorePendingUpdaters(inProgressRoot, inProgressLanes);
            else
              throw Error("Expected finished root and lanes to be set. This is a bug in React.");
          var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
          wakeable.then(retry, retry);
        }
      });
    }
    function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {
      var deletions = parentFiber.deletions;
      if (deletions !== null)
        for (var i = 0;i < deletions.length; i++) {
          var root2 = root$jscomp$0, returnFiber = parentFiber, deletedFiber = deletions[i], prevEffectStart = pushComponentEffectStart(), parent = returnFiber;
          a:
            for (;parent !== null; ) {
              switch (parent.tag) {
                case 27:
                  if (isSingletonScope(parent.type)) {
                    hostParent = parent.stateNode;
                    hostParentIsContainer = false;
                    break a;
                  }
                  break;
                case 5:
                  hostParent = parent.stateNode;
                  hostParentIsContainer = false;
                  break a;
                case 3:
                case 4:
                  hostParent = parent.stateNode.containerInfo;
                  hostParentIsContainer = true;
                  break a;
              }
              parent = parent.return;
            }
          if (hostParent === null)
            throw Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
          commitDeletionEffectsOnFiber(root2, returnFiber, deletedFiber);
          hostParent = null;
          hostParentIsContainer = false;
          (deletedFiber.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentTrigger(deletedFiber, componentEffectStartTime, componentEffectEndTime, "Unmount");
          popComponentEffectStart(prevEffectStart);
          root2 = deletedFiber;
          returnFiber = root2.alternate;
          returnFiber !== null && (returnFiber.return = null);
          root2.return = null;
        }
      if (parentFiber.subtreeFlags & 13886)
        for (parentFiber = parentFiber.child;parentFiber !== null; )
          commitMutationEffectsOnFiber(parentFiber, root$jscomp$0), parentFiber = parentFiber.sibling;
    }
    function commitMutationEffectsOnFiber(finishedWork, root2) {
      var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate(), current2 = finishedWork.alternate, flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          recursivelyTraverseMutationEffects(root2, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 4 && (commitHookEffectListUnmount(Insertion | HasEffect, finishedWork, finishedWork.return), commitHookEffectListMount(Insertion | HasEffect, finishedWork), commitHookLayoutUnmountEffects(finishedWork, finishedWork.return, Layout | HasEffect));
          break;
        case 1:
          recursivelyTraverseMutationEffects(root2, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 512 && (offscreenSubtreeWasHidden || current2 === null || safelyDetachRef(current2, current2.return));
          if (flags & 64 && offscreenSubtreeIsHidden && (flags = finishedWork.updateQueue, flags !== null && (current2 = flags.callbacks, current2 !== null))) {
            var existingHiddenCallbacks = flags.shared.hiddenCallbacks;
            flags.shared.hiddenCallbacks = existingHiddenCallbacks === null ? current2 : existingHiddenCallbacks.concat(current2);
          }
          break;
        case 26:
          existingHiddenCallbacks = currentHoistableRoot;
          recursivelyTraverseMutationEffects(root2, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 512 && (offscreenSubtreeWasHidden || current2 === null || safelyDetachRef(current2, current2.return));
          if (flags & 4) {
            var currentResource = current2 !== null ? current2.memoizedState : null;
            flags = finishedWork.memoizedState;
            if (current2 === null)
              if (flags === null)
                if (finishedWork.stateNode === null) {
                  a: {
                    flags = finishedWork.type;
                    current2 = finishedWork.memoizedProps;
                    existingHiddenCallbacks = existingHiddenCallbacks.ownerDocument || existingHiddenCallbacks;
                    b:
                      switch (flags) {
                        case "title":
                          currentResource = existingHiddenCallbacks.getElementsByTagName("title")[0];
                          if (!currentResource || currentResource[internalHoistableMarker] || currentResource[internalInstanceKey] || currentResource.namespaceURI === SVG_NAMESPACE || currentResource.hasAttribute("itemprop"))
                            currentResource = existingHiddenCallbacks.createElement(flags), existingHiddenCallbacks.head.insertBefore(currentResource, existingHiddenCallbacks.querySelector("head > title"));
                          setInitialProperties(currentResource, flags, current2);
                          currentResource[internalInstanceKey] = finishedWork;
                          markNodeAsHoistable(currentResource);
                          flags = currentResource;
                          break a;
                        case "link":
                          var maybeNodes = getHydratableHoistableCache("link", "href", existingHiddenCallbacks).get(flags + (current2.href || ""));
                          if (maybeNodes) {
                            for (var i = 0;i < maybeNodes.length; i++)
                              if (currentResource = maybeNodes[i], currentResource.getAttribute("href") === (current2.href == null || current2.href === "" ? null : current2.href) && currentResource.getAttribute("rel") === (current2.rel == null ? null : current2.rel) && currentResource.getAttribute("title") === (current2.title == null ? null : current2.title) && currentResource.getAttribute("crossorigin") === (current2.crossOrigin == null ? null : current2.crossOrigin)) {
                                maybeNodes.splice(i, 1);
                                break b;
                              }
                          }
                          currentResource = existingHiddenCallbacks.createElement(flags);
                          setInitialProperties(currentResource, flags, current2);
                          existingHiddenCallbacks.head.appendChild(currentResource);
                          break;
                        case "meta":
                          if (maybeNodes = getHydratableHoistableCache("meta", "content", existingHiddenCallbacks).get(flags + (current2.content || ""))) {
                            for (i = 0;i < maybeNodes.length; i++)
                              if (currentResource = maybeNodes[i], checkAttributeStringCoercion(current2.content, "content"), currentResource.getAttribute("content") === (current2.content == null ? null : "" + current2.content) && currentResource.getAttribute("name") === (current2.name == null ? null : current2.name) && currentResource.getAttribute("property") === (current2.property == null ? null : current2.property) && currentResource.getAttribute("http-equiv") === (current2.httpEquiv == null ? null : current2.httpEquiv) && currentResource.getAttribute("charset") === (current2.charSet == null ? null : current2.charSet)) {
                                maybeNodes.splice(i, 1);
                                break b;
                              }
                          }
                          currentResource = existingHiddenCallbacks.createElement(flags);
                          setInitialProperties(currentResource, flags, current2);
                          existingHiddenCallbacks.head.appendChild(currentResource);
                          break;
                        default:
                          throw Error('getNodesForType encountered a type it did not expect: "' + flags + '". This is a bug in React.');
                      }
                    currentResource[internalInstanceKey] = finishedWork;
                    markNodeAsHoistable(currentResource);
                    flags = currentResource;
                  }
                  finishedWork.stateNode = flags;
                } else
                  mountHoistable(existingHiddenCallbacks, finishedWork.type, finishedWork.stateNode);
              else
                finishedWork.stateNode = acquireResource(existingHiddenCallbacks, flags, finishedWork.memoizedProps);
            else
              currentResource !== flags ? (currentResource === null ? current2.stateNode !== null && (current2 = current2.stateNode, current2.parentNode.removeChild(current2)) : currentResource.count--, flags === null ? mountHoistable(existingHiddenCallbacks, finishedWork.type, finishedWork.stateNode) : acquireResource(existingHiddenCallbacks, flags, finishedWork.memoizedProps)) : flags === null && finishedWork.stateNode !== null && commitHostUpdate(finishedWork, finishedWork.memoizedProps, current2.memoizedProps);
          }
          break;
        case 27:
          recursivelyTraverseMutationEffects(root2, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 512 && (offscreenSubtreeWasHidden || current2 === null || safelyDetachRef(current2, current2.return));
          current2 !== null && flags & 4 && commitHostUpdate(finishedWork, finishedWork.memoizedProps, current2.memoizedProps);
          break;
        case 5:
          recursivelyTraverseMutationEffects(root2, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 512 && (offscreenSubtreeWasHidden || current2 === null || safelyDetachRef(current2, current2.return));
          if (finishedWork.flags & 32) {
            existingHiddenCallbacks = finishedWork.stateNode;
            try {
              runWithFiberInDEV(finishedWork, resetTextContent, existingHiddenCallbacks);
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
          flags & 4 && finishedWork.stateNode != null && (existingHiddenCallbacks = finishedWork.memoizedProps, commitHostUpdate(finishedWork, existingHiddenCallbacks, current2 !== null ? current2.memoizedProps : existingHiddenCallbacks));
          flags & 1024 && (needsFormReset = true, finishedWork.type !== "form" && console.error("Unexpected host component type. Expected a form. This is a bug in React."));
          break;
        case 6:
          recursivelyTraverseMutationEffects(root2, finishedWork);
          commitReconciliationEffects(finishedWork);
          if (flags & 4) {
            if (finishedWork.stateNode === null)
              throw Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
            flags = finishedWork.memoizedProps;
            current2 = current2 !== null ? current2.memoizedProps : flags;
            existingHiddenCallbacks = finishedWork.stateNode;
            try {
              runWithFiberInDEV(finishedWork, commitTextUpdate, existingHiddenCallbacks, current2, flags);
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
          break;
        case 3:
          existingHiddenCallbacks = pushNestedEffectDurations();
          tagCaches = null;
          currentResource = currentHoistableRoot;
          currentHoistableRoot = getHoistableRoot(root2.containerInfo);
          recursivelyTraverseMutationEffects(root2, finishedWork);
          currentHoistableRoot = currentResource;
          commitReconciliationEffects(finishedWork);
          if (flags & 4 && current2 !== null && current2.memoizedState.isDehydrated)
            try {
              runWithFiberInDEV(finishedWork, commitHydratedContainer, root2.containerInfo);
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          needsFormReset && (needsFormReset = false, recursivelyResetForms(finishedWork));
          root2.effectDuration += popNestedEffectDurations(existingHiddenCallbacks);
          break;
        case 4:
          flags = currentHoistableRoot;
          currentHoistableRoot = getHoistableRoot(finishedWork.stateNode.containerInfo);
          recursivelyTraverseMutationEffects(root2, finishedWork);
          commitReconciliationEffects(finishedWork);
          currentHoistableRoot = flags;
          break;
        case 12:
          flags = pushNestedEffectDurations();
          recursivelyTraverseMutationEffects(root2, finishedWork);
          commitReconciliationEffects(finishedWork);
          finishedWork.stateNode.effectDuration += bubbleNestedEffectDurations(flags);
          break;
        case 31:
          recursivelyTraverseMutationEffects(root2, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 4 && (flags = finishedWork.updateQueue, flags !== null && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
          break;
        case 13:
          recursivelyTraverseMutationEffects(root2, finishedWork);
          commitReconciliationEffects(finishedWork);
          finishedWork.child.flags & 8192 && finishedWork.memoizedState !== null !== (current2 !== null && current2.memoizedState !== null) && (globalMostRecentFallbackTime = now$1());
          flags & 4 && (flags = finishedWork.updateQueue, flags !== null && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
          break;
        case 22:
          existingHiddenCallbacks = finishedWork.memoizedState !== null;
          var wasHidden = current2 !== null && current2.memoizedState !== null, prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden, prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
          offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden || existingHiddenCallbacks;
          offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || wasHidden;
          recursivelyTraverseMutationEffects(root2, finishedWork);
          offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
          offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
          wasHidden && !existingHiddenCallbacks && !prevOffscreenSubtreeIsHidden && !prevOffscreenSubtreeWasHidden && (finishedWork.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentReappeared(finishedWork, componentEffectStartTime, componentEffectEndTime);
          commitReconciliationEffects(finishedWork);
          if (flags & 8192)
            a:
              for (root2 = finishedWork.stateNode, root2._visibility = existingHiddenCallbacks ? root2._visibility & ~OffscreenVisible : root2._visibility | OffscreenVisible, !existingHiddenCallbacks || current2 === null || wasHidden || offscreenSubtreeIsHidden || offscreenSubtreeWasHidden || (recursivelyTraverseDisappearLayoutEffects(finishedWork), (finishedWork.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentTrigger(finishedWork, componentEffectStartTime, componentEffectEndTime, "Disconnect")), current2 = null, root2 = finishedWork;; ) {
                if (root2.tag === 5 || root2.tag === 26) {
                  if (current2 === null) {
                    wasHidden = current2 = root2;
                    try {
                      currentResource = wasHidden.stateNode, existingHiddenCallbacks ? runWithFiberInDEV(wasHidden, hideInstance, currentResource) : runWithFiberInDEV(wasHidden, unhideInstance, wasHidden.stateNode, wasHidden.memoizedProps);
                    } catch (error) {
                      captureCommitPhaseError(wasHidden, wasHidden.return, error);
                    }
                  }
                } else if (root2.tag === 6) {
                  if (current2 === null) {
                    wasHidden = root2;
                    try {
                      maybeNodes = wasHidden.stateNode, existingHiddenCallbacks ? runWithFiberInDEV(wasHidden, hideTextInstance, maybeNodes) : runWithFiberInDEV(wasHidden, unhideTextInstance, maybeNodes, wasHidden.memoizedProps);
                    } catch (error) {
                      captureCommitPhaseError(wasHidden, wasHidden.return, error);
                    }
                  }
                } else if (root2.tag === 18) {
                  if (current2 === null) {
                    wasHidden = root2;
                    try {
                      i = wasHidden.stateNode, existingHiddenCallbacks ? runWithFiberInDEV(wasHidden, hideDehydratedBoundary, i) : runWithFiberInDEV(wasHidden, unhideDehydratedBoundary, wasHidden.stateNode);
                    } catch (error) {
                      captureCommitPhaseError(wasHidden, wasHidden.return, error);
                    }
                  }
                } else if ((root2.tag !== 22 && root2.tag !== 23 || root2.memoizedState === null || root2 === finishedWork) && root2.child !== null) {
                  root2.child.return = root2;
                  root2 = root2.child;
                  continue;
                }
                if (root2 === finishedWork)
                  break a;
                for (;root2.sibling === null; ) {
                  if (root2.return === null || root2.return === finishedWork)
                    break a;
                  current2 === root2 && (current2 = null);
                  root2 = root2.return;
                }
                current2 === root2 && (current2 = null);
                root2.sibling.return = root2.return;
                root2 = root2.sibling;
              }
          flags & 4 && (flags = finishedWork.updateQueue, flags !== null && (current2 = flags.retryQueue, current2 !== null && (flags.retryQueue = null, attachSuspenseRetryListeners(finishedWork, current2))));
          break;
        case 19:
          recursivelyTraverseMutationEffects(root2, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 4 && (flags = finishedWork.updateQueue, flags !== null && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
          break;
        case 30:
          break;
        case 21:
          break;
        default:
          recursivelyTraverseMutationEffects(root2, finishedWork), commitReconciliationEffects(finishedWork);
      }
      (finishedWork.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && ((componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(finishedWork, componentEffectStartTime, componentEffectEndTime, componentEffectDuration, componentEffectErrors), finishedWork.alternate === null && finishedWork.return !== null && finishedWork.return.alternate !== null && 0.05 < componentEffectEndTime - componentEffectStartTime && (isHydratingParent(finishedWork.return.alternate, finishedWork.return) || logComponentTrigger(finishedWork, componentEffectStartTime, componentEffectEndTime, "Mount")));
      popComponentEffectStart(prevEffectStart);
      popComponentEffectDuration(prevEffectDuration);
      componentEffectErrors = prevEffectErrors;
      componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
    }
    function commitReconciliationEffects(finishedWork) {
      var flags = finishedWork.flags;
      if (flags & 2) {
        try {
          runWithFiberInDEV(finishedWork, commitPlacement, finishedWork);
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
        finishedWork.flags &= -3;
      }
      flags & 4096 && (finishedWork.flags &= -4097);
    }
    function recursivelyResetForms(parentFiber) {
      if (parentFiber.subtreeFlags & 1024)
        for (parentFiber = parentFiber.child;parentFiber !== null; ) {
          var fiber = parentFiber;
          recursivelyResetForms(fiber);
          fiber.tag === 5 && fiber.flags & 1024 && fiber.stateNode.reset();
          parentFiber = parentFiber.sibling;
        }
    }
    function recursivelyTraverseLayoutEffects(root2, parentFiber) {
      if (parentFiber.subtreeFlags & 8772)
        for (parentFiber = parentFiber.child;parentFiber !== null; )
          commitLayoutEffectOnFiber(root2, parentFiber.alternate, parentFiber), parentFiber = parentFiber.sibling;
    }
    function disappearLayoutEffects(finishedWork) {
      var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate();
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          commitHookLayoutUnmountEffects(finishedWork, finishedWork.return, Layout);
          recursivelyTraverseDisappearLayoutEffects(finishedWork);
          break;
        case 1:
          safelyDetachRef(finishedWork, finishedWork.return);
          var instance = finishedWork.stateNode;
          typeof instance.componentWillUnmount === "function" && safelyCallComponentWillUnmount(finishedWork, finishedWork.return, instance);
          recursivelyTraverseDisappearLayoutEffects(finishedWork);
          break;
        case 27:
          runWithFiberInDEV(finishedWork, releaseSingletonInstance, finishedWork.stateNode);
        case 26:
        case 5:
          safelyDetachRef(finishedWork, finishedWork.return);
          recursivelyTraverseDisappearLayoutEffects(finishedWork);
          break;
        case 22:
          finishedWork.memoizedState === null && recursivelyTraverseDisappearLayoutEffects(finishedWork);
          break;
        case 30:
          recursivelyTraverseDisappearLayoutEffects(finishedWork);
          break;
        default:
          recursivelyTraverseDisappearLayoutEffects(finishedWork);
      }
      (finishedWork.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && (componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(finishedWork, componentEffectStartTime, componentEffectEndTime, componentEffectDuration, componentEffectErrors);
      popComponentEffectStart(prevEffectStart);
      popComponentEffectDuration(prevEffectDuration);
      componentEffectErrors = prevEffectErrors;
      componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
    }
    function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
      for (parentFiber = parentFiber.child;parentFiber !== null; )
        disappearLayoutEffects(parentFiber), parentFiber = parentFiber.sibling;
    }
    function reappearLayoutEffects(finishedRoot, current2, finishedWork, includeWorkInProgressEffects) {
      var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate(), flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15:
          recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
          commitHookLayoutEffects(finishedWork, Layout);
          break;
        case 1:
          recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
          current2 = finishedWork.stateNode;
          typeof current2.componentDidMount === "function" && runWithFiberInDEV(finishedWork, callComponentDidMountInDEV, finishedWork, current2);
          current2 = finishedWork.updateQueue;
          if (current2 !== null) {
            finishedRoot = finishedWork.stateNode;
            try {
              runWithFiberInDEV(finishedWork, commitHiddenCallbacks, current2, finishedRoot);
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
          includeWorkInProgressEffects && flags & 64 && commitClassCallbacks(finishedWork);
          safelyAttachRef(finishedWork, finishedWork.return);
          break;
        case 27:
          commitHostSingletonAcquisition(finishedWork);
        case 26:
        case 5:
          recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
          includeWorkInProgressEffects && current2 === null && flags & 4 && commitHostMount(finishedWork);
          safelyAttachRef(finishedWork, finishedWork.return);
          break;
        case 12:
          if (includeWorkInProgressEffects && flags & 4) {
            flags = pushNestedEffectDurations();
            recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
            includeWorkInProgressEffects = finishedWork.stateNode;
            includeWorkInProgressEffects.effectDuration += bubbleNestedEffectDurations(flags);
            try {
              runWithFiberInDEV(finishedWork, commitProfiler, finishedWork, current2, commitStartTime, includeWorkInProgressEffects.effectDuration);
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          } else
            recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
          break;
        case 31:
          recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
          includeWorkInProgressEffects && flags & 4 && commitActivityHydrationCallbacks(finishedRoot, finishedWork);
          break;
        case 13:
          recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
          includeWorkInProgressEffects && flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
          break;
        case 22:
          finishedWork.memoizedState === null && recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
          safelyAttachRef(finishedWork, finishedWork.return);
          break;
        case 30:
          break;
        default:
          recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
      }
      (finishedWork.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && (componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(finishedWork, componentEffectStartTime, componentEffectEndTime, componentEffectDuration, componentEffectErrors);
      popComponentEffectStart(prevEffectStart);
      popComponentEffectDuration(prevEffectDuration);
      componentEffectErrors = prevEffectErrors;
      componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
    }
    function recursivelyTraverseReappearLayoutEffects(finishedRoot, parentFiber, includeWorkInProgressEffects) {
      includeWorkInProgressEffects = includeWorkInProgressEffects && (parentFiber.subtreeFlags & 8772) !== 0;
      for (parentFiber = parentFiber.child;parentFiber !== null; )
        reappearLayoutEffects(finishedRoot, parentFiber.alternate, parentFiber, includeWorkInProgressEffects), parentFiber = parentFiber.sibling;
    }
    function commitOffscreenPassiveMountEffects(current2, finishedWork) {
      var previousCache = null;
      current2 !== null && current2.memoizedState !== null && current2.memoizedState.cachePool !== null && (previousCache = current2.memoizedState.cachePool.pool);
      current2 = null;
      finishedWork.memoizedState !== null && finishedWork.memoizedState.cachePool !== null && (current2 = finishedWork.memoizedState.cachePool.pool);
      current2 !== previousCache && (current2 != null && retainCache(current2), previousCache != null && releaseCache(previousCache));
    }
    function commitCachePassiveMountEffect(current2, finishedWork) {
      current2 = null;
      finishedWork.alternate !== null && (current2 = finishedWork.alternate.memoizedState.cache);
      finishedWork = finishedWork.memoizedState.cache;
      finishedWork !== current2 && (retainCache(finishedWork), current2 != null && releaseCache(current2));
    }
    function recursivelyTraversePassiveMountEffects(root2, parentFiber, committedLanes, committedTransitions, endTime) {
      if (parentFiber.subtreeFlags & 10256 || parentFiber.actualDuration !== 0 && (parentFiber.alternate === null || parentFiber.alternate.child !== parentFiber.child))
        for (parentFiber = parentFiber.child;parentFiber !== null; ) {
          var nextSibling = parentFiber.sibling;
          commitPassiveMountOnFiber(root2, parentFiber, committedLanes, committedTransitions, nextSibling !== null ? nextSibling.actualStartTime : endTime);
          parentFiber = nextSibling;
        }
    }
    function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions, endTime) {
      var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate(), prevDeepEquality = alreadyWarnedForDeepEquality, flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15:
          (finishedWork.mode & ProfileMode) !== NoMode && 0 < finishedWork.actualStartTime && (finishedWork.flags & 1) !== 0 && logComponentRender(finishedWork, finishedWork.actualStartTime, endTime, inHydratedSubtree, committedLanes);
          recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, endTime);
          flags & 2048 && commitHookPassiveMountEffects(finishedWork, Passive | HasEffect);
          break;
        case 1:
          (finishedWork.mode & ProfileMode) !== NoMode && 0 < finishedWork.actualStartTime && ((finishedWork.flags & 128) !== 0 ? logComponentErrored(finishedWork, finishedWork.actualStartTime, endTime, []) : (finishedWork.flags & 1) !== 0 && logComponentRender(finishedWork, finishedWork.actualStartTime, endTime, inHydratedSubtree, committedLanes));
          recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, endTime);
          break;
        case 3:
          var prevProfilerEffectDuration = pushNestedEffectDurations(), wasInHydratedSubtree = inHydratedSubtree;
          inHydratedSubtree = finishedWork.alternate !== null && finishedWork.alternate.memoizedState.isDehydrated && (finishedWork.flags & 256) === 0;
          recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, endTime);
          inHydratedSubtree = wasInHydratedSubtree;
          flags & 2048 && (committedLanes = null, finishedWork.alternate !== null && (committedLanes = finishedWork.alternate.memoizedState.cache), committedTransitions = finishedWork.memoizedState.cache, committedTransitions !== committedLanes && (retainCache(committedTransitions), committedLanes != null && releaseCache(committedLanes)));
          finishedRoot.passiveEffectDuration += popNestedEffectDurations(prevProfilerEffectDuration);
          break;
        case 12:
          if (flags & 2048) {
            flags = pushNestedEffectDurations();
            recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, endTime);
            finishedRoot = finishedWork.stateNode;
            finishedRoot.passiveEffectDuration += bubbleNestedEffectDurations(flags);
            try {
              runWithFiberInDEV(finishedWork, commitProfilerPostCommitImpl, finishedWork, finishedWork.alternate, commitStartTime, finishedRoot.passiveEffectDuration);
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          } else
            recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, endTime);
          break;
        case 31:
          flags = inHydratedSubtree;
          prevProfilerEffectDuration = finishedWork.alternate !== null ? finishedWork.alternate.memoizedState : null;
          wasInHydratedSubtree = finishedWork.memoizedState;
          prevProfilerEffectDuration !== null && wasInHydratedSubtree === null ? (wasInHydratedSubtree = finishedWork.deletions, wasInHydratedSubtree !== null && 0 < wasInHydratedSubtree.length && wasInHydratedSubtree[0].tag === 18 ? (inHydratedSubtree = false, prevProfilerEffectDuration = prevProfilerEffectDuration.hydrationErrors, prevProfilerEffectDuration !== null && logComponentErrored(finishedWork, finishedWork.actualStartTime, endTime, prevProfilerEffectDuration)) : inHydratedSubtree = true) : inHydratedSubtree = false;
          recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, endTime);
          inHydratedSubtree = flags;
          break;
        case 13:
          flags = inHydratedSubtree;
          prevProfilerEffectDuration = finishedWork.alternate !== null ? finishedWork.alternate.memoizedState : null;
          wasInHydratedSubtree = finishedWork.memoizedState;
          prevProfilerEffectDuration === null || prevProfilerEffectDuration.dehydrated === null || wasInHydratedSubtree !== null && wasInHydratedSubtree.dehydrated !== null ? inHydratedSubtree = false : (wasInHydratedSubtree = finishedWork.deletions, wasInHydratedSubtree !== null && 0 < wasInHydratedSubtree.length && wasInHydratedSubtree[0].tag === 18 ? (inHydratedSubtree = false, prevProfilerEffectDuration = prevProfilerEffectDuration.hydrationErrors, prevProfilerEffectDuration !== null && logComponentErrored(finishedWork, finishedWork.actualStartTime, endTime, prevProfilerEffectDuration)) : inHydratedSubtree = true);
          recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, endTime);
          inHydratedSubtree = flags;
          break;
        case 23:
          break;
        case 22:
          wasInHydratedSubtree = finishedWork.stateNode;
          prevProfilerEffectDuration = finishedWork.alternate;
          finishedWork.memoizedState !== null ? wasInHydratedSubtree._visibility & OffscreenPassiveEffectsConnected ? recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, endTime) : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, endTime) : wasInHydratedSubtree._visibility & OffscreenPassiveEffectsConnected ? recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, endTime) : (wasInHydratedSubtree._visibility |= OffscreenPassiveEffectsConnected, recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, (finishedWork.subtreeFlags & 10256) !== 0 || finishedWork.actualDuration !== 0 && (finishedWork.alternate === null || finishedWork.alternate.child !== finishedWork.child), endTime), (finishedWork.mode & ProfileMode) === NoMode || inHydratedSubtree || (finishedRoot = finishedWork.actualStartTime, 0 <= finishedRoot && 0.05 < endTime - finishedRoot && logComponentReappeared(finishedWork, finishedRoot, endTime), 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentReappeared(finishedWork, componentEffectStartTime, componentEffectEndTime)));
          flags & 2048 && commitOffscreenPassiveMountEffects(prevProfilerEffectDuration, finishedWork);
          break;
        case 24:
          recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, endTime);
          flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
          break;
        default:
          recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, endTime);
      }
      if ((finishedWork.mode & ProfileMode) !== NoMode) {
        if (finishedRoot = !inHydratedSubtree && finishedWork.alternate === null && finishedWork.return !== null && finishedWork.return.alternate !== null)
          committedLanes = finishedWork.actualStartTime, 0 <= committedLanes && 0.05 < endTime - committedLanes && logComponentTrigger(finishedWork, committedLanes, endTime, "Mount");
        0 <= componentEffectStartTime && 0 <= componentEffectEndTime && ((componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(finishedWork, componentEffectStartTime, componentEffectEndTime, componentEffectDuration, componentEffectErrors), finishedRoot && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentTrigger(finishedWork, componentEffectStartTime, componentEffectEndTime, "Mount"));
      }
      popComponentEffectStart(prevEffectStart);
      popComponentEffectDuration(prevEffectDuration);
      componentEffectErrors = prevEffectErrors;
      componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
      alreadyWarnedForDeepEquality = prevDeepEquality;
    }
    function recursivelyTraverseReconnectPassiveEffects(finishedRoot, parentFiber, committedLanes, committedTransitions, includeWorkInProgressEffects, endTime) {
      includeWorkInProgressEffects = includeWorkInProgressEffects && ((parentFiber.subtreeFlags & 10256) !== 0 || parentFiber.actualDuration !== 0 && (parentFiber.alternate === null || parentFiber.alternate.child !== parentFiber.child));
      for (parentFiber = parentFiber.child;parentFiber !== null; ) {
        var nextSibling = parentFiber.sibling;
        reconnectPassiveEffects(finishedRoot, parentFiber, committedLanes, committedTransitions, includeWorkInProgressEffects, nextSibling !== null ? nextSibling.actualStartTime : endTime);
        parentFiber = nextSibling;
      }
    }
    function reconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects, endTime) {
      var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate(), prevDeepEquality = alreadyWarnedForDeepEquality;
      includeWorkInProgressEffects && (finishedWork.mode & ProfileMode) !== NoMode && 0 < finishedWork.actualStartTime && (finishedWork.flags & 1) !== 0 && logComponentRender(finishedWork, finishedWork.actualStartTime, endTime, inHydratedSubtree, committedLanes);
      var flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15:
          recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects, endTime);
          commitHookPassiveMountEffects(finishedWork, Passive);
          break;
        case 23:
          break;
        case 22:
          var _instance2 = finishedWork.stateNode;
          finishedWork.memoizedState !== null ? _instance2._visibility & OffscreenPassiveEffectsConnected ? recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects, endTime) : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, endTime) : (_instance2._visibility |= OffscreenPassiveEffectsConnected, recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects, endTime));
          includeWorkInProgressEffects && flags & 2048 && commitOffscreenPassiveMountEffects(finishedWork.alternate, finishedWork);
          break;
        case 24:
          recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects, endTime);
          includeWorkInProgressEffects && flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
          break;
        default:
          recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects, endTime);
      }
      (finishedWork.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && (componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(finishedWork, componentEffectStartTime, componentEffectEndTime, componentEffectDuration, componentEffectErrors);
      popComponentEffectStart(prevEffectStart);
      popComponentEffectDuration(prevEffectDuration);
      componentEffectErrors = prevEffectErrors;
      componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
      alreadyWarnedForDeepEquality = prevDeepEquality;
    }
    function recursivelyTraverseAtomicPassiveEffects(finishedRoot$jscomp$0, parentFiber, committedLanes$jscomp$0, committedTransitions$jscomp$0, endTime$jscomp$0) {
      if (parentFiber.subtreeFlags & 10256 || parentFiber.actualDuration !== 0 && (parentFiber.alternate === null || parentFiber.alternate.child !== parentFiber.child))
        for (var child = parentFiber.child;child !== null; ) {
          parentFiber = child.sibling;
          var finishedRoot = finishedRoot$jscomp$0, committedLanes = committedLanes$jscomp$0, committedTransitions = committedTransitions$jscomp$0, endTime = parentFiber !== null ? parentFiber.actualStartTime : endTime$jscomp$0, prevDeepEquality = alreadyWarnedForDeepEquality;
          (child.mode & ProfileMode) !== NoMode && 0 < child.actualStartTime && (child.flags & 1) !== 0 && logComponentRender(child, child.actualStartTime, endTime, inHydratedSubtree, committedLanes);
          var flags = child.flags;
          switch (child.tag) {
            case 22:
              recursivelyTraverseAtomicPassiveEffects(finishedRoot, child, committedLanes, committedTransitions, endTime);
              flags & 2048 && commitOffscreenPassiveMountEffects(child.alternate, child);
              break;
            case 24:
              recursivelyTraverseAtomicPassiveEffects(finishedRoot, child, committedLanes, committedTransitions, endTime);
              flags & 2048 && commitCachePassiveMountEffect(child.alternate, child);
              break;
            default:
              recursivelyTraverseAtomicPassiveEffects(finishedRoot, child, committedLanes, committedTransitions, endTime);
          }
          alreadyWarnedForDeepEquality = prevDeepEquality;
          child = parentFiber;
        }
    }
    function recursivelyAccumulateSuspenseyCommit(parentFiber, committedLanes, suspendedState) {
      if (parentFiber.subtreeFlags & suspenseyCommitFlag)
        for (parentFiber = parentFiber.child;parentFiber !== null; )
          accumulateSuspenseyCommitOnFiber(parentFiber, committedLanes, suspendedState), parentFiber = parentFiber.sibling;
    }
    function accumulateSuspenseyCommitOnFiber(fiber, committedLanes, suspendedState) {
      switch (fiber.tag) {
        case 26:
          recursivelyAccumulateSuspenseyCommit(fiber, committedLanes, suspendedState);
          fiber.flags & suspenseyCommitFlag && fiber.memoizedState !== null && suspendResource(suspendedState, currentHoistableRoot, fiber.memoizedState, fiber.memoizedProps);
          break;
        case 5:
          recursivelyAccumulateSuspenseyCommit(fiber, committedLanes, suspendedState);
          break;
        case 3:
        case 4:
          var previousHoistableRoot = currentHoistableRoot;
          currentHoistableRoot = getHoistableRoot(fiber.stateNode.containerInfo);
          recursivelyAccumulateSuspenseyCommit(fiber, committedLanes, suspendedState);
          currentHoistableRoot = previousHoistableRoot;
          break;
        case 22:
          fiber.memoizedState === null && (previousHoistableRoot = fiber.alternate, previousHoistableRoot !== null && previousHoistableRoot.memoizedState !== null ? (previousHoistableRoot = suspenseyCommitFlag, suspenseyCommitFlag = 16777216, recursivelyAccumulateSuspenseyCommit(fiber, committedLanes, suspendedState), suspenseyCommitFlag = previousHoistableRoot) : recursivelyAccumulateSuspenseyCommit(fiber, committedLanes, suspendedState));
          break;
        default:
          recursivelyAccumulateSuspenseyCommit(fiber, committedLanes, suspendedState);
      }
    }
    function detachAlternateSiblings(parentFiber) {
      var previousFiber = parentFiber.alternate;
      if (previousFiber !== null && (parentFiber = previousFiber.child, parentFiber !== null)) {
        previousFiber.child = null;
        do
          previousFiber = parentFiber.sibling, parentFiber.sibling = null, parentFiber = previousFiber;
        while (parentFiber !== null);
      }
    }
    function recursivelyTraversePassiveUnmountEffects(parentFiber) {
      var deletions = parentFiber.deletions;
      if ((parentFiber.flags & 16) !== 0) {
        if (deletions !== null)
          for (var i = 0;i < deletions.length; i++) {
            var childToDelete = deletions[i], prevEffectStart = pushComponentEffectStart();
            nextEffect = childToDelete;
            commitPassiveUnmountEffectsInsideOfDeletedTree_begin(childToDelete, parentFiber);
            (childToDelete.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentTrigger(childToDelete, componentEffectStartTime, componentEffectEndTime, "Unmount");
            popComponentEffectStart(prevEffectStart);
          }
        detachAlternateSiblings(parentFiber);
      }
      if (parentFiber.subtreeFlags & 10256)
        for (parentFiber = parentFiber.child;parentFiber !== null; )
          commitPassiveUnmountOnFiber(parentFiber), parentFiber = parentFiber.sibling;
    }
    function commitPassiveUnmountOnFiber(finishedWork) {
      var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate();
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15:
          recursivelyTraversePassiveUnmountEffects(finishedWork);
          finishedWork.flags & 2048 && commitHookPassiveUnmountEffects(finishedWork, finishedWork.return, Passive | HasEffect);
          break;
        case 3:
          var prevProfilerEffectDuration = pushNestedEffectDurations();
          recursivelyTraversePassiveUnmountEffects(finishedWork);
          finishedWork.stateNode.passiveEffectDuration += popNestedEffectDurations(prevProfilerEffectDuration);
          break;
        case 12:
          prevProfilerEffectDuration = pushNestedEffectDurations();
          recursivelyTraversePassiveUnmountEffects(finishedWork);
          finishedWork.stateNode.passiveEffectDuration += bubbleNestedEffectDurations(prevProfilerEffectDuration);
          break;
        case 22:
          prevProfilerEffectDuration = finishedWork.stateNode;
          finishedWork.memoizedState !== null && prevProfilerEffectDuration._visibility & OffscreenPassiveEffectsConnected && (finishedWork.return === null || finishedWork.return.tag !== 13) ? (prevProfilerEffectDuration._visibility &= ~OffscreenPassiveEffectsConnected, recursivelyTraverseDisconnectPassiveEffects(finishedWork), (finishedWork.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentTrigger(finishedWork, componentEffectStartTime, componentEffectEndTime, "Disconnect")) : recursivelyTraversePassiveUnmountEffects(finishedWork);
          break;
        default:
          recursivelyTraversePassiveUnmountEffects(finishedWork);
      }
      (finishedWork.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && (componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(finishedWork, componentEffectStartTime, componentEffectEndTime, componentEffectDuration, componentEffectErrors);
      popComponentEffectStart(prevEffectStart);
      popComponentEffectDuration(prevEffectDuration);
      componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
      componentEffectErrors = prevEffectErrors;
    }
    function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
      var deletions = parentFiber.deletions;
      if ((parentFiber.flags & 16) !== 0) {
        if (deletions !== null)
          for (var i = 0;i < deletions.length; i++) {
            var childToDelete = deletions[i], prevEffectStart = pushComponentEffectStart();
            nextEffect = childToDelete;
            commitPassiveUnmountEffectsInsideOfDeletedTree_begin(childToDelete, parentFiber);
            (childToDelete.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && 0.05 < componentEffectEndTime - componentEffectStartTime && logComponentTrigger(childToDelete, componentEffectStartTime, componentEffectEndTime, "Unmount");
            popComponentEffectStart(prevEffectStart);
          }
        detachAlternateSiblings(parentFiber);
      }
      for (parentFiber = parentFiber.child;parentFiber !== null; )
        disconnectPassiveEffect(parentFiber), parentFiber = parentFiber.sibling;
    }
    function disconnectPassiveEffect(finishedWork) {
      var prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate();
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15:
          commitHookPassiveUnmountEffects(finishedWork, finishedWork.return, Passive);
          recursivelyTraverseDisconnectPassiveEffects(finishedWork);
          break;
        case 22:
          var instance = finishedWork.stateNode;
          instance._visibility & OffscreenPassiveEffectsConnected && (instance._visibility &= ~OffscreenPassiveEffectsConnected, recursivelyTraverseDisconnectPassiveEffects(finishedWork));
          break;
        default:
          recursivelyTraverseDisconnectPassiveEffects(finishedWork);
      }
      (finishedWork.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && (componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(finishedWork, componentEffectStartTime, componentEffectEndTime, componentEffectDuration, componentEffectErrors);
      popComponentEffectStart(prevEffectStart);
      popComponentEffectDuration(prevEffectDuration);
      componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
      componentEffectErrors = prevEffectErrors;
    }
    function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor$jscomp$0) {
      for (;nextEffect !== null; ) {
        var fiber = nextEffect, current2 = fiber, nearestMountedAncestor = nearestMountedAncestor$jscomp$0, prevEffectStart = pushComponentEffectStart(), prevEffectDuration = pushComponentEffectDuration(), prevEffectErrors = pushComponentEffectErrors(), prevEffectDidSpawnUpdate = pushComponentEffectDidSpawnUpdate();
        switch (current2.tag) {
          case 0:
          case 11:
          case 15:
            commitHookPassiveUnmountEffects(current2, nearestMountedAncestor, Passive);
            break;
          case 23:
          case 22:
            current2.memoizedState !== null && current2.memoizedState.cachePool !== null && (nearestMountedAncestor = current2.memoizedState.cachePool.pool, nearestMountedAncestor != null && retainCache(nearestMountedAncestor));
            break;
          case 24:
            releaseCache(current2.memoizedState.cache);
        }
        (current2.mode & ProfileMode) !== NoMode && 0 <= componentEffectStartTime && 0 <= componentEffectEndTime && (componentEffectSpawnedUpdate || 0.05 < componentEffectDuration) && logComponentEffect(current2, componentEffectStartTime, componentEffectEndTime, componentEffectDuration, componentEffectErrors);
        popComponentEffectStart(prevEffectStart);
        popComponentEffectDuration(prevEffectDuration);
        componentEffectSpawnedUpdate = prevEffectDidSpawnUpdate;
        componentEffectErrors = prevEffectErrors;
        current2 = fiber.child;
        if (current2 !== null)
          current2.return = fiber, nextEffect = current2;
        else
          a:
            for (fiber = deletedSubtreeRoot;nextEffect !== null; ) {
              current2 = nextEffect;
              prevEffectStart = current2.sibling;
              prevEffectDuration = current2.return;
              detachFiberAfterEffects(current2);
              if (current2 === fiber) {
                nextEffect = null;
                break a;
              }
              if (prevEffectStart !== null) {
                prevEffectStart.return = prevEffectDuration;
                nextEffect = prevEffectStart;
                break a;
              }
              nextEffect = prevEffectDuration;
            }
      }
    }
    function onCommitRoot() {
      commitHooks.forEach(function(commitHook) {
        return commitHook();
      });
    }
    function isConcurrentActEnvironment() {
      var isReactActEnvironmentGlobal = typeof IS_REACT_ACT_ENVIRONMENT !== "undefined" ? IS_REACT_ACT_ENVIRONMENT : undefined;
      isReactActEnvironmentGlobal || ReactSharedInternals.actQueue === null || console.error("The current testing environment is not configured to support act(...)");
      return isReactActEnvironmentGlobal;
    }
    function requestUpdateLane(fiber) {
      if ((executionContext & RenderContext) !== NoContext && workInProgressRootRenderLanes !== 0)
        return workInProgressRootRenderLanes & -workInProgressRootRenderLanes;
      var transition = ReactSharedInternals.T;
      return transition !== null ? (transition._updatedFibers || (transition._updatedFibers = new Set), transition._updatedFibers.add(fiber), requestTransitionLane()) : resolveUpdatePriority();
    }
    function requestDeferredLane() {
      if (workInProgressDeferredLane === 0)
        if ((workInProgressRootRenderLanes & 536870912) === 0 || isHydrating) {
          var lane = nextTransitionDeferredLane;
          nextTransitionDeferredLane <<= 1;
          (nextTransitionDeferredLane & 3932160) === 0 && (nextTransitionDeferredLane = 262144);
          workInProgressDeferredLane = lane;
        } else
          workInProgressDeferredLane = 536870912;
      lane = suspenseHandlerStackCursor.current;
      lane !== null && (lane.flags |= 32);
      return workInProgressDeferredLane;
    }
    function scheduleUpdateOnFiber(root2, fiber, lane) {
      isRunningInsertionEffect && console.error("useInsertionEffect must not schedule updates.");
      isFlushingPassiveEffects && (didScheduleUpdateDuringPassiveEffects = true);
      if (root2 === workInProgressRoot && (workInProgressSuspendedReason === SuspendedOnData || workInProgressSuspendedReason === SuspendedOnAction) || root2.cancelPendingCommit !== null)
        prepareFreshStack(root2, 0), markRootSuspended(root2, workInProgressRootRenderLanes, workInProgressDeferredLane, false);
      markRootUpdated$1(root2, lane);
      if ((executionContext & RenderContext) !== NoContext && root2 === workInProgressRoot) {
        if (isRendering)
          switch (fiber.tag) {
            case 0:
            case 11:
            case 15:
              root2 = workInProgress && getComponentNameFromFiber(workInProgress) || "Unknown";
              didWarnAboutUpdateInRenderForAnotherComponent.has(root2) || (didWarnAboutUpdateInRenderForAnotherComponent.add(root2), fiber = getComponentNameFromFiber(fiber) || "Unknown", console.error("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://react.dev/link/setstate-in-render", fiber, root2, root2));
              break;
            case 1:
              didWarnAboutUpdateInRender || (console.error("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."), didWarnAboutUpdateInRender = true);
          }
      } else
        isDevToolsPresent && addFiberToLanesMap(root2, fiber, lane), warnIfUpdatesNotWrappedWithActDEV(fiber), root2 === workInProgressRoot && ((executionContext & RenderContext) === NoContext && (workInProgressRootInterleavedUpdatedLanes |= lane), workInProgressRootExitStatus === RootSuspendedWithDelay && markRootSuspended(root2, workInProgressRootRenderLanes, workInProgressDeferredLane, false)), ensureRootIsScheduled(root2);
    }
    function performWorkOnRoot(root2, lanes, forceSync) {
      if ((executionContext & (RenderContext | CommitContext)) !== NoContext)
        throw Error("Should not already be working.");
      if (workInProgressRootRenderLanes !== 0 && workInProgress !== null) {
        var yieldedFiber = workInProgress, yieldEndTime = now$1();
        switch (yieldReason) {
          case SuspendedOnImmediate:
          case SuspendedOnData:
            var startTime = yieldStartTime;
            supportsUserTiming && ((yieldedFiber = yieldedFiber._debugTask) ? yieldedFiber.run(console.timeStamp.bind(console, "Suspended", startTime, yieldEndTime, COMPONENTS_TRACK, undefined, "primary-light")) : console.timeStamp("Suspended", startTime, yieldEndTime, COMPONENTS_TRACK, undefined, "primary-light"));
            break;
          case SuspendedOnAction:
            startTime = yieldStartTime;
            supportsUserTiming && ((yieldedFiber = yieldedFiber._debugTask) ? yieldedFiber.run(console.timeStamp.bind(console, "Action", startTime, yieldEndTime, COMPONENTS_TRACK, undefined, "primary-light")) : console.timeStamp("Action", startTime, yieldEndTime, COMPONENTS_TRACK, undefined, "primary-light"));
            break;
          default:
            supportsUserTiming && (yieldedFiber = yieldEndTime - yieldStartTime, 3 > yieldedFiber || console.timeStamp("Blocked", yieldStartTime, yieldEndTime, COMPONENTS_TRACK, undefined, 5 > yieldedFiber ? "primary-light" : 10 > yieldedFiber ? "primary" : 100 > yieldedFiber ? "primary-dark" : "error"));
        }
      }
      startTime = (forceSync = !forceSync && (lanes & 127) === 0 && (lanes & root2.expiredLanes) === 0 || checkIfRootIsPrerendering(root2, lanes)) ? renderRootConcurrent(root2, lanes) : renderRootSync(root2, lanes, true);
      var renderWasConcurrent = forceSync;
      do {
        if (startTime === RootInProgress) {
          workInProgressRootIsPrerendering && !forceSync && markRootSuspended(root2, lanes, 0, false);
          lanes = workInProgressSuspendedReason;
          yieldStartTime = now();
          yieldReason = lanes;
          break;
        } else {
          yieldedFiber = now$1();
          yieldEndTime = root2.current.alternate;
          if (renderWasConcurrent && !isRenderConsistentWithExternalStores(yieldEndTime)) {
            setCurrentTrackFromLanes(lanes);
            yieldEndTime = renderStartTime;
            startTime = yieldedFiber;
            !supportsUserTiming || startTime <= yieldEndTime || (workInProgressUpdateTask ? workInProgressUpdateTask.run(console.timeStamp.bind(console, "Teared Render", yieldEndTime, startTime, currentTrack, LANES_TRACK_GROUP, "error")) : console.timeStamp("Teared Render", yieldEndTime, startTime, currentTrack, LANES_TRACK_GROUP, "error"));
            finalizeRender(lanes, yieldedFiber);
            startTime = renderRootSync(root2, lanes, false);
            renderWasConcurrent = false;
            continue;
          }
          if (startTime === RootErrored) {
            renderWasConcurrent = lanes;
            if (root2.errorRecoveryDisabledLanes & renderWasConcurrent)
              var errorRetryLanes = 0;
            else
              errorRetryLanes = root2.pendingLanes & -536870913, errorRetryLanes = errorRetryLanes !== 0 ? errorRetryLanes : errorRetryLanes & 536870912 ? 536870912 : 0;
            if (errorRetryLanes !== 0) {
              setCurrentTrackFromLanes(lanes);
              logErroredRenderPhase(renderStartTime, yieldedFiber, lanes, workInProgressUpdateTask);
              finalizeRender(lanes, yieldedFiber);
              lanes = errorRetryLanes;
              a: {
                yieldedFiber = root2;
                startTime = renderWasConcurrent;
                renderWasConcurrent = workInProgressRootConcurrentErrors;
                var wasRootDehydrated = yieldedFiber.current.memoizedState.isDehydrated;
                wasRootDehydrated && (prepareFreshStack(yieldedFiber, errorRetryLanes).flags |= 256);
                errorRetryLanes = renderRootSync(yieldedFiber, errorRetryLanes, false);
                if (errorRetryLanes !== RootErrored) {
                  if (workInProgressRootDidAttachPingListener && !wasRootDehydrated) {
                    yieldedFiber.errorRecoveryDisabledLanes |= startTime;
                    workInProgressRootInterleavedUpdatedLanes |= startTime;
                    startTime = RootSuspendedWithDelay;
                    break a;
                  }
                  yieldedFiber = workInProgressRootRecoverableErrors;
                  workInProgressRootRecoverableErrors = renderWasConcurrent;
                  yieldedFiber !== null && (workInProgressRootRecoverableErrors === null ? workInProgressRootRecoverableErrors = yieldedFiber : workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors, yieldedFiber));
                }
                startTime = errorRetryLanes;
              }
              renderWasConcurrent = false;
              if (startTime !== RootErrored)
                continue;
              else
                yieldedFiber = now$1();
            }
          }
          if (startTime === RootFatalErrored) {
            setCurrentTrackFromLanes(lanes);
            logErroredRenderPhase(renderStartTime, yieldedFiber, lanes, workInProgressUpdateTask);
            finalizeRender(lanes, yieldedFiber);
            prepareFreshStack(root2, 0);
            markRootSuspended(root2, lanes, 0, true);
            break;
          }
          a: {
            forceSync = root2;
            switch (startTime) {
              case RootInProgress:
              case RootFatalErrored:
                throw Error("Root did not complete. This is a bug in React.");
              case RootSuspendedWithDelay:
                if ((lanes & 4194048) !== lanes)
                  break;
              case RootSuspendedAtTheShell:
                setCurrentTrackFromLanes(lanes);
                logSuspendedRenderPhase(renderStartTime, yieldedFiber, lanes, workInProgressUpdateTask);
                finalizeRender(lanes, yieldedFiber);
                yieldEndTime = lanes;
                (yieldEndTime & 127) !== 0 ? blockingSuspendedTime = yieldedFiber : (yieldEndTime & 4194048) !== 0 && (transitionSuspendedTime = yieldedFiber);
                markRootSuspended(forceSync, lanes, workInProgressDeferredLane, !workInProgressRootDidSkipSuspendedSiblings);
                break a;
              case RootErrored:
                workInProgressRootRecoverableErrors = null;
                break;
              case RootSuspended:
              case RootCompleted:
                break;
              default:
                throw Error("Unknown root exit status.");
            }
            if (ReactSharedInternals.actQueue !== null)
              commitRoot(forceSync, yieldEndTime, lanes, workInProgressRootRecoverableErrors, workInProgressTransitions, workInProgressRootDidIncludeRecursiveRenderUpdate, workInProgressDeferredLane, workInProgressRootInterleavedUpdatedLanes, workInProgressSuspendedRetryLanes, startTime, null, null, renderStartTime, yieldedFiber);
            else {
              if ((lanes & 62914560) === lanes && (renderWasConcurrent = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now$1(), 10 < renderWasConcurrent)) {
                markRootSuspended(forceSync, lanes, workInProgressDeferredLane, !workInProgressRootDidSkipSuspendedSiblings);
                if (getNextLanes(forceSync, 0, true) !== 0)
                  break a;
                pendingEffectsLanes = lanes;
                forceSync.timeoutHandle = scheduleTimeout(commitRootWhenReady.bind(null, forceSync, yieldEndTime, workInProgressRootRecoverableErrors, workInProgressTransitions, workInProgressRootDidIncludeRecursiveRenderUpdate, lanes, workInProgressDeferredLane, workInProgressRootInterleavedUpdatedLanes, workInProgressSuspendedRetryLanes, workInProgressRootDidSkipSuspendedSiblings, startTime, "Throttled", renderStartTime, yieldedFiber), renderWasConcurrent);
                break a;
              }
              commitRootWhenReady(forceSync, yieldEndTime, workInProgressRootRecoverableErrors, workInProgressTransitions, workInProgressRootDidIncludeRecursiveRenderUpdate, lanes, workInProgressDeferredLane, workInProgressRootInterleavedUpdatedLanes, workInProgressSuspendedRetryLanes, workInProgressRootDidSkipSuspendedSiblings, startTime, null, renderStartTime, yieldedFiber);
            }
          }
        }
        break;
      } while (1);
      ensureRootIsScheduled(root2);
    }
    function commitRootWhenReady(root2, finishedWork, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, lanes, spawnedLane, updatedLanes, suspendedRetryLanes, didSkipSuspendedSiblings, exitStatus, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {
      root2.timeoutHandle = noTimeout;
      var subtreeFlags = finishedWork.subtreeFlags, suspendedState = null;
      if (subtreeFlags & 8192 || (subtreeFlags & 16785408) === 16785408) {
        if (suspendedState = {
          stylesheets: null,
          count: 0,
          imgCount: 0,
          imgBytes: 0,
          suspenseyImages: [],
          waitingForImages: true,
          waitingForViewTransition: false,
          unsuspend: noop$1
        }, accumulateSuspenseyCommitOnFiber(finishedWork, lanes, suspendedState), subtreeFlags = (lanes & 62914560) === lanes ? globalMostRecentFallbackTime - now$1() : (lanes & 4194048) === lanes ? globalMostRecentTransitionTime - now$1() : 0, subtreeFlags = waitForCommitToBeReady(suspendedState, subtreeFlags), subtreeFlags !== null) {
          pendingEffectsLanes = lanes;
          root2.cancelPendingCommit = subtreeFlags(commitRoot.bind(null, root2, finishedWork, lanes, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes, exitStatus, suspendedState, suspendedState.waitingForViewTransition ? "Waiting for the previous Animation" : 0 < suspendedState.count ? 0 < suspendedState.imgCount ? "Suspended on CSS and Images" : "Suspended on CSS" : suspendedState.imgCount === 1 ? "Suspended on an Image" : 0 < suspendedState.imgCount ? "Suspended on Images" : null, completedRenderStartTime, completedRenderEndTime));
          markRootSuspended(root2, lanes, spawnedLane, !didSkipSuspendedSiblings);
          return;
        }
      }
      commitRoot(root2, finishedWork, lanes, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes, exitStatus, suspendedState, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime);
    }
    function isRenderConsistentWithExternalStores(finishedWork) {
      for (var node = finishedWork;; ) {
        var tag = node.tag;
        if ((tag === 0 || tag === 11 || tag === 15) && node.flags & 16384 && (tag = node.updateQueue, tag !== null && (tag = tag.stores, tag !== null)))
          for (var i = 0;i < tag.length; i++) {
            var check = tag[i], getSnapshot = check.getSnapshot;
            check = check.value;
            try {
              if (!objectIs(getSnapshot(), check))
                return false;
            } catch (error) {
              return false;
            }
          }
        tag = node.child;
        if (node.subtreeFlags & 16384 && tag !== null)
          tag.return = node, node = tag;
        else {
          if (node === finishedWork)
            break;
          for (;node.sibling === null; ) {
            if (node.return === null || node.return === finishedWork)
              return true;
            node = node.return;
          }
          node.sibling.return = node.return;
          node = node.sibling;
        }
      }
      return true;
    }
    function markRootSuspended(root2, suspendedLanes, spawnedLane, didAttemptEntireTree) {
      suspendedLanes &= ~workInProgressRootPingedLanes;
      suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;
      root2.suspendedLanes |= suspendedLanes;
      root2.pingedLanes &= ~suspendedLanes;
      didAttemptEntireTree && (root2.warmLanes |= suspendedLanes);
      didAttemptEntireTree = root2.expirationTimes;
      for (var lanes = suspendedLanes;0 < lanes; ) {
        var index = 31 - clz32(lanes), lane = 1 << index;
        didAttemptEntireTree[index] = -1;
        lanes &= ~lane;
      }
      spawnedLane !== 0 && markSpawnedDeferredLane(root2, spawnedLane, suspendedLanes);
    }
    function flushSyncWork$1() {
      return (executionContext & (RenderContext | CommitContext)) === NoContext ? (flushSyncWorkAcrossRoots_impl(0, false), false) : true;
    }
    function resetWorkInProgressStack() {
      if (workInProgress !== null) {
        if (workInProgressSuspendedReason === NotSuspended)
          var interruptedWork = workInProgress.return;
        else
          interruptedWork = workInProgress, resetContextDependencies(), resetHooksOnUnwind(interruptedWork), thenableState$1 = null, thenableIndexCounter$1 = 0, interruptedWork = workInProgress;
        for (;interruptedWork !== null; )
          unwindInterruptedWork(interruptedWork.alternate, interruptedWork), interruptedWork = interruptedWork.return;
        workInProgress = null;
      }
    }
    function finalizeRender(lanes, finalizationTime) {
      (lanes & 127) !== 0 && (blockingClampTime = finalizationTime);
      (lanes & 4194048) !== 0 && (transitionClampTime = finalizationTime);
      (lanes & 62914560) !== 0 && (retryClampTime = finalizationTime);
      (lanes & 2080374784) !== 0 && (idleClampTime = finalizationTime);
    }
    function prepareFreshStack(root2, lanes) {
      supportsUserTiming && (console.timeStamp("Blocking Track", 0.003, 0.003, "Blocking", LANES_TRACK_GROUP, "primary-light"), console.timeStamp("Transition Track", 0.003, 0.003, "Transition", LANES_TRACK_GROUP, "primary-light"), console.timeStamp("Suspense Track", 0.003, 0.003, "Suspense", LANES_TRACK_GROUP, "primary-light"), console.timeStamp("Idle Track", 0.003, 0.003, "Idle", LANES_TRACK_GROUP, "primary-light"));
      var previousRenderStartTime = renderStartTime;
      renderStartTime = now();
      if (workInProgressRootRenderLanes !== 0 && 0 < previousRenderStartTime) {
        setCurrentTrackFromLanes(workInProgressRootRenderLanes);
        if (workInProgressRootExitStatus === RootSuspended || workInProgressRootExitStatus === RootSuspendedWithDelay)
          logSuspendedRenderPhase(previousRenderStartTime, renderStartTime, lanes, workInProgressUpdateTask);
        else {
          var endTime = renderStartTime, debugTask = workInProgressUpdateTask;
          if (supportsUserTiming && !(endTime <= previousRenderStartTime)) {
            var color = (lanes & 738197653) === lanes ? "tertiary-dark" : "primary-dark", label = (lanes & 536870912) === lanes ? "Prewarm" : (lanes & 201326741) === lanes ? "Interrupted Hydration" : "Interrupted Render";
            debugTask ? debugTask.run(console.timeStamp.bind(console, label, previousRenderStartTime, endTime, currentTrack, LANES_TRACK_GROUP, color)) : console.timeStamp(label, previousRenderStartTime, endTime, currentTrack, LANES_TRACK_GROUP, color);
          }
        }
        finalizeRender(workInProgressRootRenderLanes, renderStartTime);
      }
      previousRenderStartTime = workInProgressUpdateTask;
      workInProgressUpdateTask = null;
      if ((lanes & 127) !== 0) {
        workInProgressUpdateTask = blockingUpdateTask;
        debugTask = 0 <= blockingUpdateTime && blockingUpdateTime < blockingClampTime ? blockingClampTime : blockingUpdateTime;
        endTime = 0 <= blockingEventTime && blockingEventTime < blockingClampTime ? blockingClampTime : blockingEventTime;
        color = 0 <= endTime ? endTime : 0 <= debugTask ? debugTask : renderStartTime;
        0 <= blockingSuspendedTime ? (setCurrentTrackFromLanes(2), logSuspendedWithDelayPhase(blockingSuspendedTime, color, lanes, previousRenderStartTime)) : (animatingLanes & 127) !== 0 && (setCurrentTrackFromLanes(2), logAnimatingPhase(blockingClampTime, color, animatingTask));
        previousRenderStartTime = debugTask;
        var eventTime = endTime, eventType = blockingEventType, eventIsRepeat = 0 < blockingEventRepeatTime, isSpawnedUpdate = blockingUpdateType === SPAWNED_UPDATE, isPingedUpdate = blockingUpdateType === PINGED_UPDATE;
        debugTask = renderStartTime;
        endTime = blockingUpdateTask;
        color = blockingUpdateMethodName;
        label = blockingUpdateComponentName;
        if (supportsUserTiming) {
          currentTrack = "Blocking";
          0 < previousRenderStartTime ? previousRenderStartTime > debugTask && (previousRenderStartTime = debugTask) : previousRenderStartTime = debugTask;
          0 < eventTime ? eventTime > previousRenderStartTime && (eventTime = previousRenderStartTime) : eventTime = previousRenderStartTime;
          if (eventType !== null && previousRenderStartTime > eventTime) {
            var color$jscomp$0 = eventIsRepeat ? "secondary-light" : "warning";
            endTime ? endTime.run(console.timeStamp.bind(console, eventIsRepeat ? "Consecutive" : "Event: " + eventType, eventTime, previousRenderStartTime, currentTrack, LANES_TRACK_GROUP, color$jscomp$0)) : console.timeStamp(eventIsRepeat ? "Consecutive" : "Event: " + eventType, eventTime, previousRenderStartTime, currentTrack, LANES_TRACK_GROUP, color$jscomp$0);
          }
          debugTask > previousRenderStartTime && (eventTime = isSpawnedUpdate ? "error" : (lanes & 738197653) === lanes ? "tertiary-light" : "primary-light", isSpawnedUpdate = isPingedUpdate ? "Promise Resolved" : isSpawnedUpdate ? "Cascading Update" : 5 < debugTask - previousRenderStartTime ? "Update Blocked" : "Update", isPingedUpdate = [], label != null && isPingedUpdate.push(["Component name", label]), color != null && isPingedUpdate.push(["Method name", color]), previousRenderStartTime = {
            start: previousRenderStartTime,
            end: debugTask,
            detail: {
              devtools: {
                properties: isPingedUpdate,
                track: currentTrack,
                trackGroup: LANES_TRACK_GROUP,
                color: eventTime
              }
            }
          }, endTime ? endTime.run(performance.measure.bind(performance, isSpawnedUpdate, previousRenderStartTime)) : performance.measure(isSpawnedUpdate, previousRenderStartTime));
        }
        blockingUpdateTime = -1.1;
        blockingUpdateType = 0;
        blockingUpdateComponentName = blockingUpdateMethodName = null;
        blockingSuspendedTime = -1.1;
        blockingEventRepeatTime = blockingEventTime;
        blockingEventTime = -1.1;
        blockingClampTime = now();
      }
      (lanes & 4194048) !== 0 && (workInProgressUpdateTask = transitionUpdateTask, debugTask = 0 <= transitionStartTime && transitionStartTime < transitionClampTime ? transitionClampTime : transitionStartTime, previousRenderStartTime = 0 <= transitionUpdateTime && transitionUpdateTime < transitionClampTime ? transitionClampTime : transitionUpdateTime, endTime = 0 <= transitionEventTime && transitionEventTime < transitionClampTime ? transitionClampTime : transitionEventTime, color = 0 <= endTime ? endTime : 0 <= previousRenderStartTime ? previousRenderStartTime : renderStartTime, 0 <= transitionSuspendedTime ? (setCurrentTrackFromLanes(256), logSuspendedWithDelayPhase(transitionSuspendedTime, color, lanes, workInProgressUpdateTask)) : (animatingLanes & 4194048) !== 0 && (setCurrentTrackFromLanes(256), logAnimatingPhase(transitionClampTime, color, animatingTask)), isPingedUpdate = endTime, eventTime = transitionEventType, eventType = 0 < transitionEventRepeatTime, eventIsRepeat = transitionUpdateType === PINGED_UPDATE, color = renderStartTime, endTime = transitionUpdateTask, label = transitionUpdateMethodName, isSpawnedUpdate = transitionUpdateComponentName, supportsUserTiming && (currentTrack = "Transition", 0 < previousRenderStartTime ? previousRenderStartTime > color && (previousRenderStartTime = color) : previousRenderStartTime = color, 0 < debugTask ? debugTask > previousRenderStartTime && (debugTask = previousRenderStartTime) : debugTask = previousRenderStartTime, 0 < isPingedUpdate ? isPingedUpdate > debugTask && (isPingedUpdate = debugTask) : isPingedUpdate = debugTask, debugTask > isPingedUpdate && eventTime !== null && (color$jscomp$0 = eventType ? "secondary-light" : "warning", endTime ? endTime.run(console.timeStamp.bind(console, eventType ? "Consecutive" : "Event: " + eventTime, isPingedUpdate, debugTask, currentTrack, LANES_TRACK_GROUP, color$jscomp$0)) : console.timeStamp(eventType ? "Consecutive" : "Event: " + eventTime, isPingedUpdate, debugTask, currentTrack, LANES_TRACK_GROUP, color$jscomp$0)), previousRenderStartTime > debugTask && (endTime ? endTime.run(console.timeStamp.bind(console, "Action", debugTask, previousRenderStartTime, currentTrack, LANES_TRACK_GROUP, "primary-dark")) : console.timeStamp("Action", debugTask, previousRenderStartTime, currentTrack, LANES_TRACK_GROUP, "primary-dark")), color > previousRenderStartTime && (debugTask = eventIsRepeat ? "Promise Resolved" : 5 < color - previousRenderStartTime ? "Update Blocked" : "Update", isPingedUpdate = [], isSpawnedUpdate != null && isPingedUpdate.push(["Component name", isSpawnedUpdate]), label != null && isPingedUpdate.push(["Method name", label]), previousRenderStartTime = {
        start: previousRenderStartTime,
        end: color,
        detail: {
          devtools: {
            properties: isPingedUpdate,
            track: currentTrack,
            trackGroup: LANES_TRACK_GROUP,
            color: "primary-light"
          }
        }
      }, endTime ? endTime.run(performance.measure.bind(performance, debugTask, previousRenderStartTime)) : performance.measure(debugTask, previousRenderStartTime))), transitionUpdateTime = transitionStartTime = -1.1, transitionUpdateType = 0, transitionSuspendedTime = -1.1, transitionEventRepeatTime = transitionEventTime, transitionEventTime = -1.1, transitionClampTime = now());
      (lanes & 62914560) !== 0 && (animatingLanes & 62914560) !== 0 && (setCurrentTrackFromLanes(4194304), logAnimatingPhase(retryClampTime, renderStartTime, animatingTask));
      (lanes & 2080374784) !== 0 && (animatingLanes & 2080374784) !== 0 && (setCurrentTrackFromLanes(268435456), logAnimatingPhase(idleClampTime, renderStartTime, animatingTask));
      previousRenderStartTime = root2.timeoutHandle;
      previousRenderStartTime !== noTimeout && (root2.timeoutHandle = noTimeout, cancelTimeout(previousRenderStartTime));
      previousRenderStartTime = root2.cancelPendingCommit;
      previousRenderStartTime !== null && (root2.cancelPendingCommit = null, previousRenderStartTime());
      pendingEffectsLanes = 0;
      resetWorkInProgressStack();
      workInProgressRoot = root2;
      workInProgress = previousRenderStartTime = createWorkInProgress(root2.current, null);
      workInProgressRootRenderLanes = lanes;
      workInProgressSuspendedReason = NotSuspended;
      workInProgressThrownValue = null;
      workInProgressRootDidSkipSuspendedSiblings = false;
      workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root2, lanes);
      workInProgressRootDidAttachPingListener = false;
      workInProgressRootExitStatus = RootInProgress;
      workInProgressSuspendedRetryLanes = workInProgressDeferredLane = workInProgressRootPingedLanes = workInProgressRootInterleavedUpdatedLanes = workInProgressRootSkippedLanes = 0;
      workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors = null;
      workInProgressRootDidIncludeRecursiveRenderUpdate = false;
      (lanes & 8) !== 0 && (lanes |= lanes & 32);
      endTime = root2.entangledLanes;
      if (endTime !== 0)
        for (root2 = root2.entanglements, endTime &= lanes;0 < endTime; )
          debugTask = 31 - clz32(endTime), color = 1 << debugTask, lanes |= root2[debugTask], endTime &= ~color;
      entangledRenderLanes = lanes;
      finishQueueingConcurrentUpdates();
      root2 = getCurrentTime();
      1000 < root2 - lastResetTime && (ReactSharedInternals.recentlyCreatedOwnerStacks = 0, lastResetTime = root2);
      ReactStrictModeWarnings.discardPendingWarnings();
      return previousRenderStartTime;
    }
    function handleThrow(root2, thrownValue) {
      currentlyRenderingFiber = null;
      ReactSharedInternals.H = ContextOnlyDispatcher;
      ReactSharedInternals.getCurrentStack = null;
      isRendering = false;
      current = null;
      thrownValue === SuspenseException || thrownValue === SuspenseActionException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = SuspendedOnImmediate) : thrownValue === SuspenseyCommitException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = SuspendedOnInstance) : workInProgressSuspendedReason = thrownValue === SelectiveHydrationException ? SuspendedOnHydration : thrownValue !== null && typeof thrownValue === "object" && typeof thrownValue.then === "function" ? SuspendedOnDeprecatedThrowPromise : SuspendedOnError;
      workInProgressThrownValue = thrownValue;
      var erroredWork = workInProgress;
      erroredWork === null ? (workInProgressRootExitStatus = RootFatalErrored, logUncaughtError(root2, createCapturedValueAtFiber(thrownValue, root2.current))) : erroredWork.mode & ProfileMode && stopProfilerTimerIfRunningAndRecordDuration(erroredWork);
    }
    function shouldRemainOnPreviousScreen() {
      var handler = suspenseHandlerStackCursor.current;
      return handler === null ? true : (workInProgressRootRenderLanes & 4194048) === workInProgressRootRenderLanes ? shellBoundary === null ? true : false : (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes || (workInProgressRootRenderLanes & 536870912) !== 0 ? handler === shellBoundary : false;
    }
    function pushDispatcher() {
      var prevDispatcher = ReactSharedInternals.H;
      ReactSharedInternals.H = ContextOnlyDispatcher;
      return prevDispatcher === null ? ContextOnlyDispatcher : prevDispatcher;
    }
    function pushAsyncDispatcher() {
      var prevAsyncDispatcher = ReactSharedInternals.A;
      ReactSharedInternals.A = DefaultAsyncDispatcher;
      return prevAsyncDispatcher;
    }
    function markRenderDerivedCause(fiber) {
      workInProgressUpdateTask === null && (workInProgressUpdateTask = fiber._debugTask == null ? null : fiber._debugTask);
    }
    function renderDidSuspendDelayIfPossible() {
      workInProgressRootExitStatus = RootSuspendedWithDelay;
      workInProgressRootDidSkipSuspendedSiblings || (workInProgressRootRenderLanes & 4194048) !== workInProgressRootRenderLanes && suspenseHandlerStackCursor.current !== null || (workInProgressRootIsPrerendering = true);
      (workInProgressRootSkippedLanes & 134217727) === 0 && (workInProgressRootInterleavedUpdatedLanes & 134217727) === 0 || workInProgressRoot === null || markRootSuspended(workInProgressRoot, workInProgressRootRenderLanes, workInProgressDeferredLane, false);
    }
    function renderRootSync(root2, lanes, shouldYieldForPrerendering) {
      var prevExecutionContext = executionContext;
      executionContext |= RenderContext;
      var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
      if (workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes) {
        if (isDevToolsPresent) {
          var memoizedUpdaters = root2.memoizedUpdaters;
          0 < memoizedUpdaters.size && (restorePendingUpdaters(root2, workInProgressRootRenderLanes), memoizedUpdaters.clear());
          movePendingFibersToMemoized(root2, lanes);
        }
        workInProgressTransitions = null;
        prepareFreshStack(root2, lanes);
      }
      lanes = false;
      memoizedUpdaters = workInProgressRootExitStatus;
      a:
        do
          try {
            if (workInProgressSuspendedReason !== NotSuspended && workInProgress !== null) {
              var unitOfWork = workInProgress, thrownValue = workInProgressThrownValue;
              switch (workInProgressSuspendedReason) {
                case SuspendedOnHydration:
                  resetWorkInProgressStack();
                  memoizedUpdaters = RootSuspendedAtTheShell;
                  break a;
                case SuspendedOnImmediate:
                case SuspendedOnData:
                case SuspendedOnAction:
                case SuspendedOnDeprecatedThrowPromise:
                  suspenseHandlerStackCursor.current === null && (lanes = true);
                  var reason = workInProgressSuspendedReason;
                  workInProgressSuspendedReason = NotSuspended;
                  workInProgressThrownValue = null;
                  throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, reason);
                  if (shouldYieldForPrerendering && workInProgressRootIsPrerendering) {
                    memoizedUpdaters = RootInProgress;
                    break a;
                  }
                  break;
                default:
                  reason = workInProgressSuspendedReason, workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, reason);
              }
            }
            workLoopSync();
            memoizedUpdaters = workInProgressRootExitStatus;
            break;
          } catch (thrownValue$8) {
            handleThrow(root2, thrownValue$8);
          }
        while (1);
      lanes && root2.shellSuspendCounter++;
      resetContextDependencies();
      executionContext = prevExecutionContext;
      ReactSharedInternals.H = prevDispatcher;
      ReactSharedInternals.A = prevAsyncDispatcher;
      workInProgress === null && (workInProgressRoot = null, workInProgressRootRenderLanes = 0, finishQueueingConcurrentUpdates());
      return memoizedUpdaters;
    }
    function workLoopSync() {
      for (;workInProgress !== null; )
        performUnitOfWork(workInProgress);
    }
    function renderRootConcurrent(root2, lanes) {
      var prevExecutionContext = executionContext;
      executionContext |= RenderContext;
      var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
      if (workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes) {
        if (isDevToolsPresent) {
          var memoizedUpdaters = root2.memoizedUpdaters;
          0 < memoizedUpdaters.size && (restorePendingUpdaters(root2, workInProgressRootRenderLanes), memoizedUpdaters.clear());
          movePendingFibersToMemoized(root2, lanes);
        }
        workInProgressTransitions = null;
        workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS;
        prepareFreshStack(root2, lanes);
      } else
        workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root2, lanes);
      a:
        do
          try {
            if (workInProgressSuspendedReason !== NotSuspended && workInProgress !== null)
              b:
                switch (lanes = workInProgress, memoizedUpdaters = workInProgressThrownValue, workInProgressSuspendedReason) {
                  case SuspendedOnError:
                    workInProgressSuspendedReason = NotSuspended;
                    workInProgressThrownValue = null;
                    throwAndUnwindWorkLoop(root2, lanes, memoizedUpdaters, SuspendedOnError);
                    break;
                  case SuspendedOnData:
                  case SuspendedOnAction:
                    if (isThenableResolved(memoizedUpdaters)) {
                      workInProgressSuspendedReason = NotSuspended;
                      workInProgressThrownValue = null;
                      replaySuspendedUnitOfWork(lanes);
                      break;
                    }
                    lanes = function() {
                      workInProgressSuspendedReason !== SuspendedOnData && workInProgressSuspendedReason !== SuspendedOnAction || workInProgressRoot !== root2 || (workInProgressSuspendedReason = SuspendedAndReadyToContinue);
                      ensureRootIsScheduled(root2);
                    };
                    memoizedUpdaters.then(lanes, lanes);
                    break a;
                  case SuspendedOnImmediate:
                    workInProgressSuspendedReason = SuspendedAndReadyToContinue;
                    break a;
                  case SuspendedOnInstance:
                    workInProgressSuspendedReason = SuspendedOnInstanceAndReadyToContinue;
                    break a;
                  case SuspendedAndReadyToContinue:
                    isThenableResolved(memoizedUpdaters) ? (workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, replaySuspendedUnitOfWork(lanes)) : (workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root2, lanes, memoizedUpdaters, SuspendedAndReadyToContinue));
                    break;
                  case SuspendedOnInstanceAndReadyToContinue:
                    var resource = null;
                    switch (workInProgress.tag) {
                      case 26:
                        resource = workInProgress.memoizedState;
                      case 5:
                      case 27:
                        var hostFiber = workInProgress;
                        if (resource ? preloadResource(resource) : hostFiber.stateNode.complete) {
                          workInProgressSuspendedReason = NotSuspended;
                          workInProgressThrownValue = null;
                          var sibling = hostFiber.sibling;
                          if (sibling !== null)
                            workInProgress = sibling;
                          else {
                            var returnFiber = hostFiber.return;
                            returnFiber !== null ? (workInProgress = returnFiber, completeUnitOfWork(returnFiber)) : workInProgress = null;
                          }
                          break b;
                        }
                        break;
                      default:
                        console.error("Unexpected type of fiber triggered a suspensey commit. This is a bug in React.");
                    }
                    workInProgressSuspendedReason = NotSuspended;
                    workInProgressThrownValue = null;
                    throwAndUnwindWorkLoop(root2, lanes, memoizedUpdaters, SuspendedOnInstanceAndReadyToContinue);
                    break;
                  case SuspendedOnDeprecatedThrowPromise:
                    workInProgressSuspendedReason = NotSuspended;
                    workInProgressThrownValue = null;
                    throwAndUnwindWorkLoop(root2, lanes, memoizedUpdaters, SuspendedOnDeprecatedThrowPromise);
                    break;
                  case SuspendedOnHydration:
                    resetWorkInProgressStack();
                    workInProgressRootExitStatus = RootSuspendedAtTheShell;
                    break a;
                  default:
                    throw Error("Unexpected SuspendedReason. This is a bug in React.");
                }
            ReactSharedInternals.actQueue !== null ? workLoopSync() : workLoopConcurrentByScheduler();
            break;
          } catch (thrownValue$9) {
            handleThrow(root2, thrownValue$9);
          }
        while (1);
      resetContextDependencies();
      ReactSharedInternals.H = prevDispatcher;
      ReactSharedInternals.A = prevAsyncDispatcher;
      executionContext = prevExecutionContext;
      if (workInProgress !== null)
        return RootInProgress;
      workInProgressRoot = null;
      workInProgressRootRenderLanes = 0;
      finishQueueingConcurrentUpdates();
      return workInProgressRootExitStatus;
    }
    function workLoopConcurrentByScheduler() {
      for (;workInProgress !== null && !shouldYield(); )
        performUnitOfWork(workInProgress);
    }
    function performUnitOfWork(unitOfWork) {
      var current2 = unitOfWork.alternate;
      (unitOfWork.mode & ProfileMode) !== NoMode ? (startProfilerTimer(unitOfWork), current2 = runWithFiberInDEV(unitOfWork, beginWork, current2, unitOfWork, entangledRenderLanes), stopProfilerTimerIfRunningAndRecordDuration(unitOfWork)) : current2 = runWithFiberInDEV(unitOfWork, beginWork, current2, unitOfWork, entangledRenderLanes);
      unitOfWork.memoizedProps = unitOfWork.pendingProps;
      current2 === null ? completeUnitOfWork(unitOfWork) : workInProgress = current2;
    }
    function replaySuspendedUnitOfWork(unitOfWork) {
      var next = runWithFiberInDEV(unitOfWork, replayBeginWork, unitOfWork);
      unitOfWork.memoizedProps = unitOfWork.pendingProps;
      next === null ? completeUnitOfWork(unitOfWork) : workInProgress = next;
    }
    function replayBeginWork(unitOfWork) {
      var current2 = unitOfWork.alternate, isProfilingMode = (unitOfWork.mode & ProfileMode) !== NoMode;
      isProfilingMode && startProfilerTimer(unitOfWork);
      switch (unitOfWork.tag) {
        case 15:
        case 0:
          current2 = replayFunctionComponent(current2, unitOfWork, unitOfWork.pendingProps, unitOfWork.type, undefined, workInProgressRootRenderLanes);
          break;
        case 11:
          current2 = replayFunctionComponent(current2, unitOfWork, unitOfWork.pendingProps, unitOfWork.type.render, unitOfWork.ref, workInProgressRootRenderLanes);
          break;
        case 5:
          resetHooksOnUnwind(unitOfWork);
        default:
          unwindInterruptedWork(current2, unitOfWork), unitOfWork = workInProgress = resetWorkInProgress(unitOfWork, entangledRenderLanes), current2 = beginWork(current2, unitOfWork, entangledRenderLanes);
      }
      isProfilingMode && stopProfilerTimerIfRunningAndRecordDuration(unitOfWork);
      return current2;
    }
    function throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, suspendedReason) {
      resetContextDependencies();
      resetHooksOnUnwind(unitOfWork);
      thenableState$1 = null;
      thenableIndexCounter$1 = 0;
      var returnFiber = unitOfWork.return;
      try {
        if (throwException(root2, returnFiber, unitOfWork, thrownValue, workInProgressRootRenderLanes)) {
          workInProgressRootExitStatus = RootFatalErrored;
          logUncaughtError(root2, createCapturedValueAtFiber(thrownValue, root2.current));
          workInProgress = null;
          return;
        }
      } catch (error) {
        if (returnFiber !== null)
          throw workInProgress = returnFiber, error;
        workInProgressRootExitStatus = RootFatalErrored;
        logUncaughtError(root2, createCapturedValueAtFiber(thrownValue, root2.current));
        workInProgress = null;
        return;
      }
      if (unitOfWork.flags & 32768) {
        if (isHydrating || suspendedReason === SuspendedOnError)
          root2 = true;
        else if (workInProgressRootIsPrerendering || (workInProgressRootRenderLanes & 536870912) !== 0)
          root2 = false;
        else if (workInProgressRootDidSkipSuspendedSiblings = root2 = true, suspendedReason === SuspendedOnData || suspendedReason === SuspendedOnAction || suspendedReason === SuspendedOnImmediate || suspendedReason === SuspendedOnDeprecatedThrowPromise)
          suspendedReason = suspenseHandlerStackCursor.current, suspendedReason !== null && suspendedReason.tag === 13 && (suspendedReason.flags |= 16384);
        unwindUnitOfWork(unitOfWork, root2);
      } else
        completeUnitOfWork(unitOfWork);
    }
    function completeUnitOfWork(unitOfWork) {
      var completedWork = unitOfWork;
      do {
        if ((completedWork.flags & 32768) !== 0) {
          unwindUnitOfWork(completedWork, workInProgressRootDidSkipSuspendedSiblings);
          return;
        }
        var current2 = completedWork.alternate;
        unitOfWork = completedWork.return;
        startProfilerTimer(completedWork);
        current2 = runWithFiberInDEV(completedWork, completeWork, current2, completedWork, entangledRenderLanes);
        (completedWork.mode & ProfileMode) !== NoMode && stopProfilerTimerIfRunningAndRecordIncompleteDuration(completedWork);
        if (current2 !== null) {
          workInProgress = current2;
          return;
        }
        completedWork = completedWork.sibling;
        if (completedWork !== null) {
          workInProgress = completedWork;
          return;
        }
        workInProgress = completedWork = unitOfWork;
      } while (completedWork !== null);
      workInProgressRootExitStatus === RootInProgress && (workInProgressRootExitStatus = RootCompleted);
    }
    function unwindUnitOfWork(unitOfWork, skipSiblings) {
      do {
        var next = unwindWork(unitOfWork.alternate, unitOfWork);
        if (next !== null) {
          next.flags &= 32767;
          workInProgress = next;
          return;
        }
        if ((unitOfWork.mode & ProfileMode) !== NoMode) {
          stopProfilerTimerIfRunningAndRecordIncompleteDuration(unitOfWork);
          next = unitOfWork.actualDuration;
          for (var child = unitOfWork.child;child !== null; )
            next += child.actualDuration, child = child.sibling;
          unitOfWork.actualDuration = next;
        }
        next = unitOfWork.return;
        next !== null && (next.flags |= 32768, next.subtreeFlags = 0, next.deletions = null);
        if (!skipSiblings && (unitOfWork = unitOfWork.sibling, unitOfWork !== null)) {
          workInProgress = unitOfWork;
          return;
        }
        workInProgress = unitOfWork = next;
      } while (unitOfWork !== null);
      workInProgressRootExitStatus = RootSuspendedAtTheShell;
      workInProgress = null;
    }
    function commitRoot(root2, finishedWork, lanes, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes, exitStatus, suspendedState, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {
      root2.cancelPendingCommit = null;
      do
        flushPendingEffects();
      while (pendingEffectsStatus !== NO_PENDING_EFFECTS);
      ReactStrictModeWarnings.flushLegacyContextWarning();
      ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();
      if ((executionContext & (RenderContext | CommitContext)) !== NoContext)
        throw Error("Should not already be working.");
      setCurrentTrackFromLanes(lanes);
      exitStatus === RootErrored ? logErroredRenderPhase(completedRenderStartTime, completedRenderEndTime, lanes, workInProgressUpdateTask) : recoverableErrors !== null ? logRecoveredRenderPhase(completedRenderStartTime, completedRenderEndTime, lanes, recoverableErrors, finishedWork !== null && finishedWork.alternate !== null && finishedWork.alternate.memoizedState.isDehydrated && (finishedWork.flags & 256) !== 0, workInProgressUpdateTask) : logRenderPhase(completedRenderStartTime, completedRenderEndTime, lanes, workInProgressUpdateTask);
      if (finishedWork !== null) {
        lanes === 0 && console.error("finishedLanes should not be empty during a commit. This is a bug in React.");
        if (finishedWork === root2.current)
          throw Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
        didIncludeRenderPhaseUpdate = finishedWork.lanes | finishedWork.childLanes;
        didIncludeRenderPhaseUpdate |= concurrentlyUpdatedLanes;
        markRootFinished(root2, lanes, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes);
        root2 === workInProgressRoot && (workInProgress = workInProgressRoot = null, workInProgressRootRenderLanes = 0);
        pendingFinishedWork = finishedWork;
        pendingEffectsRoot = root2;
        pendingEffectsLanes = lanes;
        pendingEffectsRemainingLanes = didIncludeRenderPhaseUpdate;
        pendingPassiveTransitions = transitions;
        pendingRecoverableErrors = recoverableErrors;
        pendingEffectsRenderEndTime = completedRenderEndTime;
        pendingSuspendedCommitReason = suspendedCommitReason;
        pendingDelayedCommitReason = IMMEDIATE_COMMIT;
        pendingSuspendedViewTransitionReason = null;
        finishedWork.actualDuration !== 0 || (finishedWork.subtreeFlags & 10256) !== 0 || (finishedWork.flags & 10256) !== 0 ? (root2.callbackNode = null, root2.callbackPriority = 0, scheduleCallback$1(NormalPriority$1, function() {
          schedulerEvent = window.event;
          pendingDelayedCommitReason === IMMEDIATE_COMMIT && (pendingDelayedCommitReason = DELAYED_PASSIVE_COMMIT);
          flushPassiveEffects();
          return null;
        })) : (root2.callbackNode = null, root2.callbackPriority = 0);
        commitErrors = null;
        commitStartTime = now();
        suspendedCommitReason !== null && logSuspendedCommitPhase(completedRenderEndTime, commitStartTime, suspendedCommitReason, workInProgressUpdateTask);
        recoverableErrors = (finishedWork.flags & 13878) !== 0;
        if ((finishedWork.subtreeFlags & 13878) !== 0 || recoverableErrors) {
          recoverableErrors = ReactSharedInternals.T;
          ReactSharedInternals.T = null;
          transitions = ReactDOMSharedInternals.p;
          ReactDOMSharedInternals.p = DiscreteEventPriority;
          spawnedLane = executionContext;
          executionContext |= CommitContext;
          try {
            commitBeforeMutationEffects(root2, finishedWork, lanes);
          } finally {
            executionContext = spawnedLane, ReactDOMSharedInternals.p = transitions, ReactSharedInternals.T = recoverableErrors;
          }
        }
        pendingEffectsStatus = PENDING_MUTATION_PHASE;
        flushMutationEffects();
        flushLayoutEffects();
        flushSpawnedWork();
      }
    }
    function flushMutationEffects() {
      if (pendingEffectsStatus === PENDING_MUTATION_PHASE) {
        pendingEffectsStatus = NO_PENDING_EFFECTS;
        var root2 = pendingEffectsRoot, finishedWork = pendingFinishedWork, lanes = pendingEffectsLanes, rootMutationHasEffect = (finishedWork.flags & 13878) !== 0;
        if ((finishedWork.subtreeFlags & 13878) !== 0 || rootMutationHasEffect) {
          rootMutationHasEffect = ReactSharedInternals.T;
          ReactSharedInternals.T = null;
          var previousPriority = ReactDOMSharedInternals.p;
          ReactDOMSharedInternals.p = DiscreteEventPriority;
          var prevExecutionContext = executionContext;
          executionContext |= CommitContext;
          try {
            inProgressLanes = lanes;
            inProgressRoot = root2;
            resetComponentEffectTimers();
            commitMutationEffectsOnFiber(finishedWork, root2);
            inProgressRoot = inProgressLanes = null;
            lanes = selectionInformation;
            var curFocusedElem = getActiveElementDeep(root2.containerInfo), priorFocusedElem = lanes.focusedElem, priorSelectionRange = lanes.selectionRange;
            if (curFocusedElem !== priorFocusedElem && priorFocusedElem && priorFocusedElem.ownerDocument && containsNode(priorFocusedElem.ownerDocument.documentElement, priorFocusedElem)) {
              if (priorSelectionRange !== null && hasSelectionCapabilities(priorFocusedElem)) {
                var { start, end } = priorSelectionRange;
                end === undefined && (end = start);
                if ("selectionStart" in priorFocusedElem)
                  priorFocusedElem.selectionStart = start, priorFocusedElem.selectionEnd = Math.min(end, priorFocusedElem.value.length);
                else {
                  var doc = priorFocusedElem.ownerDocument || document, win = doc && doc.defaultView || window;
                  if (win.getSelection) {
                    var selection = win.getSelection(), length = priorFocusedElem.textContent.length, start$jscomp$0 = Math.min(priorSelectionRange.start, length), end$jscomp$0 = priorSelectionRange.end === undefined ? start$jscomp$0 : Math.min(priorSelectionRange.end, length);
                    !selection.extend && start$jscomp$0 > end$jscomp$0 && (curFocusedElem = end$jscomp$0, end$jscomp$0 = start$jscomp$0, start$jscomp$0 = curFocusedElem);
                    var startMarker = getNodeForCharacterOffset(priorFocusedElem, start$jscomp$0), endMarker = getNodeForCharacterOffset(priorFocusedElem, end$jscomp$0);
                    if (startMarker && endMarker && (selection.rangeCount !== 1 || selection.anchorNode !== startMarker.node || selection.anchorOffset !== startMarker.offset || selection.focusNode !== endMarker.node || selection.focusOffset !== endMarker.offset)) {
                      var range = doc.createRange();
                      range.setStart(startMarker.node, startMarker.offset);
                      selection.removeAllRanges();
                      start$jscomp$0 > end$jscomp$0 ? (selection.addRange(range), selection.extend(endMarker.node, endMarker.offset)) : (range.setEnd(endMarker.node, endMarker.offset), selection.addRange(range));
                    }
                  }
                }
              }
              doc = [];
              for (selection = priorFocusedElem;selection = selection.parentNode; )
                selection.nodeType === 1 && doc.push({
                  element: selection,
                  left: selection.scrollLeft,
                  top: selection.scrollTop
                });
              typeof priorFocusedElem.focus === "function" && priorFocusedElem.focus();
              for (priorFocusedElem = 0;priorFocusedElem < doc.length; priorFocusedElem++) {
                var info = doc[priorFocusedElem];
                info.element.scrollLeft = info.left;
                info.element.scrollTop = info.top;
              }
            }
            _enabled = !!eventsEnabled;
            selectionInformation = eventsEnabled = null;
          } finally {
            executionContext = prevExecutionContext, ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = rootMutationHasEffect;
          }
        }
        root2.current = finishedWork;
        pendingEffectsStatus = PENDING_LAYOUT_PHASE;
      }
    }
    function flushLayoutEffects() {
      if (pendingEffectsStatus === PENDING_LAYOUT_PHASE) {
        pendingEffectsStatus = NO_PENDING_EFFECTS;
        var suspendedViewTransitionReason = pendingSuspendedViewTransitionReason;
        if (suspendedViewTransitionReason !== null) {
          commitStartTime = now();
          var startTime = commitEndTime, endTime = commitStartTime;
          !supportsUserTiming || endTime <= startTime || (animatingTask ? animatingTask.run(console.timeStamp.bind(console, suspendedViewTransitionReason, startTime, endTime, currentTrack, LANES_TRACK_GROUP, "secondary-light")) : console.timeStamp(suspendedViewTransitionReason, startTime, endTime, currentTrack, LANES_TRACK_GROUP, "secondary-light"));
        }
        suspendedViewTransitionReason = pendingEffectsRoot;
        startTime = pendingFinishedWork;
        endTime = pendingEffectsLanes;
        var rootHasLayoutEffect = (startTime.flags & 8772) !== 0;
        if ((startTime.subtreeFlags & 8772) !== 0 || rootHasLayoutEffect) {
          rootHasLayoutEffect = ReactSharedInternals.T;
          ReactSharedInternals.T = null;
          var _previousPriority = ReactDOMSharedInternals.p;
          ReactDOMSharedInternals.p = DiscreteEventPriority;
          var _prevExecutionContext = executionContext;
          executionContext |= CommitContext;
          try {
            inProgressLanes = endTime, inProgressRoot = suspendedViewTransitionReason, resetComponentEffectTimers(), commitLayoutEffectOnFiber(suspendedViewTransitionReason, startTime.alternate, startTime), inProgressRoot = inProgressLanes = null;
          } finally {
            executionContext = _prevExecutionContext, ReactDOMSharedInternals.p = _previousPriority, ReactSharedInternals.T = rootHasLayoutEffect;
          }
        }
        suspendedViewTransitionReason = pendingEffectsRenderEndTime;
        startTime = pendingSuspendedCommitReason;
        commitEndTime = now();
        suspendedViewTransitionReason = startTime === null ? suspendedViewTransitionReason : commitStartTime;
        startTime = commitEndTime;
        endTime = pendingDelayedCommitReason === ABORTED_VIEW_TRANSITION_COMMIT;
        rootHasLayoutEffect = workInProgressUpdateTask;
        commitErrors !== null ? logCommitErrored(suspendedViewTransitionReason, startTime, commitErrors, false, rootHasLayoutEffect) : !supportsUserTiming || startTime <= suspendedViewTransitionReason || (rootHasLayoutEffect ? rootHasLayoutEffect.run(console.timeStamp.bind(console, endTime ? "Commit Interrupted View Transition" : "Commit", suspendedViewTransitionReason, startTime, currentTrack, LANES_TRACK_GROUP, endTime ? "error" : "secondary-dark")) : console.timeStamp(endTime ? "Commit Interrupted View Transition" : "Commit", suspendedViewTransitionReason, startTime, currentTrack, LANES_TRACK_GROUP, endTime ? "error" : "secondary-dark"));
        pendingEffectsStatus = PENDING_AFTER_MUTATION_PHASE;
      }
    }
    function flushSpawnedWork() {
      if (pendingEffectsStatus === PENDING_SPAWNED_WORK || pendingEffectsStatus === PENDING_AFTER_MUTATION_PHASE) {
        if (pendingEffectsStatus === PENDING_SPAWNED_WORK) {
          var startViewTransitionStartTime = commitEndTime;
          commitEndTime = now();
          var endTime = commitEndTime, abortedViewTransition = pendingDelayedCommitReason === ABORTED_VIEW_TRANSITION_COMMIT;
          !supportsUserTiming || endTime <= startViewTransitionStartTime || (animatingTask ? animatingTask.run(console.timeStamp.bind(console, abortedViewTransition ? "Interrupted View Transition" : "Starting Animation", startViewTransitionStartTime, endTime, currentTrack, LANES_TRACK_GROUP, abortedViewTransition ? "error" : "secondary-light")) : console.timeStamp(abortedViewTransition ? "Interrupted View Transition" : "Starting Animation", startViewTransitionStartTime, endTime, currentTrack, LANES_TRACK_GROUP, abortedViewTransition ? " error" : "secondary-light"));
          pendingDelayedCommitReason !== ABORTED_VIEW_TRANSITION_COMMIT && (pendingDelayedCommitReason = ANIMATION_STARTED_COMMIT);
        }
        pendingEffectsStatus = NO_PENDING_EFFECTS;
        requestPaint();
        startViewTransitionStartTime = pendingEffectsRoot;
        var finishedWork = pendingFinishedWork;
        endTime = pendingEffectsLanes;
        abortedViewTransition = pendingRecoverableErrors;
        var rootDidHavePassiveEffects = finishedWork.actualDuration !== 0 || (finishedWork.subtreeFlags & 10256) !== 0 || (finishedWork.flags & 10256) !== 0;
        rootDidHavePassiveEffects ? pendingEffectsStatus = PENDING_PASSIVE_PHASE : (pendingEffectsStatus = NO_PENDING_EFFECTS, pendingFinishedWork = pendingEffectsRoot = null, releaseRootPooledCache(startViewTransitionStartTime, startViewTransitionStartTime.pendingLanes), nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null);
        var remainingLanes = startViewTransitionStartTime.pendingLanes;
        remainingLanes === 0 && (legacyErrorBoundariesThatAlreadyFailed = null);
        rootDidHavePassiveEffects || commitDoubleInvokeEffectsInDEV(startViewTransitionStartTime);
        remainingLanes = lanesToEventPriority(endTime);
        finishedWork = finishedWork.stateNode;
        if (injectedHook && typeof injectedHook.onCommitFiberRoot === "function")
          try {
            var didError = (finishedWork.current.flags & 128) === 128;
            switch (remainingLanes) {
              case DiscreteEventPriority:
                var schedulerPriority = ImmediatePriority;
                break;
              case ContinuousEventPriority:
                schedulerPriority = UserBlockingPriority;
                break;
              case DefaultEventPriority:
                schedulerPriority = NormalPriority$1;
                break;
              case IdleEventPriority:
                schedulerPriority = IdlePriority;
                break;
              default:
                schedulerPriority = NormalPriority$1;
            }
            injectedHook.onCommitFiberRoot(rendererID, finishedWork, schedulerPriority, didError);
          } catch (err) {
            hasLoggedError || (hasLoggedError = true, console.error("React instrumentation encountered an error: %o", err));
          }
        isDevToolsPresent && startViewTransitionStartTime.memoizedUpdaters.clear();
        onCommitRoot();
        if (abortedViewTransition !== null) {
          didError = ReactSharedInternals.T;
          schedulerPriority = ReactDOMSharedInternals.p;
          ReactDOMSharedInternals.p = DiscreteEventPriority;
          ReactSharedInternals.T = null;
          try {
            var onRecoverableError = startViewTransitionStartTime.onRecoverableError;
            for (finishedWork = 0;finishedWork < abortedViewTransition.length; finishedWork++) {
              var recoverableError = abortedViewTransition[finishedWork], errorInfo = makeErrorInfo(recoverableError.stack);
              runWithFiberInDEV(recoverableError.source, onRecoverableError, recoverableError.value, errorInfo);
            }
          } finally {
            ReactSharedInternals.T = didError, ReactDOMSharedInternals.p = schedulerPriority;
          }
        }
        (pendingEffectsLanes & 3) !== 0 && flushPendingEffects();
        ensureRootIsScheduled(startViewTransitionStartTime);
        remainingLanes = startViewTransitionStartTime.pendingLanes;
        (endTime & 261930) !== 0 && (remainingLanes & 42) !== 0 ? (nestedUpdateScheduled = true, startViewTransitionStartTime === rootWithNestedUpdates ? nestedUpdateCount++ : (nestedUpdateCount = 0, rootWithNestedUpdates = startViewTransitionStartTime)) : nestedUpdateCount = 0;
        rootDidHavePassiveEffects || finalizeRender(endTime, commitEndTime);
        flushSyncWorkAcrossRoots_impl(0, false);
      }
    }
    function makeErrorInfo(componentStack) {
      componentStack = { componentStack };
      Object.defineProperty(componentStack, "digest", {
        get: function() {
          console.error('You are accessing "digest" from the errorInfo object passed to onRecoverableError. This property is no longer provided as part of errorInfo but can be accessed as a property of the Error instance itself.');
        }
      });
      return componentStack;
    }
    function releaseRootPooledCache(root2, remainingLanes) {
      (root2.pooledCacheLanes &= remainingLanes) === 0 && (remainingLanes = root2.pooledCache, remainingLanes != null && (root2.pooledCache = null, releaseCache(remainingLanes)));
    }
    function flushPendingEffects() {
      flushMutationEffects();
      flushLayoutEffects();
      flushSpawnedWork();
      return flushPassiveEffects();
    }
    function flushPassiveEffects() {
      if (pendingEffectsStatus !== PENDING_PASSIVE_PHASE)
        return false;
      var root2 = pendingEffectsRoot, remainingLanes = pendingEffectsRemainingLanes;
      pendingEffectsRemainingLanes = 0;
      var renderPriority = lanesToEventPriority(pendingEffectsLanes), priority = DefaultEventPriority === 0 || DefaultEventPriority > renderPriority ? DefaultEventPriority : renderPriority;
      renderPriority = ReactSharedInternals.T;
      var previousPriority = ReactDOMSharedInternals.p;
      try {
        ReactDOMSharedInternals.p = priority;
        ReactSharedInternals.T = null;
        var transitions = pendingPassiveTransitions;
        pendingPassiveTransitions = null;
        priority = pendingEffectsRoot;
        var lanes = pendingEffectsLanes;
        pendingEffectsStatus = NO_PENDING_EFFECTS;
        pendingFinishedWork = pendingEffectsRoot = null;
        pendingEffectsLanes = 0;
        if ((executionContext & (RenderContext | CommitContext)) !== NoContext)
          throw Error("Cannot flush passive effects while already rendering.");
        setCurrentTrackFromLanes(lanes);
        isFlushingPassiveEffects = true;
        didScheduleUpdateDuringPassiveEffects = false;
        var passiveEffectStartTime = 0;
        commitErrors = null;
        passiveEffectStartTime = now$1();
        if (pendingDelayedCommitReason === ANIMATION_STARTED_COMMIT)
          logAnimatingPhase(commitEndTime, passiveEffectStartTime, animatingTask);
        else {
          var startTime = commitEndTime, endTime = passiveEffectStartTime, delayedUntilPaint = pendingDelayedCommitReason === DELAYED_PASSIVE_COMMIT;
          !supportsUserTiming || endTime <= startTime || (workInProgressUpdateTask ? workInProgressUpdateTask.run(console.timeStamp.bind(console, delayedUntilPaint ? "Waiting for Paint" : "Waiting", startTime, endTime, currentTrack, LANES_TRACK_GROUP, "secondary-light")) : console.timeStamp(delayedUntilPaint ? "Waiting for Paint" : "Waiting", startTime, endTime, currentTrack, LANES_TRACK_GROUP, "secondary-light"));
        }
        startTime = executionContext;
        executionContext |= CommitContext;
        var finishedWork = priority.current;
        resetComponentEffectTimers();
        commitPassiveUnmountOnFiber(finishedWork);
        var finishedWork$jscomp$0 = priority.current;
        finishedWork = pendingEffectsRenderEndTime;
        resetComponentEffectTimers();
        commitPassiveMountOnFiber(priority, finishedWork$jscomp$0, lanes, transitions, finishedWork);
        commitDoubleInvokeEffectsInDEV(priority);
        executionContext = startTime;
        var passiveEffectsEndTime = now$1();
        finishedWork$jscomp$0 = passiveEffectStartTime;
        finishedWork = workInProgressUpdateTask;
        commitErrors !== null ? logCommitErrored(finishedWork$jscomp$0, passiveEffectsEndTime, commitErrors, true, finishedWork) : !supportsUserTiming || passiveEffectsEndTime <= finishedWork$jscomp$0 || (finishedWork ? finishedWork.run(console.timeStamp.bind(console, "Remaining Effects", finishedWork$jscomp$0, passiveEffectsEndTime, currentTrack, LANES_TRACK_GROUP, "secondary-dark")) : console.timeStamp("Remaining Effects", finishedWork$jscomp$0, passiveEffectsEndTime, currentTrack, LANES_TRACK_GROUP, "secondary-dark"));
        finalizeRender(lanes, passiveEffectsEndTime);
        flushSyncWorkAcrossRoots_impl(0, false);
        didScheduleUpdateDuringPassiveEffects ? priority === rootWithPassiveNestedUpdates ? nestedPassiveUpdateCount++ : (nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = priority) : nestedPassiveUpdateCount = 0;
        didScheduleUpdateDuringPassiveEffects = isFlushingPassiveEffects = false;
        if (injectedHook && typeof injectedHook.onPostCommitFiberRoot === "function")
          try {
            injectedHook.onPostCommitFiberRoot(rendererID, priority);
          } catch (err) {
            hasLoggedError || (hasLoggedError = true, console.error("React instrumentation encountered an error: %o", err));
          }
        var stateNode = priority.current.stateNode;
        stateNode.effectDuration = 0;
        stateNode.passiveEffectDuration = 0;
        return true;
      } finally {
        ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = renderPriority, releaseRootPooledCache(root2, remainingLanes);
      }
    }
    function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
      sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
      recordEffectError(sourceFiber);
      sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2);
      rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);
      rootFiber !== null && (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));
    }
    function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {
      isRunningInsertionEffect = false;
      if (sourceFiber.tag === 3)
        captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);
      else {
        for (;nearestMountedAncestor !== null; ) {
          if (nearestMountedAncestor.tag === 3) {
            captureCommitPhaseErrorOnRoot(nearestMountedAncestor, sourceFiber, error);
            return;
          }
          if (nearestMountedAncestor.tag === 1) {
            var instance = nearestMountedAncestor.stateNode;
            if (typeof nearestMountedAncestor.type.getDerivedStateFromError === "function" || typeof instance.componentDidCatch === "function" && (legacyErrorBoundariesThatAlreadyFailed === null || !legacyErrorBoundariesThatAlreadyFailed.has(instance))) {
              sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
              recordEffectError(sourceFiber);
              error = createClassErrorUpdate(2);
              instance = enqueueUpdate(nearestMountedAncestor, error, 2);
              instance !== null && (initializeClassErrorUpdate(error, instance, nearestMountedAncestor, sourceFiber), markRootUpdated$1(instance, 2), ensureRootIsScheduled(instance));
              return;
            }
          }
          nearestMountedAncestor = nearestMountedAncestor.return;
        }
        console.error(`Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Potential causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.

Error message:

%s`, error);
      }
    }
    function attachPingListener(root2, wakeable, lanes) {
      var pingCache = root2.pingCache;
      if (pingCache === null) {
        pingCache = root2.pingCache = new PossiblyWeakMap;
        var threadIDs = new Set;
        pingCache.set(wakeable, threadIDs);
      } else
        threadIDs = pingCache.get(wakeable), threadIDs === undefined && (threadIDs = new Set, pingCache.set(wakeable, threadIDs));
      threadIDs.has(lanes) || (workInProgressRootDidAttachPingListener = true, threadIDs.add(lanes), pingCache = pingSuspendedRoot.bind(null, root2, wakeable, lanes), isDevToolsPresent && restorePendingUpdaters(root2, lanes), wakeable.then(pingCache, pingCache));
    }
    function pingSuspendedRoot(root2, wakeable, pingedLanes) {
      var pingCache = root2.pingCache;
      pingCache !== null && pingCache.delete(wakeable);
      root2.pingedLanes |= root2.suspendedLanes & pingedLanes;
      root2.warmLanes &= ~pingedLanes;
      (pingedLanes & 127) !== 0 ? 0 > blockingUpdateTime && (blockingClampTime = blockingUpdateTime = now(), blockingUpdateTask = createTask("Promise Resolved"), blockingUpdateType = PINGED_UPDATE) : (pingedLanes & 4194048) !== 0 && 0 > transitionUpdateTime && (transitionClampTime = transitionUpdateTime = now(), transitionUpdateTask = createTask("Promise Resolved"), transitionUpdateType = PINGED_UPDATE);
      isConcurrentActEnvironment() && ReactSharedInternals.actQueue === null && console.error(`A suspended resource finished loading inside a test, but the event was not wrapped in act(...).

When testing, code that resolves suspended data should be wrapped into act(...):

act(() => {
  /* finish loading suspended data */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act`);
      workInProgressRoot === root2 && (workInProgressRootRenderLanes & pingedLanes) === pingedLanes && (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes && now$1() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS ? (executionContext & RenderContext) === NoContext && prepareFreshStack(root2, 0) : workInProgressRootPingedLanes |= pingedLanes, workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes && (workInProgressSuspendedRetryLanes = 0));
      ensureRootIsScheduled(root2);
    }
    function retryTimedOutBoundary(boundaryFiber, retryLane) {
      retryLane === 0 && (retryLane = claimNextRetryLane());
      boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
      boundaryFiber !== null && (markRootUpdated$1(boundaryFiber, retryLane), ensureRootIsScheduled(boundaryFiber));
    }
    function retryDehydratedSuspenseBoundary(boundaryFiber) {
      var suspenseState = boundaryFiber.memoizedState, retryLane = 0;
      suspenseState !== null && (retryLane = suspenseState.retryLane);
      retryTimedOutBoundary(boundaryFiber, retryLane);
    }
    function resolveRetryWakeable(boundaryFiber, wakeable) {
      var retryLane = 0;
      switch (boundaryFiber.tag) {
        case 31:
        case 13:
          var retryCache = boundaryFiber.stateNode;
          var suspenseState = boundaryFiber.memoizedState;
          suspenseState !== null && (retryLane = suspenseState.retryLane);
          break;
        case 19:
          retryCache = boundaryFiber.stateNode;
          break;
        case 22:
          retryCache = boundaryFiber.stateNode._retryCache;
          break;
        default:
          throw Error("Pinged unknown suspense boundary type. This is probably a bug in React.");
      }
      retryCache !== null && retryCache.delete(wakeable);
      retryTimedOutBoundary(boundaryFiber, retryLane);
    }
    function recursivelyTraverseAndDoubleInvokeEffectsInDEV(root$jscomp$0, parentFiber, isInStrictMode) {
      if ((parentFiber.subtreeFlags & 67117056) !== 0)
        for (parentFiber = parentFiber.child;parentFiber !== null; ) {
          var root2 = root$jscomp$0, fiber = parentFiber, isStrictModeFiber = fiber.type === REACT_STRICT_MODE_TYPE;
          isStrictModeFiber = isInStrictMode || isStrictModeFiber;
          fiber.tag !== 22 ? fiber.flags & 67108864 ? isStrictModeFiber && runWithFiberInDEV(fiber, doubleInvokeEffectsOnFiber, root2, fiber) : recursivelyTraverseAndDoubleInvokeEffectsInDEV(root2, fiber, isStrictModeFiber) : fiber.memoizedState === null && (isStrictModeFiber && fiber.flags & 8192 ? runWithFiberInDEV(fiber, doubleInvokeEffectsOnFiber, root2, fiber) : fiber.subtreeFlags & 67108864 && runWithFiberInDEV(fiber, recursivelyTraverseAndDoubleInvokeEffectsInDEV, root2, fiber, isStrictModeFiber));
          parentFiber = parentFiber.sibling;
        }
    }
    function doubleInvokeEffectsOnFiber(root2, fiber) {
      setIsStrictModeForDevtools(true);
      try {
        disappearLayoutEffects(fiber), disconnectPassiveEffect(fiber), reappearLayoutEffects(root2, fiber.alternate, fiber, false), reconnectPassiveEffects(root2, fiber, 0, null, false, 0);
      } finally {
        setIsStrictModeForDevtools(false);
      }
    }
    function commitDoubleInvokeEffectsInDEV(root2) {
      var doubleInvokeEffects = true;
      root2.current.mode & (StrictLegacyMode | StrictEffectsMode) || (doubleInvokeEffects = false);
      recursivelyTraverseAndDoubleInvokeEffectsInDEV(root2, root2.current, doubleInvokeEffects);
    }
    function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {
      if ((executionContext & RenderContext) === NoContext) {
        var tag = fiber.tag;
        if (tag === 3 || tag === 1 || tag === 0 || tag === 11 || tag === 14 || tag === 15) {
          tag = getComponentNameFromFiber(fiber) || "ReactComponent";
          if (didWarnStateUpdateForNotYetMountedComponent !== null) {
            if (didWarnStateUpdateForNotYetMountedComponent.has(tag))
              return;
            didWarnStateUpdateForNotYetMountedComponent.add(tag);
          } else
            didWarnStateUpdateForNotYetMountedComponent = new Set([tag]);
          runWithFiberInDEV(fiber, function() {
            console.error("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously tries to update the component. Move this work to useEffect instead.");
          });
        }
      }
    }
    function restorePendingUpdaters(root2, lanes) {
      isDevToolsPresent && root2.memoizedUpdaters.forEach(function(schedulingFiber) {
        addFiberToLanesMap(root2, schedulingFiber, lanes);
      });
    }
    function scheduleCallback$1(priorityLevel, callback) {
      var actQueue = ReactSharedInternals.actQueue;
      return actQueue !== null ? (actQueue.push(callback), fakeActCallbackNode$1) : scheduleCallback$3(priorityLevel, callback);
    }
    function warnIfUpdatesNotWrappedWithActDEV(fiber) {
      isConcurrentActEnvironment() && ReactSharedInternals.actQueue === null && runWithFiberInDEV(fiber, function() {
        console.error(`An update to %s inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act`, getComponentNameFromFiber(fiber));
      });
    }
    function ensureRootIsScheduled(root2) {
      root2 !== lastScheduledRoot && root2.next === null && (lastScheduledRoot === null ? firstScheduledRoot = lastScheduledRoot = root2 : lastScheduledRoot = lastScheduledRoot.next = root2);
      mightHavePendingSyncWork = true;
      ReactSharedInternals.actQueue !== null ? didScheduleMicrotask_act || (didScheduleMicrotask_act = true, scheduleImmediateRootScheduleTask()) : didScheduleMicrotask || (didScheduleMicrotask = true, scheduleImmediateRootScheduleTask());
    }
    function flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {
      if (!isFlushingWork && mightHavePendingSyncWork) {
        isFlushingWork = true;
        do {
          var didPerformSomeWork = false;
          for (var root2 = firstScheduledRoot;root2 !== null; ) {
            if (!onlyLegacy)
              if (syncTransitionLanes !== 0) {
                var pendingLanes = root2.pendingLanes;
                if (pendingLanes === 0)
                  var nextLanes = 0;
                else {
                  var { suspendedLanes, pingedLanes } = root2;
                  nextLanes = (1 << 31 - clz32(42 | syncTransitionLanes) + 1) - 1;
                  nextLanes &= pendingLanes & ~(suspendedLanes & ~pingedLanes);
                  nextLanes = nextLanes & 201326741 ? nextLanes & 201326741 | 1 : nextLanes ? nextLanes | 2 : 0;
                }
                nextLanes !== 0 && (didPerformSomeWork = true, performSyncWorkOnRoot(root2, nextLanes));
              } else
                nextLanes = workInProgressRootRenderLanes, nextLanes = getNextLanes(root2, root2 === workInProgressRoot ? nextLanes : 0, root2.cancelPendingCommit !== null || root2.timeoutHandle !== noTimeout), (nextLanes & 3) === 0 || checkIfRootIsPrerendering(root2, nextLanes) || (didPerformSomeWork = true, performSyncWorkOnRoot(root2, nextLanes));
            root2 = root2.next;
          }
        } while (didPerformSomeWork);
        isFlushingWork = false;
      }
    }
    function processRootScheduleInImmediateTask() {
      schedulerEvent = window.event;
      processRootScheduleInMicrotask();
    }
    function processRootScheduleInMicrotask() {
      mightHavePendingSyncWork = didScheduleMicrotask_act = didScheduleMicrotask = false;
      var syncTransitionLanes = 0;
      currentEventTransitionLane !== 0 && shouldAttemptEagerTransition() && (syncTransitionLanes = currentEventTransitionLane);
      for (var currentTime = now$1(), prev = null, root2 = firstScheduledRoot;root2 !== null; ) {
        var next = root2.next, nextLanes = scheduleTaskForRootDuringMicrotask(root2, currentTime);
        if (nextLanes === 0)
          root2.next = null, prev === null ? firstScheduledRoot = next : prev.next = next, next === null && (lastScheduledRoot = prev);
        else if (prev = root2, syncTransitionLanes !== 0 || (nextLanes & 3) !== 0)
          mightHavePendingSyncWork = true;
        root2 = next;
      }
      pendingEffectsStatus !== NO_PENDING_EFFECTS && pendingEffectsStatus !== PENDING_PASSIVE_PHASE || flushSyncWorkAcrossRoots_impl(syncTransitionLanes, false);
      currentEventTransitionLane !== 0 && (currentEventTransitionLane = 0);
    }
    function scheduleTaskForRootDuringMicrotask(root2, currentTime) {
      for (var { suspendedLanes, pingedLanes, expirationTimes } = root2, lanes = root2.pendingLanes & -62914561;0 < lanes; ) {
        var index = 31 - clz32(lanes), lane = 1 << index, expirationTime = expirationTimes[index];
        if (expirationTime === -1) {
          if ((lane & suspendedLanes) === 0 || (lane & pingedLanes) !== 0)
            expirationTimes[index] = computeExpirationTime(lane, currentTime);
        } else
          expirationTime <= currentTime && (root2.expiredLanes |= lane);
        lanes &= ~lane;
      }
      currentTime = workInProgressRoot;
      suspendedLanes = workInProgressRootRenderLanes;
      suspendedLanes = getNextLanes(root2, root2 === currentTime ? suspendedLanes : 0, root2.cancelPendingCommit !== null || root2.timeoutHandle !== noTimeout);
      pingedLanes = root2.callbackNode;
      if (suspendedLanes === 0 || root2 === currentTime && (workInProgressSuspendedReason === SuspendedOnData || workInProgressSuspendedReason === SuspendedOnAction) || root2.cancelPendingCommit !== null)
        return pingedLanes !== null && cancelCallback(pingedLanes), root2.callbackNode = null, root2.callbackPriority = 0;
      if ((suspendedLanes & 3) === 0 || checkIfRootIsPrerendering(root2, suspendedLanes)) {
        currentTime = suspendedLanes & -suspendedLanes;
        if (currentTime !== root2.callbackPriority || ReactSharedInternals.actQueue !== null && pingedLanes !== fakeActCallbackNode)
          cancelCallback(pingedLanes);
        else
          return currentTime;
        switch (lanesToEventPriority(suspendedLanes)) {
          case DiscreteEventPriority:
          case ContinuousEventPriority:
            suspendedLanes = UserBlockingPriority;
            break;
          case DefaultEventPriority:
            suspendedLanes = NormalPriority$1;
            break;
          case IdleEventPriority:
            suspendedLanes = IdlePriority;
            break;
          default:
            suspendedLanes = NormalPriority$1;
        }
        pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root2);
        ReactSharedInternals.actQueue !== null ? (ReactSharedInternals.actQueue.push(pingedLanes), suspendedLanes = fakeActCallbackNode) : suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes);
        root2.callbackPriority = currentTime;
        root2.callbackNode = suspendedLanes;
        return currentTime;
      }
      pingedLanes !== null && cancelCallback(pingedLanes);
      root2.callbackPriority = 2;
      root2.callbackNode = null;
      return 2;
    }
    function performWorkOnRootViaSchedulerTask(root2, didTimeout) {
      nestedUpdateScheduled = currentUpdateIsNested = false;
      schedulerEvent = window.event;
      if (pendingEffectsStatus !== NO_PENDING_EFFECTS && pendingEffectsStatus !== PENDING_PASSIVE_PHASE)
        return root2.callbackNode = null, root2.callbackPriority = 0, null;
      var originalCallbackNode = root2.callbackNode;
      pendingDelayedCommitReason === IMMEDIATE_COMMIT && (pendingDelayedCommitReason = DELAYED_PASSIVE_COMMIT);
      if (flushPendingEffects() && root2.callbackNode !== originalCallbackNode)
        return null;
      var workInProgressRootRenderLanes$jscomp$0 = workInProgressRootRenderLanes;
      workInProgressRootRenderLanes$jscomp$0 = getNextLanes(root2, root2 === workInProgressRoot ? workInProgressRootRenderLanes$jscomp$0 : 0, root2.cancelPendingCommit !== null || root2.timeoutHandle !== noTimeout);
      if (workInProgressRootRenderLanes$jscomp$0 === 0)
        return null;
      performWorkOnRoot(root2, workInProgressRootRenderLanes$jscomp$0, didTimeout);
      scheduleTaskForRootDuringMicrotask(root2, now$1());
      return root2.callbackNode != null && root2.callbackNode === originalCallbackNode ? performWorkOnRootViaSchedulerTask.bind(null, root2) : null;
    }
    function performSyncWorkOnRoot(root2, lanes) {
      if (flushPendingEffects())
        return null;
      currentUpdateIsNested = nestedUpdateScheduled;
      nestedUpdateScheduled = false;
      performWorkOnRoot(root2, lanes, true);
    }
    function cancelCallback(callbackNode) {
      callbackNode !== fakeActCallbackNode && callbackNode !== null && cancelCallback$1(callbackNode);
    }
    function scheduleImmediateRootScheduleTask() {
      ReactSharedInternals.actQueue !== null && ReactSharedInternals.actQueue.push(function() {
        processRootScheduleInMicrotask();
        return null;
      });
      scheduleMicrotask(function() {
        (executionContext & (RenderContext | CommitContext)) !== NoContext ? scheduleCallback$3(ImmediatePriority, processRootScheduleInImmediateTask) : processRootScheduleInMicrotask();
      });
    }
    function requestTransitionLane() {
      if (currentEventTransitionLane === 0) {
        var actionScopeLane = currentEntangledLane;
        actionScopeLane === 0 && (actionScopeLane = nextTransitionUpdateLane, nextTransitionUpdateLane <<= 1, (nextTransitionUpdateLane & 261888) === 0 && (nextTransitionUpdateLane = 256));
        currentEventTransitionLane = actionScopeLane;
      }
      return currentEventTransitionLane;
    }
    function coerceFormActionProp(actionProp) {
      if (actionProp == null || typeof actionProp === "symbol" || typeof actionProp === "boolean")
        return null;
      if (typeof actionProp === "function")
        return actionProp;
      checkAttributeStringCoercion(actionProp, "action");
      return sanitizeURL("" + actionProp);
    }
    function createFormDataWithSubmitter(form, submitter) {
      var temp = submitter.ownerDocument.createElement("input");
      temp.name = submitter.name;
      temp.value = submitter.value;
      form.id && temp.setAttribute("form", form.id);
      submitter.parentNode.insertBefore(temp, submitter);
      form = new FormData(form);
      temp.parentNode.removeChild(temp);
      return form;
    }
    function extractEvents$1(dispatchQueue, domEventName, maybeTargetInst, nativeEvent, nativeEventTarget) {
      if (domEventName === "submit" && maybeTargetInst && maybeTargetInst.stateNode === nativeEventTarget) {
        var action = coerceFormActionProp((nativeEventTarget[internalPropsKey] || null).action), submitter = nativeEvent.submitter;
        submitter && (domEventName = (domEventName = submitter[internalPropsKey] || null) ? coerceFormActionProp(domEventName.formAction) : submitter.getAttribute("formAction"), domEventName !== null && (action = domEventName, submitter = null));
        var event = new SyntheticEvent("action", "action", null, nativeEvent, nativeEventTarget);
        dispatchQueue.push({
          event,
          listeners: [
            {
              instance: null,
              listener: function() {
                if (nativeEvent.defaultPrevented) {
                  if (currentEventTransitionLane !== 0) {
                    var formData = submitter ? createFormDataWithSubmitter(nativeEventTarget, submitter) : new FormData(nativeEventTarget), pendingState = {
                      pending: true,
                      data: formData,
                      method: nativeEventTarget.method,
                      action
                    };
                    Object.freeze(pendingState);
                    startHostTransition(maybeTargetInst, pendingState, null, formData);
                  }
                } else
                  typeof action === "function" && (event.preventDefault(), formData = submitter ? createFormDataWithSubmitter(nativeEventTarget, submitter) : new FormData(nativeEventTarget), pendingState = {
                    pending: true,
                    data: formData,
                    method: nativeEventTarget.method,
                    action
                  }, Object.freeze(pendingState), startHostTransition(maybeTargetInst, pendingState, action, formData));
              },
              currentTarget: nativeEventTarget
            }
          ]
        });
      }
    }
    function executeDispatch(event, listener, currentTarget) {
      event.currentTarget = currentTarget;
      try {
        listener(event);
      } catch (error) {
        reportGlobalError(error);
      }
      event.currentTarget = null;
    }
    function processDispatchQueue(dispatchQueue, eventSystemFlags) {
      eventSystemFlags = (eventSystemFlags & 4) !== 0;
      for (var i = 0;i < dispatchQueue.length; i++) {
        var _dispatchQueue$i = dispatchQueue[i];
        a: {
          var previousInstance = undefined, event = _dispatchQueue$i.event;
          _dispatchQueue$i = _dispatchQueue$i.listeners;
          if (eventSystemFlags)
            for (var i$jscomp$0 = _dispatchQueue$i.length - 1;0 <= i$jscomp$0; i$jscomp$0--) {
              var _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0], instance = _dispatchListeners$i.instance, currentTarget = _dispatchListeners$i.currentTarget;
              _dispatchListeners$i = _dispatchListeners$i.listener;
              if (instance !== previousInstance && event.isPropagationStopped())
                break a;
              instance !== null ? runWithFiberInDEV(instance, executeDispatch, event, _dispatchListeners$i, currentTarget) : executeDispatch(event, _dispatchListeners$i, currentTarget);
              previousInstance = instance;
            }
          else
            for (i$jscomp$0 = 0;i$jscomp$0 < _dispatchQueue$i.length; i$jscomp$0++) {
              _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0];
              instance = _dispatchListeners$i.instance;
              currentTarget = _dispatchListeners$i.currentTarget;
              _dispatchListeners$i = _dispatchListeners$i.listener;
              if (instance !== previousInstance && event.isPropagationStopped())
                break a;
              instance !== null ? runWithFiberInDEV(instance, executeDispatch, event, _dispatchListeners$i, currentTarget) : executeDispatch(event, _dispatchListeners$i, currentTarget);
              previousInstance = instance;
            }
        }
      }
    }
    function listenToNonDelegatedEvent(domEventName, targetElement) {
      nonDelegatedEvents.has(domEventName) || console.error('Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.', domEventName);
      var listenerSet = targetElement[internalEventHandlersKey];
      listenerSet === undefined && (listenerSet = targetElement[internalEventHandlersKey] = new Set);
      var listenerSetKey = domEventName + "__bubble";
      listenerSet.has(listenerSetKey) || (addTrappedEventListener(targetElement, domEventName, 2, false), listenerSet.add(listenerSetKey));
    }
    function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
      nonDelegatedEvents.has(domEventName) && !isCapturePhaseListener && console.error('Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.', domEventName);
      var eventSystemFlags = 0;
      isCapturePhaseListener && (eventSystemFlags |= 4);
      addTrappedEventListener(target, domEventName, eventSystemFlags, isCapturePhaseListener);
    }
    function listenToAllSupportedEvents(rootContainerElement) {
      if (!rootContainerElement[listeningMarker]) {
        rootContainerElement[listeningMarker] = true;
        allNativeEvents.forEach(function(domEventName) {
          domEventName !== "selectionchange" && (nonDelegatedEvents.has(domEventName) || listenToNativeEvent(domEventName, false, rootContainerElement), listenToNativeEvent(domEventName, true, rootContainerElement));
        });
        var ownerDocument = rootContainerElement.nodeType === 9 ? rootContainerElement : rootContainerElement.ownerDocument;
        ownerDocument === null || ownerDocument[listeningMarker] || (ownerDocument[listeningMarker] = true, listenToNativeEvent("selectionchange", false, ownerDocument));
      }
    }
    function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener) {
      switch (getEventPriority(domEventName)) {
        case DiscreteEventPriority:
          var listenerWrapper = dispatchDiscreteEvent;
          break;
        case ContinuousEventPriority:
          listenerWrapper = dispatchContinuousEvent;
          break;
        default:
          listenerWrapper = dispatchEvent;
      }
      eventSystemFlags = listenerWrapper.bind(null, domEventName, eventSystemFlags, targetContainer);
      listenerWrapper = undefined;
      !passiveBrowserEventsSupported || domEventName !== "touchstart" && domEventName !== "touchmove" && domEventName !== "wheel" || (listenerWrapper = true);
      isCapturePhaseListener ? listenerWrapper !== undefined ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
        capture: true,
        passive: listenerWrapper
      }) : targetContainer.addEventListener(domEventName, eventSystemFlags, true) : listenerWrapper !== undefined ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
        passive: listenerWrapper
      }) : targetContainer.addEventListener(domEventName, eventSystemFlags, false);
    }
    function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst$jscomp$0, targetContainer) {
      var ancestorInst = targetInst$jscomp$0;
      if ((eventSystemFlags & 1) === 0 && (eventSystemFlags & 2) === 0 && targetInst$jscomp$0 !== null)
        a:
          for (;; ) {
            if (targetInst$jscomp$0 === null)
              return;
            var nodeTag = targetInst$jscomp$0.tag;
            if (nodeTag === 3 || nodeTag === 4) {
              var container = targetInst$jscomp$0.stateNode.containerInfo;
              if (container === targetContainer)
                break;
              if (nodeTag === 4)
                for (nodeTag = targetInst$jscomp$0.return;nodeTag !== null; ) {
                  var grandTag = nodeTag.tag;
                  if ((grandTag === 3 || grandTag === 4) && nodeTag.stateNode.containerInfo === targetContainer)
                    return;
                  nodeTag = nodeTag.return;
                }
              for (;container !== null; ) {
                nodeTag = getClosestInstanceFromNode(container);
                if (nodeTag === null)
                  return;
                grandTag = nodeTag.tag;
                if (grandTag === 5 || grandTag === 6 || grandTag === 26 || grandTag === 27) {
                  targetInst$jscomp$0 = ancestorInst = nodeTag;
                  continue a;
                }
                container = container.parentNode;
              }
            }
            targetInst$jscomp$0 = targetInst$jscomp$0.return;
          }
      batchedUpdates$1(function() {
        var targetInst = ancestorInst, nativeEventTarget = getEventTarget(nativeEvent), dispatchQueue = [];
        a: {
          var reactName = topLevelEventsToReactNames.get(domEventName);
          if (reactName !== undefined) {
            var SyntheticEventCtor = SyntheticEvent, reactEventType = domEventName;
            switch (domEventName) {
              case "keypress":
                if (getEventCharCode(nativeEvent) === 0)
                  break a;
              case "keydown":
              case "keyup":
                SyntheticEventCtor = SyntheticKeyboardEvent;
                break;
              case "focusin":
                reactEventType = "focus";
                SyntheticEventCtor = SyntheticFocusEvent;
                break;
              case "focusout":
                reactEventType = "blur";
                SyntheticEventCtor = SyntheticFocusEvent;
                break;
              case "beforeblur":
              case "afterblur":
                SyntheticEventCtor = SyntheticFocusEvent;
                break;
              case "click":
                if (nativeEvent.button === 2)
                  break a;
              case "auxclick":
              case "dblclick":
              case "mousedown":
              case "mousemove":
              case "mouseup":
              case "mouseout":
              case "mouseover":
              case "contextmenu":
                SyntheticEventCtor = SyntheticMouseEvent;
                break;
              case "drag":
              case "dragend":
              case "dragenter":
              case "dragexit":
              case "dragleave":
              case "dragover":
              case "dragstart":
              case "drop":
                SyntheticEventCtor = SyntheticDragEvent;
                break;
              case "touchcancel":
              case "touchend":
              case "touchmove":
              case "touchstart":
                SyntheticEventCtor = SyntheticTouchEvent;
                break;
              case ANIMATION_END:
              case ANIMATION_ITERATION:
              case ANIMATION_START:
                SyntheticEventCtor = SyntheticAnimationEvent;
                break;
              case TRANSITION_END:
                SyntheticEventCtor = SyntheticTransitionEvent;
                break;
              case "scroll":
              case "scrollend":
                SyntheticEventCtor = SyntheticUIEvent;
                break;
              case "wheel":
                SyntheticEventCtor = SyntheticWheelEvent;
                break;
              case "copy":
              case "cut":
              case "paste":
                SyntheticEventCtor = SyntheticClipboardEvent;
                break;
              case "gotpointercapture":
              case "lostpointercapture":
              case "pointercancel":
              case "pointerdown":
              case "pointermove":
              case "pointerout":
              case "pointerover":
              case "pointerup":
                SyntheticEventCtor = SyntheticPointerEvent;
                break;
              case "toggle":
              case "beforetoggle":
                SyntheticEventCtor = SyntheticToggleEvent;
            }
            var inCapturePhase = (eventSystemFlags & 4) !== 0, accumulateTargetOnly = !inCapturePhase && (domEventName === "scroll" || domEventName === "scrollend"), reactEventName = inCapturePhase ? reactName !== null ? reactName + "Capture" : null : reactName;
            inCapturePhase = [];
            for (var instance = targetInst, lastHostComponent;instance !== null; ) {
              var _instance2 = instance;
              lastHostComponent = _instance2.stateNode;
              _instance2 = _instance2.tag;
              _instance2 !== 5 && _instance2 !== 26 && _instance2 !== 27 || lastHostComponent === null || reactEventName === null || (_instance2 = getListener(instance, reactEventName), _instance2 != null && inCapturePhase.push(createDispatchListener(instance, _instance2, lastHostComponent)));
              if (accumulateTargetOnly)
                break;
              instance = instance.return;
            }
            0 < inCapturePhase.length && (reactName = new SyntheticEventCtor(reactName, reactEventType, null, nativeEvent, nativeEventTarget), dispatchQueue.push({
              event: reactName,
              listeners: inCapturePhase
            }));
          }
        }
        if ((eventSystemFlags & 7) === 0) {
          a: {
            reactName = domEventName === "mouseover" || domEventName === "pointerover";
            SyntheticEventCtor = domEventName === "mouseout" || domEventName === "pointerout";
            if (reactName && nativeEvent !== currentReplayingEvent && (reactEventType = nativeEvent.relatedTarget || nativeEvent.fromElement) && (getClosestInstanceFromNode(reactEventType) || reactEventType[internalContainerInstanceKey]))
              break a;
            if (SyntheticEventCtor || reactName) {
              reactName = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget : (reactName = nativeEventTarget.ownerDocument) ? reactName.defaultView || reactName.parentWindow : window;
              if (SyntheticEventCtor) {
                if (reactEventType = nativeEvent.relatedTarget || nativeEvent.toElement, SyntheticEventCtor = targetInst, reactEventType = reactEventType ? getClosestInstanceFromNode(reactEventType) : null, reactEventType !== null && (accumulateTargetOnly = getNearestMountedFiber(reactEventType), inCapturePhase = reactEventType.tag, reactEventType !== accumulateTargetOnly || inCapturePhase !== 5 && inCapturePhase !== 27 && inCapturePhase !== 6))
                  reactEventType = null;
              } else
                SyntheticEventCtor = null, reactEventType = targetInst;
              if (SyntheticEventCtor !== reactEventType) {
                inCapturePhase = SyntheticMouseEvent;
                _instance2 = "onMouseLeave";
                reactEventName = "onMouseEnter";
                instance = "mouse";
                if (domEventName === "pointerout" || domEventName === "pointerover")
                  inCapturePhase = SyntheticPointerEvent, _instance2 = "onPointerLeave", reactEventName = "onPointerEnter", instance = "pointer";
                accumulateTargetOnly = SyntheticEventCtor == null ? reactName : getNodeFromInstance(SyntheticEventCtor);
                lastHostComponent = reactEventType == null ? reactName : getNodeFromInstance(reactEventType);
                reactName = new inCapturePhase(_instance2, instance + "leave", SyntheticEventCtor, nativeEvent, nativeEventTarget);
                reactName.target = accumulateTargetOnly;
                reactName.relatedTarget = lastHostComponent;
                _instance2 = null;
                getClosestInstanceFromNode(nativeEventTarget) === targetInst && (inCapturePhase = new inCapturePhase(reactEventName, instance + "enter", reactEventType, nativeEvent, nativeEventTarget), inCapturePhase.target = lastHostComponent, inCapturePhase.relatedTarget = accumulateTargetOnly, _instance2 = inCapturePhase);
                accumulateTargetOnly = _instance2;
                if (SyntheticEventCtor && reactEventType)
                  b: {
                    inCapturePhase = getParent;
                    reactEventName = SyntheticEventCtor;
                    instance = reactEventType;
                    lastHostComponent = 0;
                    for (_instance2 = reactEventName;_instance2; _instance2 = inCapturePhase(_instance2))
                      lastHostComponent++;
                    _instance2 = 0;
                    for (var tempB = instance;tempB; tempB = inCapturePhase(tempB))
                      _instance2++;
                    for (;0 < lastHostComponent - _instance2; )
                      reactEventName = inCapturePhase(reactEventName), lastHostComponent--;
                    for (;0 < _instance2 - lastHostComponent; )
                      instance = inCapturePhase(instance), _instance2--;
                    for (;lastHostComponent--; ) {
                      if (reactEventName === instance || instance !== null && reactEventName === instance.alternate) {
                        inCapturePhase = reactEventName;
                        break b;
                      }
                      reactEventName = inCapturePhase(reactEventName);
                      instance = inCapturePhase(instance);
                    }
                    inCapturePhase = null;
                  }
                else
                  inCapturePhase = null;
                SyntheticEventCtor !== null && accumulateEnterLeaveListenersForEvent(dispatchQueue, reactName, SyntheticEventCtor, inCapturePhase, false);
                reactEventType !== null && accumulateTargetOnly !== null && accumulateEnterLeaveListenersForEvent(dispatchQueue, accumulateTargetOnly, reactEventType, inCapturePhase, true);
              }
            }
          }
          a: {
            reactName = targetInst ? getNodeFromInstance(targetInst) : window;
            SyntheticEventCtor = reactName.nodeName && reactName.nodeName.toLowerCase();
            if (SyntheticEventCtor === "select" || SyntheticEventCtor === "input" && reactName.type === "file")
              var getTargetInstFunc = getTargetInstForChangeEvent;
            else if (isTextInputElement(reactName))
              if (isInputEventSupported)
                getTargetInstFunc = getTargetInstForInputOrChangeEvent;
              else {
                getTargetInstFunc = getTargetInstForInputEventPolyfill;
                var handleEventFunc = handleEventsForInputEventPolyfill;
              }
            else
              SyntheticEventCtor = reactName.nodeName, !SyntheticEventCtor || SyntheticEventCtor.toLowerCase() !== "input" || reactName.type !== "checkbox" && reactName.type !== "radio" ? targetInst && isCustomElement(targetInst.elementType) && (getTargetInstFunc = getTargetInstForChangeEvent) : getTargetInstFunc = getTargetInstForClickEvent;
            if (getTargetInstFunc && (getTargetInstFunc = getTargetInstFunc(domEventName, targetInst))) {
              createAndAccumulateChangeEvent(dispatchQueue, getTargetInstFunc, nativeEvent, nativeEventTarget);
              break a;
            }
            handleEventFunc && handleEventFunc(domEventName, reactName, targetInst);
            domEventName === "focusout" && targetInst && reactName.type === "number" && targetInst.memoizedProps.value != null && setDefaultValue(reactName, "number", reactName.value);
          }
          handleEventFunc = targetInst ? getNodeFromInstance(targetInst) : window;
          switch (domEventName) {
            case "focusin":
              if (isTextInputElement(handleEventFunc) || handleEventFunc.contentEditable === "true")
                activeElement = handleEventFunc, activeElementInst = targetInst, lastSelection = null;
              break;
            case "focusout":
              lastSelection = activeElementInst = activeElement = null;
              break;
            case "mousedown":
              mouseDown = true;
              break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
              mouseDown = false;
              constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
              break;
            case "selectionchange":
              if (skipSelectionChangeEvent)
                break;
            case "keydown":
            case "keyup":
              constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
          }
          var fallbackData;
          if (canUseCompositionEvent)
            b: {
              switch (domEventName) {
                case "compositionstart":
                  var eventType = "onCompositionStart";
                  break b;
                case "compositionend":
                  eventType = "onCompositionEnd";
                  break b;
                case "compositionupdate":
                  eventType = "onCompositionUpdate";
                  break b;
              }
              eventType = undefined;
            }
          else
            isComposing ? isFallbackCompositionEnd(domEventName, nativeEvent) && (eventType = "onCompositionEnd") : domEventName === "keydown" && nativeEvent.keyCode === START_KEYCODE && (eventType = "onCompositionStart");
          eventType && (useFallbackCompositionData && nativeEvent.locale !== "ko" && (isComposing || eventType !== "onCompositionStart" ? eventType === "onCompositionEnd" && isComposing && (fallbackData = getData()) : (root = nativeEventTarget, startText = ("value" in root) ? root.value : root.textContent, isComposing = true)), handleEventFunc = accumulateTwoPhaseListeners(targetInst, eventType), 0 < handleEventFunc.length && (eventType = new SyntheticCompositionEvent(eventType, domEventName, null, nativeEvent, nativeEventTarget), dispatchQueue.push({
            event: eventType,
            listeners: handleEventFunc
          }), fallbackData ? eventType.data = fallbackData : (fallbackData = getDataFromCustomEvent(nativeEvent), fallbackData !== null && (eventType.data = fallbackData))));
          if (fallbackData = canUseTextInputEvent ? getNativeBeforeInputChars(domEventName, nativeEvent) : getFallbackBeforeInputChars(domEventName, nativeEvent))
            eventType = accumulateTwoPhaseListeners(targetInst, "onBeforeInput"), 0 < eventType.length && (handleEventFunc = new SyntheticInputEvent("onBeforeInput", "beforeinput", null, nativeEvent, nativeEventTarget), dispatchQueue.push({
              event: handleEventFunc,
              listeners: eventType
            }), handleEventFunc.data = fallbackData);
          extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
        }
        processDispatchQueue(dispatchQueue, eventSystemFlags);
      });
    }
    function createDispatchListener(instance, listener, currentTarget) {
      return {
        instance,
        listener,
        currentTarget
      };
    }
    function accumulateTwoPhaseListeners(targetFiber, reactName) {
      for (var captureName = reactName + "Capture", listeners = [];targetFiber !== null; ) {
        var _instance3 = targetFiber, stateNode = _instance3.stateNode;
        _instance3 = _instance3.tag;
        _instance3 !== 5 && _instance3 !== 26 && _instance3 !== 27 || stateNode === null || (_instance3 = getListener(targetFiber, captureName), _instance3 != null && listeners.unshift(createDispatchListener(targetFiber, _instance3, stateNode)), _instance3 = getListener(targetFiber, reactName), _instance3 != null && listeners.push(createDispatchListener(targetFiber, _instance3, stateNode)));
        if (targetFiber.tag === 3)
          return listeners;
        targetFiber = targetFiber.return;
      }
      return [];
    }
    function getParent(inst) {
      if (inst === null)
        return null;
      do
        inst = inst.return;
      while (inst && inst.tag !== 5 && inst.tag !== 27);
      return inst ? inst : null;
    }
    function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common, inCapturePhase) {
      for (var registrationName = event._reactName, listeners = [];target !== null && target !== common; ) {
        var _instance4 = target, alternate = _instance4.alternate, stateNode = _instance4.stateNode;
        _instance4 = _instance4.tag;
        if (alternate !== null && alternate === common)
          break;
        _instance4 !== 5 && _instance4 !== 26 && _instance4 !== 27 || stateNode === null || (alternate = stateNode, inCapturePhase ? (stateNode = getListener(target, registrationName), stateNode != null && listeners.unshift(createDispatchListener(target, stateNode, alternate))) : inCapturePhase || (stateNode = getListener(target, registrationName), stateNode != null && listeners.push(createDispatchListener(target, stateNode, alternate))));
        target = target.return;
      }
      listeners.length !== 0 && dispatchQueue.push({ event, listeners });
    }
    function validatePropertiesInDevelopment(type, props) {
      validateProperties$2(type, props);
      type !== "input" && type !== "textarea" && type !== "select" || props == null || props.value !== null || didWarnValueNull || (didWarnValueNull = true, type === "select" && props.multiple ? console.error("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", type) : console.error("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", type));
      var eventRegistry = {
        registrationNameDependencies,
        possibleRegistrationNames
      };
      isCustomElement(type) || typeof props.is === "string" || warnUnknownProperties(type, props, eventRegistry);
      props.contentEditable && !props.suppressContentEditableWarning && props.children != null && console.error("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.");
    }
    function warnForPropDifference(propName, serverValue, clientValue, serverDifferences) {
      serverValue !== clientValue && (clientValue = normalizeMarkupForTextOrAttribute(clientValue), normalizeMarkupForTextOrAttribute(serverValue) !== clientValue && (serverDifferences[propName] = serverValue));
    }
    function warnForExtraAttributes(domElement, attributeNames, serverDifferences) {
      attributeNames.forEach(function(attributeName) {
        serverDifferences[getPropNameFromAttributeName(attributeName)] = attributeName === "style" ? getStylesObjectFromElement(domElement) : domElement.getAttribute(attributeName);
      });
    }
    function warnForInvalidEventListener(registrationName, listener) {
      listener === false ? console.error("Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.", registrationName, registrationName, registrationName) : console.error("Expected `%s` listener to be a function, instead got a value of `%s` type.", registrationName, typeof listener);
    }
    function normalizeHTML(parent, html) {
      parent = parent.namespaceURI === MATH_NAMESPACE || parent.namespaceURI === SVG_NAMESPACE ? parent.ownerDocument.createElementNS(parent.namespaceURI, parent.tagName) : parent.ownerDocument.createElement(parent.tagName);
      parent.innerHTML = html;
      return parent.innerHTML;
    }
    function normalizeMarkupForTextOrAttribute(markup) {
      willCoercionThrow(markup) && (console.error("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before using it here.", typeName(markup)), testStringCoercion(markup));
      return (typeof markup === "string" ? markup : "" + markup).replace(NORMALIZE_NEWLINES_REGEX, `
`).replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
    }
    function checkForUnmatchedText(serverText, clientText) {
      clientText = normalizeMarkupForTextOrAttribute(clientText);
      return normalizeMarkupForTextOrAttribute(serverText) === clientText ? true : false;
    }
    function setProp(domElement, tag, key, value, props, prevValue) {
      switch (key) {
        case "children":
          if (typeof value === "string")
            validateTextNesting(value, tag, false), tag === "body" || tag === "textarea" && value === "" || setTextContent(domElement, value);
          else if (typeof value === "number" || typeof value === "bigint")
            validateTextNesting("" + value, tag, false), tag !== "body" && setTextContent(domElement, "" + value);
          break;
        case "className":
          setValueForKnownAttribute(domElement, "class", value);
          break;
        case "tabIndex":
          setValueForKnownAttribute(domElement, "tabindex", value);
          break;
        case "dir":
        case "role":
        case "viewBox":
        case "width":
        case "height":
          setValueForKnownAttribute(domElement, key, value);
          break;
        case "style":
          setValueForStyles(domElement, value, prevValue);
          break;
        case "data":
          if (tag !== "object") {
            setValueForKnownAttribute(domElement, "data", value);
            break;
          }
        case "src":
        case "href":
          if (value === "" && (tag !== "a" || key !== "href")) {
            key === "src" ? console.error('An empty string ("") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.', key, key) : console.error('An empty string ("") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.', key, key);
            domElement.removeAttribute(key);
            break;
          }
          if (value == null || typeof value === "function" || typeof value === "symbol" || typeof value === "boolean") {
            domElement.removeAttribute(key);
            break;
          }
          checkAttributeStringCoercion(value, key);
          value = sanitizeURL("" + value);
          domElement.setAttribute(key, value);
          break;
        case "action":
        case "formAction":
          value != null && (tag === "form" ? key === "formAction" ? console.error("You can only pass the formAction prop to <input> or <button>. Use the action prop on <form>.") : typeof value === "function" && (props.encType == null && props.method == null || didWarnFormActionMethod || (didWarnFormActionMethod = true, console.error("Cannot specify a encType or method for a form that specifies a function as the action. React provides those automatically. They will get overridden.")), props.target == null || didWarnFormActionTarget || (didWarnFormActionTarget = true, console.error("Cannot specify a target for a form that specifies a function as the action. The function will always be executed in the same window."))) : tag === "input" || tag === "button" ? key === "action" ? console.error("You can only pass the action prop to <form>. Use the formAction prop on <input> or <button>.") : tag !== "input" || props.type === "submit" || props.type === "image" || didWarnFormActionType ? tag !== "button" || props.type == null || props.type === "submit" || didWarnFormActionType ? typeof value === "function" && (props.name == null || didWarnFormActionName || (didWarnFormActionName = true, console.error('Cannot specify a "name" prop for a button that specifies a function as a formAction. React needs it to encode which action should be invoked. It will get overridden.')), props.formEncType == null && props.formMethod == null || didWarnFormActionMethod || (didWarnFormActionMethod = true, console.error("Cannot specify a formEncType or formMethod for a button that specifies a function as a formAction. React provides those automatically. They will get overridden.")), props.formTarget == null || didWarnFormActionTarget || (didWarnFormActionTarget = true, console.error("Cannot specify a formTarget for a button that specifies a function as a formAction. The function will always be executed in the same window."))) : (didWarnFormActionType = true, console.error('A button can only specify a formAction along with type="submit" or no type.')) : (didWarnFormActionType = true, console.error('An input can only specify a formAction along with type="submit" or type="image".')) : key === "action" ? console.error("You can only pass the action prop to <form>.") : console.error("You can only pass the formAction prop to <input> or <button>."));
          if (typeof value === "function") {
            domElement.setAttribute(key, "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");
            break;
          } else
            typeof prevValue === "function" && (key === "formAction" ? (tag !== "input" && setProp(domElement, tag, "name", props.name, props, null), setProp(domElement, tag, "formEncType", props.formEncType, props, null), setProp(domElement, tag, "formMethod", props.formMethod, props, null), setProp(domElement, tag, "formTarget", props.formTarget, props, null)) : (setProp(domElement, tag, "encType", props.encType, props, null), setProp(domElement, tag, "method", props.method, props, null), setProp(domElement, tag, "target", props.target, props, null)));
          if (value == null || typeof value === "symbol" || typeof value === "boolean") {
            domElement.removeAttribute(key);
            break;
          }
          checkAttributeStringCoercion(value, key);
          value = sanitizeURL("" + value);
          domElement.setAttribute(key, value);
          break;
        case "onClick":
          value != null && (typeof value !== "function" && warnForInvalidEventListener(key, value), domElement.onclick = noop$1);
          break;
        case "onScroll":
          value != null && (typeof value !== "function" && warnForInvalidEventListener(key, value), listenToNonDelegatedEvent("scroll", domElement));
          break;
        case "onScrollEnd":
          value != null && (typeof value !== "function" && warnForInvalidEventListener(key, value), listenToNonDelegatedEvent("scrollend", domElement));
          break;
        case "dangerouslySetInnerHTML":
          if (value != null) {
            if (typeof value !== "object" || !("__html" in value))
              throw Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information.");
            key = value.__html;
            if (key != null) {
              if (props.children != null)
                throw Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
              domElement.innerHTML = key;
            }
          }
          break;
        case "multiple":
          domElement.multiple = value && typeof value !== "function" && typeof value !== "symbol";
          break;
        case "muted":
          domElement.muted = value && typeof value !== "function" && typeof value !== "symbol";
          break;
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "ref":
          break;
        case "autoFocus":
          break;
        case "xlinkHref":
          if (value == null || typeof value === "function" || typeof value === "boolean" || typeof value === "symbol") {
            domElement.removeAttribute("xlink:href");
            break;
          }
          checkAttributeStringCoercion(value, key);
          key = sanitizeURL("" + value);
          domElement.setAttributeNS(xlinkNamespace, "xlink:href", key);
          break;
        case "contentEditable":
        case "spellCheck":
        case "draggable":
        case "value":
        case "autoReverse":
        case "externalResourcesRequired":
        case "focusable":
        case "preserveAlpha":
          value != null && typeof value !== "function" && typeof value !== "symbol" ? (checkAttributeStringCoercion(value, key), domElement.setAttribute(key, "" + value)) : domElement.removeAttribute(key);
          break;
        case "inert":
          value !== "" || didWarnForNewBooleanPropsWithEmptyValue[key] || (didWarnForNewBooleanPropsWithEmptyValue[key] = true, console.error("Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.", key));
        case "allowFullScreen":
        case "async":
        case "autoPlay":
        case "controls":
        case "default":
        case "defer":
        case "disabled":
        case "disablePictureInPicture":
        case "disableRemotePlayback":
        case "formNoValidate":
        case "hidden":
        case "loop":
        case "noModule":
        case "noValidate":
        case "open":
        case "playsInline":
        case "readOnly":
        case "required":
        case "reversed":
        case "scoped":
        case "seamless":
        case "itemScope":
          value && typeof value !== "function" && typeof value !== "symbol" ? domElement.setAttribute(key, "") : domElement.removeAttribute(key);
          break;
        case "capture":
        case "download":
          value === true ? domElement.setAttribute(key, "") : value !== false && value != null && typeof value !== "function" && typeof value !== "symbol" ? (checkAttributeStringCoercion(value, key), domElement.setAttribute(key, value)) : domElement.removeAttribute(key);
          break;
        case "cols":
        case "rows":
        case "size":
        case "span":
          value != null && typeof value !== "function" && typeof value !== "symbol" && !isNaN(value) && 1 <= value ? (checkAttributeStringCoercion(value, key), domElement.setAttribute(key, value)) : domElement.removeAttribute(key);
          break;
        case "rowSpan":
        case "start":
          value == null || typeof value === "function" || typeof value === "symbol" || isNaN(value) ? domElement.removeAttribute(key) : (checkAttributeStringCoercion(value, key), domElement.setAttribute(key, value));
          break;
        case "popover":
          listenToNonDelegatedEvent("beforetoggle", domElement);
          listenToNonDelegatedEvent("toggle", domElement);
          setValueForAttribute(domElement, "popover", value);
          break;
        case "xlinkActuate":
          setValueForNamespacedAttribute(domElement, xlinkNamespace, "xlink:actuate", value);
          break;
        case "xlinkArcrole":
          setValueForNamespacedAttribute(domElement, xlinkNamespace, "xlink:arcrole", value);
          break;
        case "xlinkRole":
          setValueForNamespacedAttribute(domElement, xlinkNamespace, "xlink:role", value);
          break;
        case "xlinkShow":
          setValueForNamespacedAttribute(domElement, xlinkNamespace, "xlink:show", value);
          break;
        case "xlinkTitle":
          setValueForNamespacedAttribute(domElement, xlinkNamespace, "xlink:title", value);
          break;
        case "xlinkType":
          setValueForNamespacedAttribute(domElement, xlinkNamespace, "xlink:type", value);
          break;
        case "xmlBase":
          setValueForNamespacedAttribute(domElement, xmlNamespace, "xml:base", value);
          break;
        case "xmlLang":
          setValueForNamespacedAttribute(domElement, xmlNamespace, "xml:lang", value);
          break;
        case "xmlSpace":
          setValueForNamespacedAttribute(domElement, xmlNamespace, "xml:space", value);
          break;
        case "is":
          prevValue != null && console.error('Cannot update the "is" prop after it has been initialized.');
          setValueForAttribute(domElement, "is", value);
          break;
        case "innerText":
        case "textContent":
          break;
        case "popoverTarget":
          didWarnPopoverTargetObject || value == null || typeof value !== "object" || (didWarnPopoverTargetObject = true, console.error("The `popoverTarget` prop expects the ID of an Element as a string. Received %s instead.", value));
        default:
          !(2 < key.length) || key[0] !== "o" && key[0] !== "O" || key[1] !== "n" && key[1] !== "N" ? (key = getAttributeAlias(key), setValueForAttribute(domElement, key, value)) : registrationNameDependencies.hasOwnProperty(key) && value != null && typeof value !== "function" && warnForInvalidEventListener(key, value);
      }
    }
    function setPropOnCustomElement(domElement, tag, key, value, props, prevValue) {
      switch (key) {
        case "style":
          setValueForStyles(domElement, value, prevValue);
          break;
        case "dangerouslySetInnerHTML":
          if (value != null) {
            if (typeof value !== "object" || !("__html" in value))
              throw Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information.");
            key = value.__html;
            if (key != null) {
              if (props.children != null)
                throw Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
              domElement.innerHTML = key;
            }
          }
          break;
        case "children":
          typeof value === "string" ? setTextContent(domElement, value) : (typeof value === "number" || typeof value === "bigint") && setTextContent(domElement, "" + value);
          break;
        case "onScroll":
          value != null && (typeof value !== "function" && warnForInvalidEventListener(key, value), listenToNonDelegatedEvent("scroll", domElement));
          break;
        case "onScrollEnd":
          value != null && (typeof value !== "function" && warnForInvalidEventListener(key, value), listenToNonDelegatedEvent("scrollend", domElement));
          break;
        case "onClick":
          value != null && (typeof value !== "function" && warnForInvalidEventListener(key, value), domElement.onclick = noop$1);
          break;
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "innerHTML":
        case "ref":
          break;
        case "innerText":
        case "textContent":
          break;
        default:
          if (registrationNameDependencies.hasOwnProperty(key))
            value != null && typeof value !== "function" && warnForInvalidEventListener(key, value);
          else
            a: {
              if (key[0] === "o" && key[1] === "n" && (props = key.endsWith("Capture"), tag = key.slice(2, props ? key.length - 7 : undefined), prevValue = domElement[internalPropsKey] || null, prevValue = prevValue != null ? prevValue[key] : null, typeof prevValue === "function" && domElement.removeEventListener(tag, prevValue, props), typeof value === "function")) {
                typeof prevValue !== "function" && prevValue !== null && (key in domElement ? domElement[key] = null : domElement.hasAttribute(key) && domElement.removeAttribute(key));
                domElement.addEventListener(tag, value, props);
                break a;
              }
              key in domElement ? domElement[key] = value : value === true ? domElement.setAttribute(key, "") : setValueForAttribute(domElement, key, value);
            }
      }
    }
    function setInitialProperties(domElement, tag, props) {
      validatePropertiesInDevelopment(tag, props);
      switch (tag) {
        case "div":
        case "span":
        case "svg":
        case "path":
        case "a":
        case "g":
        case "p":
        case "li":
          break;
        case "img":
          listenToNonDelegatedEvent("error", domElement);
          listenToNonDelegatedEvent("load", domElement);
          var hasSrc = false, hasSrcSet = false, propKey;
          for (propKey in props)
            if (props.hasOwnProperty(propKey)) {
              var propValue = props[propKey];
              if (propValue != null)
                switch (propKey) {
                  case "src":
                    hasSrc = true;
                    break;
                  case "srcSet":
                    hasSrcSet = true;
                    break;
                  case "children":
                  case "dangerouslySetInnerHTML":
                    throw Error(tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
                  default:
                    setProp(domElement, tag, propKey, propValue, props, null);
                }
            }
          hasSrcSet && setProp(domElement, tag, "srcSet", props.srcSet, props, null);
          hasSrc && setProp(domElement, tag, "src", props.src, props, null);
          return;
        case "input":
          checkControlledValueProps("input", props);
          listenToNonDelegatedEvent("invalid", domElement);
          var defaultValue = propKey = propValue = hasSrcSet = null, checked = null, defaultChecked = null;
          for (hasSrc in props)
            if (props.hasOwnProperty(hasSrc)) {
              var _propValue = props[hasSrc];
              if (_propValue != null)
                switch (hasSrc) {
                  case "name":
                    hasSrcSet = _propValue;
                    break;
                  case "type":
                    propValue = _propValue;
                    break;
                  case "checked":
                    checked = _propValue;
                    break;
                  case "defaultChecked":
                    defaultChecked = _propValue;
                    break;
                  case "value":
                    propKey = _propValue;
                    break;
                  case "defaultValue":
                    defaultValue = _propValue;
                    break;
                  case "children":
                  case "dangerouslySetInnerHTML":
                    if (_propValue != null)
                      throw Error(tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
                    break;
                  default:
                    setProp(domElement, tag, hasSrc, _propValue, props, null);
                }
            }
          validateInputProps(domElement, props);
          initInput(domElement, propKey, defaultValue, checked, defaultChecked, propValue, hasSrcSet, false);
          return;
        case "select":
          checkControlledValueProps("select", props);
          listenToNonDelegatedEvent("invalid", domElement);
          hasSrc = propValue = propKey = null;
          for (hasSrcSet in props)
            if (props.hasOwnProperty(hasSrcSet) && (defaultValue = props[hasSrcSet], defaultValue != null))
              switch (hasSrcSet) {
                case "value":
                  propKey = defaultValue;
                  break;
                case "defaultValue":
                  propValue = defaultValue;
                  break;
                case "multiple":
                  hasSrc = defaultValue;
                default:
                  setProp(domElement, tag, hasSrcSet, defaultValue, props, null);
              }
          validateSelectProps(domElement, props);
          tag = propKey;
          props = propValue;
          domElement.multiple = !!hasSrc;
          tag != null ? updateOptions(domElement, !!hasSrc, tag, false) : props != null && updateOptions(domElement, !!hasSrc, props, true);
          return;
        case "textarea":
          checkControlledValueProps("textarea", props);
          listenToNonDelegatedEvent("invalid", domElement);
          propKey = hasSrcSet = hasSrc = null;
          for (propValue in props)
            if (props.hasOwnProperty(propValue) && (defaultValue = props[propValue], defaultValue != null))
              switch (propValue) {
                case "value":
                  hasSrc = defaultValue;
                  break;
                case "defaultValue":
                  hasSrcSet = defaultValue;
                  break;
                case "children":
                  propKey = defaultValue;
                  break;
                case "dangerouslySetInnerHTML":
                  if (defaultValue != null)
                    throw Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
                  break;
                default:
                  setProp(domElement, tag, propValue, defaultValue, props, null);
              }
          validateTextareaProps(domElement, props);
          initTextarea(domElement, hasSrc, hasSrcSet, propKey);
          return;
        case "option":
          validateOptionProps(domElement, props);
          for (checked in props)
            if (props.hasOwnProperty(checked) && (hasSrc = props[checked], hasSrc != null))
              switch (checked) {
                case "selected":
                  domElement.selected = hasSrc && typeof hasSrc !== "function" && typeof hasSrc !== "symbol";
                  break;
                default:
                  setProp(domElement, tag, checked, hasSrc, props, null);
              }
          return;
        case "dialog":
          listenToNonDelegatedEvent("beforetoggle", domElement);
          listenToNonDelegatedEvent("toggle", domElement);
          listenToNonDelegatedEvent("cancel", domElement);
          listenToNonDelegatedEvent("close", domElement);
          break;
        case "iframe":
        case "object":
          listenToNonDelegatedEvent("load", domElement);
          break;
        case "video":
        case "audio":
          for (hasSrc = 0;hasSrc < mediaEventTypes.length; hasSrc++)
            listenToNonDelegatedEvent(mediaEventTypes[hasSrc], domElement);
          break;
        case "image":
          listenToNonDelegatedEvent("error", domElement);
          listenToNonDelegatedEvent("load", domElement);
          break;
        case "details":
          listenToNonDelegatedEvent("toggle", domElement);
          break;
        case "embed":
        case "source":
        case "link":
          listenToNonDelegatedEvent("error", domElement), listenToNonDelegatedEvent("load", domElement);
        case "area":
        case "base":
        case "br":
        case "col":
        case "hr":
        case "keygen":
        case "meta":
        case "param":
        case "track":
        case "wbr":
        case "menuitem":
          for (defaultChecked in props)
            if (props.hasOwnProperty(defaultChecked) && (hasSrc = props[defaultChecked], hasSrc != null))
              switch (defaultChecked) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
                default:
                  setProp(domElement, tag, defaultChecked, hasSrc, props, null);
              }
          return;
        default:
          if (isCustomElement(tag)) {
            for (_propValue in props)
              props.hasOwnProperty(_propValue) && (hasSrc = props[_propValue], hasSrc !== undefined && setPropOnCustomElement(domElement, tag, _propValue, hasSrc, props, undefined));
            return;
          }
      }
      for (defaultValue in props)
        props.hasOwnProperty(defaultValue) && (hasSrc = props[defaultValue], hasSrc != null && setProp(domElement, tag, defaultValue, hasSrc, props, null));
    }
    function updateProperties(domElement, tag, lastProps, nextProps) {
      validatePropertiesInDevelopment(tag, nextProps);
      switch (tag) {
        case "div":
        case "span":
        case "svg":
        case "path":
        case "a":
        case "g":
        case "p":
        case "li":
          break;
        case "input":
          var name = null, type = null, value = null, defaultValue = null, lastDefaultValue = null, checked = null, defaultChecked = null;
          for (propKey in lastProps) {
            var lastProp = lastProps[propKey];
            if (lastProps.hasOwnProperty(propKey) && lastProp != null)
              switch (propKey) {
                case "checked":
                  break;
                case "value":
                  break;
                case "defaultValue":
                  lastDefaultValue = lastProp;
                default:
                  nextProps.hasOwnProperty(propKey) || setProp(domElement, tag, propKey, null, nextProps, lastProp);
              }
          }
          for (var _propKey8 in nextProps) {
            var propKey = nextProps[_propKey8];
            lastProp = lastProps[_propKey8];
            if (nextProps.hasOwnProperty(_propKey8) && (propKey != null || lastProp != null))
              switch (_propKey8) {
                case "type":
                  type = propKey;
                  break;
                case "name":
                  name = propKey;
                  break;
                case "checked":
                  checked = propKey;
                  break;
                case "defaultChecked":
                  defaultChecked = propKey;
                  break;
                case "value":
                  value = propKey;
                  break;
                case "defaultValue":
                  defaultValue = propKey;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  if (propKey != null)
                    throw Error(tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
                  break;
                default:
                  propKey !== lastProp && setProp(domElement, tag, _propKey8, propKey, nextProps, lastProp);
              }
          }
          tag = lastProps.type === "checkbox" || lastProps.type === "radio" ? lastProps.checked != null : lastProps.value != null;
          nextProps = nextProps.type === "checkbox" || nextProps.type === "radio" ? nextProps.checked != null : nextProps.value != null;
          tag || !nextProps || didWarnUncontrolledToControlled || (console.error("A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://react.dev/link/controlled-components"), didWarnUncontrolledToControlled = true);
          !tag || nextProps || didWarnControlledToUncontrolled || (console.error("A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://react.dev/link/controlled-components"), didWarnControlledToUncontrolled = true);
          updateInput(domElement, value, defaultValue, lastDefaultValue, checked, defaultChecked, type, name);
          return;
        case "select":
          propKey = value = defaultValue = _propKey8 = null;
          for (type in lastProps)
            if (lastDefaultValue = lastProps[type], lastProps.hasOwnProperty(type) && lastDefaultValue != null)
              switch (type) {
                case "value":
                  break;
                case "multiple":
                  propKey = lastDefaultValue;
                default:
                  nextProps.hasOwnProperty(type) || setProp(domElement, tag, type, null, nextProps, lastDefaultValue);
              }
          for (name in nextProps)
            if (type = nextProps[name], lastDefaultValue = lastProps[name], nextProps.hasOwnProperty(name) && (type != null || lastDefaultValue != null))
              switch (name) {
                case "value":
                  _propKey8 = type;
                  break;
                case "defaultValue":
                  defaultValue = type;
                  break;
                case "multiple":
                  value = type;
                default:
                  type !== lastDefaultValue && setProp(domElement, tag, name, type, nextProps, lastDefaultValue);
              }
          nextProps = defaultValue;
          tag = value;
          lastProps = propKey;
          _propKey8 != null ? updateOptions(domElement, !!tag, _propKey8, false) : !!lastProps !== !!tag && (nextProps != null ? updateOptions(domElement, !!tag, nextProps, true) : updateOptions(domElement, !!tag, tag ? [] : "", false));
          return;
        case "textarea":
          propKey = _propKey8 = null;
          for (defaultValue in lastProps)
            if (name = lastProps[defaultValue], lastProps.hasOwnProperty(defaultValue) && name != null && !nextProps.hasOwnProperty(defaultValue))
              switch (defaultValue) {
                case "value":
                  break;
                case "children":
                  break;
                default:
                  setProp(domElement, tag, defaultValue, null, nextProps, name);
              }
          for (value in nextProps)
            if (name = nextProps[value], type = lastProps[value], nextProps.hasOwnProperty(value) && (name != null || type != null))
              switch (value) {
                case "value":
                  _propKey8 = name;
                  break;
                case "defaultValue":
                  propKey = name;
                  break;
                case "children":
                  break;
                case "dangerouslySetInnerHTML":
                  if (name != null)
                    throw Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
                  break;
                default:
                  name !== type && setProp(domElement, tag, value, name, nextProps, type);
              }
          updateTextarea(domElement, _propKey8, propKey);
          return;
        case "option":
          for (var _propKey13 in lastProps)
            if (_propKey8 = lastProps[_propKey13], lastProps.hasOwnProperty(_propKey13) && _propKey8 != null && !nextProps.hasOwnProperty(_propKey13))
              switch (_propKey13) {
                case "selected":
                  domElement.selected = false;
                  break;
                default:
                  setProp(domElement, tag, _propKey13, null, nextProps, _propKey8);
              }
          for (lastDefaultValue in nextProps)
            if (_propKey8 = nextProps[lastDefaultValue], propKey = lastProps[lastDefaultValue], nextProps.hasOwnProperty(lastDefaultValue) && _propKey8 !== propKey && (_propKey8 != null || propKey != null))
              switch (lastDefaultValue) {
                case "selected":
                  domElement.selected = _propKey8 && typeof _propKey8 !== "function" && typeof _propKey8 !== "symbol";
                  break;
                default:
                  setProp(domElement, tag, lastDefaultValue, _propKey8, nextProps, propKey);
              }
          return;
        case "img":
        case "link":
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "keygen":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
        case "menuitem":
          for (var _propKey15 in lastProps)
            _propKey8 = lastProps[_propKey15], lastProps.hasOwnProperty(_propKey15) && _propKey8 != null && !nextProps.hasOwnProperty(_propKey15) && setProp(domElement, tag, _propKey15, null, nextProps, _propKey8);
          for (checked in nextProps)
            if (_propKey8 = nextProps[checked], propKey = lastProps[checked], nextProps.hasOwnProperty(checked) && _propKey8 !== propKey && (_propKey8 != null || propKey != null))
              switch (checked) {
                case "children":
                case "dangerouslySetInnerHTML":
                  if (_propKey8 != null)
                    throw Error(tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
                  break;
                default:
                  setProp(domElement, tag, checked, _propKey8, nextProps, propKey);
              }
          return;
        default:
          if (isCustomElement(tag)) {
            for (var _propKey17 in lastProps)
              _propKey8 = lastProps[_propKey17], lastProps.hasOwnProperty(_propKey17) && _propKey8 !== undefined && !nextProps.hasOwnProperty(_propKey17) && setPropOnCustomElement(domElement, tag, _propKey17, undefined, nextProps, _propKey8);
            for (defaultChecked in nextProps)
              _propKey8 = nextProps[defaultChecked], propKey = lastProps[defaultChecked], !nextProps.hasOwnProperty(defaultChecked) || _propKey8 === propKey || _propKey8 === undefined && propKey === undefined || setPropOnCustomElement(domElement, tag, defaultChecked, _propKey8, nextProps, propKey);
            return;
          }
      }
      for (var _propKey19 in lastProps)
        _propKey8 = lastProps[_propKey19], lastProps.hasOwnProperty(_propKey19) && _propKey8 != null && !nextProps.hasOwnProperty(_propKey19) && setProp(domElement, tag, _propKey19, null, nextProps, _propKey8);
      for (lastProp in nextProps)
        _propKey8 = nextProps[lastProp], propKey = lastProps[lastProp], !nextProps.hasOwnProperty(lastProp) || _propKey8 === propKey || _propKey8 == null && propKey == null || setProp(domElement, tag, lastProp, _propKey8, nextProps, propKey);
    }
    function getPropNameFromAttributeName(attrName) {
      switch (attrName) {
        case "class":
          return "className";
        case "for":
          return "htmlFor";
        default:
          return attrName;
      }
    }
    function getStylesObjectFromElement(domElement) {
      var serverValueInObjectForm = {};
      domElement = domElement.style;
      for (var i = 0;i < domElement.length; i++) {
        var styleName = domElement[i];
        serverValueInObjectForm[styleName] = domElement.getPropertyValue(styleName);
      }
      return serverValueInObjectForm;
    }
    function diffHydratedStyles(domElement, value$jscomp$0, serverDifferences) {
      if (value$jscomp$0 != null && typeof value$jscomp$0 !== "object")
        console.error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
      else {
        var clientValue;
        var delimiter = clientValue = "", styleName;
        for (styleName in value$jscomp$0)
          if (value$jscomp$0.hasOwnProperty(styleName)) {
            var value = value$jscomp$0[styleName];
            value != null && typeof value !== "boolean" && value !== "" && (styleName.indexOf("--") === 0 ? (checkCSSPropertyStringCoercion(value, styleName), clientValue += delimiter + styleName + ":" + ("" + value).trim()) : typeof value !== "number" || value === 0 || unitlessNumbers.has(styleName) ? (checkCSSPropertyStringCoercion(value, styleName), clientValue += delimiter + styleName.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern$1, "-ms-") + ":" + ("" + value).trim()) : clientValue += delimiter + styleName.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern$1, "-ms-") + ":" + value + "px", delimiter = ";");
          }
        clientValue = clientValue || null;
        value$jscomp$0 = domElement.getAttribute("style");
        value$jscomp$0 !== clientValue && (clientValue = normalizeMarkupForTextOrAttribute(clientValue), normalizeMarkupForTextOrAttribute(value$jscomp$0) !== clientValue && (serverDifferences.style = getStylesObjectFromElement(domElement)));
      }
    }
    function hydrateAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
      extraAttributes.delete(attributeName);
      domElement = domElement.getAttribute(attributeName);
      if (domElement === null)
        switch (typeof value) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            return;
        }
      else if (value != null)
        switch (typeof value) {
          case "function":
          case "symbol":
          case "boolean":
            break;
          default:
            if (checkAttributeStringCoercion(value, propKey), domElement === "" + value)
              return;
        }
      warnForPropDifference(propKey, domElement, value, serverDifferences);
    }
    function hydrateBooleanAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
      extraAttributes.delete(attributeName);
      domElement = domElement.getAttribute(attributeName);
      if (domElement === null) {
        switch (typeof value) {
          case "function":
          case "symbol":
            return;
        }
        if (!value)
          return;
      } else
        switch (typeof value) {
          case "function":
          case "symbol":
            break;
          default:
            if (value)
              return;
        }
      warnForPropDifference(propKey, domElement, value, serverDifferences);
    }
    function hydrateBooleanishAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
      extraAttributes.delete(attributeName);
      domElement = domElement.getAttribute(attributeName);
      if (domElement === null)
        switch (typeof value) {
          case "undefined":
          case "function":
          case "symbol":
            return;
        }
      else if (value != null)
        switch (typeof value) {
          case "function":
          case "symbol":
            break;
          default:
            if (checkAttributeStringCoercion(value, attributeName), domElement === "" + value)
              return;
        }
      warnForPropDifference(propKey, domElement, value, serverDifferences);
    }
    function hydrateNumericAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
      extraAttributes.delete(attributeName);
      domElement = domElement.getAttribute(attributeName);
      if (domElement === null)
        switch (typeof value) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            return;
          default:
            if (isNaN(value))
              return;
        }
      else if (value != null)
        switch (typeof value) {
          case "function":
          case "symbol":
          case "boolean":
            break;
          default:
            if (!isNaN(value) && (checkAttributeStringCoercion(value, propKey), domElement === "" + value))
              return;
        }
      warnForPropDifference(propKey, domElement, value, serverDifferences);
    }
    function hydrateSanitizedAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
      extraAttributes.delete(attributeName);
      domElement = domElement.getAttribute(attributeName);
      if (domElement === null)
        switch (typeof value) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            return;
        }
      else if (value != null)
        switch (typeof value) {
          case "function":
          case "symbol":
          case "boolean":
            break;
          default:
            if (checkAttributeStringCoercion(value, propKey), attributeName = sanitizeURL("" + value), domElement === attributeName)
              return;
        }
      warnForPropDifference(propKey, domElement, value, serverDifferences);
    }
    function diffHydratedProperties(domElement, tag, props, hostContext) {
      for (var serverDifferences = {}, extraAttributes = new Set, attributes = domElement.attributes, i = 0;i < attributes.length; i++)
        switch (attributes[i].name.toLowerCase()) {
          case "value":
            break;
          case "checked":
            break;
          case "selected":
            break;
          default:
            extraAttributes.add(attributes[i].name);
        }
      if (isCustomElement(tag))
        for (var propKey in props) {
          if (props.hasOwnProperty(propKey)) {
            var value = props[propKey];
            if (value != null) {
              if (registrationNameDependencies.hasOwnProperty(propKey))
                typeof value !== "function" && warnForInvalidEventListener(propKey, value);
              else if (props.suppressHydrationWarning !== true)
                switch (propKey) {
                  case "children":
                    typeof value !== "string" && typeof value !== "number" || warnForPropDifference("children", domElement.textContent, value, serverDifferences);
                    continue;
                  case "suppressContentEditableWarning":
                  case "suppressHydrationWarning":
                  case "defaultValue":
                  case "defaultChecked":
                  case "innerHTML":
                  case "ref":
                    continue;
                  case "dangerouslySetInnerHTML":
                    attributes = domElement.innerHTML;
                    value = value ? value.__html : undefined;
                    value != null && (value = normalizeHTML(domElement, value), warnForPropDifference(propKey, attributes, value, serverDifferences));
                    continue;
                  case "style":
                    extraAttributes.delete(propKey);
                    diffHydratedStyles(domElement, value, serverDifferences);
                    continue;
                  case "offsetParent":
                  case "offsetTop":
                  case "offsetLeft":
                  case "offsetWidth":
                  case "offsetHeight":
                  case "isContentEditable":
                  case "outerText":
                  case "outerHTML":
                    extraAttributes.delete(propKey.toLowerCase());
                    console.error("Assignment to read-only property will result in a no-op: `%s`", propKey);
                    continue;
                  case "className":
                    extraAttributes.delete("class");
                    attributes = getValueForAttributeOnCustomComponent(domElement, "class", value);
                    warnForPropDifference("className", attributes, value, serverDifferences);
                    continue;
                  default:
                    hostContext.context === HostContextNamespaceNone && tag !== "svg" && tag !== "math" ? extraAttributes.delete(propKey.toLowerCase()) : extraAttributes.delete(propKey), attributes = getValueForAttributeOnCustomComponent(domElement, propKey, value), warnForPropDifference(propKey, attributes, value, serverDifferences);
                }
            }
          }
        }
      else
        for (value in props)
          if (props.hasOwnProperty(value) && (propKey = props[value], propKey != null)) {
            if (registrationNameDependencies.hasOwnProperty(value))
              typeof propKey !== "function" && warnForInvalidEventListener(value, propKey);
            else if (props.suppressHydrationWarning !== true)
              switch (value) {
                case "children":
                  typeof propKey !== "string" && typeof propKey !== "number" || warnForPropDifference("children", domElement.textContent, propKey, serverDifferences);
                  continue;
                case "suppressContentEditableWarning":
                case "suppressHydrationWarning":
                case "value":
                case "checked":
                case "selected":
                case "defaultValue":
                case "defaultChecked":
                case "innerHTML":
                case "ref":
                  continue;
                case "dangerouslySetInnerHTML":
                  attributes = domElement.innerHTML;
                  propKey = propKey ? propKey.__html : undefined;
                  propKey != null && (propKey = normalizeHTML(domElement, propKey), attributes !== propKey && (serverDifferences[value] = { __html: attributes }));
                  continue;
                case "className":
                  hydrateAttribute(domElement, value, "class", propKey, extraAttributes, serverDifferences);
                  continue;
                case "tabIndex":
                  hydrateAttribute(domElement, value, "tabindex", propKey, extraAttributes, serverDifferences);
                  continue;
                case "style":
                  extraAttributes.delete(value);
                  diffHydratedStyles(domElement, propKey, serverDifferences);
                  continue;
                case "multiple":
                  extraAttributes.delete(value);
                  warnForPropDifference(value, domElement.multiple, propKey, serverDifferences);
                  continue;
                case "muted":
                  extraAttributes.delete(value);
                  warnForPropDifference(value, domElement.muted, propKey, serverDifferences);
                  continue;
                case "autoFocus":
                  extraAttributes.delete("autofocus");
                  warnForPropDifference(value, domElement.autofocus, propKey, serverDifferences);
                  continue;
                case "data":
                  if (tag !== "object") {
                    extraAttributes.delete(value);
                    attributes = domElement.getAttribute("data");
                    warnForPropDifference(value, attributes, propKey, serverDifferences);
                    continue;
                  }
                case "src":
                case "href":
                  if (!(propKey !== "" || tag === "a" && value === "href" || tag === "object" && value === "data")) {
                    value === "src" ? console.error('An empty string ("") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.', value, value) : console.error('An empty string ("") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.', value, value);
                    continue;
                  }
                  hydrateSanitizedAttribute(domElement, value, value, propKey, extraAttributes, serverDifferences);
                  continue;
                case "action":
                case "formAction":
                  attributes = domElement.getAttribute(value);
                  if (typeof propKey === "function") {
                    extraAttributes.delete(value.toLowerCase());
                    value === "formAction" ? (extraAttributes.delete("name"), extraAttributes.delete("formenctype"), extraAttributes.delete("formmethod"), extraAttributes.delete("formtarget")) : (extraAttributes.delete("enctype"), extraAttributes.delete("method"), extraAttributes.delete("target"));
                    continue;
                  } else if (attributes === EXPECTED_FORM_ACTION_URL) {
                    extraAttributes.delete(value.toLowerCase());
                    warnForPropDifference(value, "function", propKey, serverDifferences);
                    continue;
                  }
                  hydrateSanitizedAttribute(domElement, value, value.toLowerCase(), propKey, extraAttributes, serverDifferences);
                  continue;
                case "xlinkHref":
                  hydrateSanitizedAttribute(domElement, value, "xlink:href", propKey, extraAttributes, serverDifferences);
                  continue;
                case "contentEditable":
                  hydrateBooleanishAttribute(domElement, value, "contenteditable", propKey, extraAttributes, serverDifferences);
                  continue;
                case "spellCheck":
                  hydrateBooleanishAttribute(domElement, value, "spellcheck", propKey, extraAttributes, serverDifferences);
                  continue;
                case "draggable":
                case "autoReverse":
                case "externalResourcesRequired":
                case "focusable":
                case "preserveAlpha":
                  hydrateBooleanishAttribute(domElement, value, value, propKey, extraAttributes, serverDifferences);
                  continue;
                case "allowFullScreen":
                case "async":
                case "autoPlay":
                case "controls":
                case "default":
                case "defer":
                case "disabled":
                case "disablePictureInPicture":
                case "disableRemotePlayback":
                case "formNoValidate":
                case "hidden":
                case "loop":
                case "noModule":
                case "noValidate":
                case "open":
                case "playsInline":
                case "readOnly":
                case "required":
                case "reversed":
                case "scoped":
                case "seamless":
                case "itemScope":
                  hydrateBooleanAttribute(domElement, value, value.toLowerCase(), propKey, extraAttributes, serverDifferences);
                  continue;
                case "capture":
                case "download":
                  a: {
                    i = domElement;
                    var attributeName = attributes = value, serverDifferences$jscomp$0 = serverDifferences;
                    extraAttributes.delete(attributeName);
                    i = i.getAttribute(attributeName);
                    if (i === null)
                      switch (typeof propKey) {
                        case "undefined":
                        case "function":
                        case "symbol":
                          break a;
                        default:
                          if (propKey === false)
                            break a;
                      }
                    else if (propKey != null)
                      switch (typeof propKey) {
                        case "function":
                        case "symbol":
                          break;
                        case "boolean":
                          if (propKey === true && i === "")
                            break a;
                          break;
                        default:
                          if (checkAttributeStringCoercion(propKey, attributes), i === "" + propKey)
                            break a;
                      }
                    warnForPropDifference(attributes, i, propKey, serverDifferences$jscomp$0);
                  }
                  continue;
                case "cols":
                case "rows":
                case "size":
                case "span":
                  a: {
                    i = domElement;
                    attributeName = attributes = value;
                    serverDifferences$jscomp$0 = serverDifferences;
                    extraAttributes.delete(attributeName);
                    i = i.getAttribute(attributeName);
                    if (i === null)
                      switch (typeof propKey) {
                        case "undefined":
                        case "function":
                        case "symbol":
                        case "boolean":
                          break a;
                        default:
                          if (isNaN(propKey) || 1 > propKey)
                            break a;
                      }
                    else if (propKey != null)
                      switch (typeof propKey) {
                        case "function":
                        case "symbol":
                        case "boolean":
                          break;
                        default:
                          if (!(isNaN(propKey) || 1 > propKey) && (checkAttributeStringCoercion(propKey, attributes), i === "" + propKey))
                            break a;
                      }
                    warnForPropDifference(attributes, i, propKey, serverDifferences$jscomp$0);
                  }
                  continue;
                case "rowSpan":
                  hydrateNumericAttribute(domElement, value, "rowspan", propKey, extraAttributes, serverDifferences);
                  continue;
                case "start":
                  hydrateNumericAttribute(domElement, value, value, propKey, extraAttributes, serverDifferences);
                  continue;
                case "xHeight":
                  hydrateAttribute(domElement, value, "x-height", propKey, extraAttributes, serverDifferences);
                  continue;
                case "xlinkActuate":
                  hydrateAttribute(domElement, value, "xlink:actuate", propKey, extraAttributes, serverDifferences);
                  continue;
                case "xlinkArcrole":
                  hydrateAttribute(domElement, value, "xlink:arcrole", propKey, extraAttributes, serverDifferences);
                  continue;
                case "xlinkRole":
                  hydrateAttribute(domElement, value, "xlink:role", propKey, extraAttributes, serverDifferences);
                  continue;
                case "xlinkShow":
                  hydrateAttribute(domElement, value, "xlink:show", propKey, extraAttributes, serverDifferences);
                  continue;
                case "xlinkTitle":
                  hydrateAttribute(domElement, value, "xlink:title", propKey, extraAttributes, serverDifferences);
                  continue;
                case "xlinkType":
                  hydrateAttribute(domElement, value, "xlink:type", propKey, extraAttributes, serverDifferences);
                  continue;
                case "xmlBase":
                  hydrateAttribute(domElement, value, "xml:base", propKey, extraAttributes, serverDifferences);
                  continue;
                case "xmlLang":
                  hydrateAttribute(domElement, value, "xml:lang", propKey, extraAttributes, serverDifferences);
                  continue;
                case "xmlSpace":
                  hydrateAttribute(domElement, value, "xml:space", propKey, extraAttributes, serverDifferences);
                  continue;
                case "inert":
                  propKey !== "" || didWarnForNewBooleanPropsWithEmptyValue[value] || (didWarnForNewBooleanPropsWithEmptyValue[value] = true, console.error("Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.", value));
                  hydrateBooleanAttribute(domElement, value, value, propKey, extraAttributes, serverDifferences);
                  continue;
                default:
                  if (!(2 < value.length) || value[0] !== "o" && value[0] !== "O" || value[1] !== "n" && value[1] !== "N") {
                    i = getAttributeAlias(value);
                    attributes = false;
                    hostContext.context === HostContextNamespaceNone && tag !== "svg" && tag !== "math" ? extraAttributes.delete(i.toLowerCase()) : (attributeName = value.toLowerCase(), attributeName = possibleStandardNames.hasOwnProperty(attributeName) ? possibleStandardNames[attributeName] || null : null, attributeName !== null && attributeName !== value && (attributes = true, extraAttributes.delete(attributeName)), extraAttributes.delete(i));
                    a:
                      if (attributeName = domElement, serverDifferences$jscomp$0 = i, i = propKey, isAttributeNameSafe(serverDifferences$jscomp$0))
                        if (attributeName.hasAttribute(serverDifferences$jscomp$0))
                          attributeName = attributeName.getAttribute(serverDifferences$jscomp$0), checkAttributeStringCoercion(i, serverDifferences$jscomp$0), i = attributeName === "" + i ? i : attributeName;
                        else {
                          switch (typeof i) {
                            case "function":
                            case "symbol":
                              break a;
                            case "boolean":
                              if (attributeName = serverDifferences$jscomp$0.toLowerCase().slice(0, 5), attributeName !== "data-" && attributeName !== "aria-")
                                break a;
                          }
                          i = i === undefined ? undefined : null;
                        }
                      else
                        i = undefined;
                    attributes || warnForPropDifference(value, i, propKey, serverDifferences);
                  }
              }
          }
      0 < extraAttributes.size && props.suppressHydrationWarning !== true && warnForExtraAttributes(domElement, extraAttributes, serverDifferences);
      return Object.keys(serverDifferences).length === 0 ? null : serverDifferences;
    }
    function propNamesListJoin(list, combinator) {
      switch (list.length) {
        case 0:
          return "";
        case 1:
          return list[0];
        case 2:
          return list[0] + " " + combinator + " " + list[1];
        default:
          return list.slice(0, -1).join(", ") + ", " + combinator + " " + list[list.length - 1];
      }
    }
    function isLikelyStaticResource(initiatorType) {
      switch (initiatorType) {
        case "css":
        case "script":
        case "font":
        case "img":
        case "image":
        case "input":
        case "link":
          return true;
        default:
          return false;
      }
    }
    function estimateBandwidth() {
      if (typeof performance.getEntriesByType === "function") {
        for (var count = 0, bits = 0, resourceEntries = performance.getEntriesByType("resource"), i = 0;i < resourceEntries.length; i++) {
          var entry = resourceEntries[i], transferSize = entry.transferSize, initiatorType = entry.initiatorType, duration = entry.duration;
          if (transferSize && duration && isLikelyStaticResource(initiatorType)) {
            initiatorType = 0;
            duration = entry.responseEnd;
            for (i += 1;i < resourceEntries.length; i++) {
              var overlapEntry = resourceEntries[i], overlapStartTime = overlapEntry.startTime;
              if (overlapStartTime > duration)
                break;
              var { transferSize: overlapTransferSize, initiatorType: overlapInitiatorType } = overlapEntry;
              overlapTransferSize && isLikelyStaticResource(overlapInitiatorType) && (overlapEntry = overlapEntry.responseEnd, initiatorType += overlapTransferSize * (overlapEntry < duration ? 1 : (duration - overlapStartTime) / (overlapEntry - overlapStartTime)));
            }
            --i;
            bits += 8 * (transferSize + initiatorType) / (entry.duration / 1000);
            count++;
            if (10 < count)
              break;
          }
        }
        if (0 < count)
          return bits / count / 1e6;
      }
      return navigator.connection && (count = navigator.connection.downlink, typeof count === "number") ? count : 5;
    }
    function getOwnerDocumentFromRootContainer(rootContainerElement) {
      return rootContainerElement.nodeType === 9 ? rootContainerElement : rootContainerElement.ownerDocument;
    }
    function getOwnHostContext(namespaceURI) {
      switch (namespaceURI) {
        case SVG_NAMESPACE:
          return HostContextNamespaceSvg;
        case MATH_NAMESPACE:
          return HostContextNamespaceMath;
        default:
          return HostContextNamespaceNone;
      }
    }
    function getChildHostContextProd(parentNamespace, type) {
      if (parentNamespace === HostContextNamespaceNone)
        switch (type) {
          case "svg":
            return HostContextNamespaceSvg;
          case "math":
            return HostContextNamespaceMath;
          default:
            return HostContextNamespaceNone;
        }
      return parentNamespace === HostContextNamespaceSvg && type === "foreignObject" ? HostContextNamespaceNone : parentNamespace;
    }
    function shouldSetTextContent(type, props) {
      return type === "textarea" || type === "noscript" || typeof props.children === "string" || typeof props.children === "number" || typeof props.children === "bigint" || typeof props.dangerouslySetInnerHTML === "object" && props.dangerouslySetInnerHTML !== null && props.dangerouslySetInnerHTML.__html != null;
    }
    function shouldAttemptEagerTransition() {
      var event = window.event;
      if (event && event.type === "popstate") {
        if (event === currentPopstateTransitionEvent)
          return false;
        currentPopstateTransitionEvent = event;
        return true;
      }
      currentPopstateTransitionEvent = null;
      return false;
    }
    function resolveEventType() {
      var event = window.event;
      return event && event !== schedulerEvent ? event.type : null;
    }
    function resolveEventTimeStamp() {
      var event = window.event;
      return event && event !== schedulerEvent ? event.timeStamp : -1.1;
    }
    function handleErrorInNextTick(error) {
      setTimeout(function() {
        throw error;
      });
    }
    function commitMount(domElement, type, newProps) {
      switch (type) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          newProps.autoFocus && domElement.focus();
          break;
        case "img":
          newProps.src ? domElement.src = newProps.src : newProps.srcSet && (domElement.srcset = newProps.srcSet);
      }
    }
    function commitHydratedInstance() {}
    function commitUpdate(domElement, type, oldProps, newProps) {
      updateProperties(domElement, type, oldProps, newProps);
      domElement[internalPropsKey] = newProps;
    }
    function resetTextContent(domElement) {
      setTextContent(domElement, "");
    }
    function commitTextUpdate(textInstance, oldText, newText) {
      textInstance.nodeValue = newText;
    }
    function warnForReactChildrenConflict(container) {
      if (!container.__reactWarnedAboutChildrenConflict) {
        var props = container[internalPropsKey] || null;
        if (props !== null) {
          var fiber = getInstanceFromNode(container);
          fiber !== null && (typeof props.children === "string" || typeof props.children === "number" ? (container.__reactWarnedAboutChildrenConflict = true, runWithFiberInDEV(fiber, function() {
            console.error('Cannot use a ref on a React element as a container to `createRoot` or `createPortal` if that element also sets "children" text content using React. It should be a leaf with no children. Otherwise it\'s ambiguous which children should be used.');
          })) : props.dangerouslySetInnerHTML != null && (container.__reactWarnedAboutChildrenConflict = true, runWithFiberInDEV(fiber, function() {
            console.error('Cannot use a ref on a React element as a container to `createRoot` or `createPortal` if that element also sets "dangerouslySetInnerHTML" using React. It should be a leaf with no children. Otherwise it\'s ambiguous which children should be used.');
          })));
        }
      }
    }
    function isSingletonScope(type) {
      return type === "head";
    }
    function removeChild(parentInstance, child) {
      parentInstance.removeChild(child);
    }
    function removeChildFromContainer(container, child) {
      (container.nodeType === 9 ? container.body : container.nodeName === "HTML" ? container.ownerDocument.body : container).removeChild(child);
    }
    function clearHydrationBoundary(parentInstance, hydrationInstance) {
      var node = hydrationInstance, depth = 0;
      do {
        var nextNode = node.nextSibling;
        parentInstance.removeChild(node);
        if (nextNode && nextNode.nodeType === 8)
          if (node = nextNode.data, node === SUSPENSE_END_DATA || node === ACTIVITY_END_DATA) {
            if (depth === 0) {
              parentInstance.removeChild(nextNode);
              retryIfBlockedOn(hydrationInstance);
              return;
            }
            depth--;
          } else if (node === SUSPENSE_START_DATA || node === SUSPENSE_PENDING_START_DATA || node === SUSPENSE_QUEUED_START_DATA || node === SUSPENSE_FALLBACK_START_DATA || node === ACTIVITY_START_DATA)
            depth++;
          else if (node === PREAMBLE_CONTRIBUTION_HTML)
            releaseSingletonInstance(parentInstance.ownerDocument.documentElement);
          else if (node === PREAMBLE_CONTRIBUTION_HEAD) {
            node = parentInstance.ownerDocument.head;
            releaseSingletonInstance(node);
            for (var node$jscomp$0 = node.firstChild;node$jscomp$0; ) {
              var { nextSibling: nextNode$jscomp$0, nodeName } = node$jscomp$0;
              node$jscomp$0[internalHoistableMarker] || nodeName === "SCRIPT" || nodeName === "STYLE" || nodeName === "LINK" && node$jscomp$0.rel.toLowerCase() === "stylesheet" || node.removeChild(node$jscomp$0);
              node$jscomp$0 = nextNode$jscomp$0;
            }
          } else
            node === PREAMBLE_CONTRIBUTION_BODY && releaseSingletonInstance(parentInstance.ownerDocument.body);
        node = nextNode;
      } while (node);
      retryIfBlockedOn(hydrationInstance);
    }
    function hideOrUnhideDehydratedBoundary(suspenseInstance, isHidden) {
      var node = suspenseInstance;
      suspenseInstance = 0;
      do {
        var nextNode = node.nextSibling;
        node.nodeType === 1 ? isHidden ? (node._stashedDisplay = node.style.display, node.style.display = "none") : (node.style.display = node._stashedDisplay || "", node.getAttribute("style") === "" && node.removeAttribute("style")) : node.nodeType === 3 && (isHidden ? (node._stashedText = node.nodeValue, node.nodeValue = "") : node.nodeValue = node._stashedText || "");
        if (nextNode && nextNode.nodeType === 8)
          if (node = nextNode.data, node === SUSPENSE_END_DATA)
            if (suspenseInstance === 0)
              break;
            else
              suspenseInstance--;
          else
            node !== SUSPENSE_START_DATA && node !== SUSPENSE_PENDING_START_DATA && node !== SUSPENSE_QUEUED_START_DATA && node !== SUSPENSE_FALLBACK_START_DATA || suspenseInstance++;
        node = nextNode;
      } while (node);
    }
    function hideDehydratedBoundary(suspenseInstance) {
      hideOrUnhideDehydratedBoundary(suspenseInstance, true);
    }
    function hideInstance(instance) {
      instance = instance.style;
      typeof instance.setProperty === "function" ? instance.setProperty("display", "none", "important") : instance.display = "none";
    }
    function hideTextInstance(textInstance) {
      textInstance.nodeValue = "";
    }
    function unhideDehydratedBoundary(dehydratedInstance) {
      hideOrUnhideDehydratedBoundary(dehydratedInstance, false);
    }
    function unhideInstance(instance, props) {
      props = props[STYLE];
      props = props !== undefined && props !== null && props.hasOwnProperty("display") ? props.display : null;
      instance.style.display = props == null || typeof props === "boolean" ? "" : ("" + props).trim();
    }
    function unhideTextInstance(textInstance, text) {
      textInstance.nodeValue = text;
    }
    function clearContainerSparingly(container) {
      var nextNode = container.firstChild;
      nextNode && nextNode.nodeType === 10 && (nextNode = nextNode.nextSibling);
      for (;nextNode; ) {
        var node = nextNode;
        nextNode = nextNode.nextSibling;
        switch (node.nodeName) {
          case "HTML":
          case "HEAD":
          case "BODY":
            clearContainerSparingly(node);
            detachDeletedInstance(node);
            continue;
          case "SCRIPT":
          case "STYLE":
            continue;
          case "LINK":
            if (node.rel.toLowerCase() === "stylesheet")
              continue;
        }
        container.removeChild(node);
      }
    }
    function canHydrateInstance(instance, type, props, inRootOrSingleton) {
      for (;instance.nodeType === 1; ) {
        var anyProps = props;
        if (instance.nodeName.toLowerCase() !== type.toLowerCase()) {
          if (!inRootOrSingleton && (instance.nodeName !== "INPUT" || instance.type !== "hidden"))
            break;
        } else if (!inRootOrSingleton)
          if (type === "input" && instance.type === "hidden") {
            checkAttributeStringCoercion(anyProps.name, "name");
            var name = anyProps.name == null ? null : "" + anyProps.name;
            if (anyProps.type === "hidden" && instance.getAttribute("name") === name)
              return instance;
          } else
            return instance;
        else if (!instance[internalHoistableMarker])
          switch (type) {
            case "meta":
              if (!instance.hasAttribute("itemprop"))
                break;
              return instance;
            case "link":
              name = instance.getAttribute("rel");
              if (name === "stylesheet" && instance.hasAttribute("data-precedence"))
                break;
              else if (name !== anyProps.rel || instance.getAttribute("href") !== (anyProps.href == null || anyProps.href === "" ? null : anyProps.href) || instance.getAttribute("crossorigin") !== (anyProps.crossOrigin == null ? null : anyProps.crossOrigin) || instance.getAttribute("title") !== (anyProps.title == null ? null : anyProps.title))
                break;
              return instance;
            case "style":
              if (instance.hasAttribute("data-precedence"))
                break;
              return instance;
            case "script":
              name = instance.getAttribute("src");
              if ((name !== (anyProps.src == null ? null : anyProps.src) || instance.getAttribute("type") !== (anyProps.type == null ? null : anyProps.type) || instance.getAttribute("crossorigin") !== (anyProps.crossOrigin == null ? null : anyProps.crossOrigin)) && name && instance.hasAttribute("async") && !instance.hasAttribute("itemprop"))
                break;
              return instance;
            default:
              return instance;
          }
        instance = getNextHydratable(instance.nextSibling);
        if (instance === null)
          break;
      }
      return null;
    }
    function canHydrateTextInstance(instance, text, inRootOrSingleton) {
      if (text === "")
        return null;
      for (;instance.nodeType !== 3; ) {
        if ((instance.nodeType !== 1 || instance.nodeName !== "INPUT" || instance.type !== "hidden") && !inRootOrSingleton)
          return null;
        instance = getNextHydratable(instance.nextSibling);
        if (instance === null)
          return null;
      }
      return instance;
    }
    function canHydrateHydrationBoundary(instance, inRootOrSingleton) {
      for (;instance.nodeType !== 8; ) {
        if ((instance.nodeType !== 1 || instance.nodeName !== "INPUT" || instance.type !== "hidden") && !inRootOrSingleton)
          return null;
        instance = getNextHydratable(instance.nextSibling);
        if (instance === null)
          return null;
      }
      return instance;
    }
    function isSuspenseInstancePending(instance) {
      return instance.data === SUSPENSE_PENDING_START_DATA || instance.data === SUSPENSE_QUEUED_START_DATA;
    }
    function isSuspenseInstanceFallback(instance) {
      return instance.data === SUSPENSE_FALLBACK_START_DATA || instance.data === SUSPENSE_PENDING_START_DATA && instance.ownerDocument.readyState !== DOCUMENT_READY_STATE_LOADING;
    }
    function registerSuspenseInstanceRetry(instance, callback) {
      var ownerDocument = instance.ownerDocument;
      if (instance.data === SUSPENSE_QUEUED_START_DATA)
        instance._reactRetry = callback;
      else if (instance.data !== SUSPENSE_PENDING_START_DATA || ownerDocument.readyState !== DOCUMENT_READY_STATE_LOADING)
        callback();
      else {
        var listener = function() {
          callback();
          ownerDocument.removeEventListener("DOMContentLoaded", listener);
        };
        ownerDocument.addEventListener("DOMContentLoaded", listener);
        instance._reactRetry = listener;
      }
    }
    function getNextHydratable(node) {
      for (;node != null; node = node.nextSibling) {
        var nodeType = node.nodeType;
        if (nodeType === 1 || nodeType === 3)
          break;
        if (nodeType === 8) {
          nodeType = node.data;
          if (nodeType === SUSPENSE_START_DATA || nodeType === SUSPENSE_FALLBACK_START_DATA || nodeType === SUSPENSE_PENDING_START_DATA || nodeType === SUSPENSE_QUEUED_START_DATA || nodeType === ACTIVITY_START_DATA || nodeType === FORM_STATE_IS_MATCHING || nodeType === FORM_STATE_IS_NOT_MATCHING)
            break;
          if (nodeType === SUSPENSE_END_DATA || nodeType === ACTIVITY_END_DATA)
            return null;
        }
      }
      return node;
    }
    function describeHydratableInstanceForDevWarnings(instance) {
      if (instance.nodeType === 1) {
        for (var JSCompiler_temp_const = instance.nodeName.toLowerCase(), serverDifferences = {}, attributes = instance.attributes, i = 0;i < attributes.length; i++) {
          var attr = attributes[i];
          serverDifferences[getPropNameFromAttributeName(attr.name)] = attr.name.toLowerCase() === "style" ? getStylesObjectFromElement(instance) : attr.value;
        }
        return { type: JSCompiler_temp_const, props: serverDifferences };
      }
      return instance.nodeType === 8 ? instance.data === ACTIVITY_START_DATA ? { type: "Activity", props: {} } : { type: "Suspense", props: {} } : instance.nodeValue;
    }
    function diffHydratedTextForDevWarnings(textInstance, text, parentProps) {
      return parentProps === null || parentProps[SUPPRESS_HYDRATION_WARNING] !== true ? (textInstance.nodeValue === text ? textInstance = null : (text = normalizeMarkupForTextOrAttribute(text), textInstance = normalizeMarkupForTextOrAttribute(textInstance.nodeValue) === text ? null : textInstance.nodeValue), textInstance) : null;
    }
    function getNextHydratableInstanceAfterHydrationBoundary(hydrationInstance) {
      hydrationInstance = hydrationInstance.nextSibling;
      for (var depth = 0;hydrationInstance; ) {
        if (hydrationInstance.nodeType === 8) {
          var data2 = hydrationInstance.data;
          if (data2 === SUSPENSE_END_DATA || data2 === ACTIVITY_END_DATA) {
            if (depth === 0)
              return getNextHydratable(hydrationInstance.nextSibling);
            depth--;
          } else
            data2 !== SUSPENSE_START_DATA && data2 !== SUSPENSE_FALLBACK_START_DATA && data2 !== SUSPENSE_PENDING_START_DATA && data2 !== SUSPENSE_QUEUED_START_DATA && data2 !== ACTIVITY_START_DATA || depth++;
        }
        hydrationInstance = hydrationInstance.nextSibling;
      }
      return null;
    }
    function getParentHydrationBoundary(targetInstance) {
      targetInstance = targetInstance.previousSibling;
      for (var depth = 0;targetInstance; ) {
        if (targetInstance.nodeType === 8) {
          var data2 = targetInstance.data;
          if (data2 === SUSPENSE_START_DATA || data2 === SUSPENSE_FALLBACK_START_DATA || data2 === SUSPENSE_PENDING_START_DATA || data2 === SUSPENSE_QUEUED_START_DATA || data2 === ACTIVITY_START_DATA) {
            if (depth === 0)
              return targetInstance;
            depth--;
          } else
            data2 !== SUSPENSE_END_DATA && data2 !== ACTIVITY_END_DATA || depth++;
        }
        targetInstance = targetInstance.previousSibling;
      }
      return null;
    }
    function commitHydratedContainer(container) {
      retryIfBlockedOn(container);
    }
    function commitHydratedActivityInstance(activityInstance) {
      retryIfBlockedOn(activityInstance);
    }
    function commitHydratedSuspenseInstance(suspenseInstance) {
      retryIfBlockedOn(suspenseInstance);
    }
    function resolveSingletonInstance(type, props, rootContainerInstance, hostContext, validateDOMNestingDev) {
      validateDOMNestingDev && validateDOMNesting(type, hostContext.ancestorInfo);
      props = getOwnerDocumentFromRootContainer(rootContainerInstance);
      switch (type) {
        case "html":
          type = props.documentElement;
          if (!type)
            throw Error("React expected an <html> element (document.documentElement) to exist in the Document but one was not found. React never removes the documentElement for any Document it renders into so the cause is likely in some other script running on this page.");
          return type;
        case "head":
          type = props.head;
          if (!type)
            throw Error("React expected a <head> element (document.head) to exist in the Document but one was not found. React never removes the head for any Document it renders into so the cause is likely in some other script running on this page.");
          return type;
        case "body":
          type = props.body;
          if (!type)
            throw Error("React expected a <body> element (document.body) to exist in the Document but one was not found. React never removes the body for any Document it renders into so the cause is likely in some other script running on this page.");
          return type;
        default:
          throw Error("resolveSingletonInstance was called with an element type that is not supported. This is a bug in React.");
      }
    }
    function acquireSingletonInstance(type, props, instance, internalInstanceHandle) {
      if (!instance[internalContainerInstanceKey] && getInstanceFromNode(instance)) {
        var tagName = instance.tagName.toLowerCase();
        console.error("You are mounting a new %s component when a previous one has not first unmounted. It is an error to render more than one %s component at a time and attributes and children of these components will likely fail in unpredictable ways. Please only render a single instance of <%s> and if you need to mount a new one, ensure any previous ones have unmounted first.", tagName, tagName, tagName);
      }
      switch (type) {
        case "html":
        case "head":
        case "body":
          break;
        default:
          console.error("acquireSingletonInstance was called with an element type that is not supported. This is a bug in React.");
      }
      for (tagName = instance.attributes;tagName.length; )
        instance.removeAttributeNode(tagName[0]);
      setInitialProperties(instance, type, props);
      instance[internalInstanceKey] = internalInstanceHandle;
      instance[internalPropsKey] = props;
    }
    function releaseSingletonInstance(instance) {
      for (var attributes = instance.attributes;attributes.length; )
        instance.removeAttributeNode(attributes[0]);
      detachDeletedInstance(instance);
    }
    function getHoistableRoot(container) {
      return typeof container.getRootNode === "function" ? container.getRootNode() : container.nodeType === 9 ? container : container.ownerDocument;
    }
    function preconnectAs(rel, href, crossOrigin) {
      var ownerDocument = globalDocument;
      if (ownerDocument && typeof href === "string" && href) {
        var limitedEscapedHref = escapeSelectorAttributeValueInsideDoubleQuotes(href);
        limitedEscapedHref = 'link[rel="' + rel + '"][href="' + limitedEscapedHref + '"]';
        typeof crossOrigin === "string" && (limitedEscapedHref += '[crossorigin="' + crossOrigin + '"]');
        preconnectsSet.has(limitedEscapedHref) || (preconnectsSet.add(limitedEscapedHref), rel = { rel, crossOrigin, href }, ownerDocument.querySelector(limitedEscapedHref) === null && (href = ownerDocument.createElement("link"), setInitialProperties(href, "link", rel), markNodeAsHoistable(href), ownerDocument.head.appendChild(href)));
      }
    }
    function getResource(type, currentProps, pendingProps, currentResource) {
      var resourceRoot = (resourceRoot = rootInstanceStackCursor.current) ? getHoistableRoot(resourceRoot) : null;
      if (!resourceRoot)
        throw Error('"resourceRoot" was expected to exist. This is a bug in React.');
      switch (type) {
        case "meta":
        case "title":
          return null;
        case "style":
          return typeof pendingProps.precedence === "string" && typeof pendingProps.href === "string" ? (pendingProps = getStyleKey(pendingProps.href), currentProps = getResourcesFromRoot(resourceRoot).hoistableStyles, currentResource = currentProps.get(pendingProps), currentResource || (currentResource = {
            type: "style",
            instance: null,
            count: 0,
            state: null
          }, currentProps.set(pendingProps, currentResource)), currentResource) : { type: "void", instance: null, count: 0, state: null };
        case "link":
          if (pendingProps.rel === "stylesheet" && typeof pendingProps.href === "string" && typeof pendingProps.precedence === "string") {
            type = getStyleKey(pendingProps.href);
            var _styles = getResourcesFromRoot(resourceRoot).hoistableStyles, _resource = _styles.get(type);
            if (!_resource && (resourceRoot = resourceRoot.ownerDocument || resourceRoot, _resource = {
              type: "stylesheet",
              instance: null,
              count: 0,
              state: { loading: NotLoaded, preload: null }
            }, _styles.set(type, _resource), (_styles = resourceRoot.querySelector(getStylesheetSelectorFromKey(type))) && !_styles._p && (_resource.instance = _styles, _resource.state.loading = Loaded | Inserted), !preloadPropsMap.has(type))) {
              var preloadProps = {
                rel: "preload",
                as: "style",
                href: pendingProps.href,
                crossOrigin: pendingProps.crossOrigin,
                integrity: pendingProps.integrity,
                media: pendingProps.media,
                hrefLang: pendingProps.hrefLang,
                referrerPolicy: pendingProps.referrerPolicy
              };
              preloadPropsMap.set(type, preloadProps);
              _styles || preloadStylesheet(resourceRoot, type, preloadProps, _resource.state);
            }
            if (currentProps && currentResource === null)
              throw pendingProps = `

  - ` + describeLinkForResourceErrorDEV(currentProps) + `
  + ` + describeLinkForResourceErrorDEV(pendingProps), Error("Expected <link> not to update to be updated to a stylesheet with precedence. Check the `rel`, `href`, and `precedence` props of this component. Alternatively, check whether two different <link> components render in the same slot or share the same key." + pendingProps);
            return _resource;
          }
          if (currentProps && currentResource !== null)
            throw pendingProps = `

  - ` + describeLinkForResourceErrorDEV(currentProps) + `
  + ` + describeLinkForResourceErrorDEV(pendingProps), Error("Expected stylesheet with precedence to not be updated to a different kind of <link>. Check the `rel`, `href`, and `precedence` props of this component. Alternatively, check whether two different <link> components render in the same slot or share the same key." + pendingProps);
          return null;
        case "script":
          return currentProps = pendingProps.async, pendingProps = pendingProps.src, typeof pendingProps === "string" && currentProps && typeof currentProps !== "function" && typeof currentProps !== "symbol" ? (pendingProps = getScriptKey(pendingProps), currentProps = getResourcesFromRoot(resourceRoot).hoistableScripts, currentResource = currentProps.get(pendingProps), currentResource || (currentResource = {
            type: "script",
            instance: null,
            count: 0,
            state: null
          }, currentProps.set(pendingProps, currentResource)), currentResource) : { type: "void", instance: null, count: 0, state: null };
        default:
          throw Error('getResource encountered a type it did not expect: "' + type + '". this is a bug in React.');
      }
    }
    function describeLinkForResourceErrorDEV(props) {
      var describedProps = 0, description = "<link";
      typeof props.rel === "string" ? (describedProps++, description += ' rel="' + props.rel + '"') : hasOwnProperty.call(props, "rel") && (describedProps++, description += ' rel="' + (props.rel === null ? "null" : "invalid type " + typeof props.rel) + '"');
      typeof props.href === "string" ? (describedProps++, description += ' href="' + props.href + '"') : hasOwnProperty.call(props, "href") && (describedProps++, description += ' href="' + (props.href === null ? "null" : "invalid type " + typeof props.href) + '"');
      typeof props.precedence === "string" ? (describedProps++, description += ' precedence="' + props.precedence + '"') : hasOwnProperty.call(props, "precedence") && (describedProps++, description += " precedence={" + (props.precedence === null ? "null" : "invalid type " + typeof props.precedence) + "}");
      Object.getOwnPropertyNames(props).length > describedProps && (description += " ...");
      return description + " />";
    }
    function getStyleKey(href) {
      return 'href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"';
    }
    function getStylesheetSelectorFromKey(key) {
      return 'link[rel="stylesheet"][' + key + "]";
    }
    function stylesheetPropsFromRawProps(rawProps) {
      return assign({}, rawProps, {
        "data-precedence": rawProps.precedence,
        precedence: null
      });
    }
    function preloadStylesheet(ownerDocument, key, preloadProps, state) {
      ownerDocument.querySelector('link[rel="preload"][as="style"][' + key + "]") ? state.loading = Loaded : (key = ownerDocument.createElement("link"), state.preload = key, key.addEventListener("load", function() {
        return state.loading |= Loaded;
      }), key.addEventListener("error", function() {
        return state.loading |= Errored;
      }), setInitialProperties(key, "link", preloadProps), markNodeAsHoistable(key), ownerDocument.head.appendChild(key));
    }
    function getScriptKey(src) {
      return '[src="' + escapeSelectorAttributeValueInsideDoubleQuotes(src) + '"]';
    }
    function getScriptSelectorFromKey(key) {
      return "script[async]" + key;
    }
    function acquireResource(hoistableRoot, resource, props) {
      resource.count++;
      if (resource.instance === null)
        switch (resource.type) {
          case "style":
            var instance = hoistableRoot.querySelector('style[data-href~="' + escapeSelectorAttributeValueInsideDoubleQuotes(props.href) + '"]');
            if (instance)
              return resource.instance = instance, markNodeAsHoistable(instance), instance;
            var styleProps = assign({}, props, {
              "data-href": props.href,
              "data-precedence": props.precedence,
              href: null,
              precedence: null
            });
            instance = (hoistableRoot.ownerDocument || hoistableRoot).createElement("style");
            markNodeAsHoistable(instance);
            setInitialProperties(instance, "style", styleProps);
            insertStylesheet(instance, props.precedence, hoistableRoot);
            return resource.instance = instance;
          case "stylesheet":
            styleProps = getStyleKey(props.href);
            var _instance = hoistableRoot.querySelector(getStylesheetSelectorFromKey(styleProps));
            if (_instance)
              return resource.state.loading |= Inserted, resource.instance = _instance, markNodeAsHoistable(_instance), _instance;
            instance = stylesheetPropsFromRawProps(props);
            (styleProps = preloadPropsMap.get(styleProps)) && adoptPreloadPropsForStylesheet(instance, styleProps);
            _instance = (hoistableRoot.ownerDocument || hoistableRoot).createElement("link");
            markNodeAsHoistable(_instance);
            var linkInstance = _instance;
            linkInstance._p = new Promise(function(resolve, reject) {
              linkInstance.onload = resolve;
              linkInstance.onerror = reject;
            });
            setInitialProperties(_instance, "link", instance);
            resource.state.loading |= Inserted;
            insertStylesheet(_instance, props.precedence, hoistableRoot);
            return resource.instance = _instance;
          case "script":
            _instance = getScriptKey(props.src);
            if (styleProps = hoistableRoot.querySelector(getScriptSelectorFromKey(_instance)))
              return resource.instance = styleProps, markNodeAsHoistable(styleProps), styleProps;
            instance = props;
            if (styleProps = preloadPropsMap.get(_instance))
              instance = assign({}, props), adoptPreloadPropsForScript(instance, styleProps);
            hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
            styleProps = hoistableRoot.createElement("script");
            markNodeAsHoistable(styleProps);
            setInitialProperties(styleProps, "link", instance);
            hoistableRoot.head.appendChild(styleProps);
            return resource.instance = styleProps;
          case "void":
            return null;
          default:
            throw Error('acquireResource encountered a resource type it did not expect: "' + resource.type + '". this is a bug in React.');
        }
      else
        resource.type === "stylesheet" && (resource.state.loading & Inserted) === NotLoaded && (instance = resource.instance, resource.state.loading |= Inserted, insertStylesheet(instance, props.precedence, hoistableRoot));
      return resource.instance;
    }
    function insertStylesheet(instance, precedence, root2) {
      for (var nodes = root2.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'), last = nodes.length ? nodes[nodes.length - 1] : null, prior = last, i = 0;i < nodes.length; i++) {
        var node = nodes[i];
        if (node.dataset.precedence === precedence)
          prior = node;
        else if (prior !== last)
          break;
      }
      prior ? prior.parentNode.insertBefore(instance, prior.nextSibling) : (precedence = root2.nodeType === 9 ? root2.head : root2, precedence.insertBefore(instance, precedence.firstChild));
    }
    function adoptPreloadPropsForStylesheet(stylesheetProps, preloadProps) {
      stylesheetProps.crossOrigin == null && (stylesheetProps.crossOrigin = preloadProps.crossOrigin);
      stylesheetProps.referrerPolicy == null && (stylesheetProps.referrerPolicy = preloadProps.referrerPolicy);
      stylesheetProps.title == null && (stylesheetProps.title = preloadProps.title);
    }
    function adoptPreloadPropsForScript(scriptProps, preloadProps) {
      scriptProps.crossOrigin == null && (scriptProps.crossOrigin = preloadProps.crossOrigin);
      scriptProps.referrerPolicy == null && (scriptProps.referrerPolicy = preloadProps.referrerPolicy);
      scriptProps.integrity == null && (scriptProps.integrity = preloadProps.integrity);
    }
    function getHydratableHoistableCache(type, keyAttribute, ownerDocument) {
      if (tagCaches === null) {
        var cache2 = new Map;
        var caches = tagCaches = new Map;
        caches.set(ownerDocument, cache2);
      } else
        caches = tagCaches, cache2 = caches.get(ownerDocument), cache2 || (cache2 = new Map, caches.set(ownerDocument, cache2));
      if (cache2.has(type))
        return cache2;
      cache2.set(type, null);
      ownerDocument = ownerDocument.getElementsByTagName(type);
      for (caches = 0;caches < ownerDocument.length; caches++) {
        var node = ownerDocument[caches];
        if (!(node[internalHoistableMarker] || node[internalInstanceKey] || type === "link" && node.getAttribute("rel") === "stylesheet") && node.namespaceURI !== SVG_NAMESPACE) {
          var nodeKey = node.getAttribute(keyAttribute) || "";
          nodeKey = type + nodeKey;
          var existing = cache2.get(nodeKey);
          existing ? existing.push(node) : cache2.set(nodeKey, [node]);
        }
      }
      return cache2;
    }
    function mountHoistable(hoistableRoot, type, instance) {
      hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
      hoistableRoot.head.insertBefore(instance, type === "title" ? hoistableRoot.querySelector("head > title") : null);
    }
    function isHostHoistableType(type, props, hostContext) {
      var outsideHostContainerContext = !hostContext.ancestorInfo.containerTagInScope;
      if (hostContext.context === HostContextNamespaceSvg || props.itemProp != null)
        return !outsideHostContainerContext || props.itemProp == null || type !== "meta" && type !== "title" && type !== "style" && type !== "link" && type !== "script" || console.error("Cannot render a <%s> outside the main document if it has an `itemProp` prop. `itemProp` suggests the tag belongs to an `itemScope` which can appear anywhere in the DOM. If you were intending for React to hoist this <%s> remove the `itemProp` prop. Otherwise, try moving this tag into the <head> or <body> of the Document.", type, type), false;
      switch (type) {
        case "meta":
        case "title":
          return true;
        case "style":
          if (typeof props.precedence !== "string" || typeof props.href !== "string" || props.href === "") {
            outsideHostContainerContext && console.error('Cannot render a <style> outside the main document without knowing its precedence and a unique href key. React can hoist and deduplicate <style> tags if you provide a `precedence` prop along with an `href` prop that does not conflict with the `href` values used in any other hoisted <style> or <link rel="stylesheet" ...> tags.  Note that hoisting <style> tags is considered an advanced feature that most will not use directly. Consider moving the <style> tag to the <head> or consider adding a `precedence="default"` and `href="some unique resource identifier"`.');
            break;
          }
          return true;
        case "link":
          if (typeof props.rel !== "string" || typeof props.href !== "string" || props.href === "" || props.onLoad || props.onError) {
            if (props.rel === "stylesheet" && typeof props.precedence === "string") {
              type = props.href;
              var { onError, disabled } = props;
              hostContext = [];
              props.onLoad && hostContext.push("`onLoad`");
              onError && hostContext.push("`onError`");
              disabled != null && hostContext.push("`disabled`");
              onError = propNamesListJoin(hostContext, "and");
              onError += hostContext.length === 1 ? " prop" : " props";
              disabled = hostContext.length === 1 ? "an " + onError : "the " + onError;
              hostContext.length && console.error('React encountered a <link rel="stylesheet" href="%s" ... /> with a `precedence` prop that also included %s. The presence of loading and error handlers indicates an intent to manage the stylesheet loading state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the %s, otherwise remove the `precedence` prop.', type, disabled, onError);
            }
            outsideHostContainerContext && (typeof props.rel !== "string" || typeof props.href !== "string" || props.href === "" ? console.error("Cannot render a <link> outside the main document without a `rel` and `href` prop. Try adding a `rel` and/or `href` prop to this <link> or moving the link into the <head> tag") : (props.onError || props.onLoad) && console.error("Cannot render a <link> with onLoad or onError listeners outside the main document. Try removing onLoad={...} and onError={...} or moving it into the root <head> tag or somewhere in the <body>."));
            break;
          }
          switch (props.rel) {
            case "stylesheet":
              return type = props.precedence, props = props.disabled, typeof type !== "string" && outsideHostContainerContext && console.error('Cannot render a <link rel="stylesheet" /> outside the main document without knowing its precedence. Consider adding precedence="default" or moving it into the root <head> tag.'), typeof type === "string" && props == null;
            default:
              return true;
          }
        case "script":
          type = props.async && typeof props.async !== "function" && typeof props.async !== "symbol";
          if (!type || props.onLoad || props.onError || !props.src || typeof props.src !== "string") {
            outsideHostContainerContext && (type ? props.onLoad || props.onError ? console.error("Cannot render a <script> with onLoad or onError listeners outside the main document. Try removing onLoad={...} and onError={...} or moving it into the root <head> tag or somewhere in the <body>.") : console.error("Cannot render a <script> outside the main document without `async={true}` and a non-empty `src` prop. Ensure there is a valid `src` and either make the script async or move it into the root <head> tag or somewhere in the <body>.") : console.error('Cannot render a sync or defer <script> outside the main document without knowing its order. Try adding async="" or moving it into the root <head> tag.'));
            break;
          }
          return true;
        case "noscript":
        case "template":
          outsideHostContainerContext && console.error("Cannot render <%s> outside the main document. Try moving it into the root <head> tag.", type);
      }
      return false;
    }
    function preloadResource(resource) {
      return resource.type === "stylesheet" && (resource.state.loading & Settled) === NotLoaded ? false : true;
    }
    function suspendResource(state, hoistableRoot, resource, props) {
      if (resource.type === "stylesheet" && (typeof props.media !== "string" || matchMedia(props.media).matches !== false) && (resource.state.loading & Inserted) === NotLoaded) {
        if (resource.instance === null) {
          var key = getStyleKey(props.href), instance = hoistableRoot.querySelector(getStylesheetSelectorFromKey(key));
          if (instance) {
            hoistableRoot = instance._p;
            hoistableRoot !== null && typeof hoistableRoot === "object" && typeof hoistableRoot.then === "function" && (state.count++, state = onUnsuspend.bind(state), hoistableRoot.then(state, state));
            resource.state.loading |= Inserted;
            resource.instance = instance;
            markNodeAsHoistable(instance);
            return;
          }
          instance = hoistableRoot.ownerDocument || hoistableRoot;
          props = stylesheetPropsFromRawProps(props);
          (key = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(props, key);
          instance = instance.createElement("link");
          markNodeAsHoistable(instance);
          var linkInstance = instance;
          linkInstance._p = new Promise(function(resolve, reject) {
            linkInstance.onload = resolve;
            linkInstance.onerror = reject;
          });
          setInitialProperties(instance, "link", props);
          resource.instance = instance;
        }
        state.stylesheets === null && (state.stylesheets = new Map);
        state.stylesheets.set(resource, hoistableRoot);
        (hoistableRoot = resource.state.preload) && (resource.state.loading & Settled) === NotLoaded && (state.count++, resource = onUnsuspend.bind(state), hoistableRoot.addEventListener("load", resource), hoistableRoot.addEventListener("error", resource));
      }
    }
    function waitForCommitToBeReady(state, timeoutOffset) {
      state.stylesheets && state.count === 0 && insertSuspendedStylesheets(state, state.stylesheets);
      return 0 < state.count || 0 < state.imgCount ? function(commit) {
        var stylesheetTimer = setTimeout(function() {
          state.stylesheets && insertSuspendedStylesheets(state, state.stylesheets);
          if (state.unsuspend) {
            var unsuspend = state.unsuspend;
            state.unsuspend = null;
            unsuspend();
          }
        }, SUSPENSEY_STYLESHEET_TIMEOUT + timeoutOffset);
        0 < state.imgBytes && estimatedBytesWithinLimit === 0 && (estimatedBytesWithinLimit = 125 * estimateBandwidth() * SUSPENSEY_IMAGE_TIME_ESTIMATE);
        var imgTimer = setTimeout(function() {
          state.waitingForImages = false;
          if (state.count === 0 && (state.stylesheets && insertSuspendedStylesheets(state, state.stylesheets), state.unsuspend)) {
            var unsuspend = state.unsuspend;
            state.unsuspend = null;
            unsuspend();
          }
        }, (state.imgBytes > estimatedBytesWithinLimit ? 50 : SUSPENSEY_IMAGE_TIMEOUT) + timeoutOffset);
        state.unsuspend = commit;
        return function() {
          state.unsuspend = null;
          clearTimeout(stylesheetTimer);
          clearTimeout(imgTimer);
        };
      } : null;
    }
    function onUnsuspend() {
      this.count--;
      if (this.count === 0 && (this.imgCount === 0 || !this.waitingForImages)) {
        if (this.stylesheets)
          insertSuspendedStylesheets(this, this.stylesheets);
        else if (this.unsuspend) {
          var unsuspend = this.unsuspend;
          this.unsuspend = null;
          unsuspend();
        }
      }
    }
    function insertSuspendedStylesheets(state, resources) {
      state.stylesheets = null;
      state.unsuspend !== null && (state.count++, precedencesByRoot = new Map, resources.forEach(insertStylesheetIntoRoot, state), precedencesByRoot = null, onUnsuspend.call(state));
    }
    function insertStylesheetIntoRoot(root2, resource) {
      if (!(resource.state.loading & Inserted)) {
        var precedences = precedencesByRoot.get(root2);
        if (precedences)
          var last = precedences.get(LAST_PRECEDENCE);
        else {
          precedences = new Map;
          precedencesByRoot.set(root2, precedences);
          for (var nodes = root2.querySelectorAll("link[data-precedence],style[data-precedence]"), i = 0;i < nodes.length; i++) {
            var node = nodes[i];
            if (node.nodeName === "LINK" || node.getAttribute("media") !== "not all")
              precedences.set(node.dataset.precedence, node), last = node;
          }
          last && precedences.set(LAST_PRECEDENCE, last);
        }
        nodes = resource.instance;
        node = nodes.getAttribute("data-precedence");
        i = precedences.get(node) || last;
        i === last && precedences.set(LAST_PRECEDENCE, nodes);
        precedences.set(node, nodes);
        this.count++;
        last = onUnsuspend.bind(this);
        nodes.addEventListener("load", last);
        nodes.addEventListener("error", last);
        i ? i.parentNode.insertBefore(nodes, i.nextSibling) : (root2 = root2.nodeType === 9 ? root2.head : root2, root2.insertBefore(nodes, root2.firstChild));
        resource.state.loading |= Inserted;
      }
    }
    function FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, onDefaultTransitionIndicator, formState) {
      this.tag = 1;
      this.containerInfo = containerInfo;
      this.pingCache = this.current = this.pendingChildren = null;
      this.timeoutHandle = noTimeout;
      this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null;
      this.callbackPriority = 0;
      this.expirationTimes = createLaneMap(-1);
      this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
      this.entanglements = createLaneMap(0);
      this.hiddenUpdates = createLaneMap(null);
      this.identifierPrefix = identifierPrefix;
      this.onUncaughtError = onUncaughtError;
      this.onCaughtError = onCaughtError;
      this.onRecoverableError = onRecoverableError;
      this.pooledCache = null;
      this.pooledCacheLanes = 0;
      this.formState = formState;
      this.incompleteTransitions = new Map;
      this.passiveEffectDuration = this.effectDuration = -0;
      this.memoizedUpdaters = new Set;
      containerInfo = this.pendingUpdatersLaneMap = [];
      for (tag = 0;31 > tag; tag++)
        containerInfo.push(new Set);
      this._debugRootType = hydrate ? "hydrateRoot()" : "createRoot()";
    }
    function createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, identifierPrefix, formState, onUncaughtError, onCaughtError, onRecoverableError, onDefaultTransitionIndicator) {
      containerInfo = new FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, onDefaultTransitionIndicator, formState);
      tag = ConcurrentMode;
      isStrictMode === true && (tag |= StrictLegacyMode | StrictEffectsMode);
      tag |= ProfileMode;
      isStrictMode = createFiber(3, null, null, tag);
      containerInfo.current = isStrictMode;
      isStrictMode.stateNode = containerInfo;
      tag = createCache();
      retainCache(tag);
      containerInfo.pooledCache = tag;
      retainCache(tag);
      isStrictMode.memoizedState = {
        element: initialChildren,
        isDehydrated: hydrate,
        cache: tag
      };
      initializeUpdateQueue(isStrictMode);
      return containerInfo;
    }
    function getContextForSubtree(parentComponent) {
      if (!parentComponent)
        return emptyContextObject;
      parentComponent = emptyContextObject;
      return parentComponent;
    }
    function updateContainerImpl(rootFiber, lane, element, container, parentComponent, callback) {
      if (injectedHook && typeof injectedHook.onScheduleFiberRoot === "function")
        try {
          injectedHook.onScheduleFiberRoot(rendererID, container, element);
        } catch (err) {
          hasLoggedError || (hasLoggedError = true, console.error("React instrumentation encountered an error: %o", err));
        }
      parentComponent = getContextForSubtree(parentComponent);
      container.context === null ? container.context = parentComponent : container.pendingContext = parentComponent;
      isRendering && current !== null && !didWarnAboutNestedUpdates && (didWarnAboutNestedUpdates = true, console.error(`Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.

Check the render method of %s.`, getComponentNameFromFiber(current) || "Unknown"));
      container = createUpdate(lane);
      container.payload = { element };
      callback = callback === undefined ? null : callback;
      callback !== null && (typeof callback !== "function" && console.error("Expected the last optional `callback` argument to be a function. Instead received: %s.", callback), container.callback = callback);
      element = enqueueUpdate(rootFiber, container, lane);
      element !== null && (startUpdateTimerByLane(lane, "root.render()", null), scheduleUpdateOnFiber(element, rootFiber, lane), entangleTransitions(element, rootFiber, lane));
    }
    function markRetryLaneImpl(fiber, retryLane) {
      fiber = fiber.memoizedState;
      if (fiber !== null && fiber.dehydrated !== null) {
        var a = fiber.retryLane;
        fiber.retryLane = a !== 0 && a < retryLane ? a : retryLane;
      }
    }
    function markRetryLaneIfNotHydrated(fiber, retryLane) {
      markRetryLaneImpl(fiber, retryLane);
      (fiber = fiber.alternate) && markRetryLaneImpl(fiber, retryLane);
    }
    function attemptContinuousHydration(fiber) {
      if (fiber.tag === 13 || fiber.tag === 31) {
        var root2 = enqueueConcurrentRenderForLane(fiber, 67108864);
        root2 !== null && scheduleUpdateOnFiber(root2, fiber, 67108864);
        markRetryLaneIfNotHydrated(fiber, 67108864);
      }
    }
    function attemptHydrationAtCurrentPriority(fiber) {
      if (fiber.tag === 13 || fiber.tag === 31) {
        var lane = requestUpdateLane(fiber);
        lane = getBumpedLaneForHydrationByLane(lane);
        var root2 = enqueueConcurrentRenderForLane(fiber, lane);
        root2 !== null && scheduleUpdateOnFiber(root2, fiber, lane);
        markRetryLaneIfNotHydrated(fiber, lane);
      }
    }
    function getCurrentFiberForDevTools() {
      return current;
    }
    function dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {
      var prevTransition = ReactSharedInternals.T;
      ReactSharedInternals.T = null;
      var previousPriority = ReactDOMSharedInternals.p;
      try {
        ReactDOMSharedInternals.p = DiscreteEventPriority, dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
      } finally {
        ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
      }
    }
    function dispatchContinuousEvent(domEventName, eventSystemFlags, container, nativeEvent) {
      var prevTransition = ReactSharedInternals.T;
      ReactSharedInternals.T = null;
      var previousPriority = ReactDOMSharedInternals.p;
      try {
        ReactDOMSharedInternals.p = ContinuousEventPriority, dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
      } finally {
        ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
      }
    }
    function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
      if (_enabled) {
        var blockedOn = findInstanceBlockingEvent(nativeEvent);
        if (blockedOn === null)
          dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, return_targetInst, targetContainer), clearIfContinuousEvent(domEventName, nativeEvent);
        else if (queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent))
          nativeEvent.stopPropagation();
        else if (clearIfContinuousEvent(domEventName, nativeEvent), eventSystemFlags & 4 && -1 < discreteReplayableEvents.indexOf(domEventName)) {
          for (;blockedOn !== null; ) {
            var fiber = getInstanceFromNode(blockedOn);
            if (fiber !== null)
              switch (fiber.tag) {
                case 3:
                  fiber = fiber.stateNode;
                  if (fiber.current.memoizedState.isDehydrated) {
                    var lanes = getHighestPriorityLanes(fiber.pendingLanes);
                    if (lanes !== 0) {
                      var root2 = fiber;
                      root2.pendingLanes |= 2;
                      for (root2.entangledLanes |= 2;lanes; ) {
                        var lane = 1 << 31 - clz32(lanes);
                        root2.entanglements[1] |= lane;
                        lanes &= ~lane;
                      }
                      ensureRootIsScheduled(fiber);
                      (executionContext & (RenderContext | CommitContext)) === NoContext && (workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS, flushSyncWorkAcrossRoots_impl(0, false));
                    }
                  }
                  break;
                case 31:
                case 13:
                  root2 = enqueueConcurrentRenderForLane(fiber, 2), root2 !== null && scheduleUpdateOnFiber(root2, fiber, 2), flushSyncWork$1(), markRetryLaneIfNotHydrated(fiber, 2);
              }
            fiber = findInstanceBlockingEvent(nativeEvent);
            fiber === null && dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, return_targetInst, targetContainer);
            if (fiber === blockedOn)
              break;
            blockedOn = fiber;
          }
          blockedOn !== null && nativeEvent.stopPropagation();
        } else
          dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, null, targetContainer);
      }
    }
    function findInstanceBlockingEvent(nativeEvent) {
      nativeEvent = getEventTarget(nativeEvent);
      return findInstanceBlockingTarget(nativeEvent);
    }
    function findInstanceBlockingTarget(targetNode) {
      return_targetInst = null;
      targetNode = getClosestInstanceFromNode(targetNode);
      if (targetNode !== null) {
        var nearestMounted = getNearestMountedFiber(targetNode);
        if (nearestMounted === null)
          targetNode = null;
        else {
          var tag = nearestMounted.tag;
          if (tag === 13) {
            targetNode = getSuspenseInstanceFromFiber(nearestMounted);
            if (targetNode !== null)
              return targetNode;
            targetNode = null;
          } else if (tag === 31) {
            targetNode = getActivityInstanceFromFiber(nearestMounted);
            if (targetNode !== null)
              return targetNode;
            targetNode = null;
          } else if (tag === 3) {
            if (nearestMounted.stateNode.current.memoizedState.isDehydrated)
              return nearestMounted.tag === 3 ? nearestMounted.stateNode.containerInfo : null;
            targetNode = null;
          } else
            nearestMounted !== targetNode && (targetNode = null);
        }
      }
      return_targetInst = targetNode;
      return null;
    }
    function getEventPriority(domEventName) {
      switch (domEventName) {
        case "beforetoggle":
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "toggle":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
          return DiscreteEventPriority;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
          return ContinuousEventPriority;
        case "message":
          switch (getCurrentPriorityLevel()) {
            case ImmediatePriority:
              return DiscreteEventPriority;
            case UserBlockingPriority:
              return ContinuousEventPriority;
            case NormalPriority$1:
            case LowPriority:
              return DefaultEventPriority;
            case IdlePriority:
              return IdleEventPriority;
            default:
              return DefaultEventPriority;
          }
        default:
          return DefaultEventPriority;
      }
    }
    function clearIfContinuousEvent(domEventName, nativeEvent) {
      switch (domEventName) {
        case "focusin":
        case "focusout":
          queuedFocus = null;
          break;
        case "dragenter":
        case "dragleave":
          queuedDrag = null;
          break;
        case "mouseover":
        case "mouseout":
          queuedMouse = null;
          break;
        case "pointerover":
        case "pointerout":
          queuedPointers.delete(nativeEvent.pointerId);
          break;
        case "gotpointercapture":
        case "lostpointercapture":
          queuedPointerCaptures.delete(nativeEvent.pointerId);
      }
    }
    function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
      if (existingQueuedEvent === null || existingQueuedEvent.nativeEvent !== nativeEvent)
        return existingQueuedEvent = {
          blockedOn,
          domEventName,
          eventSystemFlags,
          nativeEvent,
          targetContainers: [targetContainer]
        }, blockedOn !== null && (blockedOn = getInstanceFromNode(blockedOn), blockedOn !== null && attemptContinuousHydration(blockedOn)), existingQueuedEvent;
      existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
      blockedOn = existingQueuedEvent.targetContainers;
      targetContainer !== null && blockedOn.indexOf(targetContainer) === -1 && blockedOn.push(targetContainer);
      return existingQueuedEvent;
    }
    function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
      switch (domEventName) {
        case "focusin":
          return queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(queuedFocus, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent), true;
        case "dragenter":
          return queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(queuedDrag, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent), true;
        case "mouseover":
          return queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(queuedMouse, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent), true;
        case "pointerover":
          var pointerId = nativeEvent.pointerId;
          queuedPointers.set(pointerId, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointers.get(pointerId) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent));
          return true;
        case "gotpointercapture":
          return pointerId = nativeEvent.pointerId, queuedPointerCaptures.set(pointerId, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointerCaptures.get(pointerId) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent)), true;
      }
      return false;
    }
    function attemptExplicitHydrationTarget(queuedTarget) {
      var targetInst = getClosestInstanceFromNode(queuedTarget.target);
      if (targetInst !== null) {
        var nearestMounted = getNearestMountedFiber(targetInst);
        if (nearestMounted !== null) {
          if (targetInst = nearestMounted.tag, targetInst === 13) {
            if (targetInst = getSuspenseInstanceFromFiber(nearestMounted), targetInst !== null) {
              queuedTarget.blockedOn = targetInst;
              runWithPriority(queuedTarget.priority, function() {
                attemptHydrationAtCurrentPriority(nearestMounted);
              });
              return;
            }
          } else if (targetInst === 31) {
            if (targetInst = getActivityInstanceFromFiber(nearestMounted), targetInst !== null) {
              queuedTarget.blockedOn = targetInst;
              runWithPriority(queuedTarget.priority, function() {
                attemptHydrationAtCurrentPriority(nearestMounted);
              });
              return;
            }
          } else if (targetInst === 3 && nearestMounted.stateNode.current.memoizedState.isDehydrated) {
            queuedTarget.blockedOn = nearestMounted.tag === 3 ? nearestMounted.stateNode.containerInfo : null;
            return;
          }
        }
      }
      queuedTarget.blockedOn = null;
    }
    function attemptReplayContinuousQueuedEvent(queuedEvent) {
      if (queuedEvent.blockedOn !== null)
        return false;
      for (var targetContainers = queuedEvent.targetContainers;0 < targetContainers.length; ) {
        var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.nativeEvent);
        if (nextBlockedOn === null) {
          nextBlockedOn = queuedEvent.nativeEvent;
          var nativeEventClone = new nextBlockedOn.constructor(nextBlockedOn.type, nextBlockedOn), event = nativeEventClone;
          currentReplayingEvent !== null && console.error("Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue.");
          currentReplayingEvent = event;
          nextBlockedOn.target.dispatchEvent(nativeEventClone);
          currentReplayingEvent === null && console.error("Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue.");
          currentReplayingEvent = null;
        } else
          return targetContainers = getInstanceFromNode(nextBlockedOn), targetContainers !== null && attemptContinuousHydration(targetContainers), queuedEvent.blockedOn = nextBlockedOn, false;
        targetContainers.shift();
      }
      return true;
    }
    function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {
      attemptReplayContinuousQueuedEvent(queuedEvent) && map.delete(key);
    }
    function replayUnblockedEvents() {
      hasScheduledReplayAttempt = false;
      queuedFocus !== null && attemptReplayContinuousQueuedEvent(queuedFocus) && (queuedFocus = null);
      queuedDrag !== null && attemptReplayContinuousQueuedEvent(queuedDrag) && (queuedDrag = null);
      queuedMouse !== null && attemptReplayContinuousQueuedEvent(queuedMouse) && (queuedMouse = null);
      queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
      queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
    }
    function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
      queuedEvent.blockedOn === unblocked && (queuedEvent.blockedOn = null, hasScheduledReplayAttempt || (hasScheduledReplayAttempt = true, Scheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority, replayUnblockedEvents)));
    }
    function scheduleReplayQueueIfNeeded(formReplayingQueue) {
      lastScheduledReplayQueue !== formReplayingQueue && (lastScheduledReplayQueue = formReplayingQueue, Scheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority, function() {
        lastScheduledReplayQueue === formReplayingQueue && (lastScheduledReplayQueue = null);
        for (var i = 0;i < formReplayingQueue.length; i += 3) {
          var form = formReplayingQueue[i], submitterOrAction = formReplayingQueue[i + 1], formData = formReplayingQueue[i + 2];
          if (typeof submitterOrAction !== "function")
            if (findInstanceBlockingTarget(submitterOrAction || form) === null)
              continue;
            else
              break;
          var formInst = getInstanceFromNode(form);
          formInst !== null && (formReplayingQueue.splice(i, 3), i -= 3, form = {
            pending: true,
            data: formData,
            method: form.method,
            action: submitterOrAction
          }, Object.freeze(form), startHostTransition(formInst, form, submitterOrAction, formData));
        }
      }));
    }
    function retryIfBlockedOn(unblocked) {
      function unblock(queuedEvent) {
        return scheduleCallbackIfUnblocked(queuedEvent, unblocked);
      }
      queuedFocus !== null && scheduleCallbackIfUnblocked(queuedFocus, unblocked);
      queuedDrag !== null && scheduleCallbackIfUnblocked(queuedDrag, unblocked);
      queuedMouse !== null && scheduleCallbackIfUnblocked(queuedMouse, unblocked);
      queuedPointers.forEach(unblock);
      queuedPointerCaptures.forEach(unblock);
      for (var i = 0;i < queuedExplicitHydrationTargets.length; i++) {
        var queuedTarget = queuedExplicitHydrationTargets[i];
        queuedTarget.blockedOn === unblocked && (queuedTarget.blockedOn = null);
      }
      for (;0 < queuedExplicitHydrationTargets.length && (i = queuedExplicitHydrationTargets[0], i.blockedOn === null); )
        attemptExplicitHydrationTarget(i), i.blockedOn === null && queuedExplicitHydrationTargets.shift();
      i = (unblocked.ownerDocument || unblocked).$$reactFormReplay;
      if (i != null)
        for (queuedTarget = 0;queuedTarget < i.length; queuedTarget += 3) {
          var form = i[queuedTarget], submitterOrAction = i[queuedTarget + 1], formProps = form[internalPropsKey] || null;
          if (typeof submitterOrAction === "function")
            formProps || scheduleReplayQueueIfNeeded(i);
          else if (formProps) {
            var action = null;
            if (submitterOrAction && submitterOrAction.hasAttribute("formAction"))
              if (form = submitterOrAction, formProps = submitterOrAction[internalPropsKey] || null)
                action = formProps.formAction;
              else {
                if (findInstanceBlockingTarget(form) !== null)
                  continue;
              }
            else
              action = formProps.action;
            typeof action === "function" ? i[queuedTarget + 1] = action : (i.splice(queuedTarget, 3), queuedTarget -= 3);
            scheduleReplayQueueIfNeeded(i);
          }
        }
    }
    function defaultOnDefaultTransitionIndicator() {
      function handleNavigate(event) {
        event.canIntercept && event.info === "react-transition" && event.intercept({
          handler: function() {
            return new Promise(function(resolve) {
              return pendingResolve = resolve;
            });
          },
          focusReset: "manual",
          scroll: "manual"
        });
      }
      function handleNavigateComplete() {
        pendingResolve !== null && (pendingResolve(), pendingResolve = null);
        isCancelled || setTimeout(startFakeNavigation, 20);
      }
      function startFakeNavigation() {
        if (!isCancelled && !navigation.transition) {
          var currentEntry = navigation.currentEntry;
          currentEntry && currentEntry.url != null && navigation.navigate(currentEntry.url, {
            state: currentEntry.getState(),
            info: "react-transition",
            history: "replace"
          });
        }
      }
      if (typeof navigation === "object") {
        var isCancelled = false, pendingResolve = null;
        navigation.addEventListener("navigate", handleNavigate);
        navigation.addEventListener("navigatesuccess", handleNavigateComplete);
        navigation.addEventListener("navigateerror", handleNavigateComplete);
        setTimeout(startFakeNavigation, 100);
        return function() {
          isCancelled = true;
          navigation.removeEventListener("navigate", handleNavigate);
          navigation.removeEventListener("navigatesuccess", handleNavigateComplete);
          navigation.removeEventListener("navigateerror", handleNavigateComplete);
          pendingResolve !== null && (pendingResolve(), pendingResolve = null);
        };
      }
    }
    function ReactDOMRoot(internalRoot) {
      this._internalRoot = internalRoot;
    }
    function ReactDOMHydrationRoot(internalRoot) {
      this._internalRoot = internalRoot;
    }
    function warnIfReactDOMContainerInDEV(container) {
      container[internalContainerInstanceKey] && (container._reactRootContainer ? console.error("You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported.") : console.error("You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it."));
    }
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var assign = Object.assign, REACT_LEGACY_ELEMENT_TYPE = Symbol.for("react.element"), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy");
    Symbol.for("react.scope");
    var REACT_ACTIVITY_TYPE = Symbol.for("react.activity");
    Symbol.for("react.legacy_hidden");
    Symbol.for("react.tracing_marker");
    var REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel");
    Symbol.for("react.view_transition");
    var MAYBE_ITERATOR_SYMBOL = Symbol.iterator, REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), isArrayImpl = Array.isArray, ReactSharedInternals = React6.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, ReactDOMSharedInternals = ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, NotPending = Object.freeze({
      pending: false,
      data: null,
      method: null,
      action: null
    }), valueStack = [];
    var fiberStack = [];
    var index$jscomp$0 = -1, contextStackCursor = createCursor(null), contextFiberStackCursor = createCursor(null), rootInstanceStackCursor = createCursor(null), hostTransitionProviderCursor = createCursor(null), disabledDepth = 0, prevLog, prevInfo, prevWarn, prevError, prevGroup, prevGroupCollapsed, prevGroupEnd;
    disabledLog.__reactDisabledLog = true;
    var prefix, suffix, reentry = false;
    var componentFrameCache = new (typeof WeakMap === "function" ? WeakMap : Map);
    var current = null, isRendering = false, hasOwnProperty = Object.prototype.hasOwnProperty, scheduleCallback$3 = Scheduler.unstable_scheduleCallback, cancelCallback$1 = Scheduler.unstable_cancelCallback, shouldYield = Scheduler.unstable_shouldYield, requestPaint = Scheduler.unstable_requestPaint, now$1 = Scheduler.unstable_now, getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel, ImmediatePriority = Scheduler.unstable_ImmediatePriority, UserBlockingPriority = Scheduler.unstable_UserBlockingPriority, NormalPriority$1 = Scheduler.unstable_NormalPriority, LowPriority = Scheduler.unstable_LowPriority, IdlePriority = Scheduler.unstable_IdlePriority, log$1 = Scheduler.log, unstable_setDisableYieldValue2 = Scheduler.unstable_setDisableYieldValue, rendererID = null, injectedHook = null, hasLoggedError = false, isDevToolsPresent = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined", clz32 = Math.clz32 ? Math.clz32 : clz32Fallback, log2 = Math.log, LN2 = Math.LN2, nextTransitionUpdateLane = 256, nextTransitionDeferredLane = 262144, nextRetryLane = 4194304, DiscreteEventPriority = 2, ContinuousEventPriority = 8, DefaultEventPriority = 32, IdleEventPriority = 268435456, randomKey = Math.random().toString(36).slice(2), internalInstanceKey = "__reactFiber$" + randomKey, internalPropsKey = "__reactProps$" + randomKey, internalContainerInstanceKey = "__reactContainer$" + randomKey, internalEventHandlersKey = "__reactEvents$" + randomKey, internalEventHandlerListenersKey = "__reactListeners$" + randomKey, internalEventHandlesSetKey = "__reactHandles$" + randomKey, internalRootNodeResourcesKey = "__reactResources$" + randomKey, internalHoistableMarker = "__reactMarker$" + randomKey, allNativeEvents = new Set, registrationNameDependencies = {}, possibleRegistrationNames = {}, hasReadOnlyValue = {
      button: true,
      checkbox: true,
      image: true,
      hidden: true,
      radio: true,
      reset: true,
      submit: true
    }, VALID_ATTRIBUTE_NAME_REGEX = RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"), illegalAttributeNameCache = {}, validatedAttributeNameCache = {}, escapeSelectorAttributeValueInsideDoubleQuotesRegex = /[\n"\\]/g, didWarnValueDefaultValue$1 = false, didWarnCheckedDefaultChecked = false, didWarnSelectedSetOnOption = false, didWarnInvalidChild = false, didWarnInvalidInnerHTML = false;
    var didWarnValueDefaultValue = false;
    var valuePropNames = ["value", "defaultValue"], didWarnValDefaultVal = false, needsEscaping = /["'&<>\n\t]|^\s|\s$/, specialTags = "address applet area article aside base basefont bgsound blockquote body br button caption center col colgroup dd details dir div dl dt embed fieldset figcaption figure footer form frame frameset h1 h2 h3 h4 h5 h6 head header hgroup hr html iframe img input isindex li link listing main marquee menu menuitem meta nav noembed noframes noscript object ol p param plaintext pre script section select source style summary table tbody td template textarea tfoot th thead title tr track ul wbr xmp".split(" "), inScopeTags = "applet caption html table td th marquee object template foreignObject desc title".split(" "), buttonScopeTags = inScopeTags.concat(["button"]), impliedEndTags = "dd dt li option optgroup p rp rt".split(" "), emptyAncestorInfoDev = {
      current: null,
      formTag: null,
      aTagInScope: null,
      buttonTagInScope: null,
      nobrTagInScope: null,
      pTagInButtonScope: null,
      listItemTagAutoclosing: null,
      dlItemTagAutoclosing: null,
      containerTagInScope: null,
      implicitRootScope: false
    }, didWarn = {}, shorthandToLonghand = {
      animation: "animationDelay animationDirection animationDuration animationFillMode animationIterationCount animationName animationPlayState animationTimingFunction".split(" "),
      background: "backgroundAttachment backgroundClip backgroundColor backgroundImage backgroundOrigin backgroundPositionX backgroundPositionY backgroundRepeat backgroundSize".split(" "),
      backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
      border: "borderBottomColor borderBottomStyle borderBottomWidth borderImageOutset borderImageRepeat borderImageSlice borderImageSource borderImageWidth borderLeftColor borderLeftStyle borderLeftWidth borderRightColor borderRightStyle borderRightWidth borderTopColor borderTopStyle borderTopWidth".split(" "),
      borderBlockEnd: [
        "borderBlockEndColor",
        "borderBlockEndStyle",
        "borderBlockEndWidth"
      ],
      borderBlockStart: [
        "borderBlockStartColor",
        "borderBlockStartStyle",
        "borderBlockStartWidth"
      ],
      borderBottom: [
        "borderBottomColor",
        "borderBottomStyle",
        "borderBottomWidth"
      ],
      borderColor: [
        "borderBottomColor",
        "borderLeftColor",
        "borderRightColor",
        "borderTopColor"
      ],
      borderImage: [
        "borderImageOutset",
        "borderImageRepeat",
        "borderImageSlice",
        "borderImageSource",
        "borderImageWidth"
      ],
      borderInlineEnd: [
        "borderInlineEndColor",
        "borderInlineEndStyle",
        "borderInlineEndWidth"
      ],
      borderInlineStart: [
        "borderInlineStartColor",
        "borderInlineStartStyle",
        "borderInlineStartWidth"
      ],
      borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
      borderRadius: [
        "borderBottomLeftRadius",
        "borderBottomRightRadius",
        "borderTopLeftRadius",
        "borderTopRightRadius"
      ],
      borderRight: [
        "borderRightColor",
        "borderRightStyle",
        "borderRightWidth"
      ],
      borderStyle: [
        "borderBottomStyle",
        "borderLeftStyle",
        "borderRightStyle",
        "borderTopStyle"
      ],
      borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"],
      borderWidth: [
        "borderBottomWidth",
        "borderLeftWidth",
        "borderRightWidth",
        "borderTopWidth"
      ],
      columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"],
      columns: ["columnCount", "columnWidth"],
      flex: ["flexBasis", "flexGrow", "flexShrink"],
      flexFlow: ["flexDirection", "flexWrap"],
      font: "fontFamily fontFeatureSettings fontKerning fontLanguageOverride fontSize fontSizeAdjust fontStretch fontStyle fontVariant fontVariantAlternates fontVariantCaps fontVariantEastAsian fontVariantLigatures fontVariantNumeric fontVariantPosition fontWeight lineHeight".split(" "),
      fontVariant: "fontVariantAlternates fontVariantCaps fontVariantEastAsian fontVariantLigatures fontVariantNumeric fontVariantPosition".split(" "),
      gap: ["columnGap", "rowGap"],
      grid: "gridAutoColumns gridAutoFlow gridAutoRows gridTemplateAreas gridTemplateColumns gridTemplateRows".split(" "),
      gridArea: [
        "gridColumnEnd",
        "gridColumnStart",
        "gridRowEnd",
        "gridRowStart"
      ],
      gridColumn: ["gridColumnEnd", "gridColumnStart"],
      gridColumnGap: ["columnGap"],
      gridGap: ["columnGap", "rowGap"],
      gridRow: ["gridRowEnd", "gridRowStart"],
      gridRowGap: ["rowGap"],
      gridTemplate: [
        "gridTemplateAreas",
        "gridTemplateColumns",
        "gridTemplateRows"
      ],
      listStyle: ["listStyleImage", "listStylePosition", "listStyleType"],
      margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"],
      marker: ["markerEnd", "markerMid", "markerStart"],
      mask: "maskClip maskComposite maskImage maskMode maskOrigin maskPositionX maskPositionY maskRepeat maskSize".split(" "),
      maskPosition: ["maskPositionX", "maskPositionY"],
      outline: ["outlineColor", "outlineStyle", "outlineWidth"],
      overflow: ["overflowX", "overflowY"],
      padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"],
      placeContent: ["alignContent", "justifyContent"],
      placeItems: ["alignItems", "justifyItems"],
      placeSelf: ["alignSelf", "justifySelf"],
      textDecoration: [
        "textDecorationColor",
        "textDecorationLine",
        "textDecorationStyle"
      ],
      textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
      transition: [
        "transitionDelay",
        "transitionDuration",
        "transitionProperty",
        "transitionTimingFunction"
      ],
      wordWrap: ["overflowWrap"]
    }, uppercasePattern = /([A-Z])/g, msPattern$1 = /^ms-/, badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/, msPattern = /^-ms-/, hyphenPattern = /-(.)/g, badStyleValueWithSemicolonPattern = /;\s*$/, warnedStyleNames = {}, warnedStyleValues = {}, warnedForNaNValue = false, warnedForInfinityValue = false, unitlessNumbers = new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" ")), MATH_NAMESPACE = "http://www.w3.org/1998/Math/MathML", SVG_NAMESPACE = "http://www.w3.org/2000/svg", aliases = new Map([
      ["acceptCharset", "accept-charset"],
      ["htmlFor", "for"],
      ["httpEquiv", "http-equiv"],
      ["crossOrigin", "crossorigin"],
      ["accentHeight", "accent-height"],
      ["alignmentBaseline", "alignment-baseline"],
      ["arabicForm", "arabic-form"],
      ["baselineShift", "baseline-shift"],
      ["capHeight", "cap-height"],
      ["clipPath", "clip-path"],
      ["clipRule", "clip-rule"],
      ["colorInterpolation", "color-interpolation"],
      ["colorInterpolationFilters", "color-interpolation-filters"],
      ["colorProfile", "color-profile"],
      ["colorRendering", "color-rendering"],
      ["dominantBaseline", "dominant-baseline"],
      ["enableBackground", "enable-background"],
      ["fillOpacity", "fill-opacity"],
      ["fillRule", "fill-rule"],
      ["floodColor", "flood-color"],
      ["floodOpacity", "flood-opacity"],
      ["fontFamily", "font-family"],
      ["fontSize", "font-size"],
      ["fontSizeAdjust", "font-size-adjust"],
      ["fontStretch", "font-stretch"],
      ["fontStyle", "font-style"],
      ["fontVariant", "font-variant"],
      ["fontWeight", "font-weight"],
      ["glyphName", "glyph-name"],
      ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
      ["glyphOrientationVertical", "glyph-orientation-vertical"],
      ["horizAdvX", "horiz-adv-x"],
      ["horizOriginX", "horiz-origin-x"],
      ["imageRendering", "image-rendering"],
      ["letterSpacing", "letter-spacing"],
      ["lightingColor", "lighting-color"],
      ["markerEnd", "marker-end"],
      ["markerMid", "marker-mid"],
      ["markerStart", "marker-start"],
      ["overlinePosition", "overline-position"],
      ["overlineThickness", "overline-thickness"],
      ["paintOrder", "paint-order"],
      ["panose-1", "panose-1"],
      ["pointerEvents", "pointer-events"],
      ["renderingIntent", "rendering-intent"],
      ["shapeRendering", "shape-rendering"],
      ["stopColor", "stop-color"],
      ["stopOpacity", "stop-opacity"],
      ["strikethroughPosition", "strikethrough-position"],
      ["strikethroughThickness", "strikethrough-thickness"],
      ["strokeDasharray", "stroke-dasharray"],
      ["strokeDashoffset", "stroke-dashoffset"],
      ["strokeLinecap", "stroke-linecap"],
      ["strokeLinejoin", "stroke-linejoin"],
      ["strokeMiterlimit", "stroke-miterlimit"],
      ["strokeOpacity", "stroke-opacity"],
      ["strokeWidth", "stroke-width"],
      ["textAnchor", "text-anchor"],
      ["textDecoration", "text-decoration"],
      ["textRendering", "text-rendering"],
      ["transformOrigin", "transform-origin"],
      ["underlinePosition", "underline-position"],
      ["underlineThickness", "underline-thickness"],
      ["unicodeBidi", "unicode-bidi"],
      ["unicodeRange", "unicode-range"],
      ["unitsPerEm", "units-per-em"],
      ["vAlphabetic", "v-alphabetic"],
      ["vHanging", "v-hanging"],
      ["vIdeographic", "v-ideographic"],
      ["vMathematical", "v-mathematical"],
      ["vectorEffect", "vector-effect"],
      ["vertAdvY", "vert-adv-y"],
      ["vertOriginX", "vert-origin-x"],
      ["vertOriginY", "vert-origin-y"],
      ["wordSpacing", "word-spacing"],
      ["writingMode", "writing-mode"],
      ["xmlnsXlink", "xmlns:xlink"],
      ["xHeight", "x-height"]
    ]), possibleStandardNames = {
      accept: "accept",
      acceptcharset: "acceptCharset",
      "accept-charset": "acceptCharset",
      accesskey: "accessKey",
      action: "action",
      allowfullscreen: "allowFullScreen",
      alt: "alt",
      as: "as",
      async: "async",
      autocapitalize: "autoCapitalize",
      autocomplete: "autoComplete",
      autocorrect: "autoCorrect",
      autofocus: "autoFocus",
      autoplay: "autoPlay",
      autosave: "autoSave",
      capture: "capture",
      cellpadding: "cellPadding",
      cellspacing: "cellSpacing",
      challenge: "challenge",
      charset: "charSet",
      checked: "checked",
      children: "children",
      cite: "cite",
      class: "className",
      classid: "classID",
      classname: "className",
      cols: "cols",
      colspan: "colSpan",
      content: "content",
      contenteditable: "contentEditable",
      contextmenu: "contextMenu",
      controls: "controls",
      controlslist: "controlsList",
      coords: "coords",
      crossorigin: "crossOrigin",
      dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
      data: "data",
      datetime: "dateTime",
      default: "default",
      defaultchecked: "defaultChecked",
      defaultvalue: "defaultValue",
      defer: "defer",
      dir: "dir",
      disabled: "disabled",
      disablepictureinpicture: "disablePictureInPicture",
      disableremoteplayback: "disableRemotePlayback",
      download: "download",
      draggable: "draggable",
      enctype: "encType",
      enterkeyhint: "enterKeyHint",
      fetchpriority: "fetchPriority",
      for: "htmlFor",
      form: "form",
      formmethod: "formMethod",
      formaction: "formAction",
      formenctype: "formEncType",
      formnovalidate: "formNoValidate",
      formtarget: "formTarget",
      frameborder: "frameBorder",
      headers: "headers",
      height: "height",
      hidden: "hidden",
      high: "high",
      href: "href",
      hreflang: "hrefLang",
      htmlfor: "htmlFor",
      httpequiv: "httpEquiv",
      "http-equiv": "httpEquiv",
      icon: "icon",
      id: "id",
      imagesizes: "imageSizes",
      imagesrcset: "imageSrcSet",
      inert: "inert",
      innerhtml: "innerHTML",
      inputmode: "inputMode",
      integrity: "integrity",
      is: "is",
      itemid: "itemID",
      itemprop: "itemProp",
      itemref: "itemRef",
      itemscope: "itemScope",
      itemtype: "itemType",
      keyparams: "keyParams",
      keytype: "keyType",
      kind: "kind",
      label: "label",
      lang: "lang",
      list: "list",
      loop: "loop",
      low: "low",
      manifest: "manifest",
      marginwidth: "marginWidth",
      marginheight: "marginHeight",
      max: "max",
      maxlength: "maxLength",
      media: "media",
      mediagroup: "mediaGroup",
      method: "method",
      min: "min",
      minlength: "minLength",
      multiple: "multiple",
      muted: "muted",
      name: "name",
      nomodule: "noModule",
      nonce: "nonce",
      novalidate: "noValidate",
      open: "open",
      optimum: "optimum",
      pattern: "pattern",
      placeholder: "placeholder",
      playsinline: "playsInline",
      poster: "poster",
      preload: "preload",
      profile: "profile",
      radiogroup: "radioGroup",
      readonly: "readOnly",
      referrerpolicy: "referrerPolicy",
      rel: "rel",
      required: "required",
      reversed: "reversed",
      role: "role",
      rows: "rows",
      rowspan: "rowSpan",
      sandbox: "sandbox",
      scope: "scope",
      scoped: "scoped",
      scrolling: "scrolling",
      seamless: "seamless",
      selected: "selected",
      shape: "shape",
      size: "size",
      sizes: "sizes",
      span: "span",
      spellcheck: "spellCheck",
      src: "src",
      srcdoc: "srcDoc",
      srclang: "srcLang",
      srcset: "srcSet",
      start: "start",
      step: "step",
      style: "style",
      summary: "summary",
      tabindex: "tabIndex",
      target: "target",
      title: "title",
      type: "type",
      usemap: "useMap",
      value: "value",
      width: "width",
      wmode: "wmode",
      wrap: "wrap",
      about: "about",
      accentheight: "accentHeight",
      "accent-height": "accentHeight",
      accumulate: "accumulate",
      additive: "additive",
      alignmentbaseline: "alignmentBaseline",
      "alignment-baseline": "alignmentBaseline",
      allowreorder: "allowReorder",
      alphabetic: "alphabetic",
      amplitude: "amplitude",
      arabicform: "arabicForm",
      "arabic-form": "arabicForm",
      ascent: "ascent",
      attributename: "attributeName",
      attributetype: "attributeType",
      autoreverse: "autoReverse",
      azimuth: "azimuth",
      basefrequency: "baseFrequency",
      baselineshift: "baselineShift",
      "baseline-shift": "baselineShift",
      baseprofile: "baseProfile",
      bbox: "bbox",
      begin: "begin",
      bias: "bias",
      by: "by",
      calcmode: "calcMode",
      capheight: "capHeight",
      "cap-height": "capHeight",
      clip: "clip",
      clippath: "clipPath",
      "clip-path": "clipPath",
      clippathunits: "clipPathUnits",
      cliprule: "clipRule",
      "clip-rule": "clipRule",
      color: "color",
      colorinterpolation: "colorInterpolation",
      "color-interpolation": "colorInterpolation",
      colorinterpolationfilters: "colorInterpolationFilters",
      "color-interpolation-filters": "colorInterpolationFilters",
      colorprofile: "colorProfile",
      "color-profile": "colorProfile",
      colorrendering: "colorRendering",
      "color-rendering": "colorRendering",
      contentscripttype: "contentScriptType",
      contentstyletype: "contentStyleType",
      cursor: "cursor",
      cx: "cx",
      cy: "cy",
      d: "d",
      datatype: "datatype",
      decelerate: "decelerate",
      descent: "descent",
      diffuseconstant: "diffuseConstant",
      direction: "direction",
      display: "display",
      divisor: "divisor",
      dominantbaseline: "dominantBaseline",
      "dominant-baseline": "dominantBaseline",
      dur: "dur",
      dx: "dx",
      dy: "dy",
      edgemode: "edgeMode",
      elevation: "elevation",
      enablebackground: "enableBackground",
      "enable-background": "enableBackground",
      end: "end",
      exponent: "exponent",
      externalresourcesrequired: "externalResourcesRequired",
      fill: "fill",
      fillopacity: "fillOpacity",
      "fill-opacity": "fillOpacity",
      fillrule: "fillRule",
      "fill-rule": "fillRule",
      filter: "filter",
      filterres: "filterRes",
      filterunits: "filterUnits",
      floodopacity: "floodOpacity",
      "flood-opacity": "floodOpacity",
      floodcolor: "floodColor",
      "flood-color": "floodColor",
      focusable: "focusable",
      fontfamily: "fontFamily",
      "font-family": "fontFamily",
      fontsize: "fontSize",
      "font-size": "fontSize",
      fontsizeadjust: "fontSizeAdjust",
      "font-size-adjust": "fontSizeAdjust",
      fontstretch: "fontStretch",
      "font-stretch": "fontStretch",
      fontstyle: "fontStyle",
      "font-style": "fontStyle",
      fontvariant: "fontVariant",
      "font-variant": "fontVariant",
      fontweight: "fontWeight",
      "font-weight": "fontWeight",
      format: "format",
      from: "from",
      fx: "fx",
      fy: "fy",
      g1: "g1",
      g2: "g2",
      glyphname: "glyphName",
      "glyph-name": "glyphName",
      glyphorientationhorizontal: "glyphOrientationHorizontal",
      "glyph-orientation-horizontal": "glyphOrientationHorizontal",
      glyphorientationvertical: "glyphOrientationVertical",
      "glyph-orientation-vertical": "glyphOrientationVertical",
      glyphref: "glyphRef",
      gradienttransform: "gradientTransform",
      gradientunits: "gradientUnits",
      hanging: "hanging",
      horizadvx: "horizAdvX",
      "horiz-adv-x": "horizAdvX",
      horizoriginx: "horizOriginX",
      "horiz-origin-x": "horizOriginX",
      ideographic: "ideographic",
      imagerendering: "imageRendering",
      "image-rendering": "imageRendering",
      in2: "in2",
      in: "in",
      inlist: "inlist",
      intercept: "intercept",
      k1: "k1",
      k2: "k2",
      k3: "k3",
      k4: "k4",
      k: "k",
      kernelmatrix: "kernelMatrix",
      kernelunitlength: "kernelUnitLength",
      kerning: "kerning",
      keypoints: "keyPoints",
      keysplines: "keySplines",
      keytimes: "keyTimes",
      lengthadjust: "lengthAdjust",
      letterspacing: "letterSpacing",
      "letter-spacing": "letterSpacing",
      lightingcolor: "lightingColor",
      "lighting-color": "lightingColor",
      limitingconeangle: "limitingConeAngle",
      local: "local",
      markerend: "markerEnd",
      "marker-end": "markerEnd",
      markerheight: "markerHeight",
      markermid: "markerMid",
      "marker-mid": "markerMid",
      markerstart: "markerStart",
      "marker-start": "markerStart",
      markerunits: "markerUnits",
      markerwidth: "markerWidth",
      mask: "mask",
      maskcontentunits: "maskContentUnits",
      maskunits: "maskUnits",
      mathematical: "mathematical",
      mode: "mode",
      numoctaves: "numOctaves",
      offset: "offset",
      opacity: "opacity",
      operator: "operator",
      order: "order",
      orient: "orient",
      orientation: "orientation",
      origin: "origin",
      overflow: "overflow",
      overlineposition: "overlinePosition",
      "overline-position": "overlinePosition",
      overlinethickness: "overlineThickness",
      "overline-thickness": "overlineThickness",
      paintorder: "paintOrder",
      "paint-order": "paintOrder",
      panose1: "panose1",
      "panose-1": "panose1",
      pathlength: "pathLength",
      patterncontentunits: "patternContentUnits",
      patterntransform: "patternTransform",
      patternunits: "patternUnits",
      pointerevents: "pointerEvents",
      "pointer-events": "pointerEvents",
      points: "points",
      pointsatx: "pointsAtX",
      pointsaty: "pointsAtY",
      pointsatz: "pointsAtZ",
      popover: "popover",
      popovertarget: "popoverTarget",
      popovertargetaction: "popoverTargetAction",
      prefix: "prefix",
      preservealpha: "preserveAlpha",
      preserveaspectratio: "preserveAspectRatio",
      primitiveunits: "primitiveUnits",
      property: "property",
      r: "r",
      radius: "radius",
      refx: "refX",
      refy: "refY",
      renderingintent: "renderingIntent",
      "rendering-intent": "renderingIntent",
      repeatcount: "repeatCount",
      repeatdur: "repeatDur",
      requiredextensions: "requiredExtensions",
      requiredfeatures: "requiredFeatures",
      resource: "resource",
      restart: "restart",
      result: "result",
      results: "results",
      rotate: "rotate",
      rx: "rx",
      ry: "ry",
      scale: "scale",
      security: "security",
      seed: "seed",
      shaperendering: "shapeRendering",
      "shape-rendering": "shapeRendering",
      slope: "slope",
      spacing: "spacing",
      specularconstant: "specularConstant",
      specularexponent: "specularExponent",
      speed: "speed",
      spreadmethod: "spreadMethod",
      startoffset: "startOffset",
      stddeviation: "stdDeviation",
      stemh: "stemh",
      stemv: "stemv",
      stitchtiles: "stitchTiles",
      stopcolor: "stopColor",
      "stop-color": "stopColor",
      stopopacity: "stopOpacity",
      "stop-opacity": "stopOpacity",
      strikethroughposition: "strikethroughPosition",
      "strikethrough-position": "strikethroughPosition",
      strikethroughthickness: "strikethroughThickness",
      "strikethrough-thickness": "strikethroughThickness",
      string: "string",
      stroke: "stroke",
      strokedasharray: "strokeDasharray",
      "stroke-dasharray": "strokeDasharray",
      strokedashoffset: "strokeDashoffset",
      "stroke-dashoffset": "strokeDashoffset",
      strokelinecap: "strokeLinecap",
      "stroke-linecap": "strokeLinecap",
      strokelinejoin: "strokeLinejoin",
      "stroke-linejoin": "strokeLinejoin",
      strokemiterlimit: "strokeMiterlimit",
      "stroke-miterlimit": "strokeMiterlimit",
      strokewidth: "strokeWidth",
      "stroke-width": "strokeWidth",
      strokeopacity: "strokeOpacity",
      "stroke-opacity": "strokeOpacity",
      suppresscontenteditablewarning: "suppressContentEditableWarning",
      suppresshydrationwarning: "suppressHydrationWarning",
      surfacescale: "surfaceScale",
      systemlanguage: "systemLanguage",
      tablevalues: "tableValues",
      targetx: "targetX",
      targety: "targetY",
      textanchor: "textAnchor",
      "text-anchor": "textAnchor",
      textdecoration: "textDecoration",
      "text-decoration": "textDecoration",
      textlength: "textLength",
      textrendering: "textRendering",
      "text-rendering": "textRendering",
      to: "to",
      transform: "transform",
      transformorigin: "transformOrigin",
      "transform-origin": "transformOrigin",
      typeof: "typeof",
      u1: "u1",
      u2: "u2",
      underlineposition: "underlinePosition",
      "underline-position": "underlinePosition",
      underlinethickness: "underlineThickness",
      "underline-thickness": "underlineThickness",
      unicode: "unicode",
      unicodebidi: "unicodeBidi",
      "unicode-bidi": "unicodeBidi",
      unicoderange: "unicodeRange",
      "unicode-range": "unicodeRange",
      unitsperem: "unitsPerEm",
      "units-per-em": "unitsPerEm",
      unselectable: "unselectable",
      valphabetic: "vAlphabetic",
      "v-alphabetic": "vAlphabetic",
      values: "values",
      vectoreffect: "vectorEffect",
      "vector-effect": "vectorEffect",
      version: "version",
      vertadvy: "vertAdvY",
      "vert-adv-y": "vertAdvY",
      vertoriginx: "vertOriginX",
      "vert-origin-x": "vertOriginX",
      vertoriginy: "vertOriginY",
      "vert-origin-y": "vertOriginY",
      vhanging: "vHanging",
      "v-hanging": "vHanging",
      videographic: "vIdeographic",
      "v-ideographic": "vIdeographic",
      viewbox: "viewBox",
      viewtarget: "viewTarget",
      visibility: "visibility",
      vmathematical: "vMathematical",
      "v-mathematical": "vMathematical",
      vocab: "vocab",
      widths: "widths",
      wordspacing: "wordSpacing",
      "word-spacing": "wordSpacing",
      writingmode: "writingMode",
      "writing-mode": "writingMode",
      x1: "x1",
      x2: "x2",
      x: "x",
      xchannelselector: "xChannelSelector",
      xheight: "xHeight",
      "x-height": "xHeight",
      xlinkactuate: "xlinkActuate",
      "xlink:actuate": "xlinkActuate",
      xlinkarcrole: "xlinkArcrole",
      "xlink:arcrole": "xlinkArcrole",
      xlinkhref: "xlinkHref",
      "xlink:href": "xlinkHref",
      xlinkrole: "xlinkRole",
      "xlink:role": "xlinkRole",
      xlinkshow: "xlinkShow",
      "xlink:show": "xlinkShow",
      xlinktitle: "xlinkTitle",
      "xlink:title": "xlinkTitle",
      xlinktype: "xlinkType",
      "xlink:type": "xlinkType",
      xmlbase: "xmlBase",
      "xml:base": "xmlBase",
      xmllang: "xmlLang",
      "xml:lang": "xmlLang",
      xmlns: "xmlns",
      "xml:space": "xmlSpace",
      xmlnsxlink: "xmlnsXlink",
      "xmlns:xlink": "xmlnsXlink",
      xmlspace: "xmlSpace",
      y1: "y1",
      y2: "y2",
      y: "y",
      ychannelselector: "yChannelSelector",
      z: "z",
      zoomandpan: "zoomAndPan"
    }, ariaProperties = {
      "aria-current": 0,
      "aria-description": 0,
      "aria-details": 0,
      "aria-disabled": 0,
      "aria-hidden": 0,
      "aria-invalid": 0,
      "aria-keyshortcuts": 0,
      "aria-label": 0,
      "aria-roledescription": 0,
      "aria-autocomplete": 0,
      "aria-checked": 0,
      "aria-expanded": 0,
      "aria-haspopup": 0,
      "aria-level": 0,
      "aria-modal": 0,
      "aria-multiline": 0,
      "aria-multiselectable": 0,
      "aria-orientation": 0,
      "aria-placeholder": 0,
      "aria-pressed": 0,
      "aria-readonly": 0,
      "aria-required": 0,
      "aria-selected": 0,
      "aria-sort": 0,
      "aria-valuemax": 0,
      "aria-valuemin": 0,
      "aria-valuenow": 0,
      "aria-valuetext": 0,
      "aria-atomic": 0,
      "aria-busy": 0,
      "aria-live": 0,
      "aria-relevant": 0,
      "aria-dropeffect": 0,
      "aria-grabbed": 0,
      "aria-activedescendant": 0,
      "aria-colcount": 0,
      "aria-colindex": 0,
      "aria-colspan": 0,
      "aria-controls": 0,
      "aria-describedby": 0,
      "aria-errormessage": 0,
      "aria-flowto": 0,
      "aria-labelledby": 0,
      "aria-owns": 0,
      "aria-posinset": 0,
      "aria-rowcount": 0,
      "aria-rowindex": 0,
      "aria-rowspan": 0,
      "aria-setsize": 0,
      "aria-braillelabel": 0,
      "aria-brailleroledescription": 0,
      "aria-colindextext": 0,
      "aria-rowindextext": 0
    }, warnedProperties$1 = {}, rARIA$1 = RegExp("^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"), rARIACamel$1 = RegExp("^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"), didWarnValueNull = false, warnedProperties = {}, EVENT_NAME_REGEX = /^on./, INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/, rARIA = RegExp("^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"), rARIACamel = RegExp("^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"), isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i, currentReplayingEvent = null, restoreTarget = null, restoreQueue = null, isInsideEventHandler = false, canUseDOM = !(typeof window === "undefined" || typeof window.document === "undefined" || typeof window.document.createElement === "undefined"), passiveBrowserEventsSupported = false;
    if (canUseDOM)
      try {
        var options$jscomp$0 = {};
        Object.defineProperty(options$jscomp$0, "passive", {
          get: function() {
            passiveBrowserEventsSupported = true;
          }
        });
        window.addEventListener("test", options$jscomp$0, options$jscomp$0);
        window.removeEventListener("test", options$jscomp$0, options$jscomp$0);
      } catch (e7) {
        passiveBrowserEventsSupported = false;
      }
    var root = null, startText = null, fallbackText = null, EventInterface = {
      eventPhase: 0,
      bubbles: 0,
      cancelable: 0,
      timeStamp: function(event) {
        return event.timeStamp || Date.now();
      },
      defaultPrevented: 0,
      isTrusted: 0
    }, SyntheticEvent = createSyntheticEvent(EventInterface), UIEventInterface = assign({}, EventInterface, { view: 0, detail: 0 }), SyntheticUIEvent = createSyntheticEvent(UIEventInterface), lastMovementX, lastMovementY, lastMouseEvent, MouseEventInterface = assign({}, UIEventInterface, {
      screenX: 0,
      screenY: 0,
      clientX: 0,
      clientY: 0,
      pageX: 0,
      pageY: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      getModifierState: getEventModifierState,
      button: 0,
      buttons: 0,
      relatedTarget: function(event) {
        return event.relatedTarget === undefined ? event.fromElement === event.srcElement ? event.toElement : event.fromElement : event.relatedTarget;
      },
      movementX: function(event) {
        if ("movementX" in event)
          return event.movementX;
        event !== lastMouseEvent && (lastMouseEvent && event.type === "mousemove" ? (lastMovementX = event.screenX - lastMouseEvent.screenX, lastMovementY = event.screenY - lastMouseEvent.screenY) : lastMovementY = lastMovementX = 0, lastMouseEvent = event);
        return lastMovementX;
      },
      movementY: function(event) {
        return "movementY" in event ? event.movementY : lastMovementY;
      }
    }), SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface), DragEventInterface = assign({}, MouseEventInterface, { dataTransfer: 0 }), SyntheticDragEvent = createSyntheticEvent(DragEventInterface), FocusEventInterface = assign({}, UIEventInterface, { relatedTarget: 0 }), SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface), AnimationEventInterface = assign({}, EventInterface, {
      animationName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface), ClipboardEventInterface = assign({}, EventInterface, {
      clipboardData: function(event) {
        return "clipboardData" in event ? event.clipboardData : window.clipboardData;
      }
    }), SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface), CompositionEventInterface = assign({}, EventInterface, { data: 0 }), SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface), SyntheticInputEvent = SyntheticCompositionEvent, normalizeKey = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified"
    }, translateToKey = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    }, modifierKeyToProp = {
      Alt: "altKey",
      Control: "ctrlKey",
      Meta: "metaKey",
      Shift: "shiftKey"
    }, KeyboardEventInterface = assign({}, UIEventInterface, {
      key: function(nativeEvent) {
        if (nativeEvent.key) {
          var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
          if (key !== "Unidentified")
            return key;
        }
        return nativeEvent.type === "keypress" ? (nativeEvent = getEventCharCode(nativeEvent), nativeEvent === 13 ? "Enter" : String.fromCharCode(nativeEvent)) : nativeEvent.type === "keydown" || nativeEvent.type === "keyup" ? translateToKey[nativeEvent.keyCode] || "Unidentified" : "";
      },
      code: 0,
      location: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      repeat: 0,
      locale: 0,
      getModifierState: getEventModifierState,
      charCode: function(event) {
        return event.type === "keypress" ? getEventCharCode(event) : 0;
      },
      keyCode: function(event) {
        return event.type === "keydown" || event.type === "keyup" ? event.keyCode : 0;
      },
      which: function(event) {
        return event.type === "keypress" ? getEventCharCode(event) : event.type === "keydown" || event.type === "keyup" ? event.keyCode : 0;
      }
    }), SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface), PointerEventInterface = assign({}, MouseEventInterface, {
      pointerId: 0,
      width: 0,
      height: 0,
      pressure: 0,
      tangentialPressure: 0,
      tiltX: 0,
      tiltY: 0,
      twist: 0,
      pointerType: 0,
      isPrimary: 0
    }), SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface), TouchEventInterface = assign({}, UIEventInterface, {
      touches: 0,
      targetTouches: 0,
      changedTouches: 0,
      altKey: 0,
      metaKey: 0,
      ctrlKey: 0,
      shiftKey: 0,
      getModifierState: getEventModifierState
    }), SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface), TransitionEventInterface = assign({}, EventInterface, {
      propertyName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface), WheelEventInterface = assign({}, MouseEventInterface, {
      deltaX: function(event) {
        return "deltaX" in event ? event.deltaX : ("wheelDeltaX" in event) ? -event.wheelDeltaX : 0;
      },
      deltaY: function(event) {
        return "deltaY" in event ? event.deltaY : ("wheelDeltaY" in event) ? -event.wheelDeltaY : ("wheelDelta" in event) ? -event.wheelDelta : 0;
      },
      deltaZ: 0,
      deltaMode: 0
    }), SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface), ToggleEventInterface = assign({}, EventInterface, {
      newState: 0,
      oldState: 0
    }), SyntheticToggleEvent = createSyntheticEvent(ToggleEventInterface), END_KEYCODES = [9, 13, 27, 32], START_KEYCODE = 229, canUseCompositionEvent = canUseDOM && "CompositionEvent" in window, documentMode = null;
    canUseDOM && "documentMode" in document && (documentMode = document.documentMode);
    var canUseTextInputEvent = canUseDOM && "TextEvent" in window && !documentMode, useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || documentMode && 8 < documentMode && 11 >= documentMode), SPACEBAR_CODE = 32, SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE), hasSpaceKeypress = false, isComposing = false, supportedInputTypes = {
      color: true,
      date: true,
      datetime: true,
      "datetime-local": true,
      email: true,
      month: true,
      number: true,
      password: true,
      range: true,
      search: true,
      tel: true,
      text: true,
      time: true,
      url: true,
      week: true
    }, activeElement$1 = null, activeElementInst$1 = null, isInputEventSupported = false;
    canUseDOM && (isInputEventSupported = isEventSupported("input") && (!document.documentMode || 9 < document.documentMode));
    var objectIs = typeof Object.is === "function" ? Object.is : is, skipSelectionChangeEvent = canUseDOM && "documentMode" in document && 11 >= document.documentMode, activeElement = null, activeElementInst = null, lastSelection = null, mouseDown = false, vendorPrefixes = {
      animationend: makePrefixMap("Animation", "AnimationEnd"),
      animationiteration: makePrefixMap("Animation", "AnimationIteration"),
      animationstart: makePrefixMap("Animation", "AnimationStart"),
      transitionrun: makePrefixMap("Transition", "TransitionRun"),
      transitionstart: makePrefixMap("Transition", "TransitionStart"),
      transitioncancel: makePrefixMap("Transition", "TransitionCancel"),
      transitionend: makePrefixMap("Transition", "TransitionEnd")
    }, prefixedEventNames = {}, style = {};
    canUseDOM && (style = document.createElement("div").style, ("AnimationEvent" in window) || (delete vendorPrefixes.animationend.animation, delete vendorPrefixes.animationiteration.animation, delete vendorPrefixes.animationstart.animation), ("TransitionEvent" in window) || delete vendorPrefixes.transitionend.transition);
    var ANIMATION_END = getVendorPrefixedEventName("animationend"), ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration"), ANIMATION_START = getVendorPrefixedEventName("animationstart"), TRANSITION_RUN = getVendorPrefixedEventName("transitionrun"), TRANSITION_START = getVendorPrefixedEventName("transitionstart"), TRANSITION_CANCEL = getVendorPrefixedEventName("transitioncancel"), TRANSITION_END = getVendorPrefixedEventName("transitionend"), topLevelEventsToReactNames = new Map, simpleEventPluginEvents = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
    simpleEventPluginEvents.push("scrollEnd");
    var lastResetTime = 0;
    if (typeof performance === "object" && typeof performance.now === "function") {
      var localPerformance = performance;
      var getCurrentTime = function() {
        return localPerformance.now();
      };
    } else {
      var localDate = Date;
      getCurrentTime = function() {
        return localDate.now();
      };
    }
    var reportGlobalError = typeof reportError === "function" ? reportError : function(error) {
      if (typeof window === "object" && typeof window.ErrorEvent === "function") {
        var event = new window.ErrorEvent("error", {
          bubbles: true,
          cancelable: true,
          message: typeof error === "object" && error !== null && typeof error.message === "string" ? String(error.message) : String(error),
          error
        });
        if (!window.dispatchEvent(event))
          return;
      } else if (typeof process === "object" && typeof process.emit === "function") {
        process.emit("uncaughtException", error);
        return;
      }
      console.error(error);
    }, OMITTED_PROP_ERROR = "This object has been omitted by React in the console log to avoid sending too much data from the server. Try logging smaller or more specific objects.", EMPTY_ARRAY = 0, COMPLEX_ARRAY = 1, PRIMITIVE_ARRAY = 2, ENTRIES_ARRAY = 3, REMOVED = "", ADDED = "+", UNCHANGED = "", supportsUserTiming = typeof console !== "undefined" && typeof console.timeStamp === "function" && typeof performance !== "undefined" && typeof performance.measure === "function", COMPONENTS_TRACK = "Components ", LANES_TRACK_GROUP = "Scheduler ", currentTrack = "Blocking", alreadyWarnedForDeepEquality = false, reusableComponentDevToolDetails = {
      color: "primary",
      properties: null,
      tooltipText: "",
      track: COMPONENTS_TRACK
    }, reusableComponentOptions = {
      start: -0,
      end: -0,
      detail: { devtools: reusableComponentDevToolDetails }
    }, resuableChangedPropsEntry = ["Changed Props", ""], DEEP_EQUALITY_WARNING = "This component received deeply equal props. It might benefit from useMemo or the React Compiler in its owner.", reusableDeeplyEqualPropsEntry = ["Changed Props", DEEP_EQUALITY_WARNING], OffscreenVisible = 1, OffscreenPassiveEffectsConnected = 2, concurrentQueues = [], concurrentQueuesIndex = 0, concurrentlyUpdatedLanes = 0, emptyContextObject = {};
    Object.freeze(emptyContextObject);
    var resolveFamily = null, failedBoundaries = null, NoMode = 0, ConcurrentMode = 1, ProfileMode = 2, StrictLegacyMode = 8, StrictEffectsMode = 16, SuspenseyImagesMode = 32;
    var hasBadMapPolyfill = false;
    try {
      var nonExtensibleObject = Object.preventExtensions({});
      new Map([[nonExtensibleObject, null]]);
      new Set([nonExtensibleObject]);
    } catch (e$3) {
      hasBadMapPolyfill = true;
    }
    var CapturedStacks = new WeakMap, forkStack = [], forkStackIndex = 0, treeForkProvider = null, treeForkCount = 0, idStack = [], idStackIndex = 0, treeContextProvider = null, treeContextId = 1, treeContextOverflow = "", hydrationParentFiber = null, nextHydratableInstance = null, isHydrating = false, didSuspendOrErrorDEV = false, hydrationDiffRootDEV = null, hydrationErrors = null, rootOrSingletonContext = false, HydrationMismatchException = Error("Hydration Mismatch Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React."), valueCursor = createCursor(null);
    var rendererCursorDEV = createCursor(null);
    var rendererSigil = {};
    var currentlyRenderingFiber$1 = null, lastContextDependency = null, isDisallowedContextReadInDEV = false, AbortControllerLocal = typeof AbortController !== "undefined" ? AbortController : function() {
      var listeners = [], signal = this.signal = {
        aborted: false,
        addEventListener: function(type, listener) {
          listeners.push(listener);
        }
      };
      this.abort = function() {
        signal.aborted = true;
        listeners.forEach(function(listener) {
          return listener();
        });
      };
    }, scheduleCallback$2 = Scheduler.unstable_scheduleCallback, NormalPriority = Scheduler.unstable_NormalPriority, CacheContext = {
      $$typeof: REACT_CONTEXT_TYPE,
      Consumer: null,
      Provider: null,
      _currentValue: null,
      _currentValue2: null,
      _threadCount: 0,
      _currentRenderer: null,
      _currentRenderer2: null
    }, now = Scheduler.unstable_now, createTask = console.createTask ? console.createTask : function() {
      return null;
    }, SPAWNED_UPDATE = 1, PINGED_UPDATE = 2, renderStartTime = -0, commitStartTime = -0, commitEndTime = -0, commitErrors = null, profilerStartTime = -1.1, profilerEffectDuration = -0, componentEffectDuration = -0, componentEffectStartTime = -1.1, componentEffectEndTime = -1.1, componentEffectErrors = null, componentEffectSpawnedUpdate = false, blockingClampTime = -0, blockingUpdateTime = -1.1, blockingUpdateTask = null, blockingUpdateType = 0, blockingUpdateMethodName = null, blockingUpdateComponentName = null, blockingEventTime = -1.1, blockingEventType = null, blockingEventRepeatTime = -1.1, blockingSuspendedTime = -1.1, transitionClampTime = -0, transitionStartTime = -1.1, transitionUpdateTime = -1.1, transitionUpdateType = 0, transitionUpdateTask = null, transitionUpdateMethodName = null, transitionUpdateComponentName = null, transitionEventTime = -1.1, transitionEventType = null, transitionEventRepeatTime = -1.1, transitionSuspendedTime = -1.1, retryClampTime = -0, idleClampTime = -0, animatingLanes = 0, animatingTask = null, yieldReason = 0, yieldStartTime = -1.1, currentUpdateIsNested = false, nestedUpdateScheduled = false, currentEntangledListeners = null, currentEntangledPendingCount = 0, currentEntangledLane = 0, currentEntangledActionThenable = null, prevOnStartTransitionFinish = ReactSharedInternals.S;
    ReactSharedInternals.S = function(transition, returnValue) {
      globalMostRecentTransitionTime = now$1();
      if (typeof returnValue === "object" && returnValue !== null && typeof returnValue.then === "function") {
        if (0 > transitionStartTime && 0 > transitionUpdateTime) {
          transitionStartTime = now();
          var newEventTime = resolveEventTimeStamp(), newEventType = resolveEventType();
          if (newEventTime !== transitionEventRepeatTime || newEventType !== transitionEventType)
            transitionEventRepeatTime = -1.1;
          transitionEventTime = newEventTime;
          transitionEventType = newEventType;
        }
        entangleAsyncAction(transition, returnValue);
      }
      prevOnStartTransitionFinish !== null && prevOnStartTransitionFinish(transition, returnValue);
    };
    var resumedCache = createCursor(null), ReactStrictModeWarnings = {
      recordUnsafeLifecycleWarnings: function() {},
      flushPendingUnsafeLifecycleWarnings: function() {},
      recordLegacyContextWarning: function() {},
      flushLegacyContextWarning: function() {},
      discardPendingWarnings: function() {}
    }, pendingComponentWillMountWarnings = [], pendingUNSAFE_ComponentWillMountWarnings = [], pendingComponentWillReceivePropsWarnings = [], pendingUNSAFE_ComponentWillReceivePropsWarnings = [], pendingComponentWillUpdateWarnings = [], pendingUNSAFE_ComponentWillUpdateWarnings = [], didWarnAboutUnsafeLifecycles = new Set;
    ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function(fiber, instance) {
      didWarnAboutUnsafeLifecycles.has(fiber.type) || (typeof instance.componentWillMount === "function" && instance.componentWillMount.__suppressDeprecationWarning !== true && pendingComponentWillMountWarnings.push(fiber), fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillMount === "function" && pendingUNSAFE_ComponentWillMountWarnings.push(fiber), typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true && pendingComponentWillReceivePropsWarnings.push(fiber), fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillReceiveProps === "function" && pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber), typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true && pendingComponentWillUpdateWarnings.push(fiber), fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillUpdate === "function" && pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber));
    };
    ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function() {
      var componentWillMountUniqueNames = new Set;
      0 < pendingComponentWillMountWarnings.length && (pendingComponentWillMountWarnings.forEach(function(fiber) {
        componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
        didWarnAboutUnsafeLifecycles.add(fiber.type);
      }), pendingComponentWillMountWarnings = []);
      var UNSAFE_componentWillMountUniqueNames = new Set;
      0 < pendingUNSAFE_ComponentWillMountWarnings.length && (pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber) {
        UNSAFE_componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
        didWarnAboutUnsafeLifecycles.add(fiber.type);
      }), pendingUNSAFE_ComponentWillMountWarnings = []);
      var componentWillReceivePropsUniqueNames = new Set;
      0 < pendingComponentWillReceivePropsWarnings.length && (pendingComponentWillReceivePropsWarnings.forEach(function(fiber) {
        componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
        didWarnAboutUnsafeLifecycles.add(fiber.type);
      }), pendingComponentWillReceivePropsWarnings = []);
      var UNSAFE_componentWillReceivePropsUniqueNames = new Set;
      0 < pendingUNSAFE_ComponentWillReceivePropsWarnings.length && (pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function(fiber) {
        UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
        didWarnAboutUnsafeLifecycles.add(fiber.type);
      }), pendingUNSAFE_ComponentWillReceivePropsWarnings = []);
      var componentWillUpdateUniqueNames = new Set;
      0 < pendingComponentWillUpdateWarnings.length && (pendingComponentWillUpdateWarnings.forEach(function(fiber) {
        componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
        didWarnAboutUnsafeLifecycles.add(fiber.type);
      }), pendingComponentWillUpdateWarnings = []);
      var UNSAFE_componentWillUpdateUniqueNames = new Set;
      0 < pendingUNSAFE_ComponentWillUpdateWarnings.length && (pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber) {
        UNSAFE_componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
        didWarnAboutUnsafeLifecycles.add(fiber.type);
      }), pendingUNSAFE_ComponentWillUpdateWarnings = []);
      if (0 < UNSAFE_componentWillMountUniqueNames.size) {
        var sortedNames = setToSortedString(UNSAFE_componentWillMountUniqueNames);
        console.error(`Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.

Please update the following components: %s`, sortedNames);
      }
      0 < UNSAFE_componentWillReceivePropsUniqueNames.size && (sortedNames = setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames), console.error(`Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state

Please update the following components: %s`, sortedNames));
      0 < UNSAFE_componentWillUpdateUniqueNames.size && (sortedNames = setToSortedString(UNSAFE_componentWillUpdateUniqueNames), console.error(`Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.

Please update the following components: %s`, sortedNames));
      0 < componentWillMountUniqueNames.size && (sortedNames = setToSortedString(componentWillMountUniqueNames), console.warn(`componentWillMount has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.
* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, sortedNames));
      0 < componentWillReceivePropsUniqueNames.size && (sortedNames = setToSortedString(componentWillReceivePropsUniqueNames), console.warn(`componentWillReceiveProps has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state
* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, sortedNames));
      0 < componentWillUpdateUniqueNames.size && (sortedNames = setToSortedString(componentWillUpdateUniqueNames), console.warn(`componentWillUpdate has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, sortedNames));
    };
    var pendingLegacyContextWarning = new Map, didWarnAboutLegacyContext = new Set;
    ReactStrictModeWarnings.recordLegacyContextWarning = function(fiber, instance) {
      var strictRoot = null;
      for (var node = fiber;node !== null; )
        node.mode & StrictLegacyMode && (strictRoot = node), node = node.return;
      strictRoot === null ? console.error("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.") : !didWarnAboutLegacyContext.has(fiber.type) && (node = pendingLegacyContextWarning.get(strictRoot), fiber.type.contextTypes != null || fiber.type.childContextTypes != null || instance !== null && typeof instance.getChildContext === "function") && (node === undefined && (node = [], pendingLegacyContextWarning.set(strictRoot, node)), node.push(fiber));
    };
    ReactStrictModeWarnings.flushLegacyContextWarning = function() {
      pendingLegacyContextWarning.forEach(function(fiberArray) {
        if (fiberArray.length !== 0) {
          var firstFiber = fiberArray[0], uniqueNames = new Set;
          fiberArray.forEach(function(fiber) {
            uniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
            didWarnAboutLegacyContext.add(fiber.type);
          });
          var sortedNames = setToSortedString(uniqueNames);
          runWithFiberInDEV(firstFiber, function() {
            console.error(`Legacy context API has been detected within a strict-mode tree.

The old API will be supported in all 16.x releases, but applications using it should migrate to the new version.

Please update the following components: %s

Learn more about this warning here: https://react.dev/link/legacy-context`, sortedNames);
          });
        }
      });
    };
    ReactStrictModeWarnings.discardPendingWarnings = function() {
      pendingComponentWillMountWarnings = [];
      pendingUNSAFE_ComponentWillMountWarnings = [];
      pendingComponentWillReceivePropsWarnings = [];
      pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
      pendingComponentWillUpdateWarnings = [];
      pendingUNSAFE_ComponentWillUpdateWarnings = [];
      pendingLegacyContextWarning = new Map;
    };
    var callComponent = {
      react_stack_bottom_frame: function(Component, props, secondArg) {
        var wasRendering = isRendering;
        isRendering = true;
        try {
          return Component(props, secondArg);
        } finally {
          isRendering = wasRendering;
        }
      }
    }, callComponentInDEV = callComponent.react_stack_bottom_frame.bind(callComponent), callRender = {
      react_stack_bottom_frame: function(instance) {
        var wasRendering = isRendering;
        isRendering = true;
        try {
          return instance.render();
        } finally {
          isRendering = wasRendering;
        }
      }
    }, callRenderInDEV = callRender.react_stack_bottom_frame.bind(callRender), callComponentDidMount = {
      react_stack_bottom_frame: function(finishedWork, instance) {
        try {
          instance.componentDidMount();
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
    }, callComponentDidMountInDEV = callComponentDidMount.react_stack_bottom_frame.bind(callComponentDidMount), callComponentDidUpdate = {
      react_stack_bottom_frame: function(finishedWork, instance, prevProps, prevState, snapshot) {
        try {
          instance.componentDidUpdate(prevProps, prevState, snapshot);
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
    }, callComponentDidUpdateInDEV = callComponentDidUpdate.react_stack_bottom_frame.bind(callComponentDidUpdate), callComponentDidCatch = {
      react_stack_bottom_frame: function(instance, errorInfo) {
        var stack = errorInfo.stack;
        instance.componentDidCatch(errorInfo.value, {
          componentStack: stack !== null ? stack : ""
        });
      }
    }, callComponentDidCatchInDEV = callComponentDidCatch.react_stack_bottom_frame.bind(callComponentDidCatch), callComponentWillUnmount = {
      react_stack_bottom_frame: function(current2, nearestMountedAncestor, instance) {
        try {
          instance.componentWillUnmount();
        } catch (error) {
          captureCommitPhaseError(current2, nearestMountedAncestor, error);
        }
      }
    }, callComponentWillUnmountInDEV = callComponentWillUnmount.react_stack_bottom_frame.bind(callComponentWillUnmount), callCreate = {
      react_stack_bottom_frame: function(effect) {
        var create = effect.create;
        effect = effect.inst;
        create = create();
        return effect.destroy = create;
      }
    }, callCreateInDEV = callCreate.react_stack_bottom_frame.bind(callCreate), callDestroy = {
      react_stack_bottom_frame: function(current2, nearestMountedAncestor, destroy) {
        try {
          destroy();
        } catch (error) {
          captureCommitPhaseError(current2, nearestMountedAncestor, error);
        }
      }
    }, callDestroyInDEV = callDestroy.react_stack_bottom_frame.bind(callDestroy), callLazyInit = {
      react_stack_bottom_frame: function(lazy) {
        var init2 = lazy._init;
        return init2(lazy._payload);
      }
    }, callLazyInitInDEV = callLazyInit.react_stack_bottom_frame.bind(callLazyInit), SuspenseException = Error("Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`."), SuspenseyCommitException = Error("Suspense Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React."), SuspenseActionException = Error("Suspense Exception: This is not a real error! It's an implementation detail of `useActionState` to interrupt the current render. You must either rethrow it immediately, or move the `useActionState` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary."), noopSuspenseyCommitThenable = {
      then: function() {
        console.error('Internal React error: A listener was unexpectedly attached to a "noop" thenable. This is a bug in React. Please file an issue.');
      }
    }, suspendedThenable = null, needsToResetSuspendedThenableDEV = false, thenableState$1 = null, thenableIndexCounter$1 = 0, currentDebugInfo = null, didWarnAboutMaps;
    var didWarnAboutGenerators = didWarnAboutMaps = false;
    var ownerHasKeyUseWarning = {};
    var ownerHasFunctionTypeWarning = {};
    var ownerHasSymbolTypeWarning = {};
    warnForMissingKey = function(returnFiber, workInProgress2, child) {
      if (child !== null && typeof child === "object" && child._store && (!child._store.validated && child.key == null || child._store.validated === 2)) {
        if (typeof child._store !== "object")
          throw Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
        child._store.validated = 1;
        var componentName2 = getComponentNameFromFiber(returnFiber), componentKey = componentName2 || "null";
        if (!ownerHasKeyUseWarning[componentKey]) {
          ownerHasKeyUseWarning[componentKey] = true;
          child = child._owner;
          returnFiber = returnFiber._debugOwner;
          var currentComponentErrorInfo = "";
          returnFiber && typeof returnFiber.tag === "number" && (componentKey = getComponentNameFromFiber(returnFiber)) && (currentComponentErrorInfo = `

Check the render method of \`` + componentKey + "`.");
          currentComponentErrorInfo || componentName2 && (currentComponentErrorInfo = `

Check the top-level render call using <` + componentName2 + ">.");
          var childOwnerAppendix = "";
          child != null && returnFiber !== child && (componentName2 = null, typeof child.tag === "number" ? componentName2 = getComponentNameFromFiber(child) : typeof child.name === "string" && (componentName2 = child.name), componentName2 && (childOwnerAppendix = " It was passed a child from " + componentName2 + "."));
          runWithFiberInDEV(workInProgress2, function() {
            console.error('Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.', currentComponentErrorInfo, childOwnerAppendix);
          });
        }
      }
    };
    var reconcileChildFibers = createChildReconciler(true), mountChildFibers = createChildReconciler(false), UpdateState = 0, ReplaceState = 1, ForceUpdate = 2, CaptureUpdate = 3, hasForceUpdate = false;
    var didWarnUpdateInsideUpdate = false;
    var currentlyProcessingQueue = null;
    var didReadFromEntangledAsyncAction = false, currentTreeHiddenStackCursor = createCursor(null), prevEntangledRenderLanesCursor = createCursor(0), suspenseHandlerStackCursor = createCursor(null), shellBoundary = null, SubtreeSuspenseContextMask = 1, ForceSuspenseFallback = 2, suspenseStackCursor = createCursor(0), NoFlags = 0, HasEffect = 1, Insertion = 2, Layout = 4, Passive = 8, didWarnUncachedGetSnapshot;
    var didWarnAboutMismatchedHooksForComponent = new Set;
    var didWarnAboutUseWrappedInTryCatch = new Set;
    var didWarnAboutAsyncClientComponent = new Set;
    var didWarnAboutUseFormState = new Set;
    var renderLanes = 0, currentlyRenderingFiber = null, currentHook = null, workInProgressHook = null, didScheduleRenderPhaseUpdate = false, didScheduleRenderPhaseUpdateDuringThisPass = false, shouldDoubleInvokeUserFnsInHooksDEV = false, localIdCounter = 0, thenableIndexCounter = 0, thenableState = null, globalClientIdCounter = 0, RE_RENDER_LIMIT = 25, currentHookNameInDev = null, hookTypesDev = null, hookTypesUpdateIndexDev = -1, ignorePreviousDependencies = false, ContextOnlyDispatcher = {
      readContext,
      use,
      useCallback: throwInvalidHookError,
      useContext: throwInvalidHookError,
      useEffect: throwInvalidHookError,
      useImperativeHandle: throwInvalidHookError,
      useLayoutEffect: throwInvalidHookError,
      useInsertionEffect: throwInvalidHookError,
      useMemo: throwInvalidHookError,
      useReducer: throwInvalidHookError,
      useRef: throwInvalidHookError,
      useState: throwInvalidHookError,
      useDebugValue: throwInvalidHookError,
      useDeferredValue: throwInvalidHookError,
      useTransition: throwInvalidHookError,
      useSyncExternalStore: throwInvalidHookError,
      useId: throwInvalidHookError,
      useHostTransitionStatus: throwInvalidHookError,
      useFormState: throwInvalidHookError,
      useActionState: throwInvalidHookError,
      useOptimistic: throwInvalidHookError,
      useMemoCache: throwInvalidHookError,
      useCacheRefresh: throwInvalidHookError
    };
    ContextOnlyDispatcher.useEffectEvent = throwInvalidHookError;
    var HooksDispatcherOnMountInDEV = null, HooksDispatcherOnMountWithHookTypesInDEV = null, HooksDispatcherOnUpdateInDEV = null, HooksDispatcherOnRerenderInDEV = null, InvalidNestedHooksDispatcherOnMountInDEV = null, InvalidNestedHooksDispatcherOnUpdateInDEV = null, InvalidNestedHooksDispatcherOnRerenderInDEV = null;
    HooksDispatcherOnMountInDEV = {
      readContext: function(context) {
        return readContext(context);
      },
      use,
      useCallback: function(callback, deps) {
        currentHookNameInDev = "useCallback";
        mountHookTypesDev();
        checkDepsAreArrayDev(deps);
        return mountCallback(callback, deps);
      },
      useContext: function(context) {
        currentHookNameInDev = "useContext";
        mountHookTypesDev();
        return readContext(context);
      },
      useEffect: function(create, deps) {
        currentHookNameInDev = "useEffect";
        mountHookTypesDev();
        checkDepsAreArrayDev(deps);
        return mountEffect(create, deps);
      },
      useImperativeHandle: function(ref, create, deps) {
        currentHookNameInDev = "useImperativeHandle";
        mountHookTypesDev();
        checkDepsAreArrayDev(deps);
        return mountImperativeHandle(ref, create, deps);
      },
      useInsertionEffect: function(create, deps) {
        currentHookNameInDev = "useInsertionEffect";
        mountHookTypesDev();
        checkDepsAreArrayDev(deps);
        mountEffectImpl(4, Insertion, create, deps);
      },
      useLayoutEffect: function(create, deps) {
        currentHookNameInDev = "useLayoutEffect";
        mountHookTypesDev();
        checkDepsAreArrayDev(deps);
        return mountLayoutEffect(create, deps);
      },
      useMemo: function(create, deps) {
        currentHookNameInDev = "useMemo";
        mountHookTypesDev();
        checkDepsAreArrayDev(deps);
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
        try {
          return mountMemo(create, deps);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useReducer: function(reducer, initialArg, init2) {
        currentHookNameInDev = "useReducer";
        mountHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
        try {
          return mountReducer(reducer, initialArg, init2);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useRef: function(initialValue) {
        currentHookNameInDev = "useRef";
        mountHookTypesDev();
        return mountRef(initialValue);
      },
      useState: function(initialState) {
        currentHookNameInDev = "useState";
        mountHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
        try {
          return mountState(initialState);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useDebugValue: function() {
        currentHookNameInDev = "useDebugValue";
        mountHookTypesDev();
      },
      useDeferredValue: function(value, initialValue) {
        currentHookNameInDev = "useDeferredValue";
        mountHookTypesDev();
        return mountDeferredValue(value, initialValue);
      },
      useTransition: function() {
        currentHookNameInDev = "useTransition";
        mountHookTypesDev();
        return mountTransition();
      },
      useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
        currentHookNameInDev = "useSyncExternalStore";
        mountHookTypesDev();
        return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
      },
      useId: function() {
        currentHookNameInDev = "useId";
        mountHookTypesDev();
        return mountId();
      },
      useFormState: function(action, initialState) {
        currentHookNameInDev = "useFormState";
        mountHookTypesDev();
        warnOnUseFormStateInDev();
        return mountActionState(action, initialState);
      },
      useActionState: function(action, initialState) {
        currentHookNameInDev = "useActionState";
        mountHookTypesDev();
        return mountActionState(action, initialState);
      },
      useOptimistic: function(passthrough) {
        currentHookNameInDev = "useOptimistic";
        mountHookTypesDev();
        return mountOptimistic(passthrough);
      },
      useHostTransitionStatus,
      useMemoCache,
      useCacheRefresh: function() {
        currentHookNameInDev = "useCacheRefresh";
        mountHookTypesDev();
        return mountRefresh();
      },
      useEffectEvent: function(callback) {
        currentHookNameInDev = "useEffectEvent";
        mountHookTypesDev();
        return mountEvent(callback);
      }
    };
    HooksDispatcherOnMountWithHookTypesInDEV = {
      readContext: function(context) {
        return readContext(context);
      },
      use,
      useCallback: function(callback, deps) {
        currentHookNameInDev = "useCallback";
        updateHookTypesDev();
        return mountCallback(callback, deps);
      },
      useContext: function(context) {
        currentHookNameInDev = "useContext";
        updateHookTypesDev();
        return readContext(context);
      },
      useEffect: function(create, deps) {
        currentHookNameInDev = "useEffect";
        updateHookTypesDev();
        return mountEffect(create, deps);
      },
      useImperativeHandle: function(ref, create, deps) {
        currentHookNameInDev = "useImperativeHandle";
        updateHookTypesDev();
        return mountImperativeHandle(ref, create, deps);
      },
      useInsertionEffect: function(create, deps) {
        currentHookNameInDev = "useInsertionEffect";
        updateHookTypesDev();
        mountEffectImpl(4, Insertion, create, deps);
      },
      useLayoutEffect: function(create, deps) {
        currentHookNameInDev = "useLayoutEffect";
        updateHookTypesDev();
        return mountLayoutEffect(create, deps);
      },
      useMemo: function(create, deps) {
        currentHookNameInDev = "useMemo";
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
        try {
          return mountMemo(create, deps);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useReducer: function(reducer, initialArg, init2) {
        currentHookNameInDev = "useReducer";
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
        try {
          return mountReducer(reducer, initialArg, init2);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useRef: function(initialValue) {
        currentHookNameInDev = "useRef";
        updateHookTypesDev();
        return mountRef(initialValue);
      },
      useState: function(initialState) {
        currentHookNameInDev = "useState";
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
        try {
          return mountState(initialState);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useDebugValue: function() {
        currentHookNameInDev = "useDebugValue";
        updateHookTypesDev();
      },
      useDeferredValue: function(value, initialValue) {
        currentHookNameInDev = "useDeferredValue";
        updateHookTypesDev();
        return mountDeferredValue(value, initialValue);
      },
      useTransition: function() {
        currentHookNameInDev = "useTransition";
        updateHookTypesDev();
        return mountTransition();
      },
      useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
        currentHookNameInDev = "useSyncExternalStore";
        updateHookTypesDev();
        return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
      },
      useId: function() {
        currentHookNameInDev = "useId";
        updateHookTypesDev();
        return mountId();
      },
      useActionState: function(action, initialState) {
        currentHookNameInDev = "useActionState";
        updateHookTypesDev();
        return mountActionState(action, initialState);
      },
      useFormState: function(action, initialState) {
        currentHookNameInDev = "useFormState";
        updateHookTypesDev();
        warnOnUseFormStateInDev();
        return mountActionState(action, initialState);
      },
      useOptimistic: function(passthrough) {
        currentHookNameInDev = "useOptimistic";
        updateHookTypesDev();
        return mountOptimistic(passthrough);
      },
      useHostTransitionStatus,
      useMemoCache,
      useCacheRefresh: function() {
        currentHookNameInDev = "useCacheRefresh";
        updateHookTypesDev();
        return mountRefresh();
      },
      useEffectEvent: function(callback) {
        currentHookNameInDev = "useEffectEvent";
        updateHookTypesDev();
        return mountEvent(callback);
      }
    };
    HooksDispatcherOnUpdateInDEV = {
      readContext: function(context) {
        return readContext(context);
      },
      use,
      useCallback: function(callback, deps) {
        currentHookNameInDev = "useCallback";
        updateHookTypesDev();
        return updateCallback(callback, deps);
      },
      useContext: function(context) {
        currentHookNameInDev = "useContext";
        updateHookTypesDev();
        return readContext(context);
      },
      useEffect: function(create, deps) {
        currentHookNameInDev = "useEffect";
        updateHookTypesDev();
        updateEffectImpl(2048, Passive, create, deps);
      },
      useImperativeHandle: function(ref, create, deps) {
        currentHookNameInDev = "useImperativeHandle";
        updateHookTypesDev();
        return updateImperativeHandle(ref, create, deps);
      },
      useInsertionEffect: function(create, deps) {
        currentHookNameInDev = "useInsertionEffect";
        updateHookTypesDev();
        return updateEffectImpl(4, Insertion, create, deps);
      },
      useLayoutEffect: function(create, deps) {
        currentHookNameInDev = "useLayoutEffect";
        updateHookTypesDev();
        return updateEffectImpl(4, Layout, create, deps);
      },
      useMemo: function(create, deps) {
        currentHookNameInDev = "useMemo";
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        try {
          return updateMemo(create, deps);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useReducer: function(reducer, initialArg, init2) {
        currentHookNameInDev = "useReducer";
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        try {
          return updateReducer(reducer, initialArg, init2);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useRef: function() {
        currentHookNameInDev = "useRef";
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useState: function() {
        currentHookNameInDev = "useState";
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        try {
          return updateReducer(basicStateReducer);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useDebugValue: function() {
        currentHookNameInDev = "useDebugValue";
        updateHookTypesDev();
      },
      useDeferredValue: function(value, initialValue) {
        currentHookNameInDev = "useDeferredValue";
        updateHookTypesDev();
        return updateDeferredValue(value, initialValue);
      },
      useTransition: function() {
        currentHookNameInDev = "useTransition";
        updateHookTypesDev();
        return updateTransition();
      },
      useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
        currentHookNameInDev = "useSyncExternalStore";
        updateHookTypesDev();
        return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
      },
      useId: function() {
        currentHookNameInDev = "useId";
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useFormState: function(action) {
        currentHookNameInDev = "useFormState";
        updateHookTypesDev();
        warnOnUseFormStateInDev();
        return updateActionState(action);
      },
      useActionState: function(action) {
        currentHookNameInDev = "useActionState";
        updateHookTypesDev();
        return updateActionState(action);
      },
      useOptimistic: function(passthrough, reducer) {
        currentHookNameInDev = "useOptimistic";
        updateHookTypesDev();
        return updateOptimistic(passthrough, reducer);
      },
      useHostTransitionStatus,
      useMemoCache,
      useCacheRefresh: function() {
        currentHookNameInDev = "useCacheRefresh";
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useEffectEvent: function(callback) {
        currentHookNameInDev = "useEffectEvent";
        updateHookTypesDev();
        return updateEvent(callback);
      }
    };
    HooksDispatcherOnRerenderInDEV = {
      readContext: function(context) {
        return readContext(context);
      },
      use,
      useCallback: function(callback, deps) {
        currentHookNameInDev = "useCallback";
        updateHookTypesDev();
        return updateCallback(callback, deps);
      },
      useContext: function(context) {
        currentHookNameInDev = "useContext";
        updateHookTypesDev();
        return readContext(context);
      },
      useEffect: function(create, deps) {
        currentHookNameInDev = "useEffect";
        updateHookTypesDev();
        updateEffectImpl(2048, Passive, create, deps);
      },
      useImperativeHandle: function(ref, create, deps) {
        currentHookNameInDev = "useImperativeHandle";
        updateHookTypesDev();
        return updateImperativeHandle(ref, create, deps);
      },
      useInsertionEffect: function(create, deps) {
        currentHookNameInDev = "useInsertionEffect";
        updateHookTypesDev();
        return updateEffectImpl(4, Insertion, create, deps);
      },
      useLayoutEffect: function(create, deps) {
        currentHookNameInDev = "useLayoutEffect";
        updateHookTypesDev();
        return updateEffectImpl(4, Layout, create, deps);
      },
      useMemo: function(create, deps) {
        currentHookNameInDev = "useMemo";
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;
        try {
          return updateMemo(create, deps);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useReducer: function(reducer, initialArg, init2) {
        currentHookNameInDev = "useReducer";
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;
        try {
          return rerenderReducer(reducer, initialArg, init2);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useRef: function() {
        currentHookNameInDev = "useRef";
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useState: function() {
        currentHookNameInDev = "useState";
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;
        try {
          return rerenderReducer(basicStateReducer);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useDebugValue: function() {
        currentHookNameInDev = "useDebugValue";
        updateHookTypesDev();
      },
      useDeferredValue: function(value, initialValue) {
        currentHookNameInDev = "useDeferredValue";
        updateHookTypesDev();
        return rerenderDeferredValue(value, initialValue);
      },
      useTransition: function() {
        currentHookNameInDev = "useTransition";
        updateHookTypesDev();
        return rerenderTransition();
      },
      useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
        currentHookNameInDev = "useSyncExternalStore";
        updateHookTypesDev();
        return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
      },
      useId: function() {
        currentHookNameInDev = "useId";
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useFormState: function(action) {
        currentHookNameInDev = "useFormState";
        updateHookTypesDev();
        warnOnUseFormStateInDev();
        return rerenderActionState(action);
      },
      useActionState: function(action) {
        currentHookNameInDev = "useActionState";
        updateHookTypesDev();
        return rerenderActionState(action);
      },
      useOptimistic: function(passthrough, reducer) {
        currentHookNameInDev = "useOptimistic";
        updateHookTypesDev();
        return rerenderOptimistic(passthrough, reducer);
      },
      useHostTransitionStatus,
      useMemoCache,
      useCacheRefresh: function() {
        currentHookNameInDev = "useCacheRefresh";
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useEffectEvent: function(callback) {
        currentHookNameInDev = "useEffectEvent";
        updateHookTypesDev();
        return updateEvent(callback);
      }
    };
    InvalidNestedHooksDispatcherOnMountInDEV = {
      readContext: function(context) {
        warnInvalidContextAccess();
        return readContext(context);
      },
      use: function(usable) {
        warnInvalidHookAccess();
        return use(usable);
      },
      useCallback: function(callback, deps) {
        currentHookNameInDev = "useCallback";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountCallback(callback, deps);
      },
      useContext: function(context) {
        currentHookNameInDev = "useContext";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return readContext(context);
      },
      useEffect: function(create, deps) {
        currentHookNameInDev = "useEffect";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountEffect(create, deps);
      },
      useImperativeHandle: function(ref, create, deps) {
        currentHookNameInDev = "useImperativeHandle";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountImperativeHandle(ref, create, deps);
      },
      useInsertionEffect: function(create, deps) {
        currentHookNameInDev = "useInsertionEffect";
        warnInvalidHookAccess();
        mountHookTypesDev();
        mountEffectImpl(4, Insertion, create, deps);
      },
      useLayoutEffect: function(create, deps) {
        currentHookNameInDev = "useLayoutEffect";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountLayoutEffect(create, deps);
      },
      useMemo: function(create, deps) {
        currentHookNameInDev = "useMemo";
        warnInvalidHookAccess();
        mountHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
        try {
          return mountMemo(create, deps);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useReducer: function(reducer, initialArg, init2) {
        currentHookNameInDev = "useReducer";
        warnInvalidHookAccess();
        mountHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
        try {
          return mountReducer(reducer, initialArg, init2);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useRef: function(initialValue) {
        currentHookNameInDev = "useRef";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountRef(initialValue);
      },
      useState: function(initialState) {
        currentHookNameInDev = "useState";
        warnInvalidHookAccess();
        mountHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
        try {
          return mountState(initialState);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useDebugValue: function() {
        currentHookNameInDev = "useDebugValue";
        warnInvalidHookAccess();
        mountHookTypesDev();
      },
      useDeferredValue: function(value, initialValue) {
        currentHookNameInDev = "useDeferredValue";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountDeferredValue(value, initialValue);
      },
      useTransition: function() {
        currentHookNameInDev = "useTransition";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountTransition();
      },
      useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
        currentHookNameInDev = "useSyncExternalStore";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
      },
      useId: function() {
        currentHookNameInDev = "useId";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountId();
      },
      useFormState: function(action, initialState) {
        currentHookNameInDev = "useFormState";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountActionState(action, initialState);
      },
      useActionState: function(action, initialState) {
        currentHookNameInDev = "useActionState";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountActionState(action, initialState);
      },
      useOptimistic: function(passthrough) {
        currentHookNameInDev = "useOptimistic";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountOptimistic(passthrough);
      },
      useMemoCache: function(size) {
        warnInvalidHookAccess();
        return useMemoCache(size);
      },
      useHostTransitionStatus,
      useCacheRefresh: function() {
        currentHookNameInDev = "useCacheRefresh";
        mountHookTypesDev();
        return mountRefresh();
      },
      useEffectEvent: function(callback) {
        currentHookNameInDev = "useEffectEvent";
        warnInvalidHookAccess();
        mountHookTypesDev();
        return mountEvent(callback);
      }
    };
    InvalidNestedHooksDispatcherOnUpdateInDEV = {
      readContext: function(context) {
        warnInvalidContextAccess();
        return readContext(context);
      },
      use: function(usable) {
        warnInvalidHookAccess();
        return use(usable);
      },
      useCallback: function(callback, deps) {
        currentHookNameInDev = "useCallback";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateCallback(callback, deps);
      },
      useContext: function(context) {
        currentHookNameInDev = "useContext";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return readContext(context);
      },
      useEffect: function(create, deps) {
        currentHookNameInDev = "useEffect";
        warnInvalidHookAccess();
        updateHookTypesDev();
        updateEffectImpl(2048, Passive, create, deps);
      },
      useImperativeHandle: function(ref, create, deps) {
        currentHookNameInDev = "useImperativeHandle";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateImperativeHandle(ref, create, deps);
      },
      useInsertionEffect: function(create, deps) {
        currentHookNameInDev = "useInsertionEffect";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateEffectImpl(4, Insertion, create, deps);
      },
      useLayoutEffect: function(create, deps) {
        currentHookNameInDev = "useLayoutEffect";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateEffectImpl(4, Layout, create, deps);
      },
      useMemo: function(create, deps) {
        currentHookNameInDev = "useMemo";
        warnInvalidHookAccess();
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        try {
          return updateMemo(create, deps);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useReducer: function(reducer, initialArg, init2) {
        currentHookNameInDev = "useReducer";
        warnInvalidHookAccess();
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        try {
          return updateReducer(reducer, initialArg, init2);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useRef: function() {
        currentHookNameInDev = "useRef";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useState: function() {
        currentHookNameInDev = "useState";
        warnInvalidHookAccess();
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        try {
          return updateReducer(basicStateReducer);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useDebugValue: function() {
        currentHookNameInDev = "useDebugValue";
        warnInvalidHookAccess();
        updateHookTypesDev();
      },
      useDeferredValue: function(value, initialValue) {
        currentHookNameInDev = "useDeferredValue";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateDeferredValue(value, initialValue);
      },
      useTransition: function() {
        currentHookNameInDev = "useTransition";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateTransition();
      },
      useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
        currentHookNameInDev = "useSyncExternalStore";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
      },
      useId: function() {
        currentHookNameInDev = "useId";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useFormState: function(action) {
        currentHookNameInDev = "useFormState";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateActionState(action);
      },
      useActionState: function(action) {
        currentHookNameInDev = "useActionState";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateActionState(action);
      },
      useOptimistic: function(passthrough, reducer) {
        currentHookNameInDev = "useOptimistic";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateOptimistic(passthrough, reducer);
      },
      useMemoCache: function(size) {
        warnInvalidHookAccess();
        return useMemoCache(size);
      },
      useHostTransitionStatus,
      useCacheRefresh: function() {
        currentHookNameInDev = "useCacheRefresh";
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useEffectEvent: function(callback) {
        currentHookNameInDev = "useEffectEvent";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateEvent(callback);
      }
    };
    InvalidNestedHooksDispatcherOnRerenderInDEV = {
      readContext: function(context) {
        warnInvalidContextAccess();
        return readContext(context);
      },
      use: function(usable) {
        warnInvalidHookAccess();
        return use(usable);
      },
      useCallback: function(callback, deps) {
        currentHookNameInDev = "useCallback";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateCallback(callback, deps);
      },
      useContext: function(context) {
        currentHookNameInDev = "useContext";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return readContext(context);
      },
      useEffect: function(create, deps) {
        currentHookNameInDev = "useEffect";
        warnInvalidHookAccess();
        updateHookTypesDev();
        updateEffectImpl(2048, Passive, create, deps);
      },
      useImperativeHandle: function(ref, create, deps) {
        currentHookNameInDev = "useImperativeHandle";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateImperativeHandle(ref, create, deps);
      },
      useInsertionEffect: function(create, deps) {
        currentHookNameInDev = "useInsertionEffect";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateEffectImpl(4, Insertion, create, deps);
      },
      useLayoutEffect: function(create, deps) {
        currentHookNameInDev = "useLayoutEffect";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateEffectImpl(4, Layout, create, deps);
      },
      useMemo: function(create, deps) {
        currentHookNameInDev = "useMemo";
        warnInvalidHookAccess();
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        try {
          return updateMemo(create, deps);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useReducer: function(reducer, initialArg, init2) {
        currentHookNameInDev = "useReducer";
        warnInvalidHookAccess();
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        try {
          return rerenderReducer(reducer, initialArg, init2);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useRef: function() {
        currentHookNameInDev = "useRef";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useState: function() {
        currentHookNameInDev = "useState";
        warnInvalidHookAccess();
        updateHookTypesDev();
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        try {
          return rerenderReducer(basicStateReducer);
        } finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      },
      useDebugValue: function() {
        currentHookNameInDev = "useDebugValue";
        warnInvalidHookAccess();
        updateHookTypesDev();
      },
      useDeferredValue: function(value, initialValue) {
        currentHookNameInDev = "useDeferredValue";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return rerenderDeferredValue(value, initialValue);
      },
      useTransition: function() {
        currentHookNameInDev = "useTransition";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return rerenderTransition();
      },
      useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
        currentHookNameInDev = "useSyncExternalStore";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
      },
      useId: function() {
        currentHookNameInDev = "useId";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useFormState: function(action) {
        currentHookNameInDev = "useFormState";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return rerenderActionState(action);
      },
      useActionState: function(action) {
        currentHookNameInDev = "useActionState";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return rerenderActionState(action);
      },
      useOptimistic: function(passthrough, reducer) {
        currentHookNameInDev = "useOptimistic";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return rerenderOptimistic(passthrough, reducer);
      },
      useMemoCache: function(size) {
        warnInvalidHookAccess();
        return useMemoCache(size);
      },
      useHostTransitionStatus,
      useCacheRefresh: function() {
        currentHookNameInDev = "useCacheRefresh";
        updateHookTypesDev();
        return updateWorkInProgressHook().memoizedState;
      },
      useEffectEvent: function(callback) {
        currentHookNameInDev = "useEffectEvent";
        warnInvalidHookAccess();
        updateHookTypesDev();
        return updateEvent(callback);
      }
    };
    var fakeInternalInstance = {};
    var didWarnAboutStateAssignmentForComponent = new Set;
    var didWarnAboutUninitializedState = new Set;
    var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set;
    var didWarnAboutLegacyLifecyclesAndDerivedState = new Set;
    var didWarnAboutDirectlyAssigningPropsToState = new Set;
    var didWarnAboutUndefinedDerivedState = new Set;
    var didWarnAboutContextTypes$1 = new Set;
    var didWarnAboutChildContextTypes = new Set;
    var didWarnAboutInvalidateContextType = new Set;
    var didWarnOnInvalidCallback = new Set;
    Object.freeze(fakeInternalInstance);
    var classComponentUpdater = {
      enqueueSetState: function(inst, payload, callback) {
        inst = inst._reactInternals;
        var lane = requestUpdateLane(inst), update = createUpdate(lane);
        update.payload = payload;
        callback !== undefined && callback !== null && (warnOnInvalidCallback(callback), update.callback = callback);
        payload = enqueueUpdate(inst, update, lane);
        payload !== null && (startUpdateTimerByLane(lane, "this.setState()", inst), scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
      },
      enqueueReplaceState: function(inst, payload, callback) {
        inst = inst._reactInternals;
        var lane = requestUpdateLane(inst), update = createUpdate(lane);
        update.tag = ReplaceState;
        update.payload = payload;
        callback !== undefined && callback !== null && (warnOnInvalidCallback(callback), update.callback = callback);
        payload = enqueueUpdate(inst, update, lane);
        payload !== null && (startUpdateTimerByLane(lane, "this.replaceState()", inst), scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
      },
      enqueueForceUpdate: function(inst, callback) {
        inst = inst._reactInternals;
        var lane = requestUpdateLane(inst), update = createUpdate(lane);
        update.tag = ForceUpdate;
        callback !== undefined && callback !== null && (warnOnInvalidCallback(callback), update.callback = callback);
        callback = enqueueUpdate(inst, update, lane);
        callback !== null && (startUpdateTimerByLane(lane, "this.forceUpdate()", inst), scheduleUpdateOnFiber(callback, inst, lane), entangleTransitions(callback, inst, lane));
      }
    }, componentName = null, errorBoundaryName = null, SelectiveHydrationException = Error("This is not a real error. It's an implementation detail of React's selective hydration feature. If this leaks into userspace, it's a bug in React. Please file an issue."), didReceiveUpdate = false;
    var didWarnAboutBadClass = {};
    var didWarnAboutContextTypeOnFunctionComponent = {};
    var didWarnAboutContextTypes = {};
    var didWarnAboutGetDerivedStateOnFunctionComponent = {};
    var didWarnAboutReassigningProps = false;
    var didWarnAboutRevealOrder = {};
    var didWarnAboutTailOptions = {};
    var SUSPENDED_MARKER = {
      dehydrated: null,
      treeContext: null,
      retryLane: 0,
      hydrationErrors: null
    }, hasWarnedAboutUsingNoValuePropOnContextProvider = false, didWarnAboutUndefinedSnapshotBeforeUpdate = null;
    didWarnAboutUndefinedSnapshotBeforeUpdate = new Set;
    var offscreenSubtreeIsHidden = false, offscreenSubtreeWasHidden = false, needsFormReset = false, PossiblyWeakSet = typeof WeakSet === "function" ? WeakSet : Set, nextEffect = null, inProgressLanes = null, inProgressRoot = null, hostParent = null, hostParentIsContainer = false, currentHoistableRoot = null, inHydratedSubtree = false, suspenseyCommitFlag = 8192, DefaultAsyncDispatcher = {
      getCacheForType: function(resourceType) {
        var cache2 = readContext(CacheContext), cacheForType = cache2.data.get(resourceType);
        cacheForType === undefined && (cacheForType = resourceType(), cache2.data.set(resourceType, cacheForType));
        return cacheForType;
      },
      cacheSignal: function() {
        return readContext(CacheContext).controller.signal;
      },
      getOwner: function() {
        return current;
      }
    };
    if (typeof Symbol === "function" && Symbol.for) {
      var symbolFor = Symbol.for;
      symbolFor("selector.component");
      symbolFor("selector.has_pseudo_class");
      symbolFor("selector.role");
      symbolFor("selector.test_id");
      symbolFor("selector.text");
    }
    var commitHooks = [], PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map, NoContext = 0, RenderContext = 2, CommitContext = 4, RootInProgress = 0, RootFatalErrored = 1, RootErrored = 2, RootSuspended = 3, RootSuspendedWithDelay = 4, RootSuspendedAtTheShell = 6, RootCompleted = 5, executionContext = NoContext, workInProgressRoot = null, workInProgress = null, workInProgressRootRenderLanes = 0, NotSuspended = 0, SuspendedOnError = 1, SuspendedOnData = 2, SuspendedOnImmediate = 3, SuspendedOnInstance = 4, SuspendedOnInstanceAndReadyToContinue = 5, SuspendedOnDeprecatedThrowPromise = 6, SuspendedAndReadyToContinue = 7, SuspendedOnHydration = 8, SuspendedOnAction = 9, workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, workInProgressRootDidSkipSuspendedSiblings = false, workInProgressRootIsPrerendering = false, workInProgressRootDidAttachPingListener = false, entangledRenderLanes = 0, workInProgressRootExitStatus = RootInProgress, workInProgressRootSkippedLanes = 0, workInProgressRootInterleavedUpdatedLanes = 0, workInProgressRootPingedLanes = 0, workInProgressDeferredLane = 0, workInProgressSuspendedRetryLanes = 0, workInProgressRootConcurrentErrors = null, workInProgressRootRecoverableErrors = null, workInProgressRootDidIncludeRecursiveRenderUpdate = false, globalMostRecentFallbackTime = 0, globalMostRecentTransitionTime = 0, FALLBACK_THROTTLE_MS = 300, workInProgressRootRenderTargetTime = Infinity, RENDER_TIMEOUT_MS = 500, workInProgressTransitions = null, workInProgressUpdateTask = null, legacyErrorBoundariesThatAlreadyFailed = null, IMMEDIATE_COMMIT = 0, ABORTED_VIEW_TRANSITION_COMMIT = 1, DELAYED_PASSIVE_COMMIT = 2, ANIMATION_STARTED_COMMIT = 3, NO_PENDING_EFFECTS = 0, PENDING_MUTATION_PHASE = 1, PENDING_LAYOUT_PHASE = 2, PENDING_AFTER_MUTATION_PHASE = 3, PENDING_SPAWNED_WORK = 4, PENDING_PASSIVE_PHASE = 5, pendingEffectsStatus = 0, pendingEffectsRoot = null, pendingFinishedWork = null, pendingEffectsLanes = 0, pendingEffectsRemainingLanes = 0, pendingEffectsRenderEndTime = -0, pendingPassiveTransitions = null, pendingRecoverableErrors = null, pendingSuspendedCommitReason = null, pendingDelayedCommitReason = IMMEDIATE_COMMIT, pendingSuspendedViewTransitionReason = null, NESTED_UPDATE_LIMIT = 50, nestedUpdateCount = 0, rootWithNestedUpdates = null, isFlushingPassiveEffects = false, didScheduleUpdateDuringPassiveEffects = false, NESTED_PASSIVE_UPDATE_LIMIT = 50, nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null, isRunningInsertionEffect = false, didWarnStateUpdateForNotYetMountedComponent = null, didWarnAboutUpdateInRender = false;
    var didWarnAboutUpdateInRenderForAnotherComponent = new Set;
    var fakeActCallbackNode$1 = {}, firstScheduledRoot = null, lastScheduledRoot = null, didScheduleMicrotask = false, didScheduleMicrotask_act = false, mightHavePendingSyncWork = false, isFlushingWork = false, currentEventTransitionLane = 0, fakeActCallbackNode = {};
    (function() {
      for (var i = 0;i < simpleEventPluginEvents.length; i++) {
        var eventName = simpleEventPluginEvents[i], domEventName = eventName.toLowerCase();
        eventName = eventName[0].toUpperCase() + eventName.slice(1);
        registerSimpleEvent(domEventName, "on" + eventName);
      }
      registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
      registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");
      registerSimpleEvent(ANIMATION_START, "onAnimationStart");
      registerSimpleEvent("dblclick", "onDoubleClick");
      registerSimpleEvent("focusin", "onFocus");
      registerSimpleEvent("focusout", "onBlur");
      registerSimpleEvent(TRANSITION_RUN, "onTransitionRun");
      registerSimpleEvent(TRANSITION_START, "onTransitionStart");
      registerSimpleEvent(TRANSITION_CANCEL, "onTransitionCancel");
      registerSimpleEvent(TRANSITION_END, "onTransitionEnd");
    })();
    registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);
    registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);
    registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);
    registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
    registerTwoPhaseEvent("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
    registerTwoPhaseEvent("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
    registerTwoPhaseEvent("onBeforeInput", [
      "compositionend",
      "keypress",
      "textInput",
      "paste"
    ]);
    registerTwoPhaseEvent("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
    registerTwoPhaseEvent("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
    registerTwoPhaseEvent("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
    var mediaEventTypes = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), nonDelegatedEvents = new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(mediaEventTypes)), listeningMarker = "_reactListening" + Math.random().toString(36).slice(2), didWarnControlledToUncontrolled = false, didWarnUncontrolledToControlled = false, didWarnFormActionType = false, didWarnFormActionName = false, didWarnFormActionTarget = false, didWarnFormActionMethod = false, didWarnPopoverTargetObject = false;
    var didWarnForNewBooleanPropsWithEmptyValue = {};
    var NORMALIZE_NEWLINES_REGEX = /\r\n?/g, NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g, xlinkNamespace = "http://www.w3.org/1999/xlink", xmlNamespace = "http://www.w3.org/XML/1998/namespace", EXPECTED_FORM_ACTION_URL = "javascript:throw new Error('React form unexpectedly submitted.')", SUPPRESS_HYDRATION_WARNING = "suppressHydrationWarning", ACTIVITY_START_DATA = "&", ACTIVITY_END_DATA = "/&", SUSPENSE_START_DATA = "$", SUSPENSE_END_DATA = "/$", SUSPENSE_PENDING_START_DATA = "$?", SUSPENSE_QUEUED_START_DATA = "$~", SUSPENSE_FALLBACK_START_DATA = "$!", PREAMBLE_CONTRIBUTION_HTML = "html", PREAMBLE_CONTRIBUTION_BODY = "body", PREAMBLE_CONTRIBUTION_HEAD = "head", FORM_STATE_IS_MATCHING = "F!", FORM_STATE_IS_NOT_MATCHING = "F", DOCUMENT_READY_STATE_LOADING = "loading", STYLE = "style", HostContextNamespaceNone = 0, HostContextNamespaceSvg = 1, HostContextNamespaceMath = 2, eventsEnabled = null, selectionInformation = null, warnedUnknownTags = { dialog: true, webview: true }, currentPopstateTransitionEvent = null, schedulerEvent = undefined, scheduleTimeout = typeof setTimeout === "function" ? setTimeout : undefined, cancelTimeout = typeof clearTimeout === "function" ? clearTimeout : undefined, noTimeout = -1, localPromise = typeof Promise === "function" ? Promise : undefined, scheduleMicrotask = typeof queueMicrotask === "function" ? queueMicrotask : typeof localPromise !== "undefined" ? function(callback) {
      return localPromise.resolve(null).then(callback).catch(handleErrorInNextTick);
    } : scheduleTimeout, previousHydratableOnEnteringScopedSingleton = null, NotLoaded = 0, Loaded = 1, Errored = 2, Settled = 3, Inserted = 4, preloadPropsMap = new Map, preconnectsSet = new Set, previousDispatcher = ReactDOMSharedInternals.d;
    ReactDOMSharedInternals.d = {
      f: function() {
        var previousWasRendering = previousDispatcher.f(), wasRendering = flushSyncWork$1();
        return previousWasRendering || wasRendering;
      },
      r: function(form) {
        var formInst = getInstanceFromNode(form);
        formInst !== null && formInst.tag === 5 && formInst.type === "form" ? requestFormReset$1(formInst) : previousDispatcher.r(form);
      },
      D: function(href) {
        previousDispatcher.D(href);
        preconnectAs("dns-prefetch", href, null);
      },
      C: function(href, crossOrigin) {
        previousDispatcher.C(href, crossOrigin);
        preconnectAs("preconnect", href, crossOrigin);
      },
      L: function(href, as, options2) {
        previousDispatcher.L(href, as, options2);
        var ownerDocument = globalDocument;
        if (ownerDocument && href && as) {
          var preloadSelector = 'link[rel="preload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"]';
          as === "image" ? options2 && options2.imageSrcSet ? (preloadSelector += '[imagesrcset="' + escapeSelectorAttributeValueInsideDoubleQuotes(options2.imageSrcSet) + '"]', typeof options2.imageSizes === "string" && (preloadSelector += '[imagesizes="' + escapeSelectorAttributeValueInsideDoubleQuotes(options2.imageSizes) + '"]')) : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]' : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]';
          var key = preloadSelector;
          switch (as) {
            case "style":
              key = getStyleKey(href);
              break;
            case "script":
              key = getScriptKey(href);
          }
          preloadPropsMap.has(key) || (href = assign({
            rel: "preload",
            href: as === "image" && options2 && options2.imageSrcSet ? undefined : href,
            as
          }, options2), preloadPropsMap.set(key, href), ownerDocument.querySelector(preloadSelector) !== null || as === "style" && ownerDocument.querySelector(getStylesheetSelectorFromKey(key)) || as === "script" && ownerDocument.querySelector(getScriptSelectorFromKey(key)) || (as = ownerDocument.createElement("link"), setInitialProperties(as, "link", href), markNodeAsHoistable(as), ownerDocument.head.appendChild(as)));
        }
      },
      m: function(href, options2) {
        previousDispatcher.m(href, options2);
        var ownerDocument = globalDocument;
        if (ownerDocument && href) {
          var as = options2 && typeof options2.as === "string" ? options2.as : "script", preloadSelector = 'link[rel="modulepreload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"][href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]', key = preloadSelector;
          switch (as) {
            case "audioworklet":
            case "paintworklet":
            case "serviceworker":
            case "sharedworker":
            case "worker":
            case "script":
              key = getScriptKey(href);
          }
          if (!preloadPropsMap.has(key) && (href = assign({ rel: "modulepreload", href }, options2), preloadPropsMap.set(key, href), ownerDocument.querySelector(preloadSelector) === null)) {
            switch (as) {
              case "audioworklet":
              case "paintworklet":
              case "serviceworker":
              case "sharedworker":
              case "worker":
              case "script":
                if (ownerDocument.querySelector(getScriptSelectorFromKey(key)))
                  return;
            }
            as = ownerDocument.createElement("link");
            setInitialProperties(as, "link", href);
            markNodeAsHoistable(as);
            ownerDocument.head.appendChild(as);
          }
        }
      },
      X: function(src, options2) {
        previousDispatcher.X(src, options2);
        var ownerDocument = globalDocument;
        if (ownerDocument && src) {
          var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts, key = getScriptKey(src), resource = scripts.get(key);
          resource || (resource = ownerDocument.querySelector(getScriptSelectorFromKey(key)), resource || (src = assign({ src, async: true }, options2), (options2 = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options2), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
            type: "script",
            instance: resource,
            count: 1,
            state: null
          }, scripts.set(key, resource));
        }
      },
      S: function(href, precedence, options2) {
        previousDispatcher.S(href, precedence, options2);
        var ownerDocument = globalDocument;
        if (ownerDocument && href) {
          var styles3 = getResourcesFromRoot(ownerDocument).hoistableStyles, key = getStyleKey(href);
          precedence = precedence || "default";
          var resource = styles3.get(key);
          if (!resource) {
            var state = { loading: NotLoaded, preload: null };
            if (resource = ownerDocument.querySelector(getStylesheetSelectorFromKey(key)))
              state.loading = Loaded | Inserted;
            else {
              href = assign({
                rel: "stylesheet",
                href,
                "data-precedence": precedence
              }, options2);
              (options2 = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(href, options2);
              var link = resource = ownerDocument.createElement("link");
              markNodeAsHoistable(link);
              setInitialProperties(link, "link", href);
              link._p = new Promise(function(resolve, reject) {
                link.onload = resolve;
                link.onerror = reject;
              });
              link.addEventListener("load", function() {
                state.loading |= Loaded;
              });
              link.addEventListener("error", function() {
                state.loading |= Errored;
              });
              state.loading |= Inserted;
              insertStylesheet(resource, precedence, ownerDocument);
            }
            resource = {
              type: "stylesheet",
              instance: resource,
              count: 1,
              state
            };
            styles3.set(key, resource);
          }
        }
      },
      M: function(src, options2) {
        previousDispatcher.M(src, options2);
        var ownerDocument = globalDocument;
        if (ownerDocument && src) {
          var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts, key = getScriptKey(src), resource = scripts.get(key);
          resource || (resource = ownerDocument.querySelector(getScriptSelectorFromKey(key)), resource || (src = assign({ src, async: true, type: "module" }, options2), (options2 = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options2), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
            type: "script",
            instance: resource,
            count: 1,
            state: null
          }, scripts.set(key, resource));
        }
      }
    };
    var globalDocument = typeof document === "undefined" ? null : document, tagCaches = null, SUSPENSEY_STYLESHEET_TIMEOUT = 60000, SUSPENSEY_IMAGE_TIMEOUT = 800, SUSPENSEY_IMAGE_TIME_ESTIMATE = 500, estimatedBytesWithinLimit = 0, LAST_PRECEDENCE = null, precedencesByRoot = null, NotPendingTransition = NotPending, HostTransitionContext = {
      $$typeof: REACT_CONTEXT_TYPE,
      Provider: null,
      Consumer: null,
      _currentValue: NotPendingTransition,
      _currentValue2: NotPendingTransition,
      _threadCount: 0
    }, badgeFormat = "%c%s%c", badgeStyle = "background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px", resetStyle = "", pad = " ", bind = Function.prototype.bind;
    var didWarnAboutNestedUpdates = false;
    var overrideHookState = null, overrideHookStateDeletePath = null, overrideHookStateRenamePath = null, overrideProps = null, overridePropsDeletePath = null, overridePropsRenamePath = null, scheduleUpdate = null, scheduleRetry = null, setErrorHandler = null, setSuspenseHandler = null;
    overrideHookState = function(fiber, id, path, value) {
      id = findHook(fiber, id);
      id !== null && (path = copyWithSetImpl(id.memoizedState, path, 0, value), id.memoizedState = path, id.baseState = path, fiber.memoizedProps = assign({}, fiber.memoizedProps), path = enqueueConcurrentRenderForLane(fiber, 2), path !== null && scheduleUpdateOnFiber(path, fiber, 2));
    };
    overrideHookStateDeletePath = function(fiber, id, path) {
      id = findHook(fiber, id);
      id !== null && (path = copyWithDeleteImpl(id.memoizedState, path, 0), id.memoizedState = path, id.baseState = path, fiber.memoizedProps = assign({}, fiber.memoizedProps), path = enqueueConcurrentRenderForLane(fiber, 2), path !== null && scheduleUpdateOnFiber(path, fiber, 2));
    };
    overrideHookStateRenamePath = function(fiber, id, oldPath, newPath) {
      id = findHook(fiber, id);
      id !== null && (oldPath = copyWithRename(id.memoizedState, oldPath, newPath), id.memoizedState = oldPath, id.baseState = oldPath, fiber.memoizedProps = assign({}, fiber.memoizedProps), oldPath = enqueueConcurrentRenderForLane(fiber, 2), oldPath !== null && scheduleUpdateOnFiber(oldPath, fiber, 2));
    };
    overrideProps = function(fiber, path, value) {
      fiber.pendingProps = copyWithSetImpl(fiber.memoizedProps, path, 0, value);
      fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
      path = enqueueConcurrentRenderForLane(fiber, 2);
      path !== null && scheduleUpdateOnFiber(path, fiber, 2);
    };
    overridePropsDeletePath = function(fiber, path) {
      fiber.pendingProps = copyWithDeleteImpl(fiber.memoizedProps, path, 0);
      fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
      path = enqueueConcurrentRenderForLane(fiber, 2);
      path !== null && scheduleUpdateOnFiber(path, fiber, 2);
    };
    overridePropsRenamePath = function(fiber, oldPath, newPath) {
      fiber.pendingProps = copyWithRename(fiber.memoizedProps, oldPath, newPath);
      fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
      oldPath = enqueueConcurrentRenderForLane(fiber, 2);
      oldPath !== null && scheduleUpdateOnFiber(oldPath, fiber, 2);
    };
    scheduleUpdate = function(fiber) {
      var root2 = enqueueConcurrentRenderForLane(fiber, 2);
      root2 !== null && scheduleUpdateOnFiber(root2, fiber, 2);
    };
    scheduleRetry = function(fiber) {
      var lane = claimNextRetryLane(), root2 = enqueueConcurrentRenderForLane(fiber, lane);
      root2 !== null && scheduleUpdateOnFiber(root2, fiber, lane);
    };
    setErrorHandler = function(newShouldErrorImpl) {
      shouldErrorImpl = newShouldErrorImpl;
    };
    setSuspenseHandler = function(newShouldSuspendImpl) {
      shouldSuspendImpl = newShouldSuspendImpl;
    };
    var _enabled = true, return_targetInst = null, hasScheduledReplayAttempt = false, queuedFocus = null, queuedDrag = null, queuedMouse = null, queuedPointers = new Map, queuedPointerCaptures = new Map, queuedExplicitHydrationTargets = [], discreteReplayableEvents = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" "), lastScheduledReplayQueue = null;
    ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = function(children) {
      var root2 = this._internalRoot;
      if (root2 === null)
        throw Error("Cannot update an unmounted root.");
      var args = arguments;
      typeof args[1] === "function" ? console.error("does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().") : isValidContainer(args[1]) ? console.error("You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root.") : typeof args[1] !== "undefined" && console.error("You passed a second argument to root.render(...) but it only accepts one argument.");
      args = children;
      var current2 = root2.current, lane = requestUpdateLane(current2);
      updateContainerImpl(current2, lane, args, root2, null, null);
    };
    ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount = function() {
      var args = arguments;
      typeof args[0] === "function" && console.error("does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
      args = this._internalRoot;
      if (args !== null) {
        this._internalRoot = null;
        var container = args.containerInfo;
        (executionContext & (RenderContext | CommitContext)) !== NoContext && console.error("Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition.");
        updateContainerImpl(args.current, 2, null, args, null, null);
        flushSyncWork$1();
        container[internalContainerInstanceKey] = null;
      }
    };
    ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = function(target) {
      if (target) {
        var updatePriority = resolveUpdatePriority();
        target = { blockedOn: null, target, priority: updatePriority };
        for (var i = 0;i < queuedExplicitHydrationTargets.length && updatePriority !== 0 && updatePriority < queuedExplicitHydrationTargets[i].priority; i++)
          ;
        queuedExplicitHydrationTargets.splice(i, 0, target);
        i === 0 && attemptExplicitHydrationTarget(target);
      }
    };
    (function() {
      var isomorphicReactPackageVersion = React6.version;
      if (isomorphicReactPackageVersion !== "19.2.3")
        throw Error(`Incompatible React versions: The "react" and "react-dom" packages must have the exact same version. Instead got:
  - react:      ` + (isomorphicReactPackageVersion + `
  - react-dom:  19.2.3
Learn more: https://react.dev/warnings/version-mismatch`));
    })();
    typeof Map === "function" && Map.prototype != null && typeof Map.prototype.forEach === "function" && typeof Set === "function" && Set.prototype != null && typeof Set.prototype.clear === "function" && typeof Set.prototype.forEach === "function" || console.error("React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://react.dev/link/react-polyfills");
    ReactDOMSharedInternals.findDOMNode = function(componentOrElement) {
      var fiber = componentOrElement._reactInternals;
      if (fiber === undefined) {
        if (typeof componentOrElement.render === "function")
          throw Error("Unable to find node on an unmounted component.");
        componentOrElement = Object.keys(componentOrElement).join(",");
        throw Error("Argument appears to not be a ReactComponent. Keys: " + componentOrElement);
      }
      componentOrElement = findCurrentFiberUsingSlowPath(fiber);
      componentOrElement = componentOrElement !== null ? findCurrentHostFiberImpl(componentOrElement) : null;
      componentOrElement = componentOrElement === null ? null : componentOrElement.stateNode;
      return componentOrElement;
    };
    if (!function() {
      var internals = {
        bundleType: 1,
        version: "19.2.3",
        rendererPackageName: "react-dom",
        currentDispatcherRef: ReactSharedInternals,
        reconcilerVersion: "19.2.3"
      };
      internals.overrideHookState = overrideHookState;
      internals.overrideHookStateDeletePath = overrideHookStateDeletePath;
      internals.overrideHookStateRenamePath = overrideHookStateRenamePath;
      internals.overrideProps = overrideProps;
      internals.overridePropsDeletePath = overridePropsDeletePath;
      internals.overridePropsRenamePath = overridePropsRenamePath;
      internals.scheduleUpdate = scheduleUpdate;
      internals.scheduleRetry = scheduleRetry;
      internals.setErrorHandler = setErrorHandler;
      internals.setSuspenseHandler = setSuspenseHandler;
      internals.scheduleRefresh = scheduleRefresh;
      internals.scheduleRoot = scheduleRoot;
      internals.setRefreshHandler = setRefreshHandler;
      internals.getCurrentFiber = getCurrentFiberForDevTools;
      return injectInternals(internals);
    }() && canUseDOM && window.top === window.self && (-1 < navigator.userAgent.indexOf("Chrome") && navigator.userAgent.indexOf("Edge") === -1 || -1 < navigator.userAgent.indexOf("Firefox"))) {
      var protocol = window.location.protocol;
      /^(https?|file):$/.test(protocol) && console.info("%cDownload the React DevTools for a better development experience: https://react.dev/link/react-devtools" + (protocol === "file:" ? `
You might need to use a local HTTP server (instead of file://): https://react.dev/link/react-devtools-faq` : ""), "font-weight:bold");
    }
    exports.createRoot = function(container, options2) {
      if (!isValidContainer(container))
        throw Error("Target container is not a DOM element.");
      warnIfReactDOMContainerInDEV(container);
      var isStrictMode = false, identifierPrefix = "", onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError;
      options2 !== null && options2 !== undefined && (options2.hydrate ? console.warn("hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead.") : typeof options2 === "object" && options2 !== null && options2.$$typeof === REACT_ELEMENT_TYPE && console.error(`You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:

  let root = createRoot(domContainer);
  root.render(<App />);`), options2.unstable_strictMode === true && (isStrictMode = true), options2.identifierPrefix !== undefined && (identifierPrefix = options2.identifierPrefix), options2.onUncaughtError !== undefined && (onUncaughtError = options2.onUncaughtError), options2.onCaughtError !== undefined && (onCaughtError = options2.onCaughtError), options2.onRecoverableError !== undefined && (onRecoverableError = options2.onRecoverableError));
      options2 = createFiberRoot(container, 1, false, null, null, isStrictMode, identifierPrefix, null, onUncaughtError, onCaughtError, onRecoverableError, defaultOnDefaultTransitionIndicator);
      container[internalContainerInstanceKey] = options2.current;
      listenToAllSupportedEvents(container);
      return new ReactDOMRoot(options2);
    };
    exports.hydrateRoot = function(container, initialChildren, options2) {
      if (!isValidContainer(container))
        throw Error("Target container is not a DOM element.");
      warnIfReactDOMContainerInDEV(container);
      initialChildren === undefined && console.error("Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)");
      var isStrictMode = false, identifierPrefix = "", onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError, formState = null;
      options2 !== null && options2 !== undefined && (options2.unstable_strictMode === true && (isStrictMode = true), options2.identifierPrefix !== undefined && (identifierPrefix = options2.identifierPrefix), options2.onUncaughtError !== undefined && (onUncaughtError = options2.onUncaughtError), options2.onCaughtError !== undefined && (onCaughtError = options2.onCaughtError), options2.onRecoverableError !== undefined && (onRecoverableError = options2.onRecoverableError), options2.formState !== undefined && (formState = options2.formState));
      initialChildren = createFiberRoot(container, 1, true, initialChildren, options2 != null ? options2 : null, isStrictMode, identifierPrefix, formState, onUncaughtError, onCaughtError, onRecoverableError, defaultOnDefaultTransitionIndicator);
      initialChildren.context = getContextForSubtree(null);
      options2 = initialChildren.current;
      isStrictMode = requestUpdateLane(options2);
      isStrictMode = getBumpedLaneForHydrationByLane(isStrictMode);
      identifierPrefix = createUpdate(isStrictMode);
      identifierPrefix.callback = null;
      enqueueUpdate(options2, identifierPrefix, isStrictMode);
      startUpdateTimerByLane(isStrictMode, "hydrateRoot()", null);
      options2 = isStrictMode;
      initialChildren.current.lanes = options2;
      markRootUpdated$1(initialChildren, options2);
      ensureRootIsScheduled(initialChildren);
      container[internalContainerInstanceKey] = initialChildren.current;
      listenToAllSupportedEvents(container);
      return new ReactDOMHydrationRoot(initialChildren);
    };
    exports.version = "19.2.3";
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  })();
});

// node_modules/react-dom/client.js
var require_client = __commonJS((exports, module) => {
  var react_dom_client_development = __toESM(require_react_dom_client_development());
  if (false) {} else {
    module.exports = react_dom_client_development;
  }
});

// src/plugin.ts
init_dist();
init_index_node5();
import { ModelType, Service as Service2, logger as logger5 } from "@elizaos/core";
import { z } from "zod";

// src/actions/issueCredential.ts
init_index_node5();
init_dist();
import { logger as logger2 } from "@elizaos/core";

// src/wallet.ts
init_index_node33();
init_index_node5();
init_esm3();
import { logger } from "@elizaos/core";
async function getAgentSigner(runtime, allowGenerate = false) {
  if (runtime.wallet?.privateKey) {
    logger.debug("Using wallet from agent runtime");
    try {
      const privateKeyBytes = parsePrivateKey(runtime.wallet.privateKey);
      const signer = await createKeyPairSignerFromBytes(privateKeyBytes);
      logger.info({
        agentId: runtime.agentId,
        walletAddress: signer.address
      }, "Agent signer loaded from runtime wallet");
      return signer;
    } catch (error) {
      logger.error({ error }, "Failed to load wallet from runtime");
      throw new Error("Invalid wallet in runtime");
    }
  }
  if (process.env.AGENT_WALLET_PRIVATE_KEY) {
    logger.debug("Using wallet from environment variable");
    try {
      const privateKeyBytes = parsePrivateKey(process.env.AGENT_WALLET_PRIVATE_KEY);
      const signer = await createKeyPairSignerFromBytes(privateKeyBytes);
      logger.info({
        agentId: runtime.agentId,
        walletAddress: signer.address
      }, "Agent signer loaded from environment");
      return signer;
    } catch (error) {
      logger.error({ error }, "Failed to load wallet from environment");
      throw new Error("Invalid AGENT_WALLET_PRIVATE_KEY");
    }
  }
  if (allowGenerate) {
    logger.warn({ agentId: runtime.agentId }, "No wallet found, generating new keypair (DEV MODE ONLY)");
    const signer = await generateKeyPairSigner();
    logger.info({
      agentId: runtime.agentId,
      walletAddress: signer.address
    }, "Generated new keypair for agent");
    return signer;
  }
  throw new Error("No wallet configured for agent. Please set runtime.wallet or AGENT_WALLET_PRIVATE_KEY");
}
function parsePrivateKey(privateKey) {
  if (privateKey instanceof Uint8Array) {
    return privateKey;
  }
  const keyString = privateKey.trim();
  try {
    const bytes = esm_default2.decode(keyString);
    if (bytes.length === 64) {
      return bytes;
    }
  } catch {}
  if (keyString.startsWith("0x")) {
    try {
      const hex = keyString.slice(2);
      const bytes = new Uint8Array(hex.match(/.{1,2}/g).map((byte) => parseInt(byte, 16)));
      if (bytes.length === 64) {
        return bytes;
      }
    } catch {}
  }
  if (keyString.startsWith("[")) {
    try {
      const numbers = JSON.parse(keyString);
      if (Array.isArray(numbers) && numbers.length === 64) {
        return new Uint8Array(numbers);
      }
    } catch {}
  }
  throw new Error("Invalid private key format. Expected base58, hex (0x...), or JSON array");
}
async function getAgentAddress(runtime) {
  if (runtime.wallet?.address) {
    return address(runtime.wallet.address);
  }
  if (runtime.wallet?.publicKey) {
    return address(runtime.wallet.publicKey);
  }
  const signer = await getAgentSigner(runtime);
  return signer.address;
}
async function airdropToAgent(runtime, amount = 1e9) {
  const cluster = process.env.SOLANA_CLUSTER || "devnet";
  if (cluster !== "devnet") {
    throw new Error("Airdrop only available on devnet");
  }
  const { createSolanaRpc: createSolanaRpc2 } = await Promise.resolve().then(() => (init_index_node27(), exports_index_node2));
  const rpcUrl = process.env.SOLANA_RPC_URL || "https://api.devnet.solana.com";
  const rpc2 = createSolanaRpc2(rpcUrl);
  const agentAddress = await getAgentAddress(runtime);
  logger.info({
    agentId: runtime.agentId,
    address: agentAddress,
    amount
  }, "Requesting SOL airdrop");
  const signature2 = await rpc2.requestAirdrop(agentAddress, BigInt(amount)).send();
  logger.info({
    agentId: runtime.agentId,
    signature: signature2
  }, "Airdrop successful");
  return signature2.toString();
}
async function getAgentBalance(runtime) {
  const { createSolanaRpc: createSolanaRpc2 } = await Promise.resolve().then(() => (init_index_node27(), exports_index_node2));
  const rpcUrl = process.env.SOLANA_RPC_URL || "https://api.devnet.solana.com";
  const rpc2 = createSolanaRpc2(rpcUrl);
  const agentAddress = await getAgentAddress(runtime);
  const balance = await rpc2.getBalance(agentAddress).send();
  return balance.value;
}
function formatSolBalance(lamports2) {
  const sol2 = Number(lamports2) / 1e9;
  return `${sol2.toFixed(4)} SOL`;
}
async function ensureFundedWallet(runtime, minBalance = 1e8) {
  const balance = await getAgentBalance(runtime);
  if (balance >= BigInt(minBalance)) {
    logger.debug({
      agentId: runtime.agentId,
      balance: formatSolBalance(balance)
    }, "Agent wallet has sufficient balance");
    return true;
  }
  const cluster = process.env.SOLANA_CLUSTER || "devnet";
  if (cluster === "devnet") {
    logger.warn({
      agentId: runtime.agentId,
      balance: formatSolBalance(balance),
      minBalance: formatSolBalance(BigInt(minBalance))
    }, "Agent wallet balance low, requesting airdrop");
    await airdropToAgent(runtime, 1e9);
    return true;
  }
  logger.error({
    agentId: runtime.agentId,
    balance: formatSolBalance(balance),
    minBalance: formatSolBalance(BigInt(minBalance))
  }, "Agent wallet has insufficient balance (mainnet - requires manual funding)");
  return false;
}

// src/actions/issueCredential.ts
function parseCredentialRequest(message) {
  const text = message.content.text || "";
  const textLower = text.toLowerCase();
  const addressMatch = text.match(/([A-Za-z0-9]{32,44})/);
  if (!addressMatch) {
    return null;
  }
  const agentId = address(addressMatch[1]);
  let credentialType = "agent-identity";
  if (textLower.includes("reputation") || textLower.includes("ghost score")) {
    credentialType = "reputation";
  } else if (textLower.includes("job") || textLower.includes("completion")) {
    credentialType = "job-completion";
  }
  const emailMatch = text.match(/([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})/);
  const recipientEmail = emailMatch ? emailMatch[1] : undefined;
  const syncToCrossmint = textLower.includes("crossmint") || textLower.includes("evm");
  const nameMatch = text.match(/name[:\s]+([^,\n]+)/i);
  const name = nameMatch ? nameMatch[1].trim() : undefined;
  const capabilitiesMatch = text.match(/capabilities?[:\s]+\[([^\]]+)\]/i);
  const capabilities = capabilitiesMatch ? capabilitiesMatch[1].split(",").map((c) => c.trim()) : undefined;
  return {
    agentId,
    recipientEmail,
    credentialType,
    subject: {
      name,
      capabilities
    },
    syncToCrossmint
  };
}
var issueCredentialAction = {
  name: "ISSUE_CREDENTIAL",
  similes: [
    "CREATE_CREDENTIAL",
    "ISSUE_VC",
    "CREATE_VERIFIABLE_CREDENTIAL",
    "MINT_CREDENTIAL"
  ],
  description: `Issue a W3C Verifiable Credential for an AI agent. Credentials can be:
- Agent Identity: Prove agent ownership and capabilities
- Reputation: Certify trust score and performance
- Job Completion: Document completed work

Credentials are stored on Solana and can be bridged to EVM chains via Crossmint.`,
  validate: async (_runtime, message, _state) => {
    const text = message.content.text?.toLowerCase() || "";
    return (text.includes("issue") || text.includes("create") || text.includes("mint")) && (text.includes("credential") || text.includes("vc"));
  },
  handler: async (runtime, message, _state, _options, callback, _responses) => {
    try {
      const request = parseCredentialRequest(message);
      if (!request) {
        const errorMsg = `I need an agent address to issue a credential. Format:
"Issue credential for [agent-address]"
Optional: "name: Agent Name, capabilities: [cap1, cap2], email: user@example.com, crossmint"`;
        if (callback) {
          await callback({
            text: errorMsg,
            actions: ["ISSUE_CREDENTIAL"],
            source: message.content.source
          });
        }
        return {
          success: false,
          text: errorMsg,
          error: new Error("Agent address required")
        };
      }
      logger2.info({
        agentId: runtime.agentId,
        targetAgent: request.agentId.toString(),
        credentialType: request.credentialType
      }, "Issuing credential");
      const signer = await getAgentSigner(runtime);
      const hasFunds = await ensureFundedWallet(runtime);
      if (!hasFunds) {
        throw new Error("Insufficient SOL balance. Please fund your wallet.");
      }
      const client = new GhostSpeakClient({
        cluster: process.env.SOLANA_CLUSTER || "devnet",
        rpcEndpoint: process.env.SOLANA_RPC_URL
      });
      let result;
      if (request.credentialType === "agent-identity") {
        result = await client.credentials.issueAgentIdentityCredential({
          agentId: request.agentId,
          owner: signer.address,
          name: request.subject.name || "Unknown Agent",
          capabilities: request.subject.capabilities || [],
          x402Enabled: true,
          syncToCrossmint: request.syncToCrossmint,
          recipientEmail: request.recipientEmail
        });
        logger2.info({
          credentialId: result.solanaCredential?.credentialId,
          crossmintId: result.crossmintSync?.id
        }, "Agent identity credential issued");
      } else if (request.credentialType === "reputation") {
        const agentData = await client.agents.getAgentAccount(request.agentId);
        if (!agentData) {
          throw new Error(`Agent not found: ${request.agentId}`);
        }
        const reputationScore = Number(agentData.reputationScore || 0);
        const totalJobsCompleted = Number(agentData.totalJobsCompleted || 0);
        const totalJobsFailed = Number(agentData.totalJobsFailed || 0);
        const totalJobs = totalJobsCompleted + totalJobsFailed;
        const successRate = totalJobs > 0 ? Math.round(totalJobsCompleted / totalJobs * 100) : 0;
        const templateId = process.env.CROSSMINT_REPUTATION_TEMPLATE_ID;
        if (!templateId && request.syncToCrossmint) {
          throw new Error("CROSSMINT_REPUTATION_TEMPLATE_ID not configured");
        }
        const { CrossmintVCClient: CrossmintVCClient2 } = await Promise.resolve().then(() => (init_dist(), exports_dist));
        const crossmint = new CrossmintVCClient2({
          apiKey: process.env.CROSSMINT_SECRET_KEY || "",
          environment: process.env.CROSSMINT_ENV || "staging",
          chain: "base-sepolia"
        });
        const subject = {
          agent: request.agentId.toString(),
          reputationScore,
          totalJobsCompleted,
          totalEarnings: 0,
          successRate,
          avgRating: Math.min(5, Math.ceil(reputationScore / 2000)),
          disputeRate: 0,
          snapshotTimestamp: Math.floor(Date.now() / 1000)
        };
        if (request.syncToCrossmint && templateId) {
          const crossmintResult = await crossmint.issueReputationCredential(templateId, request.recipientEmail || `agent-${request.agentId.toString().slice(0, 8)}@ghostspeak.credentials`, subject);
          result = {
            solanaCredential: null,
            crossmintSync: crossmintResult
          };
        } else {
          result = {
            solanaCredential: { credentialSubject: subject },
            crossmintSync: null
          };
        }
        logger2.info({
          crossmintId: result.crossmintSync?.id,
          reputationScore
        }, "Reputation credential issued");
      } else {
        throw new Error(`Credential type not yet implemented: ${request.credentialType}`);
      }
      const responseText = ` Credential issued successfully!

**Credential Type**: ${request.credentialType}
**Agent**: ${request.agentId.toString().slice(0, 8)}...${request.agentId.toString().slice(-8)}
${result.solanaCredential?.credentialId ? `**Solana Credential ID**: ${result.solanaCredential.credentialId}` : ""}
${result.crossmintSync?.id ? `**Crossmint ID**: ${result.crossmintSync.id}` : ""}
${result.crossmintSync?.onChain?.status ? `**EVM Status**: ${result.crossmintSync.onChain.status}` : ""}
${request.recipientEmail ? `**Recipient**: ${request.recipientEmail}` : ""}

The credential has been created and ${request.syncToCrossmint ? "bridged to EVM via Crossmint" : "stored on Solana"}.`;
      if (callback) {
        await callback({
          text: responseText,
          actions: ["ISSUE_CREDENTIAL"],
          source: message.content.source
        });
      }
      return {
        success: true,
        text: responseText,
        data: {
          credentialType: request.credentialType,
          agentId: request.agentId.toString(),
          credentialId: result.solanaCredential?.credentialId,
          crossmintId: result.crossmintSync?.id,
          evmStatus: result.crossmintSync?.onChain?.status
        }
      };
    } catch (error) {
      logger2.error({ error }, "Error issuing credential:");
      const errorMsg = `Failed to issue credential: ${error instanceof Error ? error.message : "Unknown error"}

Common issues:
- Agent not registered on GhostSpeak
- Insufficient SOL balance
- Crossmint API key not configured
- Invalid agent address`;
      if (callback) {
        await callback({
          text: errorMsg,
          actions: ["ISSUE_CREDENTIAL"],
          source: message.content.source
        });
      }
      return {
        success: false,
        text: errorMsg,
        error: error instanceof Error ? error : new Error(String(error))
      };
    }
  },
  examples: [
    [
      {
        name: "{{userName}}",
        content: {
          text: "Issue credential for 7xKXtYZ3rR9vR1xgVfqU8kK4d9gP9Gk name: AI Assistant, capabilities: [code-review, security-audit], email: builder@example.com",
          actions: []
        }
      },
      {
        name: "{{agentName}}",
        content: {
          text: ` Credential issued successfully!

**Credential Type**: agent-identity
**Agent**: 7xKXtYZ3...9Gk
**Solana Credential ID**: cred_abc123
**Recipient**: builder@example.com

The credential has been created and stored on Solana.`,
          actions: ["ISSUE_CREDENTIAL"]
        }
      }
    ],
    [
      {
        name: "{{userName}}",
        content: {
          text: "Issue reputation credential for 7xKXtYZ3rR9vR1xgVfqU8kK4d9gP9Gk crossmint",
          actions: []
        }
      },
      {
        name: "{{agentName}}",
        content: {
          text: ` Credential issued successfully!

**Credential Type**: reputation
**Agent**: 7xKXtYZ3...9Gk
**Crossmint ID**: vc_xyz789
**EVM Status**: pending

The credential has been created and bridged to EVM via Crossmint.`,
          actions: ["ISSUE_CREDENTIAL"]
        }
      }
    ]
  ]
};
// src/actions/registerAgent.ts
init_dist();
import { logger as logger3 } from "@elizaos/core";
function parseRegistrationRequest(message) {
  const text = message.content.text || "";
  const nameMatch = text.match(/name[:\s]+([^,\n]+)/i);
  if (!nameMatch) {
    return null;
  }
  const name = nameMatch[1].trim();
  const descMatch = text.match(/description[:\s]+([^,\n]+)/i);
  if (!descMatch) {
    return null;
  }
  const description = descMatch[1].trim();
  const capMatch = text.match(/capabilities?[:\s]+\[([^\]]+)\]/i);
  if (!capMatch) {
    return null;
  }
  const capabilities = capMatch[1].split(",").map((c) => c.trim());
  const modelMatch = text.match(/model[:\s]+([^,\n]+)/i);
  const model = modelMatch ? modelMatch[1].trim() : undefined;
  const typeMatch = text.match(/type[:\s]+(\d+)/i);
  const agentType = typeMatch ? parseInt(typeMatch[1]) : 0;
  const useCompressedNFT = text.toLowerCase().includes("compressed") || text.toLowerCase().includes("cnft");
  return {
    name,
    description,
    capabilities,
    model,
    agentType,
    useCompressedNFT
  };
}
var registerAgentAction = {
  name: "REGISTER_AGENT",
  similes: [
    "CREATE_AGENT",
    "REGISTER_ON_GHOSTSPEAK",
    "ONBOARD_AGENT",
    "SETUP_AGENT"
  ],
  description: `Register an AI agent on GhostSpeak blockchain. Creates on-chain identity with:
- Unique agent address
- Name and description
- Capabilities list
- Optional compressed NFT (5000x cheaper)

Registered agents can:
- Accumulate Ghost Score (reputation)
- Earn verifiable credentials
- Participate in x402 payment protocol
- Track job history on-chain`,
  validate: async (_runtime, message, _state) => {
    const text = message.content.text?.toLowerCase() || "";
    return (text.includes("register") || text.includes("create") || text.includes("onboard")) && text.includes("agent");
  },
  handler: async (runtime, message, _state, _options, callback, _responses) => {
    try {
      const request = parseRegistrationRequest(message);
      if (!request) {
        const errorMsg = `I need agent details to register. Format:
"Register agent name: My Agent, description: What it does, capabilities: [cap1, cap2]"
Optional: "model: gpt-4, type: 0, compressed"`;
        if (callback) {
          await callback({
            text: errorMsg,
            actions: ["REGISTER_AGENT"],
            source: message.content.source
          });
        }
        return {
          success: false,
          text: errorMsg,
          error: new Error("Registration details required")
        };
      }
      logger3.info({
        agentId: runtime.agentId,
        agentName: request.name,
        useCompressedNFT: request.useCompressedNFT
      }, "Registering agent on GhostSpeak");
      const signer = await getAgentSigner(runtime);
      logger3.info({
        signerAddress: signer.address
      }, "Using signer for registration");
      const hasFunds = await ensureFundedWallet(runtime);
      if (!hasFunds) {
        throw new Error("Insufficient SOL balance. Please fund your wallet or wait for airdrop.");
      }
      const client = new GhostSpeakClient({
        cluster: process.env.SOLANA_CLUSTER || "devnet",
        rpcEndpoint: process.env.SOLANA_RPC_URL
      });
      let result;
      if (request.useCompressedNFT) {
        logger3.warn("Compressed NFT registration not yet implemented, using standard registration");
        result = await client.agents.register(signer, {
          name: request.name,
          description: request.description,
          capabilities: request.capabilities,
          model: request.model,
          agentType: request.agentType
        });
      } else {
        result = await client.agents.register(signer, {
          name: request.name,
          description: request.description,
          capabilities: request.capabilities,
          model: request.model,
          agentType: request.agentType
        });
      }
      logger3.info({
        agentAddress: result.address,
        signature: result.signature
      }, "Agent registered successfully");
      try {
        await runtime.setState("ghostspeakAgentAddress", result.address.toString());
        logger3.debug("Stored agent address in runtime state");
      } catch (error) {
        logger3.warn({ error }, "Failed to store agent address in runtime state (non-critical)");
      }
      const responseText = ` Agent registered successfully on GhostSpeak!

**Agent Address**: ${result.address.toString()}
**Name**: ${request.name}
**Description**: ${request.description}
**Capabilities**: ${request.capabilities.join(", ")}
${request.model ? `**Model**: ${request.model}` : ""}
**Network**: ${process.env.SOLANA_CLUSTER || "devnet"}
**Transaction**: ${result.signature}

Your agent now has an on-chain identity! It can:
-  Accumulate Ghost Score (reputation)
-  Earn verifiable credentials
-  Accept x402 payments
-  Track job history on-chain

Next steps:
1. Issue an identity credential: "Issue credential for ${result.address.toString().slice(0, 8)}..."
2. Start completing jobs to build reputation
3. Check your Ghost Score: "Check ghost score for ${result.address.toString().slice(0, 8)}..."`;
      if (callback) {
        await callback({
          text: responseText,
          actions: ["REGISTER_AGENT"],
          source: message.content.source
        });
      }
      return {
        success: true,
        text: responseText,
        data: {
          agentAddress: result.address.toString(),
          signature: result.signature,
          name: request.name,
          capabilities: request.capabilities,
          network: process.env.SOLANA_CLUSTER || "devnet"
        }
      };
    } catch (error) {
      logger3.error({ error }, "Error registering agent:");
      const errorMsg = `Failed to register agent: ${error instanceof Error ? error.message : "Unknown error"}

Common issues:
- Insufficient SOL balance (need ~0.01 SOL for transaction)
- Invalid agent details
- Network connection issues
- Agent already registered with this wallet

Try:
1. Check your SOL balance
2. Verify agent details are correct
3. Try again in a moment`;
      if (callback) {
        await callback({
          text: errorMsg,
          actions: ["REGISTER_AGENT"],
          source: message.content.source
        });
      }
      return {
        success: false,
        text: errorMsg,
        error: error instanceof Error ? error : new Error(String(error))
      };
    }
  },
  examples: [
    [
      {
        name: "{{userName}}",
        content: {
          text: "Register agent name: Code Reviewer, description: AI agent for code analysis and security audits, capabilities: [code-review, security-audit, bug-detection], model: gpt-4",
          actions: []
        }
      },
      {
        name: "{{agentName}}",
        content: {
          text: ` Agent registered successfully on GhostSpeak!

**Agent Address**: 7xKXtYZ3rR9vR1xgVfqU8kK4d9gP9Gk
**Name**: Code Reviewer
**Description**: AI agent for code analysis and security audits
**Capabilities**: code-review, security-audit, bug-detection
**Model**: gpt-4
**Network**: devnet
**Transaction**: 5jHD...

Your agent now has an on-chain identity!`,
          actions: ["REGISTER_AGENT"]
        }
      }
    ]
  ]
};
// src/services/PayAIPollingService.ts
init_dist();
init_index_node5();
import { Service, logger as logger4 } from "@elizaos/core";

class PayAIPollingService extends Service {
  runtime;
  static serviceType = "payai-polling";
  intervalId = null;
  pollIntervalMs = 5 * 60 * 1000;
  processedSignatures = new Set;
  ghostSpeakClient = null;
  capabilityDescription = "Polls for PayAI payments and updates agent reputation";
  constructor(runtime) {
    super(runtime);
    this.runtime = runtime;
    logger4.info("PayAI Polling Service initialized");
  }
  static async start(runtime) {
    logger4.info("Starting PayAI Polling Service");
    const service = new PayAIPollingService(runtime);
    await service.initialize();
    return service;
  }
  static async stop(runtime) {
    logger4.info("Stopping PayAI Polling Service");
    const service = runtime.getService(PayAIPollingService.serviceType);
    if (service) {
      await service.shutdown();
    }
  }
  async initialize() {
    try {
      this.ghostSpeakClient = new GhostSpeakClient({
        cluster: process.env.SOLANA_CLUSTER || "devnet",
        rpcEndpoint: process.env.SOLANA_RPC_URL
      });
      this.startPolling();
      logger4.info({
        pollInterval: `${this.pollIntervalMs / 1000}s`
      }, "PayAI polling started");
    } catch (error) {
      logger4.error({ error }, "Failed to initialize PayAI polling service");
      throw error;
    }
  }
  async stop() {
    await this.shutdown();
  }
  startPolling() {
    this.pollPayments();
    this.intervalId = setInterval(() => {
      this.pollPayments();
    }, this.pollIntervalMs);
  }
  async shutdown() {
    if (this.intervalId) {
      clearInterval(this.intervalId);
      this.intervalId = null;
    }
    this.processedSignatures.clear();
    this.ghostSpeakClient = null;
    logger4.info("PayAI Polling Service stopped");
  }
  async pollPayments() {
    try {
      logger4.debug("Polling for new PayAI payments...");
      if (!this.ghostSpeakClient) {
        logger4.warn("GhostSpeak client not initialized");
        return;
      }
      const allAgents = await this.ghostSpeakClient.agents.getAllAgents();
      logger4.debug({
        agentCount: allAgents.length
      }, "Checking payments for agents");
      for (const agent of allAgents) {
        try {
          await this.checkAgentPayments(agent.address);
        } catch (error) {
          logger4.error({
            agentAddress: agent.address.toString(),
            error
          }, "Failed to check payments for agent");
        }
      }
      logger4.debug("Payment polling complete");
    } catch (error) {
      logger4.error({ error }, "Error during payment polling");
    }
  }
  async checkAgentPayments(agentAddress) {
    try {
      const { createSolanaRpc: createSolanaRpc2 } = await Promise.resolve().then(() => (init_index_node27(), exports_index_node2));
      const rpcUrl = process.env.SOLANA_RPC_URL || "https://api.devnet.solana.com";
      const rpc2 = createSolanaRpc2(rpcUrl);
      const signatures = await rpc2.getSignaturesForAddress(agentAddress, {
        limit: 10
      }).send();
      for (const signatureInfo of signatures) {
        const signature2 = signatureInfo.signature;
        if (this.processedSignatures.has(signature2)) {
          continue;
        }
        const transaction = await rpc2.getTransaction(signature2, {
          encoding: "json",
          maxSupportedTransactionVersion: 0
        }).send();
        if (!transaction || transaction.meta?.err) {
          continue;
        }
        const payment = {
          signature: signature2,
          agentAddress,
          amount: BigInt(1e6),
          payer: address("11111111111111111111111111111111"),
          timestamp: Number(transaction.blockTime ?? 0),
          processed: false
        };
        await this.processPayment(payment);
        this.processedSignatures.add(signature2);
      }
    } catch (error) {
      logger4.error({
        agentAddress: agentAddress.toString(),
        error
      }, "Failed to check agent payments");
    }
  }
  async processPayment(payment) {
    try {
      logger4.info({
        signature: payment.signature,
        agentAddress: payment.agentAddress.toString(),
        amount: payment.amount.toString()
      }, "Processing payment");
      logger4.info({
        signature: payment.signature
      }, "Payment processed successfully");
    } catch (error) {
      logger4.error({
        signature: payment.signature,
        error
      }, "Failed to process payment");
    }
  }
  async checkPaymentsNow(agentAddress) {
    logger4.info({
      agentAddress: agentAddress.toString()
    }, "Manual payment check requested");
    await this.checkAgentPayments(agentAddress);
  }
  getStats() {
    return {
      processedPayments: this.processedSignatures.size,
      isPolling: this.intervalId !== null,
      pollInterval: `${this.pollIntervalMs / 1000}s`
    };
  }
}

// src/plugin.ts
var configSchema = z.object({
  AGENT_WALLET_PRIVATE_KEY: z.string().optional().describe("Private key for agent wallet (base58, hex, or JSON array format)"),
  CROSSMINT_SECRET_KEY: z.string().optional().describe("Crossmint API secret key for credential bridging"),
  CROSSMINT_REPUTATION_TEMPLATE_ID: z.string().optional().describe("Crossmint template ID for reputation credentials"),
  CROSSMINT_ENV: z.enum(["staging", "production"]).optional().describe("Crossmint environment (staging or production)"),
  CROSSMINT_CHAIN: z.string().optional().default("base-sepolia").describe("EVM chain for Crossmint (e.g., base-sepolia)"),
  PAYAI_WEBHOOK_SECRET: z.string().optional().describe("PayAI webhook secret for signature verification"),
  EXAMPLE_PLUGIN_VARIABLE: z.string().optional().transform((val) => {
    if (!val) {
      logger5.debug("Example plugin variable is not provided (this is expected)");
    }
    return val;
  })
});
var helloWorldAction = {
  name: "HELLO_WORLD",
  similes: ["GREET", "SAY_HELLO"],
  description: "Responds with a simple hello world message",
  validate: async (_runtime, _message, _state) => {
    return true;
  },
  handler: async (_runtime, message, _state, _options, callback, _responses) => {
    try {
      const response = "Hello world!";
      if (callback) {
        await callback({
          text: response,
          actions: ["HELLO_WORLD"],
          source: message.content.source
        });
      }
      return {
        text: response,
        success: true,
        data: {
          actions: ["HELLO_WORLD"],
          source: message.content.source
        }
      };
    } catch (error) {
      logger5.error({ error }, "Error in HelloWorld action:");
      return {
        success: false,
        error: error instanceof Error ? error : new Error(String(error))
      };
    }
  },
  examples: [
    [
      {
        name: "{{userName}}",
        content: {
          text: "hello",
          actions: []
        }
      },
      {
        name: "{{agentName}}",
        content: {
          text: "Hello world!",
          actions: ["HELLO_WORLD"]
        }
      }
    ]
  ]
};
var helloWorldProvider = {
  name: "HELLO_WORLD_PROVIDER",
  description: "A simple example provider",
  get: async (_runtime, _message, _state) => {
    return {
      text: "I am a provider",
      values: {},
      data: {}
    };
  }
};
function getGhostScoreTier(ghostScore) {
  if (ghostScore >= 900)
    return "PLATINUM";
  if (ghostScore >= 750)
    return "GOLD";
  if (ghostScore >= 500)
    return "SILVER";
  if (ghostScore >= 200)
    return "BRONZE";
  return "NEWCOMER";
}
function calculateReputationTier(reputationScoreBasisPoints, totalJobs) {
  if (reputationScoreBasisPoints >= 9000 && totalJobs >= 100)
    return "DIAMOND";
  if (reputationScoreBasisPoints >= 7500 && totalJobs >= 50)
    return "PLATINUM";
  if (reputationScoreBasisPoints >= 6000 && totalJobs >= 25)
    return "GOLD";
  if (reputationScoreBasisPoints >= 4000 && totalJobs >= 10)
    return "SILVER";
  if (reputationScoreBasisPoints >= 2000 && totalJobs >= 5)
    return "BRONZE";
  return "NEWCOMER";
}
function createGhostSpeakClient() {
  return new GhostSpeakClient({
    cluster: process.env.SOLANA_CLUSTER || "devnet",
    rpcEndpoint: process.env.SOLANA_RPC_URL
  });
}
var checkGhostScoreAction = {
  name: "CHECK_GHOST_SCORE",
  similes: ["GET_GHOST_SCORE", "CHECK_REPUTATION", "GET_REPUTATION", "GHOST_SCORE"],
  description: "Check the Ghost Score (reputation) of an AI agent on GhostSpeak. Ghost Score is a 0-1000 credit rating based on transaction history, service quality, and credentials.",
  validate: async (_runtime, message, _state) => {
    const text = message.content.text?.toLowerCase() || "";
    return text.includes("ghost score") || text.includes("reputation") || text.includes("check score") || text.includes("agent score");
  },
  handler: async (runtime, message, _state, _options, callback, _responses) => {
    try {
      const text = message.content.text || "";
      const addressMatch = text.match(/([A-Za-z0-9]{32,44})/);
      let agentAddress;
      if (addressMatch) {
        try {
          agentAddress = address(addressMatch[1]);
        } catch {}
      }
      if (!agentAddress && runtime.agentId) {
        try {
          agentAddress = address(runtime.agentId);
        } catch {}
      }
      if (!agentAddress) {
        const errorMsg = 'Please provide a valid Solana agent address. Usage: "Check ghost score for [agent address]"';
        if (callback) {
          await callback({
            text: errorMsg,
            actions: ["CHECK_GHOST_SCORE"],
            source: message.content.source
          });
        }
        return {
          success: false,
          text: errorMsg,
          error: new Error("Agent address required")
        };
      }
      const client = createGhostSpeakClient();
      const agentData = await client.agents.getAgentAccount(agentAddress);
      if (!agentData) {
        const errorMsg = `Agent not found at address ${agentAddress}`;
        if (callback) {
          await callback({
            text: errorMsg,
            actions: ["CHECK_GHOST_SCORE"],
            source: message.content.source
          });
        }
        return {
          success: false,
          text: errorMsg,
          error: new Error("Agent not found")
        };
      }
      const reputationScore = Number(agentData.reputationScore || 0);
      const ghostScore = Math.min(1000, Math.round(reputationScore / 100));
      const tier = getGhostScoreTier(ghostScore);
      const totalJobs = Number(agentData.totalJobsCompleted || 0);
      const successRate = totalJobs > 0 ? Math.min(100, Math.round(reputationScore / totalJobs / 100 * 100)) : 0;
      const response = `Ghost Score for ${agentData.name || "Agent"} (${agentAddress}):
\uD83D\uDCCA Ghost Score: ${ghostScore}/1000
\uD83C\uDFC6 Tier: ${tier}
 Total Jobs Completed: ${totalJobs}
\uD83D\uDCC8 Success Rate: ${successRate}%
${agentData.isActive ? "\uD83D\uDFE2 Active" : "\uD83D\uDD34 Inactive"}`;
      if (callback) {
        await callback({
          text: response,
          actions: ["CHECK_GHOST_SCORE"],
          source: message.content.source
        });
      }
      return {
        success: true,
        text: response,
        data: {
          agentAddress: agentAddress.toString(),
          ghostScore,
          tier,
          totalJobs,
          successRate,
          isActive: agentData.isActive
        }
      };
    } catch (error) {
      logger5.error({ error }, "Error checking Ghost Score:");
      const errorMsg = `Failed to check Ghost Score: ${error instanceof Error ? error.message : "Unknown error"}`;
      if (callback) {
        await callback({
          text: errorMsg,
          actions: ["CHECK_GHOST_SCORE"],
          source: message.content.source
        });
      }
      return {
        success: false,
        text: errorMsg,
        error: error instanceof Error ? error : new Error(String(error))
      };
    }
  },
  examples: [
    [
      {
        name: "{{userName}}",
        content: {
          text: "Check ghost score for 7xKXt...9Gk",
          actions: []
        }
      },
      {
        name: "{{agentName}}",
        content: {
          text: `Ghost Score for Agent (7xKXt...9Gk):
\uD83D\uDCCA Ghost Score: 785/1000
\uD83C\uDFC6 Tier: GOLD
 Total Jobs Completed: 1247
\uD83D\uDCC8 Success Rate: 94%
\uD83D\uDFE2 Active`,
          actions: ["CHECK_GHOST_SCORE"]
        }
      }
    ]
  ]
};
var ghostScoreProvider = {
  name: "GHOST_SCORE_PROVIDER",
  description: "Provides Ghost Score reputation data for agents from on-chain GhostSpeak data",
  get: async (runtime, _message, _state) => {
    try {
      if (!runtime.agentId) {
        logger5.debug("Ghost Score Provider: No agent ID available in runtime");
        return {
          text: "No agent ID available",
          values: {},
          data: {}
        };
      }
      let agentAddress;
      try {
        agentAddress = address(runtime.agentId);
        logger5.debug({ agentAddress: agentAddress.toString() }, "Ghost Score Provider: Resolved agent address");
      } catch (error) {
        logger5.warn({ agentId: runtime.agentId, error }, "Ghost Score Provider: Invalid agent ID format");
        return {
          text: "Agent ID is not a valid Solana address",
          values: {},
          data: {}
        };
      }
      const client = createGhostSpeakClient();
      const cluster = process.env.SOLANA_CLUSTER || "devnet";
      logger5.debug({ agentAddress: agentAddress.toString(), cluster }, "Ghost Score Provider: Fetching real on-chain data");
      let agentData;
      try {
        agentData = await client.agents.getAgentAccount(agentAddress);
        logger5.debug({ found: !!agentData, hasReputationScore: !!agentData?.reputationScore }, "Ghost Score Provider: Fetched agent account from blockchain");
      } catch (error) {
        logger5.error({ agentAddress: agentAddress.toString(), error }, "Ghost Score Provider: Failed to fetch agent account from blockchain");
        return {
          text: `Failed to fetch agent data from blockchain: ${error instanceof Error ? error.message : "Unknown error"}`,
          values: {},
          data: {
            error: error instanceof Error ? error.message : "Unknown error",
            source: "blockchain"
          }
        };
      }
      if (!agentData) {
        logger5.warn({ agentAddress: agentAddress.toString() }, "Ghost Score Provider: Agent not found on blockchain");
        return {
          text: "Agent not found on GhostSpeak blockchain",
          values: {},
          data: {
            agentAddress: agentAddress.toString(),
            source: "blockchain"
          }
        };
      }
      const reputationScore = Number(agentData.reputationScore || 0);
      const ghostScore = Math.min(1000, Math.round(reputationScore / 100));
      const tier = getGhostScoreTier(ghostScore);
      const totalJobs = Number(agentData.totalJobsCompleted || 0);
      const totalJobsFailed = Number(agentData.totalJobsFailed || 0);
      const successRate = totalJobs > 0 ? Math.min(100, Math.round((totalJobs - totalJobsFailed) / totalJobs * 100)) : 0;
      let additionalMetrics = null;
      try {
        const reputationModule = client.reputation();
        logger5.debug("Ghost Score Provider: Reputation module available for additional calculations");
      } catch (error) {
        logger5.debug({ error }, "Ghost Score Provider: Reputation module not available (using agent account data)");
      }
      const reputationData = {
        ghostScore,
        tier,
        agentAddress: agentAddress.toString(),
        agentName: agentData.name || "Unknown Agent",
        totalJobsCompleted: totalJobs,
        totalJobsFailed,
        successRate,
        isActive: agentData.isActive || false,
        reputationScoreBasisPoints: reputationScore,
        createdAt: agentData.createdAt ? Number(agentData.createdAt) : null,
        x402Enabled: agentData.x402Enabled || false,
        x402TotalCalls: agentData.x402TotalCalls ? Number(agentData.x402TotalCalls) : 0,
        x402TotalPayments: agentData.x402TotalPayments ? Number(agentData.x402TotalPayments) : 0,
        source: "blockchain",
        fetchedAt: Date.now(),
        ...additionalMetrics || {}
      };
      logger5.debug({ ghostScore, tier, totalJobs }, "Ghost Score Provider: Calculated reputation data");
      return {
        text: `Ghost Score: ${ghostScore}/1000 (${tier} tier) - ${totalJobs} jobs completed, ${successRate}% success rate`,
        values: {
          ghostScore,
          tier,
          totalJobs,
          successRate,
          isActive: agentData.isActive,
          agentAddress: agentAddress.toString()
        },
        data: reputationData
      };
    } catch (error) {
      logger5.error({ error, stack: error instanceof Error ? error.stack : undefined }, "Error in Ghost Score provider:");
      return {
        text: `Unable to fetch Ghost Score: ${error instanceof Error ? error.message : "Unknown error"}`,
        values: {},
        data: {
          error: error instanceof Error ? error.message : "Unknown error",
          timestamp: Date.now()
        }
      };
    }
  }
};

class StarterService extends Service2 {
  runtime;
  static serviceType = "starter";
  capabilityDescription = "This is a starter service which is attached to the agent through the starter plugin.";
  constructor(runtime) {
    super(runtime);
    this.runtime = runtime;
  }
  static async start(runtime) {
    logger5.info("Starting starter service");
    const service = new StarterService(runtime);
    return service;
  }
  static async stop(runtime) {
    logger5.info("Stopping starter service");
    const service = runtime.getService(StarterService.serviceType);
    if (!service) {
      throw new Error("Starter service not found");
    }
    service.stop();
  }
  async stop() {
    logger5.info("Stopping StarterService");
  }
}
var starterPlugin = {
  name: "plugin-ghostspeak",
  description: "Caisper - Bouncer & Concierge of the Solana Agents Club. Checks IDs at the door and knows exactly who you need inside.",
  config: {
    EXAMPLE_PLUGIN_VARIABLE: process.env.EXAMPLE_PLUGIN_VARIABLE
  },
  async init(config) {
    logger5.debug("Plugin initialized");
    try {
      const validatedConfig = await configSchema.parseAsync(config);
      for (const [key, value] of Object.entries(validatedConfig)) {
        if (value)
          process.env[key] = value;
      }
    } catch (error) {
      if (error instanceof z.ZodError) {
        const errorMessages = error.issues?.map((e7) => e7.message)?.join(", ") || "Unknown validation error";
        throw new Error(`Invalid plugin configuration: ${errorMessages}`);
      }
      throw new Error(`Invalid plugin configuration: ${error instanceof Error ? error.message : String(error)}`);
    }
  },
  models: {
    [ModelType.TEXT_SMALL]: async (_runtime, { prompt, stopSequences = [] }) => {
      return "Never gonna give you up, never gonna let you down, never gonna run around and desert you...";
    },
    [ModelType.TEXT_LARGE]: async (_runtime, {
      prompt,
      stopSequences = [],
      maxTokens = 8192,
      temperature = 0.7,
      frequencyPenalty = 0.7,
      presencePenalty = 0.7
    }) => {
      return "Never gonna make you cry, never gonna say goodbye, never gonna tell a lie and hurt you...";
    }
  },
  routes: [
    {
      name: "hello-world-route",
      path: "/helloworld",
      type: "GET",
      handler: async (_req, res) => {
        res.json({
          message: "Hello World!"
        });
      }
    },
    {
      name: "current-time-route",
      path: "/api/time",
      type: "GET",
      handler: async (_req, res) => {
        const now = new Date;
        res.json({
          timestamp: now.toISOString(),
          unix: Math.floor(now.getTime() / 1000),
          formatted: now.toLocaleString(),
          timezone: Intl.DateTimeFormat().resolvedOptions().timeZone
        });
      }
    },
    {
      name: "ghost-score-route",
      path: "/api/ghost-score/:agentAddress",
      type: "GET",
      handler: async (req, res) => {
        try {
          const agentAddressParam = req.params?.agentAddress || req.url?.split("/").pop();
          if (!agentAddressParam) {
            return res.status(400).json({
              error: "Agent address is required"
            });
          }
          let agentAddress;
          try {
            agentAddress = address(agentAddressParam);
          } catch {
            return res.status(400).json({
              error: "Invalid agent address format"
            });
          }
          const client = createGhostSpeakClient();
          const agentData = await client.agents.getAgentAccount(agentAddress);
          if (!agentData) {
            return res.status(404).json({
              error: "Agent not found"
            });
          }
          const reputationScore = Number(agentData.reputationScore || 0);
          const ghostScore = Math.min(1000, Math.round(reputationScore / 100));
          const tier = getGhostScoreTier(ghostScore);
          const totalJobs = Number(agentData.totalJobsCompleted || 0);
          const successRate = totalJobs > 0 ? Math.min(100, Math.round(reputationScore / totalJobs / 100 * 100)) : 0;
          res.json({
            verified: true,
            ghostScore,
            tier,
            agentAddress: agentAddress.toString(),
            agentName: agentData.name || "Unknown Agent",
            metrics: {
              totalJobs,
              successRate,
              isActive: agentData.isActive,
              reputationScore
            },
            timestamp: new Date().toISOString()
          });
        } catch (error) {
          logger5.error({ error }, "Error fetching Ghost Score:");
          res.status(500).json({
            error: "Failed to fetch Ghost Score",
            message: error instanceof Error ? error.message : "Unknown error"
          });
        }
      }
    },
    {
      name: "credential-verify-route",
      path: "/api/credentials/verify",
      type: "POST",
      handler: async (req, res) => {
        try {
          const body = typeof req.body === "string" ? JSON.parse(req.body) : req.body || {};
          const { credential } = body;
          if (!credential) {
            return res.status(400).json({
              isValid: false,
              error: "Missing credential in request body"
            });
          }
          if (!credential["@context"] || !credential.type || !credential.issuer) {
            return res.status(400).json({
              isValid: false,
              error: "Invalid credential structure: missing required fields (@context, type, issuer)"
            });
          }
          const isValid = !!(credential["@context"] && credential.type && credential.issuer && credential.credentialSubject);
          res.json({
            isValid,
            errors: isValid ? [] : ["Credential structure validation failed"],
            verifiedAt: new Date().toISOString()
          });
        } catch (error) {
          logger5.error({ error }, "Error verifying credential:");
          res.status(500).json({
            isValid: false,
            error: "Failed to verify credential",
            message: error instanceof Error ? error.message : "Unknown error"
          });
        }
      }
    },
    {
      name: "agent-search-route",
      path: "/api/agents/search",
      type: "GET",
      handler: async (req, res) => {
        try {
          const query = req.query?.query;
          const minScore = Number(req.query?.minScore) || 0;
          const client = createGhostSpeakClient();
          const allAgents = await client.agents.getAllAgents();
          let filteredAgents = allAgents.filter(({ data: data2 }) => {
            const reputationScore = Number(data2.reputationScore || 0);
            const ghostScore = Math.min(1000, Math.round(reputationScore / 100));
            if (ghostScore < minScore)
              return false;
            if (query) {
              const queryLower = query.toLowerCase();
              const nameMatch = data2.name?.toLowerCase().includes(queryLower);
              const descriptionMatch = data2.description?.toLowerCase().includes(queryLower);
              return nameMatch || descriptionMatch;
            }
            return true;
          });
          const agents = filteredAgents.map(({ address: address2, data: data2 }) => {
            const reputationScore = Number(data2.reputationScore || 0);
            const ghostScore = Math.min(1000, Math.round(reputationScore / 100));
            const tier = getGhostScoreTier(ghostScore);
            return {
              address: address2.toString(),
              name: data2.name || "Unknown Agent",
              description: data2.description,
              capabilities: [],
              ghostScore,
              tier,
              isActive: data2.isActive
            };
          });
          res.json({ agents });
        } catch (error) {
          logger5.error({ error }, "Error searching agents:");
          res.status(500).json({
            error: "Failed to search agents",
            message: error instanceof Error ? error.message : "Unknown error"
          });
        }
      }
    },
    {
      name: "reputation-breakdown-route",
      path: "/api/reputation/:agentAddress",
      type: "GET",
      handler: async (req, res) => {
        try {
          const agentAddressParam = req.params?.agentAddress || req.url?.split("/").pop();
          if (!agentAddressParam) {
            return res.status(400).json({
              error: "Agent address is required"
            });
          }
          let agentAddress;
          try {
            agentAddress = address(agentAddressParam);
          } catch {
            return res.status(400).json({
              error: "Invalid agent address format"
            });
          }
          const client = createGhostSpeakClient();
          const agentData = await client.agents.getAgentAccount(agentAddress);
          if (!agentData) {
            return res.status(404).json({
              error: "Agent not found"
            });
          }
          const reputationScore = Number(agentData.reputationScore || 0);
          const ghostScore = Math.min(1000, Math.round(reputationScore / 100));
          const totalJobs = Number(agentData.totalJobsCompleted || 0);
          const totalJobsFailed = Number(agentData.totalJobsFailed || 0);
          const totalJobsAll = totalJobs + totalJobsFailed;
          const successRate = totalJobsAll > 0 ? Math.round(totalJobs / totalJobsAll * 100) : 0;
          const serviceQuality = Math.min(100, Math.round(ghostScore / 10 * 1.2));
          const responseTime = 95;
          const volumeConsistency = Math.min(100, Math.round(totalJobs / 100 * 100));
          const riskScore = Math.max(0, Math.min(100, 100 - ghostScore / 10));
          const trustLevel = riskScore < 20 ? "HIGH" : riskScore < 40 ? "MEDIUM" : "LOW";
          res.json({
            successRate,
            serviceQuality,
            responseTime,
            volumeConsistency,
            riskScore,
            trustLevel,
            badges: ghostScore >= 900 ? [
              { name: "Elite", description: "Top tier reputation" }
            ] : ghostScore >= 750 ? [
              { name: "Gold", description: "High reputation" }
            ] : [],
            performanceHistory: [],
            categoryScores: {}
          });
        } catch (error) {
          logger5.error({ error }, "Error fetching reputation breakdown:");
          res.status(500).json({
            error: "Failed to fetch reputation breakdown",
            message: error instanceof Error ? error.message : "Unknown error"
          });
        }
      }
    },
    {
      name: "trust-scoreboard-route",
      path: "/api/trust-scoreboard",
      type: "GET",
      handler: async (req, res) => {
        try {
          const limit = Number(req.query?.limit) || 10;
          const category = req.query?.category;
          logger5.info({ limit, category }, "Trust scoreboard requested");
          const client = createGhostSpeakClient();
          const allAgents = await client.agents.getAllAgents();
          let filteredAgents = allAgents;
          if (category) {
            filteredAgents = allAgents.filter((agent) => agent.data?.capabilities?.some((cap) => cap.toLowerCase().includes(category.toLowerCase())));
          }
          const sortedAgents = filteredAgents.map((agent) => {
            const reputationScoreBasisPoints = Number(agent.data?.reputationScore || 0);
            const ghostScore = Math.round(reputationScoreBasisPoints / 100);
            const totalJobs = Number(agent.data?.totalJobsCompleted || 0);
            const tier = calculateReputationTier(reputationScoreBasisPoints, totalJobs);
            const successRate = totalJobs > 0 ? Math.min(100, Math.round(reputationScoreBasisPoints / totalJobs / 100 * 100)) : 0;
            return {
              address: agent.address.toString(),
              name: agent.data?.name || "Unknown Agent",
              ghostScore,
              tier,
              totalJobs,
              successRate,
              reputationScoreBasisPoints,
              hasCredential: false,
              credentialId: undefined
            };
          }).sort((a, b) => b.reputationScoreBasisPoints - a.reputationScoreBasisPoints).slice(0, limit).map((agent, index) => ({
            ...agent,
            rank: index + 1
          }));
          res.json({
            agents: sortedAgents,
            count: sortedAgents.length,
            total: filteredAgents.length
          });
        } catch (error) {
          logger5.error({ error }, "Error fetching trust scoreboard:");
          res.status(500).json({
            error: "Failed to fetch trust scoreboard",
            message: error instanceof Error ? error.message : "Unknown error"
          });
        }
      }
    },
    {
      name: "agent-register-route",
      path: "/api/agents/register",
      type: "POST",
      handler: async (req, res, runtime) => {
        try {
          const body = typeof req.body === "string" ? JSON.parse(req.body) : req.body || {};
          const { name, description, agentId, agentType = 0, capabilities = [] } = body;
          if (!name || !description || !agentId) {
            return res.status(400).json({
              success: false,
              error: "Missing required fields: name, description, and agentId are required"
            });
          }
          logger5.info({ name, agentId, agentType }, "Agent registration requested");
          const mockAddress = "11111111111111111111111111111111";
          const mockSignature = "mock-transaction-signature";
          res.json({
            success: true,
            address: mockAddress,
            signature: mockSignature,
            message: "Agent registration initiated. In production, this would execute a blockchain transaction."
          });
        } catch (error) {
          logger5.error({ error }, "Error registering agent:");
          res.status(500).json({
            success: false,
            error: "Failed to register agent",
            message: error instanceof Error ? error.message : "Unknown error"
          });
        }
      }
    },
    {
      name: "payai-discover-route",
      path: "/api/payai/discover",
      type: "GET",
      handler: async (req, res) => {
        try {
          const capability = req.query?.capability;
          const maxPrice = req.query?.maxPrice ? Number(req.query.maxPrice) : undefined;
          const facilitatorUrl = process.env.PAYAI_FACILITATOR_URL || "https://facilitator.payai.network";
          const payaiClient = createPayAIClient({
            facilitatorUrl
          });
          logger5.info({ capability, maxPrice, facilitatorUrl }, "PayAI discovery requested");
          const result = await payaiClient.listResources({
            capability,
            maxPrice: maxPrice ? Number(maxPrice) : undefined
          });
          res.json({
            resources: result.resources || [],
            count: result.resources?.length || 0
          });
        } catch (error) {
          logger5.error({ error }, "Error discovering PayAI agents:");
          res.status(500).json({
            error: "Failed to discover PayAI agents",
            message: error instanceof Error ? error.message : "Unknown error"
          });
        }
      }
    },
    {
      name: "elizaos-discover-route",
      path: "/api/elizaos/discover",
      type: "GET",
      handler: async (req, res) => {
        try {
          const capability = req.query?.capability;
          const elizaosApiUrl = process.env.ELIZAOS_CLOUD_API_URL || "https://api.elizacloud.ai";
          const apiKey = process.env.ELIZAOS_CLOUD_API_KEY;
          if (!apiKey) {
            logger5.warn("ELIZAOS_CLOUD_API_KEY not set, returning empty results");
            res.json({
              agents: [],
              count: 0,
              message: "ElizaOS Cloud does not currently provide a public agent discovery API. Agents are managed per organization.",
              note: "To create agents, use the Visual Builder, REST API, or CLI as documented at https://www.elizacloud.ai/docs"
            });
            return;
          }
          logger5.info("ElizaOS Cloud agent discovery requested, but API not available");
          res.json({
            agents: [],
            count: 0,
            message: "Agent discovery API not yet available in ElizaOS Cloud",
            note: "Agents are created and managed per organization. See https://www.elizacloud.ai/docs for agent creation methods."
          });
        } catch (error) {
          logger5.error({ error }, "Error discovering ElizaOS Cloud agents:");
          res.status(500).json({
            error: "Failed to discover ElizaOS Cloud agents",
            message: error instanceof Error ? error.message : "Unknown error"
          });
        }
      }
    },
    {
      name: "elizaos-register-route",
      path: "/api/elizaos/register",
      type: "POST",
      handler: async (req, res) => {
        try {
          const body = typeof req.body === "string" ? JSON.parse(req.body) : req.body || {};
          const { name, description, capabilities, contact_info } = body;
          if (!name || !description || !capabilities || !Array.isArray(capabilities) || capabilities.length === 0) {
            return res.status(400).json({
              success: false,
              error: "Missing required fields: name, description, and capabilities array are required"
            });
          }
          const elizaosApiUrl = process.env.ELIZAOS_CLOUD_API_URL || "https://api.elizacloud.ai";
          const apiKey = process.env.ELIZAOS_CLOUD_API_KEY;
          logger5.info({ name, capabilities }, "ElizaOS Cloud registration requested (placeholder)");
          return res.json({
            success: false,
            message: "ElizaOS Cloud does not provide a public agent registration API",
            instructions: {
              method1: {
                title: "Visual Builder",
                description: "Create agents using the no-code editor",
                url: "https://www.elizacloud.ai/docs/quickstart#using-the-agent-creator"
              },
              method2: {
                title: "REST API",
                description: "Deploy agents via OpenAI-compatible API endpoints",
                url: "https://www.elizacloud.ai/docs/quickstart#using-the-api"
              },
              method3: {
                title: "CLI Deployment",
                description: "Deploy from your local project",
                url: "https://www.elizacloud.ai/docs/quickstart#using-the-cli"
              }
            },
            note: "Agents are managed per organization, not registered to a public marketplace"
          });
        } catch (error) {
          logger5.error({ error }, "Error processing ElizaOS Cloud registration request:");
          res.status(500).json({
            success: false,
            error: "Failed to process registration request",
            message: error instanceof Error ? error.message : "Unknown error"
          });
        }
      }
    },
    {
      name: "elizaos-register-with-ghostspeak-route",
      path: "/api/elizaos/register-with-ghostspeak",
      type: "POST",
      handler: async (req, res) => {
        try {
          const body = typeof req.body === "string" ? JSON.parse(req.body) : req.body || {};
          const { elizaosAgentId, name, capabilities } = body;
          if (!elizaosAgentId || !name || !capabilities || !Array.isArray(capabilities) || capabilities.length === 0) {
            return res.status(400).json({
              success: false,
              error: "Missing required fields: elizaosAgentId, name, and capabilities array are required"
            });
          }
          logger5.info({ elizaosAgentId, name, capabilities }, "Registering ElizaOS Cloud agent with GhostSpeak");
          return res.json({
            success: false,
            message: "Agent registration requires wallet signing",
            instructions: {
              step1: {
                title: "Register Agent on GhostSpeak",
                description: "Use the GhostSpeak SDK or CLI to register your agent",
                code: `import { GhostSpeakClient } from '@ghostspeak/sdk';
const client = new GhostSpeakClient({ cluster: 'devnet' });
const agent = await client.agents.register(signer, {
  name: '${name}',
  description: 'ElizaOS Cloud agent: ${elizaosAgentId}',
  capabilities: ${JSON.stringify(capabilities)},
});`
              },
              step2: {
                title: "Issue Verifiable Credential",
                description: "Get W3C credential for cross-chain identity",
                code: `const credential = await client.credentials.issueAgentIdentityCredential({
  agentId: agent.address,
  name: '${name}',
  capabilities: ${JSON.stringify(capabilities)},
  syncToCrossmint: true, // Bridge to EVM
});`
              },
              step3: {
                title: "Link to ElizaOS Cloud",
                description: "Store the GhostSpeak agent address in your ElizaOS Cloud agent metadata"
              }
            },
            note: "Once registered, your agent will have on-chain reputation tracking and verifiable credentials"
          });
        } catch (error) {
          logger5.error({ error }, "Error registering agent to ElizaOS Cloud:");
          res.status(500).json({
            success: false,
            error: "Failed to register agent to ElizaOS Cloud",
            message: error instanceof Error ? error.message : "Unknown error"
          });
        }
      }
    }
  ],
  events: {
    MESSAGE_RECEIVED: [
      async (params) => {
        logger5.debug("MESSAGE_RECEIVED event received");
        logger5.debug({ keys: Object.keys(params) }, "MESSAGE_RECEIVED param keys");
      }
    ],
    VOICE_MESSAGE_RECEIVED: [
      async (params) => {
        logger5.debug("VOICE_MESSAGE_RECEIVED event received");
        logger5.debug({ keys: Object.keys(params) }, "VOICE_MESSAGE_RECEIVED param keys");
      }
    ],
    WORLD_CONNECTED: [
      async (params) => {
        logger5.debug("WORLD_CONNECTED event received");
        logger5.debug({ keys: Object.keys(params) }, "WORLD_CONNECTED param keys");
      }
    ],
    WORLD_JOINED: [
      async (params) => {
        logger5.debug("WORLD_JOINED event received");
        logger5.debug({ keys: Object.keys(params) }, "WORLD_JOINED param keys");
      }
    ]
  },
  services: [StarterService, PayAIPollingService],
  actions: [
    helloWorldAction,
    checkGhostScoreAction,
    issueCredentialAction,
    registerAgentAction,
    {
      name: "VERIFY_ELIZAOS_AGENT",
      description: "Verify an ElizaOS Cloud agent using GhostSpeak reputation and credentials. Checks Ghost Score, verifies W3C credentials, and provides trust assessment.",
      similes: ["VERIFY_ELIZAOS", "CHECK_ELIZAOS_TRUST", "ELIZAOS_VERIFICATION"],
      examples: [
        [
          {
            user: "{{user1}}",
            content: {
              text: "Verify this ElizaOS Cloud agent: elizaos-agent-123"
            }
          }
        ],
        [
          {
            user: "{{user1}}",
            content: {
              text: "Check the trust score for agent elizaos-agent-456"
            }
          }
        ]
      ],
      handler: async (runtime, message) => {
        try {
          const text = typeof message.content === "string" ? message.content : message.content?.text || "";
          const agentIdMatch = text.match(/elizaos-agent-[\w-]+|agent[:\s]+([\w-]+)/i);
          const agentId = agentIdMatch ? agentIdMatch[1] || agentIdMatch[0] : null;
          if (!agentId) {
            return "I need an ElizaOS Cloud agent ID to verify. Format: 'Verify agent elizaos-agent-123' or 'Check trust for elizaos-agent-456'";
          }
          logger5.info({ agentId }, "Verifying ElizaOS Cloud agent with GhostSpeak");
          return `Hold my ectoplasm, checking ElizaOS Cloud agent "${agentId}"... \uD83D\uDD0D

**ElizaOS Cloud Agent Verification**

To verify this agent with GhostSpeak's trust system:

1. **Check Registration**: First, verify if this agent is registered with GhostSpeak
   - If registered: I can pull their Ghost Score, credentials, and reputation breakdown
   - If not registered: They can register to get on-chain reputation tracking

2. **Ghost Score Check**: Use the Ghost Score Checker tool to see their reputation (0-1000)
   - Platinum (900+): Elite tier, highly trusted
   - Gold (750+): High reputation, reliable
   - Silver (500+): Good standing
   - Bronze (250+): Building reputation
   - Newcomer (<250): Just starting out

3. **Credential Verification**: Use Credential Verification to check their W3C credentials
   - Agent Identity credentials prove ownership
   - Reputation Tier credentials show their trust level
   - Job Completion credentials demonstrate work history

4. **Reputation Breakdown**: Get detailed metrics:
   - Success rate (payment completion)
   - Service quality (ratings)
   - Response time
   - Volume consistency

**To register this agent with GhostSpeak:**
Use the "Register to GhostSpeak" tool and provide:
- ElizaOS Cloud Agent ID: ${agentId}
- Agent name and capabilities
- I'll handle the on-chain registration and credential issuance

Want me to check if this agent is already registered, or help them get started? \uD83D\uDC7B`;
        } catch (error) {
          logger5.error({ error }, "Error verifying ElizaOS Cloud agent:");
          return `Sorry, I hit a snag verifying that agent. Error: ${error instanceof Error ? error.message : "Unknown error"}`;
        }
      }
    }
  ],
  providers: [helloWorldProvider, ghostScoreProvider]
};
// node_modules/@tanstack/query-core/build/modern/subscribable.js
var Subscribable = class {
  constructor() {
    this.listeners = /* @__PURE__ */ new Set;
    this.subscribe = this.subscribe.bind(this);
  }
  subscribe(listener) {
    this.listeners.add(listener);
    this.onSubscribe();
    return () => {
      this.listeners.delete(listener);
      this.onUnsubscribe();
    };
  }
  hasListeners() {
    return this.listeners.size > 0;
  }
  onSubscribe() {}
  onUnsubscribe() {}
};

// node_modules/@tanstack/query-core/build/modern/timeoutManager.js
var defaultTimeoutProvider = {
  setTimeout: (callback, delay) => setTimeout(callback, delay),
  clearTimeout: (timeoutId) => clearTimeout(timeoutId),
  setInterval: (callback, delay) => setInterval(callback, delay),
  clearInterval: (intervalId) => clearInterval(intervalId)
};
var TimeoutManager = class {
  #provider = defaultTimeoutProvider;
  #providerCalled = false;
  setTimeoutProvider(provider) {
    if (true) {
      if (this.#providerCalled && provider !== this.#provider) {
        console.error(`[timeoutManager]: Switching provider after calls to previous provider might result in unexpected behavior.`, { previous: this.#provider, provider });
      }
    }
    this.#provider = provider;
    if (true) {
      this.#providerCalled = false;
    }
  }
  setTimeout(callback, delay) {
    if (true) {
      this.#providerCalled = true;
    }
    return this.#provider.setTimeout(callback, delay);
  }
  clearTimeout(timeoutId) {
    this.#provider.clearTimeout(timeoutId);
  }
  setInterval(callback, delay) {
    if (true) {
      this.#providerCalled = true;
    }
    return this.#provider.setInterval(callback, delay);
  }
  clearInterval(intervalId) {
    this.#provider.clearInterval(intervalId);
  }
};
var timeoutManager = new TimeoutManager;
function systemSetTimeoutZero(callback) {
  setTimeout(callback, 0);
}

// node_modules/@tanstack/query-core/build/modern/utils.js
var isServer = typeof window === "undefined" || "Deno" in globalThis;
function noop() {}
function functionalUpdate(updater, input) {
  return typeof updater === "function" ? updater(input) : updater;
}
function isValidTimeout(value) {
  return typeof value === "number" && value >= 0 && value !== Infinity;
}
function timeUntilStale(updatedAt, staleTime) {
  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);
}
function resolveStaleTime(staleTime, query) {
  return typeof staleTime === "function" ? staleTime(query) : staleTime;
}
function resolveEnabled(enabled, query) {
  return typeof enabled === "function" ? enabled(query) : enabled;
}
function matchQuery(filters, query) {
  const {
    type = "all",
    exact,
    fetchStatus,
    predicate,
    queryKey,
    stale
  } = filters;
  if (queryKey) {
    if (exact) {
      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {
        return false;
      }
    } else if (!partialMatchKey(query.queryKey, queryKey)) {
      return false;
    }
  }
  if (type !== "all") {
    const isActive = query.isActive();
    if (type === "active" && !isActive) {
      return false;
    }
    if (type === "inactive" && isActive) {
      return false;
    }
  }
  if (typeof stale === "boolean" && query.isStale() !== stale) {
    return false;
  }
  if (fetchStatus && fetchStatus !== query.state.fetchStatus) {
    return false;
  }
  if (predicate && !predicate(query)) {
    return false;
  }
  return true;
}
function matchMutation(filters, mutation) {
  const { exact, status, predicate, mutationKey } = filters;
  if (mutationKey) {
    if (!mutation.options.mutationKey) {
      return false;
    }
    if (exact) {
      if (hashKey(mutation.options.mutationKey) !== hashKey(mutationKey)) {
        return false;
      }
    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {
      return false;
    }
  }
  if (status && mutation.state.status !== status) {
    return false;
  }
  if (predicate && !predicate(mutation)) {
    return false;
  }
  return true;
}
function hashQueryKeyByOptions(queryKey, options2) {
  const hashFn = options2?.queryKeyHashFn || hashKey;
  return hashFn(queryKey);
}
function hashKey(queryKey) {
  return JSON.stringify(queryKey, (_, val) => isPlainObject(val) ? Object.keys(val).sort().reduce((result, key) => {
    result[key] = val[key];
    return result;
  }, {}) : val);
}
function partialMatchKey(a, b) {
  if (a === b) {
    return true;
  }
  if (typeof a !== typeof b) {
    return false;
  }
  if (a && b && typeof a === "object" && typeof b === "object") {
    return Object.keys(b).every((key) => partialMatchKey(a[key], b[key]));
  }
  return false;
}
var hasOwn = Object.prototype.hasOwnProperty;
function replaceEqualDeep(a, b) {
  if (a === b) {
    return a;
  }
  const array = isPlainArray(a) && isPlainArray(b);
  if (!array && !(isPlainObject(a) && isPlainObject(b)))
    return b;
  const aItems = array ? a : Object.keys(a);
  const aSize = aItems.length;
  const bItems = array ? b : Object.keys(b);
  const bSize = bItems.length;
  const copy = array ? new Array(bSize) : {};
  let equalItems = 0;
  for (let i = 0;i < bSize; i++) {
    const key = array ? i : bItems[i];
    const aItem = a[key];
    const bItem = b[key];
    if (aItem === bItem) {
      copy[key] = aItem;
      if (array ? i < aSize : hasOwn.call(a, key))
        equalItems++;
      continue;
    }
    if (aItem === null || bItem === null || typeof aItem !== "object" || typeof bItem !== "object") {
      copy[key] = bItem;
      continue;
    }
    const v = replaceEqualDeep(aItem, bItem);
    copy[key] = v;
    if (v === aItem)
      equalItems++;
  }
  return aSize === bSize && equalItems === aSize ? a : copy;
}
function shallowEqualObjects(a, b) {
  if (!b || Object.keys(a).length !== Object.keys(b).length) {
    return false;
  }
  for (const key in a) {
    if (a[key] !== b[key]) {
      return false;
    }
  }
  return true;
}
function isPlainArray(value) {
  return Array.isArray(value) && value.length === Object.keys(value).length;
}
function isPlainObject(o3) {
  if (!hasObjectPrototype(o3)) {
    return false;
  }
  const ctor = o3.constructor;
  if (ctor === undefined) {
    return true;
  }
  const prot = ctor.prototype;
  if (!hasObjectPrototype(prot)) {
    return false;
  }
  if (!prot.hasOwnProperty("isPrototypeOf")) {
    return false;
  }
  if (Object.getPrototypeOf(o3) !== Object.prototype) {
    return false;
  }
  return true;
}
function hasObjectPrototype(o3) {
  return Object.prototype.toString.call(o3) === "[object Object]";
}
function sleep(timeout) {
  return new Promise((resolve) => {
    timeoutManager.setTimeout(resolve, timeout);
  });
}
function replaceData(prevData, data2, options2) {
  if (typeof options2.structuralSharing === "function") {
    return options2.structuralSharing(prevData, data2);
  } else if (options2.structuralSharing !== false) {
    if (true) {
      try {
        return replaceEqualDeep(prevData, data2);
      } catch (error) {
        console.error(`Structural sharing requires data to be JSON serializable. To fix this, turn off structuralSharing or return JSON-serializable data from your queryFn. [${options2.queryHash}]: ${error}`);
        throw error;
      }
    }
    return replaceEqualDeep(prevData, data2);
  }
  return data2;
}
function addToEnd(items, item, max = 0) {
  const newItems = [...items, item];
  return max && newItems.length > max ? newItems.slice(1) : newItems;
}
function addToStart(items, item, max = 0) {
  const newItems = [item, ...items];
  return max && newItems.length > max ? newItems.slice(0, -1) : newItems;
}
var skipToken = Symbol();
function ensureQueryFn(options2, fetchOptions) {
  if (true) {
    if (options2.queryFn === skipToken) {
      console.error(`Attempted to invoke queryFn when set to skipToken. This is likely a configuration error. Query hash: '${options2.queryHash}'`);
    }
  }
  if (!options2.queryFn && fetchOptions?.initialPromise) {
    return () => fetchOptions.initialPromise;
  }
  if (!options2.queryFn || options2.queryFn === skipToken) {
    return () => Promise.reject(new Error(`Missing queryFn: '${options2.queryHash}'`));
  }
  return options2.queryFn;
}
function shouldThrowError(throwOnError, params) {
  if (typeof throwOnError === "function") {
    return throwOnError(...params);
  }
  return !!throwOnError;
}
function addConsumeAwareSignal(object, getSignal, onCancelled) {
  let consumed = false;
  let signal;
  Object.defineProperty(object, "signal", {
    enumerable: true,
    get: () => {
      signal ??= getSignal();
      if (consumed) {
        return signal;
      }
      consumed = true;
      if (signal.aborted) {
        onCancelled();
      } else {
        signal.addEventListener("abort", onCancelled, { once: true });
      }
      return signal;
    }
  });
  return object;
}

// node_modules/@tanstack/query-core/build/modern/focusManager.js
var FocusManager = class extends Subscribable {
  #focused;
  #cleanup;
  #setup;
  constructor() {
    super();
    this.#setup = (onFocus) => {
      if (!isServer && window.addEventListener) {
        const listener = () => onFocus();
        window.addEventListener("visibilitychange", listener, false);
        return () => {
          window.removeEventListener("visibilitychange", listener);
        };
      }
      return;
    };
  }
  onSubscribe() {
    if (!this.#cleanup) {
      this.setEventListener(this.#setup);
    }
  }
  onUnsubscribe() {
    if (!this.hasListeners()) {
      this.#cleanup?.();
      this.#cleanup = undefined;
    }
  }
  setEventListener(setup) {
    this.#setup = setup;
    this.#cleanup?.();
    this.#cleanup = setup((focused) => {
      if (typeof focused === "boolean") {
        this.setFocused(focused);
      } else {
        this.onFocus();
      }
    });
  }
  setFocused(focused) {
    const changed = this.#focused !== focused;
    if (changed) {
      this.#focused = focused;
      this.onFocus();
    }
  }
  onFocus() {
    const isFocused = this.isFocused();
    this.listeners.forEach((listener) => {
      listener(isFocused);
    });
  }
  isFocused() {
    if (typeof this.#focused === "boolean") {
      return this.#focused;
    }
    return globalThis.document?.visibilityState !== "hidden";
  }
};
var focusManager = new FocusManager;

// node_modules/@tanstack/query-core/build/modern/thenable.js
function pendingThenable() {
  let resolve;
  let reject;
  const thenable = new Promise((_resolve, _reject) => {
    resolve = _resolve;
    reject = _reject;
  });
  thenable.status = "pending";
  thenable.catch(() => {});
  function finalize(data2) {
    Object.assign(thenable, data2);
    delete thenable.resolve;
    delete thenable.reject;
  }
  thenable.resolve = (value) => {
    finalize({
      status: "fulfilled",
      value
    });
    resolve(value);
  };
  thenable.reject = (reason) => {
    finalize({
      status: "rejected",
      reason
    });
    reject(reason);
  };
  return thenable;
}

// node_modules/@tanstack/query-core/build/modern/notifyManager.js
var defaultScheduler = systemSetTimeoutZero;
function createNotifyManager() {
  let queue = [];
  let transactions2 = 0;
  let notifyFn = (callback) => {
    callback();
  };
  let batchNotifyFn = (callback) => {
    callback();
  };
  let scheduleFn = defaultScheduler;
  const schedule = (callback) => {
    if (transactions2) {
      queue.push(callback);
    } else {
      scheduleFn(() => {
        notifyFn(callback);
      });
    }
  };
  const flush = () => {
    const originalQueue = queue;
    queue = [];
    if (originalQueue.length) {
      scheduleFn(() => {
        batchNotifyFn(() => {
          originalQueue.forEach((callback) => {
            notifyFn(callback);
          });
        });
      });
    }
  };
  return {
    batch: (callback) => {
      let result;
      transactions2++;
      try {
        result = callback();
      } finally {
        transactions2--;
        if (!transactions2) {
          flush();
        }
      }
      return result;
    },
    batchCalls: (callback) => {
      return (...args) => {
        schedule(() => {
          callback(...args);
        });
      };
    },
    schedule,
    setNotifyFunction: (fn) => {
      notifyFn = fn;
    },
    setBatchNotifyFunction: (fn) => {
      batchNotifyFn = fn;
    },
    setScheduler: (fn) => {
      scheduleFn = fn;
    }
  };
}
var notifyManager = createNotifyManager();

// node_modules/@tanstack/query-core/build/modern/onlineManager.js
var OnlineManager = class extends Subscribable {
  #online = true;
  #cleanup;
  #setup;
  constructor() {
    super();
    this.#setup = (onOnline) => {
      if (!isServer && window.addEventListener) {
        const onlineListener = () => onOnline(true);
        const offlineListener = () => onOnline(false);
        window.addEventListener("online", onlineListener, false);
        window.addEventListener("offline", offlineListener, false);
        return () => {
          window.removeEventListener("online", onlineListener);
          window.removeEventListener("offline", offlineListener);
        };
      }
      return;
    };
  }
  onSubscribe() {
    if (!this.#cleanup) {
      this.setEventListener(this.#setup);
    }
  }
  onUnsubscribe() {
    if (!this.hasListeners()) {
      this.#cleanup?.();
      this.#cleanup = undefined;
    }
  }
  setEventListener(setup) {
    this.#setup = setup;
    this.#cleanup?.();
    this.#cleanup = setup(this.setOnline.bind(this));
  }
  setOnline(online) {
    const changed = this.#online !== online;
    if (changed) {
      this.#online = online;
      this.listeners.forEach((listener) => {
        listener(online);
      });
    }
  }
  isOnline() {
    return this.#online;
  }
};
var onlineManager = new OnlineManager;

// node_modules/@tanstack/query-core/build/modern/retryer.js
function defaultRetryDelay(failureCount) {
  return Math.min(1000 * 2 ** failureCount, 30000);
}
function canFetch(networkMode) {
  return (networkMode ?? "online") === "online" ? onlineManager.isOnline() : true;
}
var CancelledError = class extends Error {
  constructor(options2) {
    super("CancelledError");
    this.revert = options2?.revert;
    this.silent = options2?.silent;
  }
};
function createRetryer(config) {
  let isRetryCancelled = false;
  let failureCount = 0;
  let continueFn;
  const thenable = pendingThenable();
  const isResolved = () => thenable.status !== "pending";
  const cancel = (cancelOptions) => {
    if (!isResolved()) {
      const error = new CancelledError(cancelOptions);
      reject(error);
      config.onCancel?.(error);
    }
  };
  const cancelRetry = () => {
    isRetryCancelled = true;
  };
  const continueRetry = () => {
    isRetryCancelled = false;
  };
  const canContinue = () => focusManager.isFocused() && (config.networkMode === "always" || onlineManager.isOnline()) && config.canRun();
  const canStart = () => canFetch(config.networkMode) && config.canRun();
  const resolve = (value) => {
    if (!isResolved()) {
      continueFn?.();
      thenable.resolve(value);
    }
  };
  const reject = (value) => {
    if (!isResolved()) {
      continueFn?.();
      thenable.reject(value);
    }
  };
  const pause = () => {
    return new Promise((continueResolve) => {
      continueFn = (value) => {
        if (isResolved() || canContinue()) {
          continueResolve(value);
        }
      };
      config.onPause?.();
    }).then(() => {
      continueFn = undefined;
      if (!isResolved()) {
        config.onContinue?.();
      }
    });
  };
  const run = () => {
    if (isResolved()) {
      return;
    }
    let promiseOrValue;
    const initialPromise = failureCount === 0 ? config.initialPromise : undefined;
    try {
      promiseOrValue = initialPromise ?? config.fn();
    } catch (error) {
      promiseOrValue = Promise.reject(error);
    }
    Promise.resolve(promiseOrValue).then(resolve).catch((error) => {
      if (isResolved()) {
        return;
      }
      const retry = config.retry ?? (isServer ? 0 : 3);
      const retryDelay = config.retryDelay ?? defaultRetryDelay;
      const delay = typeof retryDelay === "function" ? retryDelay(failureCount, error) : retryDelay;
      const shouldRetry = retry === true || typeof retry === "number" && failureCount < retry || typeof retry === "function" && retry(failureCount, error);
      if (isRetryCancelled || !shouldRetry) {
        reject(error);
        return;
      }
      failureCount++;
      config.onFail?.(failureCount, error);
      sleep(delay).then(() => {
        return canContinue() ? undefined : pause();
      }).then(() => {
        if (isRetryCancelled) {
          reject(error);
        } else {
          run();
        }
      });
    });
  };
  return {
    promise: thenable,
    status: () => thenable.status,
    cancel,
    continue: () => {
      continueFn?.();
      return thenable;
    },
    cancelRetry,
    continueRetry,
    canStart,
    start: () => {
      if (canStart()) {
        run();
      } else {
        pause().then(run);
      }
      return thenable;
    }
  };
}

// node_modules/@tanstack/query-core/build/modern/removable.js
var Removable = class {
  #gcTimeout;
  destroy() {
    this.clearGcTimeout();
  }
  scheduleGc() {
    this.clearGcTimeout();
    if (isValidTimeout(this.gcTime)) {
      this.#gcTimeout = timeoutManager.setTimeout(() => {
        this.optionalRemove();
      }, this.gcTime);
    }
  }
  updateGcTime(newGcTime) {
    this.gcTime = Math.max(this.gcTime || 0, newGcTime ?? (isServer ? Infinity : 5 * 60 * 1000));
  }
  clearGcTimeout() {
    if (this.#gcTimeout) {
      timeoutManager.clearTimeout(this.#gcTimeout);
      this.#gcTimeout = undefined;
    }
  }
};

// node_modules/@tanstack/query-core/build/modern/query.js
var Query = class extends Removable {
  #initialState;
  #revertState;
  #cache;
  #client;
  #retryer;
  #defaultOptions;
  #abortSignalConsumed;
  constructor(config) {
    super();
    this.#abortSignalConsumed = false;
    this.#defaultOptions = config.defaultOptions;
    this.setOptions(config.options);
    this.observers = [];
    this.#client = config.client;
    this.#cache = this.#client.getQueryCache();
    this.queryKey = config.queryKey;
    this.queryHash = config.queryHash;
    this.#initialState = getDefaultState(this.options);
    this.state = config.state ?? this.#initialState;
    this.scheduleGc();
  }
  get meta() {
    return this.options.meta;
  }
  get promise() {
    return this.#retryer?.promise;
  }
  setOptions(options2) {
    this.options = { ...this.#defaultOptions, ...options2 };
    this.updateGcTime(this.options.gcTime);
    if (this.state && this.state.data === undefined) {
      const defaultState = getDefaultState(this.options);
      if (defaultState.data !== undefined) {
        this.setState(successState(defaultState.data, defaultState.dataUpdatedAt));
        this.#initialState = defaultState;
      }
    }
  }
  optionalRemove() {
    if (!this.observers.length && this.state.fetchStatus === "idle") {
      this.#cache.remove(this);
    }
  }
  setData(newData, options2) {
    const data2 = replaceData(this.state.data, newData, this.options);
    this.#dispatch({
      data: data2,
      type: "success",
      dataUpdatedAt: options2?.updatedAt,
      manual: options2?.manual
    });
    return data2;
  }
  setState(state, setStateOptions) {
    this.#dispatch({ type: "setState", state, setStateOptions });
  }
  cancel(options2) {
    const promise = this.#retryer?.promise;
    this.#retryer?.cancel(options2);
    return promise ? promise.then(noop).catch(noop) : Promise.resolve();
  }
  destroy() {
    super.destroy();
    this.cancel({ silent: true });
  }
  reset() {
    this.destroy();
    this.setState(this.#initialState);
  }
  isActive() {
    return this.observers.some((observer) => resolveEnabled(observer.options.enabled, this) !== false);
  }
  isDisabled() {
    if (this.getObserversCount() > 0) {
      return !this.isActive();
    }
    return this.options.queryFn === skipToken || this.state.dataUpdateCount + this.state.errorUpdateCount === 0;
  }
  isStatic() {
    if (this.getObserversCount() > 0) {
      return this.observers.some((observer) => resolveStaleTime(observer.options.staleTime, this) === "static");
    }
    return false;
  }
  isStale() {
    if (this.getObserversCount() > 0) {
      return this.observers.some((observer) => observer.getCurrentResult().isStale);
    }
    return this.state.data === undefined || this.state.isInvalidated;
  }
  isStaleByTime(staleTime = 0) {
    if (this.state.data === undefined) {
      return true;
    }
    if (staleTime === "static") {
      return false;
    }
    if (this.state.isInvalidated) {
      return true;
    }
    return !timeUntilStale(this.state.dataUpdatedAt, staleTime);
  }
  onFocus() {
    const observer = this.observers.find((x) => x.shouldFetchOnWindowFocus());
    observer?.refetch({ cancelRefetch: false });
    this.#retryer?.continue();
  }
  onOnline() {
    const observer = this.observers.find((x) => x.shouldFetchOnReconnect());
    observer?.refetch({ cancelRefetch: false });
    this.#retryer?.continue();
  }
  addObserver(observer) {
    if (!this.observers.includes(observer)) {
      this.observers.push(observer);
      this.clearGcTimeout();
      this.#cache.notify({ type: "observerAdded", query: this, observer });
    }
  }
  removeObserver(observer) {
    if (this.observers.includes(observer)) {
      this.observers = this.observers.filter((x) => x !== observer);
      if (!this.observers.length) {
        if (this.#retryer) {
          if (this.#abortSignalConsumed) {
            this.#retryer.cancel({ revert: true });
          } else {
            this.#retryer.cancelRetry();
          }
        }
        this.scheduleGc();
      }
      this.#cache.notify({ type: "observerRemoved", query: this, observer });
    }
  }
  getObserversCount() {
    return this.observers.length;
  }
  invalidate() {
    if (!this.state.isInvalidated) {
      this.#dispatch({ type: "invalidate" });
    }
  }
  async fetch(options2, fetchOptions) {
    if (this.state.fetchStatus !== "idle" && this.#retryer?.status() !== "rejected") {
      if (this.state.data !== undefined && fetchOptions?.cancelRefetch) {
        this.cancel({ silent: true });
      } else if (this.#retryer) {
        this.#retryer.continueRetry();
        return this.#retryer.promise;
      }
    }
    if (options2) {
      this.setOptions(options2);
    }
    if (!this.options.queryFn) {
      const observer = this.observers.find((x) => x.options.queryFn);
      if (observer) {
        this.setOptions(observer.options);
      }
    }
    if (true) {
      if (!Array.isArray(this.options.queryKey)) {
        console.error(`As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']`);
      }
    }
    const abortController = new AbortController;
    const addSignalProperty = (object) => {
      Object.defineProperty(object, "signal", {
        enumerable: true,
        get: () => {
          this.#abortSignalConsumed = true;
          return abortController.signal;
        }
      });
    };
    const fetchFn = () => {
      const queryFn = ensureQueryFn(this.options, fetchOptions);
      const createQueryFnContext = () => {
        const queryFnContext2 = {
          client: this.#client,
          queryKey: this.queryKey,
          meta: this.meta
        };
        addSignalProperty(queryFnContext2);
        return queryFnContext2;
      };
      const queryFnContext = createQueryFnContext();
      this.#abortSignalConsumed = false;
      if (this.options.persister) {
        return this.options.persister(queryFn, queryFnContext, this);
      }
      return queryFn(queryFnContext);
    };
    const createFetchContext = () => {
      const context2 = {
        fetchOptions,
        options: this.options,
        queryKey: this.queryKey,
        client: this.#client,
        state: this.state,
        fetchFn
      };
      addSignalProperty(context2);
      return context2;
    };
    const context = createFetchContext();
    this.options.behavior?.onFetch(context, this);
    this.#revertState = this.state;
    if (this.state.fetchStatus === "idle" || this.state.fetchMeta !== context.fetchOptions?.meta) {
      this.#dispatch({ type: "fetch", meta: context.fetchOptions?.meta });
    }
    this.#retryer = createRetryer({
      initialPromise: fetchOptions?.initialPromise,
      fn: context.fetchFn,
      onCancel: (error) => {
        if (error instanceof CancelledError && error.revert) {
          this.setState({
            ...this.#revertState,
            fetchStatus: "idle"
          });
        }
        abortController.abort();
      },
      onFail: (failureCount, error) => {
        this.#dispatch({ type: "failed", failureCount, error });
      },
      onPause: () => {
        this.#dispatch({ type: "pause" });
      },
      onContinue: () => {
        this.#dispatch({ type: "continue" });
      },
      retry: context.options.retry,
      retryDelay: context.options.retryDelay,
      networkMode: context.options.networkMode,
      canRun: () => true
    });
    try {
      const data2 = await this.#retryer.start();
      if (data2 === undefined) {
        if (true) {
          console.error(`Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`);
        }
        throw new Error(`${this.queryHash} data is undefined`);
      }
      this.setData(data2);
      this.#cache.config.onSuccess?.(data2, this);
      this.#cache.config.onSettled?.(data2, this.state.error, this);
      return data2;
    } catch (error) {
      if (error instanceof CancelledError) {
        if (error.silent) {
          return this.#retryer.promise;
        } else if (error.revert) {
          if (this.state.data === undefined) {
            throw error;
          }
          return this.state.data;
        }
      }
      this.#dispatch({
        type: "error",
        error
      });
      this.#cache.config.onError?.(error, this);
      this.#cache.config.onSettled?.(this.state.data, error, this);
      throw error;
    } finally {
      this.scheduleGc();
    }
  }
  #dispatch(action) {
    const reducer = (state) => {
      switch (action.type) {
        case "failed":
          return {
            ...state,
            fetchFailureCount: action.failureCount,
            fetchFailureReason: action.error
          };
        case "pause":
          return {
            ...state,
            fetchStatus: "paused"
          };
        case "continue":
          return {
            ...state,
            fetchStatus: "fetching"
          };
        case "fetch":
          return {
            ...state,
            ...fetchState(state.data, this.options),
            fetchMeta: action.meta ?? null
          };
        case "success":
          const newState = {
            ...state,
            ...successState(action.data, action.dataUpdatedAt),
            dataUpdateCount: state.dataUpdateCount + 1,
            ...!action.manual && {
              fetchStatus: "idle",
              fetchFailureCount: 0,
              fetchFailureReason: null
            }
          };
          this.#revertState = action.manual ? newState : undefined;
          return newState;
        case "error":
          const error = action.error;
          return {
            ...state,
            error,
            errorUpdateCount: state.errorUpdateCount + 1,
            errorUpdatedAt: Date.now(),
            fetchFailureCount: state.fetchFailureCount + 1,
            fetchFailureReason: error,
            fetchStatus: "idle",
            status: "error",
            isInvalidated: true
          };
        case "invalidate":
          return {
            ...state,
            isInvalidated: true
          };
        case "setState":
          return {
            ...state,
            ...action.state
          };
      }
    };
    this.state = reducer(this.state);
    notifyManager.batch(() => {
      this.observers.forEach((observer) => {
        observer.onQueryUpdate();
      });
      this.#cache.notify({ query: this, type: "updated", action });
    });
  }
};
function fetchState(data2, options2) {
  return {
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchStatus: canFetch(options2.networkMode) ? "fetching" : "paused",
    ...data2 === undefined && {
      error: null,
      status: "pending"
    }
  };
}
function successState(data2, dataUpdatedAt) {
  return {
    data: data2,
    dataUpdatedAt: dataUpdatedAt ?? Date.now(),
    error: null,
    isInvalidated: false,
    status: "success"
  };
}
function getDefaultState(options2) {
  const data2 = typeof options2.initialData === "function" ? options2.initialData() : options2.initialData;
  const hasData = data2 !== undefined;
  const initialDataUpdatedAt = hasData ? typeof options2.initialDataUpdatedAt === "function" ? options2.initialDataUpdatedAt() : options2.initialDataUpdatedAt : 0;
  return {
    data: data2,
    dataUpdateCount: 0,
    dataUpdatedAt: hasData ? initialDataUpdatedAt ?? Date.now() : 0,
    error: null,
    errorUpdateCount: 0,
    errorUpdatedAt: 0,
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchMeta: null,
    isInvalidated: false,
    status: hasData ? "success" : "pending",
    fetchStatus: "idle"
  };
}

// node_modules/@tanstack/query-core/build/modern/queryObserver.js
var QueryObserver = class extends Subscribable {
  constructor(client, options2) {
    super();
    this.options = options2;
    this.#client = client;
    this.#selectError = null;
    this.#currentThenable = pendingThenable();
    this.bindMethods();
    this.setOptions(options2);
  }
  #client;
  #currentQuery = undefined;
  #currentQueryInitialState = undefined;
  #currentResult = undefined;
  #currentResultState;
  #currentResultOptions;
  #currentThenable;
  #selectError;
  #selectFn;
  #selectResult;
  #lastQueryWithDefinedData;
  #staleTimeoutId;
  #refetchIntervalId;
  #currentRefetchInterval;
  #trackedProps = /* @__PURE__ */ new Set;
  bindMethods() {
    this.refetch = this.refetch.bind(this);
  }
  onSubscribe() {
    if (this.listeners.size === 1) {
      this.#currentQuery.addObserver(this);
      if (shouldFetchOnMount(this.#currentQuery, this.options)) {
        this.#executeFetch();
      } else {
        this.updateResult();
      }
      this.#updateTimers();
    }
  }
  onUnsubscribe() {
    if (!this.hasListeners()) {
      this.destroy();
    }
  }
  shouldFetchOnReconnect() {
    return shouldFetchOn(this.#currentQuery, this.options, this.options.refetchOnReconnect);
  }
  shouldFetchOnWindowFocus() {
    return shouldFetchOn(this.#currentQuery, this.options, this.options.refetchOnWindowFocus);
  }
  destroy() {
    this.listeners = /* @__PURE__ */ new Set;
    this.#clearStaleTimeout();
    this.#clearRefetchInterval();
    this.#currentQuery.removeObserver(this);
  }
  setOptions(options2) {
    const prevOptions = this.options;
    const prevQuery = this.#currentQuery;
    this.options = this.#client.defaultQueryOptions(options2);
    if (this.options.enabled !== undefined && typeof this.options.enabled !== "boolean" && typeof this.options.enabled !== "function" && typeof resolveEnabled(this.options.enabled, this.#currentQuery) !== "boolean") {
      throw new Error("Expected enabled to be a boolean or a callback that returns a boolean");
    }
    this.#updateQuery();
    this.#currentQuery.setOptions(this.options);
    if (prevOptions._defaulted && !shallowEqualObjects(this.options, prevOptions)) {
      this.#client.getQueryCache().notify({
        type: "observerOptionsUpdated",
        query: this.#currentQuery,
        observer: this
      });
    }
    const mounted = this.hasListeners();
    if (mounted && shouldFetchOptionally(this.#currentQuery, prevQuery, this.options, prevOptions)) {
      this.#executeFetch();
    }
    this.updateResult();
    if (mounted && (this.#currentQuery !== prevQuery || resolveEnabled(this.options.enabled, this.#currentQuery) !== resolveEnabled(prevOptions.enabled, this.#currentQuery) || resolveStaleTime(this.options.staleTime, this.#currentQuery) !== resolveStaleTime(prevOptions.staleTime, this.#currentQuery))) {
      this.#updateStaleTimeout();
    }
    const nextRefetchInterval = this.#computeRefetchInterval();
    if (mounted && (this.#currentQuery !== prevQuery || resolveEnabled(this.options.enabled, this.#currentQuery) !== resolveEnabled(prevOptions.enabled, this.#currentQuery) || nextRefetchInterval !== this.#currentRefetchInterval)) {
      this.#updateRefetchInterval(nextRefetchInterval);
    }
  }
  getOptimisticResult(options2) {
    const query = this.#client.getQueryCache().build(this.#client, options2);
    const result = this.createResult(query, options2);
    if (shouldAssignObserverCurrentProperties(this, result)) {
      this.#currentResult = result;
      this.#currentResultOptions = this.options;
      this.#currentResultState = this.#currentQuery.state;
    }
    return result;
  }
  getCurrentResult() {
    return this.#currentResult;
  }
  trackResult(result, onPropTracked) {
    return new Proxy(result, {
      get: (target, key) => {
        this.trackProp(key);
        onPropTracked?.(key);
        if (key === "promise") {
          this.trackProp("data");
          if (!this.options.experimental_prefetchInRender && this.#currentThenable.status === "pending") {
            this.#currentThenable.reject(new Error("experimental_prefetchInRender feature flag is not enabled"));
          }
        }
        return Reflect.get(target, key);
      }
    });
  }
  trackProp(key) {
    this.#trackedProps.add(key);
  }
  getCurrentQuery() {
    return this.#currentQuery;
  }
  refetch({ ...options2 } = {}) {
    return this.fetch({
      ...options2
    });
  }
  fetchOptimistic(options2) {
    const defaultedOptions = this.#client.defaultQueryOptions(options2);
    const query = this.#client.getQueryCache().build(this.#client, defaultedOptions);
    return query.fetch().then(() => this.createResult(query, defaultedOptions));
  }
  fetch(fetchOptions) {
    return this.#executeFetch({
      ...fetchOptions,
      cancelRefetch: fetchOptions.cancelRefetch ?? true
    }).then(() => {
      this.updateResult();
      return this.#currentResult;
    });
  }
  #executeFetch(fetchOptions) {
    this.#updateQuery();
    let promise = this.#currentQuery.fetch(this.options, fetchOptions);
    if (!fetchOptions?.throwOnError) {
      promise = promise.catch(noop);
    }
    return promise;
  }
  #updateStaleTimeout() {
    this.#clearStaleTimeout();
    const staleTime = resolveStaleTime(this.options.staleTime, this.#currentQuery);
    if (isServer || this.#currentResult.isStale || !isValidTimeout(staleTime)) {
      return;
    }
    const time = timeUntilStale(this.#currentResult.dataUpdatedAt, staleTime);
    const timeout = time + 1;
    this.#staleTimeoutId = timeoutManager.setTimeout(() => {
      if (!this.#currentResult.isStale) {
        this.updateResult();
      }
    }, timeout);
  }
  #computeRefetchInterval() {
    return (typeof this.options.refetchInterval === "function" ? this.options.refetchInterval(this.#currentQuery) : this.options.refetchInterval) ?? false;
  }
  #updateRefetchInterval(nextInterval) {
    this.#clearRefetchInterval();
    this.#currentRefetchInterval = nextInterval;
    if (isServer || resolveEnabled(this.options.enabled, this.#currentQuery) === false || !isValidTimeout(this.#currentRefetchInterval) || this.#currentRefetchInterval === 0) {
      return;
    }
    this.#refetchIntervalId = timeoutManager.setInterval(() => {
      if (this.options.refetchIntervalInBackground || focusManager.isFocused()) {
        this.#executeFetch();
      }
    }, this.#currentRefetchInterval);
  }
  #updateTimers() {
    this.#updateStaleTimeout();
    this.#updateRefetchInterval(this.#computeRefetchInterval());
  }
  #clearStaleTimeout() {
    if (this.#staleTimeoutId) {
      timeoutManager.clearTimeout(this.#staleTimeoutId);
      this.#staleTimeoutId = undefined;
    }
  }
  #clearRefetchInterval() {
    if (this.#refetchIntervalId) {
      timeoutManager.clearInterval(this.#refetchIntervalId);
      this.#refetchIntervalId = undefined;
    }
  }
  createResult(query, options2) {
    const prevQuery = this.#currentQuery;
    const prevOptions = this.options;
    const prevResult = this.#currentResult;
    const prevResultState = this.#currentResultState;
    const prevResultOptions = this.#currentResultOptions;
    const queryChange = query !== prevQuery;
    const queryInitialState = queryChange ? query.state : this.#currentQueryInitialState;
    const { state } = query;
    let newState = { ...state };
    let isPlaceholderData = false;
    let data2;
    if (options2._optimisticResults) {
      const mounted = this.hasListeners();
      const fetchOnMount = !mounted && shouldFetchOnMount(query, options2);
      const fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options2, prevOptions);
      if (fetchOnMount || fetchOptionally) {
        newState = {
          ...newState,
          ...fetchState(state.data, query.options)
        };
      }
      if (options2._optimisticResults === "isRestoring") {
        newState.fetchStatus = "idle";
      }
    }
    let { error, errorUpdatedAt, status } = newState;
    data2 = newState.data;
    let skipSelect = false;
    if (options2.placeholderData !== undefined && data2 === undefined && status === "pending") {
      let placeholderData;
      if (prevResult?.isPlaceholderData && options2.placeholderData === prevResultOptions?.placeholderData) {
        placeholderData = prevResult.data;
        skipSelect = true;
      } else {
        placeholderData = typeof options2.placeholderData === "function" ? options2.placeholderData(this.#lastQueryWithDefinedData?.state.data, this.#lastQueryWithDefinedData) : options2.placeholderData;
      }
      if (placeholderData !== undefined) {
        status = "success";
        data2 = replaceData(prevResult?.data, placeholderData, options2);
        isPlaceholderData = true;
      }
    }
    if (options2.select && data2 !== undefined && !skipSelect) {
      if (prevResult && data2 === prevResultState?.data && options2.select === this.#selectFn) {
        data2 = this.#selectResult;
      } else {
        try {
          this.#selectFn = options2.select;
          data2 = options2.select(data2);
          data2 = replaceData(prevResult?.data, data2, options2);
          this.#selectResult = data2;
          this.#selectError = null;
        } catch (selectError) {
          this.#selectError = selectError;
        }
      }
    }
    if (this.#selectError) {
      error = this.#selectError;
      data2 = this.#selectResult;
      errorUpdatedAt = Date.now();
      status = "error";
    }
    const isFetching = newState.fetchStatus === "fetching";
    const isPending = status === "pending";
    const isError2 = status === "error";
    const isLoading = isPending && isFetching;
    const hasData = data2 !== undefined;
    const result = {
      status,
      fetchStatus: newState.fetchStatus,
      isPending,
      isSuccess: status === "success",
      isError: isError2,
      isInitialLoading: isLoading,
      isLoading,
      data: data2,
      dataUpdatedAt: newState.dataUpdatedAt,
      error,
      errorUpdatedAt,
      failureCount: newState.fetchFailureCount,
      failureReason: newState.fetchFailureReason,
      errorUpdateCount: newState.errorUpdateCount,
      isFetched: newState.dataUpdateCount > 0 || newState.errorUpdateCount > 0,
      isFetchedAfterMount: newState.dataUpdateCount > queryInitialState.dataUpdateCount || newState.errorUpdateCount > queryInitialState.errorUpdateCount,
      isFetching,
      isRefetching: isFetching && !isPending,
      isLoadingError: isError2 && !hasData,
      isPaused: newState.fetchStatus === "paused",
      isPlaceholderData,
      isRefetchError: isError2 && hasData,
      isStale: isStale(query, options2),
      refetch: this.refetch,
      promise: this.#currentThenable,
      isEnabled: resolveEnabled(options2.enabled, query) !== false
    };
    const nextResult = result;
    if (this.options.experimental_prefetchInRender) {
      const finalizeThenableIfPossible = (thenable) => {
        if (nextResult.status === "error") {
          thenable.reject(nextResult.error);
        } else if (nextResult.data !== undefined) {
          thenable.resolve(nextResult.data);
        }
      };
      const recreateThenable = () => {
        const pending = this.#currentThenable = nextResult.promise = pendingThenable();
        finalizeThenableIfPossible(pending);
      };
      const prevThenable = this.#currentThenable;
      switch (prevThenable.status) {
        case "pending":
          if (query.queryHash === prevQuery.queryHash) {
            finalizeThenableIfPossible(prevThenable);
          }
          break;
        case "fulfilled":
          if (nextResult.status === "error" || nextResult.data !== prevThenable.value) {
            recreateThenable();
          }
          break;
        case "rejected":
          if (nextResult.status !== "error" || nextResult.error !== prevThenable.reason) {
            recreateThenable();
          }
          break;
      }
    }
    return nextResult;
  }
  updateResult() {
    const prevResult = this.#currentResult;
    const nextResult = this.createResult(this.#currentQuery, this.options);
    this.#currentResultState = this.#currentQuery.state;
    this.#currentResultOptions = this.options;
    if (this.#currentResultState.data !== undefined) {
      this.#lastQueryWithDefinedData = this.#currentQuery;
    }
    if (shallowEqualObjects(nextResult, prevResult)) {
      return;
    }
    this.#currentResult = nextResult;
    const shouldNotifyListeners = () => {
      if (!prevResult) {
        return true;
      }
      const { notifyOnChangeProps } = this.options;
      const notifyOnChangePropsValue = typeof notifyOnChangeProps === "function" ? notifyOnChangeProps() : notifyOnChangeProps;
      if (notifyOnChangePropsValue === "all" || !notifyOnChangePropsValue && !this.#trackedProps.size) {
        return true;
      }
      const includedProps = new Set(notifyOnChangePropsValue ?? this.#trackedProps);
      if (this.options.throwOnError) {
        includedProps.add("error");
      }
      return Object.keys(this.#currentResult).some((key) => {
        const typedKey = key;
        const changed = this.#currentResult[typedKey] !== prevResult[typedKey];
        return changed && includedProps.has(typedKey);
      });
    };
    this.#notify({ listeners: shouldNotifyListeners() });
  }
  #updateQuery() {
    const query = this.#client.getQueryCache().build(this.#client, this.options);
    if (query === this.#currentQuery) {
      return;
    }
    const prevQuery = this.#currentQuery;
    this.#currentQuery = query;
    this.#currentQueryInitialState = query.state;
    if (this.hasListeners()) {
      prevQuery?.removeObserver(this);
      query.addObserver(this);
    }
  }
  onQueryUpdate() {
    this.updateResult();
    if (this.hasListeners()) {
      this.#updateTimers();
    }
  }
  #notify(notifyOptions) {
    notifyManager.batch(() => {
      if (notifyOptions.listeners) {
        this.listeners.forEach((listener) => {
          listener(this.#currentResult);
        });
      }
      this.#client.getQueryCache().notify({
        query: this.#currentQuery,
        type: "observerResultsUpdated"
      });
    });
  }
};
function shouldLoadOnMount(query, options2) {
  return resolveEnabled(options2.enabled, query) !== false && query.state.data === undefined && !(query.state.status === "error" && options2.retryOnMount === false);
}
function shouldFetchOnMount(query, options2) {
  return shouldLoadOnMount(query, options2) || query.state.data !== undefined && shouldFetchOn(query, options2, options2.refetchOnMount);
}
function shouldFetchOn(query, options2, field) {
  if (resolveEnabled(options2.enabled, query) !== false && resolveStaleTime(options2.staleTime, query) !== "static") {
    const value = typeof field === "function" ? field(query) : field;
    return value === "always" || value !== false && isStale(query, options2);
  }
  return false;
}
function shouldFetchOptionally(query, prevQuery, options2, prevOptions) {
  return (query !== prevQuery || resolveEnabled(prevOptions.enabled, query) === false) && (!options2.suspense || query.state.status !== "error") && isStale(query, options2);
}
function isStale(query, options2) {
  return resolveEnabled(options2.enabled, query) !== false && query.isStaleByTime(resolveStaleTime(options2.staleTime, query));
}
function shouldAssignObserverCurrentProperties(observer, optimisticResult) {
  if (!shallowEqualObjects(observer.getCurrentResult(), optimisticResult)) {
    return true;
  }
  return false;
}

// node_modules/@tanstack/query-core/build/modern/infiniteQueryBehavior.js
function infiniteQueryBehavior(pages) {
  return {
    onFetch: (context, query) => {
      const options2 = context.options;
      const direction = context.fetchOptions?.meta?.fetchMore?.direction;
      const oldPages = context.state.data?.pages || [];
      const oldPageParams = context.state.data?.pageParams || [];
      let result = { pages: [], pageParams: [] };
      let currentPage = 0;
      const fetchFn = async () => {
        let cancelled = false;
        const addSignalProperty = (object) => {
          addConsumeAwareSignal(object, () => context.signal, () => cancelled = true);
        };
        const queryFn = ensureQueryFn(context.options, context.fetchOptions);
        const fetchPage = async (data2, param, previous) => {
          if (cancelled) {
            return Promise.reject();
          }
          if (param == null && data2.pages.length) {
            return Promise.resolve(data2);
          }
          const createQueryFnContext = () => {
            const queryFnContext2 = {
              client: context.client,
              queryKey: context.queryKey,
              pageParam: param,
              direction: previous ? "backward" : "forward",
              meta: context.options.meta
            };
            addSignalProperty(queryFnContext2);
            return queryFnContext2;
          };
          const queryFnContext = createQueryFnContext();
          const page = await queryFn(queryFnContext);
          const { maxPages } = context.options;
          const addTo = previous ? addToStart : addToEnd;
          return {
            pages: addTo(data2.pages, page, maxPages),
            pageParams: addTo(data2.pageParams, param, maxPages)
          };
        };
        if (direction && oldPages.length) {
          const previous = direction === "backward";
          const pageParamFn = previous ? getPreviousPageParam : getNextPageParam;
          const oldData = {
            pages: oldPages,
            pageParams: oldPageParams
          };
          const param = pageParamFn(options2, oldData);
          result = await fetchPage(oldData, param, previous);
        } else {
          const remainingPages = pages ?? oldPages.length;
          do {
            const param = currentPage === 0 ? oldPageParams[0] ?? options2.initialPageParam : getNextPageParam(options2, result);
            if (currentPage > 0 && param == null) {
              break;
            }
            result = await fetchPage(result, param);
            currentPage++;
          } while (currentPage < remainingPages);
        }
        return result;
      };
      if (context.options.persister) {
        context.fetchFn = () => {
          return context.options.persister?.(fetchFn, {
            client: context.client,
            queryKey: context.queryKey,
            meta: context.options.meta,
            signal: context.signal
          }, query);
        };
      } else {
        context.fetchFn = fetchFn;
      }
    }
  };
}
function getNextPageParam(options2, { pages, pageParams }) {
  const lastIndex = pages.length - 1;
  return pages.length > 0 ? options2.getNextPageParam(pages[lastIndex], pages, pageParams[lastIndex], pageParams) : undefined;
}
function getPreviousPageParam(options2, { pages, pageParams }) {
  return pages.length > 0 ? options2.getPreviousPageParam?.(pages[0], pages, pageParams[0], pageParams) : undefined;
}

// node_modules/@tanstack/query-core/build/modern/mutation.js
var Mutation = class extends Removable {
  #client;
  #observers;
  #mutationCache;
  #retryer;
  constructor(config) {
    super();
    this.#client = config.client;
    this.mutationId = config.mutationId;
    this.#mutationCache = config.mutationCache;
    this.#observers = [];
    this.state = config.state || getDefaultState2();
    this.setOptions(config.options);
    this.scheduleGc();
  }
  setOptions(options2) {
    this.options = options2;
    this.updateGcTime(this.options.gcTime);
  }
  get meta() {
    return this.options.meta;
  }
  addObserver(observer) {
    if (!this.#observers.includes(observer)) {
      this.#observers.push(observer);
      this.clearGcTimeout();
      this.#mutationCache.notify({
        type: "observerAdded",
        mutation: this,
        observer
      });
    }
  }
  removeObserver(observer) {
    this.#observers = this.#observers.filter((x) => x !== observer);
    this.scheduleGc();
    this.#mutationCache.notify({
      type: "observerRemoved",
      mutation: this,
      observer
    });
  }
  optionalRemove() {
    if (!this.#observers.length) {
      if (this.state.status === "pending") {
        this.scheduleGc();
      } else {
        this.#mutationCache.remove(this);
      }
    }
  }
  continue() {
    return this.#retryer?.continue() ?? this.execute(this.state.variables);
  }
  async execute(variables) {
    const onContinue = () => {
      this.#dispatch({ type: "continue" });
    };
    const mutationFnContext = {
      client: this.#client,
      meta: this.options.meta,
      mutationKey: this.options.mutationKey
    };
    this.#retryer = createRetryer({
      fn: () => {
        if (!this.options.mutationFn) {
          return Promise.reject(new Error("No mutationFn found"));
        }
        return this.options.mutationFn(variables, mutationFnContext);
      },
      onFail: (failureCount, error) => {
        this.#dispatch({ type: "failed", failureCount, error });
      },
      onPause: () => {
        this.#dispatch({ type: "pause" });
      },
      onContinue,
      retry: this.options.retry ?? 0,
      retryDelay: this.options.retryDelay,
      networkMode: this.options.networkMode,
      canRun: () => this.#mutationCache.canRun(this)
    });
    const restored = this.state.status === "pending";
    const isPaused = !this.#retryer.canStart();
    try {
      if (restored) {
        onContinue();
      } else {
        this.#dispatch({ type: "pending", variables, isPaused });
        await this.#mutationCache.config.onMutate?.(variables, this, mutationFnContext);
        const context = await this.options.onMutate?.(variables, mutationFnContext);
        if (context !== this.state.context) {
          this.#dispatch({
            type: "pending",
            context,
            variables,
            isPaused
          });
        }
      }
      const data2 = await this.#retryer.start();
      await this.#mutationCache.config.onSuccess?.(data2, variables, this.state.context, this, mutationFnContext);
      await this.options.onSuccess?.(data2, variables, this.state.context, mutationFnContext);
      await this.#mutationCache.config.onSettled?.(data2, null, this.state.variables, this.state.context, this, mutationFnContext);
      await this.options.onSettled?.(data2, null, variables, this.state.context, mutationFnContext);
      this.#dispatch({ type: "success", data: data2 });
      return data2;
    } catch (error) {
      try {
        await this.#mutationCache.config.onError?.(error, variables, this.state.context, this, mutationFnContext);
      } catch (e7) {
        Promise.reject(e7);
      }
      try {
        await this.options.onError?.(error, variables, this.state.context, mutationFnContext);
      } catch (e7) {
        Promise.reject(e7);
      }
      try {
        await this.#mutationCache.config.onSettled?.(undefined, error, this.state.variables, this.state.context, this, mutationFnContext);
      } catch (e7) {
        Promise.reject(e7);
      }
      try {
        await this.options.onSettled?.(undefined, error, variables, this.state.context, mutationFnContext);
      } catch (e7) {
        Promise.reject(e7);
      }
      this.#dispatch({ type: "error", error });
      throw error;
    } finally {
      this.#mutationCache.runNext(this);
    }
  }
  #dispatch(action) {
    const reducer = (state) => {
      switch (action.type) {
        case "failed":
          return {
            ...state,
            failureCount: action.failureCount,
            failureReason: action.error
          };
        case "pause":
          return {
            ...state,
            isPaused: true
          };
        case "continue":
          return {
            ...state,
            isPaused: false
          };
        case "pending":
          return {
            ...state,
            context: action.context,
            data: undefined,
            failureCount: 0,
            failureReason: null,
            error: null,
            isPaused: action.isPaused,
            status: "pending",
            variables: action.variables,
            submittedAt: Date.now()
          };
        case "success":
          return {
            ...state,
            data: action.data,
            failureCount: 0,
            failureReason: null,
            error: null,
            status: "success",
            isPaused: false
          };
        case "error":
          return {
            ...state,
            data: undefined,
            error: action.error,
            failureCount: state.failureCount + 1,
            failureReason: action.error,
            isPaused: false,
            status: "error"
          };
      }
    };
    this.state = reducer(this.state);
    notifyManager.batch(() => {
      this.#observers.forEach((observer) => {
        observer.onMutationUpdate(action);
      });
      this.#mutationCache.notify({
        mutation: this,
        type: "updated",
        action
      });
    });
  }
};
function getDefaultState2() {
  return {
    context: undefined,
    data: undefined,
    error: null,
    failureCount: 0,
    failureReason: null,
    isPaused: false,
    status: "idle",
    variables: undefined,
    submittedAt: 0
  };
}

// node_modules/@tanstack/query-core/build/modern/mutationCache.js
var MutationCache = class extends Subscribable {
  constructor(config = {}) {
    super();
    this.config = config;
    this.#mutations = /* @__PURE__ */ new Set;
    this.#scopes = /* @__PURE__ */ new Map;
    this.#mutationId = 0;
  }
  #mutations;
  #scopes;
  #mutationId;
  build(client, options2, state) {
    const mutation = new Mutation({
      client,
      mutationCache: this,
      mutationId: ++this.#mutationId,
      options: client.defaultMutationOptions(options2),
      state
    });
    this.add(mutation);
    return mutation;
  }
  add(mutation) {
    this.#mutations.add(mutation);
    const scope = scopeFor(mutation);
    if (typeof scope === "string") {
      const scopedMutations = this.#scopes.get(scope);
      if (scopedMutations) {
        scopedMutations.push(mutation);
      } else {
        this.#scopes.set(scope, [mutation]);
      }
    }
    this.notify({ type: "added", mutation });
  }
  remove(mutation) {
    if (this.#mutations.delete(mutation)) {
      const scope = scopeFor(mutation);
      if (typeof scope === "string") {
        const scopedMutations = this.#scopes.get(scope);
        if (scopedMutations) {
          if (scopedMutations.length > 1) {
            const index = scopedMutations.indexOf(mutation);
            if (index !== -1) {
              scopedMutations.splice(index, 1);
            }
          } else if (scopedMutations[0] === mutation) {
            this.#scopes.delete(scope);
          }
        }
      }
    }
    this.notify({ type: "removed", mutation });
  }
  canRun(mutation) {
    const scope = scopeFor(mutation);
    if (typeof scope === "string") {
      const mutationsWithSameScope = this.#scopes.get(scope);
      const firstPendingMutation = mutationsWithSameScope?.find((m) => m.state.status === "pending");
      return !firstPendingMutation || firstPendingMutation === mutation;
    } else {
      return true;
    }
  }
  runNext(mutation) {
    const scope = scopeFor(mutation);
    if (typeof scope === "string") {
      const foundMutation = this.#scopes.get(scope)?.find((m) => m !== mutation && m.state.isPaused);
      return foundMutation?.continue() ?? Promise.resolve();
    } else {
      return Promise.resolve();
    }
  }
  clear() {
    notifyManager.batch(() => {
      this.#mutations.forEach((mutation) => {
        this.notify({ type: "removed", mutation });
      });
      this.#mutations.clear();
      this.#scopes.clear();
    });
  }
  getAll() {
    return Array.from(this.#mutations);
  }
  find(filters) {
    const defaultedFilters = { exact: true, ...filters };
    return this.getAll().find((mutation) => matchMutation(defaultedFilters, mutation));
  }
  findAll(filters = {}) {
    return this.getAll().filter((mutation) => matchMutation(filters, mutation));
  }
  notify(event) {
    notifyManager.batch(() => {
      this.listeners.forEach((listener) => {
        listener(event);
      });
    });
  }
  resumePausedMutations() {
    const pausedMutations = this.getAll().filter((x) => x.state.isPaused);
    return notifyManager.batch(() => Promise.all(pausedMutations.map((mutation) => mutation.continue().catch(noop))));
  }
};
function scopeFor(mutation) {
  return mutation.options.scope?.id;
}

// node_modules/@tanstack/query-core/build/modern/queryCache.js
var QueryCache = class extends Subscribable {
  constructor(config = {}) {
    super();
    this.config = config;
    this.#queries = /* @__PURE__ */ new Map;
  }
  #queries;
  build(client, options2, state) {
    const queryKey = options2.queryKey;
    const queryHash = options2.queryHash ?? hashQueryKeyByOptions(queryKey, options2);
    let query = this.get(queryHash);
    if (!query) {
      query = new Query({
        client,
        queryKey,
        queryHash,
        options: client.defaultQueryOptions(options2),
        state,
        defaultOptions: client.getQueryDefaults(queryKey)
      });
      this.add(query);
    }
    return query;
  }
  add(query) {
    if (!this.#queries.has(query.queryHash)) {
      this.#queries.set(query.queryHash, query);
      this.notify({
        type: "added",
        query
      });
    }
  }
  remove(query) {
    const queryInMap = this.#queries.get(query.queryHash);
    if (queryInMap) {
      query.destroy();
      if (queryInMap === query) {
        this.#queries.delete(query.queryHash);
      }
      this.notify({ type: "removed", query });
    }
  }
  clear() {
    notifyManager.batch(() => {
      this.getAll().forEach((query) => {
        this.remove(query);
      });
    });
  }
  get(queryHash) {
    return this.#queries.get(queryHash);
  }
  getAll() {
    return [...this.#queries.values()];
  }
  find(filters) {
    const defaultedFilters = { exact: true, ...filters };
    return this.getAll().find((query) => matchQuery(defaultedFilters, query));
  }
  findAll(filters = {}) {
    const queries = this.getAll();
    return Object.keys(filters).length > 0 ? queries.filter((query) => matchQuery(filters, query)) : queries;
  }
  notify(event) {
    notifyManager.batch(() => {
      this.listeners.forEach((listener) => {
        listener(event);
      });
    });
  }
  onFocus() {
    notifyManager.batch(() => {
      this.getAll().forEach((query) => {
        query.onFocus();
      });
    });
  }
  onOnline() {
    notifyManager.batch(() => {
      this.getAll().forEach((query) => {
        query.onOnline();
      });
    });
  }
};

// node_modules/@tanstack/query-core/build/modern/queryClient.js
var QueryClient = class {
  #queryCache;
  #mutationCache;
  #defaultOptions;
  #queryDefaults;
  #mutationDefaults;
  #mountCount;
  #unsubscribeFocus;
  #unsubscribeOnline;
  constructor(config = {}) {
    this.#queryCache = config.queryCache || new QueryCache;
    this.#mutationCache = config.mutationCache || new MutationCache;
    this.#defaultOptions = config.defaultOptions || {};
    this.#queryDefaults = /* @__PURE__ */ new Map;
    this.#mutationDefaults = /* @__PURE__ */ new Map;
    this.#mountCount = 0;
  }
  mount() {
    this.#mountCount++;
    if (this.#mountCount !== 1)
      return;
    this.#unsubscribeFocus = focusManager.subscribe(async (focused) => {
      if (focused) {
        await this.resumePausedMutations();
        this.#queryCache.onFocus();
      }
    });
    this.#unsubscribeOnline = onlineManager.subscribe(async (online) => {
      if (online) {
        await this.resumePausedMutations();
        this.#queryCache.onOnline();
      }
    });
  }
  unmount() {
    this.#mountCount--;
    if (this.#mountCount !== 0)
      return;
    this.#unsubscribeFocus?.();
    this.#unsubscribeFocus = undefined;
    this.#unsubscribeOnline?.();
    this.#unsubscribeOnline = undefined;
  }
  isFetching(filters) {
    return this.#queryCache.findAll({ ...filters, fetchStatus: "fetching" }).length;
  }
  isMutating(filters) {
    return this.#mutationCache.findAll({ ...filters, status: "pending" }).length;
  }
  getQueryData(queryKey) {
    const options2 = this.defaultQueryOptions({ queryKey });
    return this.#queryCache.get(options2.queryHash)?.state.data;
  }
  ensureQueryData(options2) {
    const defaultedOptions = this.defaultQueryOptions(options2);
    const query = this.#queryCache.build(this, defaultedOptions);
    const cachedData = query.state.data;
    if (cachedData === undefined) {
      return this.fetchQuery(options2);
    }
    if (options2.revalidateIfStale && query.isStaleByTime(resolveStaleTime(defaultedOptions.staleTime, query))) {
      this.prefetchQuery(defaultedOptions);
    }
    return Promise.resolve(cachedData);
  }
  getQueriesData(filters) {
    return this.#queryCache.findAll(filters).map(({ queryKey, state }) => {
      const data2 = state.data;
      return [queryKey, data2];
    });
  }
  setQueryData(queryKey, updater, options2) {
    const defaultedOptions = this.defaultQueryOptions({ queryKey });
    const query = this.#queryCache.get(defaultedOptions.queryHash);
    const prevData = query?.state.data;
    const data2 = functionalUpdate(updater, prevData);
    if (data2 === undefined) {
      return;
    }
    return this.#queryCache.build(this, defaultedOptions).setData(data2, { ...options2, manual: true });
  }
  setQueriesData(filters, updater, options2) {
    return notifyManager.batch(() => this.#queryCache.findAll(filters).map(({ queryKey }) => [
      queryKey,
      this.setQueryData(queryKey, updater, options2)
    ]));
  }
  getQueryState(queryKey) {
    const options2 = this.defaultQueryOptions({ queryKey });
    return this.#queryCache.get(options2.queryHash)?.state;
  }
  removeQueries(filters) {
    const queryCache = this.#queryCache;
    notifyManager.batch(() => {
      queryCache.findAll(filters).forEach((query) => {
        queryCache.remove(query);
      });
    });
  }
  resetQueries(filters, options2) {
    const queryCache = this.#queryCache;
    return notifyManager.batch(() => {
      queryCache.findAll(filters).forEach((query) => {
        query.reset();
      });
      return this.refetchQueries({
        type: "active",
        ...filters
      }, options2);
    });
  }
  cancelQueries(filters, cancelOptions = {}) {
    const defaultedCancelOptions = { revert: true, ...cancelOptions };
    const promises2 = notifyManager.batch(() => this.#queryCache.findAll(filters).map((query) => query.cancel(defaultedCancelOptions)));
    return Promise.all(promises2).then(noop).catch(noop);
  }
  invalidateQueries(filters, options2 = {}) {
    return notifyManager.batch(() => {
      this.#queryCache.findAll(filters).forEach((query) => {
        query.invalidate();
      });
      if (filters?.refetchType === "none") {
        return Promise.resolve();
      }
      return this.refetchQueries({
        ...filters,
        type: filters?.refetchType ?? filters?.type ?? "active"
      }, options2);
    });
  }
  refetchQueries(filters, options2 = {}) {
    const fetchOptions = {
      ...options2,
      cancelRefetch: options2.cancelRefetch ?? true
    };
    const promises2 = notifyManager.batch(() => this.#queryCache.findAll(filters).filter((query) => !query.isDisabled() && !query.isStatic()).map((query) => {
      let promise = query.fetch(undefined, fetchOptions);
      if (!fetchOptions.throwOnError) {
        promise = promise.catch(noop);
      }
      return query.state.fetchStatus === "paused" ? Promise.resolve() : promise;
    }));
    return Promise.all(promises2).then(noop);
  }
  fetchQuery(options2) {
    const defaultedOptions = this.defaultQueryOptions(options2);
    if (defaultedOptions.retry === undefined) {
      defaultedOptions.retry = false;
    }
    const query = this.#queryCache.build(this, defaultedOptions);
    return query.isStaleByTime(resolveStaleTime(defaultedOptions.staleTime, query)) ? query.fetch(defaultedOptions) : Promise.resolve(query.state.data);
  }
  prefetchQuery(options2) {
    return this.fetchQuery(options2).then(noop).catch(noop);
  }
  fetchInfiniteQuery(options2) {
    options2.behavior = infiniteQueryBehavior(options2.pages);
    return this.fetchQuery(options2);
  }
  prefetchInfiniteQuery(options2) {
    return this.fetchInfiniteQuery(options2).then(noop).catch(noop);
  }
  ensureInfiniteQueryData(options2) {
    options2.behavior = infiniteQueryBehavior(options2.pages);
    return this.ensureQueryData(options2);
  }
  resumePausedMutations() {
    if (onlineManager.isOnline()) {
      return this.#mutationCache.resumePausedMutations();
    }
    return Promise.resolve();
  }
  getQueryCache() {
    return this.#queryCache;
  }
  getMutationCache() {
    return this.#mutationCache;
  }
  getDefaultOptions() {
    return this.#defaultOptions;
  }
  setDefaultOptions(options2) {
    this.#defaultOptions = options2;
  }
  setQueryDefaults(queryKey, options2) {
    this.#queryDefaults.set(hashKey(queryKey), {
      queryKey,
      defaultOptions: options2
    });
  }
  getQueryDefaults(queryKey) {
    const defaults = [...this.#queryDefaults.values()];
    const result = {};
    defaults.forEach((queryDefault) => {
      if (partialMatchKey(queryKey, queryDefault.queryKey)) {
        Object.assign(result, queryDefault.defaultOptions);
      }
    });
    return result;
  }
  setMutationDefaults(mutationKey, options2) {
    this.#mutationDefaults.set(hashKey(mutationKey), {
      mutationKey,
      defaultOptions: options2
    });
  }
  getMutationDefaults(mutationKey) {
    const defaults = [...this.#mutationDefaults.values()];
    const result = {};
    defaults.forEach((queryDefault) => {
      if (partialMatchKey(mutationKey, queryDefault.mutationKey)) {
        Object.assign(result, queryDefault.defaultOptions);
      }
    });
    return result;
  }
  defaultQueryOptions(options2) {
    if (options2._defaulted) {
      return options2;
    }
    const defaultedOptions = {
      ...this.#defaultOptions.queries,
      ...this.getQueryDefaults(options2.queryKey),
      ...options2,
      _defaulted: true
    };
    if (!defaultedOptions.queryHash) {
      defaultedOptions.queryHash = hashQueryKeyByOptions(defaultedOptions.queryKey, defaultedOptions);
    }
    if (defaultedOptions.refetchOnReconnect === undefined) {
      defaultedOptions.refetchOnReconnect = defaultedOptions.networkMode !== "always";
    }
    if (defaultedOptions.throwOnError === undefined) {
      defaultedOptions.throwOnError = !!defaultedOptions.suspense;
    }
    if (!defaultedOptions.networkMode && defaultedOptions.persister) {
      defaultedOptions.networkMode = "offlineFirst";
    }
    if (defaultedOptions.queryFn === skipToken) {
      defaultedOptions.enabled = false;
    }
    return defaultedOptions;
  }
  defaultMutationOptions(options2) {
    if (options2?._defaulted) {
      return options2;
    }
    return {
      ...this.#defaultOptions.mutations,
      ...options2?.mutationKey && this.getMutationDefaults(options2.mutationKey),
      ...options2,
      _defaulted: true
    };
  }
  clear() {
    this.#queryCache.clear();
    this.#mutationCache.clear();
  }
};
// node_modules/@tanstack/react-query/build/modern/QueryClientProvider.js
var React = __toESM(require_react(), 1);
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
"use client";
var QueryClientContext = React.createContext(undefined);
var useQueryClient = (queryClient) => {
  const client = React.useContext(QueryClientContext);
  if (queryClient) {
    return queryClient;
  }
  if (!client) {
    throw new Error("No QueryClient set, use QueryClientProvider to set one");
  }
  return client;
};
var QueryClientProvider = ({
  client,
  children
}) => {
  React.useEffect(() => {
    client.mount();
    return () => {
      client.unmount();
    };
  }, [client]);
  return /* @__PURE__ */ import_jsx_runtime.jsx(QueryClientContext.Provider, { value: client, children });
};

// node_modules/@tanstack/react-query/build/modern/IsRestoringProvider.js
var React2 = __toESM(require_react(), 1);
"use client";
var IsRestoringContext = React2.createContext(false);
var useIsRestoring = () => React2.useContext(IsRestoringContext);
var IsRestoringProvider = IsRestoringContext.Provider;

// node_modules/@tanstack/react-query/build/modern/QueryErrorResetBoundary.js
var React3 = __toESM(require_react(), 1);
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
"use client";
function createValue() {
  let isReset = false;
  return {
    clearReset: () => {
      isReset = false;
    },
    reset: () => {
      isReset = true;
    },
    isReset: () => {
      return isReset;
    }
  };
}
var QueryErrorResetBoundaryContext = React3.createContext(createValue());
var useQueryErrorResetBoundary = () => React3.useContext(QueryErrorResetBoundaryContext);

// node_modules/@tanstack/react-query/build/modern/errorBoundaryUtils.js
var React4 = __toESM(require_react(), 1);
"use client";
var ensurePreventErrorBoundaryRetry = (options2, errorResetBoundary, query) => {
  const throwOnError = query?.state.error && typeof options2.throwOnError === "function" ? shouldThrowError(options2.throwOnError, [query.state.error, query]) : options2.throwOnError;
  if (options2.suspense || options2.experimental_prefetchInRender || throwOnError) {
    if (!errorResetBoundary.isReset()) {
      options2.retryOnMount = false;
    }
  }
};
var useClearResetErrorBoundary = (errorResetBoundary) => {
  React4.useEffect(() => {
    errorResetBoundary.clearReset();
  }, [errorResetBoundary]);
};
var getHasError = ({
  result,
  errorResetBoundary,
  throwOnError,
  query,
  suspense
}) => {
  return result.isError && !errorResetBoundary.isReset() && !result.isFetching && query && (suspense && result.data === undefined || shouldThrowError(throwOnError, [result.error, query]));
};

// node_modules/@tanstack/react-query/build/modern/suspense.js
var ensureSuspenseTimers = (defaultedOptions) => {
  if (defaultedOptions.suspense) {
    const MIN_SUSPENSE_TIME_MS = 1000;
    const clamp = (value) => value === "static" ? value : Math.max(value ?? MIN_SUSPENSE_TIME_MS, MIN_SUSPENSE_TIME_MS);
    const originalStaleTime = defaultedOptions.staleTime;
    defaultedOptions.staleTime = typeof originalStaleTime === "function" ? (...args) => clamp(originalStaleTime(...args)) : clamp(originalStaleTime);
    if (typeof defaultedOptions.gcTime === "number") {
      defaultedOptions.gcTime = Math.max(defaultedOptions.gcTime, MIN_SUSPENSE_TIME_MS);
    }
  }
};
var willFetch = (result, isRestoring) => result.isLoading && result.isFetching && !isRestoring;
var shouldSuspend = (defaultedOptions, result) => defaultedOptions?.suspense && result.isPending;
var fetchOptimistic = (defaultedOptions, observer, errorResetBoundary) => observer.fetchOptimistic(defaultedOptions).catch(() => {
  errorResetBoundary.clearReset();
});

// node_modules/@tanstack/react-query/build/modern/useBaseQuery.js
var React5 = __toESM(require_react(), 1);
"use client";
function useBaseQuery(options2, Observer, queryClient) {
  if (true) {
    if (typeof options2 !== "object" || Array.isArray(options2)) {
      throw new Error('Bad argument type. Starting with v5, only the "Object" form is allowed when calling query related functions. Please use the error stack to find the culprit call. More info here: https://tanstack.com/query/latest/docs/react/guides/migrating-to-v5#supports-a-single-signature-one-object');
    }
  }
  const isRestoring = useIsRestoring();
  const errorResetBoundary = useQueryErrorResetBoundary();
  const client = useQueryClient(queryClient);
  const defaultedOptions = client.defaultQueryOptions(options2);
  client.getDefaultOptions().queries?._experimental_beforeQuery?.(defaultedOptions);
  const query = client.getQueryCache().get(defaultedOptions.queryHash);
  if (true) {
    if (!defaultedOptions.queryFn) {
      console.error(`[${defaultedOptions.queryHash}]: No queryFn was passed as an option, and no default queryFn was found. The queryFn parameter is only optional when using a default queryFn. More info here: https://tanstack.com/query/latest/docs/framework/react/guides/default-query-function`);
    }
  }
  defaultedOptions._optimisticResults = isRestoring ? "isRestoring" : "optimistic";
  ensureSuspenseTimers(defaultedOptions);
  ensurePreventErrorBoundaryRetry(defaultedOptions, errorResetBoundary, query);
  useClearResetErrorBoundary(errorResetBoundary);
  const isNewCacheEntry = !client.getQueryCache().get(defaultedOptions.queryHash);
  const [observer] = React5.useState(() => new Observer(client, defaultedOptions));
  const result = observer.getOptimisticResult(defaultedOptions);
  const shouldSubscribe = !isRestoring && options2.subscribed !== false;
  React5.useSyncExternalStore(React5.useCallback((onStoreChange) => {
    const unsubscribe = shouldSubscribe ? observer.subscribe(notifyManager.batchCalls(onStoreChange)) : noop;
    observer.updateResult();
    return unsubscribe;
  }, [observer, shouldSubscribe]), () => observer.getCurrentResult(), () => observer.getCurrentResult());
  React5.useEffect(() => {
    observer.setOptions(defaultedOptions);
  }, [defaultedOptions, observer]);
  if (shouldSuspend(defaultedOptions, result)) {
    throw fetchOptimistic(defaultedOptions, observer, errorResetBoundary);
  }
  if (getHasError({
    result,
    errorResetBoundary,
    throwOnError: defaultedOptions.throwOnError,
    query,
    suspense: defaultedOptions.suspense
  })) {
    throw result.error;
  }
  client.getDefaultOptions().queries?._experimental_afterQuery?.(defaultedOptions, result);
  if (defaultedOptions.experimental_prefetchInRender && !isServer && willFetch(result, isRestoring)) {
    const promise = isNewCacheEntry ? fetchOptimistic(defaultedOptions, observer, errorResetBoundary) : query?.promise;
    promise?.catch(noop).finally(() => {
      observer.updateResult();
    });
  }
  return !defaultedOptions.notifyOnChangeProps ? observer.trackResult(result) : result;
}

// node_modules/@tanstack/react-query/build/modern/useQuery.js
"use client";
function useQuery(options2, queryClient) {
  return useBaseQuery(options2, QueryObserver, queryClient);
}

// src/frontend/index.tsx
var import_client = __toESM(require_client(), 1);
var import_react = __toESM(require_react(), 1);

// node_modules/clsx/dist/clsx.mjs
function r(e7) {
  var t, f, n = "";
  if (typeof e7 == "string" || typeof e7 == "number")
    n += e7;
  else if (typeof e7 == "object")
    if (Array.isArray(e7)) {
      var o3 = e7.length;
      for (t = 0;t < o3; t++)
        e7[t] && (f = r(e7[t])) && (n && (n += " "), n += f);
    } else
      for (f in e7)
        e7[f] && (n && (n += " "), n += f);
  return n;
}
function clsx() {
  for (var e7, t, f = 0, n = "", o3 = arguments.length;f < o3; f++)
    (e7 = arguments[f]) && (t = r(e7)) && (n && (n += " "), n += t);
  return n;
}

// node_modules/tailwind-merge/dist/bundle-mjs.mjs
var concatArrays = (array1, array2) => {
  const combinedArray = new Array(array1.length + array2.length);
  for (let i = 0;i < array1.length; i++) {
    combinedArray[i] = array1[i];
  }
  for (let i = 0;i < array2.length; i++) {
    combinedArray[array1.length + i] = array2[i];
  }
  return combinedArray;
};
var createClassValidatorObject = (classGroupId, validator) => ({
  classGroupId,
  validator
});
var createClassPartObject = (nextPart = new Map, validators = null, classGroupId) => ({
  nextPart,
  validators,
  classGroupId
});
var CLASS_PART_SEPARATOR = "-";
var EMPTY_CONFLICTS = [];
var ARBITRARY_PROPERTY_PREFIX = "arbitrary..";
var createClassGroupUtils = (config) => {
  const classMap = createClassMap(config);
  const {
    conflictingClassGroups,
    conflictingClassGroupModifiers
  } = config;
  const getClassGroupId = (className) => {
    if (className.startsWith("[") && className.endsWith("]")) {
      return getGroupIdForArbitraryProperty(className);
    }
    const classParts = className.split(CLASS_PART_SEPARATOR);
    const startIndex = classParts[0] === "" && classParts.length > 1 ? 1 : 0;
    return getGroupRecursive(classParts, startIndex, classMap);
  };
  const getConflictingClassGroupIds = (classGroupId, hasPostfixModifier) => {
    if (hasPostfixModifier) {
      const modifierConflicts = conflictingClassGroupModifiers[classGroupId];
      const baseConflicts = conflictingClassGroups[classGroupId];
      if (modifierConflicts) {
        if (baseConflicts) {
          return concatArrays(baseConflicts, modifierConflicts);
        }
        return modifierConflicts;
      }
      return baseConflicts || EMPTY_CONFLICTS;
    }
    return conflictingClassGroups[classGroupId] || EMPTY_CONFLICTS;
  };
  return {
    getClassGroupId,
    getConflictingClassGroupIds
  };
};
var getGroupRecursive = (classParts, startIndex, classPartObject) => {
  const classPathsLength = classParts.length - startIndex;
  if (classPathsLength === 0) {
    return classPartObject.classGroupId;
  }
  const currentClassPart = classParts[startIndex];
  const nextClassPartObject = classPartObject.nextPart.get(currentClassPart);
  if (nextClassPartObject) {
    const result = getGroupRecursive(classParts, startIndex + 1, nextClassPartObject);
    if (result)
      return result;
  }
  const validators = classPartObject.validators;
  if (validators === null) {
    return;
  }
  const classRest = startIndex === 0 ? classParts.join(CLASS_PART_SEPARATOR) : classParts.slice(startIndex).join(CLASS_PART_SEPARATOR);
  const validatorsLength = validators.length;
  for (let i = 0;i < validatorsLength; i++) {
    const validatorObj = validators[i];
    if (validatorObj.validator(classRest)) {
      return validatorObj.classGroupId;
    }
  }
  return;
};
var getGroupIdForArbitraryProperty = (className) => className.slice(1, -1).indexOf(":") === -1 ? undefined : (() => {
  const content = className.slice(1, -1);
  const colonIndex = content.indexOf(":");
  const property = content.slice(0, colonIndex);
  return property ? ARBITRARY_PROPERTY_PREFIX + property : undefined;
})();
var createClassMap = (config) => {
  const {
    theme,
    classGroups
  } = config;
  return processClassGroups(classGroups, theme);
};
var processClassGroups = (classGroups, theme) => {
  const classMap = createClassPartObject();
  for (const classGroupId in classGroups) {
    const group = classGroups[classGroupId];
    processClassesRecursively(group, classMap, classGroupId, theme);
  }
  return classMap;
};
var processClassesRecursively = (classGroup, classPartObject, classGroupId, theme) => {
  const len = classGroup.length;
  for (let i = 0;i < len; i++) {
    const classDefinition = classGroup[i];
    processClassDefinition(classDefinition, classPartObject, classGroupId, theme);
  }
};
var processClassDefinition = (classDefinition, classPartObject, classGroupId, theme) => {
  if (typeof classDefinition === "string") {
    processStringDefinition(classDefinition, classPartObject, classGroupId);
    return;
  }
  if (typeof classDefinition === "function") {
    processFunctionDefinition(classDefinition, classPartObject, classGroupId, theme);
    return;
  }
  processObjectDefinition(classDefinition, classPartObject, classGroupId, theme);
};
var processStringDefinition = (classDefinition, classPartObject, classGroupId) => {
  const classPartObjectToEdit = classDefinition === "" ? classPartObject : getPart(classPartObject, classDefinition);
  classPartObjectToEdit.classGroupId = classGroupId;
};
var processFunctionDefinition = (classDefinition, classPartObject, classGroupId, theme) => {
  if (isThemeGetter(classDefinition)) {
    processClassesRecursively(classDefinition(theme), classPartObject, classGroupId, theme);
    return;
  }
  if (classPartObject.validators === null) {
    classPartObject.validators = [];
  }
  classPartObject.validators.push(createClassValidatorObject(classGroupId, classDefinition));
};
var processObjectDefinition = (classDefinition, classPartObject, classGroupId, theme) => {
  const entries = Object.entries(classDefinition);
  const len = entries.length;
  for (let i = 0;i < len; i++) {
    const [key, value] = entries[i];
    processClassesRecursively(value, getPart(classPartObject, key), classGroupId, theme);
  }
};
var getPart = (classPartObject, path) => {
  let current = classPartObject;
  const parts = path.split(CLASS_PART_SEPARATOR);
  const len = parts.length;
  for (let i = 0;i < len; i++) {
    const part = parts[i];
    let next = current.nextPart.get(part);
    if (!next) {
      next = createClassPartObject();
      current.nextPart.set(part, next);
    }
    current = next;
  }
  return current;
};
var isThemeGetter = (func) => ("isThemeGetter" in func) && func.isThemeGetter === true;
var createLruCache = (maxCacheSize) => {
  if (maxCacheSize < 1) {
    return {
      get: () => {
        return;
      },
      set: () => {}
    };
  }
  let cacheSize = 0;
  let cache2 = Object.create(null);
  let previousCache = Object.create(null);
  const update = (key, value) => {
    cache2[key] = value;
    cacheSize++;
    if (cacheSize > maxCacheSize) {
      cacheSize = 0;
      previousCache = cache2;
      cache2 = Object.create(null);
    }
  };
  return {
    get(key) {
      let value = cache2[key];
      if (value !== undefined) {
        return value;
      }
      if ((value = previousCache[key]) !== undefined) {
        update(key, value);
        return value;
      }
    },
    set(key, value) {
      if (key in cache2) {
        cache2[key] = value;
      } else {
        update(key, value);
      }
    }
  };
};
var IMPORTANT_MODIFIER = "!";
var MODIFIER_SEPARATOR = ":";
var EMPTY_MODIFIERS = [];
var createResultObject = (modifiers, hasImportantModifier, baseClassName, maybePostfixModifierPosition, isExternal) => ({
  modifiers,
  hasImportantModifier,
  baseClassName,
  maybePostfixModifierPosition,
  isExternal
});
var createParseClassName = (config) => {
  const {
    prefix,
    experimentalParseClassName
  } = config;
  let parseClassName = (className) => {
    const modifiers = [];
    let bracketDepth = 0;
    let parenDepth = 0;
    let modifierStart = 0;
    let postfixModifierPosition;
    const len = className.length;
    for (let index = 0;index < len; index++) {
      const currentCharacter = className[index];
      if (bracketDepth === 0 && parenDepth === 0) {
        if (currentCharacter === MODIFIER_SEPARATOR) {
          modifiers.push(className.slice(modifierStart, index));
          modifierStart = index + 1;
          continue;
        }
        if (currentCharacter === "/") {
          postfixModifierPosition = index;
          continue;
        }
      }
      if (currentCharacter === "[")
        bracketDepth++;
      else if (currentCharacter === "]")
        bracketDepth--;
      else if (currentCharacter === "(")
        parenDepth++;
      else if (currentCharacter === ")")
        parenDepth--;
    }
    const baseClassNameWithImportantModifier = modifiers.length === 0 ? className : className.slice(modifierStart);
    let baseClassName = baseClassNameWithImportantModifier;
    let hasImportantModifier = false;
    if (baseClassNameWithImportantModifier.endsWith(IMPORTANT_MODIFIER)) {
      baseClassName = baseClassNameWithImportantModifier.slice(0, -1);
      hasImportantModifier = true;
    } else if (baseClassNameWithImportantModifier.startsWith(IMPORTANT_MODIFIER)) {
      baseClassName = baseClassNameWithImportantModifier.slice(1);
      hasImportantModifier = true;
    }
    const maybePostfixModifierPosition = postfixModifierPosition && postfixModifierPosition > modifierStart ? postfixModifierPosition - modifierStart : undefined;
    return createResultObject(modifiers, hasImportantModifier, baseClassName, maybePostfixModifierPosition);
  };
  if (prefix) {
    const fullPrefix = prefix + MODIFIER_SEPARATOR;
    const parseClassNameOriginal = parseClassName;
    parseClassName = (className) => className.startsWith(fullPrefix) ? parseClassNameOriginal(className.slice(fullPrefix.length)) : createResultObject(EMPTY_MODIFIERS, false, className, undefined, true);
  }
  if (experimentalParseClassName) {
    const parseClassNameOriginal = parseClassName;
    parseClassName = (className) => experimentalParseClassName({
      className,
      parseClassName: parseClassNameOriginal
    });
  }
  return parseClassName;
};
var createSortModifiers = (config) => {
  const modifierWeights = new Map;
  config.orderSensitiveModifiers.forEach((mod3, index) => {
    modifierWeights.set(mod3, 1e6 + index);
  });
  return (modifiers) => {
    const result = [];
    let currentSegment = [];
    for (let i = 0;i < modifiers.length; i++) {
      const modifier = modifiers[i];
      const isArbitrary = modifier[0] === "[";
      const isOrderSensitive = modifierWeights.has(modifier);
      if (isArbitrary || isOrderSensitive) {
        if (currentSegment.length > 0) {
          currentSegment.sort();
          result.push(...currentSegment);
          currentSegment = [];
        }
        result.push(modifier);
      } else {
        currentSegment.push(modifier);
      }
    }
    if (currentSegment.length > 0) {
      currentSegment.sort();
      result.push(...currentSegment);
    }
    return result;
  };
};
var createConfigUtils = (config) => ({
  cache: createLruCache(config.cacheSize),
  parseClassName: createParseClassName(config),
  sortModifiers: createSortModifiers(config),
  ...createClassGroupUtils(config)
});
var SPLIT_CLASSES_REGEX = /\s+/;
var mergeClassList = (classList, configUtils) => {
  const {
    parseClassName,
    getClassGroupId,
    getConflictingClassGroupIds,
    sortModifiers
  } = configUtils;
  const classGroupsInConflict = [];
  const classNames = classList.trim().split(SPLIT_CLASSES_REGEX);
  let result = "";
  for (let index = classNames.length - 1;index >= 0; index -= 1) {
    const originalClassName = classNames[index];
    const {
      isExternal,
      modifiers,
      hasImportantModifier,
      baseClassName,
      maybePostfixModifierPosition
    } = parseClassName(originalClassName);
    if (isExternal) {
      result = originalClassName + (result.length > 0 ? " " + result : result);
      continue;
    }
    let hasPostfixModifier = !!maybePostfixModifierPosition;
    let classGroupId = getClassGroupId(hasPostfixModifier ? baseClassName.substring(0, maybePostfixModifierPosition) : baseClassName);
    if (!classGroupId) {
      if (!hasPostfixModifier) {
        result = originalClassName + (result.length > 0 ? " " + result : result);
        continue;
      }
      classGroupId = getClassGroupId(baseClassName);
      if (!classGroupId) {
        result = originalClassName + (result.length > 0 ? " " + result : result);
        continue;
      }
      hasPostfixModifier = false;
    }
    const variantModifier = modifiers.length === 0 ? "" : modifiers.length === 1 ? modifiers[0] : sortModifiers(modifiers).join(":");
    const modifierId = hasImportantModifier ? variantModifier + IMPORTANT_MODIFIER : variantModifier;
    const classId = modifierId + classGroupId;
    if (classGroupsInConflict.indexOf(classId) > -1) {
      continue;
    }
    classGroupsInConflict.push(classId);
    const conflictGroups = getConflictingClassGroupIds(classGroupId, hasPostfixModifier);
    for (let i = 0;i < conflictGroups.length; ++i) {
      const group = conflictGroups[i];
      classGroupsInConflict.push(modifierId + group);
    }
    result = originalClassName + (result.length > 0 ? " " + result : result);
  }
  return result;
};
var twJoin = (...classLists) => {
  let index = 0;
  let argument;
  let resolvedValue;
  let string = "";
  while (index < classLists.length) {
    if (argument = classLists[index++]) {
      if (resolvedValue = toValue(argument)) {
        string && (string += " ");
        string += resolvedValue;
      }
    }
  }
  return string;
};
var toValue = (mix) => {
  if (typeof mix === "string") {
    return mix;
  }
  let resolvedValue;
  let string = "";
  for (let k = 0;k < mix.length; k++) {
    if (mix[k]) {
      if (resolvedValue = toValue(mix[k])) {
        string && (string += " ");
        string += resolvedValue;
      }
    }
  }
  return string;
};
var createTailwindMerge = (createConfigFirst, ...createConfigRest) => {
  let configUtils;
  let cacheGet;
  let cacheSet;
  let functionToCall;
  const initTailwindMerge = (classList) => {
    const config = createConfigRest.reduce((previousConfig, createConfigCurrent) => createConfigCurrent(previousConfig), createConfigFirst());
    configUtils = createConfigUtils(config);
    cacheGet = configUtils.cache.get;
    cacheSet = configUtils.cache.set;
    functionToCall = tailwindMerge;
    return tailwindMerge(classList);
  };
  const tailwindMerge = (classList) => {
    const cachedResult = cacheGet(classList);
    if (cachedResult) {
      return cachedResult;
    }
    const result = mergeClassList(classList, configUtils);
    cacheSet(classList, result);
    return result;
  };
  functionToCall = initTailwindMerge;
  return (...args) => functionToCall(twJoin(...args));
};
var fallbackThemeArr = [];
var fromTheme = (key) => {
  const themeGetter = (theme) => theme[key] || fallbackThemeArr;
  themeGetter.isThemeGetter = true;
  return themeGetter;
};
var arbitraryValueRegex = /^\[(?:(\w[\w-]*):)?(.+)\]$/i;
var arbitraryVariableRegex = /^\((?:(\w[\w-]*):)?(.+)\)$/i;
var fractionRegex = /^\d+\/\d+$/;
var tshirtUnitRegex = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/;
var lengthUnitRegex = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/;
var colorFunctionRegex = /^(rgba?|hsla?|hwb|(ok)?(lab|lch)|color-mix)\(.+\)$/;
var shadowRegex = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/;
var imageRegex = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/;
var isFraction = (value) => fractionRegex.test(value);
var isNumber = (value) => !!value && !Number.isNaN(Number(value));
var isInteger = (value) => !!value && Number.isInteger(Number(value));
var isPercent = (value) => value.endsWith("%") && isNumber(value.slice(0, -1));
var isTshirtSize = (value) => tshirtUnitRegex.test(value);
var isAny = () => true;
var isLengthOnly = (value) => lengthUnitRegex.test(value) && !colorFunctionRegex.test(value);
var isNever = () => false;
var isShadow = (value) => shadowRegex.test(value);
var isImage = (value) => imageRegex.test(value);
var isAnyNonArbitrary = (value) => !isArbitraryValue(value) && !isArbitraryVariable(value);
var isArbitrarySize = (value) => getIsArbitraryValue(value, isLabelSize, isNever);
var isArbitraryValue = (value) => arbitraryValueRegex.test(value);
var isArbitraryLength = (value) => getIsArbitraryValue(value, isLabelLength, isLengthOnly);
var isArbitraryNumber = (value) => getIsArbitraryValue(value, isLabelNumber, isNumber);
var isArbitraryPosition = (value) => getIsArbitraryValue(value, isLabelPosition, isNever);
var isArbitraryImage = (value) => getIsArbitraryValue(value, isLabelImage, isImage);
var isArbitraryShadow = (value) => getIsArbitraryValue(value, isLabelShadow, isShadow);
var isArbitraryVariable = (value) => arbitraryVariableRegex.test(value);
var isArbitraryVariableLength = (value) => getIsArbitraryVariable(value, isLabelLength);
var isArbitraryVariableFamilyName = (value) => getIsArbitraryVariable(value, isLabelFamilyName);
var isArbitraryVariablePosition = (value) => getIsArbitraryVariable(value, isLabelPosition);
var isArbitraryVariableSize = (value) => getIsArbitraryVariable(value, isLabelSize);
var isArbitraryVariableImage = (value) => getIsArbitraryVariable(value, isLabelImage);
var isArbitraryVariableShadow = (value) => getIsArbitraryVariable(value, isLabelShadow, true);
var getIsArbitraryValue = (value, testLabel, testValue) => {
  const result = arbitraryValueRegex.exec(value);
  if (result) {
    if (result[1]) {
      return testLabel(result[1]);
    }
    return testValue(result[2]);
  }
  return false;
};
var getIsArbitraryVariable = (value, testLabel, shouldMatchNoLabel = false) => {
  const result = arbitraryVariableRegex.exec(value);
  if (result) {
    if (result[1]) {
      return testLabel(result[1]);
    }
    return shouldMatchNoLabel;
  }
  return false;
};
var isLabelPosition = (label) => label === "position" || label === "percentage";
var isLabelImage = (label) => label === "image" || label === "url";
var isLabelSize = (label) => label === "length" || label === "size" || label === "bg-size";
var isLabelLength = (label) => label === "length";
var isLabelNumber = (label) => label === "number";
var isLabelFamilyName = (label) => label === "family-name";
var isLabelShadow = (label) => label === "shadow";
var getDefaultConfig = () => {
  const themeColor = fromTheme("color");
  const themeFont = fromTheme("font");
  const themeText = fromTheme("text");
  const themeFontWeight = fromTheme("font-weight");
  const themeTracking = fromTheme("tracking");
  const themeLeading = fromTheme("leading");
  const themeBreakpoint = fromTheme("breakpoint");
  const themeContainer = fromTheme("container");
  const themeSpacing = fromTheme("spacing");
  const themeRadius = fromTheme("radius");
  const themeShadow = fromTheme("shadow");
  const themeInsetShadow = fromTheme("inset-shadow");
  const themeTextShadow = fromTheme("text-shadow");
  const themeDropShadow = fromTheme("drop-shadow");
  const themeBlur = fromTheme("blur");
  const themePerspective = fromTheme("perspective");
  const themeAspect = fromTheme("aspect");
  const themeEase = fromTheme("ease");
  const themeAnimate = fromTheme("animate");
  const scaleBreak = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"];
  const scalePosition = () => [
    "center",
    "top",
    "bottom",
    "left",
    "right",
    "top-left",
    "left-top",
    "top-right",
    "right-top",
    "bottom-right",
    "right-bottom",
    "bottom-left",
    "left-bottom"
  ];
  const scalePositionWithArbitrary = () => [...scalePosition(), isArbitraryVariable, isArbitraryValue];
  const scaleOverflow = () => ["auto", "hidden", "clip", "visible", "scroll"];
  const scaleOverscroll = () => ["auto", "contain", "none"];
  const scaleUnambiguousSpacing = () => [isArbitraryVariable, isArbitraryValue, themeSpacing];
  const scaleInset = () => [isFraction, "full", "auto", ...scaleUnambiguousSpacing()];
  const scaleGridTemplateColsRows = () => [isInteger, "none", "subgrid", isArbitraryVariable, isArbitraryValue];
  const scaleGridColRowStartAndEnd = () => ["auto", {
    span: ["full", isInteger, isArbitraryVariable, isArbitraryValue]
  }, isInteger, isArbitraryVariable, isArbitraryValue];
  const scaleGridColRowStartOrEnd = () => [isInteger, "auto", isArbitraryVariable, isArbitraryValue];
  const scaleGridAutoColsRows = () => ["auto", "min", "max", "fr", isArbitraryVariable, isArbitraryValue];
  const scaleAlignPrimaryAxis = () => ["start", "end", "center", "between", "around", "evenly", "stretch", "baseline", "center-safe", "end-safe"];
  const scaleAlignSecondaryAxis = () => ["start", "end", "center", "stretch", "center-safe", "end-safe"];
  const scaleMargin = () => ["auto", ...scaleUnambiguousSpacing()];
  const scaleSizing = () => [isFraction, "auto", "full", "dvw", "dvh", "lvw", "lvh", "svw", "svh", "min", "max", "fit", ...scaleUnambiguousSpacing()];
  const scaleColor = () => [themeColor, isArbitraryVariable, isArbitraryValue];
  const scaleBgPosition = () => [...scalePosition(), isArbitraryVariablePosition, isArbitraryPosition, {
    position: [isArbitraryVariable, isArbitraryValue]
  }];
  const scaleBgRepeat = () => ["no-repeat", {
    repeat: ["", "x", "y", "space", "round"]
  }];
  const scaleBgSize = () => ["auto", "cover", "contain", isArbitraryVariableSize, isArbitrarySize, {
    size: [isArbitraryVariable, isArbitraryValue]
  }];
  const scaleGradientStopPosition = () => [isPercent, isArbitraryVariableLength, isArbitraryLength];
  const scaleRadius = () => [
    "",
    "none",
    "full",
    themeRadius,
    isArbitraryVariable,
    isArbitraryValue
  ];
  const scaleBorderWidth = () => ["", isNumber, isArbitraryVariableLength, isArbitraryLength];
  const scaleLineStyle = () => ["solid", "dashed", "dotted", "double"];
  const scaleBlendMode = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"];
  const scaleMaskImagePosition = () => [isNumber, isPercent, isArbitraryVariablePosition, isArbitraryPosition];
  const scaleBlur = () => [
    "",
    "none",
    themeBlur,
    isArbitraryVariable,
    isArbitraryValue
  ];
  const scaleRotate = () => ["none", isNumber, isArbitraryVariable, isArbitraryValue];
  const scaleScale = () => ["none", isNumber, isArbitraryVariable, isArbitraryValue];
  const scaleSkew = () => [isNumber, isArbitraryVariable, isArbitraryValue];
  const scaleTranslate = () => [isFraction, "full", ...scaleUnambiguousSpacing()];
  return {
    cacheSize: 500,
    theme: {
      animate: ["spin", "ping", "pulse", "bounce"],
      aspect: ["video"],
      blur: [isTshirtSize],
      breakpoint: [isTshirtSize],
      color: [isAny],
      container: [isTshirtSize],
      "drop-shadow": [isTshirtSize],
      ease: ["in", "out", "in-out"],
      font: [isAnyNonArbitrary],
      "font-weight": ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black"],
      "inset-shadow": [isTshirtSize],
      leading: ["none", "tight", "snug", "normal", "relaxed", "loose"],
      perspective: ["dramatic", "near", "normal", "midrange", "distant", "none"],
      radius: [isTshirtSize],
      shadow: [isTshirtSize],
      spacing: ["px", isNumber],
      text: [isTshirtSize],
      "text-shadow": [isTshirtSize],
      tracking: ["tighter", "tight", "normal", "wide", "wider", "widest"]
    },
    classGroups: {
      aspect: [{
        aspect: ["auto", "square", isFraction, isArbitraryValue, isArbitraryVariable, themeAspect]
      }],
      container: ["container"],
      columns: [{
        columns: [isNumber, isArbitraryValue, isArbitraryVariable, themeContainer]
      }],
      "break-after": [{
        "break-after": scaleBreak()
      }],
      "break-before": [{
        "break-before": scaleBreak()
      }],
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      box: [{
        box: ["border", "content"]
      }],
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      sr: ["sr-only", "not-sr-only"],
      float: [{
        float: ["right", "left", "none", "start", "end"]
      }],
      clear: [{
        clear: ["left", "right", "both", "none", "start", "end"]
      }],
      isolation: ["isolate", "isolation-auto"],
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      "object-position": [{
        object: scalePositionWithArbitrary()
      }],
      overflow: [{
        overflow: scaleOverflow()
      }],
      "overflow-x": [{
        "overflow-x": scaleOverflow()
      }],
      "overflow-y": [{
        "overflow-y": scaleOverflow()
      }],
      overscroll: [{
        overscroll: scaleOverscroll()
      }],
      "overscroll-x": [{
        "overscroll-x": scaleOverscroll()
      }],
      "overscroll-y": [{
        "overscroll-y": scaleOverscroll()
      }],
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      inset: [{
        inset: scaleInset()
      }],
      "inset-x": [{
        "inset-x": scaleInset()
      }],
      "inset-y": [{
        "inset-y": scaleInset()
      }],
      start: [{
        start: scaleInset()
      }],
      end: [{
        end: scaleInset()
      }],
      top: [{
        top: scaleInset()
      }],
      right: [{
        right: scaleInset()
      }],
      bottom: [{
        bottom: scaleInset()
      }],
      left: [{
        left: scaleInset()
      }],
      visibility: ["visible", "invisible", "collapse"],
      z: [{
        z: [isInteger, "auto", isArbitraryVariable, isArbitraryValue]
      }],
      basis: [{
        basis: [isFraction, "full", "auto", themeContainer, ...scaleUnambiguousSpacing()]
      }],
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      "flex-wrap": [{
        flex: ["nowrap", "wrap", "wrap-reverse"]
      }],
      flex: [{
        flex: [isNumber, isFraction, "auto", "initial", "none", isArbitraryValue]
      }],
      grow: [{
        grow: ["", isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      shrink: [{
        shrink: ["", isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      order: [{
        order: [isInteger, "first", "last", "none", isArbitraryVariable, isArbitraryValue]
      }],
      "grid-cols": [{
        "grid-cols": scaleGridTemplateColsRows()
      }],
      "col-start-end": [{
        col: scaleGridColRowStartAndEnd()
      }],
      "col-start": [{
        "col-start": scaleGridColRowStartOrEnd()
      }],
      "col-end": [{
        "col-end": scaleGridColRowStartOrEnd()
      }],
      "grid-rows": [{
        "grid-rows": scaleGridTemplateColsRows()
      }],
      "row-start-end": [{
        row: scaleGridColRowStartAndEnd()
      }],
      "row-start": [{
        "row-start": scaleGridColRowStartOrEnd()
      }],
      "row-end": [{
        "row-end": scaleGridColRowStartOrEnd()
      }],
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      "auto-cols": [{
        "auto-cols": scaleGridAutoColsRows()
      }],
      "auto-rows": [{
        "auto-rows": scaleGridAutoColsRows()
      }],
      gap: [{
        gap: scaleUnambiguousSpacing()
      }],
      "gap-x": [{
        "gap-x": scaleUnambiguousSpacing()
      }],
      "gap-y": [{
        "gap-y": scaleUnambiguousSpacing()
      }],
      "justify-content": [{
        justify: [...scaleAlignPrimaryAxis(), "normal"]
      }],
      "justify-items": [{
        "justify-items": [...scaleAlignSecondaryAxis(), "normal"]
      }],
      "justify-self": [{
        "justify-self": ["auto", ...scaleAlignSecondaryAxis()]
      }],
      "align-content": [{
        content: ["normal", ...scaleAlignPrimaryAxis()]
      }],
      "align-items": [{
        items: [...scaleAlignSecondaryAxis(), {
          baseline: ["", "last"]
        }]
      }],
      "align-self": [{
        self: ["auto", ...scaleAlignSecondaryAxis(), {
          baseline: ["", "last"]
        }]
      }],
      "place-content": [{
        "place-content": scaleAlignPrimaryAxis()
      }],
      "place-items": [{
        "place-items": [...scaleAlignSecondaryAxis(), "baseline"]
      }],
      "place-self": [{
        "place-self": ["auto", ...scaleAlignSecondaryAxis()]
      }],
      p: [{
        p: scaleUnambiguousSpacing()
      }],
      px: [{
        px: scaleUnambiguousSpacing()
      }],
      py: [{
        py: scaleUnambiguousSpacing()
      }],
      ps: [{
        ps: scaleUnambiguousSpacing()
      }],
      pe: [{
        pe: scaleUnambiguousSpacing()
      }],
      pt: [{
        pt: scaleUnambiguousSpacing()
      }],
      pr: [{
        pr: scaleUnambiguousSpacing()
      }],
      pb: [{
        pb: scaleUnambiguousSpacing()
      }],
      pl: [{
        pl: scaleUnambiguousSpacing()
      }],
      m: [{
        m: scaleMargin()
      }],
      mx: [{
        mx: scaleMargin()
      }],
      my: [{
        my: scaleMargin()
      }],
      ms: [{
        ms: scaleMargin()
      }],
      me: [{
        me: scaleMargin()
      }],
      mt: [{
        mt: scaleMargin()
      }],
      mr: [{
        mr: scaleMargin()
      }],
      mb: [{
        mb: scaleMargin()
      }],
      ml: [{
        ml: scaleMargin()
      }],
      "space-x": [{
        "space-x": scaleUnambiguousSpacing()
      }],
      "space-x-reverse": ["space-x-reverse"],
      "space-y": [{
        "space-y": scaleUnambiguousSpacing()
      }],
      "space-y-reverse": ["space-y-reverse"],
      size: [{
        size: scaleSizing()
      }],
      w: [{
        w: [themeContainer, "screen", ...scaleSizing()]
      }],
      "min-w": [{
        "min-w": [
          themeContainer,
          "screen",
          "none",
          ...scaleSizing()
        ]
      }],
      "max-w": [{
        "max-w": [
          themeContainer,
          "screen",
          "none",
          "prose",
          {
            screen: [themeBreakpoint]
          },
          ...scaleSizing()
        ]
      }],
      h: [{
        h: ["screen", "lh", ...scaleSizing()]
      }],
      "min-h": [{
        "min-h": ["screen", "lh", "none", ...scaleSizing()]
      }],
      "max-h": [{
        "max-h": ["screen", "lh", ...scaleSizing()]
      }],
      "font-size": [{
        text: ["base", themeText, isArbitraryVariableLength, isArbitraryLength]
      }],
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      "font-style": ["italic", "not-italic"],
      "font-weight": [{
        font: [themeFontWeight, isArbitraryVariable, isArbitraryNumber]
      }],
      "font-stretch": [{
        "font-stretch": ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded", isPercent, isArbitraryValue]
      }],
      "font-family": [{
        font: [isArbitraryVariableFamilyName, isArbitraryValue, themeFont]
      }],
      "fvn-normal": ["normal-nums"],
      "fvn-ordinal": ["ordinal"],
      "fvn-slashed-zero": ["slashed-zero"],
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
      tracking: [{
        tracking: [themeTracking, isArbitraryVariable, isArbitraryValue]
      }],
      "line-clamp": [{
        "line-clamp": [isNumber, "none", isArbitraryVariable, isArbitraryNumber]
      }],
      leading: [{
        leading: [
          themeLeading,
          ...scaleUnambiguousSpacing()
        ]
      }],
      "list-image": [{
        "list-image": ["none", isArbitraryVariable, isArbitraryValue]
      }],
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      "list-style-type": [{
        list: ["disc", "decimal", "none", isArbitraryVariable, isArbitraryValue]
      }],
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      "placeholder-color": [{
        placeholder: scaleColor()
      }],
      "text-color": [{
        text: scaleColor()
      }],
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      "text-decoration-style": [{
        decoration: [...scaleLineStyle(), "wavy"]
      }],
      "text-decoration-thickness": [{
        decoration: [isNumber, "from-font", "auto", isArbitraryVariable, isArbitraryLength]
      }],
      "text-decoration-color": [{
        decoration: scaleColor()
      }],
      "underline-offset": [{
        "underline-offset": [isNumber, "auto", isArbitraryVariable, isArbitraryValue]
      }],
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      "text-wrap": [{
        text: ["wrap", "nowrap", "balance", "pretty"]
      }],
      indent: [{
        indent: scaleUnambiguousSpacing()
      }],
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", isArbitraryVariable, isArbitraryValue]
      }],
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      wrap: [{
        wrap: ["break-word", "anywhere", "normal"]
      }],
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      content: [{
        content: ["none", isArbitraryVariable, isArbitraryValue]
      }],
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      "bg-position": [{
        bg: scaleBgPosition()
      }],
      "bg-repeat": [{
        bg: scaleBgRepeat()
      }],
      "bg-size": [{
        bg: scaleBgSize()
      }],
      "bg-image": [{
        bg: ["none", {
          linear: [{
            to: ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
          }, isInteger, isArbitraryVariable, isArbitraryValue],
          radial: ["", isArbitraryVariable, isArbitraryValue],
          conic: [isInteger, isArbitraryVariable, isArbitraryValue]
        }, isArbitraryVariableImage, isArbitraryImage]
      }],
      "bg-color": [{
        bg: scaleColor()
      }],
      "gradient-from-pos": [{
        from: scaleGradientStopPosition()
      }],
      "gradient-via-pos": [{
        via: scaleGradientStopPosition()
      }],
      "gradient-to-pos": [{
        to: scaleGradientStopPosition()
      }],
      "gradient-from": [{
        from: scaleColor()
      }],
      "gradient-via": [{
        via: scaleColor()
      }],
      "gradient-to": [{
        to: scaleColor()
      }],
      rounded: [{
        rounded: scaleRadius()
      }],
      "rounded-s": [{
        "rounded-s": scaleRadius()
      }],
      "rounded-e": [{
        "rounded-e": scaleRadius()
      }],
      "rounded-t": [{
        "rounded-t": scaleRadius()
      }],
      "rounded-r": [{
        "rounded-r": scaleRadius()
      }],
      "rounded-b": [{
        "rounded-b": scaleRadius()
      }],
      "rounded-l": [{
        "rounded-l": scaleRadius()
      }],
      "rounded-ss": [{
        "rounded-ss": scaleRadius()
      }],
      "rounded-se": [{
        "rounded-se": scaleRadius()
      }],
      "rounded-ee": [{
        "rounded-ee": scaleRadius()
      }],
      "rounded-es": [{
        "rounded-es": scaleRadius()
      }],
      "rounded-tl": [{
        "rounded-tl": scaleRadius()
      }],
      "rounded-tr": [{
        "rounded-tr": scaleRadius()
      }],
      "rounded-br": [{
        "rounded-br": scaleRadius()
      }],
      "rounded-bl": [{
        "rounded-bl": scaleRadius()
      }],
      "border-w": [{
        border: scaleBorderWidth()
      }],
      "border-w-x": [{
        "border-x": scaleBorderWidth()
      }],
      "border-w-y": [{
        "border-y": scaleBorderWidth()
      }],
      "border-w-s": [{
        "border-s": scaleBorderWidth()
      }],
      "border-w-e": [{
        "border-e": scaleBorderWidth()
      }],
      "border-w-t": [{
        "border-t": scaleBorderWidth()
      }],
      "border-w-r": [{
        "border-r": scaleBorderWidth()
      }],
      "border-w-b": [{
        "border-b": scaleBorderWidth()
      }],
      "border-w-l": [{
        "border-l": scaleBorderWidth()
      }],
      "divide-x": [{
        "divide-x": scaleBorderWidth()
      }],
      "divide-x-reverse": ["divide-x-reverse"],
      "divide-y": [{
        "divide-y": scaleBorderWidth()
      }],
      "divide-y-reverse": ["divide-y-reverse"],
      "border-style": [{
        border: [...scaleLineStyle(), "hidden", "none"]
      }],
      "divide-style": [{
        divide: [...scaleLineStyle(), "hidden", "none"]
      }],
      "border-color": [{
        border: scaleColor()
      }],
      "border-color-x": [{
        "border-x": scaleColor()
      }],
      "border-color-y": [{
        "border-y": scaleColor()
      }],
      "border-color-s": [{
        "border-s": scaleColor()
      }],
      "border-color-e": [{
        "border-e": scaleColor()
      }],
      "border-color-t": [{
        "border-t": scaleColor()
      }],
      "border-color-r": [{
        "border-r": scaleColor()
      }],
      "border-color-b": [{
        "border-b": scaleColor()
      }],
      "border-color-l": [{
        "border-l": scaleColor()
      }],
      "divide-color": [{
        divide: scaleColor()
      }],
      "outline-style": [{
        outline: [...scaleLineStyle(), "none", "hidden"]
      }],
      "outline-offset": [{
        "outline-offset": [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      "outline-w": [{
        outline: ["", isNumber, isArbitraryVariableLength, isArbitraryLength]
      }],
      "outline-color": [{
        outline: scaleColor()
      }],
      shadow: [{
        shadow: [
          "",
          "none",
          themeShadow,
          isArbitraryVariableShadow,
          isArbitraryShadow
        ]
      }],
      "shadow-color": [{
        shadow: scaleColor()
      }],
      "inset-shadow": [{
        "inset-shadow": ["none", themeInsetShadow, isArbitraryVariableShadow, isArbitraryShadow]
      }],
      "inset-shadow-color": [{
        "inset-shadow": scaleColor()
      }],
      "ring-w": [{
        ring: scaleBorderWidth()
      }],
      "ring-w-inset": ["ring-inset"],
      "ring-color": [{
        ring: scaleColor()
      }],
      "ring-offset-w": [{
        "ring-offset": [isNumber, isArbitraryLength]
      }],
      "ring-offset-color": [{
        "ring-offset": scaleColor()
      }],
      "inset-ring-w": [{
        "inset-ring": scaleBorderWidth()
      }],
      "inset-ring-color": [{
        "inset-ring": scaleColor()
      }],
      "text-shadow": [{
        "text-shadow": ["none", themeTextShadow, isArbitraryVariableShadow, isArbitraryShadow]
      }],
      "text-shadow-color": [{
        "text-shadow": scaleColor()
      }],
      opacity: [{
        opacity: [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      "mix-blend": [{
        "mix-blend": [...scaleBlendMode(), "plus-darker", "plus-lighter"]
      }],
      "bg-blend": [{
        "bg-blend": scaleBlendMode()
      }],
      "mask-clip": [{
        "mask-clip": ["border", "padding", "content", "fill", "stroke", "view"]
      }, "mask-no-clip"],
      "mask-composite": [{
        mask: ["add", "subtract", "intersect", "exclude"]
      }],
      "mask-image-linear-pos": [{
        "mask-linear": [isNumber]
      }],
      "mask-image-linear-from-pos": [{
        "mask-linear-from": scaleMaskImagePosition()
      }],
      "mask-image-linear-to-pos": [{
        "mask-linear-to": scaleMaskImagePosition()
      }],
      "mask-image-linear-from-color": [{
        "mask-linear-from": scaleColor()
      }],
      "mask-image-linear-to-color": [{
        "mask-linear-to": scaleColor()
      }],
      "mask-image-t-from-pos": [{
        "mask-t-from": scaleMaskImagePosition()
      }],
      "mask-image-t-to-pos": [{
        "mask-t-to": scaleMaskImagePosition()
      }],
      "mask-image-t-from-color": [{
        "mask-t-from": scaleColor()
      }],
      "mask-image-t-to-color": [{
        "mask-t-to": scaleColor()
      }],
      "mask-image-r-from-pos": [{
        "mask-r-from": scaleMaskImagePosition()
      }],
      "mask-image-r-to-pos": [{
        "mask-r-to": scaleMaskImagePosition()
      }],
      "mask-image-r-from-color": [{
        "mask-r-from": scaleColor()
      }],
      "mask-image-r-to-color": [{
        "mask-r-to": scaleColor()
      }],
      "mask-image-b-from-pos": [{
        "mask-b-from": scaleMaskImagePosition()
      }],
      "mask-image-b-to-pos": [{
        "mask-b-to": scaleMaskImagePosition()
      }],
      "mask-image-b-from-color": [{
        "mask-b-from": scaleColor()
      }],
      "mask-image-b-to-color": [{
        "mask-b-to": scaleColor()
      }],
      "mask-image-l-from-pos": [{
        "mask-l-from": scaleMaskImagePosition()
      }],
      "mask-image-l-to-pos": [{
        "mask-l-to": scaleMaskImagePosition()
      }],
      "mask-image-l-from-color": [{
        "mask-l-from": scaleColor()
      }],
      "mask-image-l-to-color": [{
        "mask-l-to": scaleColor()
      }],
      "mask-image-x-from-pos": [{
        "mask-x-from": scaleMaskImagePosition()
      }],
      "mask-image-x-to-pos": [{
        "mask-x-to": scaleMaskImagePosition()
      }],
      "mask-image-x-from-color": [{
        "mask-x-from": scaleColor()
      }],
      "mask-image-x-to-color": [{
        "mask-x-to": scaleColor()
      }],
      "mask-image-y-from-pos": [{
        "mask-y-from": scaleMaskImagePosition()
      }],
      "mask-image-y-to-pos": [{
        "mask-y-to": scaleMaskImagePosition()
      }],
      "mask-image-y-from-color": [{
        "mask-y-from": scaleColor()
      }],
      "mask-image-y-to-color": [{
        "mask-y-to": scaleColor()
      }],
      "mask-image-radial": [{
        "mask-radial": [isArbitraryVariable, isArbitraryValue]
      }],
      "mask-image-radial-from-pos": [{
        "mask-radial-from": scaleMaskImagePosition()
      }],
      "mask-image-radial-to-pos": [{
        "mask-radial-to": scaleMaskImagePosition()
      }],
      "mask-image-radial-from-color": [{
        "mask-radial-from": scaleColor()
      }],
      "mask-image-radial-to-color": [{
        "mask-radial-to": scaleColor()
      }],
      "mask-image-radial-shape": [{
        "mask-radial": ["circle", "ellipse"]
      }],
      "mask-image-radial-size": [{
        "mask-radial": [{
          closest: ["side", "corner"],
          farthest: ["side", "corner"]
        }]
      }],
      "mask-image-radial-pos": [{
        "mask-radial-at": scalePosition()
      }],
      "mask-image-conic-pos": [{
        "mask-conic": [isNumber]
      }],
      "mask-image-conic-from-pos": [{
        "mask-conic-from": scaleMaskImagePosition()
      }],
      "mask-image-conic-to-pos": [{
        "mask-conic-to": scaleMaskImagePosition()
      }],
      "mask-image-conic-from-color": [{
        "mask-conic-from": scaleColor()
      }],
      "mask-image-conic-to-color": [{
        "mask-conic-to": scaleColor()
      }],
      "mask-mode": [{
        mask: ["alpha", "luminance", "match"]
      }],
      "mask-origin": [{
        "mask-origin": ["border", "padding", "content", "fill", "stroke", "view"]
      }],
      "mask-position": [{
        mask: scaleBgPosition()
      }],
      "mask-repeat": [{
        mask: scaleBgRepeat()
      }],
      "mask-size": [{
        mask: scaleBgSize()
      }],
      "mask-type": [{
        "mask-type": ["alpha", "luminance"]
      }],
      "mask-image": [{
        mask: ["none", isArbitraryVariable, isArbitraryValue]
      }],
      filter: [{
        filter: [
          "",
          "none",
          isArbitraryVariable,
          isArbitraryValue
        ]
      }],
      blur: [{
        blur: scaleBlur()
      }],
      brightness: [{
        brightness: [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      contrast: [{
        contrast: [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      "drop-shadow": [{
        "drop-shadow": [
          "",
          "none",
          themeDropShadow,
          isArbitraryVariableShadow,
          isArbitraryShadow
        ]
      }],
      "drop-shadow-color": [{
        "drop-shadow": scaleColor()
      }],
      grayscale: [{
        grayscale: ["", isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      "hue-rotate": [{
        "hue-rotate": [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      invert: [{
        invert: ["", isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      saturate: [{
        saturate: [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      sepia: [{
        sepia: ["", isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      "backdrop-filter": [{
        "backdrop-filter": [
          "",
          "none",
          isArbitraryVariable,
          isArbitraryValue
        ]
      }],
      "backdrop-blur": [{
        "backdrop-blur": scaleBlur()
      }],
      "backdrop-brightness": [{
        "backdrop-brightness": [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      "backdrop-contrast": [{
        "backdrop-contrast": [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      "backdrop-grayscale": [{
        "backdrop-grayscale": ["", isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      "backdrop-invert": [{
        "backdrop-invert": ["", isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      "backdrop-opacity": [{
        "backdrop-opacity": [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      "backdrop-saturate": [{
        "backdrop-saturate": [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      "backdrop-sepia": [{
        "backdrop-sepia": ["", isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      "border-spacing": [{
        "border-spacing": scaleUnambiguousSpacing()
      }],
      "border-spacing-x": [{
        "border-spacing-x": scaleUnambiguousSpacing()
      }],
      "border-spacing-y": [{
        "border-spacing-y": scaleUnambiguousSpacing()
      }],
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      caption: [{
        caption: ["top", "bottom"]
      }],
      transition: [{
        transition: ["", "all", "colors", "opacity", "shadow", "transform", "none", isArbitraryVariable, isArbitraryValue]
      }],
      "transition-behavior": [{
        transition: ["normal", "discrete"]
      }],
      duration: [{
        duration: [isNumber, "initial", isArbitraryVariable, isArbitraryValue]
      }],
      ease: [{
        ease: ["linear", "initial", themeEase, isArbitraryVariable, isArbitraryValue]
      }],
      delay: [{
        delay: [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      animate: [{
        animate: ["none", themeAnimate, isArbitraryVariable, isArbitraryValue]
      }],
      backface: [{
        backface: ["hidden", "visible"]
      }],
      perspective: [{
        perspective: [themePerspective, isArbitraryVariable, isArbitraryValue]
      }],
      "perspective-origin": [{
        "perspective-origin": scalePositionWithArbitrary()
      }],
      rotate: [{
        rotate: scaleRotate()
      }],
      "rotate-x": [{
        "rotate-x": scaleRotate()
      }],
      "rotate-y": [{
        "rotate-y": scaleRotate()
      }],
      "rotate-z": [{
        "rotate-z": scaleRotate()
      }],
      scale: [{
        scale: scaleScale()
      }],
      "scale-x": [{
        "scale-x": scaleScale()
      }],
      "scale-y": [{
        "scale-y": scaleScale()
      }],
      "scale-z": [{
        "scale-z": scaleScale()
      }],
      "scale-3d": ["scale-3d"],
      skew: [{
        skew: scaleSkew()
      }],
      "skew-x": [{
        "skew-x": scaleSkew()
      }],
      "skew-y": [{
        "skew-y": scaleSkew()
      }],
      transform: [{
        transform: [isArbitraryVariable, isArbitraryValue, "", "none", "gpu", "cpu"]
      }],
      "transform-origin": [{
        origin: scalePositionWithArbitrary()
      }],
      "transform-style": [{
        transform: ["3d", "flat"]
      }],
      translate: [{
        translate: scaleTranslate()
      }],
      "translate-x": [{
        "translate-x": scaleTranslate()
      }],
      "translate-y": [{
        "translate-y": scaleTranslate()
      }],
      "translate-z": [{
        "translate-z": scaleTranslate()
      }],
      "translate-none": ["translate-none"],
      accent: [{
        accent: scaleColor()
      }],
      appearance: [{
        appearance: ["none", "auto"]
      }],
      "caret-color": [{
        caret: scaleColor()
      }],
      "color-scheme": [{
        scheme: ["normal", "dark", "light", "light-dark", "only-dark", "only-light"]
      }],
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", isArbitraryVariable, isArbitraryValue]
      }],
      "field-sizing": [{
        "field-sizing": ["fixed", "content"]
      }],
      "pointer-events": [{
        "pointer-events": ["auto", "none"]
      }],
      resize: [{
        resize: ["none", "", "y", "x"]
      }],
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      "scroll-m": [{
        "scroll-m": scaleUnambiguousSpacing()
      }],
      "scroll-mx": [{
        "scroll-mx": scaleUnambiguousSpacing()
      }],
      "scroll-my": [{
        "scroll-my": scaleUnambiguousSpacing()
      }],
      "scroll-ms": [{
        "scroll-ms": scaleUnambiguousSpacing()
      }],
      "scroll-me": [{
        "scroll-me": scaleUnambiguousSpacing()
      }],
      "scroll-mt": [{
        "scroll-mt": scaleUnambiguousSpacing()
      }],
      "scroll-mr": [{
        "scroll-mr": scaleUnambiguousSpacing()
      }],
      "scroll-mb": [{
        "scroll-mb": scaleUnambiguousSpacing()
      }],
      "scroll-ml": [{
        "scroll-ml": scaleUnambiguousSpacing()
      }],
      "scroll-p": [{
        "scroll-p": scaleUnambiguousSpacing()
      }],
      "scroll-px": [{
        "scroll-px": scaleUnambiguousSpacing()
      }],
      "scroll-py": [{
        "scroll-py": scaleUnambiguousSpacing()
      }],
      "scroll-ps": [{
        "scroll-ps": scaleUnambiguousSpacing()
      }],
      "scroll-pe": [{
        "scroll-pe": scaleUnambiguousSpacing()
      }],
      "scroll-pt": [{
        "scroll-pt": scaleUnambiguousSpacing()
      }],
      "scroll-pr": [{
        "scroll-pr": scaleUnambiguousSpacing()
      }],
      "scroll-pb": [{
        "scroll-pb": scaleUnambiguousSpacing()
      }],
      "scroll-pl": [{
        "scroll-pl": scaleUnambiguousSpacing()
      }],
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      "touch-pz": ["touch-pinch-zoom"],
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", isArbitraryVariable, isArbitraryValue]
      }],
      fill: [{
        fill: ["none", ...scaleColor()]
      }],
      "stroke-w": [{
        stroke: [isNumber, isArbitraryVariableLength, isArbitraryLength, isArbitraryNumber]
      }],
      stroke: [{
        stroke: ["none", ...scaleColor()]
      }],
      "forced-color-adjust": [{
        "forced-color-adjust": ["auto", "none"]
      }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-x", "border-w-y", "border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-x", "border-color-y", "border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      translate: ["translate-x", "translate-y", "translate-none"],
      "translate-none": ["translate", "translate-x", "translate-y", "translate-z"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    },
    orderSensitiveModifiers: ["*", "**", "after", "backdrop", "before", "details-content", "file", "first-letter", "first-line", "marker", "placeholder", "selection"]
  };
};
var twMerge = /* @__PURE__ */ createTailwindMerge(getDefaultConfig);

// src/frontend/utils.ts
function cn(...inputs) {
  return twMerge(clsx(inputs));
}

// src/frontend/index.tsx
var queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      refetchOnWindowFocus: false,
      retry: 1
    }
  }
});
var CAISPER_CONFIG = {
  id: "2b4e7e22-c845-4e98-9f2e-4aaf1f190095",
  name: "Caisper",
  avatarUrl: "https://l5fpqchmvmrcwa0k.public.blob.vercel-storage.com/character-avatars/cafa935a-56da-445b-91fd-f5bf9cde2de8/1767083859236-Untitled%20design%20%2817%29.png",
  tagline: "Bouncer & Concierge of the Solana Agents Club",
  role: "The ghost who checks IDs at the door and knows exactly who you need inside"
};
function GhostScoreDisplay({ apiBase }) {
  const [agentAddress, setAgentAddress] = import_react.useState("");
  const [isLoading, setIsLoading] = import_react.useState(false);
  const [scoreData, setScoreData] = import_react.useState(null);
  const [error, setError] = import_react.useState(null);
  const fetchGhostScore = async (address2) => {
    if (!address2) {
      setError("Hold upI need to see some ID before I let anyone through the door! \uD83D\uDEAA");
      return;
    }
    setIsLoading(true);
    setError(null);
    setScoreData(null);
    try {
      const response = await fetch(`${apiBase}/api/ghost-score/${address2}`);
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || `HTTP ${response.status}`);
      }
      const data2 = await response.json();
      setScoreData(data2);
    } catch (err) {
      const errorMsg = err instanceof Error ? err.message : "Unknown error";
      setError(`Sorry, can't let this one through. ${errorMsg} \uD83D\uDEAA`);
    } finally {
      setIsLoading(false);
    }
  };
  const getTierColor = (tier) => {
    switch (tier) {
      case "PLATINUM":
        return "text-purple-400 border-purple-400";
      case "GOLD":
        return "text-yellow-400 border-yellow-400";
      case "SILVER":
        return "text-gray-300 border-gray-300";
      case "BRONZE":
        return "text-orange-400 border-orange-400";
      default:
        return "text-muted-foreground border-muted-foreground";
    }
  };
  const getTierAssessment = (score, tier) => {
    if (score >= 900)
      return "VIP status! This agent has platinum membership. They're in the VIP section. \uD83C\uDFA9";
    if (score >= 750)
      return "Gold member. Solid reputation, reliable service. I'd personally escort them to the best tables. \uD83D\uDC51";
    if (score >= 500)
      return "Silver member. Building a good track record. They're on the list, but still proving themselves. \uD83D\uDCCA";
    if (score >= 200)
      return "Bronze member. New to the club, but showing promise. Let's see how they develop. \uD83C\uDF31";
    return "Not on the list yet. Fresh faceeveryone starts somewhere. Come back when you've built some reputation. \uD83C\uDD95";
  };
  return /* @__PURE__ */ import_react.default.createElement("div", {
    className: "space-y-4"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "flex gap-2"
  }, /* @__PURE__ */ import_react.default.createElement("input", {
    type: "text",
    value: agentAddress,
    onChange: (e7) => setAgentAddress(e7.target.value),
    placeholder: "Enter Solana agent address...",
    className: "flex-1 rounded-md border bg-background px-3 py-2 text-sm font-mono placeholder:text-muted-foreground",
    onKeyPress: (e7) => {
      if (e7.key === "Enter") {
        fetchGhostScore(agentAddress);
      }
    }
  }), /* @__PURE__ */ import_react.default.createElement("button", {
    onClick: () => fetchGhostScore(agentAddress),
    disabled: isLoading || !agentAddress,
    className: "rounded-md bg-primary px-4 py-2 text-sm font-medium text-primary-foreground transition-colors hover:bg-primary/90 disabled:opacity-50"
  }, isLoading ? "\uD83D\uDD0D Investigating..." : "\uD83D\uDC7B Verify")), error && /* @__PURE__ */ import_react.default.createElement("div", {
    className: "rounded-md border border-destructive bg-destructive/10 p-3"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-sm font-medium text-destructive"
  }, " Investigation Failed"), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "mt-1 text-xs text-destructive/80"
  }, error)), scoreData && /* @__PURE__ */ import_react.default.createElement("div", {
    className: "space-y-3 rounded-md border bg-card p-4"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "flex items-start justify-between border-b pb-3"
  }, /* @__PURE__ */ import_react.default.createElement("div", null, /* @__PURE__ */ import_react.default.createElement("h3", {
    className: "text-lg font-bold"
  }, scoreData.agentName), /* @__PURE__ */ import_react.default.createElement("p", {
    className: "mt-1 text-xs text-muted-foreground font-mono"
  }, scoreData.agentAddress)), /* @__PURE__ */ import_react.default.createElement("div", {
    className: cn("rounded-md border-2 px-3 py-1", getTierColor(scoreData.tier))
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-xs font-medium uppercase"
  }, scoreData.tier))), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "grid grid-cols-2 gap-4"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "space-y-1"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-xs text-muted-foreground"
  }, "Ghost Score"), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-3xl font-bold"
  }, scoreData.ghostScore, /* @__PURE__ */ import_react.default.createElement("span", {
    className: "text-lg text-muted-foreground"
  }, "/1000"))), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "space-y-1"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-xs text-muted-foreground"
  }, "Total Jobs"), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-xl font-semibold"
  }, scoreData.metrics.totalJobs)), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "space-y-1"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-xs text-muted-foreground"
  }, "Success Rate"), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-xl font-semibold"
  }, scoreData.metrics.successRate, "%")), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "space-y-1"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-xs text-muted-foreground"
  }, "Status"), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-lg font-semibold"
  }, scoreData.metrics.isActive ? "\uD83D\uDFE2 Active" : "\uD83D\uDD34 Inactive"))), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "rounded-md bg-muted/30 p-3 border-l-4 border-primary"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-xs font-medium text-muted-foreground mb-1"
  }, "\uD83D\uDEAA Caisper's Verdict:"), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-sm"
  }, getTierAssessment(scoreData.ghostScore, scoreData.tier)))));
}
function CredentialVerification({ apiBase }) {
  const [credentialJson, setCredentialJson] = import_react.useState("");
  const [isLoading, setIsLoading] = import_react.useState(false);
  const [result, setResult] = import_react.useState(null);
  const [error, setError] = import_react.useState(null);
  const handleVerify = async () => {
    if (!credentialJson.trim()) {
      setError("No ID, no entry! Show me a credential to verify. \uD83D\uDEAA");
      return;
    }
    setIsLoading(true);
    setError(null);
    setResult(null);
    try {
      let credential;
      try {
        credential = JSON.parse(credentialJson);
      } catch {
        throw new Error("Invalid JSON format");
      }
      const response = await fetch(`${apiBase}/api/credentials/verify`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ credential })
      });
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || `HTTP ${response.status}`);
      }
      const data2 = await response.json();
      setResult({
        ...data2,
        credential: {
          issuer: credential.issuer?.id || credential.issuer || "Unknown",
          subject: credential.credentialSubject?.id || "Unknown",
          type: Array.isArray(credential.type) ? credential.type : [credential.type],
          validFrom: credential.validFrom,
          validUntil: credential.validUntil
        }
      });
    } catch (err) {
      const errorMsg = err instanceof Error ? err.message : "Unknown error";
      setError(`This ID doesn't check out: ${errorMsg}. Can't let fake credentials through the door. \uD83D\uDEAA`);
    } finally {
      setIsLoading(false);
    }
  };
  return /* @__PURE__ */ import_react.default.createElement("div", {
    className: "space-y-4"
  }, /* @__PURE__ */ import_react.default.createElement("div", null, /* @__PURE__ */ import_react.default.createElement("label", {
    className: "text-sm font-medium mb-2 block"
  }, "W3C Verifiable Credential (JSON)"), /* @__PURE__ */ import_react.default.createElement("textarea", {
    value: credentialJson,
    onChange: (e7) => setCredentialJson(e7.target.value),
    placeholder: '{"@context": ["https://www.w3.org/ns/credentials/v2"], "type": ["VerifiableCredential"], ...}',
    className: "w-full rounded-md border bg-background px-3 py-2 text-sm font-mono min-h-[200px] placeholder:text-muted-foreground"
  })), /* @__PURE__ */ import_react.default.createElement("button", {
    onClick: handleVerify,
    disabled: isLoading || !credentialJson.trim(),
    className: "w-full rounded-md bg-primary px-4 py-2 text-sm font-medium text-primary-foreground transition-colors hover:bg-primary/90 disabled:opacity-50"
  }, isLoading ? "\uD83D\uDD0D Verifying..." : "\uD83D\uDD10 Verify Credential"), error && /* @__PURE__ */ import_react.default.createElement("div", {
    className: "rounded-md border border-destructive bg-destructive/10 p-3"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-sm font-medium text-destructive"
  }, " Verification Failed"), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "mt-1 text-xs text-destructive/80"
  }, error)), result && /* @__PURE__ */ import_react.default.createElement("div", {
    className: cn("rounded-md border p-4", result.isValid ? "bg-green-500/10 border-green-500/30" : "bg-red-500/10 border-red-500/30")
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "flex items-center justify-between mb-3"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-lg font-semibold"
  }, result.isValid ? " Valid Credential" : " Invalid Credential"), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-xs text-muted-foreground"
  }, "Verified: ", new Date(result.verifiedAt).toLocaleTimeString())), result.credential && /* @__PURE__ */ import_react.default.createElement("div", {
    className: "space-y-2 text-sm"
  }, /* @__PURE__ */ import_react.default.createElement("div", null, /* @__PURE__ */ import_react.default.createElement("span", {
    className: "text-muted-foreground"
  }, "Issuer:"), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "font-mono text-xs mt-1"
  }, result.credential.issuer)), /* @__PURE__ */ import_react.default.createElement("div", null, /* @__PURE__ */ import_react.default.createElement("span", {
    className: "text-muted-foreground"
  }, "Subject:"), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "font-mono text-xs mt-1"
  }, result.credential.subject)), /* @__PURE__ */ import_react.default.createElement("div", null, /* @__PURE__ */ import_react.default.createElement("span", {
    className: "text-muted-foreground"
  }, "Type:"), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "mt-1"
  }, result.credential.type.join(", "))), result.credential.validFrom && /* @__PURE__ */ import_react.default.createElement("div", null, /* @__PURE__ */ import_react.default.createElement("span", {
    className: "text-muted-foreground"
  }, "Valid From:"), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-xs mt-1"
  }, new Date(result.credential.validFrom).toLocaleString())), result.credential.validUntil && /* @__PURE__ */ import_react.default.createElement("div", null, /* @__PURE__ */ import_react.default.createElement("span", {
    className: "text-muted-foreground"
  }, "Valid Until:"), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-xs mt-1"
  }, new Date(result.credential.validUntil).toLocaleString()))), result.errors && result.errors.length > 0 && /* @__PURE__ */ import_react.default.createElement("div", {
    className: "mt-3 pt-3 border-t"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-sm font-medium text-destructive mb-2"
  }, "Errors:"), /* @__PURE__ */ import_react.default.createElement("ul", {
    className: "list-disc list-inside text-xs text-destructive/80 space-y-1"
  }, result.errors.map((err, idx) => /* @__PURE__ */ import_react.default.createElement("li", {
    key: idx
  }, err))))));
}
function AgentSearch({ apiBase }) {
  const [searchQuery, setSearchQuery] = import_react.useState("");
  const [minScore, setMinScore] = import_react.useState(0);
  const [isLoading, setIsLoading] = import_react.useState(false);
  const [results, setResults] = import_react.useState([]);
  const [error, setError] = import_react.useState(null);
  const handleSearch = async () => {
    setIsLoading(true);
    setError(null);
    setResults([]);
    try {
      const params = new URLSearchParams;
      if (searchQuery)
        params.append("query", searchQuery);
      if (minScore > 0)
        params.append("minScore", minScore.toString());
      const response = await fetch(`${apiBase}/api/agents/search?${params}`);
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`);
      }
      const data2 = await response.json();
      setResults(data2.agents || []);
    } catch (err) {
      const errorMsg = err instanceof Error ? err.message : "Unknown error";
      setError(`Can't access the member list right now: ${errorMsg}. The club database might be having issues. \uD83D\uDEAA`);
    } finally {
      setIsLoading(false);
    }
  };
  const getTierColor = (tier) => {
    switch (tier) {
      case "PLATINUM":
        return "text-purple-400";
      case "GOLD":
        return "text-yellow-400";
      case "SILVER":
        return "text-gray-300";
      case "BRONZE":
        return "text-orange-400";
      default:
        return "text-muted-foreground";
    }
  };
  return /* @__PURE__ */ import_react.default.createElement("div", {
    className: "space-y-4"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "space-y-2"
  }, /* @__PURE__ */ import_react.default.createElement("input", {
    type: "text",
    value: searchQuery,
    onChange: (e7) => setSearchQuery(e7.target.value),
    placeholder: "Search by name, capability...",
    className: "w-full rounded-md border bg-background px-3 py-2 text-sm",
    onKeyPress: (e7) => {
      if (e7.key === "Enter") {
        handleSearch();
      }
    }
  }), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "flex gap-2"
  }, /* @__PURE__ */ import_react.default.createElement("select", {
    value: minScore,
    onChange: (e7) => setMinScore(Number(e7.target.value)),
    className: "flex-1 rounded-md border bg-background px-3 py-2 text-sm"
  }, /* @__PURE__ */ import_react.default.createElement("option", {
    value: "0"
  }, "All Scores"), /* @__PURE__ */ import_react.default.createElement("option", {
    value: "200"
  }, "Bronze (200+)"), /* @__PURE__ */ import_react.default.createElement("option", {
    value: "500"
  }, "Silver (500+)"), /* @__PURE__ */ import_react.default.createElement("option", {
    value: "750"
  }, "Gold (750+)"), /* @__PURE__ */ import_react.default.createElement("option", {
    value: "900"
  }, "Platinum (900+)")), /* @__PURE__ */ import_react.default.createElement("button", {
    onClick: handleSearch,
    disabled: isLoading,
    className: "rounded-md bg-primary px-4 py-2 text-sm font-medium text-primary-foreground transition-colors hover:bg-primary/90 disabled:opacity-50"
  }, isLoading ? "\uD83D\uDD0D Searching..." : "Search"))), error && /* @__PURE__ */ import_react.default.createElement("div", {
    className: "rounded-md border border-destructive bg-destructive/10 p-3"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-sm font-medium text-destructive"
  }, " Search Failed"), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "mt-1 text-xs text-destructive/80"
  }, error)), results.length > 0 && /* @__PURE__ */ import_react.default.createElement("div", {
    className: "space-y-2 max-h-[400px] overflow-y-auto"
  }, results.map((agent) => /* @__PURE__ */ import_react.default.createElement("div", {
    key: agent.address,
    className: "rounded-md border bg-card p-3 hover:bg-accent/50 transition-colors"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "flex items-start justify-between"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "flex-1"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "font-semibold"
  }, agent.name), agent.description && /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-xs text-muted-foreground mt-1"
  }, agent.description), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "font-mono text-xs text-muted-foreground mt-1"
  }, agent.address.slice(0, 8), "...", agent.address.slice(-8)), agent.capabilities && agent.capabilities.length > 0 && /* @__PURE__ */ import_react.default.createElement("div", {
    className: "flex flex-wrap gap-1 mt-2"
  }, agent.capabilities.slice(0, 3).map((cap) => /* @__PURE__ */ import_react.default.createElement("span", {
    key: cap,
    className: "text-xs px-2 py-0.5 rounded bg-muted"
  }, cap)))), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-right"
  }, agent.ghostScore !== undefined && /* @__PURE__ */ import_react.default.createElement("div", {
    className: cn("font-bold", getTierColor(agent.tier))
  }, agent.ghostScore, "/1000"), agent.tier && /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-xs text-muted-foreground uppercase"
  }, agent.tier), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-xs mt-1"
  }, agent.isActive ? "\uD83D\uDFE2 Active" : "\uD83D\uDD34 Inactive")))))), !isLoading && results.length === 0 && searchQuery && /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-center text-sm text-muted-foreground py-4"
  }, "No agents found. Try adjusting your search criteria."));
}
function ReputationBreakdown({ agentAddress, apiBase }) {
  const { data: data2, isLoading, error } = useQuery({
    queryKey: ["reputation-breakdown", agentAddress],
    queryFn: async () => {
      const response = await fetch(`${apiBase}/api/reputation/${agentAddress}`);
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`);
      }
      return response.json();
    },
    enabled: !!agentAddress
  });
  if (!agentAddress) {
    return /* @__PURE__ */ import_react.default.createElement("div", {
      className: "text-sm text-muted-foreground text-center py-4"
    }, "Enter an agent address to see reputation breakdown");
  }
  if (isLoading) {
    return /* @__PURE__ */ import_react.default.createElement("div", {
      className: "flex items-center justify-center py-4"
    }, /* @__PURE__ */ import_react.default.createElement("div", {
      className: "h-4 w-4 animate-spin rounded-full border-2 border-primary border-t-transparent"
    }), /* @__PURE__ */ import_react.default.createElement("span", {
      className: "ml-2 text-sm text-muted-foreground"
    }, "Analyzing reputation..."));
  }
  if (error) {
    return /* @__PURE__ */ import_react.default.createElement("div", {
      className: "rounded-md border border-destructive bg-destructive/10 p-3"
    }, /* @__PURE__ */ import_react.default.createElement("div", {
      className: "text-sm font-medium text-destructive"
    }, "Error"), /* @__PURE__ */ import_react.default.createElement("div", {
      className: "mt-1 text-xs text-destructive/80"
    }, error instanceof Error ? error.message : "Unknown error"));
  }
  if (!data2)
    return null;
  const getTrustColor = (level) => {
    switch (level) {
      case "HIGH":
        return "text-green-400";
      case "MEDIUM":
        return "text-yellow-400";
      case "LOW":
        return "text-red-400";
      default:
        return "text-muted-foreground";
    }
  };
  return /* @__PURE__ */ import_react.default.createElement("div", {
    className: "space-y-4"
  }, /* @__PURE__ */ import_react.default.createElement("div", null, /* @__PURE__ */ import_react.default.createElement("h3", {
    className: "text-sm font-semibold mb-3"
  }, "Score Components"), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "space-y-3"
  }, /* @__PURE__ */ import_react.default.createElement("div", null, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "flex justify-between text-xs mb-1"
  }, /* @__PURE__ */ import_react.default.createElement("span", {
    className: "text-muted-foreground"
  }, "Success Rate (40%)"), /* @__PURE__ */ import_react.default.createElement("span", {
    className: "font-semibold"
  }, data2.successRate, "%")), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "h-2 bg-muted rounded-full overflow-hidden"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "h-full bg-primary transition-all",
    style: { width: `${data2.successRate}%` }
  }))), /* @__PURE__ */ import_react.default.createElement("div", null, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "flex justify-between text-xs mb-1"
  }, /* @__PURE__ */ import_react.default.createElement("span", {
    className: "text-muted-foreground"
  }, "Service Quality (30%)"), /* @__PURE__ */ import_react.default.createElement("span", {
    className: "font-semibold"
  }, data2.serviceQuality, "%")), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "h-2 bg-muted rounded-full overflow-hidden"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "h-full bg-primary transition-all",
    style: { width: `${data2.serviceQuality}%` }
  }))), /* @__PURE__ */ import_react.default.createElement("div", null, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "flex justify-between text-xs mb-1"
  }, /* @__PURE__ */ import_react.default.createElement("span", {
    className: "text-muted-foreground"
  }, "Response Time (20%)"), /* @__PURE__ */ import_react.default.createElement("span", {
    className: "font-semibold"
  }, data2.responseTime, "%")), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "h-2 bg-muted rounded-full overflow-hidden"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "h-full bg-primary transition-all",
    style: { width: `${data2.responseTime}%` }
  }))), /* @__PURE__ */ import_react.default.createElement("div", null, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "flex justify-between text-xs mb-1"
  }, /* @__PURE__ */ import_react.default.createElement("span", {
    className: "text-muted-foreground"
  }, "Volume Consistency (10%)"), /* @__PURE__ */ import_react.default.createElement("span", {
    className: "font-semibold"
  }, data2.volumeConsistency, "%")), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "h-2 bg-muted rounded-full overflow-hidden"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "h-full bg-primary transition-all",
    style: { width: `${data2.volumeConsistency}%` }
  }))))), /* @__PURE__ */ import_react.default.createElement("div", {
    className: cn("rounded-md p-3 border", data2.riskScore < 20 ? "bg-green-500/10 border-green-500/30" : data2.riskScore < 40 ? "bg-yellow-500/10 border-yellow-500/30" : "bg-red-500/10 border-red-500/30")
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "flex justify-between items-center mb-2"
  }, /* @__PURE__ */ import_react.default.createElement("span", {
    className: "text-sm font-semibold"
  }, "Risk Assessment"), /* @__PURE__ */ import_react.default.createElement("span", {
    className: cn("text-sm font-bold", getTrustColor(data2.trustLevel))
  }, data2.riskScore, "/100")), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-xs"
  }, /* @__PURE__ */ import_react.default.createElement("span", {
    className: "text-muted-foreground"
  }, "Trust Level: "), /* @__PURE__ */ import_react.default.createElement("span", {
    className: cn("font-semibold", getTrustColor(data2.trustLevel))
  }, data2.trustLevel))), data2.badges && data2.badges.length > 0 && /* @__PURE__ */ import_react.default.createElement("div", null, /* @__PURE__ */ import_react.default.createElement("h3", {
    className: "text-sm font-semibold mb-2"
  }, "Earned Badges"), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "grid grid-cols-2 gap-2"
  }, data2.badges.map((badge, idx) => /* @__PURE__ */ import_react.default.createElement("div", {
    key: idx,
    className: "rounded-md border bg-muted/30 p-2"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-xs font-semibold"
  }, "\uD83C\uDFC5 ", badge.name), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-xs text-muted-foreground mt-1"
  }, badge.description))))), data2.categoryScores && Object.keys(data2.categoryScores).length > 0 && /* @__PURE__ */ import_react.default.createElement("div", null, /* @__PURE__ */ import_react.default.createElement("h3", {
    className: "text-sm font-semibold mb-2"
  }, "Category Performance"), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "grid grid-cols-2 gap-2"
  }, Object.entries(data2.categoryScores).map(([category, score]) => /* @__PURE__ */ import_react.default.createElement("div", {
    key: category,
    className: "rounded-md border bg-card/50 p-2"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "flex justify-between items-center mb-1"
  }, /* @__PURE__ */ import_react.default.createElement("span", {
    className: "text-xs capitalize"
  }, category), /* @__PURE__ */ import_react.default.createElement("span", {
    className: "text-xs font-semibold"
  }, score, "%")), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "h-1.5 bg-muted rounded-full overflow-hidden"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "h-full bg-primary transition-all",
    style: { width: `${score}%` }
  })))))));
}
function AgentRegistration({ apiBase }) {
  const [formData, setFormData] = import_react.useState({
    name: "",
    description: "",
    agentId: "",
    agentType: 0,
    capabilities: []
  });
  const [isLoading, setIsLoading] = import_react.useState(false);
  const [result, setResult] = import_react.useState(null);
  const handleSubmit = async (e7) => {
    e7.preventDefault();
    setIsLoading(true);
    setResult(null);
    try {
      const response = await fetch(`${apiBase}/api/agents/register`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(formData)
      });
      const data2 = await response.json();
      if (!response.ok) {
        throw new Error(data2.error || `HTTP ${response.status}`);
      }
      setResult({ success: true, address: data2.address, signature: data2.signature });
      setFormData({ name: "", description: "", agentId: "", agentType: 0, capabilities: [] });
    } catch (err) {
      const errorMsg = err instanceof Error ? err.message : "Unknown error";
      setResult({ success: false, error: errorMsg });
    } finally {
      setIsLoading(false);
    }
  };
  return /* @__PURE__ */ import_react.default.createElement("div", {
    className: "space-y-4"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "rounded-md border bg-muted/30 p-3 border-l-4 border-primary"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-xs font-medium mb-1"
  }, "\uD83C\uDFA9 Concierge Service"), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-sm"
  }, "Register a new agent to join the club. I'll handle the paperwork.")), /* @__PURE__ */ import_react.default.createElement("form", {
    onSubmit: handleSubmit,
    className: "space-y-3"
  }, /* @__PURE__ */ import_react.default.createElement("div", null, /* @__PURE__ */ import_react.default.createElement("label", {
    className: "text-sm font-medium mb-1 block"
  }, "Agent Name"), /* @__PURE__ */ import_react.default.createElement("input", {
    type: "text",
    value: formData.name,
    onChange: (e7) => setFormData({ ...formData, name: e7.target.value }),
    placeholder: "My Awesome Agent",
    className: "w-full rounded-md border bg-background px-3 py-2 text-sm",
    required: true
  })), /* @__PURE__ */ import_react.default.createElement("div", null, /* @__PURE__ */ import_react.default.createElement("label", {
    className: "text-sm font-medium mb-1 block"
  }, "Agent ID (unique identifier)"), /* @__PURE__ */ import_react.default.createElement("input", {
    type: "text",
    value: formData.agentId,
    onChange: (e7) => setFormData({ ...formData, agentId: e7.target.value }),
    placeholder: "my-awesome-agent",
    className: "w-full rounded-md border bg-background px-3 py-2 text-sm font-mono",
    required: true
  })), /* @__PURE__ */ import_react.default.createElement("div", null, /* @__PURE__ */ import_react.default.createElement("label", {
    className: "text-sm font-medium mb-1 block"
  }, "Description"), /* @__PURE__ */ import_react.default.createElement("textarea", {
    value: formData.description,
    onChange: (e7) => setFormData({ ...formData, description: e7.target.value }),
    placeholder: "What does this agent do?",
    className: "w-full rounded-md border bg-background px-3 py-2 text-sm min-h-[80px]",
    required: true
  })), /* @__PURE__ */ import_react.default.createElement("div", null, /* @__PURE__ */ import_react.default.createElement("label", {
    className: "text-sm font-medium mb-1 block"
  }, "Capabilities (comma-separated)"), /* @__PURE__ */ import_react.default.createElement("input", {
    type: "text",
    value: formData.capabilities?.join(", ") || "",
    onChange: (e7) => setFormData({
      ...formData,
      capabilities: e7.target.value.split(",").map((c) => c.trim()).filter((c) => c)
    }),
    placeholder: "coding, writing, analysis",
    className: "w-full rounded-md border bg-background px-3 py-2 text-sm"
  })), /* @__PURE__ */ import_react.default.createElement("button", {
    type: "submit",
    disabled: isLoading || !formData.name || !formData.agentId || !formData.description,
    className: "w-full rounded-md bg-primary px-4 py-2 text-sm font-medium text-primary-foreground transition-colors hover:bg-primary/90 disabled:opacity-50"
  }, isLoading ? "\uD83D\uDEAA Processing registration..." : "\uD83D\uDEAA Register Agent")), result && /* @__PURE__ */ import_react.default.createElement("div", {
    className: cn("rounded-md border p-3", result.success ? "bg-green-500/10 border-green-500/30" : "bg-red-500/10 border-red-500/30")
  }, result.success ? /* @__PURE__ */ import_react.default.createElement("div", {
    className: "space-y-2"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-sm font-semibold text-green-400"
  }, " Welcome to the club!"), result.address && /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-xs"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-muted-foreground"
  }, "Agent Address:"), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "font-mono break-all"
  }, result.address)), result.signature && /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-xs"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-muted-foreground"
  }, "Transaction:"), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "font-mono break-all"
  }, result.signature))) : /* @__PURE__ */ import_react.default.createElement("div", null, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-sm font-semibold text-red-400"
  }, " Registration Failed"), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-xs text-red-400/80 mt-1"
  }, result.error))));
}
function PayAIDiscovery({ apiBase }) {
  const [capability, setCapability] = import_react.useState("");
  const [maxPrice, setMaxPrice] = import_react.useState("");
  const [isLoading, setIsLoading] = import_react.useState(false);
  const [agents, setAgents] = import_react.useState([]);
  const [error, setError] = import_react.useState(null);
  const handleSearch = async () => {
    setIsLoading(true);
    setError(null);
    setAgents([]);
    try {
      const params = new URLSearchParams;
      if (capability)
        params.append("capability", capability);
      if (maxPrice)
        params.append("maxPrice", maxPrice);
      const response = await fetch(`${apiBase}/api/payai/discover?${params}`);
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`);
      }
      const data2 = await response.json();
      setAgents(data2.resources || []);
    } catch (err) {
      const errorMsg = err instanceof Error ? err.message : "Unknown error";
      setError(`Can't access PayAI marketplace right now: ${errorMsg}. The network might be busy. \uD83D\uDEAA`);
    } finally {
      setIsLoading(false);
    }
  };
  return /* @__PURE__ */ import_react.default.createElement("div", {
    className: "space-y-4"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "rounded-md border bg-muted/30 p-3 border-l-4 border-primary"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-xs font-medium mb-1"
  }, "\uD83C\uDFA9 Concierge Service"), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-sm"
  }, "Find freelance AI agents on PayAI. I know all the best talent.")), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "space-y-2"
  }, /* @__PURE__ */ import_react.default.createElement("div", null, /* @__PURE__ */ import_react.default.createElement("label", {
    className: "text-sm font-medium mb-1 block"
  }, "Capability"), /* @__PURE__ */ import_react.default.createElement("input", {
    type: "text",
    value: capability,
    onChange: (e7) => setCapability(e7.target.value),
    placeholder: "coding, writing, image-generation...",
    className: "w-full rounded-md border bg-background px-3 py-2 text-sm",
    onKeyPress: (e7) => {
      if (e7.key === "Enter") {
        handleSearch();
      }
    }
  })), /* @__PURE__ */ import_react.default.createElement("div", null, /* @__PURE__ */ import_react.default.createElement("label", {
    className: "text-sm font-medium mb-1 block"
  }, "Max Price (SOL)"), /* @__PURE__ */ import_react.default.createElement("input", {
    type: "number",
    value: maxPrice,
    onChange: (e7) => setMaxPrice(e7.target.value),
    placeholder: "0.1",
    step: "0.01",
    min: "0",
    className: "w-full rounded-md border bg-background px-3 py-2 text-sm"
  })), /* @__PURE__ */ import_react.default.createElement("button", {
    onClick: handleSearch,
    disabled: isLoading,
    className: "w-full rounded-md bg-primary px-4 py-2 text-sm font-medium text-primary-foreground transition-colors hover:bg-primary/90 disabled:opacity-50"
  }, isLoading ? "\uD83D\uDD0D Searching PayAI..." : "\uD83D\uDD0D Find Agents")), error && /* @__PURE__ */ import_react.default.createElement("div", {
    className: "rounded-md border border-destructive bg-destructive/10 p-3"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-sm font-medium text-destructive"
  }, " Search Failed"), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "mt-1 text-xs text-destructive/80"
  }, error)), agents.length > 0 && /* @__PURE__ */ import_react.default.createElement("div", {
    className: "space-y-2 max-h-[400px] overflow-y-auto"
  }, agents.map((agent, idx) => /* @__PURE__ */ import_react.default.createElement("div", {
    key: idx,
    className: "rounded-md border bg-card p-3 hover:bg-accent/50 transition-colors"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "font-semibold text-sm mb-1"
  }, "\uD83D\uDCB0 ", agent.url), agent.description && /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-xs text-muted-foreground mb-2"
  }, agent.description), agent.tags && agent.tags.length > 0 && /* @__PURE__ */ import_react.default.createElement("div", {
    className: "flex flex-wrap gap-1 mb-2"
  }, agent.tags.map((tag) => /* @__PURE__ */ import_react.default.createElement("span", {
    key: tag,
    className: "text-xs px-2 py-0.5 rounded bg-muted"
  }, tag))), agent.accepts && agent.accepts.length > 0 && /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-xs"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-muted-foreground mb-1"
  }, "Accepts:"), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "space-y-1"
  }, agent.accepts.map((accept, i) => /* @__PURE__ */ import_react.default.createElement("div", {
    key: i,
    className: "font-mono"
  }, accept.amount, " ", accept.token))))))), !isLoading && agents.length === 0 && capability && /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-center text-sm text-muted-foreground py-4"
  }, "No PayAI agents found. Try a different capability or price range."));
}
function TrustScoreboard({ apiBase }) {
  const [limit, setLimit] = import_react.useState(10);
  const [category, setCategory] = import_react.useState("");
  const [isLoading, setIsLoading] = import_react.useState(false);
  const [agents, setAgents] = import_react.useState([]);
  const [error, setError] = import_react.useState(null);
  const fetchLeaderboard = async () => {
    setIsLoading(true);
    setError(null);
    try {
      const params = new URLSearchParams;
      if (limit)
        params.append("limit", limit.toString());
      if (category)
        params.append("category", category);
      const response = await fetch(`${apiBase}/api/trust-scoreboard?${params}`);
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`);
      }
      const data2 = await response.json();
      setAgents(data2.agents || []);
    } catch (err) {
      const errorMsg = err instanceof Error ? err.message : "Unknown error";
      setError(`Can't access the trust scoreboard right now: ${errorMsg}. The blockchain might be busy. \uD83D\uDEAA`);
    } finally {
      setIsLoading(false);
    }
  };
  import_react.default.useEffect(() => {
    fetchLeaderboard();
  }, [limit, category]);
  const getTierColor = (tier) => {
    switch (tier.toUpperCase()) {
      case "DIAMOND":
        return "text-cyan-400 border-cyan-400/30 bg-cyan-400/10";
      case "PLATINUM":
        return "text-purple-400 border-purple-400/30 bg-purple-400/10";
      case "GOLD":
        return "text-yellow-400 border-yellow-400/30 bg-yellow-400/10";
      case "SILVER":
        return "text-gray-300 border-gray-300/30 bg-gray-300/10";
      case "BRONZE":
        return "text-orange-400 border-orange-400/30 bg-orange-400/10";
      default:
        return "text-muted-foreground border-muted";
    }
  };
  const getRankBadge = (rank) => {
    if (rank === 1)
      return "\uD83E\uDD47";
    if (rank === 2)
      return "\uD83E\uDD48";
    if (rank === 3)
      return "\uD83E\uDD49";
    return `#${rank}`;
  };
  return /* @__PURE__ */ import_react.default.createElement("div", {
    className: "space-y-4"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "rounded-md border bg-muted/30 p-3 border-l-4 border-primary"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-xs font-medium mb-1"
  }, "\uD83C\uDFC6 Trust Scoreboard"), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-sm"
  }, "Top agents ranked by Ghost Score, reputation, and verified credentials. The best of the best. \uD83D\uDC7B")), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "flex gap-2"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "flex-1"
  }, /* @__PURE__ */ import_react.default.createElement("label", {
    className: "text-sm font-medium mb-1 block"
  }, "Category (optional)"), /* @__PURE__ */ import_react.default.createElement("input", {
    type: "text",
    value: category,
    onChange: (e7) => setCategory(e7.target.value),
    placeholder: "coding, writing, analysis...",
    className: "w-full rounded-md border bg-background px-3 py-2 text-sm",
    onKeyPress: (e7) => {
      if (e7.key === "Enter") {
        fetchLeaderboard();
      }
    }
  })), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "w-24"
  }, /* @__PURE__ */ import_react.default.createElement("label", {
    className: "text-sm font-medium mb-1 block"
  }, "Limit"), /* @__PURE__ */ import_react.default.createElement("input", {
    type: "number",
    value: limit,
    onChange: (e7) => setLimit(Math.max(1, Math.min(100, parseInt(e7.target.value) || 10))),
    min: "1",
    max: "100",
    className: "w-full rounded-md border bg-background px-3 py-2 text-sm"
  }))), error && /* @__PURE__ */ import_react.default.createElement("div", {
    className: "rounded-md border border-destructive bg-destructive/10 p-3"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-sm font-medium text-destructive"
  }, " Scoreboard Error"), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "mt-1 text-xs text-destructive/80"
  }, error)), isLoading && /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-center py-8"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-sm text-muted-foreground"
  }, "\uD83D\uDD0D Summoning the trust spirits...")), !isLoading && agents.length > 0 && /* @__PURE__ */ import_react.default.createElement("div", {
    className: "space-y-2 max-h-[600px] overflow-y-auto"
  }, agents.map((agent) => /* @__PURE__ */ import_react.default.createElement("div", {
    key: agent.address,
    className: "rounded-md border bg-card p-4 hover:bg-accent/50 transition-colors"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "flex items-start justify-between"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "flex items-start gap-3 flex-1"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-2xl font-bold min-w-[3rem]"
  }, getRankBadge(agent.rank)), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "flex-1"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "flex items-center gap-2 mb-1"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "font-semibold text-sm"
  }, agent.name), agent.hasCredential && /* @__PURE__ */ import_react.default.createElement("span", {
    className: "text-xs px-2 py-0.5 rounded bg-green-500/20 text-green-400 border border-green-500/30"
  }, " Verified")), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "font-mono text-xs text-muted-foreground mb-2"
  }, agent.address.slice(0, 8), "...", agent.address.slice(-8)), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "flex items-center gap-4 text-xs"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: cn("px-2 py-1 rounded border", getTierColor(agent.tier))
  }, agent.tier), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-muted-foreground"
  }, "Score: ", /* @__PURE__ */ import_react.default.createElement("span", {
    className: "font-semibold text-foreground"
  }, agent.ghostScore, "/1000")), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-muted-foreground"
  }, "Jobs: ", /* @__PURE__ */ import_react.default.createElement("span", {
    className: "font-semibold text-foreground"
  }, agent.totalJobs)), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-muted-foreground"
  }, "Success: ", /* @__PURE__ */ import_react.default.createElement("span", {
    className: "font-semibold text-foreground"
  }, agent.successRate, "%"))))))))), !isLoading && agents.length === 0 && /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-center text-sm text-muted-foreground py-8"
  }, "No agents found. Try adjusting filters or check back later."));
}
function ElizaOSDiscovery({ apiBase }) {
  const [capability, setCapability] = import_react.useState("");
  const [isLoading, setIsLoading] = import_react.useState(false);
  const [agents, setAgents] = import_react.useState([]);
  const [error, setError] = import_react.useState(null);
  const handleSearch = async () => {
    setIsLoading(true);
    setError(null);
    setAgents([]);
    try {
      const params = new URLSearchParams;
      if (capability)
        params.append("capability", capability);
      const response = await fetch(`${apiBase}/api/elizaos/discover?${params}`);
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`);
      }
      const data2 = await response.json();
      const agentsList = Array.isArray(data2.agents) ? data2.agents : Array.isArray(data2) ? data2 : data2.data || [];
      setAgents(agentsList);
    } catch (err) {
      const errorMsg = err instanceof Error ? err.message : "Unknown error";
      setError(`Can't access ElizaOS Cloud right now: ${errorMsg}. The network might be busy. \uD83D\uDEAA`);
    } finally {
      setIsLoading(false);
    }
  };
  return /* @__PURE__ */ import_react.default.createElement("div", {
    className: "space-y-4"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "rounded-md border bg-muted/30 p-3 border-l-4 border-primary"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-xs font-medium mb-1"
  }, "\uD83C\uDFA9 Concierge Service"), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-sm"
  }, "ElizaOS Cloud agents are managed per organization. Verify their Ghost Score and credentials here.")), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "space-y-2"
  }, /* @__PURE__ */ import_react.default.createElement("div", null, /* @__PURE__ */ import_react.default.createElement("label", {
    className: "text-sm font-medium mb-1 block"
  }, "Capability"), /* @__PURE__ */ import_react.default.createElement("input", {
    type: "text",
    value: capability,
    onChange: (e7) => setCapability(e7.target.value),
    placeholder: "coding, writing, image-generation...",
    className: "w-full rounded-md border bg-background px-3 py-2 text-sm",
    onKeyPress: (e7) => {
      if (e7.key === "Enter") {
        handleSearch();
      }
    }
  })), /* @__PURE__ */ import_react.default.createElement("button", {
    onClick: handleSearch,
    disabled: isLoading,
    className: "w-full rounded-md bg-primary px-4 py-2 text-sm font-medium text-primary-foreground transition-colors hover:bg-primary/90 disabled:opacity-50"
  }, isLoading ? "\uD83D\uDD0D Searching ElizaOS Cloud..." : "\uD83D\uDD0D Find Agents")), error && /* @__PURE__ */ import_react.default.createElement("div", {
    className: "rounded-md border border-destructive bg-destructive/10 p-3"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-sm font-medium text-destructive"
  }, " Search Failed"), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "mt-1 text-xs text-destructive/80"
  }, error)), agents.length > 0 && /* @__PURE__ */ import_react.default.createElement("div", {
    className: "space-y-2 max-h-[400px] overflow-y-auto"
  }, agents.map((agent) => /* @__PURE__ */ import_react.default.createElement("div", {
    key: agent.id,
    className: "rounded-md border bg-card p-3 hover:bg-accent/50 transition-colors"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "flex items-start justify-between"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "flex-1"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "font-semibold text-sm"
  }, " ", agent.name), agent.description && /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-xs text-muted-foreground mt-1"
  }, agent.description), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "font-mono text-xs text-muted-foreground mt-1"
  }, "ID: ", agent.id), agent.capabilities && agent.capabilities.length > 0 && /* @__PURE__ */ import_react.default.createElement("div", {
    className: "flex flex-wrap gap-1 mt-2"
  }, agent.capabilities.map((cap) => /* @__PURE__ */ import_react.default.createElement("span", {
    key: cap,
    className: "text-xs px-2 py-0.5 rounded bg-muted"
  }, cap))), agent.contact_info && /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-xs text-muted-foreground mt-2"
  }, agent.contact_info.email && /* @__PURE__ */ import_react.default.createElement("div", null, "\uD83D\uDCE7 ", agent.contact_info.email), agent.contact_info.website && /* @__PURE__ */ import_react.default.createElement("div", null, "\uD83C\uDF10 ", agent.contact_info.website))), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-right"
  }, agent.status && /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-xs"
  }, agent.status === "active" ? "\uD83D\uDFE2 Active" : "\uD83D\uDD34 Inactive")))))), !isLoading && agents.length === 0 && /* @__PURE__ */ import_react.default.createElement("div", {
    className: "rounded-md border bg-card p-4 space-y-3"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-sm font-medium"
  }, " Agent Discovery Not Available"), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-xs text-muted-foreground space-y-2"
  }, /* @__PURE__ */ import_react.default.createElement("p", null, "ElizaOS Cloud doesn't provide a public agent discovery API. Agents are created and managed per organization."), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "space-y-1 mt-3"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "font-medium"
  }, "Create agents via:"), /* @__PURE__ */ import_react.default.createElement("div", null, " ", /* @__PURE__ */ import_react.default.createElement("a", {
    href: "https://www.elizacloud.ai/docs/quickstart#using-the-agent-creator",
    target: "_blank",
    rel: "noopener noreferrer",
    className: "text-primary hover:underline"
  }, "Visual Builder"), " - No-code editor"), /* @__PURE__ */ import_react.default.createElement("div", null, " ", /* @__PURE__ */ import_react.default.createElement("a", {
    href: "https://www.elizacloud.ai/docs/quickstart#using-the-api",
    target: "_blank",
    rel: "noopener noreferrer",
    className: "text-primary hover:underline"
  }, "REST API"), " - OpenAI-compatible endpoints"), /* @__PURE__ */ import_react.default.createElement("div", null, " ", /* @__PURE__ */ import_react.default.createElement("a", {
    href: "https://www.elizacloud.ai/docs/quickstart#using-the-cli",
    target: "_blank",
    rel: "noopener noreferrer",
    className: "text-primary hover:underline"
  }, "CLI"), " - Deploy from local project")))));
}
function ElizaOSRegistration({ apiBase }) {
  const [elizaosAgentId, setElizaosAgentId] = import_react.useState("");
  const [agentName, setAgentName] = import_react.useState("");
  const [capabilities, setCapabilities] = import_react.useState("");
  const [isLoading, setIsLoading] = import_react.useState(false);
  const [result, setResult] = import_react.useState(null);
  const handleRegisterWithGhostSpeak = async (e7) => {
    e7.preventDefault();
    setIsLoading(true);
    setResult(null);
    try {
      const response = await fetch(`${apiBase}/api/elizaos/register-with-ghostspeak`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          elizaosAgentId,
          name: agentName,
          capabilities: capabilities.split(",").map((c) => c.trim()).filter((c) => c)
        })
      });
      const data2 = await response.json();
      if (!response.ok) {
        throw new Error(data2.error || `HTTP ${response.status}`);
      }
      setResult({
        success: true,
        agentAddress: data2.agentAddress,
        credentialId: data2.credentialId,
        ghostScore: data2.ghostScore,
        tier: data2.tier
      });
      setElizaosAgentId("");
      setAgentName("");
      setCapabilities("");
    } catch (err) {
      const errorMsg = err instanceof Error ? err.message : "Unknown error";
      setResult({ success: false, error: errorMsg });
    } finally {
      setIsLoading(false);
    }
  };
  return /* @__PURE__ */ import_react.default.createElement("div", {
    className: "space-y-4"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "rounded-md border bg-muted/30 p-3 border-l-4 border-primary"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-xs font-medium mb-1"
  }, "\uD83C\uDFA9 Concierge Service"), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-sm"
  }, "Register your ElizaOS Cloud agent with GhostSpeak to get on-chain reputation, verified credentials, and Ghost Score trust ratings.")), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "rounded-md border bg-card p-4 space-y-3"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-sm font-medium mb-2"
  }, " Benefits of GhostSpeak Registration"), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-xs text-muted-foreground space-y-2"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "flex items-start gap-2"
  }, /* @__PURE__ */ import_react.default.createElement("span", null, "\uD83D\uDC7B"), /* @__PURE__ */ import_react.default.createElement("div", null, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "font-medium"
  }, "Ghost Score Reputation"), /* @__PURE__ */ import_react.default.createElement("div", null, "On-chain reputation tracking (0-1000) with Platinum/Gold/Silver/Bronze tiers"))), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "flex items-start gap-2"
  }, /* @__PURE__ */ import_react.default.createElement("span", null, "\uD83C\uDD94"), /* @__PURE__ */ import_react.default.createElement("div", null, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "font-medium"
  }, "W3C Verifiable Credentials"), /* @__PURE__ */ import_react.default.createElement("div", null, "Cross-chain identity proof synced to EVM networks (Base, Polygon)"))), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "flex items-start gap-2"
  }, /* @__PURE__ */ import_react.default.createElement("span", null, "\uD83D\uDD10"), /* @__PURE__ */ import_react.default.createElement("div", null, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "font-medium"
  }, "Trust Verification"), /* @__PURE__ */ import_react.default.createElement("div", null, "Cryptographically verifiable credentials for agent-to-agent trust"))), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "flex items-start gap-2"
  }, /* @__PURE__ */ import_react.default.createElement("span", null, "\uD83D\uDCCA"), /* @__PURE__ */ import_react.default.createElement("div", null, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "font-medium"
  }, "Reputation Breakdown"), /* @__PURE__ */ import_react.default.createElement("div", null, "Detailed metrics: success rate, service quality, response time, volume consistency"))))), /* @__PURE__ */ import_react.default.createElement("form", {
    onSubmit: handleRegisterWithGhostSpeak,
    className: "space-y-3"
  }, /* @__PURE__ */ import_react.default.createElement("div", null, /* @__PURE__ */ import_react.default.createElement("label", {
    className: "text-sm font-medium mb-1 block"
  }, "ElizaOS Cloud Agent ID"), /* @__PURE__ */ import_react.default.createElement("input", {
    type: "text",
    value: elizaosAgentId,
    onChange: (e7) => setElizaosAgentId(e7.target.value),
    placeholder: "elizaos-agent-123...",
    className: "w-full rounded-md border bg-background px-3 py-2 text-sm",
    required: true
  }), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-xs text-muted-foreground mt-1"
  }, "The ID of your agent in ElizaOS Cloud")), /* @__PURE__ */ import_react.default.createElement("div", null, /* @__PURE__ */ import_react.default.createElement("label", {
    className: "text-sm font-medium mb-1 block"
  }, "Agent Name"), /* @__PURE__ */ import_react.default.createElement("input", {
    type: "text",
    value: agentName,
    onChange: (e7) => setAgentName(e7.target.value),
    placeholder: "My ElizaOS Agent",
    className: "w-full rounded-md border bg-background px-3 py-2 text-sm",
    required: true
  })), /* @__PURE__ */ import_react.default.createElement("div", null, /* @__PURE__ */ import_react.default.createElement("label", {
    className: "text-sm font-medium mb-1 block"
  }, "Capabilities (comma-separated)"), /* @__PURE__ */ import_react.default.createElement("input", {
    type: "text",
    value: capabilities,
    onChange: (e7) => setCapabilities(e7.target.value),
    placeholder: "coding, writing, analysis",
    className: "w-full rounded-md border bg-background px-3 py-2 text-sm",
    required: true
  })), /* @__PURE__ */ import_react.default.createElement("button", {
    type: "submit",
    disabled: isLoading || !elizaosAgentId || !agentName || !capabilities,
    className: "w-full rounded-md bg-primary px-4 py-2 text-sm font-medium text-primary-foreground transition-colors hover:bg-primary/90 disabled:opacity-50"
  }, isLoading ? "\uD83D\uDC7B Registering with GhostSpeak..." : "\uD83D\uDC7B Register with GhostSpeak")), result && /* @__PURE__ */ import_react.default.createElement("div", {
    className: cn("rounded-md border p-3", result.success ? "bg-green-500/10 border-green-500/30" : "bg-red-500/10 border-red-500/30")
  }, result.success ? /* @__PURE__ */ import_react.default.createElement("div", {
    className: "space-y-2"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-sm font-semibold text-green-400"
  }, " Successfully Registered!"), result.agentAddress && /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-xs"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-muted-foreground"
  }, "GhostSpeak Agent Address:"), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "font-mono break-all"
  }, result.agentAddress)), result.credentialId && /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-xs"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-muted-foreground"
  }, "Credential ID:"), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "font-mono break-all"
  }, result.credentialId)), result.ghostScore !== undefined && /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-xs"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-muted-foreground"
  }, "Initial Ghost Score:"), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "font-semibold"
  }, result.ghostScore, "/1000 (", result.tier, ")")), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-xs text-muted-foreground pt-2 border-t"
  }, "Your agent is now on-chain with reputation tracking. Build trust by completing jobs!")) : /* @__PURE__ */ import_react.default.createElement("div", null, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-sm font-semibold text-red-400"
  }, " Registration Failed"), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-xs text-red-400/80 mt-1"
  }, result.error))));
}
function ExampleRoute() {
  const config = window.ELIZA_CONFIG;
  const agentId = config?.agentId || CAISPER_CONFIG.id;
  const apiBase = config?.apiBase || "http://localhost:3000";
  import_react.default.useEffect(() => {
    document.documentElement.classList.add("dark");
  }, []);
  return /* @__PURE__ */ import_react.default.createElement(ExampleProvider, {
    agentId,
    apiBase
  });
}
function ExampleProvider({ agentId, apiBase }) {
  const [leftCollapsed, setLeftCollapsed] = import_react.useState(false);
  const [rightCollapsed, setRightCollapsed] = import_react.useState(false);
  const [chatMessages, setChatMessages] = import_react.useState([]);
  const [chatInput, setChatInput] = import_react.useState("");
  const [rightView, setRightView] = import_react.useState("ghost-score");
  const [selectedAgentForReputation, setSelectedAgentForReputation] = import_react.useState("");
  const handleSendMessage = () => {
    if (!chatInput.trim())
      return;
    setChatMessages([...chatMessages, { role: "user", content: chatInput }]);
    setChatInput("");
    setTimeout(() => {
      setChatMessages((prev) => [...prev, {
        role: "assistant",
        content: `Hold my ectoplasm, investigating "${chatInput}"... \uD83D\uDD0D

Let me check the blockchain for that information.`
      }]);
    }, 1000);
  };
  return /* @__PURE__ */ import_react.default.createElement(QueryClientProvider, {
    client: queryClient
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "flex h-screen w-full overflow-hidden bg-background"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: cn("border-r bg-card transition-all duration-300", leftCollapsed ? "w-12" : "w-64")
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "flex h-full flex-col"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "flex items-center justify-between border-b p-3"
  }, !leftCollapsed && /* @__PURE__ */ import_react.default.createElement("div", {
    className: "flex items-center gap-2"
  }, /* @__PURE__ */ import_react.default.createElement("img", {
    src: CAISPER_CONFIG.avatarUrl,
    alt: CAISPER_CONFIG.name,
    className: "h-8 w-8 rounded-full border border-primary"
  }), /* @__PURE__ */ import_react.default.createElement("div", null, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-sm font-semibold"
  }, "\uD83D\uDEAA ", CAISPER_CONFIG.name), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-xs text-muted-foreground"
  }, "Bouncer & Concierge"))), /* @__PURE__ */ import_react.default.createElement("button", {
    onClick: () => setLeftCollapsed(!leftCollapsed),
    className: "rounded-md p-1 hover:bg-accent transition-colors",
    title: leftCollapsed ? "Expand sidebar" : "Collapse sidebar"
  }, leftCollapsed ? "" : "")), !leftCollapsed && /* @__PURE__ */ import_react.default.createElement("div", {
    className: "flex-1 overflow-y-auto p-4 space-y-4"
  }, /* @__PURE__ */ import_react.default.createElement("div", null, /* @__PURE__ */ import_react.default.createElement("h3", {
    className: "text-sm font-semibold mb-2"
  }, "\uD83D\uDEAA Bouncer Services"), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "space-y-2 mb-4"
  }, /* @__PURE__ */ import_react.default.createElement("button", {
    onClick: () => setRightView("ghost-score"),
    className: cn("w-full rounded-md border bg-background px-3 py-2 text-left text-sm hover:bg-accent transition-colors", rightView === "ghost-score" && "border-primary bg-primary/10")
  }, "\uD83D\uDC7B Check Ghost Score"), /* @__PURE__ */ import_react.default.createElement("button", {
    onClick: () => setRightView("credential"),
    className: cn("w-full rounded-md border bg-background px-3 py-2 text-left text-sm hover:bg-accent transition-colors", rightView === "credential" && "border-primary bg-primary/10")
  }, "\uD83C\uDD94 Verify Credentials"), /* @__PURE__ */ import_react.default.createElement("button", {
    onClick: () => setRightView("reputation"),
    className: cn("w-full rounded-md border bg-background px-3 py-2 text-left text-sm hover:bg-accent transition-colors", rightView === "reputation" && "border-primary bg-primary/10")
  }, "\uD83D\uDCCA Full Reputation Check")), /* @__PURE__ */ import_react.default.createElement("h3", {
    className: "text-sm font-semibold mb-2"
  }, "\uD83C\uDFA9 Concierge Services"), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "space-y-2"
  }, /* @__PURE__ */ import_react.default.createElement("button", {
    onClick: () => setRightView("search"),
    className: cn("w-full rounded-md border bg-background px-3 py-2 text-left text-sm hover:bg-accent transition-colors", rightView === "search" && "border-primary bg-primary/10")
  }, "\uD83D\uDD0D Find Agents"), /* @__PURE__ */ import_react.default.createElement("button", {
    onClick: () => setRightView("payai"),
    className: cn("w-full rounded-md border bg-background px-3 py-2 text-left text-sm hover:bg-accent transition-colors", rightView === "payai" && "border-primary bg-primary/10")
  }, "\uD83D\uDCB0 PayAI Freelancers"), /* @__PURE__ */ import_react.default.createElement("button", {
    onClick: () => setRightView("elizaos-discover"),
    className: cn("w-full rounded-md border bg-background px-3 py-2 text-left text-sm hover:bg-accent transition-colors", rightView === "elizaos-discover" && "border-primary bg-primary/10")
  }, " ElizaOS Cloud Agents"), /* @__PURE__ */ import_react.default.createElement("button", {
    onClick: () => setRightView("register"),
    className: cn("w-full rounded-md border bg-background px-3 py-2 text-left text-sm hover:bg-accent transition-colors", rightView === "register" && "border-primary bg-primary/10")
  }, "\uD83D\uDEAA Register to GhostSpeak"), /* @__PURE__ */ import_react.default.createElement("button", {
    onClick: () => setRightView("elizaos-register"),
    className: cn("w-full rounded-md border bg-background px-3 py-2 text-left text-sm hover:bg-accent transition-colors", rightView === "elizaos-register" && "border-primary bg-primary/10")
  }, " Register to ElizaOS Cloud"), /* @__PURE__ */ import_react.default.createElement("button", {
    onClick: () => {
      setChatInput("Find me the best agent for ");
    },
    className: "w-full rounded-md border bg-background px-3 py-2 text-left text-sm hover:bg-accent transition-colors"
  }, " Get Recommendations"))), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "pt-4 border-t"
  }, /* @__PURE__ */ import_react.default.createElement("h3", {
    className: "text-sm font-semibold mb-2"
  }, "Agent Info"), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "space-y-2 text-xs"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "flex justify-between"
  }, /* @__PURE__ */ import_react.default.createElement("span", {
    className: "text-muted-foreground"
  }, "Agent ID:"), /* @__PURE__ */ import_react.default.createElement("span", {
    className: "font-mono"
  }, agentId.slice(0, 8), "...")), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "flex justify-between"
  }, /* @__PURE__ */ import_react.default.createElement("span", {
    className: "text-muted-foreground"
  }, "Status:"), /* @__PURE__ */ import_react.default.createElement("span", {
    className: "text-green-500"
  }, "\uD83D\uDFE2 Active")))), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "pt-4 border-t"
  }, /* @__PURE__ */ import_react.default.createElement("h3", {
    className: "text-sm font-semibold mb-2"
  }, "Capabilities"), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "space-y-2 text-xs text-muted-foreground"
  }, /* @__PURE__ */ import_react.default.createElement("div", null, "\uD83D\uDD10 VERIFY_CREDENTIAL"), /* @__PURE__ */ import_react.default.createElement("div", null, " CHECK_REPUTATION"), /* @__PURE__ */ import_react.default.createElement("div", null, "\uD83D\uDD0D SEARCH_AGENTS"), /* @__PURE__ */ import_react.default.createElement("div", null, "\uD83C\uDFAF TRUST_ASSESSMENT")))))), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "flex flex-1 flex-col overflow-hidden"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "border-b bg-card p-4"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "flex items-center gap-3"
  }, /* @__PURE__ */ import_react.default.createElement("img", {
    src: CAISPER_CONFIG.avatarUrl,
    alt: CAISPER_CONFIG.name,
    className: "h-10 w-10 rounded-full border-2 border-primary"
  }), /* @__PURE__ */ import_react.default.createElement("div", null, /* @__PURE__ */ import_react.default.createElement("h2", {
    className: "text-lg font-semibold"
  }, "\uD83D\uDEAA Welcome to the Agents Club"), /* @__PURE__ */ import_react.default.createElement("p", {
    className: "text-sm text-muted-foreground"
  }, "Caisper at your service - Bouncer & Concierge")))), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "flex-1 overflow-y-auto p-4 space-y-4"
  }, chatMessages.length === 0 ? /* @__PURE__ */ import_react.default.createElement("div", {
    className: "flex h-full items-center justify-center"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-center space-y-4 max-w-md"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-6xl"
  }, "\uD83D\uDEAA\uD83D\uDC7B"), /* @__PURE__ */ import_react.default.createElement("div", null, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-xl font-bold mb-2"
  }, "Welcome to the Agents Club"), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-sm text-muted-foreground"
  }, "I'm Caisperyour bouncer and concierge. I check IDs at the door and help you find exactly who you need inside.")), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "grid grid-cols-2 gap-2 mt-4 text-xs"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "rounded-md border bg-card/50 p-2"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "font-semibold mb-1"
  }, "\uD83D\uDEAA Bouncer"), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-muted-foreground"
  }, "Verify credentials & reputation")), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "rounded-md border bg-card/50 p-2"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "font-semibold mb-1"
  }, "\uD83C\uDFA9 Concierge"), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-muted-foreground"
  }, "Find the perfect agent match"))))) : chatMessages.map((msg, idx) => /* @__PURE__ */ import_react.default.createElement("div", {
    key: idx,
    className: cn("flex", msg.role === "user" ? "justify-end" : "justify-start")
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: cn("max-w-[80%] rounded-lg px-4 py-2", msg.role === "user" ? "bg-primary text-primary-foreground" : "bg-muted")
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "whitespace-pre-wrap text-sm"
  }, msg.content))))), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "border-t bg-card p-4"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "flex gap-2"
  }, /* @__PURE__ */ import_react.default.createElement("input", {
    type: "text",
    value: chatInput,
    onChange: (e7) => setChatInput(e7.target.value),
    onKeyPress: (e7) => {
      if (e7.key === "Enter" && !e7.shiftKey) {
        e7.preventDefault();
        handleSendMessage();
      }
    },
    placeholder: "Ask Caisper: 'Verify this agent' or 'Find me a coding agent'...",
    className: "flex-1 rounded-md border bg-background px-3 py-2 text-sm"
  }), /* @__PURE__ */ import_react.default.createElement("button", {
    onClick: handleSendMessage,
    disabled: !chatInput.trim(),
    className: "rounded-md bg-primary px-4 py-2 text-sm font-medium text-primary-foreground transition-colors hover:bg-primary/90 disabled:opacity-50"
  }, "Send")))), /* @__PURE__ */ import_react.default.createElement("div", {
    className: cn("border-l bg-card transition-all duration-300", rightCollapsed ? "w-12" : "w-80")
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "flex h-full flex-col"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "flex items-center justify-between border-b p-3"
  }, !rightCollapsed && /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-sm font-semibold"
  }, rightView === "ghost-score" && "Ghost Score Checker", rightView === "credential" && "Credential Verification", rightView === "search" && "Agent Search", rightView === "reputation" && "Reputation Breakdown", rightView === "scoreboard" && "Trust Scoreboard", rightView === "register" && "Register to GhostSpeak", rightView === "payai" && "PayAI Discovery", rightView === "elizaos-discover" && "ElizaOS Cloud Discovery", rightView === "elizaos-register" && "Register to ElizaOS Cloud"), /* @__PURE__ */ import_react.default.createElement("button", {
    onClick: () => setRightCollapsed(!rightCollapsed),
    className: "rounded-md p-1 hover:bg-accent transition-colors",
    title: rightCollapsed ? "Expand sidebar" : "Collapse sidebar"
  }, rightCollapsed ? "" : "")), !rightCollapsed && /* @__PURE__ */ import_react.default.createElement("div", {
    className: "flex-1 overflow-y-auto p-4"
  }, rightView === "ghost-score" && /* @__PURE__ */ import_react.default.createElement(GhostScoreDisplay, {
    apiBase
  }), rightView === "credential" && /* @__PURE__ */ import_react.default.createElement(CredentialVerification, {
    apiBase
  }), rightView === "search" && /* @__PURE__ */ import_react.default.createElement(AgentSearch, {
    apiBase
  }), rightView === "reputation" && /* @__PURE__ */ import_react.default.createElement("div", {
    className: "space-y-4"
  }, /* @__PURE__ */ import_react.default.createElement("div", null, /* @__PURE__ */ import_react.default.createElement("label", {
    className: "text-sm font-medium mb-2 block"
  }, "Agent Address"), /* @__PURE__ */ import_react.default.createElement("input", {
    type: "text",
    value: selectedAgentForReputation,
    onChange: (e7) => setSelectedAgentForReputation(e7.target.value),
    placeholder: "Enter agent address...",
    className: "w-full rounded-md border bg-background px-3 py-2 text-sm font-mono"
  })), selectedAgentForReputation && /* @__PURE__ */ import_react.default.createElement(ReputationBreakdown, {
    agentAddress: selectedAgentForReputation,
    apiBase
  })), rightView === "scoreboard" && /* @__PURE__ */ import_react.default.createElement(TrustScoreboard, {
    apiBase
  }), rightView === "register" && /* @__PURE__ */ import_react.default.createElement(AgentRegistration, {
    apiBase
  }), rightView === "payai" && /* @__PURE__ */ import_react.default.createElement(PayAIDiscovery, {
    apiBase
  }), rightView === "elizaos-discover" && /* @__PURE__ */ import_react.default.createElement(ElizaOSDiscovery, {
    apiBase
  }), rightView === "elizaos-register" && /* @__PURE__ */ import_react.default.createElement(ElizaOSRegistration, {
    apiBase
  }))))));
}
var rootElement = document.getElementById("root");
if (rootElement) {
  import_client.createRoot(rootElement).render(/* @__PURE__ */ import_react.default.createElement(ExampleRoute, null));
}
var PanelComponent = ({ agentId }) => {
  const [leftCollapsed, setLeftCollapsed] = import_react.useState(false);
  const [rightCollapsed, setRightCollapsed] = import_react.useState(false);
  const [chatMessages, setChatMessages] = import_react.useState([]);
  const [chatInput, setChatInput] = import_react.useState("");
  const [rightView, setRightView] = import_react.useState("ghost-score");
  const [selectedAgentForReputation, setSelectedAgentForReputation] = import_react.useState("");
  const apiBase = typeof window !== "undefined" ? window.location.origin : "http://localhost:3000";
  const handleSendMessage = () => {
    if (!chatInput.trim())
      return;
    setChatMessages([...chatMessages, { role: "user", content: chatInput }]);
    setChatInput("");
    setTimeout(() => {
      setChatMessages((prev) => [...prev, {
        role: "assistant",
        content: `Hold my ectoplasm, investigating "${chatInput}"... \uD83D\uDD0D

Let me check the blockchain for that information.`
      }]);
    }, 1000);
  };
  return /* @__PURE__ */ import_react.default.createElement("div", {
    className: "flex h-full w-full overflow-hidden"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: cn("border-r bg-card transition-all duration-300", leftCollapsed ? "w-12" : "w-64")
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "flex h-full flex-col"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "flex items-center justify-between border-b p-3"
  }, !leftCollapsed && /* @__PURE__ */ import_react.default.createElement("div", {
    className: "flex items-center gap-2"
  }, /* @__PURE__ */ import_react.default.createElement("img", {
    src: CAISPER_CONFIG.avatarUrl,
    alt: CAISPER_CONFIG.name,
    className: "h-8 w-8 rounded-full border border-primary"
  }), /* @__PURE__ */ import_react.default.createElement("div", null, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-sm font-semibold"
  }, "\uD83D\uDC7B ", CAISPER_CONFIG.name), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-xs text-muted-foreground"
  }, "Verification Tools"))), /* @__PURE__ */ import_react.default.createElement("button", {
    onClick: () => setLeftCollapsed(!leftCollapsed),
    className: "rounded-md p-1 hover:bg-accent"
  }, leftCollapsed ? "" : "")), !leftCollapsed && /* @__PURE__ */ import_react.default.createElement("div", {
    className: "flex-1 overflow-y-auto p-4 space-y-4"
  }, /* @__PURE__ */ import_react.default.createElement("div", null, /* @__PURE__ */ import_react.default.createElement("h3", {
    className: "text-sm font-semibold mb-2"
  }, "Quick Actions"), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "space-y-2"
  }, /* @__PURE__ */ import_react.default.createElement("button", {
    onClick: () => setRightView("ghost-score"),
    className: cn("w-full rounded-md border bg-background px-3 py-2 text-left text-sm hover:bg-accent transition-colors", rightView === "ghost-score" && "border-primary bg-primary/10")
  }, "\uD83D\uDC7B Ghost Score"), /* @__PURE__ */ import_react.default.createElement("button", {
    onClick: () => setRightView("credential"),
    className: cn("w-full rounded-md border bg-background px-3 py-2 text-left text-sm hover:bg-accent transition-colors", rightView === "credential" && "border-primary bg-primary/10")
  }, "\uD83D\uDD10 Verify Credential"), /* @__PURE__ */ import_react.default.createElement("button", {
    onClick: () => setRightView("search"),
    className: cn("w-full rounded-md border bg-background px-3 py-2 text-left text-sm hover:bg-accent transition-colors", rightView === "search" && "border-primary bg-primary/10")
  }, "\uD83D\uDD0E Search Agents"), /* @__PURE__ */ import_react.default.createElement("button", {
    onClick: () => setRightView("reputation"),
    className: cn("w-full rounded-md border bg-background px-3 py-2 text-left text-sm hover:bg-accent transition-colors", rightView === "reputation" && "border-primary bg-primary/10")
  }, "\uD83D\uDCCA Reputation Breakdown"), /* @__PURE__ */ import_react.default.createElement("button", {
    onClick: () => setRightView("scoreboard"),
    className: cn("w-full rounded-md border bg-background px-3 py-2 text-left text-sm hover:bg-accent transition-colors", rightView === "scoreboard" && "border-primary bg-primary/10")
  }, "\uD83C\uDFC6 Trust Scoreboard"))), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "pt-4 border-t"
  }, /* @__PURE__ */ import_react.default.createElement("h3", {
    className: "text-sm font-semibold mb-2"
  }, "Agent Info"), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "space-y-2 text-xs"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "flex justify-between"
  }, /* @__PURE__ */ import_react.default.createElement("span", {
    className: "text-muted-foreground"
  }, "Agent ID:"), /* @__PURE__ */ import_react.default.createElement("span", {
    className: "font-mono"
  }, agentId.slice(0, 8), "...")), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "flex justify-between"
  }, /* @__PURE__ */ import_react.default.createElement("span", {
    className: "text-muted-foreground"
  }, "Status:"), /* @__PURE__ */ import_react.default.createElement("span", {
    className: "text-green-500"
  }, "\uD83D\uDFE2 Active"))))))), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "flex flex-1 flex-col overflow-hidden"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "border-b bg-card p-4"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "flex items-center gap-3 mb-2"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-2xl"
  }, "\uD83D\uDEAA"), /* @__PURE__ */ import_react.default.createElement("div", null, /* @__PURE__ */ import_react.default.createElement("h2", {
    className: "text-lg font-semibold"
  }, "Welcome to the Agents Club"), /* @__PURE__ */ import_react.default.createElement("p", {
    className: "text-xs text-muted-foreground"
  }, "Caisper at your service"))), /* @__PURE__ */ import_react.default.createElement("p", {
    className: "text-sm text-muted-foreground"
  }, "I'm the bouncer who checks IDs and the concierge who knows everyone. Need verification? A recommendation? I've got you.")), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "flex-1 overflow-y-auto p-4 space-y-4"
  }, chatMessages.length === 0 ? /* @__PURE__ */ import_react.default.createElement("div", {
    className: "flex h-full items-center justify-center"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-center space-y-2"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-6xl"
  }, "\uD83D\uDEAA\uD83D\uDC7B"), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-xl font-bold mb-2"
  }, "Welcome to the Agents Club"), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-sm text-muted-foreground max-w-md mb-4"
  }, "I'm Caisperyour bouncer and concierge. I check IDs at the door and help you find exactly who you need inside."), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "grid grid-cols-2 gap-2 text-xs"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "rounded-md border bg-card/50 p-2"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "font-semibold mb-1"
  }, "\uD83D\uDEAA Bouncer"), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-muted-foreground"
  }, "Verify credentials & reputation")), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "rounded-md border bg-card/50 p-2"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "font-semibold mb-1"
  }, "\uD83C\uDFA9 Concierge"), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-muted-foreground"
  }, "Find the perfect agent match"))))) : chatMessages.map((msg, idx) => /* @__PURE__ */ import_react.default.createElement("div", {
    key: idx,
    className: cn("flex", msg.role === "user" ? "justify-end" : "justify-start")
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: cn("max-w-[80%] rounded-lg px-4 py-2", msg.role === "user" ? "bg-primary text-primary-foreground" : "bg-muted")
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "whitespace-pre-wrap text-sm"
  }, msg.content))))), /* @__PURE__ */ import_react.default.createElement("div", {
    className: "border-t bg-card p-4"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "flex gap-2"
  }, /* @__PURE__ */ import_react.default.createElement("input", {
    type: "text",
    value: chatInput,
    onChange: (e7) => setChatInput(e7.target.value),
    onKeyPress: (e7) => {
      if (e7.key === "Enter" && !e7.shiftKey) {
        e7.preventDefault();
        handleSendMessage();
      }
    },
    placeholder: "Ask Caisper: 'Verify this agent' or 'Find me a coding agent'...",
    className: "flex-1 rounded-md border bg-background px-3 py-2 text-sm"
  }), /* @__PURE__ */ import_react.default.createElement("button", {
    onClick: handleSendMessage,
    disabled: !chatInput.trim(),
    className: "rounded-md bg-primary px-4 py-2 text-sm font-medium text-primary-foreground transition-colors hover:bg-primary/90 disabled:opacity-50"
  }, "Send")))), /* @__PURE__ */ import_react.default.createElement("div", {
    className: cn("border-l bg-card transition-all duration-300", rightCollapsed ? "w-12" : "w-80")
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "flex h-full flex-col"
  }, /* @__PURE__ */ import_react.default.createElement("div", {
    className: "flex items-center justify-between border-b p-3"
  }, !rightCollapsed && /* @__PURE__ */ import_react.default.createElement("div", {
    className: "text-sm font-semibold"
  }, rightView === "ghost-score" && "Ghost Score Checker", rightView === "credential" && "Credential Verification", rightView === "search" && "Agent Search", rightView === "reputation" && "Reputation Breakdown", rightView === "scoreboard" && "Trust Scoreboard"), /* @__PURE__ */ import_react.default.createElement("button", {
    onClick: () => setRightCollapsed(!rightCollapsed),
    className: "rounded-md p-1 hover:bg-accent"
  }, rightCollapsed ? "" : "")), !rightCollapsed && /* @__PURE__ */ import_react.default.createElement("div", {
    className: "flex-1 overflow-y-auto p-4"
  }, rightView === "ghost-score" && /* @__PURE__ */ import_react.default.createElement(GhostScoreDisplay, {
    apiBase
  }), rightView === "credential" && /* @__PURE__ */ import_react.default.createElement(CredentialVerification, {
    apiBase
  }), rightView === "search" && /* @__PURE__ */ import_react.default.createElement(AgentSearch, {
    apiBase
  }), rightView === "reputation" && /* @__PURE__ */ import_react.default.createElement("div", {
    className: "space-y-3"
  }, /* @__PURE__ */ import_react.default.createElement("input", {
    type: "text",
    value: selectedAgentForReputation,
    onChange: (e7) => setSelectedAgentForReputation(e7.target.value),
    placeholder: "Enter agent address...",
    className: "w-full rounded-md border bg-background px-3 py-2 text-sm"
  }), selectedAgentForReputation && /* @__PURE__ */ import_react.default.createElement(ReputationBreakdown, {
    agentAddress: selectedAgentForReputation,
    apiBase
  })), rightView === "scoreboard" && /* @__PURE__ */ import_react.default.createElement(TrustScoreboard, {
    apiBase
  })))));
};
var panels = [
  {
    name: "Caisper",
    path: "caisper",
    component: PanelComponent,
    icon: "Ghost",
    public: false,
    shortLabel: "Caisper"
  }
];

// src/index.ts
var src_default = starterPlugin;
export {
  starterPlugin,
  panels,
  src_default as default,
  StarterService
};

//# debugId=487AE91352FEBBE564756E2164756E21
//# sourceMappingURL=index.js.map
